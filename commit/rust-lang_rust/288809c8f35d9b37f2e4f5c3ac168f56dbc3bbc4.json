{"sha": "288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ODgwOWM4ZjM1ZDliMzdmMmU0ZjVjM2FjMTY4ZjU2ZGJjM2JiYzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-16T03:22:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-16T03:22:21Z"}, "message": "Auto merge of #23682 - tamird:DRY-is-empty, r=alexcrichton\n\nr? @alexcrichton", "tree": {"sha": "2606f4c9c39c215161feb41a74348d7e07d79c1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2606f4c9c39c215161feb41a74348d7e07d79c1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "html_url": "https://github.com/rust-lang/rust/commit/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e40449e0d545561c73a9b9b324b5971b533a87b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40449e0d545561c73a9b9b324b5971b533a87b7", "html_url": "https://github.com/rust-lang/rust/commit/e40449e0d545561c73a9b9b324b5971b533a87b7"}, {"sha": "c55ae1dc3094912c935fb95cf915841af0259305", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55ae1dc3094912c935fb95cf915841af0259305", "html_url": "https://github.com/rust-lang/rust/commit/c55ae1dc3094912c935fb95cf915841af0259305"}], "stats": {"total": 521, "additions": 262, "deletions": 259}, "files": [{"sha": "d014512666f90dd3156fbbd089cda7329da56d98", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -368,7 +368,7 @@ pub fn make_metrics_test_closure(config: &Config, testfile: &Path) -> test::Test\n fn extract_gdb_version(full_version_line: Option<String>) -> Option<String> {\n     match full_version_line {\n         Some(ref full_version_line)\n-          if full_version_line.trim().len() > 0 => {\n+          if !full_version_line.trim().is_empty() => {\n             let full_version_line = full_version_line.trim();\n \n             // used to be a regex \"(^|[^0-9])([0-9]\\.[0-9])([^0-9]|$)\"\n@@ -408,7 +408,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n \n     match full_version_line {\n         Some(ref full_version_line)\n-          if full_version_line.trim().len() > 0 => {\n+          if !full_version_line.trim().is_empty() => {\n             let full_version_line = full_version_line.trim();\n \n             for (pos, l) in full_version_line.char_indices() {\n@@ -426,7 +426,7 @@ fn extract_lldb_version(full_version_line: Option<String>) -> Option<String> {\n                 let vers = full_version_line[pos + 5..].chars().take_while(|c| {\n                     c.is_digit(10)\n                 }).collect::<String>();\n-                if vers.len() > 0 { return Some(vers) }\n+                if !vers.is_empty() { return Some(vers) }\n             }\n             println!(\"Could not extract LLDB version from line '{}'\",\n                      full_version_line);"}, {"sha": "8ae3639318291a723692c76bf675785458784401", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -864,7 +864,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                 }\n                 first = false;\n             }\n-            if !failed && rest.len() == 0 {\n+            if !failed && rest.is_empty() {\n                 i += 1;\n             }\n             if i == num_check_lines {\n@@ -1662,7 +1662,7 @@ fn _arm_push_aux_shared_library(config: &Config, testfile: &Path) {\n // codegen tests (vs. clang)\n \n fn append_suffix_to_stem(p: &Path, suffix: &str) -> PathBuf {\n-    if suffix.len() == 0 {\n+    if suffix.is_empty() {\n         p.to_path_buf()\n     } else {\n         let mut stem = p.file_stem().unwrap().to_os_string();"}, {"sha": "0ed23dae9b55918cd17d225d5d5e7ab63ecad679", "filename": "src/doc/reference.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -3788,7 +3788,7 @@ its type parameters are types:\n \n ```ignore\n fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> Vec<B> {\n-    if xs.len() == 0 {\n+    if xs.is_empty() {\n        return vec![];\n     }\n     let first: B = f(xs[0].clone());"}, {"sha": "859d5ea99bf506876e8c24673bb4d816fe035092", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -692,7 +692,7 @@ mod stack {\n                         // We've reached the root, so no matter what, we're done. We manually\n                         // access the root via the tree itself to avoid creating any dangling\n                         // pointers.\n-                        if self.map.root.len() == 0 && !self.map.root.is_leaf() {\n+                        if self.map.root.is_empty() && !self.map.root.is_leaf() {\n                             // We've emptied out the root, so make its only child the new root.\n                             // If it's a leaf, we just let it become empty.\n                             self.map.depth -= 1;"}, {"sha": "a480335c946939d8ee6f15dd678d9d44fe3805b5", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -585,6 +585,9 @@ impl <K, V> Node<K, V> {\n         self._len\n     }\n \n+    /// Does the node not contain any key-value pairs\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n     /// How many key-value pairs the node can fit\n     pub fn capacity(&self) -> usize {\n         self._capacity\n@@ -1097,7 +1100,7 @@ impl<K, V> Node<K, V> {\n     /// When a node has no keys or values and only a single edge, extract that edge.\n     pub fn hoist_lone_child(&mut self) {\n         // Necessary for correctness, but in a private module\n-        debug_assert!(self.len() == 0);\n+        debug_assert!(self.is_empty());\n         debug_assert!(!self.is_leaf());\n \n         unsafe {\n@@ -1225,7 +1228,7 @@ impl<K, V> Node<K, V> {\n     /// because we have one too many, and our parent now has one too few\n     fn split(&mut self) -> (K, V, Node<K, V>) {\n         // Necessary for correctness, but in a private function\n-        debug_assert!(self.len() > 0);\n+        debug_assert!(!self.is_empty());\n \n         let mut right = if self.is_leaf() {\n             Node::new_leaf(self.capacity())"}, {"sha": "740fa3eb19e86db086df0d081e17c7e3171c88bc", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -227,7 +227,7 @@ impl CharExt for char {\n #[inline]\n pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n-    if code < MAX_ONE_B && dst.len() >= 1 {\n+    if code < MAX_ONE_B && !dst.is_empty() {\n         dst[0] = code as u8;\n         Some(1)\n     } else if code < MAX_TWO_B && dst.len() >= 2 {\n@@ -258,7 +258,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n #[inline]\n pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n-    if (ch & 0xFFFF) == ch  && dst.len() >= 1 {\n+    if (ch & 0xFFFF) == ch && !dst.is_empty() {\n         // The BMP falls through (assuming non-surrogate, as it should)\n         dst[0] = ch as u16;\n         Some(1)"}, {"sha": "4b1742a43482a216772721537c07189b952dc4bb", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -204,7 +204,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn first(&self) -> Option<&T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n+        if self.is_empty() { None } else { Some(&self[0]) }\n     }\n \n     #[inline]\n@@ -217,7 +217,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn last(&self) -> Option<&T> {\n-        if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+        if self.is_empty() { None } else { Some(&self[self.len() - 1]) }\n     }\n \n     #[inline]\n@@ -296,7 +296,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn first_mut(&mut self) -> Option<&mut T> {\n-        if self.len() == 0 { None } else { Some(&mut self[0]) }\n+        if self.is_empty() { None } else { Some(&mut self[0]) }\n     }\n \n     #[inline]\n@@ -1306,7 +1306,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let chunksz = cmp::min(self.v.len(), self.size);\n@@ -1318,7 +1318,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             (0, Some(0))\n         } else {\n             let n = self.v.len() / self.size;\n@@ -1333,7 +1333,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let remainder = self.v.len() % self.size;\n@@ -1384,7 +1384,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n@@ -1397,7 +1397,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             (0, Some(0))\n         } else {\n             let n = self.v.len() / self.chunk_size;\n@@ -1412,7 +1412,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n+        if self.v.is_empty() {\n             None\n         } else {\n             let remainder = self.v.len() % self.chunk_size;"}, {"sha": "2d6ef39361e8ad5011f67525f0ae4f5bb20ff40b", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -1119,7 +1119,7 @@ enum OldSearcher {\n impl OldSearcher {\n     #[allow(dead_code)]\n     fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher {\n-        if needle.len() == 0 {\n+        if needle.is_empty() {\n             // Handle specially\n             unimplemented!()\n         // FIXME: Tune this."}, {"sha": "9a96612195cf8f01c02e347203fc16ae611880ad", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -457,7 +457,7 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n {\n     if m.state.done() {\n         SearchStep::Done\n-    } else if m.needle.len() == 0 && m.start <= m.end {\n+    } else if m.needle.is_empty() && m.start <= m.end {\n         // Case for needle == \"\"\n         if let State::Reject(a, b) = m.state.take() {\n             SearchStep::Reject(a, b)"}, {"sha": "fa2ae79688d72a89d429601e241a221fe960e22b", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -371,7 +371,7 @@ impl<'a> Parser<'a> {\n             None => {\n                 let tmp = self.cur.clone();\n                 match self.word() {\n-                    word if word.len() > 0 => {\n+                    word if !word.is_empty() => {\n                         if self.consume('$') {\n                             CountIsName(word)\n                         } else {\n@@ -463,7 +463,7 @@ mod tests {\n     fn musterr(s: &str) {\n         let mut p = Parser::new(s);\n         p.next();\n-        assert!(p.errors.len() != 0);\n+        assert!(!p.errors.is_empty());\n     }\n \n     #[test]"}, {"sha": "02c4a2339966f9352379519bc5f91898cbf8ee20", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -804,7 +804,7 @@ fn format_option(opt: &OptGroup) -> String {\n     }\n \n     // Use short_name is possible, but fallback to long_name.\n-    if opt.short_name.len() > 0 {\n+    if !opt.short_name.is_empty() {\n         line.push('-');\n         line.push_str(&opt.short_name[..]);\n     } else {"}, {"sha": "9ea680c7efe7643c8bab6a4717333931bb3d49bd", "filename": "src/liblog/directive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fliblog%2Fdirective.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Fliblog%2Fdirective.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fdirective.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -45,7 +45,7 @@ pub fn parse_logging_spec(spec: &str) -> (Vec<LogDirective>, Option<String>) {\n         return (dirs, None);\n     }\n     mods.map(|m| { for s in m.split(',') {\n-        if s.len() == 0 { continue }\n+        if s.is_empty() { continue }\n         let mut parts = s.split('=');\n         let (log_level, name) = match (parts.next(), parts.next().map(|s| s.trim()), parts.next()) {\n             (Some(part0), None, None) => {"}, {"sha": "802c5815398f2c4398c25b24dd50d8594c491177", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -80,7 +80,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n             (None, Some(sess)) => sess.err(s),\n         }\n     };\n-    if s.len() == 0 {\n+    if s.is_empty() {\n         say(\"crate name must not be empty\");\n     }\n     for c in s.chars() {"}, {"sha": "6b3bde409f540091d82718b8be3f477b132891ec", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -767,7 +767,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n                         get_type(cdata, field_ty.id.node, tcx).ty\n                     })\n                     .collect();\n-                let arg_names = if arg_names.len() == 0 { None } else { Some(arg_names) };\n+                let arg_names = if arg_names.is_empty() { None } else { Some(arg_names) };\n \n                 (None, arg_tys, arg_names)\n             }\n@@ -1383,7 +1383,7 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n \n     debug!(\"found dylib deps: {}\", formats.as_str_slice());\n     for spec in formats.as_str_slice().split(',') {\n-        if spec.len() == 0 { continue }\n+        if spec.is_empty() { continue }\n         let cnum = spec.split(':').nth(0).unwrap();\n         let link = spec.split(':').nth(1).unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();"}, {"sha": "29270bd6c624bac0aa02705a1526f09742da3be3", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -469,7 +469,7 @@ fn each_auxiliary_node_id<F>(item: &ast::Item, callback: F) -> bool where\n         ast::ItemStruct(ref struct_def, _) => {\n             // If this is a newtype struct, return the constructor.\n             match struct_def.ctor_id {\n-                Some(ctor_id) if struct_def.fields.len() > 0 &&\n+                Some(ctor_id) if !struct_def.fields.is_empty() &&\n                         struct_def.fields[0].node.kind.is_unnamed() => {\n                     continue_ = callback(ctor_id);\n                 }\n@@ -1751,7 +1751,7 @@ fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for filemap in &codemap.files.borrow()[..] {\n \n-        if filemap.lines.borrow().len() == 0 || filemap.is_imported() {\n+        if filemap.lines.borrow().is_empty() || filemap.is_imported() {\n             // No need to export empty filemaps, as they can't contain spans\n             // that need translation.\n             // Also no need to re-export imported filemaps, as any downstream"}, {"sha": "398e4cd33b9434fb7b148f2a66bdbe5789a399ac", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -307,13 +307,13 @@ impl<'a> Context<'a> {\n     }\n \n     pub fn report_load_errs(&mut self) {\n-        let message = if self.rejected_via_hash.len() > 0 {\n+        let message = if !self.rejected_via_hash.is_empty() {\n             format!(\"found possibly newer version of crate `{}`\",\n                     self.ident)\n-        } else if self.rejected_via_triple.len() > 0 {\n+        } else if !self.rejected_via_triple.is_empty() {\n             format!(\"couldn't find crate `{}` with expected target triple {}\",\n                     self.ident, self.triple)\n-        } else if self.rejected_via_kind.len() > 0 {\n+        } else if !self.rejected_via_kind.is_empty() {\n             format!(\"found staticlib `{}` instead of rlib or dylib\", self.ident)\n         } else {\n             format!(\"can't find crate for `{}`\", self.ident)\n@@ -325,15 +325,15 @@ impl<'a> Context<'a> {\n         };\n         self.sess.span_err(self.span, &message[..]);\n \n-        if self.rejected_via_triple.len() > 0 {\n+        if !self.rejected_via_triple.is_empty() {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     &format!(\"crate `{}`, path #{}, triple {}: {}\",\n                             self.ident, i+1, got, path.display()));\n             }\n         }\n-        if self.rejected_via_hash.len() > 0 {\n+        if !self.rejected_via_hash.is_empty() {\n             self.sess.span_note(self.span, \"perhaps this crate needs \\\n                                             to be recompiled?\");\n             let mismatches = self.rejected_via_hash.iter();\n@@ -353,7 +353,7 @@ impl<'a> Context<'a> {\n                 }\n             }\n         }\n-        if self.rejected_via_kind.len() > 0 {\n+        if !self.rejected_via_kind.is_empty() {\n             self.sess.fileline_help(self.span, \"please recompile this crate using \\\n                                             --crate-type lib\");\n             let mismatches = self.rejected_via_kind.iter();\n@@ -517,7 +517,7 @@ impl<'a> Context<'a> {\n             //                library's metadata sections. In theory we should\n             //                read both, but reading dylib metadata is quite\n             //                slow.\n-            if m.len() == 0 {\n+            if m.is_empty() {\n                 return None\n             } else if m.len() == 1 {\n                 return Some(m.into_iter().next().unwrap())"}, {"sha": "912854a6d7dfbb7470ece68ce8f483da1eefdc0c", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -239,7 +239,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n                     if let Some(DefLocal(_)) = def {\n                         if ty::enum_variants(cx.tcx, def_id).iter().any(|variant|\n                             token::get_name(variant.name) == token::get_name(ident.node.name)\n-                                && variant.args.len() == 0\n+                                && variant.args.is_empty()\n                         ) {\n                             span_warn!(cx.tcx.sess, p.span, E0170,\n                                 \"pattern binding `{}` is named the same as one \\\n@@ -636,19 +636,19 @@ fn is_useful(cx: &MatchCheckCtxt,\n              -> Usefulness {\n     let &Matrix(ref rows) = matrix;\n     debug!(\"{:?}\", matrix);\n-    if rows.len() == 0 {\n+    if rows.is_empty() {\n         return match witness {\n             ConstructWitness => UsefulWithWitness(vec!()),\n             LeaveOutWitness => Useful\n         };\n     }\n-    if rows[0].len() == 0 {\n+    if rows[0].is_empty() {\n         return NotUseful;\n     }\n     assert!(rows.iter().all(|r| r.len() == v.len()));\n     let real_pat = match rows.iter().find(|r| (*r)[0].id != DUMMY_NODE_ID) {\n         Some(r) => raw_pat(r[0]),\n-        None if v.len() == 0 => return NotUseful,\n+        None if v.is_empty() => return NotUseful,\n         None => v[0]\n     };\n     let left_ty = if real_pat.id == DUMMY_NODE_ID {"}, {"sha": "2befbf9924577dd7a61905074daa235922e2a2f6", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -182,7 +182,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn mark_live_symbols(&mut self) {\n         let mut scanned = HashSet::new();\n-        while self.worklist.len() > 0 {\n+        while !self.worklist.is_empty() {\n             let id = self.worklist.pop().unwrap();\n             if scanned.contains(&id) {\n                 continue"}, {"sha": "3dbbcce27b6eac3382a6dce15767ab790dee0a0f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -966,7 +966,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n     fn pick_lifetime(&self,\n                      region_names: &HashSet<ast::Name>)\n                      -> (ast::Lifetime, FreshOrKept) {\n-        if region_names.len() > 0 {\n+        if !region_names.is_empty() {\n             // It's not necessary to convert the set of region names to a\n             // vector of string and then sort them. However, it makes the\n             // choice of lifetime name deterministic and thus easier to test.\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                             let lifetimes =\n                                 path.segments.last().unwrap().parameters.lifetimes();\n                             let mut insert = Vec::new();\n-                            if lifetimes.len() == 0 {\n+                            if lifetimes.is_empty() {\n                                 let anon = self.cur_anon.get();\n                                 for (i, a) in (anon..anon+expected).enumerate() {\n                                     if anon_nums.contains(&a) {\n@@ -1361,7 +1361,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n \n             ast::AngleBracketedParameters(ref data) => {\n                 let mut new_lts = Vec::new();\n-                if data.lifetimes.len() == 0 {\n+                if data.lifetimes.is_empty() {\n                     // traverse once to see if there's a need to insert lifetime\n                     let need_insert = (0..expected).any(|i| {\n                         indexes.contains(&i)"}, {"sha": "054cec68745ade14c5abe630742a9f81232cb018", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -88,7 +88,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n             Err(_) => \"/tmp/constraints.node%.dot\".to_string(),\n         };\n \n-        if output_template.len() == 0 {\n+        if output_template.is_empty() {\n             tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n "}, {"sha": "c6be97e6dbe0dc46f6db6108d227310e963ef274", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn in_snapshot(&self) -> bool {\n-        self.undo_log.borrow().len() > 0\n+        !self.undo_log.borrow().is_empty()\n     }\n \n     pub fn start_snapshot(&self) -> RegionSnapshot {"}, {"sha": "d4136637e585c5391a76fde2bf3b79759aa1875e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -716,7 +716,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             None => {\n                 // Vanilla 'break' or 'loop', so use the enclosing\n                 // loop scope\n-                if self.loop_scope.len() == 0 {\n+                if self.loop_scope.is_empty() {\n                     self.ir.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     *self.loop_scope.last().unwrap()\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     // for nil return types, it is ok to not return a value expl.\n                 } else {\n                     let ends_with_stmt = match body.expr {\n-                        None if body.stmts.len() > 0 =>\n+                        None if !body.stmts.is_empty() =>\n                             match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n                                     ty::expr_ty(self.ir.tcx, &**e) == t_ret\n@@ -1586,7 +1586,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn should_warn(&self, var: Variable) -> Option<String> {\n         let name = self.ir.variable_name(var);\n-        if name.len() == 0 || name.as_bytes()[0] == ('_' as u8) {\n+        if name.is_empty() || name.as_bytes()[0] == ('_' as u8) {\n             None\n         } else {\n             Some(name)"}, {"sha": "a9da92a768fe64c43644c22799012336e6f1e47e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -227,7 +227,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                                                                                ref bounds,\n                                                                                ref bound_lifetimes,\n                                                                                .. }) => {\n-                    if bound_lifetimes.len() > 0 {\n+                    if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let result = self.with(LateScope(bound_lifetimes, self.scope),\n                                                |old_scope, this| {\n@@ -267,7 +267,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                             _modifier: &ast::TraitBoundModifier) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack || trait_ref.bound_lifetimes.len() > 0 {\n+        if !self.trait_ref_hack || !trait_ref.bound_lifetimes.is_empty() {\n             if self.trait_ref_hack {\n                 println!(\"{:?}\", trait_ref.span);\n                 span_err!(self.sess, trait_ref.span, E0316,"}, {"sha": "d9cdf0fa1cb3691d5c5eea50a17b0dab3deae403", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -361,7 +361,7 @@ impl<T> VecPerParamSpace<T> {\n     pub fn get_self<'a>(&'a self) -> Option<&'a T> {\n         let v = self.get_slice(SelfSpace);\n         assert!(v.len() <= 1);\n-        if v.len() == 0 { None } else { Some(&v[0]) }\n+        if v.is_empty() { None } else { Some(&v[0]) }\n     }\n \n     pub fn len(&self, space: ParamSpace) -> usize {"}, {"sha": "5938c6df92a66ecb1264051b0c4500d4d9b67f3f", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -298,7 +298,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                self.predicates.len(),\n                errors.len());\n \n-        if errors.len() == 0 {\n+        if errors.is_empty() {\n             Ok(())\n         } else {\n             Err(errors)"}, {"sha": "ed8a6fb0200a46a5bd9d0b2f7c734097b806e3fe", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -698,7 +698,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // is checked for in `evaluate_stack` (and hence users\n         // who might care about this case, like coherence, should use\n         // that function).\n-        if candidates.len() == 0 {\n+        if candidates.is_empty() {\n             return Err(Unimplemented);\n         }\n \n@@ -873,7 +873,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         try!(self.assemble_candidates_from_caller_bounds(stack, &mut candidates));\n         // Default implementations have lower priority, so we only\n         // consider triggering a default if there is no other impl that can apply.\n-        if candidates.vec.len() == 0 {\n+        if candidates.vec.is_empty() {\n             try!(self.assemble_candidates_from_default_impls(obligation, &mut candidates));\n         }\n         debug!(\"candidate list size: {}\", candidates.vec.len());"}, {"sha": "1e817890440f2ac2b7539afbdf296da32d15a345", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -3036,7 +3036,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n }\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n-    bounds.len() == 0 ||\n+    bounds.is_empty() ||\n         bounds[1..].iter().enumerate().all(\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n@@ -3665,7 +3665,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                     res = res | TC::OwnsDtor;\n                 }\n \n-                if variants.len() != 0 {\n+                if !variants.is_empty() {\n                     let repr_hints = lookup_repr_hints(cx, did);\n                     if repr_hints.len() > 1 {\n                         // this is an error later on, but this type isn't safe\n@@ -3687,7 +3687,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                             if variants.len() == 2 {\n                                 let mut data_idx = 0;\n \n-                                if variants[0].args.len() == 0 {\n+                                if variants[0].args.is_empty() {\n                                     data_idx = 1;\n                                 }\n \n@@ -4200,10 +4200,10 @@ pub fn type_is_c_like_enum(cx: &ctxt, ty: Ty) -> bool {\n     match ty.sty {\n         ty_enum(did, _) => {\n             let variants = enum_variants(cx, did);\n-            if variants.len() == 0 {\n+            if variants.is_empty() {\n                 false\n             } else {\n-                variants.iter().all(|v| v.args.len() == 0)\n+                variants.iter().all(|v| v.args.is_empty())\n             }\n         }\n         _ => false\n@@ -4654,7 +4654,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             match resolve_expr(tcx, expr) {\n                 def::DefVariant(tid, vid, _) => {\n                     let variant_info = enum_variant_with_id(tcx, tid, vid);\n-                    if variant_info.args.len() > 0 {\n+                    if !variant_info.args.is_empty() {\n                         // N-ary variant.\n                         RvalueDatumExpr\n                     } else {\n@@ -5259,7 +5259,7 @@ impl<'tcx> VariantInfo<'tcx> {\n \n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if args.len() > 0 {\n+                let arg_tys = if !args.is_empty() {\n                     // the regions in the argument types come from the\n                     // enum def'n, and hence will all be early bound\n                     ty::no_late_bound_regions(cx, &ty_fn_args(ctor_ty)).unwrap()\n@@ -5280,7 +5280,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             ast::StructVariantKind(ref struct_def) => {\n                 let fields: &[StructField] = &struct_def.fields;\n \n-                assert!(fields.len() > 0);\n+                assert!(!fields.is_empty());\n \n                 let arg_tys = struct_def.fields.iter()\n                     .map(|field| node_id_to_type(cx, field.node.id)).collect();"}, {"sha": "1c414d3d5f3910ec51afbd64f5e02cbbe40d0ebe", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -544,7 +544,7 @@ pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n                                  .map(|(a, b)| relation.relate(a, b))\n                                  .collect::<Result<_, _>>());\n                 Ok(ty::mk_tup(tcx, ts))\n-            } else if as_.len() != 0 && bs.len() != 0 {\n+            } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(ty::terr_tuple_size(\n                     expected_found(relation, &as_.len(), &bs.len())))\n             } else {"}, {"sha": "3fb6c191f6ce383d06a2befe022334536d502051", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -902,7 +902,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n     output_types.sort();\n     output_types.dedup();\n-    if output_types.len() == 0 {\n+    if output_types.is_empty() {\n         output_types.push(OutputTypeExe);\n     }\n "}, {"sha": "fe076b904caef65d03557b74d5234883149379df", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -558,7 +558,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n                     &strs[0][..]\n                 },\n                 tail)\n-    } else if strs.len() > 0 {\n+    } else if !strs.is_empty() {\n         format!(\"{}<{}>\", base, strs.connect(\", \"))\n     } else {\n         format!(\"{}\", base)\n@@ -1269,7 +1269,7 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n         let names: Vec<_> = names.iter().map(|s| &s[..]).collect();\n \n         let value_str = unbound_value.user_string(tcx);\n-        if names.len() == 0 {\n+        if names.is_empty() {\n             value_str\n         } else {\n             format!(\"for<{}> {}\", names.connect(\",\"), value_str)"}, {"sha": "de934cf65ac21c0d0b8ff60becd52fa11fe54b40", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -50,7 +50,7 @@ impl TempDir {\n         let mut rng = thread_rng();\n         for _ in 0..NUM_RETRIES {\n             let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n-            let leaf = if prefix.len() > 0 {\n+            let leaf = if !prefix.is_empty() {\n                 format!(\"{}.{}\", prefix, suffix)\n             } else {\n                 // If we're given an empty string for a prefix, then creating a"}, {"sha": "1453c9b784b69ec40e4100c638c6eab005fb22a0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -887,9 +887,9 @@ pub fn collect_crate_types(session: &Session,\n     // command line, then reuse the empty `base` Vec to hold the types that\n     // will be found in crate attributes.\n     let mut base = session.opts.crate_types.clone();\n-    if base.len() == 0 {\n+    if base.is_empty() {\n         base.extend(attr_types.into_iter());\n-        if base.len() == 0 {\n+        if base.is_empty() {\n             base.push(link::default_output_for_target(session));\n         }\n         base.sort();"}, {"sha": "8f21a800d5c4d8c8e6749c5fd5b6361b20a7c7b1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -425,7 +425,7 @@ impl RustcDefaultCalls {\n                         odir: &Option<PathBuf>,\n                         ofile: &Option<PathBuf>)\n                         -> Compilation {\n-        if sess.opts.prints.len() == 0 {\n+        if sess.opts.prints.is_empty() {\n             return Compilation::Continue;\n         }\n "}, {"sha": "00c3450ebb935ac326ca6e904d05f49f8575c3f0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -676,7 +676,7 @@ fn print_flowgraph<W: Write>(variants: Vec<borrowck_dot::Variant>,\n     };\n \n     match code {\n-        _ if variants.len() == 0 => {\n+        _ if variants.is_empty() => {\n             let r = dot::render(&lcfg, &mut out);\n             return expand_err_details(r);\n         }"}, {"sha": "bdc3fdcfc1415ae0cc9398d2991a0090740b024c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -778,7 +778,7 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n+            !ident.is_empty() && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {\n@@ -1900,7 +1900,7 @@ impl LintPass for UnconditionalRecursion {\n         // doesn't return (e.g. calls a `-> !` function or `loop { /*\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n-        if !reached_exit_without_self_call && self_call_spans.len() > 0 {\n+        if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n             cx.span_lint(UNCONDITIONAL_RECURSION, sp,\n                          \"function cannot return without recurring\");\n "}, {"sha": "70c824a67a0efbd6d621c6e4533d390fe3221610", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n         let check_inherited = |sp: Span, vis: ast::Visibility, note: &str| {\n             if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n-                if note.len() > 0 {\n+                if !note.is_empty() {\n                     tcx.sess.span_note(sp, note);\n                 }\n             }"}, {"sha": "777154f3c9c3b41881f7b2c3849160402dc32853", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -767,7 +767,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 f.name\n             }).collect::<Vec<_>>();\n \n-            if fields.len() == 0 {\n+            if fields.is_empty() {\n                 child_name_bindings.define_value(def, DUMMY_SP, modifiers);\n             }\n "}, {"sha": "0058b31088b92b220a84d079fcd38a198ba0cc85", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -2172,7 +2172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     // check that all of the arms in an or-pattern have exactly the\n     // same set of bindings, with the same binding modes for each.\n     fn check_consistent_bindings(&mut self, arm: &Arm) {\n-        if arm.pats.len() == 0 {\n+        if arm.pats.is_empty() {\n             return\n         }\n         let map_0 = self.binding_mode_map(&*arm.pats[0]);\n@@ -3072,7 +3072,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n-        if values.len() > 0 &&\n+        if !values.is_empty() &&\n             values[smallest] != usize::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n@@ -3228,7 +3228,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         format!(\"to call `{}::{}`\", path_str, path_name)\n                                 };\n \n-                                if msg.len() > 0 {\n+                                if !msg.is_empty() {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n@@ -3522,7 +3522,7 @@ fn module_to_string(module: &Module) -> String {\n     }\n     collect_mod(&mut names, module);\n \n-    if names.len() == 0 {\n+    if names.is_empty() {\n         return \"???\".to_string();\n     }\n     names_to_string(&names.into_iter().rev().collect::<Vec<ast::Name>>())"}, {"sha": "4b488981bfbc6af7297b8322ed0399f838058c13", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -304,7 +304,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n-        let container = if module_path.len() == 0 {\n+        let container = if module_path.is_empty() {\n             // Use the crate root.\n             Some((self.resolver.graph_root.get_module(), LastMod(AllPublic)))\n         } else {"}, {"sha": "b53be98a06cc30198f16c20db0234319c5fde7af", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -269,7 +269,7 @@ pub fn sanitize(s: &str) -> String {\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n-    if result.len() > 0 &&\n+    if !result.is_empty() &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n         return format!(\"_{}\", &result[..]);\n@@ -463,7 +463,7 @@ pub fn filename_for_input(sess: &Session,\n         }\n         config::CrateTypeExecutable => {\n             let suffix = &sess.target.target.options.exe_suffix;\n-            if suffix.len() == 0 {\n+            if suffix.is_empty() {\n                 out_filename.to_path_buf()\n             } else {\n                 out_filename.with_extension(&suffix[1..])"}, {"sha": "57dba30723f9cfeada05c0827494de10bf7160f7", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -263,7 +263,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n     fn process_formals(&mut self, formals: &Vec<ast::Arg>, qualname: &str) {\n         for arg in formals {\n-            assert!(self.collected_paths.len() == 0 && !self.collecting);\n+            assert!(self.collected_paths.is_empty() && !self.collecting);\n             self.collecting = true;\n             self.visit_pat(&*arg.pat);\n             self.collecting = false;\n@@ -1119,7 +1119,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n                             for n in glob_map.get(&item.id).unwrap() {\n-                                if name_string.len() > 0 {\n+                                if !name_string.is_empty() {\n                                     name_string.push_str(\", \");\n                                 }\n                                 name_string.push_str(n.as_str());\n@@ -1394,7 +1394,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n     }\n \n     fn visit_arm(&mut self, arm: &ast::Arm) {\n-        assert!(self.collected_paths.len() == 0 && !self.collecting);\n+        assert!(self.collected_paths.is_empty() && !self.collecting);\n         self.collecting = true;\n         for pattern in &arm.pats {\n             // collect paths from the arm's patterns\n@@ -1462,7 +1462,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n \n         // The local could declare multiple new vars, we must walk the\n         // pattern and collect them all.\n-        assert!(self.collected_paths.len() == 0 && !self.collecting);\n+        assert!(self.collected_paths.is_empty() && !self.collecting);\n         self.collecting = true;\n         self.visit_pat(&*l.pat);\n         self.collecting = false;"}, {"sha": "744ec5a616841eae4706f156b00f2ba5514725d6", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -988,7 +988,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n-    if m.len() == 0 {\n+    if m.is_empty() {\n         if chk.is_fallible() {\n             chk.handle_fail(bcx);\n         }\n@@ -1112,7 +1112,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let mut kind = NoBranch;\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_string(test_val));\n-    if opts.len() > 0 {\n+    if !opts.is_empty() {\n         match opts[0] {\n             ConstantValue(..) | ConstantRange(..) => {\n                 test_val = load_if_immediate(bcx, val, left_ty);\n@@ -1152,7 +1152,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n \n     let defaults = enter_default(else_cx, dm, m, col, val);\n-    let exhaustive = chk.is_infallible() && defaults.len() == 0;\n+    let exhaustive = chk.is_infallible() && defaults.is_empty();\n     let len = opts.len();\n \n     // Compile subtrees for each option"}, {"sha": "f574b4ed8db90ba60dafba987b94f7056742f2b4", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -235,7 +235,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n \n-            if cases.len() == 0 {\n+            if cases.is_empty() {\n                 // Uninhabitable; represent as unit\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n@@ -244,7 +244,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                   dtor_to_init_u8(dtor));\n             }\n \n-            if !dtor && cases.iter().all(|c| c.tys.len() == 0) {\n+            if !dtor && cases.iter().all(|c| c.tys.is_empty()) {\n                 // All bodies empty -> intlike\n                 let discrs: Vec<u64> = cases.iter().map(|c| c.discr).collect();\n                 let bounds = IntBounds {"}, {"sha": "93eb24a47de679c38744079d1e0528e723b3384c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -2392,7 +2392,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     ccx.sess().bug(\"struct variant kind unexpected in get_item_val\")\n                 }\n             };\n-            assert!(args.len() != 0);\n+            assert!(!args.is_empty());\n             let ty = ty::node_id_to_type(ccx.tcx(), id);\n             let parent = ccx.tcx().map.get_parent(id);\n             let enm = ccx.tcx().map.expect_item(parent);"}, {"sha": "8d946e2743bdf0d5fe90fc726e3b8fcf02962443", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -70,7 +70,7 @@ trait ClassList {\n \n impl ClassList for [RegClass] {\n     fn is_pass_byval(&self) -> bool {\n-        if self.len() == 0 { return false; }\n+        if self.is_empty() { return false; }\n \n         let class = self[0];\n            class == Memory\n@@ -79,7 +79,7 @@ impl ClassList for [RegClass] {\n     }\n \n     fn is_ret_bysret(&self) -> bool {\n-        if self.len() == 0 { return false; }\n+        if self.is_empty() { return false; }\n \n         self[0] == Memory\n     }"}, {"sha": "0e8c33cd93a5b36e36aa126413960af23eb55aec", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -184,7 +184,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                                                     bcx.fcx.param_substs);\n \n                 // Nullary variants are not callable\n-                assert!(vinfo.args.len() > 0);\n+                assert!(!vinfo.args.is_empty());\n \n                 Callee {\n                     bcx: bcx,\n@@ -495,7 +495,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n \n         match map_node {\n             ast_map::NodeVariant(v) => match v.node.kind {\n-                ast::TupleVariantKind(ref args) => args.len() > 0,\n+                ast::TupleVariantKind(ref args) => !args.is_empty(),\n                 _ => false\n             },\n             ast_map::NodeStructCtor(_) => true,"}, {"sha": "38136b03a214191122270774087afcbf2394333c", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -781,7 +781,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n-                    if vinfo.args.len() > 0 {\n+                    if !vinfo.args.is_empty() {\n                         // N-ary variant.\n                         expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {"}, {"sha": "159b101e85e5ff28e34d9d6219ceb1dbf13704ec", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -532,7 +532,7 @@ impl<'tcx> TypeMap<'tcx> {\n             // Maybe check that there is no self type here.\n \n             let tps = substs.types.get_slice(subst::TypeSpace);\n-            if tps.len() > 0 {\n+            if !tps.is_empty() {\n                 output.push('<');\n \n                 for &type_parameter in tps {\n@@ -1102,7 +1102,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Ok(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && &bytes[bytes.len()-1..] == b\"}\" {\n+            if !bytes.is_empty() && &bytes[bytes.len()-1..] == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -2017,7 +2017,7 @@ struct StructMemberDescriptionFactory<'tcx> {\n impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n-        if self.fields.len() == 0 {\n+        if self.fields.is_empty() {\n             return Vec::new();\n         }\n \n@@ -2210,7 +2210,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n             adt::Univariant(ref struct_def, _) => {\n                 assert!(self.variants.len() <= 1);\n \n-                if self.variants.len() == 0 {\n+                if self.variants.is_empty() {\n                     vec![]\n                 } else {\n                     let (variant_type_metadata,\n@@ -3834,7 +3834,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push_str(\"fn(\");\n \n             let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n-            if sig.inputs.len() > 0 {\n+            if !sig.inputs.is_empty() {\n                 for &parameter_type in &sig.inputs {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n@@ -3844,7 +3844,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n \n             if sig.variadic {\n-                if sig.inputs.len() > 0 {\n+                if !sig.inputs.is_empty() {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");"}, {"sha": "b91f50222a27f4d4ea5627faca110b0a47407c49", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -1135,7 +1135,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match def {\n         def::DefVariant(tid, vid, _) => {\n             let variant_info = ty::enum_variant_with_id(bcx.tcx(), tid, vid);\n-            if variant_info.args.len() > 0 {\n+            if !variant_info.args.is_empty() {\n                 // N-ary variant.\n                 let llfn = callee::trans_fn_ref(bcx.ccx(), vid,\n                                                 ExprId(ref_expr.id),"}, {"sha": "e346fb0d93189a1b52ea245d54a6441b89df82c8", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -83,7 +83,7 @@ pub fn trans_impl(ccx: &CrateContext,\n     for impl_item in impl_items {\n         match impl_item.node {\n             ast::MethodImplItem(ref sig, ref body) => {\n-                if sig.generics.ty_params.len() == 0 {\n+                if sig.generics.ty_params.is_empty() {\n                     let trans_everywhere = attr::requests_inline(&impl_item.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, impl_item.id);"}, {"sha": "b3ab58e416f7414864745c3219fac86966982f53", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -69,7 +69,7 @@ pub fn untuple_arguments_if_necessary<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         return inputs.iter().cloned().collect()\n     }\n \n-    if inputs.len() == 0 {\n+    if inputs.is_empty() {\n         return Vec::new()\n     }\n "}, {"sha": "e37e9c970185c5e0dcdd3344f9dec25b076b6060", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -1125,7 +1125,7 @@ fn one_bound_for_assoc_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   span: Span)\n     -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n {\n-    if bounds.len() == 0 {\n+    if bounds.is_empty() {\n         span_err!(tcx.sess, span, E0220,\n                   \"associated type `{}` not found for `{}`\",\n                   assoc_name,\n@@ -2025,7 +2025,7 @@ fn compute_object_lifetime_bound<'tcx>(\n             \"only a single explicit lifetime bound is permitted\");\n     }\n \n-    if explicit_region_bounds.len() != 0 {\n+    if !explicit_region_bounds.is_empty() {\n         // Explicitly specified region bound. Use that.\n         let r = explicit_region_bounds[0];\n         return ast_region_to_region(tcx, r);\n@@ -2042,7 +2042,7 @@ fn compute_object_lifetime_bound<'tcx>(\n \n     // If there are no derived region bounds, then report back that we\n     // can find no region bound.\n-    if derived_region_bounds.len() == 0 {\n+    if derived_region_bounds.is_empty() {\n         match rscope.object_lifetime_default(span) {\n             Some(r) => { return r; }\n             None => {\n@@ -2130,11 +2130,11 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                                                      &mut builtin_bounds) {\n                             let segments = &b.trait_ref.path.segments;\n                             let parameters = &segments[segments.len() - 1].parameters;\n-                            if parameters.types().len() > 0 {\n+                            if !parameters.types().is_empty() {\n                                 check_type_argument_count(tcx, b.trait_ref.path.span,\n                                                           parameters.types().len(), 0, 0);\n                             }\n-                            if parameters.lifetimes().len() > 0 {\n+                            if !parameters.lifetimes().is_empty() {\n                                 report_lifetime_number_error(tcx, b.trait_ref.path.span,\n                                                              parameters.lifetimes().len(), 0);\n                             }"}, {"sha": "0959f9d1b9154e4e2df4dcb30d1424e68b339938", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -594,7 +594,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             for (subpat, arg_ty) in subpats.iter().zip(arg_tys.iter()) {\n                 check_pat(pcx, &**subpat, *arg_ty);\n             }\n-        } else if arg_tys.len() == 0 {\n+        } else if arg_tys.is_empty() {\n             span_err!(tcx.sess, pat.span, E0024,\n                       \"this pattern has {} field{}, but the corresponding {} has no fields\",\n                       subpats.len(), if subpats.len() == 1 {\"\"} else {\"s\"}, kind_name);"}, {"sha": "a4175fe8325b2c1d703372cc3938826aa1febdab", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -67,7 +67,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             }\n \n-            if static_sources.len() > 0 {\n+            if !static_sources.is_empty() {\n                 fcx.tcx().sess.fileline_note(\n                     span,\n                     \"found defined static methods, maybe a `self` is missing?\");\n@@ -200,7 +200,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         })\n         .collect::<Vec<_>>();\n \n-    if candidates.len() > 0 {\n+    if !candidates.is_empty() {\n         // sort from most relevant to least relevant\n         candidates.sort_by(|a, b| a.cmp(b).reverse());\n         candidates.dedup();"}, {"sha": "2830090e09871f8dc5ecf33072b04f03811bdcaf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -4258,7 +4258,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // The first step then is to categorize the segments appropriately.\n \n-    assert!(segments.len() >= 1);\n+    assert!(!segments.is_empty());\n \n     let mut ufcs_method = None;\n     let mut segment_spaces: Vec<_>;\n@@ -4480,7 +4480,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n-        if data.bindings.len() > 0 {\n+        if !data.bindings.is_empty() {\n             span_err!(fcx.tcx().sess, data.bindings[0].span, E0182,\n                       \"unexpected binding of associated item in expression path \\\n                        (only allowed in type paths)\");\n@@ -4719,7 +4719,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            tps.len(), ppaux::ty_to_string(ccx.tcx, ty));\n \n     // make a vector of booleans initially false, set to true when used\n-    if tps.len() == 0 { return; }\n+    if tps.is_empty() { return; }\n     let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n     ty::walk_ty(ty, |t| {"}, {"sha": "7f2af1d1b6262b63152c37d0dfc997b9f20251e0", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -174,7 +174,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n \n                 // For DST, all intermediate types must be sized.\n-                if variant.fields.len() > 0 {\n+                if !variant.fields.is_empty() {\n                     for field in variant.fields.init() {\n                         fcx.register_builtin_bound(\n                             field.ty,\n@@ -658,7 +658,7 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     enum_def.variants.iter()\n         .map(|variant| {\n             match variant.node.kind {\n-                ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+                ast::TupleVariantKind(ref args) if !args.is_empty() => {\n                     let ctor_ty = ty::node_id_to_type(fcx.tcx(), variant.node.id);\n \n                     // the regions in the argument types come from the"}, {"sha": "b0c994f7f6405500a582a480510210dcbfc923d4", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         for &impl_did in &*trait_impls.borrow() {\n             let items = impl_items.get(&impl_did).unwrap();\n-            if items.len() < 1 {\n+            if items.is_empty() {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }"}, {"sha": "e5022b98918f7d0d5b6f5cce06005f124cf46939", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -576,7 +576,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n         let result_ty = match variant.node.kind {\n-            ast::TupleVariantKind(ref args) if args.len() > 0 => {\n+            ast::TupleVariantKind(ref args) if !args.is_empty() => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n                 ty::mk_ctor_fn(tcx, variant_def_id, &input_tys, enum_scheme.ty)\n@@ -1035,7 +1035,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     match struct_def.ctor_id {\n         None => {}\n         Some(ctor_id) => {\n-            if struct_def.fields.len() == 0 {\n+            if struct_def.fields.is_empty() {\n                 // Enum-like.\n                 write_ty_to_tcx(tcx, ctor_id, selfty);\n \n@@ -1893,7 +1893,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                   .flat_map(|predicate| {\n                       match *predicate {\n                           ast::WherePredicate::BoundPredicate(ref data) => {\n-                              if data.bound_lifetimes.len() == 0 &&\n+                              if data.bound_lifetimes.is_empty() &&\n                                   is_param(ccx.tcx, &data.bounded_ty, param_id)\n                               {\n                                   from_bounds(ccx, &data.bounds).into_iter()"}, {"sha": "72702dc8d9472f31937721939b3c0af3c5ab638d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -712,7 +712,7 @@ impl<'tcx> Clean<Option<Vec<TyParamBound>>> for subst::Substs<'tcx> {\n             trait_: t.clean(cx),\n             lifetimes: vec![]\n         }, ast::TraitBoundModifier::None)));\n-        if v.len() > 0 {Some(v)} else {None}\n+        if !v.is_empty() {Some(v)} else {None}\n     }\n }\n \n@@ -1820,7 +1820,7 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n         let kind = match self.arg_names.as_ref().map(|s| &**s) {\n-            None | Some([]) if self.args.len() == 0 => CLikeVariant,\n+            None | Some([]) if self.args.is_empty() => CLikeVariant,\n             None | Some([]) => {\n                 TupleVariant(self.args.clean(cx))\n             }\n@@ -1874,7 +1874,7 @@ impl Clean<VariantKind> for ast::VariantKind {\n     fn clean(&self, cx: &DocContext) -> VariantKind {\n         match self {\n             &ast::TupleVariantKind(ref args) => {\n-                if args.len() == 0 {\n+                if args.is_empty() {\n                     CLikeVariant\n                 } else {\n                     TupleVariant(args.iter().map(|x| x.ty.clean(cx)).collect())"}, {"sha": "d2dccca362ef81fa80f32024636a48c101846dad", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -94,7 +94,7 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n \n impl fmt::Display for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n+        if self.lifetimes.is_empty() && self.type_params.is_empty() { return Ok(()) }\n         try!(f.write_str(\"&lt;\"));\n \n         for (i, life) in self.lifetimes.iter().enumerate() {\n@@ -104,8 +104,8 @@ impl fmt::Display for clean::Generics {\n             try!(write!(f, \"{}\", *life));\n         }\n \n-        if self.type_params.len() > 0 {\n-            if self.lifetimes.len() > 0 {\n+        if !self.type_params.is_empty() {\n+            if !self.lifetimes.is_empty() {\n                 try!(f.write_str(\", \"));\n             }\n             for (i, tp) in self.type_params.iter().enumerate() {\n@@ -114,7 +114,7 @@ impl fmt::Display for clean::Generics {\n                 }\n                 try!(f.write_str(&tp.name));\n \n-                if tp.bounds.len() > 0 {\n+                if !tp.bounds.is_empty() {\n                     try!(write!(f, \": {}\", TyParamBounds(&tp.bounds)));\n                 }\n \n@@ -132,7 +132,7 @@ impl fmt::Display for clean::Generics {\n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &WhereClause(gens) = self;\n-        if gens.where_predicates.len() == 0 {\n+        if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n         try!(f.write_str(\" <span class='where'>where \"));\n@@ -175,7 +175,7 @@ impl fmt::Display for clean::Lifetime {\n \n impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.lifetimes.len() > 0 {\n+        if !self.lifetimes.is_empty() {\n             try!(f.write_str(\"for&lt;\"));\n             for (i, lt) in self.lifetimes.iter().enumerate() {\n                 if i > 0 {\n@@ -212,7 +212,7 @@ impl fmt::Display for clean::PathParameters {\n             clean::PathParameters::AngleBracketed {\n                 ref lifetimes, ref types, ref bindings\n             } => {\n-                if lifetimes.len() > 0 || types.len() > 0 || bindings.len() > 0 {\n+                if !lifetimes.is_empty() || !types.is_empty() || !bindings.is_empty() {\n                     try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n                     for lifetime in lifetimes {\n@@ -541,7 +541,7 @@ impl fmt::Display for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n             if i > 0 { try!(write!(f, \", \")); }\n-            if input.name.len() > 0 {\n+            if !input.name.is_empty() {\n                 try!(write!(f, \"{}: \", input.name));\n             }\n             try!(write!(f, \"{}\", input.type_));\n@@ -585,8 +585,8 @@ impl<'a> fmt::Display for Method<'a> {\n             }\n         }\n         for (i, input) in d.inputs.values.iter().enumerate() {\n-            if i > 0 || args.len() > 0 { args.push_str(\", \"); }\n-            if input.name.len() > 0 {\n+            if i > 0 || !args.is_empty() { args.push_str(\", \"); }\n+            if !input.name.is_empty() {\n                 args.push_str(&format!(\"{}: \", input.name));\n             }\n             args.push_str(&format!(\"{}\", input.type_));\n@@ -734,7 +734,7 @@ impl<'a> fmt::Display for ConciseStability<'a> {\n                 };\n                 write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n                        lvl = Escape(&*lvl),\n-                       colon = if stability.reason.len() > 0 { \": \" } else { \"\" },\n+                       colon = if !stability.reason.is_empty() { \": \" } else { \"\" },\n                        reason = Escape(&*stability.reason))\n             }\n             None => {"}, {"sha": "a53884ca047d16325766712b06c302ea62d18b4d", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -130,7 +130,7 @@ r##\"<!DOCTYPE html>\n     content   = *t,\n     root_path = page.root_path,\n     ty        = page.ty,\n-    logo      = if layout.logo.len() == 0 {\n+    logo      = if layout.logo.is_empty() {\n         \"\".to_string()\n     } else {\n         format!(\"<a href='{}{}/index.html'>\\\n@@ -141,7 +141,7 @@ r##\"<!DOCTYPE html>\n     title     = page.title,\n     description = page.description,\n     keywords = page.keywords,\n-    favicon   = if layout.favicon.len() == 0 {\n+    favicon   = if layout.favicon.is_empty() {\n         \"\".to_string()\n     } else {\n         format!(r#\"<link rel=\"shortcut icon\" href=\"{}\">\"#, layout.favicon)\n@@ -152,7 +152,7 @@ r##\"<!DOCTYPE html>\n     sidebar   = *sidebar,\n     krate     = layout.krate,\n     play_url  = layout.playground_url,\n-    play_js   = if layout.playground_url.len() == 0 {\n+    play_js   = if layout.playground_url.is_empty() {\n         \"\".to_string()\n     } else {\n         format!(r#\"<script src=\"{}playpen.js\"></script>\"#, page.root_path)"}, {"sha": "334f05fb36fa8f0329766b8d8cd93a7827badc27", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -305,7 +305,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         let text = format!(r##\"<h{lvl} id=\"{id}\" class='section-header'><a\n                            href=\"#{id}\">{sec}{}</a></h{lvl}>\"##,\n                            s, lvl = level, id = id,\n-                           sec = if sec.len() == 0 {\n+                           sec = if sec.is_empty() {\n                                sec.to_string()\n                            } else {\n                                format!(\"{} \", sec)\n@@ -491,7 +491,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n-        if md.len() == 0 { return Ok(()) }\n+        if md.is_empty() { return Ok(()) }\n         render(fmt, md, false)\n     }\n }"}, {"sha": "5f4a3e74b6589bb54a2abeeb7794b2faffd6491d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -912,7 +912,7 @@ impl DocFolder for Cache {\n                      false)\n                 }\n                 clean::MethodItem(..) => {\n-                    if self.parent_stack.len() == 0 {\n+                    if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n                         let last = self.parent_stack.last().unwrap();\n@@ -973,7 +973,7 @@ impl DocFolder for Cache {\n         // Keep track of the fully qualified path for this item.\n         let pushed = if item.name.is_some() {\n             let n = item.name.as_ref().unwrap();\n-            if n.len() > 0 {\n+            if !n.is_empty() {\n                 self.stack.push(n.to_string());\n                 true\n             } else { false }\n@@ -1115,7 +1115,7 @@ impl Context {\n     fn recurse<T, F>(&mut self, s: String, f: F) -> T where\n         F: FnOnce(&mut Context) -> T,\n     {\n-        if s.len() == 0 {\n+        if s.is_empty() {\n             panic!(\"Unexpected empty destination: {:?}\", self.current);\n         }\n         let prev = self.dst.clone();\n@@ -1208,7 +1208,7 @@ impl Context {\n \n             let mut title = cx.current.connect(\"::\");\n             if pushname {\n-                if title.len() > 0 {\n+                if !title.is_empty() {\n                     title.push_str(\"::\");\n                 }\n                 title.push_str(it.name.as_ref().unwrap());\n@@ -1343,7 +1343,7 @@ impl Context {\n     fn ignore_private_item(&self, it: &clean::Item) -> bool {\n         match it.inner {\n             clean::ModuleItem(ref m) => {\n-                (m.items.len() == 0 &&\n+                (m.items.is_empty() &&\n                  it.doc_value().is_none() &&\n                  it.visibility != Some(ast::Public)) ||\n                 (self.passes.contains(\"strip-private\") && it.visibility != Some(ast::Public))\n@@ -1690,7 +1690,7 @@ struct Initializer<'a>(&'a str);\n impl<'a> fmt::Display for Initializer<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Initializer(s) = *self;\n-        if s.len() == 0 { return Ok(()); }\n+        if s.is_empty() { return Ok(()); }\n         try!(write!(f, \"<code> = </code>\"));\n         write!(f, \"<code>{}</code>\", s)\n     }\n@@ -1736,8 +1736,8 @@ fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n     let mut bounds = String::new();\n-    if t.bounds.len() > 0 {\n-        if bounds.len() > 0 {\n+    if !t.bounds.is_empty() {\n+        if !bounds.is_empty() {\n             bounds.push(' ');\n         }\n         bounds.push_str(\": \");\n@@ -1766,7 +1766,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         match m.inner { clean::MethodItem(_) => true, _ => false }\n     }).collect::<Vec<_>>();\n \n-    if t.items.len() == 0 {\n+    if t.items.is_empty() {\n         try!(write!(w, \"{{ }}\"));\n     } else {\n         try!(write!(w, \"{{\\n\"));\n@@ -1775,15 +1775,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(render_method(w, t, MethodLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n-        if types.len() > 0 && required.len() > 0 {\n+        if !types.is_empty() && !required.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &required {\n             try!(write!(w, \"    \"));\n             try!(render_method(w, m, MethodLink::Anchor));\n             try!(write!(w, \";\\n\"));\n         }\n-        if required.len() > 0 && provided.len() > 0 {\n+        if !required.is_empty() && !provided.is_empty() {\n             try!(w.write_str(\"\\n\"));\n         }\n         for m in &provided {\n@@ -1810,7 +1810,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         Ok(())\n     }\n \n-    if types.len() > 0 {\n+    if !types.is_empty() {\n         try!(write!(w, \"\n             <h2 id='associated-types'>Associated Types</h2>\n             <div class='methods'>\n@@ -1822,7 +1822,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // Output the documentation for each function individually\n-    if required.len() > 0 {\n+    if !required.is_empty() {\n         try!(write!(w, \"\n             <h2 id='required-methods'>Required Methods</h2>\n             <div class='methods'>\n@@ -1832,7 +1832,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n         try!(write!(w, \"</div>\"));\n     }\n-    if provided.len() > 0 {\n+    if !provided.is_empty() {\n         try!(write!(w, \"\n             <h2 id='provided-methods'>Provided Methods</h2>\n             <div class='methods'>\n@@ -1882,7 +1882,7 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n               default: &Option<clean::Type>)\n               -> fmt::Result {\n     try!(write!(w, \"type {}\", it.name.as_ref().unwrap()));\n-    if bounds.len() > 0 {\n+    if !bounds.is_empty() {\n         try!(write!(w, \": {}\", TyParamBounds(bounds)))\n     }\n     if let Some(ref default) = *default {\n@@ -1986,7 +1986,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n                   it.name.as_ref().unwrap(),\n                   e.generics,\n                   WhereClause(&e.generics)));\n-    if e.variants.len() == 0 && !e.variants_stripped {\n+    if e.variants.is_empty() && !e.variants_stripped {\n         try!(write!(w, \" {{}}\"));\n     } else {\n         try!(write!(w, \" {{\\n\"));\n@@ -2031,7 +2031,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     try!(write!(w, \"</pre>\"));\n \n     try!(document(w, it));\n-    if e.variants.len() > 0 {\n+    if !e.variants.is_empty() {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in &e.variants {\n             try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n@@ -2170,13 +2170,13 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.into_iter()\n         .partition(|i| i.impl_.trait_.is_none());\n-    if non_trait.len() > 0 {\n+    if !non_trait.is_empty() {\n         try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n         for i in &non_trait {\n             try!(render_impl(w, i, MethodLink::Anchor));\n         }\n     }\n-    if traits.len() > 0 {\n+    if !traits.is_empty() {\n         try!(write!(w, \"<h2 id='implementations'>Trait \\\n                           Implementations</h2>\"));\n         let (derived, manual): (Vec<_>, _) = traits.into_iter()\n@@ -2185,7 +2185,7 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             let did = i.trait_did().unwrap();\n             try!(render_impl(w, i, MethodLink::GotoSource(did)));\n         }\n-        if derived.len() > 0 {\n+        if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));"}, {"sha": "008da466db0105d29c0122d4a3befc477b3b1cad", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -219,7 +219,7 @@ pub fn main_args(args: &[String]) -> isize {\n         return 0;\n     }\n \n-    if matches.free.len() == 0 {\n+    if matches.free.is_empty() {\n         println!(\"expected an input file to act on\");\n         return 1;\n     } if matches.free.len() > 1 {"}, {"sha": "00de4e3ec53cf6ac458dfd2ab41813fed61d6f2d", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -74,7 +74,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     };\n \n     let (metadata, text) = extract_leading_metadata(&input_str);\n-    if metadata.len() == 0 {\n+    if metadata.is_empty() {\n         let _ = writeln!(&mut io::stderr(),\n                          \"invalid markdown file: expecting initial line with `% ...TITLE...`\");\n         return 5;"}, {"sha": "53cfbb3efdda528aa39ca1a45b390ba0e7724542", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -215,9 +215,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 match i.inner {\n                     // emptied modules/impls have no need to exist\n                     clean::ModuleItem(ref m)\n-                        if m.items.len() == 0 &&\n+                        if m.items.is_empty() &&\n                            i.doc_value().is_none() => None,\n-                    clean::ImplItem(ref i) if i.items.len() == 0 => None,\n+                    clean::ImplItem(ref i) if i.items.is_empty() => None,\n                     _ => {\n                         self.retained.insert(i.def_id.node);\n                         Some(i)\n@@ -294,7 +294,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                 &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n             }).cloned().collect();\n-            if docstr.len() > 0 {\n+            if !docstr.is_empty() {\n                 a.push(clean::NameValue(\"doc\".to_string(), docstr));\n             }\n             i.attrs = a;\n@@ -350,7 +350,7 @@ pub fn unindent(s: &str) -> String {\n         }\n     });\n \n-    if lines.len() >= 1 {\n+    if !lines.is_empty() {\n         let mut unindented = vec![ lines[0].trim().to_string() ];\n         unindented.push_all(&lines.tail().iter().map(|&line| {\n             if line.chars().all(|c| c.is_whitespace()) {"}, {"sha": "449f9c79d1d455ca2af8990383999add19e83e2f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -409,7 +409,7 @@ impl Collector {\n impl DocFolder for Collector {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         let pushed = match item.name {\n-            Some(ref name) if name.len() == 0 => false,\n+            Some(ref name) if name.is_empty() => false,\n             Some(ref name) => { self.names.push(name.to_string()); true }\n             None => false\n         };"}, {"sha": "e4f4dbaafbe49516a1307cf5c1770a5bba01bdb4", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -175,7 +175,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                      please_inline)\n                 }).collect::<Vec<ast::PathListItem>>();\n \n-                if mine.len() == 0 {\n+                if mine.is_empty() {\n                     None\n                 } else {\n                     Some(ast::ViewPathList(p, mine))"}, {"sha": "8f020d0857d7bcd17f8ef61bffb5330b91e202e8", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -3837,7 +3837,7 @@ mod tests {\n         let mut stack = Stack::new();\n \n         assert!(stack.is_empty());\n-        assert!(stack.len() == 0);\n+        assert!(stack.is_empty());\n         assert!(!stack.last_is_index());\n \n         stack.push_index(0);"}, {"sha": "62c03389b24ae8e28c3c81097f899d07dfd44aa4", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -430,7 +430,7 @@ impl<T, S> HashSet<T, S>\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n+    pub fn is_empty(&self) -> bool { self.map.is_empty() }\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]"}, {"sha": "07b43b6c5dbdb1af0747da09c3206cce07094455", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -349,7 +349,7 @@ pub trait Write {\n     /// This function will return the first error that `write` returns.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n-        while buf.len() > 0 {\n+        while !buf.is_empty() {\n             match self.write(buf) {\n                 Ok(0) => return Err(Error::new(ErrorKind::WriteZero,\n                                                \"failed to write whole buffer\")),"}, {"sha": "cb78fc56bf20c2b7ac5425fc5ddae341fd78a101", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -218,7 +218,7 @@ mod platform {\n                     return Some(DeviceNS(u8_slice_as_os_str(slice)));\n                 }\n                 match parse_two_comps(path, is_sep_byte) {\n-                    Some((server, share)) if server.len() > 0 && share.len() > 0 => {\n+                    Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n                         // \\\\server\\share\n                         return Some(UNC(u8_slice_as_os_str(server),\n                                         u8_slice_as_os_str(share)));\n@@ -401,7 +401,7 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n     let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n-    path.len() > 0 && is_sep_byte(path[0])\n+    !path.is_empty() && is_sep_byte(path[0])\n }\n \n // basic workhorse for splitting stem and extension\n@@ -810,15 +810,15 @@ impl<'a> Iterator for Components<'a> {\n                 State::StartDir => {\n                     self.front = State::Body;\n                     if self.has_physical_root {\n-                        debug_assert!(self.path.len() > 0);\n+                        debug_assert!(!self.path.is_empty());\n                         self.path = &self.path[1..];\n                         return Some(Component::RootDir)\n                     } else if let Some(p) = self.prefix {\n                         if p.has_implicit_root() && !p.is_verbatim() {\n                             return Some(Component::RootDir)\n                         }\n                     } else if self.include_cur_dir() {\n-                        debug_assert!(self.path.len() > 0);\n+                        debug_assert!(!self.path.is_empty());\n                         self.path = &self.path[1..];\n                         return Some(Component::CurDir)\n                     }\n@@ -1055,7 +1055,7 @@ impl PathBuf {\n         };\n \n         let extension = extension.as_ref();\n-        if os_str_as_u8_slice(extension).len() > 0 {\n+        if !os_str_as_u8_slice(extension).is_empty() {\n             stem.push(\".\");\n             stem.push(extension);\n         }"}, {"sha": "f8dd6a00c7f1d9c21577cbbc7e2804d38c9242f8", "filename": "src/libstd/rand/reader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Frand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Frand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Freader.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -51,7 +51,7 @@ impl<R: Read> Rng for ReaderRng<R> {\n         unsafe { *(bytes.as_ptr() as *const u64) }\n     }\n     fn fill_bytes(&mut self, mut v: &mut [u8]) {\n-        while v.len() > 0 {\n+        while !v.is_empty() {\n             let t = v;\n             match self.reader.read(t) {\n                 Ok(0) => panic!(\"ReaderRng.fill_bytes: EOF reached\"),"}, {"sha": "580d970af0c3da3d77a1a484da9c7497ea085e93", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -76,7 +76,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n         try!(writer.write_all(s.as_bytes()));\n     } else {\n         let mut first = true;\n-        while inner.len() > 0 {\n+        while !inner.is_empty() {\n             if !first {\n                 try!(writer.write_all(b\"::\"));\n             } else {\n@@ -89,7 +89,7 @@ pub fn demangle(writer: &mut Write, s: &str) -> io::Result<()> {\n             let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();\n             inner = &rest[i..];\n             rest = &rest[..i];\n-            while rest.len() > 0 {\n+            while !rest.is_empty() {\n                 if rest.starts_with(\"$\") {\n                     macro_rules! demangle {\n                         ($($pat:expr, => $demangled:expr),*) => ({"}, {"sha": "16c2a9125eaa711efabbcdb884ac827e6a1efe4e", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -381,7 +381,7 @@ fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n         // it will be dropped entirely when parsed on the other end.\n         let arg_bytes = &arg.as_inner().inner.as_inner();\n         let quote = arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n-            || arg_bytes.len() == 0;\n+            || arg_bytes.is_empty();\n         if quote {\n             cmd.push('\"' as u16);\n         }"}, {"sha": "26463df1871225f08e193d3ed15c3cf925a9e620", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -429,14 +429,14 @@ pub struct Generics {\n }\n \n impl Generics {\n-    pub fn is_parameterized(&self) -> bool {\n-        self.lifetimes.len() + self.ty_params.len() > 0\n-    }\n     pub fn is_lt_parameterized(&self) -> bool {\n-        self.lifetimes.len() > 0\n+        !self.lifetimes.is_empty()\n     }\n     pub fn is_type_parameterized(&self) -> bool {\n-        self.ty_params.len() > 0\n+        !self.ty_params.is_empty()\n+    }\n+    pub fn is_parameterized(&self) -> bool {\n+        self.is_lt_parameterized() || self.is_type_parameterized()\n     }\n }\n "}, {"sha": "a0bde8f6c525e9dfadedaff51974a3ebd2f6091c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -360,7 +360,7 @@ impl Encodable for FileMap {\n                     // store the length\n                     try! { s.emit_u32(lines.len() as u32) };\n \n-                    if lines.len() > 0 {\n+                    if !lines.is_empty() {\n                         // In order to preserve some space, we exploit the fact that\n                         // the lines list is sorted and individual lines are\n                         // probably not that long. Because of that we can store lines\n@@ -569,7 +569,7 @@ impl CodeMap {\n         // accidentally overflowing into the next filemap in case the last byte\n         // of span is also the last byte of filemap, which leads to incorrect\n         // results from CodeMap.span_to_*.\n-        if src.len() > 0 && !src.ends_with(\"\\n\") {\n+        if !src.is_empty() && !src.ends_with(\"\\n\") {\n             src.push('\\n');\n         }\n \n@@ -652,7 +652,7 @@ impl CodeMap {\n     }\n \n     pub fn span_to_string(&self, sp: Span) -> String {\n-        if self.files.borrow().len() == 0 && sp == DUMMY_SP {\n+        if self.files.borrow().is_empty() && sp == DUMMY_SP {\n             return \"no-location\".to_string();\n         }\n \n@@ -808,7 +808,7 @@ impl CodeMap {\n         loop {\n             let lines = files[a].lines.borrow();\n             let lines = lines;\n-            if lines.len() > 0 {\n+            if !lines.is_empty() {\n                 break;\n             }\n             if a == 0 {"}, {"sha": "6915969032810cf3830234f50b99c6aafadb157f", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -90,7 +90,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::Colon &&\n                       p.token != token::ModSep {\n \n-                    if outputs.len() != 0 {\n+                    if !outputs.is_empty() {\n                         panictry!(p.eat(&token::Comma));\n                     }\n \n@@ -130,7 +130,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::Colon &&\n                       p.token != token::ModSep {\n \n-                    if inputs.len() != 0 {\n+                    if !inputs.is_empty() {\n                         panictry!(p.eat(&token::Comma));\n                     }\n \n@@ -154,7 +154,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                       p.token != token::Colon &&\n                       p.token != token::ModSep {\n \n-                    if clobs.len() != 0 {\n+                    if !clobs.is_empty() {\n                         panictry!(p.eat(&token::Comma));\n                     }\n "}, {"sha": "9e36c75dda4289c2b4f410dd9eae91aaa74bfc1f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -774,7 +774,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       sp: Span,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n-    if tts.len() != 0 {\n+    if !tts.is_empty() {\n         cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n     }\n }"}, {"sha": "95eb68ca0d37dc34dde66c2e9cf199a41365492a", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -89,7 +89,7 @@ fn cs_clone(\n         }\n     }\n \n-    if all_fields.len() >= 1 && all_fields[0].name.is_none() {\n+    if !all_fields.is_empty() && all_fields[0].name.is_none() {\n         // enum-like\n         let subcalls = all_fields.iter().map(subcall).collect();\n         let path = cx.expr_path(ctor_path);"}, {"sha": "6425e6a28ece00f03c03184302a59962925caad8", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -240,7 +240,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n-            if fields.len() > 0 {\n+            if !fields.is_empty() {\n                 let last = fields.len() - 1;\n                 for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n                     let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "7f6f29df530a73ae340f041a506f6fb83a725aa0", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -912,7 +912,7 @@ impl<'a> MethodDef<'a> {\n         }\n \n         // transpose raw_fields\n-        let fields = if raw_fields.len() > 0 {\n+        let fields = if !raw_fields.is_empty() {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n             let mut other_fields: Vec<vec::IntoIter<(Span, Option<Ident>, P<Expr>)>>\n@@ -1248,7 +1248,7 @@ impl<'a> MethodDef<'a> {\n \n             match_arms.push(catch_all_match_arm);\n \n-        } else if variants.len() == 0 {\n+        } else if variants.is_empty() {\n             // As an additional wrinkle, For a zero-variant enum A,\n             // currently the compiler\n             // will accept `fn (a: &Self) { match   *a   { } }`"}, {"sha": "2ca74644b3bfd01a6c5cd5151792ab19d6e0ceb5", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -65,7 +65,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                        -> Box<base::MacResult+'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        Some(ref exprs) if exprs.len() == 0 => {\n+        Some(ref exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }"}, {"sha": "74ec219af15409503ac1f16f38a2c765350ba88c", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -841,7 +841,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n fn expand_arm(arm: ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // expand pats... they might contain macro uses:\n     let expanded_pats = arm.pats.move_map(|pat| fld.fold_pat(pat));\n-    if expanded_pats.len() == 0 {\n+    if expanded_pats.is_empty() {\n         panic!(\"encountered match arm with 0 patterns\");\n     }\n     // all of the pats must have the same set of bindings, so use the\n@@ -1887,7 +1887,7 @@ mod test {\n             let binding_name = mtwt::resolve(bindings[binding_idx]);\n             let binding_marks = mtwt::marksof(bindings[binding_idx].ctxt, invalid_name);\n             // shouldmatch can't name varrefs that don't exist:\n-            assert!((shouldmatch.len() == 0) ||\n+            assert!((shouldmatch.is_empty()) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n                 let print_hygiene_debug_info = || {"}, {"sha": "4fe5ab1554500877aa1e2f99e00b62d93d65ebab", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -688,7 +688,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     loop {\n         match parser.next() {\n             Some(piece) => {\n-                if parser.errors.len() > 0 { break }\n+                if !parser.errors.is_empty() { break }\n                 cx.verify_piece(&piece);\n                 match cx.trans_piece(&piece) {\n                     Some(piece) => {"}, {"sha": "ce83b84efee805ac9d129d921a54b0e4296bbe3f", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -266,7 +266,7 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n /// Push a name... unless it matches the one on top, in which\n /// case pop and discard (so two of the same marks cancel)\n fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n-    if (marks.len() > 0) && (*marks.last().unwrap() == mark) {\n+    if (!marks.is_empty()) && (*marks.last().unwrap() == mark) {\n         marks.pop().unwrap();\n     } else {\n         marks.push(mark);"}, {"sha": "9c3a556b210f9edb84f0910a90413bd697bca545", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -457,7 +457,7 @@ pub fn parse(sess: &ParseSess,\n                 return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n-            if (bb_eis.len() > 0 && next_eis.len() > 0)\n+            if (!bb_eis.is_empty() && !next_eis.is_empty())\n                 || bb_eis.len() > 1 {\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n@@ -472,12 +472,12 @@ pub fn parse(sess: &ParseSess,\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()).to_string());\n-            } else if bb_eis.len() == 0 && next_eis.len() == 0 {\n+            } else if bb_eis.is_empty() && next_eis.is_empty() {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n-            } else if next_eis.len() > 0 {\n+            } else if !next_eis.is_empty() {\n                 /* Now process the next token */\n-                while next_eis.len() > 0 {\n+                while !next_eis.is_empty() {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n@@ -504,7 +504,7 @@ pub fn parse(sess: &ParseSess,\n             }\n         }\n \n-        assert!(cur_eis.len() > 0);\n+        assert!(!cur_eis.is_empty());\n     }\n }\n "}, {"sha": "bda01d5a6541c72822ea517c21ad2e3858376f2d", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -63,7 +63,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut i = 0;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n-        if lines.len() > 0 &&\n+        if !lines.is_empty() &&\n                 lines[0].chars().all(|c| c == '*') {\n             i += 1;\n         }\n@@ -294,7 +294,7 @@ fn read_block_comment(rdr: &mut StringReader,\n                 }\n             }\n         }\n-        if curr_line.len() != 0 {\n+        if !curr_line.is_empty() {\n             trim_whitespace_prefix_and_push_line(&mut lines,\n                                                  curr_line,\n                                                  col);"}, {"sha": "0515d1ae945bda170e818902f935145042f740ff", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -449,7 +449,7 @@ impl<'a> Parser<'a> {\n                     (format!(\"expected one of {}, found `{}`\",\n                              expect,\n                              actual))\n-                } else if expected.len() == 0 {\n+                } else if expected.is_empty() {\n                     (format!(\"unexpected token: `{}`\",\n                              actual))\n                 } else {\n@@ -1244,7 +1244,7 @@ impl<'a> Parser<'a> {\n \n         // In type grammar, `+` is treated like a binary operator,\n         // and hence both L and R side are required.\n-        if bounds.len() == 0 {\n+        if bounds.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n                           \"at least one type parameter bound \\\n@@ -2191,7 +2191,7 @@ impl<'a> Parser<'a> {\n                                                  &[token::CloseDelim(token::Brace)]));\n                             }\n \n-                            if fields.len() == 0 && base.is_none() {\n+                            if fields.is_empty() && base.is_none() {\n                                 let last_span = self.last_span;\n                                 self.span_err(last_span,\n                                               \"structure literal must either \\\n@@ -2254,7 +2254,7 @@ impl<'a> Parser<'a> {\n                         (Vec::new(), Vec::new(), Vec::new())\n                     };\n \n-                    if bindings.len() > 0 {\n+                    if !bindings.is_empty() {\n                         let last_span = self.last_span;\n                         self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n                     }\n@@ -3024,7 +3024,7 @@ impl<'a> Parser<'a> {\n                 try!(self.expect(&token::Comma));\n \n                 if self.token == token::CloseDelim(token::Bracket)\n-                        && (before_slice || after.len() != 0) {\n+                        && (before_slice || !after.is_empty()) {\n                     break\n                 }\n             }\n@@ -3914,7 +3914,7 @@ impl<'a> Parser<'a> {\n                         let hi = self.span.hi;\n                         let span = mk_sp(lo, hi);\n \n-                        if bounds.len() == 0 {\n+                        if bounds.is_empty() {\n                             self.span_err(span,\n                                           \"each predicate in a `where` clause must have \\\n                                            at least one bound in it\");\n@@ -4572,7 +4572,7 @@ impl<'a> Parser<'a> {\n                 fields.push(try!(self.parse_struct_decl_field(true)));\n             }\n \n-            if fields.len() == 0 {\n+            if fields.is_empty() {\n                 return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n                     token::get_ident(class_name.clone()))));\n@@ -4611,7 +4611,7 @@ impl<'a> Parser<'a> {\n                     Ok(spanned(lo, p.span.hi, struct_field_))\n                 }));\n \n-            if fields.len() == 0 {\n+            if fields.is_empty() {\n                 return Err(self.fatal(&format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n                     token::get_ident(class_name.clone()))));\n@@ -5023,7 +5023,7 @@ impl<'a> Parser<'a> {\n                 all_nullary = false;\n                 let start_span = self.span;\n                 let struct_def = try!(self.parse_struct_def());\n-                if struct_def.fields.len() == 0 {\n+                if struct_def.fields.is_empty() {\n                     self.span_err(start_span,\n                         &format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\","}, {"sha": "3fd4e31b4771ee8aac8ea64fa38453e8cf52ca7c", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -565,7 +565,7 @@ impl<'a> Printer<'a> {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((print_stack.len() != 0));\n+            assert!((!print_stack.is_empty()));\n             print_stack.pop().unwrap();\n             Ok(())\n           }"}, {"sha": "c51b5d039784d4009ff091d183485fdd0e0906c7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -1656,7 +1656,7 @@ impl<'a> State<'a> {\n         try!(self.print_expr(&*args[0]));\n         try!(word(&mut self.s, \".\"));\n         try!(self.print_ident(ident.node));\n-        if tys.len() > 0 {\n+        if !tys.is_empty() {\n             try!(word(&mut self.s, \"::<\"));\n             try!(self.commasep(Inconsistent, tys,\n                                |s, ty| s.print_type(&**ty)));\n@@ -1956,7 +1956,7 @@ impl<'a> State<'a> {\n                     options.push(\"intel\");\n                 }\n \n-                if options.len() > 0 {\n+                if !options.is_empty() {\n                     try!(space(&mut self.s));\n                     try!(self.word_space(\":\"));\n                     try!(self.commasep(Inconsistent, &*options,\n@@ -2214,7 +2214,7 @@ impl<'a> State<'a> {\n                     },\n                     |f| f.node.pat.span));\n                 if etc {\n-                    if fields.len() != 0 { try!(self.word_space(\",\")); }\n+                    if !fields.is_empty() { try!(self.word_space(\",\")); }\n                     try!(word(&mut self.s, \"..\"));\n                 }\n                 try!(space(&mut self.s));\n@@ -2546,7 +2546,7 @@ impl<'a> State<'a> {\n \n     pub fn print_where_clause(&mut self, where_clause: &ast::WhereClause)\n                               -> io::Result<()> {\n-        if where_clause.predicates.len() == 0 {\n+        if where_clause.predicates.is_empty() {\n             return Ok(())\n         }\n \n@@ -2727,7 +2727,7 @@ impl<'a> State<'a> {\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n-        if generics.lifetimes.len() > 0 || generics.ty_params.len() > 0 {\n+        if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n             try!(word(&mut self.s, \"for\"));\n             try!(self.print_generics(generics));\n         }"}, {"sha": "c9ad08bb8523485ae9eb9478dfe97fd71fd8a493", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -123,7 +123,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             Percent => {\n                 match cur {\n                     '%' => { output.push(c); state = Nothing },\n-                    'c' => if stack.len() > 0 {\n+                    'c' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             // if c is 0, use 0200 (128) for ncurses compatibility\n                             Number(c) => {\n@@ -141,7 +141,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     'g' => state = GetVar,\n                     '\\'' => state = CharConstant,\n                     '{' => state = IntConstant(0),\n-                    'l' => if stack.len() > 0 {\n+                    'l' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Words(s) => stack.push(Number(s.len() as isize)),\n                             _        => return Err(\"a non-str was used with %l\".to_string())\n@@ -231,14 +231,14 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                             _ => return Err(\"non-numbers on stack with logical or\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n-                    '!' => if stack.len() > 0 {\n+                    '!' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(0) => stack.push(Number(1)),\n                             Number(_) => stack.push(Number(0)),\n                             _ => return Err(\"non-number on stack with logical not\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n-                    '~' => if stack.len() > 0 {\n+                    '~' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(x) => stack.push(Number(!x)),\n                             _         => return Err(\"non-number on stack with %~\".to_string())\n@@ -253,7 +253,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     },\n \n                     // printf-style support for %doxXs\n-                    'd'|'o'|'x'|'X'|'s' => if stack.len() > 0 {\n+                    'd'|'o'|'x'|'X'|'s' => if !stack.is_empty() {\n                         let flags = Flags::new();\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), flags);\n                         if res.is_err() { return res }\n@@ -278,7 +278,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n \n                     // conditionals\n                     '?' => (),\n-                    't' => if stack.len() > 0 {\n+                    't' => if !stack.is_empty() {\n                         match stack.pop().unwrap() {\n                             Number(0) => state = SeekIfElse(0),\n                             Number(_) => (),\n@@ -303,12 +303,12 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             },\n             SetVar => {\n                 if cur >= 'A' && cur <= 'Z' {\n-                    if stack.len() > 0 {\n+                    if !stack.is_empty() {\n                         let idx = (cur as u8) - b'A';\n                         vars.sta[idx as usize] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n                 } else if cur >= 'a' && cur <= 'z' {\n-                    if stack.len() > 0 {\n+                    if !stack.is_empty() {\n                         let idx = (cur as u8) - b'a';\n                         vars.dyn[idx as usize] = stack.pop().unwrap();\n                     } else { return Err(\"stack is empty\".to_string()) }\n@@ -352,7 +352,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n             FormatPattern(ref mut flags, ref mut fstate) => {\n                 old_state = Nothing;\n                 match (*fstate, cur) {\n-                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if stack.len() > 0 {\n+                    (_,'d')|(_,'o')|(_,'x')|(_,'X')|(_,'s') => if !stack.is_empty() {\n                         let res = format(stack.pop().unwrap(), FormatOp::from_char(cur), *flags);\n                         if res.is_err() { return res }\n                         output.push_all(&res.unwrap());"}, {"sha": "16062060df087d90d5d349b48c0761b7ceadb3e6", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -20,7 +20,7 @@ use std::path::PathBuf;\n /// Return path to database entry for `term`\n #[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<Box<PathBuf>> {\n-    if term.len() == 0 {\n+    if term.is_empty() {\n         return None;\n     }\n "}, {"sha": "a9624840f676d21918cad381b935f5bd457648ce", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -373,7 +373,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n \n     if matches.opt_present(\"h\") { usage(&args[0]); return None; }\n \n-    let filter = if matches.free.len() > 0 {\n+    let filter = if !matches.free.is_empty() {\n         Some(matches.free[0].clone())\n     } else {\n         None\n@@ -588,14 +588,14 @@ impl<T: Write> ConsoleTestState<T> {\n         let mut fail_out = String::new();\n         for &(ref f, ref stdout) in &self.failures {\n             failures.push(f.name.to_string());\n-            if stdout.len() > 0 {\n+            if !stdout.is_empty() {\n                 fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n                 let output = String::from_utf8_lossy(stdout);\n                 fail_out.push_str(&output);\n                 fail_out.push_str(\"\\n\");\n             }\n         }\n-        if fail_out.len() > 0 {\n+        if !fail_out.is_empty() {\n             try!(self.write_plain(\"\\n\"));\n             try!(self.write_plain(&fail_out));\n         }"}, {"sha": "06e0de76eafd8df7cc69c3449b99b23f5635cf79", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -196,17 +196,17 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     }\n \n     fn min(&self) -> T {\n-        assert!(self.len() != 0);\n+        assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.min(*q))\n     }\n \n     fn max(&self) -> T {\n-        assert!(self.len() != 0);\n+        assert!(!self.is_empty());\n         self.iter().fold(self[0], |p, q| p.max(*q))\n     }\n \n     fn mean(&self) -> T {\n-        assert!(self.len() != 0);\n+        assert!(!self.is_empty());\n         self.sum() / FromPrimitive::from_usize(self.len()).unwrap()\n     }\n \n@@ -284,7 +284,7 @@ impl<T: Float + FromPrimitive> Stats<T> for [T] {\n // linear interpolation. If samples are not sorted, return nonsensical value.\n fn percentile_of_sorted<T: Float + FromPrimitive>(sorted_samples: &[T],\n                                                              pct: T) -> T {\n-    assert!(sorted_samples.len() != 0);\n+    assert!(!sorted_samples.is_empty());\n     if sorted_samples.len() == 1 {\n         return sorted_samples[0];\n     }"}, {"sha": "701187ed35a6f7c9573c7dcfb6706907eb6b5e61", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -157,7 +157,7 @@ impl<'a> Iterator for Graphemes<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         use tables::grapheme as gr;\n-        if self.string.len() == 0 {\n+        if self.string.is_empty() {\n             return None;\n         }\n \n@@ -257,7 +257,7 @@ impl<'a> DoubleEndedIterator for Graphemes<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         use tables::grapheme as gr;\n-        if self.string.len() == 0 {\n+        if self.string.is_empty() {\n             return None;\n         }\n "}, {"sha": "46caed6f9f5f59c482bf879de7af0abdf2427c47", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -43,7 +43,7 @@ fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n \n     if env::var_os(\"RUST_BENCH\").is_some() {\n         run_test = true\n-    } else if argv.len() > 0 {\n+    } else if !argv.is_empty() {\n         run_test = argv.iter().any(|x| x == &\"all\".to_string()) || argv.iter().any(|x| x == &name)\n     }\n \n@@ -60,7 +60,7 @@ fn shift_push() {\n     let mut v1 = repeat(1).take(30000).collect::<Vec<_>>();\n     let mut v2 = Vec::new();\n \n-    while v1.len() > 0 {\n+    while !v1.is_empty() {\n         v2.push(v1.remove(0));\n     }\n }"}, {"sha": "b777b25243ba6e8b1b48a778e03b640913982721", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -184,7 +184,7 @@ fn main() {\n    for line in rdr.lines() {\n        let line = line.unwrap().trim().to_string();\n \n-       if line.len() == 0 { continue; }\n+       if line.is_empty() { continue; }\n \n        match (line.as_bytes()[0] as char, proc_mode) {\n "}, {"sha": "c4af33da50c9462811ca99b143269b0454d5c877", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -252,7 +252,7 @@ fn generate_frequencies(mut input: &[u8], frame: usize) -> Table {\n     }\n     frequencies.lookup(code, BumpCallback);\n \n-    while input.len() != 0 && input[0] != ('>' as u8) {\n+    while !input.is_empty() && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n         input = &input[1..];"}, {"sha": "de7fb737958f2a1f3434b205aa411fe218d10471", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -196,7 +196,7 @@ fn shift_mut_ref<'a, T>(r: &mut &'a mut [T]) -> Option<&'a mut T> {\n     use std::mem;\n     use std::raw::Repr;\n \n-    if r.len() == 0 { return None }\n+    if r.is_empty() { return None }\n     unsafe {\n         let mut raw = r.repr();\n         let ret = raw.data as *mut T;"}, {"sha": "c5da5fc0c1a5e620fff5a1bf5e7e608ac3d331fe", "filename": "src/test/run-pass/dst-struct-sole.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct-sole.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -79,7 +79,7 @@ pub fn main() {\n \n     // Zero size vec.\n     let f5: &Fat<[isize]> = &Fat { ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n     let f5: &Fat<[Bar]> = &Fat { ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n }"}, {"sha": "92253d815958d0e223c869b182fdeb51e6c6e2bd", "filename": "src/test/run-pass/dst-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fdst-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-struct.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -98,9 +98,9 @@ pub fn main() {\n \n     // Zero size vec.\n     let f5: &Fat<[isize]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n     let f5: &Fat<[Bar]> = &Fat { f1: 5, f2: \"some str\", ptr: [] };\n-    assert!(f5.ptr.len() == 0);\n+    assert!(f5.ptr.is_empty());\n \n     // Deeply nested.\n     let f1 = Fat { f1: 5, f2: \"some str\", ptr: Fat { f1: 8, f2: \"deep str\", ptr: [1, 2, 3]} };"}, {"sha": "c854747bcf7bd2343a79762ab8ea3c8874662747", "filename": "src/test/run-pass/issue-12860.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fissue-12860.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12860.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -30,7 +30,7 @@ fn main() {\n     let middle = XYZ{x: 0, y: 0, z: 0};\n     border.insert(middle);\n \n-    while border.len() > 0 && connected.len() < 10000 {\n+    while !border.is_empty() && connected.len() < 10000 {\n         let choice = *(border.iter().next().unwrap());\n         border.remove(&choice);\n         connected.insert(choice);"}, {"sha": "0efa85e232bae4f1b3a50d7fe78756218386fc37", "filename": "src/test/run-pass/issue-3556.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "raw_url": "https://github.com/rust-lang/rust/raw/288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4/src%2Ftest%2Frun-pass%2Fissue-3556.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3556.rs?ref=288809c8f35d9b37f2e4f5c3ac168f56dbc3bbc4", "patch": "@@ -44,5 +44,5 @@ pub fn main()\n                     \"foo\".to_string(), \"foo\".to_string(), \"foo\".to_string(),\n                     \"foo\".to_string());\n     let v = format!(\"{:?}\", u);    // this is the line that causes the seg fault\n-    assert!(v.len() > 0);\n+    assert!(!v.is_empty());\n }"}]}