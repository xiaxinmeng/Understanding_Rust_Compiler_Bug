{"sha": "dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZmI0ZWU3MDI1NGVjNjk2ODAxY2JkYjIyZDJkZTJiYjFjOTM5ZWQ=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-23T14:24:07Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-02-23T14:36:38Z"}, "message": "Split ty.rs into several modules\n\nIt was just getting too big. We now have:\n\n - ty: the `Ty` enum and helpers\n - ty::infer: actual type inference\n - ty::lower: lowering from HIR to `Ty`\n - ty::op: helpers for binary operations, currently", "tree": {"sha": "8d36f12550779a0d51c46d706f96a09df16059a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d36f12550779a0d51c46d706f96a09df16059a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "html_url": "https://github.com/rust-lang/rust/commit/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "460ceb4cf2b8217abd002f8a30ef52f2aa25fee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/460ceb4cf2b8217abd002f8a30ef52f2aa25fee9", "html_url": "https://github.com/rust-lang/rust/commit/460ceb4cf2b8217abd002f8a30ef52f2aa25fee9"}], "stats": {"total": 2950, "additions": 1500, "deletions": 1450}, "files": [{"sha": "9d0b40ce0e00f2d36a00d4a485601447d49ee2fe", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "patch": "@@ -483,6 +483,10 @@ impl Function {\n         db.body_hir(*self)\n     }\n \n+    pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n+        db.type_for_def((*self).into(), Namespace::Values)\n+    }\n+\n     pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSyntaxMapping {\n         let scopes = db.expr_scopes(*self);\n         let syntax_mapping = db.body_syntax_mapping(*self);"}, {"sha": "e505c86e38761be941dc8f884d99a465df6cfe1a", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 18, "deletions": 1450, "changes": 1468, "blob_url": "https://github.com/rust-lang/rust/blob/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "patch": "@@ -1,171 +1,24 @@\n-//! The type system. We currently use this to infer types for completion.\n-//!\n-//! For type inference, compare the implementations in rustc (the various\n-//! check_* methods in librustc_typeck/check/mod.rs are a good entry point) and\n-//! IntelliJ-Rust (org.rust.lang.core.types.infer). Our entry point for\n-//! inference here is the `infer` function, which infers the types of all\n-//! expressions in a given function.\n-//!\n-//! The central struct here is `Ty`, which represents a type. During inference,\n-//! it can contain type 'variables' which represent currently unknown types; as\n-//! we walk through the expressions, we might determine that certain variables\n-//! need to be equal to each other, or to certain types. To record this, we use\n-//! the union-find implementation from the `ena` crate, which is extracted from\n-//! rustc.\n+//! The type system. We currently use this to infer types for completion, hover\n+//! information and various assists.\n \n mod autoderef;\n pub(crate) mod primitive;\n #[cfg(test)]\n mod tests;\n pub(crate) mod method_resolution;\n+mod op;\n+mod lower;\n+mod infer;\n \n-use std::borrow::Cow;\n-use std::iter::repeat;\n-use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n-use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n-use ra_arena::map::ArenaMap;\n use join_to_string::join;\n-use rustc_hash::FxHashMap;\n \n-use test_utils::tested_by;\n+use crate::{Name, AdtDef, type_ref::Mutability};\n \n-use crate::{\n-    Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n-    FnSignature, ModuleDef, AdtDef,\n-    HirDatabase,\n-    type_ref::{TypeRef, Mutability},\n-    name::{KnownName},\n-    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n-    generics::GenericParams,\n-    path::{ GenericArgs, GenericArg},\n-    adt::VariantDef,\n-    resolve::{Resolver, Resolution}, nameres::Namespace\n-};\n-\n-/// The ID of a type variable.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct TypeVarId(u32);\n-\n-impl UnifyKey for TypeVarId {\n-    type Value = TypeVarValue;\n-\n-    fn index(&self) -> u32 {\n-        self.0\n-    }\n-\n-    fn from_index(i: u32) -> Self {\n-        TypeVarId(i)\n-    }\n-\n-    fn tag() -> &'static str {\n-        \"TypeVarId\"\n-    }\n-}\n-\n-/// The value of a type variable: either we already know the type, or we don't\n-/// know it yet.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum TypeVarValue {\n-    Known(Ty),\n-    Unknown,\n-}\n-\n-impl TypeVarValue {\n-    fn known(&self) -> Option<&Ty> {\n-        match self {\n-            TypeVarValue::Known(ty) => Some(ty),\n-            TypeVarValue::Unknown => None,\n-        }\n-    }\n-}\n-\n-impl UnifyValue for TypeVarValue {\n-    type Error = NoError;\n-\n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n-        match (value1, value2) {\n-            // We should never equate two type variables, both of which have\n-            // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n-                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n-                t1, t2\n-            ),\n-\n-            // If one side is known, prefer that one.\n-            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n-            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n-\n-            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n-        }\n-    }\n-}\n-\n-/// The kinds of placeholders we need during type inference. There's separate\n-/// values for general types, and for integer and float variables. The latter\n-/// two are used for inference of literal values (e.g. `100` could be one of\n-/// several integer types).\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum InferTy {\n-    TypeVar(TypeVarId),\n-    IntVar(TypeVarId),\n-    FloatVar(TypeVarId),\n-}\n-\n-impl InferTy {\n-    fn to_inner(self) -> TypeVarId {\n-        match self {\n-            InferTy::TypeVar(ty) | InferTy::IntVar(ty) | InferTy::FloatVar(ty) => ty,\n-        }\n-    }\n-\n-    fn fallback_value(self) -> Ty {\n-        match self {\n-            InferTy::TypeVar(..) => Ty::Unknown,\n-            InferTy::IntVar(..) => {\n-                Ty::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32))\n-            }\n-            InferTy::FloatVar(..) => {\n-                Ty::Float(primitive::UncertainFloatTy::Known(primitive::FloatTy::F64))\n-            }\n-        }\n-    }\n-}\n-\n-/// When inferring an expression, we propagate downward whatever type hint we\n-/// are able in the form of an `Expectation`.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-struct Expectation {\n-    ty: Ty,\n-    // TODO: In some cases, we need to be aware whether the expectation is that\n-    // the type match exactly what we passed, or whether it just needs to be\n-    // coercible to the expected type. See Expectation::rvalue_hint in rustc.\n-}\n-\n-impl Expectation {\n-    /// The expectation that the type of the expression needs to equal the given\n-    /// type.\n-    fn has_type(ty: Ty) -> Self {\n-        Expectation { ty }\n-    }\n-\n-    /// This expresses no expectation on the type.\n-    fn none() -> Self {\n-        Expectation { ty: Ty::Unknown }\n-    }\n-}\n-\n-/// A list of substitutions for generic parameters.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Substs(Arc<[Ty]>);\n-\n-impl Substs {\n-    pub fn empty() -> Substs {\n-        Substs(Arc::new([]))\n-    }\n-}\n+pub(crate) use lower::{TypableDef, CallableDef, type_for_def, type_for_field};\n+pub(crate) use infer::{infer, InferenceResult, InferTy};\n \n /// A type. This is based on the `TyKind` enum in rustc (librustc/ty/sty.rs).\n ///\n@@ -295,6 +148,16 @@ pub enum Ty {\n     Unknown,\n }\n \n+/// A list of substitutions for generic parameters.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct Substs(Arc<[Ty]>);\n+\n+impl Substs {\n+    pub fn empty() -> Substs {\n+        Substs(Arc::new([]))\n+    }\n+}\n+\n /// A function signature.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct FnSig {\n@@ -303,150 +166,6 @@ pub struct FnSig {\n }\n \n impl Ty {\n-    pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n-        match type_ref {\n-            TypeRef::Never => Ty::Never,\n-            TypeRef::Tuple(inner) => {\n-                let inner_tys =\n-                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                Ty::Tuple(inner_tys.into())\n-            }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n-            TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::RawPtr(Arc::new(inner_ty), *mutability)\n-            }\n-            TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::Array(Arc::new(inner_ty))\n-            }\n-            TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::Slice(Arc::new(inner_ty))\n-            }\n-            TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, resolver, inner);\n-                Ty::Ref(Arc::new(inner_ty), *mutability)\n-            }\n-            TypeRef::Placeholder => Ty::Unknown,\n-            TypeRef::Fn(params) => {\n-                let mut inner_tys =\n-                    params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                let return_ty =\n-                    inner_tys.pop().expect(\"TypeRef::Fn should always have at least return type\");\n-                let sig = FnSig { input: inner_tys, output: return_ty };\n-                Ty::FnPtr(Arc::new(sig))\n-            }\n-            TypeRef::Error => Ty::Unknown,\n-        }\n-    }\n-\n-    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n-        if let Some(name) = path.as_ident() {\n-            // TODO handle primitive type names in resolver as well?\n-            if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n-                return Ty::Int(int_ty);\n-            } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n-                return Ty::Float(float_ty);\n-            } else if let Some(known) = name.as_known_name() {\n-                match known {\n-                    KnownName::Bool => return Ty::Bool,\n-                    KnownName::Char => return Ty::Char,\n-                    KnownName::Str => return Ty::Str,\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        // Resolve the path (in type namespace)\n-        let resolution = resolver.resolve_path(db, path).take_types();\n-\n-        let def = match resolution {\n-            Some(Resolution::Def(def)) => def,\n-            Some(Resolution::LocalBinding(..)) => {\n-                // this should never happen\n-                panic!(\"path resolved to local binding in type ns\");\n-            }\n-            Some(Resolution::GenericParam(idx)) => {\n-                return Ty::Param {\n-                    idx,\n-                    // TODO: maybe return name in resolution?\n-                    name: path\n-                        .as_ident()\n-                        .expect(\"generic param should be single-segment path\")\n-                        .clone(),\n-                };\n-            }\n-            Some(Resolution::SelfType(impl_block)) => {\n-                return impl_block.target_ty(db);\n-            }\n-            None => return Ty::Unknown,\n-        };\n-\n-        let typable: TypableDef = match def.into() {\n-            None => return Ty::Unknown,\n-            Some(it) => it,\n-        };\n-        let ty = db.type_for_def(typable, Namespace::Types);\n-        let substs = Ty::substs_from_path(db, resolver, path, typable);\n-        ty.apply_substs(substs)\n-    }\n-\n-    /// Collect generic arguments from a path into a `Substs`. See also\n-    /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n-    fn substs_from_path(\n-        db: &impl HirDatabase,\n-        resolver: &Resolver,\n-        path: &Path,\n-        resolved: TypableDef,\n-    ) -> Substs {\n-        let mut substs = Vec::new();\n-        let last = path.segments.last().expect(\"path should have at least one segment\");\n-        let (def_generics, segment) = match resolved {\n-            TypableDef::Function(func) => (func.generic_params(db), last),\n-            TypableDef::Struct(s) => (s.generic_params(db), last),\n-            TypableDef::Enum(e) => (e.generic_params(db), last),\n-            TypableDef::EnumVariant(var) => {\n-                // the generic args for an enum variant may be either specified\n-                // on the segment referring to the enum, or on the segment\n-                // referring to the variant. So `Option::<T>::None` and\n-                // `Option::None::<T>` are both allowed (though the former is\n-                // preferred). See also `def_ids_for_path_segments` in rustc.\n-                let len = path.segments.len();\n-                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n-                    // Option::<T>::None\n-                    &path.segments[len - 2]\n-                } else {\n-                    // Option::None::<T>\n-                    last\n-                };\n-                (var.parent_enum(db).generic_params(db), segment)\n-            }\n-        };\n-        let parent_param_count = def_generics.count_parent_params();\n-        substs.extend((0..parent_param_count).map(|_| Ty::Unknown));\n-        if let Some(generic_args) = &segment.args_and_bindings {\n-            // if args are provided, it should be all of them, but we can't rely on that\n-            let param_count = def_generics.params.len();\n-            for arg in generic_args.args.iter().take(param_count) {\n-                match arg {\n-                    GenericArg::Type(type_ref) => {\n-                        let ty = Ty::from_hir(db, resolver, type_ref);\n-                        substs.push(ty);\n-                    }\n-                }\n-            }\n-        }\n-        // add placeholders for args that were not provided\n-        // TODO: handle defaults\n-        let supplied_params = substs.len();\n-        for _ in supplied_params..def_generics.count_params_including_parent() {\n-            substs.push(Ty::Unknown);\n-        }\n-        assert_eq!(substs.len(), def_generics.count_params_including_parent());\n-        Substs(substs.into())\n-    }\n-\n     pub fn unit() -> Self {\n         Ty::Tuple(Arc::new([]))\n     }\n@@ -652,1154 +371,3 @@ impl fmt::Display for Ty {\n         }\n     }\n }\n-\n-// Functions returning declared types for items\n-\n-/// Compute the declared type of a function. This should not need to look at the\n-/// function body.\n-fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n-    let signature = def.signature(db);\n-    let resolver = def.resolver(db);\n-    let generics = def.generic_params(db);\n-    let name = def.name(db);\n-    let input =\n-        signature.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n-    let output = Ty::from_hir(db, &resolver, signature.ret_type());\n-    let sig = Arc::new(FnSig { input, output });\n-    let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), sig, name, substs }\n-}\n-\n-/// Compute the type of a tuple struct constructor.\n-fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n-    let var_data = def.variant_data(db);\n-    let fields = match var_data.fields() {\n-        Some(fields) => fields,\n-        None => return type_for_struct(db, def), // Unit struct\n-    };\n-    let resolver = def.resolver(db);\n-    let generics = def.generic_params(db);\n-    let name = def.name(db).unwrap_or_else(Name::missing);\n-    let input = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n-    let output = type_for_struct(db, def);\n-    let sig = Arc::new(FnSig { input, output });\n-    let substs = make_substs(&generics);\n-    Ty::FnDef { def: def.into(), sig, name, substs }\n-}\n-\n-/// Compute the type of a tuple enum variant constructor.\n-fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> Ty {\n-    let var_data = def.variant_data(db);\n-    let fields = match var_data.fields() {\n-        Some(fields) => fields,\n-        None => return type_for_enum(db, def.parent_enum(db)), // Unit variant\n-    };\n-    let resolver = def.parent_enum(db).resolver(db);\n-    let generics = def.parent_enum(db).generic_params(db);\n-    let name = def.name(db).unwrap_or_else(Name::missing);\n-    let input = fields\n-        .iter()\n-        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n-        .collect::<Vec<_>>();\n-    let substs = make_substs(&generics);\n-    let output = type_for_enum(db, def.parent_enum(db)).apply_substs(substs.clone());\n-    let sig = Arc::new(FnSig { input, output });\n-    Ty::FnDef { def: def.into(), sig, name, substs }\n-}\n-\n-fn make_substs(generics: &GenericParams) -> Substs {\n-    Substs(\n-        generics\n-            .params_including_parent()\n-            .into_iter()\n-            .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-            .collect::<Vec<_>>()\n-            .into(),\n-    )\n-}\n-\n-fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n-    let generics = s.generic_params(db);\n-    Ty::Adt {\n-        def_id: s.into(),\n-        name: s.name(db).unwrap_or_else(Name::missing),\n-        substs: make_substs(&generics),\n-    }\n-}\n-\n-fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n-    let generics = s.generic_params(db);\n-    Ty::Adt {\n-        def_id: s.into(),\n-        name: s.name(db).unwrap_or_else(Name::missing),\n-        substs: make_substs(&generics),\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum TypableDef {\n-    Function(Function),\n-    Struct(Struct),\n-    Enum(Enum),\n-    EnumVariant(EnumVariant),\n-}\n-impl_froms!(TypableDef: Function, Struct, Enum, EnumVariant);\n-\n-impl From<ModuleDef> for Option<TypableDef> {\n-    fn from(def: ModuleDef) -> Option<TypableDef> {\n-        let res = match def {\n-            ModuleDef::Function(f) => f.into(),\n-            ModuleDef::Struct(s) => s.into(),\n-            ModuleDef::Enum(e) => e.into(),\n-            ModuleDef::EnumVariant(v) => v.into(),\n-            ModuleDef::Const(_)\n-            | ModuleDef::Static(_)\n-            | ModuleDef::Module(_)\n-            | ModuleDef::Trait(_)\n-            | ModuleDef::Type(_) => return None,\n-        };\n-        Some(res)\n-    }\n-}\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum CallableDef {\n-    Function(Function),\n-    Struct(Struct),\n-    EnumVariant(EnumVariant),\n-}\n-impl_froms!(CallableDef: Function, Struct, EnumVariant);\n-\n-pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef, ns: Namespace) -> Ty {\n-    match (def, ns) {\n-        (TypableDef::Function(f), Namespace::Values) => type_for_fn(db, f),\n-        (TypableDef::Struct(s), Namespace::Types) => type_for_struct(db, s),\n-        (TypableDef::Struct(s), Namespace::Values) => type_for_struct_constructor(db, s),\n-        (TypableDef::Enum(e), Namespace::Types) => type_for_enum(db, e),\n-        (TypableDef::EnumVariant(v), Namespace::Values) => type_for_enum_variant_constructor(db, v),\n-\n-        // 'error' cases:\n-        (TypableDef::Function(_), Namespace::Types) => Ty::Unknown,\n-        (TypableDef::Enum(_), Namespace::Values) => Ty::Unknown,\n-        (TypableDef::EnumVariant(_), Namespace::Types) => Ty::Unknown,\n-    }\n-}\n-\n-pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n-    let parent_def = field.parent_def(db);\n-    let resolver = match parent_def {\n-        VariantDef::Struct(it) => it.resolver(db),\n-        VariantDef::EnumVariant(it) => it.parent_enum(db).resolver(db),\n-    };\n-    let var_data = parent_def.variant_data(db);\n-    let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n-    Ty::from_hir(db, &resolver, type_ref)\n-}\n-\n-/// The result of type inference: A mapping from expressions and patterns to types.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct InferenceResult {\n-    /// For each method call expr, records the function it resolves to.\n-    method_resolutions: FxHashMap<ExprId, Function>,\n-    /// For each field access expr, records the field it resolves to.\n-    field_resolutions: FxHashMap<ExprId, StructField>,\n-    type_of_expr: ArenaMap<ExprId, Ty>,\n-    type_of_pat: ArenaMap<PatId, Ty>,\n-}\n-\n-impl InferenceResult {\n-    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n-        self.method_resolutions.get(&expr).map(|it| *it)\n-    }\n-    pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n-        self.field_resolutions.get(&expr).map(|it| *it)\n-    }\n-}\n-\n-impl Index<ExprId> for InferenceResult {\n-    type Output = Ty;\n-\n-    fn index(&self, expr: ExprId) -> &Ty {\n-        self.type_of_expr.get(expr).unwrap_or(&Ty::Unknown)\n-    }\n-}\n-\n-impl Index<PatId> for InferenceResult {\n-    type Output = Ty;\n-\n-    fn index(&self, pat: PatId) -> &Ty {\n-        self.type_of_pat.get(pat).unwrap_or(&Ty::Unknown)\n-    }\n-}\n-\n-/// The inference context contains all information needed during type inference.\n-#[derive(Clone, Debug)]\n-struct InferenceContext<'a, D: HirDatabase> {\n-    db: &'a D,\n-    body: Arc<Body>,\n-    resolver: Resolver,\n-    var_unification_table: InPlaceUnificationTable<TypeVarId>,\n-    method_resolutions: FxHashMap<ExprId, Function>,\n-    field_resolutions: FxHashMap<ExprId, StructField>,\n-    type_of_expr: ArenaMap<ExprId, Ty>,\n-    type_of_pat: ArenaMap<PatId, Ty>,\n-    /// The return type of the function being inferred.\n-    return_ty: Ty,\n-}\n-\n-fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n-    match op {\n-        BinaryOp::BooleanOr\n-        | BinaryOp::BooleanAnd\n-        | BinaryOp::EqualityTest\n-        | BinaryOp::NegatedEqualityTest\n-        | BinaryOp::LesserEqualTest\n-        | BinaryOp::GreaterEqualTest\n-        | BinaryOp::LesserTest\n-        | BinaryOp::GreaterTest => Ty::Bool,\n-        BinaryOp::Assignment\n-        | BinaryOp::AddAssign\n-        | BinaryOp::SubAssign\n-        | BinaryOp::DivAssign\n-        | BinaryOp::MulAssign\n-        | BinaryOp::RemAssign\n-        | BinaryOp::ShrAssign\n-        | BinaryOp::ShlAssign\n-        | BinaryOp::BitAndAssign\n-        | BinaryOp::BitOrAssign\n-        | BinaryOp::BitXorAssign => Ty::unit(),\n-        BinaryOp::Addition\n-        | BinaryOp::Subtraction\n-        | BinaryOp::Multiplication\n-        | BinaryOp::Division\n-        | BinaryOp::Remainder\n-        | BinaryOp::LeftShift\n-        | BinaryOp::RightShift\n-        | BinaryOp::BitwiseAnd\n-        | BinaryOp::BitwiseOr\n-        | BinaryOp::BitwiseXor => match rhs_ty {\n-            Ty::Int(..)\n-            | Ty::Float(..)\n-            | Ty::Infer(InferTy::IntVar(..))\n-            | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n-            _ => Ty::Unknown,\n-        },\n-        BinaryOp::RangeRightOpen | BinaryOp::RangeRightClosed => Ty::Unknown,\n-    }\n-}\n-\n-fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n-    match op {\n-        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::Bool,\n-        BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n-            Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n-            _ => Ty::Unknown,\n-        },\n-        BinaryOp::LesserEqualTest\n-        | BinaryOp::GreaterEqualTest\n-        | BinaryOp::LesserTest\n-        | BinaryOp::GreaterTest\n-        | BinaryOp::AddAssign\n-        | BinaryOp::SubAssign\n-        | BinaryOp::DivAssign\n-        | BinaryOp::MulAssign\n-        | BinaryOp::RemAssign\n-        | BinaryOp::ShrAssign\n-        | BinaryOp::ShlAssign\n-        | BinaryOp::BitAndAssign\n-        | BinaryOp::BitOrAssign\n-        | BinaryOp::BitXorAssign\n-        | BinaryOp::Addition\n-        | BinaryOp::Subtraction\n-        | BinaryOp::Multiplication\n-        | BinaryOp::Division\n-        | BinaryOp::Remainder\n-        | BinaryOp::LeftShift\n-        | BinaryOp::RightShift\n-        | BinaryOp::BitwiseAnd\n-        | BinaryOp::BitwiseOr\n-        | BinaryOp::BitwiseXor => match lhs_ty {\n-            Ty::Int(..) | Ty::Float(..) => lhs_ty,\n-            _ => Ty::Unknown,\n-        },\n-        _ => Ty::Unknown,\n-    }\n-}\n-\n-impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n-        InferenceContext {\n-            method_resolutions: FxHashMap::default(),\n-            field_resolutions: FxHashMap::default(),\n-            type_of_expr: ArenaMap::default(),\n-            type_of_pat: ArenaMap::default(),\n-            var_unification_table: InPlaceUnificationTable::new(),\n-            return_ty: Ty::Unknown, // set in collect_fn_signature\n-            db,\n-            body,\n-            resolver,\n-        }\n-    }\n-\n-    fn resolve_all(mut self) -> InferenceResult {\n-        let mut tv_stack = Vec::new();\n-        let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n-        for ty in expr_types.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n-            *ty = resolved;\n-        }\n-        let mut pat_types = mem::replace(&mut self.type_of_pat, ArenaMap::default());\n-        for ty in pat_types.values_mut() {\n-            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n-            *ty = resolved;\n-        }\n-        InferenceResult {\n-            method_resolutions: self.method_resolutions,\n-            field_resolutions: self.field_resolutions,\n-            type_of_expr: expr_types,\n-            type_of_pat: pat_types,\n-        }\n-    }\n-\n-    fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {\n-        self.type_of_expr.insert(expr, ty);\n-    }\n-\n-    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n-        self.method_resolutions.insert(expr, func);\n-    }\n-\n-    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n-        self.field_resolutions.insert(expr, field);\n-    }\n-\n-    fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n-        self.type_of_pat.insert(pat, ty);\n-    }\n-\n-    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        let ty = Ty::from_hir(\n-            self.db,\n-            // TODO use right resolver for block\n-            &self.resolver,\n-            type_ref,\n-        );\n-        let ty = self.insert_type_vars(ty);\n-        ty\n-    }\n-\n-    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n-        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n-    }\n-\n-    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n-        self.unify_inner(ty1, ty2, 0)\n-    }\n-\n-    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        if depth > 1000 {\n-            // prevent stackoverflows\n-            panic!(\"infinite recursion in unification\");\n-        }\n-        if ty1 == ty2 {\n-            return true;\n-        }\n-        // try to resolve type vars first\n-        let ty1 = self.resolve_ty_shallow(ty1);\n-        let ty2 = self.resolve_ty_shallow(ty2);\n-        match (&*ty1, &*ty2) {\n-            (Ty::Unknown, ..) => true,\n-            (.., Ty::Unknown) => true,\n-            (Ty::Int(t1), Ty::Int(t2)) => match (t1, t2) {\n-                (primitive::UncertainIntTy::Unknown, _)\n-                | (_, primitive::UncertainIntTy::Unknown) => true,\n-                _ => t1 == t2,\n-            },\n-            (Ty::Float(t1), Ty::Float(t2)) => match (t1, t2) {\n-                (primitive::UncertainFloatTy::Unknown, _)\n-                | (_, primitive::UncertainFloatTy::Unknown) => true,\n-                _ => t1 == t2,\n-            },\n-            (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n-            (\n-                Ty::Adt { def_id: def_id1, substs: substs1, .. },\n-                Ty::Adt { def_id: def_id2, substs: substs2, .. },\n-            ) if def_id1 == def_id2 => self.unify_substs(substs1, substs2, depth + 1),\n-            (Ty::Slice(t1), Ty::Slice(t2)) => self.unify_inner(t1, t2, depth + 1),\n-            (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => {\n-                self.unify_inner(t1, t2, depth + 1)\n-            }\n-            (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify_inner(t1, t2, depth + 1),\n-            (Ty::FnPtr(sig1), Ty::FnPtr(sig2)) if sig1 == sig2 => true,\n-            (Ty::Tuple(ts1), Ty::Tuple(ts2)) if ts1.len() == ts2.len() => {\n-                ts1.iter().zip(ts2.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth + 1))\n-            }\n-            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n-            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n-            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n-                // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(*tv1, *tv2);\n-                true\n-            }\n-            (Ty::Infer(InferTy::TypeVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n-            | (Ty::Infer(InferTy::IntVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::IntVar(tv)))\n-            | (Ty::Infer(InferTy::FloatVar(tv)), other)\n-            | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n-                // the type var is unknown since we tried to resolve it\n-                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n-                true\n-            }\n-            _ => false,\n-        }\n-    }\n-\n-    fn new_type_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_integer_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    fn new_float_var(&mut self) -> Ty {\n-        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n-    }\n-\n-    /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n-    fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n-        match ty {\n-            Ty::Unknown => self.new_type_var(),\n-            Ty::Int(primitive::UncertainIntTy::Unknown) => self.new_integer_var(),\n-            Ty::Float(primitive::UncertainFloatTy::Unknown) => self.new_float_var(),\n-            _ => ty,\n-        }\n-    }\n-\n-    fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n-    }\n-\n-    /// Resolves the type as far as currently possible, replacing type variables\n-    /// by their known types. All types returned by the infer_* functions should\n-    /// be resolved as far as possible, i.e. contain no type variables with\n-    /// known type.\n-    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_as_possible);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    ty\n-                }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n-    /// If `ty` is a type variable with known type, returns that type;\n-    /// otherwise, return ty.\n-    fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n-        let mut ty = Cow::Borrowed(ty);\n-        // The type variable could resolve to a int/float variable. Hence try\n-        // resolving up to three times; each type of variable shouldn't occur\n-        // more than once\n-        for i in 0..3 {\n-            if i > 0 {\n-                tested_by!(type_var_resolves_to_int_var);\n-            }\n-            match &*ty {\n-                Ty::Infer(tv) => {\n-                    let inner = tv.to_inner();\n-                    match self.var_unification_table.probe_value(inner).known() {\n-                        Some(known_ty) => {\n-                            // The known_ty can't be a type var itself\n-                            ty = Cow::Owned(known_ty.clone());\n-                        }\n-                        _ => return ty,\n-                    }\n-                }\n-                _ => return ty,\n-            }\n-        }\n-        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n-        ty\n-    }\n-\n-    /// Resolves the type completely; type variables without known type are\n-    /// replaced by Ty::Unknown.\n-    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Infer(tv) => {\n-                let inner = tv.to_inner();\n-                if tv_stack.contains(&inner) {\n-                    tested_by!(type_var_cycles_resolve_completely);\n-                    // recursive type\n-                    return tv.fallback_value();\n-                }\n-                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n-                    // known_ty may contain other variables that are known by now\n-                    tv_stack.push(inner);\n-                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n-                    tv_stack.pop();\n-                    result\n-                } else {\n-                    tv.fallback_value()\n-                }\n-            }\n-            _ => ty,\n-        })\n-    }\n-\n-    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n-        let resolved = resolver.resolve_path_segments(self.db, &path);\n-\n-        let (def, remaining_index) = resolved.into_inner();\n-\n-        log::debug!(\n-            \"path {:?} resolved to {:?} with remaining index {:?}\",\n-            path,\n-            def,\n-            remaining_index\n-        );\n-\n-        // if the remaining_index is None, we expect the path\n-        // to be fully resolved, in this case we continue with\n-        // the default by attempting to `take_values\u00b4 from the resolution.\n-        // Otherwise the path was partially resolved, which means\n-        // we might have resolved into a type for which\n-        // we may find some associated item starting at the\n-        // path.segment pointed to by `remaining_index\u00b4\n-        let resolved =\n-            if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n-\n-        match resolved {\n-            Resolution::Def(def) => {\n-                let typable: Option<TypableDef> = def.into();\n-                let typable = typable?;\n-\n-                if let Some(remaining_index) = remaining_index {\n-                    let ty = self.db.type_for_def(typable, Namespace::Types);\n-                    // TODO: Keep resolving the segments\n-                    // if we have more segments to process\n-                    let segment = &path.segments[remaining_index];\n-\n-                    log::debug!(\"looking for path segment: {:?}\", segment);\n-\n-                    // Attempt to find an impl_item for the type which has a name matching\n-                    // the current segment\n-                    let ty = ty.iterate_impl_items(self.db, |item| match item {\n-                        crate::ImplItem::Method(func) => {\n-                            let sig = func.signature(self.db);\n-                            if segment.name == *sig.name() {\n-                                return Some(type_for_fn(self.db, func));\n-                            }\n-                            None\n-                        }\n-\n-                        // TODO: Resolve associated const\n-                        crate::ImplItem::Const(_) => None,\n-\n-                        // TODO: Resolve associated types\n-                        crate::ImplItem::Type(_) => None,\n-                    });\n-                    ty\n-                } else {\n-                    let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                    let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n-                    let ty = self.insert_type_vars(ty);\n-                    Some(ty)\n-                }\n-            }\n-            Resolution::LocalBinding(pat) => {\n-                let ty = self.type_of_pat.get(pat)?;\n-                let ty = self.resolve_ty_as_possible(&mut vec![], ty.clone());\n-                Some(ty)\n-            }\n-            Resolution::GenericParam(..) => {\n-                // generic params can't refer to values... yet\n-                None\n-            }\n-            Resolution::SelfType(_) => {\n-                log::error!(\"path expr {:?} resolved to Self type in values ns\", path);\n-                None\n-            }\n-        }\n-    }\n-\n-    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n-        let path = match path {\n-            Some(path) => path,\n-            None => return (Ty::Unknown, None),\n-        };\n-        let resolver = &self.resolver;\n-        let typable: Option<TypableDef> = match resolver.resolve_path(self.db, &path).take_types() {\n-            Some(Resolution::Def(def)) => def.into(),\n-            Some(Resolution::LocalBinding(..)) => {\n-                // this cannot happen\n-                log::error!(\"path resolved to local binding in type ns\");\n-                return (Ty::Unknown, None);\n-            }\n-            Some(Resolution::GenericParam(..)) => {\n-                // generic params can't be used in struct literals\n-                return (Ty::Unknown, None);\n-            }\n-            Some(Resolution::SelfType(..)) => {\n-                // TODO this is allowed in an impl for a struct, handle this\n-                return (Ty::Unknown, None);\n-            }\n-            None => return (Ty::Unknown, None),\n-        };\n-        let def = match typable {\n-            None => return (Ty::Unknown, None),\n-            Some(it) => it,\n-        };\n-        // TODO remove the duplication between here and `Ty::from_path`?\n-        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n-        match def {\n-            TypableDef::Struct(s) => {\n-                let ty = s.ty(self.db);\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(s.into()))\n-            }\n-            TypableDef::EnumVariant(var) => {\n-                let ty = var.parent_enum(self.db).ty(self.db);\n-                let ty = self.insert_type_vars(ty.apply_substs(substs));\n-                (ty, Some(var.into()))\n-            }\n-            TypableDef::Function(_) | TypableDef::Enum(_) => (Ty::Unknown, None),\n-        }\n-    }\n-\n-    fn infer_tuple_struct_pat(\n-        &mut self,\n-        path: Option<&Path>,\n-        subpats: &[PatId],\n-        expected: &Ty,\n-    ) -> Ty {\n-        let (ty, def) = self.resolve_variant(path);\n-\n-        self.unify(&ty, expected);\n-\n-        let substs = ty.substs().unwrap_or_else(Substs::empty);\n-\n-        for (i, &subpat) in subpats.iter().enumerate() {\n-            let expected_ty = def\n-                .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n-                .map_or(Ty::Unknown, |field| field.ty(self.db))\n-                .subst(&substs);\n-            self.infer_pat(subpat, &expected_ty);\n-        }\n-\n-        ty\n-    }\n-\n-    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n-        let (ty, def) = self.resolve_variant(path);\n-\n-        self.unify(&ty, expected);\n-\n-        let substs = ty.substs().unwrap_or_else(Substs::empty);\n-\n-        for subpat in subpats {\n-            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n-            let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n-            self.infer_pat(subpat.pat, &expected_ty);\n-        }\n-\n-        ty\n-    }\n-\n-    fn infer_pat(&mut self, pat: PatId, expected: &Ty) -> Ty {\n-        let body = Arc::clone(&self.body); // avoid borrow checker problem\n-\n-        let ty = match &body[pat] {\n-            Pat::Tuple(ref args) => {\n-                let expectations = match *expected {\n-                    Ty::Tuple(ref tuple_args) => &**tuple_args,\n-                    _ => &[],\n-                };\n-                let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n-\n-                let inner_tys = args\n-                    .iter()\n-                    .zip(expectations_iter)\n-                    .map(|(&pat, ty)| self.infer_pat(pat, ty))\n-                    .collect::<Vec<_>>()\n-                    .into();\n-\n-                Ty::Tuple(inner_tys)\n-            }\n-            Pat::Ref { pat, mutability } => {\n-                let expectation = match *expected {\n-                    Ty::Ref(ref sub_ty, exp_mut) => {\n-                        if *mutability != exp_mut {\n-                            // TODO: emit type error?\n-                        }\n-                        &**sub_ty\n-                    }\n-                    _ => &Ty::Unknown,\n-                };\n-                let subty = self.infer_pat(*pat, expectation);\n-                Ty::Ref(subty.into(), *mutability)\n-            }\n-            Pat::TupleStruct { path: ref p, args: ref subpats } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected)\n-            }\n-            Pat::Struct { path: ref p, args: ref fields } => {\n-                self.infer_struct_pat(p.as_ref(), fields, expected)\n-            }\n-            Pat::Path(path) => {\n-                // TODO use correct resolver for the surrounding expression\n-                let resolver = self.resolver.clone();\n-                self.infer_path_expr(&resolver, &path).unwrap_or(Ty::Unknown)\n-            }\n-            Pat::Bind { mode, name: _name, subpat } => {\n-                let inner_ty = if let Some(subpat) = subpat {\n-                    self.infer_pat(*subpat, expected)\n-                } else {\n-                    expected.clone()\n-                };\n-                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n-\n-                let bound_ty = match mode {\n-                    BindingAnnotation::Ref => Ty::Ref(inner_ty.clone().into(), Mutability::Shared),\n-                    BindingAnnotation::RefMut => Ty::Ref(inner_ty.clone().into(), Mutability::Mut),\n-                    BindingAnnotation::Mutable | BindingAnnotation::Unannotated => inner_ty.clone(),\n-                };\n-                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n-                self.write_pat_ty(pat, bound_ty);\n-                return inner_ty;\n-            }\n-            _ => Ty::Unknown,\n-        };\n-        // use a new type variable if we got Ty::Unknown here\n-        let ty = self.insert_type_vars_shallow(ty);\n-        self.unify(&ty, expected);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        self.write_pat_ty(pat, ty.clone());\n-        ty\n-    }\n-\n-    fn substs_for_method_call(\n-        &mut self,\n-        def_generics: Option<Arc<GenericParams>>,\n-        generic_args: &Option<GenericArgs>,\n-    ) -> Substs {\n-        let (parent_param_count, param_count) =\n-            def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n-        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n-        for _ in 0..parent_param_count {\n-            substs.push(Ty::Unknown);\n-        }\n-        // handle provided type arguments\n-        if let Some(generic_args) = generic_args {\n-            // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(param_count) {\n-                match arg {\n-                    GenericArg::Type(type_ref) => {\n-                        let ty = self.make_ty(type_ref);\n-                        substs.push(ty);\n-                    }\n-                }\n-            }\n-        };\n-        let supplied_params = substs.len();\n-        for _ in supplied_params..parent_param_count + param_count {\n-            substs.push(Ty::Unknown);\n-        }\n-        assert_eq!(substs.len(), parent_param_count + param_count);\n-        Substs(substs.into())\n-    }\n-\n-    fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n-        let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        let ty = match &body[tgt_expr] {\n-            Expr::Missing => Ty::Unknown,\n-            Expr::If { condition, then_branch, else_branch } => {\n-                // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n-                let then_ty = self.infer_expr(*then_branch, expected);\n-                match else_branch {\n-                    Some(else_branch) => {\n-                        self.infer_expr(*else_branch, expected);\n-                    }\n-                    None => {\n-                        // no else branch -> unit\n-                        self.unify(&then_ty, &Ty::unit()); // actually coerce\n-                    }\n-                };\n-                then_ty\n-            }\n-            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n-            Expr::Loop { body } => {\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                // TODO handle break with value\n-                Ty::Never\n-            }\n-            Expr::While { condition, body } => {\n-                // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                Ty::unit()\n-            }\n-            Expr::For { iterable, body, pat } => {\n-                let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-                self.infer_pat(*pat, &Ty::Unknown);\n-                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n-                Ty::unit()\n-            }\n-            Expr::Lambda { body, args, arg_types } => {\n-                assert_eq!(args.len(), arg_types.len());\n-\n-                for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n-                    let expected = if let Some(type_ref) = arg_type {\n-                        let ty = self.make_ty(type_ref);\n-                        ty\n-                    } else {\n-                        Ty::Unknown\n-                    };\n-                    self.infer_pat(*arg_pat, &expected);\n-                }\n-\n-                // TODO: infer lambda type etc.\n-                let _body_ty = self.infer_expr(*body, &Expectation::none());\n-                Ty::Unknown\n-            }\n-            Expr::Call { callee, args } => {\n-                let callee_ty = self.infer_expr(*callee, &Expectation::none());\n-                let (param_tys, ret_ty) = match &callee_ty {\n-                    Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n-                    Ty::FnDef { substs, sig, .. } => {\n-                        let ret_ty = sig.output.clone().subst(&substs);\n-                        let param_tys =\n-                            sig.input.iter().map(|ty| ty.clone().subst(&substs)).collect();\n-                        (param_tys, ret_ty)\n-                    }\n-                    _ => {\n-                        // not callable\n-                        // TODO report an error?\n-                        (Vec::new(), Ty::Unknown)\n-                    }\n-                };\n-                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param) in args.iter().zip(param_iter) {\n-                    self.infer_expr(*arg, &Expectation::has_type(param));\n-                }\n-                ret_ty\n-            }\n-            Expr::MethodCall { receiver, args, method_name, generic_args } => {\n-                let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n-                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n-                let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n-                    Some((ty, func)) => {\n-                        self.write_method_resolution(tgt_expr, func);\n-                        (\n-                            ty,\n-                            self.db.type_for_def(func.into(), Namespace::Values),\n-                            Some(func.generic_params(self.db)),\n-                        )\n-                    }\n-                    None => (Ty::Unknown, receiver_ty, None),\n-                };\n-                let substs = self.substs_for_method_call(def_generics, generic_args);\n-                let method_ty = method_ty.apply_substs(substs);\n-                let method_ty = self.insert_type_vars(method_ty);\n-                let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n-                    Ty::FnPtr(sig) => {\n-                        if !sig.input.is_empty() {\n-                            (sig.input[0].clone(), sig.input[1..].to_vec(), sig.output.clone())\n-                        } else {\n-                            (Ty::Unknown, Vec::new(), sig.output.clone())\n-                        }\n-                    }\n-                    Ty::FnDef { substs, sig, .. } => {\n-                        let ret_ty = sig.output.clone().subst(&substs);\n-\n-                        if !sig.input.is_empty() {\n-                            let mut arg_iter = sig.input.iter().map(|ty| ty.clone().subst(&substs));\n-                            let receiver_ty = arg_iter.next().unwrap();\n-                            (receiver_ty, arg_iter.collect(), ret_ty)\n-                        } else {\n-                            (Ty::Unknown, Vec::new(), ret_ty)\n-                        }\n-                    }\n-                    _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n-                };\n-                // Apply autoref so the below unification works correctly\n-                let actual_receiver_ty = match expected_receiver_ty {\n-                    Ty::Ref(_, mutability) => Ty::Ref(Arc::new(derefed_receiver_ty), mutability),\n-                    _ => derefed_receiver_ty,\n-                };\n-                self.unify(&expected_receiver_ty, &actual_receiver_ty);\n-\n-                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n-                for (arg, param) in args.iter().zip(param_iter) {\n-                    self.infer_expr(*arg, &Expectation::has_type(param));\n-                }\n-                ret_ty\n-            }\n-            Expr::Match { expr, arms } => {\n-                let expected = if expected.ty == Ty::Unknown {\n-                    Expectation::has_type(self.new_type_var())\n-                } else {\n-                    expected.clone()\n-                };\n-                let input_ty = self.infer_expr(*expr, &Expectation::none());\n-\n-                for arm in arms {\n-                    for &pat in &arm.pats {\n-                        let _pat_ty = self.infer_pat(pat, &input_ty);\n-                    }\n-                    if let Some(guard_expr) = arm.guard {\n-                        self.infer_expr(guard_expr, &Expectation::has_type(Ty::Bool));\n-                    }\n-                    self.infer_expr(arm.expr, &expected);\n-                }\n-\n-                expected.ty\n-            }\n-            Expr::Path(p) => {\n-                // TODO this could be more efficient...\n-                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n-                self.infer_path_expr(&resolver, p).unwrap_or(Ty::Unknown)\n-            }\n-            Expr::Continue => Ty::Never,\n-            Expr::Break { expr } => {\n-                if let Some(expr) = expr {\n-                    // TODO handle break with value\n-                    self.infer_expr(*expr, &Expectation::none());\n-                }\n-                Ty::Never\n-            }\n-            Expr::Return { expr } => {\n-                if let Some(expr) = expr {\n-                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n-                }\n-                Ty::Never\n-            }\n-            Expr::StructLit { path, fields, spread } => {\n-                let (ty, def_id) = self.resolve_variant(path.as_ref());\n-                let substs = ty.substs().unwrap_or_else(Substs::empty);\n-                for field in fields {\n-                    let field_ty = def_id\n-                        .and_then(|it| it.field(self.db, &field.name))\n-                        .map_or(Ty::Unknown, |field| field.ty(self.db))\n-                        .subst(&substs);\n-                    self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n-                }\n-                if let Some(expr) = spread {\n-                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n-                }\n-                ty\n-            }\n-            Expr::Field { expr, name } => {\n-                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n-                let ty = receiver_ty\n-                    .autoderef(self.db)\n-                    .find_map(|derefed_ty| match derefed_ty {\n-                        Ty::Tuple(fields) => {\n-                            let i = name.to_string().parse::<usize>().ok();\n-                            i.and_then(|i| fields.get(i).cloned())\n-                        }\n-                        Ty::Adt { def_id: AdtDef::Struct(s), ref substs, .. } => {\n-                            s.field(self.db, name).map(|field| {\n-                                self.write_field_resolution(tgt_expr, field);\n-                                field.ty(self.db).subst(substs)\n-                            })\n-                        }\n-                        _ => None,\n-                    })\n-                    .unwrap_or(Ty::Unknown);\n-                self.insert_type_vars(ty)\n-            }\n-            Expr::Try { expr } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                Ty::Unknown\n-            }\n-            Expr::Cast { expr, type_ref } => {\n-                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                let cast_ty = self.make_ty(type_ref);\n-                // TODO check the cast...\n-                cast_ty\n-            }\n-            Expr::Ref { expr, mutability } => {\n-                let expectation = if let Ty::Ref(ref subty, expected_mutability) = expected.ty {\n-                    if expected_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n-                        // TODO: throw type error - expected mut reference but found shared ref,\n-                        // which cannot be coerced\n-                    }\n-                    Expectation::has_type((**subty).clone())\n-                } else {\n-                    Expectation::none()\n-                };\n-                // TODO reference coercions etc.\n-                let inner_ty = self.infer_expr(*expr, &expectation);\n-                Ty::Ref(Arc::new(inner_ty), *mutability)\n-            }\n-            Expr::UnaryOp { expr, op } => {\n-                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n-                match op {\n-                    UnaryOp::Deref => {\n-                        if let Some(derefed_ty) = inner_ty.builtin_deref() {\n-                            derefed_ty\n-                        } else {\n-                            // TODO Deref::deref\n-                            Ty::Unknown\n-                        }\n-                    }\n-                    UnaryOp::Neg => {\n-                        match inner_ty {\n-                            Ty::Int(primitive::UncertainIntTy::Unknown)\n-                            | Ty::Int(primitive::UncertainIntTy::Signed(..))\n-                            | Ty::Infer(InferTy::IntVar(..))\n-                            | Ty::Infer(InferTy::FloatVar(..))\n-                            | Ty::Float(..) => inner_ty,\n-                            // TODO: resolve ops::Neg trait\n-                            _ => Ty::Unknown,\n-                        }\n-                    }\n-                    UnaryOp::Not => {\n-                        match inner_ty {\n-                            Ty::Bool | Ty::Int(_) | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n-                            // TODO: resolve ops::Not trait for inner_ty\n-                            _ => Ty::Unknown,\n-                        }\n-                    }\n-                }\n-            }\n-            Expr::BinaryOp { lhs, rhs, op } => match op {\n-                Some(op) => {\n-                    let lhs_expectation = match op {\n-                        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n-                            Expectation::has_type(Ty::Bool)\n-                        }\n-                        _ => Expectation::none(),\n-                    };\n-                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n-                    // TODO: find implementation of trait corresponding to operation\n-                    // symbol and resolve associated `Output` type\n-                    let rhs_expectation = binary_op_rhs_expectation(*op, lhs_ty);\n-                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n-\n-                    // TODO: similar as above, return ty is often associated trait type\n-                    binary_op_return_ty(*op, rhs_ty)\n-                }\n-                _ => Ty::Unknown,\n-            },\n-            Expr::Tuple { exprs } => {\n-                let mut ty_vec = Vec::with_capacity(exprs.len());\n-                for arg in exprs.iter() {\n-                    ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n-                }\n-\n-                Ty::Tuple(Arc::from(ty_vec))\n-            }\n-            Expr::Array { exprs } => {\n-                let elem_ty = match &expected.ty {\n-                    Ty::Slice(inner) | Ty::Array(inner) => Ty::clone(&inner),\n-                    _ => self.new_type_var(),\n-                };\n-\n-                for expr in exprs.iter() {\n-                    self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n-                }\n-\n-                Ty::Array(Arc::new(elem_ty))\n-            }\n-            Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::Bool,\n-                Literal::String(..) => Ty::Ref(Arc::new(Ty::Str), Mutability::Shared),\n-                Literal::ByteString(..) => {\n-                    let byte_type = Arc::new(Ty::Int(primitive::UncertainIntTy::Unsigned(\n-                        primitive::UintTy::U8,\n-                    )));\n-                    let slice_type = Arc::new(Ty::Slice(byte_type));\n-                    Ty::Ref(slice_type, Mutability::Shared)\n-                }\n-                Literal::Char(..) => Ty::Char,\n-                Literal::Int(_v, ty) => Ty::Int(*ty),\n-                Literal::Float(_v, ty) => Ty::Float(*ty),\n-            },\n-        };\n-        // use a new type variable if we got Ty::Unknown here\n-        let ty = self.insert_type_vars_shallow(ty);\n-        self.unify(&ty, &expected.ty);\n-        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n-        self.write_expr_ty(tgt_expr, ty.clone());\n-        ty\n-    }\n-\n-    fn infer_block(\n-        &mut self,\n-        statements: &[Statement],\n-        tail: Option<ExprId>,\n-        expected: &Expectation,\n-    ) -> Ty {\n-        for stmt in statements {\n-            match stmt {\n-                Statement::Let { pat, type_ref, initializer } => {\n-                    let decl_ty =\n-                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n-                    let decl_ty = self.insert_type_vars(decl_ty);\n-                    let ty = if let Some(expr) = initializer {\n-                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n-                        expr_ty\n-                    } else {\n-                        decl_ty\n-                    };\n-\n-                    self.infer_pat(*pat, &ty);\n-                }\n-                Statement::Expr(expr) => {\n-                    self.infer_expr(*expr, &Expectation::none());\n-                }\n-            }\n-        }\n-        let ty = if let Some(expr) = tail { self.infer_expr(expr, expected) } else { Ty::unit() };\n-        ty\n-    }\n-\n-    fn collect_fn_signature(&mut self, signature: &FnSignature) {\n-        let body = Arc::clone(&self.body); // avoid borrow checker problem\n-        for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n-            let ty = self.make_ty(type_ref);\n-\n-            self.infer_pat(*pat, &ty);\n-        }\n-        self.return_ty = self.make_ty(signature.ret_type());\n-    }\n-\n-    fn infer_body(&mut self) {\n-        self.infer_expr(self.body.body_expr(), &Expectation::has_type(self.return_ty.clone()));\n-    }\n-}\n-\n-pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n-    db.check_canceled();\n-    let body = func.body(db);\n-    let resolver = func.resolver(db);\n-    let mut ctx = InferenceContext::new(db, body, resolver);\n-\n-    let signature = func.signature(db);\n-    ctx.collect_fn_signature(&signature);\n-\n-    ctx.infer_body();\n-\n-    Arc::new(ctx.resolve_all())\n-}"}, {"sha": "6ee9080d3838879413604b8819d974253c346533", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "added", "additions": 1079, "deletions": 0, "changes": 1079, "blob_url": "https://github.com/rust-lang/rust/blob/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "patch": "@@ -0,0 +1,1079 @@\n+//! Type inference, i.e. the process of walking through the code and determining\n+//! the type of each expression and pattern.\n+//!\n+//! For type inference, compare the implementations in rustc (the various\n+//! check_* methods in librustc_typeck/check/mod.rs are a good entry point) and\n+//! IntelliJ-Rust (org.rust.lang.core.types.infer). Our entry point for\n+//! inference here is the `infer` function, which infers the types of all\n+//! expressions in a given function.\n+//!\n+//! During inference, types (i.e. the `Ty` struct) can contain type 'variables'\n+//! which represent currently unknown types; as we walk through the expressions,\n+//! we might determine that certain variables need to be equal to each other, or\n+//! to certain types. To record this, we use the union-find implementation from\n+//! the `ena` crate, which is extracted from rustc.\n+\n+use std::borrow::Cow;\n+use std::iter::repeat;\n+use std::ops::Index;\n+use std::sync::Arc;\n+use std::mem;\n+\n+use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n+use ra_arena::map::ArenaMap;\n+use rustc_hash::FxHashMap;\n+\n+use test_utils::tested_by;\n+\n+use crate::{\n+    Function, StructField, Path, Name,\n+    FnSignature, AdtDef,\n+    HirDatabase,\n+    type_ref::{TypeRef, Mutability},\n+    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n+    generics::GenericParams,\n+    path::{GenericArgs, GenericArg},\n+    adt::VariantDef,\n+    resolve::{Resolver, Resolution},\n+    nameres::Namespace\n+};\n+use super::{Ty, TypableDef, Substs, primitive, op};\n+\n+/// The entry point of type inference.\n+pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n+    db.check_canceled();\n+    let body = func.body(db);\n+    let resolver = func.resolver(db);\n+    let mut ctx = InferenceContext::new(db, body, resolver);\n+\n+    let signature = func.signature(db);\n+    ctx.collect_fn_signature(&signature);\n+\n+    ctx.infer_body();\n+\n+    Arc::new(ctx.resolve_all())\n+}\n+\n+/// The result of type inference: A mapping from expressions and patterns to types.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct InferenceResult {\n+    /// For each method call expr, records the function it resolves to.\n+    method_resolutions: FxHashMap<ExprId, Function>,\n+    /// For each field access expr, records the field it resolves to.\n+    field_resolutions: FxHashMap<ExprId, StructField>,\n+    pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n+    pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n+}\n+\n+impl InferenceResult {\n+    pub fn method_resolution(&self, expr: ExprId) -> Option<Function> {\n+        self.method_resolutions.get(&expr).map(|it| *it)\n+    }\n+    pub fn field_resolution(&self, expr: ExprId) -> Option<StructField> {\n+        self.field_resolutions.get(&expr).map(|it| *it)\n+    }\n+}\n+\n+impl Index<ExprId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, expr: ExprId) -> &Ty {\n+        self.type_of_expr.get(expr).unwrap_or(&Ty::Unknown)\n+    }\n+}\n+\n+impl Index<PatId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, pat: PatId) -> &Ty {\n+        self.type_of_pat.get(pat).unwrap_or(&Ty::Unknown)\n+    }\n+}\n+\n+/// The inference context contains all information needed during type inference.\n+#[derive(Clone, Debug)]\n+struct InferenceContext<'a, D: HirDatabase> {\n+    db: &'a D,\n+    body: Arc<Body>,\n+    resolver: Resolver,\n+    var_unification_table: InPlaceUnificationTable<TypeVarId>,\n+    method_resolutions: FxHashMap<ExprId, Function>,\n+    field_resolutions: FxHashMap<ExprId, StructField>,\n+    type_of_expr: ArenaMap<ExprId, Ty>,\n+    type_of_pat: ArenaMap<PatId, Ty>,\n+    /// The return type of the function being inferred.\n+    return_ty: Ty,\n+}\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n+        InferenceContext {\n+            method_resolutions: FxHashMap::default(),\n+            field_resolutions: FxHashMap::default(),\n+            type_of_expr: ArenaMap::default(),\n+            type_of_pat: ArenaMap::default(),\n+            var_unification_table: InPlaceUnificationTable::new(),\n+            return_ty: Ty::Unknown, // set in collect_fn_signature\n+            db,\n+            body,\n+            resolver,\n+        }\n+    }\n+\n+    fn resolve_all(mut self) -> InferenceResult {\n+        let mut tv_stack = Vec::new();\n+        let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n+        for ty in expr_types.values_mut() {\n+            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            *ty = resolved;\n+        }\n+        let mut pat_types = mem::replace(&mut self.type_of_pat, ArenaMap::default());\n+        for ty in pat_types.values_mut() {\n+            let resolved = self.resolve_ty_completely(&mut tv_stack, mem::replace(ty, Ty::Unknown));\n+            *ty = resolved;\n+        }\n+        InferenceResult {\n+            method_resolutions: self.method_resolutions,\n+            field_resolutions: self.field_resolutions,\n+            type_of_expr: expr_types,\n+            type_of_pat: pat_types,\n+        }\n+    }\n+\n+    fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {\n+        self.type_of_expr.insert(expr, ty);\n+    }\n+\n+    fn write_method_resolution(&mut self, expr: ExprId, func: Function) {\n+        self.method_resolutions.insert(expr, func);\n+    }\n+\n+    fn write_field_resolution(&mut self, expr: ExprId, field: StructField) {\n+        self.field_resolutions.insert(expr, field);\n+    }\n+\n+    fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n+        self.type_of_pat.insert(pat, ty);\n+    }\n+\n+    fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n+        let ty = Ty::from_hir(\n+            self.db,\n+            // TODO use right resolver for block\n+            &self.resolver,\n+            type_ref,\n+        );\n+        let ty = self.insert_type_vars(ty);\n+        ty\n+    }\n+\n+    fn unify_substs(&mut self, substs1: &Substs, substs2: &Substs, depth: usize) -> bool {\n+        substs1.0.iter().zip(substs2.0.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth))\n+    }\n+\n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n+        self.unify_inner(ty1, ty2, 0)\n+    }\n+\n+    fn unify_inner(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n+        if depth > 1000 {\n+            // prevent stackoverflows\n+            panic!(\"infinite recursion in unification\");\n+        }\n+        if ty1 == ty2 {\n+            return true;\n+        }\n+        // try to resolve type vars first\n+        let ty1 = self.resolve_ty_shallow(ty1);\n+        let ty2 = self.resolve_ty_shallow(ty2);\n+        match (&*ty1, &*ty2) {\n+            (Ty::Unknown, ..) => true,\n+            (.., Ty::Unknown) => true,\n+            (Ty::Int(t1), Ty::Int(t2)) => match (t1, t2) {\n+                (primitive::UncertainIntTy::Unknown, _)\n+                | (_, primitive::UncertainIntTy::Unknown) => true,\n+                _ => t1 == t2,\n+            },\n+            (Ty::Float(t1), Ty::Float(t2)) => match (t1, t2) {\n+                (primitive::UncertainFloatTy::Unknown, _)\n+                | (_, primitive::UncertainFloatTy::Unknown) => true,\n+                _ => t1 == t2,\n+            },\n+            (Ty::Bool, _) | (Ty::Str, _) | (Ty::Never, _) | (Ty::Char, _) => ty1 == ty2,\n+            (\n+                Ty::Adt { def_id: def_id1, substs: substs1, .. },\n+                Ty::Adt { def_id: def_id2, substs: substs2, .. },\n+            ) if def_id1 == def_id2 => self.unify_substs(substs1, substs2, depth + 1),\n+            (Ty::Slice(t1), Ty::Slice(t2)) => self.unify_inner(t1, t2, depth + 1),\n+            (Ty::RawPtr(t1, m1), Ty::RawPtr(t2, m2)) if m1 == m2 => {\n+                self.unify_inner(t1, t2, depth + 1)\n+            }\n+            (Ty::Ref(t1, m1), Ty::Ref(t2, m2)) if m1 == m2 => self.unify_inner(t1, t2, depth + 1),\n+            (Ty::FnPtr(sig1), Ty::FnPtr(sig2)) if sig1 == sig2 => true,\n+            (Ty::Tuple(ts1), Ty::Tuple(ts2)) if ts1.len() == ts2.len() => {\n+                ts1.iter().zip(ts2.iter()).all(|(t1, t2)| self.unify_inner(t1, t2, depth + 1))\n+            }\n+            (Ty::Infer(InferTy::TypeVar(tv1)), Ty::Infer(InferTy::TypeVar(tv2)))\n+            | (Ty::Infer(InferTy::IntVar(tv1)), Ty::Infer(InferTy::IntVar(tv2)))\n+            | (Ty::Infer(InferTy::FloatVar(tv1)), Ty::Infer(InferTy::FloatVar(tv2))) => {\n+                // both type vars are unknown since we tried to resolve them\n+                self.var_unification_table.union(*tv1, *tv2);\n+                true\n+            }\n+            (Ty::Infer(InferTy::TypeVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::TypeVar(tv)))\n+            | (Ty::Infer(InferTy::IntVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::IntVar(tv)))\n+            | (Ty::Infer(InferTy::FloatVar(tv)), other)\n+            | (other, Ty::Infer(InferTy::FloatVar(tv))) => {\n+                // the type var is unknown since we tried to resolve it\n+                self.var_unification_table.union_value(*tv, TypeVarValue::Known(other.clone()));\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn new_type_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::TypeVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    fn new_integer_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::IntVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    fn new_float_var(&mut self) -> Ty {\n+        Ty::Infer(InferTy::FloatVar(self.var_unification_table.new_key(TypeVarValue::Unknown)))\n+    }\n+\n+    /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n+    fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n+        match ty {\n+            Ty::Unknown => self.new_type_var(),\n+            Ty::Int(primitive::UncertainIntTy::Unknown) => self.new_integer_var(),\n+            Ty::Float(primitive::UncertainFloatTy::Unknown) => self.new_float_var(),\n+            _ => ty,\n+        }\n+    }\n+\n+    fn insert_type_vars(&mut self, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| self.insert_type_vars_shallow(ty))\n+    }\n+\n+    /// Resolves the type as far as currently possible, replacing type variables\n+    /// by their known types. All types returned by the infer_* functions should\n+    /// be resolved as far as possible, i.e. contain no type variables with\n+    /// known type.\n+    fn resolve_ty_as_possible(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_as_possible);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_as_possible(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    ty\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    /// If `ty` is a type variable with known type, returns that type;\n+    /// otherwise, return ty.\n+    fn resolve_ty_shallow<'b>(&mut self, ty: &'b Ty) -> Cow<'b, Ty> {\n+        let mut ty = Cow::Borrowed(ty);\n+        // The type variable could resolve to a int/float variable. Hence try\n+        // resolving up to three times; each type of variable shouldn't occur\n+        // more than once\n+        for i in 0..3 {\n+            if i > 0 {\n+                tested_by!(type_var_resolves_to_int_var);\n+            }\n+            match &*ty {\n+                Ty::Infer(tv) => {\n+                    let inner = tv.to_inner();\n+                    match self.var_unification_table.probe_value(inner).known() {\n+                        Some(known_ty) => {\n+                            // The known_ty can't be a type var itself\n+                            ty = Cow::Owned(known_ty.clone());\n+                        }\n+                        _ => return ty,\n+                    }\n+                }\n+                _ => return ty,\n+            }\n+        }\n+        log::error!(\"Inference variable still not resolved: {:?}\", ty);\n+        ty\n+    }\n+\n+    /// Resolves the type completely; type variables without known type are\n+    /// replaced by Ty::Unknown.\n+    fn resolve_ty_completely(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n+        ty.fold(&mut |ty| match ty {\n+            Ty::Infer(tv) => {\n+                let inner = tv.to_inner();\n+                if tv_stack.contains(&inner) {\n+                    tested_by!(type_var_cycles_resolve_completely);\n+                    // recursive type\n+                    return tv.fallback_value();\n+                }\n+                if let Some(known_ty) = self.var_unification_table.probe_value(inner).known() {\n+                    // known_ty may contain other variables that are known by now\n+                    tv_stack.push(inner);\n+                    let result = self.resolve_ty_completely(tv_stack, known_ty.clone());\n+                    tv_stack.pop();\n+                    result\n+                } else {\n+                    tv.fallback_value()\n+                }\n+            }\n+            _ => ty,\n+        })\n+    }\n+\n+    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n+        let resolved = resolver.resolve_path_segments(self.db, &path);\n+\n+        let (def, remaining_index) = resolved.into_inner();\n+\n+        log::debug!(\n+            \"path {:?} resolved to {:?} with remaining index {:?}\",\n+            path,\n+            def,\n+            remaining_index\n+        );\n+\n+        // if the remaining_index is None, we expect the path\n+        // to be fully resolved, in this case we continue with\n+        // the default by attempting to `take_values\u00b4 from the resolution.\n+        // Otherwise the path was partially resolved, which means\n+        // we might have resolved into a type for which\n+        // we may find some associated item starting at the\n+        // path.segment pointed to by `remaining_index\u00b4\n+        let resolved =\n+            if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n+\n+        match resolved {\n+            Resolution::Def(def) => {\n+                let typable: Option<TypableDef> = def.into();\n+                let typable = typable?;\n+\n+                if let Some(remaining_index) = remaining_index {\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n+                    // TODO: Keep resolving the segments\n+                    // if we have more segments to process\n+                    let segment = &path.segments[remaining_index];\n+\n+                    log::debug!(\"looking for path segment: {:?}\", segment);\n+\n+                    // Attempt to find an impl_item for the type which has a name matching\n+                    // the current segment\n+                    let ty = ty.iterate_impl_items(self.db, |item| match item {\n+                        crate::ImplItem::Method(func) => {\n+                            let sig = func.signature(self.db);\n+                            if segment.name == *sig.name() {\n+                                return Some(func.ty(self.db));\n+                            }\n+                            None\n+                        }\n+\n+                        // TODO: Resolve associated const\n+                        crate::ImplItem::Const(_) => None,\n+\n+                        // TODO: Resolve associated types\n+                        crate::ImplItem::Type(_) => None,\n+                    });\n+                    ty\n+                } else {\n+                    let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                    let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n+                    let ty = self.insert_type_vars(ty);\n+                    Some(ty)\n+                }\n+            }\n+            Resolution::LocalBinding(pat) => {\n+                let ty = self.type_of_pat.get(pat)?;\n+                let ty = self.resolve_ty_as_possible(&mut vec![], ty.clone());\n+                Some(ty)\n+            }\n+            Resolution::GenericParam(..) => {\n+                // generic params can't refer to values... yet\n+                None\n+            }\n+            Resolution::SelfType(_) => {\n+                log::error!(\"path expr {:?} resolved to Self type in values ns\", path);\n+                None\n+            }\n+        }\n+    }\n+\n+    fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n+        let path = match path {\n+            Some(path) => path,\n+            None => return (Ty::Unknown, None),\n+        };\n+        let resolver = &self.resolver;\n+        let typable: Option<TypableDef> = match resolver.resolve_path(self.db, &path).take_types() {\n+            Some(Resolution::Def(def)) => def.into(),\n+            Some(Resolution::LocalBinding(..)) => {\n+                // this cannot happen\n+                log::error!(\"path resolved to local binding in type ns\");\n+                return (Ty::Unknown, None);\n+            }\n+            Some(Resolution::GenericParam(..)) => {\n+                // generic params can't be used in struct literals\n+                return (Ty::Unknown, None);\n+            }\n+            Some(Resolution::SelfType(..)) => {\n+                // TODO this is allowed in an impl for a struct, handle this\n+                return (Ty::Unknown, None);\n+            }\n+            None => return (Ty::Unknown, None),\n+        };\n+        let def = match typable {\n+            None => return (Ty::Unknown, None),\n+            Some(it) => it,\n+        };\n+        // TODO remove the duplication between here and `Ty::from_path`?\n+        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n+        match def {\n+            TypableDef::Struct(s) => {\n+                let ty = s.ty(self.db);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                (ty, Some(s.into()))\n+            }\n+            TypableDef::EnumVariant(var) => {\n+                let ty = var.parent_enum(self.db).ty(self.db);\n+                let ty = self.insert_type_vars(ty.apply_substs(substs));\n+                (ty, Some(var.into()))\n+            }\n+            TypableDef::Function(_) | TypableDef::Enum(_) => (Ty::Unknown, None),\n+        }\n+    }\n+\n+    fn infer_tuple_struct_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[PatId],\n+        expected: &Ty,\n+    ) -> Ty {\n+        let (ty, def) = self.resolve_variant(path);\n+\n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().unwrap_or_else(Substs::empty);\n+\n+        for (i, &subpat) in subpats.iter().enumerate() {\n+            let expected_ty = def\n+                .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n+                .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                .subst(&substs);\n+            self.infer_pat(subpat, &expected_ty);\n+        }\n+\n+        ty\n+    }\n+\n+    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n+        let (ty, def) = self.resolve_variant(path);\n+\n+        self.unify(&ty, expected);\n+\n+        let substs = ty.substs().unwrap_or_else(Substs::empty);\n+\n+        for subpat in subpats {\n+            let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n+            let expected_ty =\n+                matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n+            self.infer_pat(subpat.pat, &expected_ty);\n+        }\n+\n+        ty\n+    }\n+\n+    fn infer_pat(&mut self, pat: PatId, expected: &Ty) -> Ty {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+\n+        let ty = match &body[pat] {\n+            Pat::Tuple(ref args) => {\n+                let expectations = match *expected {\n+                    Ty::Tuple(ref tuple_args) => &**tuple_args,\n+                    _ => &[],\n+                };\n+                let expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n+\n+                let inner_tys = args\n+                    .iter()\n+                    .zip(expectations_iter)\n+                    .map(|(&pat, ty)| self.infer_pat(pat, ty))\n+                    .collect::<Vec<_>>()\n+                    .into();\n+\n+                Ty::Tuple(inner_tys)\n+            }\n+            Pat::Ref { pat, mutability } => {\n+                let expectation = match *expected {\n+                    Ty::Ref(ref sub_ty, exp_mut) => {\n+                        if *mutability != exp_mut {\n+                            // TODO: emit type error?\n+                        }\n+                        &**sub_ty\n+                    }\n+                    _ => &Ty::Unknown,\n+                };\n+                let subty = self.infer_pat(*pat, expectation);\n+                Ty::Ref(subty.into(), *mutability)\n+            }\n+            Pat::TupleStruct { path: ref p, args: ref subpats } => {\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected)\n+            }\n+            Pat::Struct { path: ref p, args: ref fields } => {\n+                self.infer_struct_pat(p.as_ref(), fields, expected)\n+            }\n+            Pat::Path(path) => {\n+                // TODO use correct resolver for the surrounding expression\n+                let resolver = self.resolver.clone();\n+                self.infer_path_expr(&resolver, &path).unwrap_or(Ty::Unknown)\n+            }\n+            Pat::Bind { mode, name: _name, subpat } => {\n+                let inner_ty = if let Some(subpat) = subpat {\n+                    self.infer_pat(*subpat, expected)\n+                } else {\n+                    expected.clone()\n+                };\n+                let inner_ty = self.insert_type_vars_shallow(inner_ty);\n+\n+                let bound_ty = match mode {\n+                    BindingAnnotation::Ref => Ty::Ref(inner_ty.clone().into(), Mutability::Shared),\n+                    BindingAnnotation::RefMut => Ty::Ref(inner_ty.clone().into(), Mutability::Mut),\n+                    BindingAnnotation::Mutable | BindingAnnotation::Unannotated => inner_ty.clone(),\n+                };\n+                let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n+                self.write_pat_ty(pat, bound_ty);\n+                return inner_ty;\n+            }\n+            _ => Ty::Unknown,\n+        };\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        self.unify(&ty, expected);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        self.write_pat_ty(pat, ty.clone());\n+        ty\n+    }\n+\n+    fn substs_for_method_call(\n+        &mut self,\n+        def_generics: Option<Arc<GenericParams>>,\n+        generic_args: &Option<GenericArgs>,\n+    ) -> Substs {\n+        let (parent_param_count, param_count) =\n+            def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+        let mut substs = Vec::with_capacity(parent_param_count + param_count);\n+        for _ in 0..parent_param_count {\n+            substs.push(Ty::Unknown);\n+        }\n+        // handle provided type arguments\n+        if let Some(generic_args) = generic_args {\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            for arg in generic_args.args.iter().take(param_count) {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        let ty = self.make_ty(type_ref);\n+                        substs.push(ty);\n+                    }\n+                }\n+            }\n+        };\n+        let supplied_params = substs.len();\n+        for _ in supplied_params..parent_param_count + param_count {\n+            substs.push(Ty::Unknown);\n+        }\n+        assert_eq!(substs.len(), parent_param_count + param_count);\n+        Substs(substs.into())\n+    }\n+\n+    fn infer_expr(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        let ty = match &body[tgt_expr] {\n+            Expr::Missing => Ty::Unknown,\n+            Expr::If { condition, then_branch, else_branch } => {\n+                // if let is desugared to match, so this is always simple if\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                let then_ty = self.infer_expr(*then_branch, expected);\n+                match else_branch {\n+                    Some(else_branch) => {\n+                        self.infer_expr(*else_branch, expected);\n+                    }\n+                    None => {\n+                        // no else branch -> unit\n+                        self.unify(&then_ty, &Ty::unit()); // actually coerce\n+                    }\n+                };\n+                then_ty\n+            }\n+            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected),\n+            Expr::Loop { body } => {\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                // TODO handle break with value\n+                Ty::Never\n+            }\n+            Expr::While { condition, body } => {\n+                // while let is desugared to a match loop, so this is always simple while\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool));\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                Ty::unit()\n+            }\n+            Expr::For { iterable, body, pat } => {\n+                let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n+                self.infer_pat(*pat, &Ty::Unknown);\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n+                Ty::unit()\n+            }\n+            Expr::Lambda { body, args, arg_types } => {\n+                assert_eq!(args.len(), arg_types.len());\n+\n+                for (arg_pat, arg_type) in args.iter().zip(arg_types.iter()) {\n+                    let expected = if let Some(type_ref) = arg_type {\n+                        let ty = self.make_ty(type_ref);\n+                        ty\n+                    } else {\n+                        Ty::Unknown\n+                    };\n+                    self.infer_pat(*arg_pat, &expected);\n+                }\n+\n+                // TODO: infer lambda type etc.\n+                let _body_ty = self.infer_expr(*body, &Expectation::none());\n+                Ty::Unknown\n+            }\n+            Expr::Call { callee, args } => {\n+                let callee_ty = self.infer_expr(*callee, &Expectation::none());\n+                let (param_tys, ret_ty) = match &callee_ty {\n+                    Ty::FnPtr(sig) => (sig.input.clone(), sig.output.clone()),\n+                    Ty::FnDef { substs, sig, .. } => {\n+                        let ret_ty = sig.output.clone().subst(&substs);\n+                        let param_tys =\n+                            sig.input.iter().map(|ty| ty.clone().subst(&substs)).collect();\n+                        (param_tys, ret_ty)\n+                    }\n+                    _ => {\n+                        // not callable\n+                        // TODO report an error?\n+                        (Vec::new(), Ty::Unknown)\n+                    }\n+                };\n+                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+                for (arg, param) in args.iter().zip(param_iter) {\n+                    self.infer_expr(*arg, &Expectation::has_type(param));\n+                }\n+                ret_ty\n+            }\n+            Expr::MethodCall { receiver, args, method_name, generic_args } => {\n+                let receiver_ty = self.infer_expr(*receiver, &Expectation::none());\n+                let resolved = receiver_ty.clone().lookup_method(self.db, method_name);\n+                let (derefed_receiver_ty, method_ty, def_generics) = match resolved {\n+                    Some((ty, func)) => {\n+                        self.write_method_resolution(tgt_expr, func);\n+                        (\n+                            ty,\n+                            self.db.type_for_def(func.into(), Namespace::Values),\n+                            Some(func.generic_params(self.db)),\n+                        )\n+                    }\n+                    None => (Ty::Unknown, receiver_ty, None),\n+                };\n+                let substs = self.substs_for_method_call(def_generics, generic_args);\n+                let method_ty = method_ty.apply_substs(substs);\n+                let method_ty = self.insert_type_vars(method_ty);\n+                let (expected_receiver_ty, param_tys, ret_ty) = match &method_ty {\n+                    Ty::FnPtr(sig) => {\n+                        if !sig.input.is_empty() {\n+                            (sig.input[0].clone(), sig.input[1..].to_vec(), sig.output.clone())\n+                        } else {\n+                            (Ty::Unknown, Vec::new(), sig.output.clone())\n+                        }\n+                    }\n+                    Ty::FnDef { substs, sig, .. } => {\n+                        let ret_ty = sig.output.clone().subst(&substs);\n+\n+                        if !sig.input.is_empty() {\n+                            let mut arg_iter = sig.input.iter().map(|ty| ty.clone().subst(&substs));\n+                            let receiver_ty = arg_iter.next().unwrap();\n+                            (receiver_ty, arg_iter.collect(), ret_ty)\n+                        } else {\n+                            (Ty::Unknown, Vec::new(), ret_ty)\n+                        }\n+                    }\n+                    _ => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+                };\n+                // Apply autoref so the below unification works correctly\n+                let actual_receiver_ty = match expected_receiver_ty {\n+                    Ty::Ref(_, mutability) => Ty::Ref(Arc::new(derefed_receiver_ty), mutability),\n+                    _ => derefed_receiver_ty,\n+                };\n+                self.unify(&expected_receiver_ty, &actual_receiver_ty);\n+\n+                let param_iter = param_tys.into_iter().chain(repeat(Ty::Unknown));\n+                for (arg, param) in args.iter().zip(param_iter) {\n+                    self.infer_expr(*arg, &Expectation::has_type(param));\n+                }\n+                ret_ty\n+            }\n+            Expr::Match { expr, arms } => {\n+                let expected = if expected.ty == Ty::Unknown {\n+                    Expectation::has_type(self.new_type_var())\n+                } else {\n+                    expected.clone()\n+                };\n+                let input_ty = self.infer_expr(*expr, &Expectation::none());\n+\n+                for arm in arms {\n+                    for &pat in &arm.pats {\n+                        let _pat_ty = self.infer_pat(pat, &input_ty);\n+                    }\n+                    if let Some(guard_expr) = arm.guard {\n+                        self.infer_expr(guard_expr, &Expectation::has_type(Ty::Bool));\n+                    }\n+                    self.infer_expr(arm.expr, &expected);\n+                }\n+\n+                expected.ty\n+            }\n+            Expr::Path(p) => {\n+                // TODO this could be more efficient...\n+                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n+                self.infer_path_expr(&resolver, p).unwrap_or(Ty::Unknown)\n+            }\n+            Expr::Continue => Ty::Never,\n+            Expr::Break { expr } => {\n+                if let Some(expr) = expr {\n+                    // TODO handle break with value\n+                    self.infer_expr(*expr, &Expectation::none());\n+                }\n+                Ty::Never\n+            }\n+            Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()));\n+                }\n+                Ty::Never\n+            }\n+            Expr::StructLit { path, fields, spread } => {\n+                let (ty, def_id) = self.resolve_variant(path.as_ref());\n+                let substs = ty.substs().unwrap_or_else(Substs::empty);\n+                for field in fields {\n+                    let field_ty = def_id\n+                        .and_then(|it| it.field(self.db, &field.name))\n+                        .map_or(Ty::Unknown, |field| field.ty(self.db))\n+                        .subst(&substs);\n+                    self.infer_expr(field.expr, &Expectation::has_type(field_ty));\n+                }\n+                if let Some(expr) = spread {\n+                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()));\n+                }\n+                ty\n+            }\n+            Expr::Field { expr, name } => {\n+                let receiver_ty = self.infer_expr(*expr, &Expectation::none());\n+                let ty = receiver_ty\n+                    .autoderef(self.db)\n+                    .find_map(|derefed_ty| match derefed_ty {\n+                        Ty::Tuple(fields) => {\n+                            let i = name.to_string().parse::<usize>().ok();\n+                            i.and_then(|i| fields.get(i).cloned())\n+                        }\n+                        Ty::Adt { def_id: AdtDef::Struct(s), ref substs, .. } => {\n+                            s.field(self.db, name).map(|field| {\n+                                self.write_field_resolution(tgt_expr, field);\n+                                field.ty(self.db).subst(substs)\n+                            })\n+                        }\n+                        _ => None,\n+                    })\n+                    .unwrap_or(Ty::Unknown);\n+                self.insert_type_vars(ty)\n+            }\n+            Expr::Try { expr } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                Ty::Unknown\n+            }\n+            Expr::Cast { expr, type_ref } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                let cast_ty = self.make_ty(type_ref);\n+                // TODO check the cast...\n+                cast_ty\n+            }\n+            Expr::Ref { expr, mutability } => {\n+                let expectation = if let Ty::Ref(ref subty, expected_mutability) = expected.ty {\n+                    if expected_mutability == Mutability::Mut && *mutability == Mutability::Shared {\n+                        // TODO: throw type error - expected mut reference but found shared ref,\n+                        // which cannot be coerced\n+                    }\n+                    Expectation::has_type((**subty).clone())\n+                } else {\n+                    Expectation::none()\n+                };\n+                // TODO reference coercions etc.\n+                let inner_ty = self.infer_expr(*expr, &expectation);\n+                Ty::Ref(Arc::new(inner_ty), *mutability)\n+            }\n+            Expr::UnaryOp { expr, op } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none());\n+                match op {\n+                    UnaryOp::Deref => {\n+                        if let Some(derefed_ty) = inner_ty.builtin_deref() {\n+                            derefed_ty\n+                        } else {\n+                            // TODO Deref::deref\n+                            Ty::Unknown\n+                        }\n+                    }\n+                    UnaryOp::Neg => {\n+                        match inner_ty {\n+                            Ty::Int(primitive::UncertainIntTy::Unknown)\n+                            | Ty::Int(primitive::UncertainIntTy::Signed(..))\n+                            | Ty::Infer(InferTy::IntVar(..))\n+                            | Ty::Infer(InferTy::FloatVar(..))\n+                            | Ty::Float(..) => inner_ty,\n+                            // TODO: resolve ops::Neg trait\n+                            _ => Ty::Unknown,\n+                        }\n+                    }\n+                    UnaryOp::Not => {\n+                        match inner_ty {\n+                            Ty::Bool | Ty::Int(_) | Ty::Infer(InferTy::IntVar(..)) => inner_ty,\n+                            // TODO: resolve ops::Not trait for inner_ty\n+                            _ => Ty::Unknown,\n+                        }\n+                    }\n+                }\n+            }\n+            Expr::BinaryOp { lhs, rhs, op } => match op {\n+                Some(op) => {\n+                    let lhs_expectation = match op {\n+                        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n+                            Expectation::has_type(Ty::Bool)\n+                        }\n+                        _ => Expectation::none(),\n+                    };\n+                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n+                    // TODO: find implementation of trait corresponding to operation\n+                    // symbol and resolve associated `Output` type\n+                    let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty);\n+                    let rhs_ty = self.infer_expr(*rhs, &Expectation::has_type(rhs_expectation));\n+\n+                    // TODO: similar as above, return ty is often associated trait type\n+                    op::binary_op_return_ty(*op, rhs_ty)\n+                }\n+                _ => Ty::Unknown,\n+            },\n+            Expr::Tuple { exprs } => {\n+                let mut ty_vec = Vec::with_capacity(exprs.len());\n+                for arg in exprs.iter() {\n+                    ty_vec.push(self.infer_expr(*arg, &Expectation::none()));\n+                }\n+\n+                Ty::Tuple(Arc::from(ty_vec))\n+            }\n+            Expr::Array { exprs } => {\n+                let elem_ty = match &expected.ty {\n+                    Ty::Slice(inner) | Ty::Array(inner) => Ty::clone(&inner),\n+                    _ => self.new_type_var(),\n+                };\n+\n+                for expr in exprs.iter() {\n+                    self.infer_expr(*expr, &Expectation::has_type(elem_ty.clone()));\n+                }\n+\n+                Ty::Array(Arc::new(elem_ty))\n+            }\n+            Expr::Literal(lit) => match lit {\n+                Literal::Bool(..) => Ty::Bool,\n+                Literal::String(..) => Ty::Ref(Arc::new(Ty::Str), Mutability::Shared),\n+                Literal::ByteString(..) => {\n+                    let byte_type = Arc::new(Ty::Int(primitive::UncertainIntTy::Unsigned(\n+                        primitive::UintTy::U8,\n+                    )));\n+                    let slice_type = Arc::new(Ty::Slice(byte_type));\n+                    Ty::Ref(slice_type, Mutability::Shared)\n+                }\n+                Literal::Char(..) => Ty::Char,\n+                Literal::Int(_v, ty) => Ty::Int(*ty),\n+                Literal::Float(_v, ty) => Ty::Float(*ty),\n+            },\n+        };\n+        // use a new type variable if we got Ty::Unknown here\n+        let ty = self.insert_type_vars_shallow(ty);\n+        self.unify(&ty, &expected.ty);\n+        let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n+        self.write_expr_ty(tgt_expr, ty.clone());\n+        ty\n+    }\n+\n+    fn infer_block(\n+        &mut self,\n+        statements: &[Statement],\n+        tail: Option<ExprId>,\n+        expected: &Expectation,\n+    ) -> Ty {\n+        for stmt in statements {\n+            match stmt {\n+                Statement::Let { pat, type_ref, initializer } => {\n+                    let decl_ty =\n+                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n+                    let decl_ty = self.insert_type_vars(decl_ty);\n+                    let ty = if let Some(expr) = initializer {\n+                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty));\n+                        expr_ty\n+                    } else {\n+                        decl_ty\n+                    };\n+\n+                    self.infer_pat(*pat, &ty);\n+                }\n+                Statement::Expr(expr) => {\n+                    self.infer_expr(*expr, &Expectation::none());\n+                }\n+            }\n+        }\n+        let ty = if let Some(expr) = tail { self.infer_expr(expr, expected) } else { Ty::unit() };\n+        ty\n+    }\n+\n+    fn collect_fn_signature(&mut self, signature: &FnSignature) {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n+            let ty = self.make_ty(type_ref);\n+\n+            self.infer_pat(*pat, &ty);\n+        }\n+        self.return_ty = self.make_ty(signature.ret_type());\n+    }\n+\n+    fn infer_body(&mut self) {\n+        self.infer_expr(self.body.body_expr(), &Expectation::has_type(self.return_ty.clone()));\n+    }\n+}\n+\n+/// The ID of a type variable.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct TypeVarId(u32);\n+\n+impl UnifyKey for TypeVarId {\n+    type Value = TypeVarValue;\n+\n+    fn index(&self) -> u32 {\n+        self.0\n+    }\n+\n+    fn from_index(i: u32) -> Self {\n+        TypeVarId(i)\n+    }\n+\n+    fn tag() -> &'static str {\n+        \"TypeVarId\"\n+    }\n+}\n+\n+/// The value of a type variable: either we already know the type, or we don't\n+/// know it yet.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum TypeVarValue {\n+    Known(Ty),\n+    Unknown,\n+}\n+\n+impl TypeVarValue {\n+    fn known(&self) -> Option<&Ty> {\n+        match self {\n+            TypeVarValue::Known(ty) => Some(ty),\n+            TypeVarValue::Unknown => None,\n+        }\n+    }\n+}\n+\n+impl UnifyValue for TypeVarValue {\n+    type Error = NoError;\n+\n+    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, NoError> {\n+        match (value1, value2) {\n+            // We should never equate two type variables, both of which have\n+            // known types. Instead, we recursively equate those types.\n+            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n+                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n+                t1, t2\n+            ),\n+\n+            // If one side is known, prefer that one.\n+            (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n+            (TypeVarValue::Unknown, TypeVarValue::Known(..)) => Ok(value2.clone()),\n+\n+            (TypeVarValue::Unknown, TypeVarValue::Unknown) => Ok(TypeVarValue::Unknown),\n+        }\n+    }\n+}\n+\n+/// The kinds of placeholders we need during type inference. There's separate\n+/// values for general types, and for integer and float variables. The latter\n+/// two are used for inference of literal values (e.g. `100` could be one of\n+/// several integer types).\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum InferTy {\n+    TypeVar(TypeVarId),\n+    IntVar(TypeVarId),\n+    FloatVar(TypeVarId),\n+}\n+\n+impl InferTy {\n+    fn to_inner(self) -> TypeVarId {\n+        match self {\n+            InferTy::TypeVar(ty) | InferTy::IntVar(ty) | InferTy::FloatVar(ty) => ty,\n+        }\n+    }\n+\n+    fn fallback_value(self) -> Ty {\n+        match self {\n+            InferTy::TypeVar(..) => Ty::Unknown,\n+            InferTy::IntVar(..) => {\n+                Ty::Int(primitive::UncertainIntTy::Signed(primitive::IntTy::I32))\n+            }\n+            InferTy::FloatVar(..) => {\n+                Ty::Float(primitive::UncertainFloatTy::Known(primitive::FloatTy::F64))\n+            }\n+        }\n+    }\n+}\n+\n+/// When inferring an expression, we propagate downward whatever type hint we\n+/// are able in the form of an `Expectation`.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+struct Expectation {\n+    ty: Ty,\n+    // TODO: In some cases, we need to be aware whether the expectation is that\n+    // the type match exactly what we passed, or whether it just needs to be\n+    // coercible to the expected type. See Expectation::rvalue_hint in rustc.\n+}\n+\n+impl Expectation {\n+    /// The expectation that the type of the expression needs to equal the given\n+    /// type.\n+    fn has_type(ty: Ty) -> Self {\n+        Expectation { ty }\n+    }\n+\n+    /// This expresses no expectation on the type.\n+    fn none() -> Self {\n+        Expectation { ty: Ty::Unknown }\n+    }\n+}"}, {"sha": "cc9e0fd40e20b9a96e8e44d87210e018fd9d742f", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "added", "additions": 318, "deletions": 0, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "patch": "@@ -0,0 +1,318 @@\n+//! Methods for lowering the HIR to types. There are two main cases here:\n+//!\n+//!  - Lowering a type reference like `&usize` or `Option<foo::bar::Baz>` to a\n+//!    type: The entry point for this is `Ty::from_hir`.\n+//!  - Building the type for an item: This happens through the `type_for_def` query.\n+//!\n+//! This usually involves resolving names, collecting generic arguments etc.\n+\n+use std::sync::Arc;\n+\n+use crate::{\n+    Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n+    ModuleDef,\n+    HirDatabase,\n+    type_ref::TypeRef,\n+    name::KnownName,\n+    nameres::Namespace,\n+    resolve::{Resolver, Resolution},\n+    path::GenericArg,\n+    generics::GenericParams,\n+    adt::VariantDef,\n+};\n+use super::{Ty, primitive, FnSig, Substs};\n+\n+impl Ty {\n+    pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n+        match type_ref {\n+            TypeRef::Never => Ty::Never,\n+            TypeRef::Tuple(inner) => {\n+                let inner_tys =\n+                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n+                Ty::Tuple(inner_tys.into())\n+            }\n+            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n+            TypeRef::RawPtr(inner, mutability) => {\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                Ty::RawPtr(Arc::new(inner_ty), *mutability)\n+            }\n+            TypeRef::Array(inner) => {\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                Ty::Array(Arc::new(inner_ty))\n+            }\n+            TypeRef::Slice(inner) => {\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                Ty::Slice(Arc::new(inner_ty))\n+            }\n+            TypeRef::Reference(inner, mutability) => {\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n+                Ty::Ref(Arc::new(inner_ty), *mutability)\n+            }\n+            TypeRef::Placeholder => Ty::Unknown,\n+            TypeRef::Fn(params) => {\n+                let mut inner_tys =\n+                    params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n+                let return_ty =\n+                    inner_tys.pop().expect(\"TypeRef::Fn should always have at least return type\");\n+                let sig = FnSig { input: inner_tys, output: return_ty };\n+                Ty::FnPtr(Arc::new(sig))\n+            }\n+            TypeRef::Error => Ty::Unknown,\n+        }\n+    }\n+\n+    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n+        if let Some(name) = path.as_ident() {\n+            // TODO handle primitive type names in resolver as well?\n+            if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n+                return Ty::Int(int_ty);\n+            } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n+                return Ty::Float(float_ty);\n+            } else if let Some(known) = name.as_known_name() {\n+                match known {\n+                    KnownName::Bool => return Ty::Bool,\n+                    KnownName::Char => return Ty::Char,\n+                    KnownName::Str => return Ty::Str,\n+                    _ => {}\n+                }\n+            }\n+        }\n+\n+        // Resolve the path (in type namespace)\n+        let resolution = resolver.resolve_path(db, path).take_types();\n+\n+        let def = match resolution {\n+            Some(Resolution::Def(def)) => def,\n+            Some(Resolution::LocalBinding(..)) => {\n+                // this should never happen\n+                panic!(\"path resolved to local binding in type ns\");\n+            }\n+            Some(Resolution::GenericParam(idx)) => {\n+                return Ty::Param {\n+                    idx,\n+                    // TODO: maybe return name in resolution?\n+                    name: path\n+                        .as_ident()\n+                        .expect(\"generic param should be single-segment path\")\n+                        .clone(),\n+                };\n+            }\n+            Some(Resolution::SelfType(impl_block)) => {\n+                return impl_block.target_ty(db);\n+            }\n+            None => return Ty::Unknown,\n+        };\n+\n+        let typable: TypableDef = match def.into() {\n+            None => return Ty::Unknown,\n+            Some(it) => it,\n+        };\n+        let ty = db.type_for_def(typable, Namespace::Types);\n+        let substs = Ty::substs_from_path(db, resolver, path, typable);\n+        ty.apply_substs(substs)\n+    }\n+\n+    /// Collect generic arguments from a path into a `Substs`. See also\n+    /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n+    pub(super) fn substs_from_path(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        path: &Path,\n+        resolved: TypableDef,\n+    ) -> Substs {\n+        let mut substs = Vec::new();\n+        let last = path.segments.last().expect(\"path should have at least one segment\");\n+        let (def_generics, segment) = match resolved {\n+            TypableDef::Function(func) => (func.generic_params(db), last),\n+            TypableDef::Struct(s) => (s.generic_params(db), last),\n+            TypableDef::Enum(e) => (e.generic_params(db), last),\n+            TypableDef::EnumVariant(var) => {\n+                // the generic args for an enum variant may be either specified\n+                // on the segment referring to the enum, or on the segment\n+                // referring to the variant. So `Option::<T>::None` and\n+                // `Option::None::<T>` are both allowed (though the former is\n+                // preferred). See also `def_ids_for_path_segments` in rustc.\n+                let len = path.segments.len();\n+                let segment = if len >= 2 && path.segments[len - 2].args_and_bindings.is_some() {\n+                    // Option::<T>::None\n+                    &path.segments[len - 2]\n+                } else {\n+                    // Option::None::<T>\n+                    last\n+                };\n+                (var.parent_enum(db).generic_params(db), segment)\n+            }\n+        };\n+        let parent_param_count = def_generics.count_parent_params();\n+        substs.extend((0..parent_param_count).map(|_| Ty::Unknown));\n+        if let Some(generic_args) = &segment.args_and_bindings {\n+            // if args are provided, it should be all of them, but we can't rely on that\n+            let param_count = def_generics.params.len();\n+            for arg in generic_args.args.iter().take(param_count) {\n+                match arg {\n+                    GenericArg::Type(type_ref) => {\n+                        let ty = Ty::from_hir(db, resolver, type_ref);\n+                        substs.push(ty);\n+                    }\n+                }\n+            }\n+        }\n+        // add placeholders for args that were not provided\n+        // TODO: handle defaults\n+        let supplied_params = substs.len();\n+        for _ in supplied_params..def_generics.count_params_including_parent() {\n+            substs.push(Ty::Unknown);\n+        }\n+        assert_eq!(substs.len(), def_generics.count_params_including_parent());\n+        Substs(substs.into())\n+    }\n+}\n+\n+/// Build the declared type of an item. This depends on the namespace; e.g. for\n+/// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n+/// the constructor function `(usize) -> Foo` which lives in the values\n+/// namespace.\n+pub(crate) fn type_for_def(db: &impl HirDatabase, def: TypableDef, ns: Namespace) -> Ty {\n+    match (def, ns) {\n+        (TypableDef::Function(f), Namespace::Values) => type_for_fn(db, f),\n+        (TypableDef::Struct(s), Namespace::Types) => type_for_struct(db, s),\n+        (TypableDef::Struct(s), Namespace::Values) => type_for_struct_constructor(db, s),\n+        (TypableDef::Enum(e), Namespace::Types) => type_for_enum(db, e),\n+        (TypableDef::EnumVariant(v), Namespace::Values) => type_for_enum_variant_constructor(db, v),\n+\n+        // 'error' cases:\n+        (TypableDef::Function(_), Namespace::Types) => Ty::Unknown,\n+        (TypableDef::Enum(_), Namespace::Values) => Ty::Unknown,\n+        (TypableDef::EnumVariant(_), Namespace::Types) => Ty::Unknown,\n+    }\n+}\n+\n+/// Build the type of a specific field of a struct or enum variant.\n+pub(crate) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n+    let parent_def = field.parent_def(db);\n+    let resolver = match parent_def {\n+        VariantDef::Struct(it) => it.resolver(db),\n+        VariantDef::EnumVariant(it) => it.parent_enum(db).resolver(db),\n+    };\n+    let var_data = parent_def.variant_data(db);\n+    let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n+    Ty::from_hir(db, &resolver, type_ref)\n+}\n+\n+/// Build the declared type of a function. This should not need to look at the\n+/// function body.\n+fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n+    let signature = def.signature(db);\n+    let resolver = def.resolver(db);\n+    let generics = def.generic_params(db);\n+    let name = def.name(db);\n+    let input =\n+        signature.params().iter().map(|tr| Ty::from_hir(db, &resolver, tr)).collect::<Vec<_>>();\n+    let output = Ty::from_hir(db, &resolver, signature.ret_type());\n+    let sig = Arc::new(FnSig { input, output });\n+    let substs = make_substs(&generics);\n+    Ty::FnDef { def: def.into(), sig, name, substs }\n+}\n+\n+/// Build the type of a tuple struct constructor.\n+fn type_for_struct_constructor(db: &impl HirDatabase, def: Struct) -> Ty {\n+    let var_data = def.variant_data(db);\n+    let fields = match var_data.fields() {\n+        Some(fields) => fields,\n+        None => return type_for_struct(db, def), // Unit struct\n+    };\n+    let resolver = def.resolver(db);\n+    let generics = def.generic_params(db);\n+    let name = def.name(db).unwrap_or_else(Name::missing);\n+    let input = fields\n+        .iter()\n+        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n+        .collect::<Vec<_>>();\n+    let output = type_for_struct(db, def);\n+    let sig = Arc::new(FnSig { input, output });\n+    let substs = make_substs(&generics);\n+    Ty::FnDef { def: def.into(), sig, name, substs }\n+}\n+\n+/// Build the type of a tuple enum variant constructor.\n+fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariant) -> Ty {\n+    let var_data = def.variant_data(db);\n+    let fields = match var_data.fields() {\n+        Some(fields) => fields,\n+        None => return type_for_enum(db, def.parent_enum(db)), // Unit variant\n+    };\n+    let resolver = def.parent_enum(db).resolver(db);\n+    let generics = def.parent_enum(db).generic_params(db);\n+    let name = def.name(db).unwrap_or_else(Name::missing);\n+    let input = fields\n+        .iter()\n+        .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n+        .collect::<Vec<_>>();\n+    let substs = make_substs(&generics);\n+    let output = type_for_enum(db, def.parent_enum(db)).apply_substs(substs.clone());\n+    let sig = Arc::new(FnSig { input, output });\n+    Ty::FnDef { def: def.into(), sig, name, substs }\n+}\n+\n+fn make_substs(generics: &GenericParams) -> Substs {\n+    Substs(\n+        generics\n+            .params_including_parent()\n+            .into_iter()\n+            .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n+            .collect::<Vec<_>>()\n+            .into(),\n+    )\n+}\n+\n+fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Ty {\n+    let generics = s.generic_params(db);\n+    Ty::Adt {\n+        def_id: s.into(),\n+        name: s.name(db).unwrap_or_else(Name::missing),\n+        substs: make_substs(&generics),\n+    }\n+}\n+\n+fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Ty {\n+    let generics = s.generic_params(db);\n+    Ty::Adt {\n+        def_id: s.into(),\n+        name: s.name(db).unwrap_or_else(Name::missing),\n+        substs: make_substs(&generics),\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum TypableDef {\n+    Function(Function),\n+    Struct(Struct),\n+    Enum(Enum),\n+    EnumVariant(EnumVariant),\n+}\n+impl_froms!(TypableDef: Function, Struct, Enum, EnumVariant);\n+\n+impl From<ModuleDef> for Option<TypableDef> {\n+    fn from(def: ModuleDef) -> Option<TypableDef> {\n+        let res = match def {\n+            ModuleDef::Function(f) => f.into(),\n+            ModuleDef::Struct(s) => s.into(),\n+            ModuleDef::Enum(e) => e.into(),\n+            ModuleDef::EnumVariant(v) => v.into(),\n+            ModuleDef::Const(_)\n+            | ModuleDef::Static(_)\n+            | ModuleDef::Module(_)\n+            | ModuleDef::Trait(_)\n+            | ModuleDef::Type(_) => return None,\n+        };\n+        Some(res)\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum CallableDef {\n+    Function(Function),\n+    Struct(Struct),\n+    EnumVariant(EnumVariant),\n+}\n+impl_froms!(CallableDef: Function, Struct, EnumVariant);"}, {"sha": "8703cf2366bf42dec63cfe08cf6bfb200f06d214", "filename": "crates/ra_hir/src/ty/op.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcfb4ee70254ec696801cbdb22d2de2bb1c939ed/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fop.rs?ref=dcfb4ee70254ec696801cbdb22d2de2bb1c939ed", "patch": "@@ -0,0 +1,81 @@\n+use crate::expr::BinaryOp;\n+use super::{Ty, InferTy};\n+\n+pub(super) fn binary_op_return_ty(op: BinaryOp, rhs_ty: Ty) -> Ty {\n+    match op {\n+        BinaryOp::BooleanOr\n+        | BinaryOp::BooleanAnd\n+        | BinaryOp::EqualityTest\n+        | BinaryOp::NegatedEqualityTest\n+        | BinaryOp::LesserEqualTest\n+        | BinaryOp::GreaterEqualTest\n+        | BinaryOp::LesserTest\n+        | BinaryOp::GreaterTest => Ty::Bool,\n+        BinaryOp::Assignment\n+        | BinaryOp::AddAssign\n+        | BinaryOp::SubAssign\n+        | BinaryOp::DivAssign\n+        | BinaryOp::MulAssign\n+        | BinaryOp::RemAssign\n+        | BinaryOp::ShrAssign\n+        | BinaryOp::ShlAssign\n+        | BinaryOp::BitAndAssign\n+        | BinaryOp::BitOrAssign\n+        | BinaryOp::BitXorAssign => Ty::unit(),\n+        BinaryOp::Addition\n+        | BinaryOp::Subtraction\n+        | BinaryOp::Multiplication\n+        | BinaryOp::Division\n+        | BinaryOp::Remainder\n+        | BinaryOp::LeftShift\n+        | BinaryOp::RightShift\n+        | BinaryOp::BitwiseAnd\n+        | BinaryOp::BitwiseOr\n+        | BinaryOp::BitwiseXor => match rhs_ty {\n+            Ty::Int(..)\n+            | Ty::Float(..)\n+            | Ty::Infer(InferTy::IntVar(..))\n+            | Ty::Infer(InferTy::FloatVar(..)) => rhs_ty,\n+            _ => Ty::Unknown,\n+        },\n+        BinaryOp::RangeRightOpen | BinaryOp::RangeRightClosed => Ty::Unknown,\n+    }\n+}\n+\n+pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n+    match op {\n+        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => Ty::Bool,\n+        BinaryOp::Assignment | BinaryOp::EqualityTest => match lhs_ty {\n+            Ty::Int(..) | Ty::Float(..) | Ty::Str | Ty::Char | Ty::Bool => lhs_ty,\n+            _ => Ty::Unknown,\n+        },\n+        BinaryOp::LesserEqualTest\n+        | BinaryOp::GreaterEqualTest\n+        | BinaryOp::LesserTest\n+        | BinaryOp::GreaterTest\n+        | BinaryOp::AddAssign\n+        | BinaryOp::SubAssign\n+        | BinaryOp::DivAssign\n+        | BinaryOp::MulAssign\n+        | BinaryOp::RemAssign\n+        | BinaryOp::ShrAssign\n+        | BinaryOp::ShlAssign\n+        | BinaryOp::BitAndAssign\n+        | BinaryOp::BitOrAssign\n+        | BinaryOp::BitXorAssign\n+        | BinaryOp::Addition\n+        | BinaryOp::Subtraction\n+        | BinaryOp::Multiplication\n+        | BinaryOp::Division\n+        | BinaryOp::Remainder\n+        | BinaryOp::LeftShift\n+        | BinaryOp::RightShift\n+        | BinaryOp::BitwiseAnd\n+        | BinaryOp::BitwiseOr\n+        | BinaryOp::BitwiseXor => match lhs_ty {\n+            Ty::Int(..) | Ty::Float(..) => lhs_ty,\n+            _ => Ty::Unknown,\n+        },\n+        _ => Ty::Unknown,\n+    }\n+}"}]}