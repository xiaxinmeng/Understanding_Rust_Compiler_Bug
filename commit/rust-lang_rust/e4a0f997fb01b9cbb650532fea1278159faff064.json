{"sha": "e4a0f997fb01b9cbb650532fea1278159faff064", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0YTBmOTk3ZmIwMWI5Y2JiNjUwNTMyZmVhMTI3ODE1OWZhZmYwNjQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2011-08-12T14:15:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-16T22:05:56Z"}, "message": "Port the compiler to the typaram foo<T> syntax.", "tree": {"sha": "6544a660e7af2a2485a14d200730d38e08ef29e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6544a660e7af2a2485a14d200730d38e08ef29e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4a0f997fb01b9cbb650532fea1278159faff064", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4a0f997fb01b9cbb650532fea1278159faff064", "html_url": "https://github.com/rust-lang/rust/commit/e4a0f997fb01b9cbb650532fea1278159faff064", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4a0f997fb01b9cbb650532fea1278159faff064/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "url": "https://api.github.com/repos/rust-lang/rust/commits/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32", "html_url": "https://github.com/rust-lang/rust/commit/f764f9a8cf52e686ba6e54b594e6bbbdd5bc7b32"}], "stats": {"total": 1136, "additions": 568, "deletions": 568}, "files": [{"sha": "93b88a818c484805d25263940890882b35108c35", "filename": "src/comp/README", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2FREADME?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -33,7 +33,7 @@ The 3 central data structures:\n     structure:\n \n       - Many -- though not all -- nodes within this data structure are\n-        wrapped in the type spanned[T], meaning that the front-end has\n+        wrapped in the type spanned<T>, meaning that the front-end has\n         marked the input coordinates of that node. The member .node is\n         the data itself, the member .span is the input location (file,\n         line, column; both low and high)."}, {"sha": "f94a9d0e2736251dd50a915f29b8c4f99821a4e1", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -285,14 +285,14 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n-        {name: option::t[str],\n-         vers: option::t[str],\n+        {name: option::t<str>,\n+         vers: option::t<str>,\n          cmh_items: [@ast::meta_item]};\n \n     fn provided_link_metas(sess: &session::session, c: &ast::crate) ->\n        provided_metas {\n-        let name: option::t[str] = none;\n-        let vers: option::t[str] = none;\n+        let name: option::t<str> = none;\n+        let vers: option::t<str> = none;\n         let cmh_items: [@ast::meta_item] = ~[];\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess, linkage_metas);"}, {"sha": "8bd185bb9d43891ac98e2f9068155fea95cbeb47", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -437,7 +437,7 @@ fn opts() -> [getopts::opt] {\n           optflag(\"lib\"), optflag(\"static\"), optflag(\"gc\")];\n }\n \n-fn main(args: vec[str]) {\n+fn main(args: vec<str>) {\n     let args_ivec = vec::from_vec(args);\n     let binary = vec::shift(args_ivec);\n     let binary_dir = fs::dirname(binary);"}, {"sha": "ea3eae6076772d6b14e76420f3a63b0776f5918e", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -54,7 +54,7 @@ obj session(targ_cfg: @config,\n             parse_sess: parse_sess,\n \n             // For a library crate, this is always none\n-            mutable main_fn: option::t[node_id],\n+            mutable main_fn: option::t<node_id>,\n             mutable err_count: uint) {\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n@@ -111,7 +111,7 @@ obj session(targ_cfg: @config,\n         ret codemap::span_to_str(sp, self.get_codemap());\n     }\n     fn set_main_id(d: node_id) { main_fn = some(d); }\n-    fn get_main_id() -> option::t[node_id] { main_fn }\n+    fn get_main_id() -> option::t<node_id> { main_fn }\n }\n // Local Variables:\n // fill-column: 78;"}, {"sha": "6474dfc1b773e9c9263e7772ec6413f75dcbf78c", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -45,7 +45,7 @@ fn find_attrs_by_name(attrs: &[ast::attribute], name: ast::ident) ->\n    [ast::attribute] {\n     let filter =\n         bind fn (a: &ast::attribute, name: ast::ident) ->\n-                option::t[ast::attribute] {\n+                option::t<ast::attribute> {\n                  if get_attr_name(a) == name {\n                      option::some(a)\n                  } else { option::none }\n@@ -61,7 +61,7 @@ fn find_meta_items_by_name(metas: &[@ast::meta_item], name: ast::ident) ->\n    [@ast::meta_item] {\n     let filter =\n         bind fn (m: &@ast::meta_item, name: ast::ident) ->\n-                option::t[@ast::meta_item] {\n+                option::t<@ast::meta_item> {\n                  if get_meta_item_name(m) == name {\n                      option::some(m)\n                  } else { option::none }\n@@ -79,7 +79,7 @@ fn get_meta_item_name(meta: &@ast::meta_item) -> ast::ident {\n \n // Gets the string value if the meta_item is a meta_name_value variant\n // containing a string, otherwise none\n-fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t[str] {\n+fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n         alt v.node {\n@@ -167,7 +167,7 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: str) ->\n \n     let filter =\n         bind fn (item: &@ast::meta_item, name: str) ->\n-                option::t[@ast::meta_item] {\n+                option::t<@ast::meta_item> {\n                  if get_meta_item_name(item) != name {\n                      option::some(item)\n                  } else { option::none }\n@@ -189,7 +189,7 @@ fn require_unique_names(sess: &session::session,\n     }\n }\n \n-fn span[T](item: &T) -> ast::spanned[T] {\n+fn span[T](item: &T) -> ast::spanned<T> {\n     ret {node: item, span: ast::mk_sp(0u, 0u)};\n }\n "}, {"sha": "4a9eeac0d220968bdce44e5ac5e6e197e9d723bd", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -25,7 +25,7 @@ fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n }\n \n fn filter_item(cfg: &ast::crate_cfg, item: &@ast::item) ->\n-   option::t[@ast::item] {\n+   option::t<@ast::item> {\n     if item_in_cfg(cfg, item) { option::some(item) } else { option::none }\n }\n \n@@ -38,7 +38,7 @@ fn fold_mod(cfg: &ast::crate_cfg, m: &ast::_mod, fld: fold::ast_fold) ->\n }\n \n fn filter_native_item(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n-   option::t[@ast::native_item] {\n+   option::t<@ast::native_item> {\n     if native_item_in_cfg(cfg, item) {\n         option::some(item)\n     } else { option::none }\n@@ -55,7 +55,7 @@ fn fold_native_mod(cfg: &ast::crate_cfg, nm: &ast::native_mod,\n }\n \n fn filter_stmt(cfg: &ast::crate_cfg, stmt: &@ast::stmt) ->\n-   option::t[@ast::stmt] {\n+   option::t<@ast::stmt> {\n     alt stmt.node {\n       ast::stmt_decl(decl, _) {\n         alt decl.node {"}, {"sha": "0ad041e5edde18e4342919af10fce3b543491c24", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -57,7 +57,7 @@ fn fold_mod(cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should\n     // have some mechanism to indicate to the translation pass which function\n     // we want to be main.\n-    fn nomain(item: &@ast::item) -> option::t[@ast::item] {\n+    fn nomain(item: &@ast::item) -> option::t<@ast::item> {\n         alt item.node {\n           ast::item_fn(f, _) {\n             if item.ident == \"main\" {\n@@ -167,7 +167,7 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     ret @item;\n }\n \n-fn nospan[T](t: &T) -> ast::spanned[T] {\n+fn nospan[T](t: &T) -> ast::spanned<T> {\n     ret {node: t, span: ast::dummy_sp()};\n }\n "}, {"sha": "12bcb5ad5fa4499861b90b8d6d84b16834e8eebf", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -1420,8 +1420,8 @@ fn new_builder(llbb: BasicBlockRef) -> builder {\n \n /* Memory-managed object interface to type handles. */\n \n-obj type_names(type_names: std::map::hashmap[TypeRef, str],\n-               named_types: std::map::hashmap[str, TypeRef]) {\n+obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n+               named_types: std::map::hashmap<str, TypeRef>) {\n \n     fn associate(s: str, t: TypeRef) {\n         assert (!named_types.contains_key(s));\n@@ -1446,8 +1446,8 @@ fn mk_type_names() -> type_names {\n \n     fn eq(a: &TypeRef, b: &TypeRef) -> bool { ret a as uint == b as uint; }\n \n-    let hasher: std::map::hashfn[TypeRef] = hash;\n-    let eqer: std::map::eqfn[TypeRef] = eq;\n+    let hasher: std::map::hashfn<TypeRef> = hash;\n+    let eqer: std::map::eqfn<TypeRef> = eq;\n     let tn = std::map::mk_hashmap[TypeRef, str](hasher, eqer);\n \n     ret type_names(tn, nt);"}, {"sha": "58e85e904405821409f42673d501c4ff7fe431b8", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -45,7 +45,7 @@ fn read_crates(sess: session::session, crate: &ast::crate) {\n \n type env =\n     @{sess: session::session,\n-      crate_cache: @hashmap[str, int],\n+      crate_cache: @hashmap<str, int>,\n       library_search_paths: [str],\n       mutable next_crate_num: ast::crate_num};\n \n@@ -118,7 +118,7 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n fn find_library_crate(sess: &session::session, ident: &ast::ident,\n                       metas: &[@ast::meta_item],\n                       library_search_paths: &[str]) ->\n-   option::t[{ident: str, data: @[u8]}] {\n+   option::t<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n \n@@ -148,7 +148,7 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n                           metas: &[@ast::meta_item],\n                           library_search_paths: &[str]) ->\n-   option::t[{ident: str, data: @[u8]}] {\n+   option::t<{ident: str, data: @[u8]}> {\n     let prefix: str = nn.prefix + crate_name;\n     // FIXME: we could probably use a 'glob' function in std::fs but it will\n     // be much easier to write once the unsafe module knows more about FFI\n@@ -183,7 +183,7 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: str,\n     ret none;\n }\n \n-fn get_metadata_section(filename: str) -> option::t[@[u8]] {\n+fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n     let b = str::buf(filename);\n     let mb = llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(b);\n     if mb as int == 0 { ret option::none[@[u8]]; }"}, {"sha": "70e7ab1169dffd323c7102255e84dbf888c831ce", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -27,7 +27,7 @@ export get_use_stmt_cnum;\n // local crate numbers (as generated during this session). Each external\n // crate may refer to types in other external crates, and each has their\n // own crate numbers.\n-type cnum_map = map::hashmap[ast::crate_num, ast::crate_num];\n+type cnum_map = map::hashmap<ast::crate_num, ast::crate_num>;\n \n type crate_metadata = {name: str, data: @[u8], cnum_map: cnum_map};\n \n@@ -39,14 +39,14 @@ type crate_metadata = {name: str, data: @[u8], cnum_map: cnum_map};\n tag cstore { private(cstore_private); }\n \n type cstore_private =\n-    @{metas: map::hashmap[ast::crate_num, crate_metadata],\n+    @{metas: map::hashmap<ast::crate_num, crate_metadata>,\n       use_crate_map: use_crate_map,\n       mutable used_crate_files: [str],\n       mutable used_libraries: [str],\n       mutable used_link_args: [str]};\n \n // Map from node_id's of local use statements to crate numbers\n-type use_crate_map = map::hashmap[ast::node_id, ast::crate_num];\n+type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n fn p(cstore: &cstore) -> cstore_private { alt cstore { private(p) { p } } }"}, {"sha": "b4203bd08e22a1066b1cf930d5c46a1e18979d2a", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -56,7 +56,7 @@ fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool , hash: uint) ->\n }\n \n fn maybe_find_item(item_id: int, items: &ebml::doc) ->\n-   option::t[ebml::doc] {\n+   option::t<ebml::doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         ret ebml::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }"}, {"sha": "62771235ee8695bdd6c21a1be04542fd57ec06e5", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -19,7 +19,7 @@ import front::attr;\n export encode_metadata;\n export encoded_ty;\n \n-type abbrev_map = map::hashmap[ty::t, tyencode::ty_abbrev];\n+type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n \n type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n \n@@ -39,7 +39,7 @@ fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n type entry[T] = {val: T, pos: uint};\n \n fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n-                            path: &[str], index: &mutable [entry[str]]) {\n+                            path: &[str], index: &mutable [entry<str>]) {\n     for variant: variant in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -50,7 +50,7 @@ fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n }\n \n fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n-                index: &mutable [entry[str]], name: &str) {\n+                index: &mutable [entry<str>], name: &str) {\n     let full_path = path + ~[name];\n     index +=\n         ~[{val: str::connect(full_path, \"::\"),\n@@ -59,7 +59,7 @@ fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n \n fn encode_native_module_item_paths(ebml_w: &ebml::writer,\n                                    nmod: &native_mod, path: &[str],\n-                                   index: &mutable [entry[str]]) {\n+                                   index: &mutable [entry<str>]) {\n     for nitem: @native_item in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -70,7 +70,7 @@ fn encode_native_module_item_paths(ebml_w: &ebml::writer,\n }\n \n fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n-                            path: &[str], index: &mutable [entry[str]]) {\n+                            path: &[str], index: &mutable [entry<str>]) {\n     for it: @item in module.items {\n         if !is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -149,8 +149,8 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n }\n \n fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) ->\n-   [entry[str]] {\n-    let index: [entry[str]] = ~[];\n+   [entry<str>] {\n+    let index: [entry<str>] = ~[];\n     let path: [str] = ~[];\n     ebml::start_tag(ebml_w, tag_paths);\n     encode_module_item_paths(ebml_w, crate.node.module, path, index);\n@@ -226,7 +226,7 @@ fn encode_tag_id(ebml_w: &ebml::writer, id: &def_id) {\n \n fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n                            id: node_id, variants: &[variant],\n-                           index: &mutable [entry[int]],\n+                           index: &mutable [entry<int>],\n                            ty_params: &[ty_param]) {\n     for variant: variant in variants {\n         index += ~[{val: variant.node.id, pos: ebml_w.writer.tell()}];\n@@ -246,7 +246,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n }\n \n fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer,\n-                        item: @item, index: &mutable [entry[int]]) {\n+                        item: @item, index: &mutable [entry<int>]) {\n     alt item.node {\n       item_const(_, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -368,8 +368,8 @@ fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n }\n \n fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n-   [entry[int]] {\n-    let index: [entry[int]] = ~[];\n+   [entry<int>] {\n+    let index: [entry<int>] = ~[];\n     ebml::start_tag(ebml_w, tag_items_data);\n     for each kvp: @{key: node_id, val: middle::ast_map::ast_node}  in\n              ecx.ccx.ast_map.items() {\n@@ -392,32 +392,32 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index[T](index: &[entry[T]], hash_fn: fn(&T) -> uint ) ->\n-   [@[entry[T]]] {\n-    let buckets: [@mutable [entry[T]]] = ~[];\n+fn create_index[T](index: &[entry<T>], hash_fn: fn(&T) -> uint ) ->\n+   [@[entry<T>]] {\n+    let buckets: [@mutable [entry<T>]] = ~[];\n     for each i: uint in uint::range(0u, 256u) { buckets += ~[@mutable ~[]]; }\n-    for elt: entry[T] in index {\n+    for elt: entry<T> in index {\n         let h = hash_fn(elt.val);\n         *buckets.(h % 256u) += ~[elt];\n     }\n \n     let buckets_frozen = ~[];\n-    for bucket: @mutable [entry[T]] in buckets {\n+    for bucket: @mutable [entry<T>] in buckets {\n         buckets_frozen += ~[@*bucket];\n     }\n     ret buckets_frozen;\n }\n \n-fn encode_index[T](ebml_w: &ebml::writer, buckets: &[@[entry[T]]],\n+fn encode_index[T](ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n                    write_fn: fn(&io::writer, &T) ) {\n     let writer = io::new_writer_(ebml_w.writer);\n     ebml::start_tag(ebml_w, tag_index);\n     let bucket_locs: [uint] = ~[];\n     ebml::start_tag(ebml_w, tag_index_buckets);\n-    for bucket: @[entry[T]] in buckets {\n+    for bucket: @[entry<T>] in buckets {\n         bucket_locs += ~[ebml_w.writer.tell()];\n         ebml::start_tag(ebml_w, tag_index_buckets_bucket);\n-        for elt: entry[T] in *bucket {\n+        for elt: entry<T> in *bucket {\n             ebml::start_tag(ebml_w, tag_index_buckets_bucket_elt);\n             writer.write_be_uint(elt.pos, 4u);\n             write_fn(writer, elt.val);"}, {"sha": "7c102c2de623549ecad1bd8e942094e3726f242c", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -115,7 +115,7 @@ fn parse_path(st: @pstate, sd: str_def) -> ast::path {\n     fail \"parse_path: ill-formed path\";\n }\n \n-type arg_parser[T] = fn(@pstate, str_def) -> ast::constr_arg_general_[T] ;\n+type arg_parser[T] = fn(@pstate, str_def) -> ast::constr_arg_general_<T> ;\n \n fn parse_constr_arg(st: @pstate, sd: str_def) -> ast::fn_constr_arg {\n     alt peek(st) as char {\n@@ -143,22 +143,22 @@ fn parse_constr_arg(st: @pstate, sd: str_def) -> ast::fn_constr_arg {\n }\n \n fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n-   ast::constr_arg_general_[path] {\n+   ast::constr_arg_general_<path> {\n     alt peek(st) as char {\n       '*' { st.pos += 1u; ret ast::carg_base; }\n       c { ret ast::carg_ident(parse_path(st, sd)); }\n     }\n }\n \n-fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n-   @ty::constr_general[T] {\n+fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser<T>) ->\n+   @ty::constr_general<T> {\n     let sp = ast::dummy_sp(); // FIXME: use a real span\n-    let args: [@sp_constr_arg[T]] = ~[];\n+    let args: [@sp_constr_arg<T>] = ~[];\n     let pth: path = parse_path(st, sd);\n     let ignore: char = next(st) as char;\n     assert (ignore as char == '(');\n     let def = parse_def(st, sd);\n-    let an_arg: constr_arg_general_[T];\n+    let an_arg: constr_arg_general_<T>;\n     do  {\n         an_arg = pser(st, sd);\n         // FIXME use a real span"}, {"sha": "23af6721887b907912ef31703f322e2893b270fe", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -26,7 +26,7 @@ type ctxt =  // Def -> str Callback:\n // Whatever format you choose should not contain pipe characters.\n type ty_abbrev = {pos: uint, len: uint, s: str};\n \n-tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap[ty::t, ty_abbrev]); }\n+tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n \n fn cx_uses_abbrevs(cx: &@ctxt) -> bool {\n     alt cx.abbrevs {"}, {"sha": "e3c316989558a63c66df6a900f9e8deab3495f6d", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -36,7 +36,7 @@ type scope = @[restrict];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n-type ctx = {tcx: ty::ctxt, local_map: std::map::hashmap[node_id, local_info]};\n+type ctx = {tcx: ty::ctxt, local_map: std::map::hashmap<node_id, local_info>};\n \n fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     // Stores information about object fields and function\n@@ -52,7 +52,7 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n }\n \n fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n-            name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt[scope]) {\n+            name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     for arg_: ast::arg in f.decl.inputs {\n         cx.local_map.insert(arg_.id, arg(arg_.mode));\n@@ -82,7 +82,7 @@ fn visit_fn(cx: &@ctx, f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n     v.visit_block(f.body, scope, v);\n }\n \n-fn visit_item(cx: &@ctx, i: &@ast::item, sc: &scope, v: &vt[scope]) {\n+fn visit_item(cx: &@ctx, i: &@ast::item, sc: &scope, v: &vt<scope>) {\n     alt i.node {\n       ast::item_obj(o, _, _) {\n         for f: ast::obj_field in o.fields {\n@@ -94,7 +94,7 @@ fn visit_item(cx: &@ctx, i: &@ast::item, sc: &scope, v: &vt[scope]) {\n     visit::visit_item(i, sc, v);\n }\n \n-fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt[scope]) {\n+fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     let handled = true;\n     alt ex.node {\n       ast::expr_call(f, args) {\n@@ -145,7 +145,7 @@ fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt[scope]) {\n     if !handled { visit::visit_expr(ex, sc, v); }\n }\n \n-fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt[scope]) {\n+fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n     visit::visit_decl(d, sc, v);\n     alt d.node {\n       ast::decl_local(locs) {\n@@ -309,7 +309,7 @@ fn check_tail_call(cx: &ctx, call: &@ast::expr) {\n }\n \n fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n-             v: &vt[scope]) {\n+             v: &vt<scope>) {\n     visit::visit_expr(input, sc, v);\n     let root = expr_root(cx, input, true);\n     let roots =\n@@ -336,7 +336,7 @@ fn arm_defnums(arm: &ast::arm) -> [node_id] {\n }\n \n fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n-                  blk: &ast::blk, sc: &scope, v: &vt[scope]) {\n+                  blk: &ast::blk, sc: &scope, v: &vt<scope>) {\n     visit::visit_expr(call, sc, v);\n     alt call.node {\n       ast::expr_call(f, args) {\n@@ -354,7 +354,7 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n }\n \n fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n-             sc: &scope, v: &vt[scope]) {\n+             sc: &scope, v: &vt<scope>) {\n     visit::visit_expr(seq, sc, v);\n     let root = expr_root(cx, seq, false);\n     let root_def =\n@@ -405,7 +405,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     }\n }\n \n-fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt[scope]) {\n+fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     alt dest.node {\n       ast::expr_path(p) {\n         let dnum = ast::def_id_of_def(cx.tcx.def_map.get(dest.id)).node;\n@@ -440,7 +440,7 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt[scope]) {\n     }\n }\n \n-fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt[scope]) {\n+fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     alt src.node {\n       ast::expr_path(p) {\n         alt cx.tcx.def_map.get(src.id) {\n@@ -464,7 +464,7 @@ fn check_move_rhs(cx: &@ctx, src: &@ast::expr, sc: &scope, v: &vt[scope]) {\n }\n \n fn check_assign(cx: &@ctx, dest: &@ast::expr, src: &@ast::expr, sc: &scope,\n-                v: &vt[scope]) {\n+                v: &vt<scope>) {\n     visit_expr(cx, src, sc, v);\n     check_lval(cx, dest, sc, v);\n }\n@@ -630,19 +630,19 @@ fn mut_field(ds: &@[deref]) -> bool {\n     ret false;\n }\n \n-fn inner_mut(ds: &@[deref]) -> option::t[ty::t] {\n+fn inner_mut(ds: &@[deref]) -> option::t<ty::t> {\n     for d: deref in *ds { if d.mut { ret some(d.outer_t); } }\n     ret none;\n }\n \n-fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t[ast::def] {\n+fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def> {\n     ret alt ex.node {\n       ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n       _ { none }\n     }\n }\n \n-fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t[ast::def_id] {\n+fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def_id> {\n     alt ex.node {\n       ast::expr_path(_) {\n         ret some(ast::def_id_of_def(cx.tcx.def_map.get(ex.id)));"}, {"sha": "aa9cea21d7de45fd4f6da8bb67d8f9b0f768dd8a", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -12,7 +12,7 @@ tag ast_node {\n     node_expr(@expr);\n }\n \n-type map = std::map::hashmap[node_id, ast_node];\n+type map = std::map::hashmap<node_id, ast_node>;\n \n fn map_crate(c: &crate) -> map {\n     // FIXME: This is using an adapter to convert the smallintmap\n@@ -29,7 +29,7 @@ fn map_crate(c: &crate) -> map {\n     ret map;\n }\n \n-fn map_item(map: &map, i: &@item, e: &(), v: &vt[()]) {\n+fn map_item(map: &map, i: &@item, e: &(), v: &vt<()>) {\n     map.insert(i.id, node_item(i));\n     alt i.node {\n       item_obj(_, _, ctor_id) { map.insert(ctor_id, node_obj_ctor(i)); }\n@@ -38,17 +38,17 @@ fn map_item(map: &map, i: &@item, e: &(), v: &vt[()]) {\n     visit::visit_item(i, e, v);\n }\n \n-fn map_native_item(map: &map, i: &@native_item, e: &(), v: &vt[()]) {\n+fn map_native_item(map: &map, i: &@native_item, e: &(), v: &vt<()>) {\n     map.insert(i.id, node_native_item(i));\n     visit::visit_native_item(i, e, v);\n }\n \n-fn map_expr(map: &map, ex: &@expr, e: &(), v: &vt[()]) {\n+fn map_expr(map: &map, ex: &@expr, e: &(), v: &vt<()>) {\n     map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, e, v);\n }\n \n-fn new_smallintmap_int_adapter[@V]() -> std::map::hashmap[int, V] {\n+fn new_smallintmap_int_adapter[@V]() -> std::map::hashmap<int, V> {\n     let key_idx = fn (key: &int) -> uint { key as uint };\n     let idx_key = fn (idx: &uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n@@ -62,10 +62,10 @@ fn new_smallintmap_int_adapter[@V]() -> std::map::hashmap[int, V] {\n fn new_smallintmap_adapter[@K,\n                            @V](key_idx: fn(&K) -> uint ,\n                                idx_key: fn(&uint) -> K ) ->\n-   std::map::hashmap[K, V] {\n+   std::map::hashmap<K, V> {\n \n     obj adapter[@K,\n-                @V](map: smallintmap::smallintmap[V],\n+                @V](map: smallintmap::smallintmap<V>,\n                     key_idx: fn(&K) -> uint ,\n                     idx_key: fn(&uint) -> K ) {\n \n@@ -83,17 +83,17 @@ fn new_smallintmap_adapter[@K,\n \n         fn get(key: &K) -> V { ret smallintmap::get(map, key_idx(key)); }\n \n-        fn find(key: &K) -> option::t[V] {\n+        fn find(key: &K) -> option::t<V> {\n             ret smallintmap::find(map, key_idx(key));\n         }\n \n-        fn remove(key: &K) -> option::t[V] { fail }\n+        fn remove(key: &K) -> option::t<V> { fail }\n \n         fn rehash() { fail }\n \n         iter items() -> @{key: K, val: V} {\n             let idx = 0u;\n-            for item: option::t[V] in map.v {\n+            for item: option::t<V> in map.v {\n                 alt item {\n                   option::some(elt) {\n                     let value = elt;"}, {"sha": "54017c6e282bdaedae43d19a1620df4a02d45d3f", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -10,7 +10,7 @@ fn check_crate(tcx: &ty::ctxt, crate: &@crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(tcx: &ty::ctxt, ex: &@expr, s: &(), v: &visit::vt[()]) {\n+fn check_expr(tcx: &ty::ctxt, ex: &@expr, s: &(), v: &visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     alt ex.node { expr_alt(_, arms) { check_arms(tcx, arms); } _ { } }\n }\n@@ -99,7 +99,7 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n     }\n }\n \n-fn check_local(tcx: &ty::ctxt, loc: &@local, s: &(), v: &visit::vt[()]) {\n+fn check_local(tcx: &ty::ctxt, loc: &@local, s: &(), v: &visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(tcx, loc.node.pat) {\n         tcx.sess.span_err(loc.node.pat.span,"}, {"sha": "ccd932049a36ed533648452a412d6151a92ec170", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -28,17 +28,17 @@ export def_lookup;\n // \"canonical\" referencing node_id per free variable. The set is useful for\n // testing membership, the list of referencing sites is what you want for most\n // other things.\n-type freevar_set = hashset[ast::node_id];\n+type freevar_set = hashset<ast::node_id>;\n type freevar_info = {defs: freevar_set, refs: @[ast::node_id]};\n-type freevar_map = hashmap[ast::node_id, freevar_info];\n+type freevar_map = hashmap<ast::node_id, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n-                    walker: &fn(&visit::vt[()]) ,\n+                    walker: &fn(&visit::vt<()>) ,\n                     initial_decls: [ast::node_id]) -> freevar_info {\n     let decls = new_int_hash();\n     for decl: ast::node_id in initial_decls { set_add(decls, decl); }\n@@ -108,7 +108,7 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n \n     let walk_fn = lambda(f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n                          i: &ast::fn_ident, nid: ast::node_id) {\n-        let start_walk = lambda(v: &visit::vt[()]) {\n+        let start_walk = lambda(v: &visit::vt<()>) {\n             v.visit_fn(f, tps, sp, i, nid, (), v);\n         };\n         let vars = collect_freevars(def_map, sess, start_walk, ~[]);\n@@ -117,7 +117,7 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n     let walk_expr = lambda(expr: &@ast::expr) {\n         alt expr.node {\n           ast::expr_for_each(local, _, body) {\n-            let start_walk = lambda(v: &visit::vt[()]) {\n+            let start_walk = lambda(v: &visit::vt<()>) {\n                 v.visit_block(body, (), v);\n             };\n             let bound = ast::pat_binding_ids(local.node.pat);\n@@ -157,7 +157,7 @@ fn is_freevar_of(tcx: &ty::ctxt, def: ast::node_id, f: ast::node_id) -> bool {\n     ret get_freevar_defs(tcx, f).contains_key(def);\n }\n fn def_lookup(tcx: &ty::ctxt, f: ast::node_id, id: ast::node_id) ->\n-   option::t[ast::def] {\n+   option::t<ast::def> {\n     alt tcx.def_map.find(id) {\n       none. { ret none; }\n       some(d) {"}, {"sha": "e38d305a00c8c3653a977d37c425e5d8c72d9e97", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -57,20 +57,20 @@ tag scope {\n     scope_arm(ast::arm);\n }\n \n-type scopes = list[scope];\n+type scopes = list<scope>;\n \n tag import_state {\n     todo(@ast::view_item, scopes); // only used for explicit imports\n \n     resolving(span);\n-    resolved(option::t[def],\n+    resolved(option::t<def>,\n               /* value */\n-             option::t[def],\n+             option::t<def>,\n               /* type */\n-             option::t[def]); /* module */\n+             option::t<def>); /* module */\n }\n \n-type ext_hash = hashmap[{did: def_id, ident: str, ns: namespace}, def];\n+type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n \n fn new_ext_hash() -> ext_hash {\n     type key = {did: def_id, ident: str, ns: namespace};\n@@ -96,30 +96,30 @@ tag mod_index_entry {\n     mie_tag_variant(/* tag item */@ast::item, /* variant index */uint);\n }\n \n-type mod_index = hashmap[ident, list[mod_index_entry]];\n+type mod_index = hashmap<ident, list<mod_index_entry>>;\n \n // A tuple of an imported def and the import stmt that brung it\n type glob_imp_def = {def: def, item: @ast::view_item};\n \n type indexed_mod =\n-    {m: option::t[ast::_mod],\n+    {m: option::t<ast::_mod>,\n      index: mod_index,\n      mutable glob_imports: [glob_imp_def],\n-     glob_imported_names: hashmap[str, import_state]};\n+     glob_imported_names: hashmap<str, import_state>};\n \n \n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n \n-type def_map = hashmap[node_id, def];\n+type def_map = hashmap<node_id, def>;\n \n type env =\n     {cstore: cstore::cstore,\n      def_map: def_map,\n      ast_map: ast_map::map,\n-     imports: hashmap[ast::node_id, import_state],\n-     mod_map: hashmap[ast::node_id, @indexed_mod],\n-     ext_map: hashmap[def_id, [ident]],\n+     imports: hashmap<ast::node_id, import_state>,\n+     mod_map: hashmap<ast::node_id, @indexed_mod>,\n+     ext_map: hashmap<def_id, [ident]>,\n      ext_cache: ext_hash,\n      mutable reported: [{ident: str, sc: scope}],\n      sess: session};\n@@ -168,15 +168,15 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: ~[],\n                        glob_imported_names: new_str_hash[import_state]()});\n-    fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, v: &vt[scopes]) {\n+    fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, v: &vt<scopes>) {\n         alt i.node {\n           ast::view_item_import(_, ids, id) {\n             e.imports.insert(id, todo(i, sc));\n           }\n           _ { }\n         }\n     }\n-    fn index_i(e: @env, i: &@ast::item, sc: &scopes, v: &vt[scopes]) {\n+    fn index_i(e: @env, i: &@ast::item, sc: &scopes, v: &vt<scopes>) {\n         visit_item_with_scope(i, sc, v);\n         alt i.node {\n           ast::item_mod(md) {\n@@ -206,7 +206,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n              with *visit::default_visitor[scopes]()};\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n-    fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes, v: &vt[scopes]) {\n+    fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes, v: &vt<scopes>) {\n         fn find_mod(e: @env, sc: scopes) -> @indexed_mod {\n             alt sc {\n               cons(scope_item(i), tl) {\n@@ -265,7 +265,7 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n     e.sess.abort_if_errors();\n \n-    fn walk_expr(e: @env, exp: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n+    fn walk_expr(e: @env, exp: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n         visit_expr_with_scope(exp, sc, v);\n         alt exp.node {\n           ast::expr_path(p) {\n@@ -276,7 +276,7 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n           _ { }\n         }\n     }\n-    fn walk_ty(e: @env, t: &@ast::ty, sc: &scopes, v: &vt[scopes]) {\n+    fn walk_ty(e: @env, t: &@ast::ty, sc: &scopes, v: &vt<scopes>) {\n         visit::visit_ty(t, sc, v);\n         alt t.node {\n           ast::ty_path(p, id) {\n@@ -287,13 +287,13 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n         }\n     }\n     fn walk_constr(e: @env, p: &ast::path, sp: &span, id: node_id,\n-                   sc: &scopes, v: &vt[scopes]) {\n+                   sc: &scopes, v: &vt<scopes>) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n     }\n-    fn walk_arm(e: @env, a: &ast::arm, sc: &scopes, v: &vt[scopes]) {\n+    fn walk_arm(e: @env, a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n         visit_arm_with_scope(a, sc, v);\n     }\n-    fn walk_pat(e: &@env, pat: &@ast::pat, sc: &scopes, v: &vt[scopes]) {\n+    fn walk_pat(e: &@env, pat: &@ast::pat, sc: &scopes, v: &vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_tag(p, _) {\n@@ -312,25 +312,25 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n         }\n     }\n \n-    fn maybe_insert(e: @env, id: node_id, def: option::t[def]) {\n+    fn maybe_insert(e: @env, id: node_id, def: option::t<def>) {\n         if option::is_some(def) { e.def_map.insert(id, option::get(def)); }\n     }\n }\n \n \n // Visit helper functions\n-fn visit_item_with_scope(i: &@ast::item, sc: &scopes, v: &vt[scopes]) {\n+fn visit_item_with_scope(i: &@ast::item, sc: &scopes, v: &vt<scopes>) {\n     visit::visit_item(i, cons(scope_item(i), @sc), v);\n }\n \n fn visit_native_item_with_scope(ni: &@ast::native_item, sc: &scopes,\n-                                v: &vt[scopes]) {\n+                                v: &vt<scopes>) {\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n                        sp: &span, name: &fn_ident, id: node_id, sc: &scopes,\n-                       v: &vt[scopes]) {\n+                       v: &vt<scopes>) {\n     // is this a main fn declaration?\n     alt name {\n       some(nm) {\n@@ -353,7 +353,7 @@ fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n                     cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n }\n \n-fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt[scopes]) {\n+fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt<scopes>) {\n     let pos = @mutable 0u, loc = @mutable 0u;\n     let block_sc = cons(scope_block(b, pos, loc), @sc);\n     for stmt in b.node.stmts {\n@@ -364,7 +364,7 @@ fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt[scopes]) {\n     visit::visit_expr_opt(b.node.expr, block_sc, v);\n }\n \n-fn visit_decl_with_scope(d: &@decl, sc: &scopes, v: &vt[scopes]) {\n+fn visit_decl_with_scope(d: &@decl, sc: &scopes, v: &vt<scopes>) {\n     let loc_pos = alt list::car(sc) {\n       scope_block(_, _, pos) { pos }\n       _ { @mutable 0u }\n@@ -380,11 +380,11 @@ fn visit_decl_with_scope(d: &@decl, sc: &scopes, v: &vt[scopes]) {\n     }\n }\n \n-fn visit_arm_with_scope(a: &ast::arm, sc: &scopes, v: &vt[scopes]) {\n+fn visit_arm_with_scope(a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n     visit::visit_arm(a, cons(scope_arm(a), @sc), v);\n }\n \n-fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n+fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n     alt x.node {\n       ast::expr_for(decl, coll, blk) | ast::expr_for_each(decl, coll, blk) {\n         let new_sc = cons[scope](scope_loop(decl), @sc);\n@@ -400,7 +400,7 @@ fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt[scopes]) {\n }\n \n fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n-   option::t[def] {\n+   option::t<def> {\n     let path_len = vec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path.(0), ns_module);\n     let i = 1u;\n@@ -425,7 +425,7 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n }\n \n fn resolve_constr(e: @env, id: node_id, c: &@ast::constr, sc: &scopes,\n-                  v: &vt[scopes]) {\n+                  v: &vt<scopes>) {\n     let new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_value);\n     if option::is_some(new_def) {\n@@ -506,13 +506,13 @@ fn resolve_import(e: &env, it: &@ast::view_item, sc_in: &scopes) {\n         }\n     }\n     fn register(e: &env, defid: def_id, sp: &span, name: &ident, sc: &scopes,\n-                val: &option::t[def], typ: &option::t[def],\n-                md: &option::t[def]) {\n+                val: &option::t<def>, typ: &option::t<def>,\n+                md: &option::t<def>) {\n         if is_none(val) && is_none(typ) && is_none(md) {\n             unresolved_err(e, sc, sp, name, \"import\");\n         } else { e.imports.insert(defid.node, resolved(val, typ, md)); }\n     }\n-    fn remove_if_unresolved(imports: hashmap[ast::node_id, import_state],\n+    fn remove_if_unresolved(imports: hashmap<ast::node_id, import_state>,\n                             node_id: ast::node_id) {\n \n         // If we couldn't resolve the import, don't leave it in a partially\n@@ -572,7 +572,7 @@ fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n \n // Lookup helpers\n fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n-                      ns: namespace) -> option::t[def] {\n+                      ns: namespace) -> option::t<def> {\n     let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n \n@@ -596,7 +596,7 @@ fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n }\n \n fn lookup_in_scope_strict(e: &env, sc: scopes, sp: &span, name: &ident,\n-                          ns: namespace) -> option::t[def] {\n+                          ns: namespace) -> option::t<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n       none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n@@ -629,9 +629,9 @@ fn def_is_ty_arg(d: &def) -> bool {\n }\n \n fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n-                   ns: namespace) -> option::t[def] {\n+                   ns: namespace) -> option::t<def> {\n     fn in_scope(e: &env, sp: &span, name: &ident, s: &scope, ns: namespace) ->\n-       option::t[def] {\n+       option::t<def> {\n         alt s {\n           scope_crate. {\n             ret lookup_in_local_mod(e, -1, sp, name, ns, inside);\n@@ -728,7 +728,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n }\n \n fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n-   option::t[def] {\n+   option::t<def> {\n     let i = 0u;\n     for tp: ast::ty_param in ty_params {\n         if str::eq(tp.ident, name) { ret some(ast::def_ty_arg(i,tp.kind)); }\n@@ -737,7 +737,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n     ret none[def];\n }\n \n-fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t[def_id] {\n+fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n     let found = none;\n     for each bound in ast::pat_bindings(pat) {\n         let p_name = alt bound.node { ast::pat_bind(n) { n } };\n@@ -750,7 +750,7 @@ fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t[def_id] {\n \n fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n                 ty_params: &[ast::ty_param], ns: namespace) ->\n-   option::t[def] {\n+   option::t<def> {\n     alt ns {\n       ns_value. {\n         for a: ast::arg in decl.inputs {\n@@ -766,7 +766,7 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n }\n \n fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n-                 ns: namespace) -> option::t[def] {\n+                 ns: namespace) -> option::t<def> {\n     alt ns {\n       ns_value. {\n         for f: ast::obj_field in ob.fields {\n@@ -782,7 +782,7 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n }\n \n fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n-                   ns: namespace) -> option::t[def] {\n+                   ns: namespace) -> option::t<def> {\n     let i = vec::len(b.stmts);\n     while i > 0u {\n         i -= 1u;\n@@ -838,7 +838,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n     ret none[def];\n }\n \n-fn found_def_item(i: &@ast::item, ns: namespace) -> option::t[def] {\n+fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n     alt i.node {\n       ast::item_const(_, _) {\n         if ns == ns_value { ret some(ast::def_const(local_def(i.id))); }\n@@ -884,15 +884,15 @@ fn found_def_item(i: &@ast::item, ns: namespace) -> option::t[def] {\n }\n \n fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n-                        ns: namespace, dr: dir) -> option::t[def] {\n+                        ns: namespace, dr: dir) -> option::t<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n       none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n \n fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n-                 dr: dir) -> option::t[def] {\n+                 dr: dir) -> option::t<def> {\n     let defid = ast::def_id_of_def(m);\n     if defid.crate != ast::local_crate {\n         // examining a module in an external crate\n@@ -919,7 +919,7 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n }\n \n fn found_view_item(e: &env, vi: @ast::view_item, ns: namespace) ->\n-   option::t[def] {\n+   option::t<def> {\n     alt vi.node {\n       ast::view_item_use(_, _, id) {\n         let cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n@@ -935,7 +935,7 @@ fn found_view_item(e: &env, vi: @ast::view_item, ns: namespace) ->\n     }\n }\n \n-fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t[def] {\n+fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t<def> {\n     alt e.imports.get(defid.node) {\n       todo(item, sc) {\n         resolve_import(e, item, sc);\n@@ -949,12 +949,12 @@ fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t[def] {\n }\n \n fn lookup_in_local_native_mod(e: &env, node_id: node_id, sp: &span,\n-                              id: &ident, ns: namespace) -> option::t[def] {\n+                              id: &ident, ns: namespace) -> option::t<def> {\n     ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n }\n \n fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n-                       ns: namespace, dr: dir) -> option::t[def] {\n+                       ns: namespace, dr: dir) -> option::t<def> {\n     let info = e.mod_map.get(node_id);\n     if dr == outside && !ast::is_exported(id, option::get(info.m)) {\n         // if we're in a native mod, then dr==inside, so info.m is some _mod\n@@ -984,13 +984,13 @@ fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n }\n \n fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n-                      wanted_ns: namespace, dr: dir) -> option::t[def] {\n+                      wanted_ns: namespace, dr: dir) -> option::t<def> {\n     fn per_ns(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n-              ns: namespace, dr: dir) -> option::t[def] {\n+              ns: namespace, dr: dir) -> option::t<def> {\n \n         fn lookup_in_mod_(e: &env, def: &glob_imp_def, sp: &span,\n                           name: &ident, ns: namespace, dr: dir) ->\n-           option::t[glob_imp_def] {\n+           option::t<glob_imp_def> {\n             alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n               option::some(d) { option::some({def: d, item: def.item}) }\n               option::none. { option::none }\n@@ -1041,7 +1041,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n }\n \n fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n-   option::t[def] {\n+   option::t<def> {\n     alt mie {\n       mie_view_item(view_item) { ret found_view_item(e, view_item, ns); }\n       mie_item(item) { ret found_def_item(item, ns); }\n@@ -1077,7 +1077,7 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n \n \n // Module indexing\n-fn add_to_index(index: &hashmap[ident, list[mod_index_entry]], id: &ident,\n+fn add_to_index(index: &hashmap<ident, list<mod_index_entry>>, id: &ident,\n                 ent: &mod_index_entry) {\n     alt index.find(id) {\n       none. { index.insert(id, cons(ent, @nil[mod_index_entry])); }\n@@ -1086,7 +1086,7 @@ fn add_to_index(index: &hashmap[ident, list[mod_index_entry]], id: &ident,\n }\n \n fn index_mod(md: &ast::_mod) -> mod_index {\n-    let index = new_str_hash[list[mod_index_entry]]();\n+    let index = new_str_hash[list<mod_index_entry>]();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n           ast::view_item_import(ident, _, _) | ast::view_item_use(ident, _, _)\n@@ -1121,7 +1121,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n }\n \n fn index_nmod(md: &ast::native_mod) -> mod_index {\n-    let index = new_str_hash[list[mod_index_entry]]();\n+    let index = new_str_hash[list<mod_index_entry>]();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n           ast::view_item_use(ident, _, _) | ast::view_item_import(ident, _, _)\n@@ -1158,7 +1158,7 @@ fn ns_for_def(d: def) -> namespace {\n }\n \n fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n-   option::t[def] {\n+   option::t<def> {\n     for d: def in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if ns == ns_for_def(d) { ret some(d); }\n@@ -1173,7 +1173,7 @@ fn check_for_collisions(e: &@env, c: &ast::crate) {\n     // name for multiple entities in the same namespace.\n     for each m: @{key: ast::node_id, val: @indexed_mod}\n         in e.mod_map.items() {\n-        for each name: @{key: ident, val: list[mod_index_entry]}\n+        for each name: @{key: ident, val: list<mod_index_entry>}\n             in m.val.index.items() {\n             check_mod_name(*e, name.key, name.val);\n         }\n@@ -1188,7 +1188,7 @@ fn check_for_collisions(e: &@env, c: &ast::crate) {\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n-fn check_mod_name(e: &env, name: &ident, entries: list[mod_index_entry]) {\n+fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n     let saw_mod = false;\n     let saw_type = false;\n     let saw_value = false;\n@@ -1229,7 +1229,7 @@ fn mie_span(mie: &mod_index_entry) -> span {\n         };\n }\n \n-fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt[()]) {\n+fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n     fn typaram_names(tps: &[ast::ty_param]) -> [ident] {\n         let x: [ast::ident] = ~[];\n         for tp: ast::ty_param in tps { x += ~[tp.ident] }\n@@ -1266,7 +1266,7 @@ fn check_pat(ch: checker, p: &@ast::pat) {\n     }\n }\n \n-fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt[()]) {\n+fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n     visit::visit_arm(a, x, v);\n     let ch0 = checker(*e, \"binding\");\n     check_pat(ch0, a.pats.(0));\n@@ -1296,7 +1296,7 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt[()]) {\n     }\n }\n \n-fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt[()]) {\n+fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n     visit::visit_block(b, x, v);\n     let values = checker(*e, \"value\");\n     let types = checker(*e, \"type\");\n@@ -1349,7 +1349,7 @@ fn check_fn(e: &env, sp: &span, f: &ast::_fn) {\n     ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n-fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt[()]) {\n+fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt<()>) {\n     alt ex.node {\n       ast::expr_rec(fields, _) {\n         fn field_name(f: &ast::field) -> ident { ret f.node.ident; }\n@@ -1360,7 +1360,7 @@ fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt[()]) {\n     visit::visit_expr(ex, x, v);\n }\n \n-fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt[()]) {\n+fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt<()>) {\n     alt ty.node {\n       ast::ty_rec(fields) {\n         fn field_name(f: &ast::ty_field) -> ident { ret f.node.ident; }"}, {"sha": "7927af71fe3d8ee7a51304b7d735333cc10f9b13", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -39,9 +39,9 @@ type res_info = { did: ast::def_id, t: ty::t };\n type ctxt = {\n     mutable next_tag_id: u16,\n     pad: u16,\n-    tag_id_to_index: hashmap[ast::def_id,u16],\n+    tag_id_to_index: hashmap<ast::def_id,u16>,\n     mutable tag_order: [ast::def_id],\n-    resources: interner::interner[res_info],\n+    resources: interner::interner<res_info>,\n     llshapetablesty: TypeRef,\n     llshapetables: ValueRef\n };"}, {"sha": "3beef789129066db1bffdba75438a9b3bc2b3f62", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -361,23 +361,23 @@ fn decl_glue(llmod: ModuleRef, cx: &crate_ctxt, s: &str) -> ValueRef {\n     ret decl_cdecl_fn(llmod, s, T_fn(~[T_taskptr(cx)], T_void()));\n }\n \n-fn get_extern_fn(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n+fn get_extern_fn(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n                  name: &str, cc: uint, ty: TypeRef) -> ValueRef {\n     if externs.contains_key(name) { ret externs.get(name); }\n     let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name, f);\n     ret f;\n }\n \n-fn get_extern_const(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n+fn get_extern_const(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n                     name: &str, ty: TypeRef) -> ValueRef {\n     if externs.contains_key(name) { ret externs.get(name); }\n     let c = llvm::LLVMAddGlobal(llmod, ty, str::buf(name));\n     externs.insert(name, c);\n     ret c;\n }\n \n-fn get_simple_extern_fn(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n+fn get_simple_extern_fn(externs: &hashmap<str, ValueRef>, llmod: ModuleRef,\n                         name: &str, n_args: int) -> ValueRef {\n     let inputs = std::vec::init_elt[TypeRef](T_int(), n_args as uint);\n     let output = T_int();\n@@ -386,7 +386,7 @@ fn get_simple_extern_fn(externs: &hashmap[str, ValueRef], llmod: ModuleRef,\n }\n \n fn trans_native_call(b: &builder, glues: @glue_fns, lltaskptr: ValueRef,\n-                     externs: &hashmap[str, ValueRef], tn: &type_names,\n+                     externs: &hashmap<str, ValueRef>, tn: &type_names,\n                      llmod: ModuleRef, name: &str, pass_task: bool,\n                      args: &[ValueRef]) -> ValueRef {\n     let n: int = std::vec::len[ValueRef](args) as int;\n@@ -939,7 +939,7 @@ fn trans_stack_local_derived_tydesc(cx: &@block_ctxt, llsz: ValueRef,\n }\n \n fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n-                      static_ti: &mutable option::t[@tydesc_info]) -> result {\n+                      static_ti: &mutable option::t<@tydesc_info>) -> result {\n     alt cx.fcx.derived_tydescs.find(t) {\n       some(info) {\n \n@@ -1007,7 +1007,7 @@ fn get_derived_tydesc(cx: &@block_ctxt, t: &ty::t, escapes: bool,\n }\n \n fn get_tydesc(cx: &@block_ctxt, orig_t: &ty::t, escapes: bool,\n-              static_ti: &mutable option::t[@tydesc_info]) -> result {\n+              static_ti: &mutable option::t<@tydesc_info>) -> result {\n \n     let t = ty::strip_cname(bcx_tcx(cx), orig_t);\n \n@@ -1470,7 +1470,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: &ast::def_id,\n                                    ~[C_int(0), C_int(abi::fn_field_box)]));\n     let args = ~[cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env];\n     for tp: ty::t in tps {\n-        let ti: option::t[@tydesc_info] = none;\n+        let ti: option::t<@tydesc_info> = none;\n         let td = get_tydesc(cx, tp, false, ti);\n         args += ~[td.val];\n         cx = td.bcx;\n@@ -1983,7 +1983,7 @@ fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: &ty::t, f: &val_and_ty_fn)\n }\n \n fn lazily_emit_all_tydesc_glue(cx: &@block_ctxt,\n-                               static_ti: &option::t[@tydesc_info]) {\n+                               static_ti: &option::t<@tydesc_info>) {\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_copy_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, static_ti);\n@@ -1992,13 +1992,13 @@ fn lazily_emit_all_tydesc_glue(cx: &@block_ctxt,\n \n fn lazily_emit_all_generic_info_tydesc_glues(cx: &@block_ctxt,\n                                              gi: &generic_info) {\n-    for ti: option::t[@tydesc_info] in gi.static_tis {\n+    for ti: option::t<@tydesc_info> in gi.static_tis {\n         lazily_emit_all_tydesc_glue(cx, ti);\n     }\n }\n \n fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n-                           static_ti: &option::t[@tydesc_info]) {\n+                           static_ti: &option::t<@tydesc_info>) {\n     alt static_ti {\n       none. { }\n       some(ti) {\n@@ -2073,7 +2073,7 @@ fn lazily_emit_tydesc_glue(cx: &@block_ctxt, field: int,\n }\n \n fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n-                         field: int, static_ti: &option::t[@tydesc_info]) {\n+                         field: int, static_ti: &option::t<@tydesc_info>) {\n     lazily_emit_tydesc_glue(cx, field, static_ti);\n \n     let static_glue_fn = none;\n@@ -2114,7 +2114,7 @@ fn call_tydesc_glue_full(cx: &@block_ctxt, v: ValueRef, tydesc: ValueRef,\n \n fn call_tydesc_glue(cx: &@block_ctxt, v: ValueRef, t: &ty::t, field: int) ->\n    result {\n-    let ti: option::t[@tydesc_info] = none[@tydesc_info];\n+    let ti: option::t<@tydesc_info> = none[@tydesc_info];\n     let td = get_tydesc(cx, t, false, ti);\n     call_tydesc_glue_full(td.bcx, spill_if_immediate(td.bcx, v, t), td.val,\n                           field, ti);\n@@ -3376,7 +3376,7 @@ fn join_branches(parent_cx: &@block_ctxt, ins: &[result]) -> @block_ctxt {\n tag out_method { return; save_in(ValueRef); }\n \n fn trans_if(cx: &@block_ctxt, cond: &@ast::expr, thn: &ast::blk,\n-            els: &option::t[@ast::expr], id: ast::node_id,\n+            els: &option::t<@ast::expr>, id: ast::node_id,\n             output: &out_method) -> result {\n     let cond_res = trans_expr(cx, cond);\n \n@@ -3778,15 +3778,15 @@ fn trans_do_while(cx: &@block_ctxt, body: &ast::blk, cond: &@ast::expr) ->\n \n type generic_info =\n     {item_type: ty::t,\n-     static_tis: [option::t[@tydesc_info]],\n+     static_tis: [option::t<@tydesc_info>],\n      tydescs: [ValueRef]};\n \n type lval_result =\n     {res: result,\n      is_mem: bool,\n-     generic: option::t[generic_info],\n-     llobj: option::t[ValueRef],\n-     method_ty: option::t[ty::t]};\n+     generic: option::t<generic_info>,\n+     llobj: option::t<ValueRef>,\n+     method_ty: option::t<ty::t>};\n \n fn lval_mem(cx: &@block_ctxt, val: ValueRef) -> lval_result {\n     ret {res: rslt(cx, val),\n@@ -3827,7 +3827,7 @@ fn lval_generic_fn(cx: &@block_ctxt, tpt: &ty::ty_param_kinds_and_ty,\n     if std::vec::len[ty::t](tys) != 0u {\n         let bcx = lv.res.bcx;\n         let tydescs: [ValueRef] = ~[];\n-        let tis: [option::t[@tydesc_info]] = ~[];\n+        let tis: [option::t<@tydesc_info>] = ~[];\n         for t: ty::t in tys {\n             // TODO: Doesn't always escape.\n \n@@ -4213,10 +4213,10 @@ fn trans_cast(cx: &@block_ctxt, e: &@ast::expr, id: ast::node_id) -> result {\n }\n \n fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n-                    outgoing_fty: &ty::t, args: &[option::t[@ast::expr]],\n+                    outgoing_fty: &ty::t, args: &[option::t<@ast::expr>],\n                     env_ty: &ty::t, bound_tys: &[ty::t],\n                     ty_param_count: uint,\n-                    target_fn: &option::t[ValueRef]) ->\n+                    target_fn: &option::t<ValueRef>) ->\n     {val: ValueRef, ty: TypeRef} {\n \n     // Here we're not necessarily constructing a thunk in the sense of\n@@ -4330,7 +4330,7 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n         type_of_explicit_args(cx.ccx, sp, outgoing_args);\n-    for arg: option::t[@ast::expr] in args {\n+    for arg: option::t<@ast::expr> in args {\n         let out_arg = outgoing_args.(outgoing_arg_index);\n         let llout_arg_ty = llout_arg_tys.(outgoing_arg_index);\n         let is_val = out_arg.mode == ty::mo_val;\n@@ -4405,16 +4405,16 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: &ty::t,\n }\n \n fn trans_bind(cx: &@block_ctxt, f: &@ast::expr,\n-              args: &[option::t[@ast::expr]], id: ast::node_id) -> result {\n+              args: &[option::t<@ast::expr>], id: ast::node_id) -> result {\n     let f_res = trans_lval_gen(cx, f);\n     ret trans_bind_1(cx, f, f_res, args, id);\n }\n \n fn trans_bind_1(cx: &@block_ctxt, f: &@ast::expr, f_res: &lval_result,\n-                args: &[option::t[@ast::expr]], id: ast::node_id) ->\n+                args: &[option::t<@ast::expr>], id: ast::node_id) ->\n    result {\n     let bound: [@ast::expr] = ~[];\n-    for argopt: option::t[@ast::expr] in args {\n+    for argopt: option::t<@ast::expr> in args {\n         alt argopt { none. { } some(e) { bound += ~[e]; } }\n     }\n \n@@ -4561,7 +4561,7 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg,\n //  - new_fn_ctxt\n //  - trans_args\n fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n-              gen: &option::t[generic_info], lliterbody: &option::t[ValueRef],\n+              gen: &option::t<generic_info>, lliterbody: &option::t<ValueRef>,\n               es: &[@ast::expr], fn_ty: &ty::t) ->\n    {bcx: @block_ctxt,\n     args: [ValueRef],\n@@ -4645,7 +4645,7 @@ fn trans_args(cx: &@block_ctxt, llenv: ValueRef,\n }\n \n fn trans_call(cx: &@block_ctxt, f: &@ast::expr,\n-              lliterbody: &option::t[ValueRef], args: &[@ast::expr],\n+              lliterbody: &option::t<ValueRef>, args: &[@ast::expr],\n               id: ast::node_id) -> result {\n     // NB: 'f' isn't necessarily a function; it might be an entire self-call\n     // expression because of the hack that allows us to process self-calls\n@@ -4910,7 +4910,7 @@ fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n }\n \n fn trans_rec(cx: &@block_ctxt, fields: &[ast::field],\n-             base: &option::t[@ast::expr], id: ast::node_id) -> result {\n+             base: &option::t<@ast::expr>, id: ast::node_id) -> result {\n     let bcx = cx;\n     let t = node_id_type(bcx_ccx(bcx), id);\n     let rec_res = alloc_ty(bcx, t);\n@@ -5263,8 +5263,8 @@ fn trans_check_expr(cx: &@block_ctxt, e: &@ast::expr, s: &str) -> result {\n     ret rslt(next_cx, C_nil());\n }\n \n-fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t[span],\n-                   fail_expr: &option::t[@ast::expr]) -> result {\n+fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t<span>,\n+                   fail_expr: &option::t<@ast::expr>) -> result {\n     let bcx = cx;\n     alt fail_expr {\n       some(expr) {\n@@ -5290,13 +5290,13 @@ fn trans_fail_expr(cx: &@block_ctxt, sp_opt: &option::t[span],\n     }\n }\n \n-fn trans_fail(cx: &@block_ctxt, sp_opt: &option::t[span], fail_str: &str) ->\n+fn trans_fail(cx: &@block_ctxt, sp_opt: &option::t<span>, fail_str: &str) ->\n    result {\n     let V_fail_str = C_cstr(bcx_ccx(cx), fail_str);\n     ret trans_fail_value(cx, sp_opt, V_fail_str);\n }\n \n-fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t[span],\n+fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t<span>,\n                     V_fail_str: &ValueRef) -> result {\n     let V_filename;\n     let V_line;\n@@ -5316,7 +5316,7 @@ fn trans_fail_value(cx: &@block_ctxt, sp_opt: &option::t[span],\n     ret rslt(cx, C_nil());\n }\n \n-fn trans_put(cx: &@block_ctxt, e: &option::t[@ast::expr]) -> result {\n+fn trans_put(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n     let llcallee = C_nil();\n     let llenv = C_nil();\n     alt { cx.fcx.lliterbody } {\n@@ -5415,7 +5415,7 @@ fn trans_cont(sp: &span, cx: &@block_ctxt) -> result {\n     ret trans_break_cont(sp, cx, false);\n }\n \n-fn trans_ret(cx: &@block_ctxt, e: &option::t[@ast::expr]) -> result {\n+fn trans_ret(cx: &@block_ctxt, e: &option::t<@ast::expr>) -> result {\n     let bcx = cx;\n     alt e {\n       some(x) {\n@@ -5552,7 +5552,7 @@ fn new_scope_block_ctxt(bcx: &@block_ctxt, n: &str) -> @block_ctxt {\n }\n \n fn new_loop_scope_block_ctxt(bcx: &@block_ctxt,\n-                             _cont: &option::t[@block_ctxt],\n+                             _cont: &option::t<@block_ctxt>,\n                              _break: &@block_ctxt, n: &str) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx),\n                        LOOP_SCOPE_BLOCK(_cont, _break), n);\n@@ -5788,11 +5788,11 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: &span, llfndecl: ValueRef,\n     let llretptr: ValueRef = llvm::LLVMGetParam(llfndecl, 0u);\n     let lltaskptr: ValueRef = llvm::LLVMGetParam(llfndecl, 1u);\n     let llenv: ValueRef = llvm::LLVMGetParam(llfndecl, 2u);\n-    let llargs: hashmap[ast::node_id, ValueRef] = new_int_hash[ValueRef]();\n-    let llobjfields: hashmap[ast::node_id, ValueRef] =\n+    let llargs: hashmap<ast::node_id, ValueRef> = new_int_hash[ValueRef]();\n+    let llobjfields: hashmap<ast::node_id, ValueRef> =\n         new_int_hash[ValueRef]();\n-    let lllocals: hashmap[ast::node_id, ValueRef] = new_int_hash[ValueRef]();\n-    let llupvars: hashmap[ast::node_id, ValueRef] = new_int_hash[ValueRef]();\n+    let lllocals: hashmap<ast::node_id, ValueRef> = new_int_hash[ValueRef]();\n+    let llupvars: hashmap<ast::node_id, ValueRef> = new_int_hash[ValueRef]();\n     let derived_tydescs =\n         map::mk_hashmap[ty::t, derived_tydesc_info](ty::hash_ty, ty::eq_ty);\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n@@ -5838,7 +5838,7 @@ fn new_fn_ctxt(cx: @local_ctxt, sp: &span, llfndecl: ValueRef) -> @fn_ctxt {\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n-                             ty_self: option::t[ty::t], ret_ty: ty::t,\n+                             ty_self: option::t<ty::t>, ret_ty: ty::t,\n                              args: &[ast::arg], ty_params: &[ast::ty_param]) {\n     // Skip the implicit arguments 0, 1, and 2.  TODO: Pull out 3u and define\n     // it as a constant, since we're using it in several places in trans this\n@@ -5997,11 +5997,11 @@ fn finish_fn(fcx: &@fn_ctxt, lltop: BasicBlockRef) {\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n-                 llfnty: &option::t[TypeRef], cx: @local_ctxt, sp: &span,\n-                 f: &ast::_fn, llfndecl: ValueRef, ty_self: option::t[ty::t],\n+fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n+                 llfnty: &option::t<TypeRef>, cx: @local_ctxt, sp: &span,\n+                 f: &ast::_fn, llfndecl: ValueRef, ty_self: option::t<ty::t>,\n                  ty_params: &[ast::ty_param], id: ast::node_id)\n-    -> option::t[{fn_pair: ValueRef, bcx: @block_ctxt}] {\n+    -> option::t<{fn_pair: ValueRef, bcx: @block_ctxt}> {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n@@ -6068,7 +6068,7 @@ fn trans_closure(bcx_maybe: &option::t[@block_ctxt],\n }\n \n fn trans_fn_inner(cx: @local_ctxt, sp: &span, f: &ast::_fn,\n-                  llfndecl: ValueRef, ty_self: option::t[ty::t],\n+                  llfndecl: ValueRef, ty_self: option::t<ty::t>,\n                   ty_params: &[ast::ty_param], id: ast::node_id) {\n     trans_closure(none, none, cx, sp, f, llfndecl, ty_self, ty_params, id);\n }\n@@ -6077,7 +6077,7 @@ fn trans_fn_inner(cx: @local_ctxt, sp: &span, f: &ast::_fn,\n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n fn trans_fn(cx: @local_ctxt, sp: &span, f: &ast::_fn, llfndecl: ValueRef,\n-            ty_self: option::t[ty::t], ty_params: &[ast::ty_param],\n+            ty_self: option::t<ty::t>, ty_params: &[ast::ty_param],\n             id: ast::node_id) {\n     if !cx.ccx.sess.get_opts().stats {\n         trans_fn_inner(cx, sp, f, llfndecl, ty_self, ty_params, id);\n@@ -6747,7 +6747,7 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n fn item_path(item: &@ast::item) -> [str] { ret ~[item.ident]; }\n \n fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[str],\n-                       v: &vt[[str]]) {\n+                       v: &vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, _, _) {\n         if !ccx.obj_methods.contains_key(i.id) {\n@@ -6759,7 +6759,7 @@ fn collect_native_item(ccx: @crate_ctxt, i: &@ast::native_item, pt: &[str],\n }\n \n fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n-                  v: &vt[[str]]) {\n+                  v: &vt<[str]>) {\n     visit::visit_item(i, pt + item_path(i), v);\n     alt i.node {\n       ast::item_const(_, _) {\n@@ -6778,7 +6778,7 @@ fn collect_item_1(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n }\n \n fn collect_item_2(ccx: &@crate_ctxt, i: &@ast::item, pt: &[str],\n-                  v: &vt[[str]]) {\n+                  v: &vt<[str]>) {\n     let new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n@@ -6818,7 +6818,7 @@ fn collect_items(ccx: &@crate_ctxt, crate: @ast::crate) {\n }\n \n fn collect_tag_ctor(ccx: @crate_ctxt, i: &@ast::item, pt: &[str],\n-                    v: &vt[[str]]) {\n+                    v: &vt<[str]>) {\n     let new_pt = pt + item_path(i);\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n@@ -6844,7 +6844,7 @@ fn collect_tag_ctors(ccx: &@crate_ctxt, crate: @ast::crate) {\n \n // The constant translation pass.\n fn trans_constant(ccx: @crate_ctxt, it: &@ast::item, pt: &[str],\n-                  v: &vt[[str]]) {\n+                  v: &vt<[str]>) {\n     let new_pt = pt + item_path(it);\n     visit::visit_item(it, new_pt, v);\n     alt it.node {\n@@ -6891,7 +6891,7 @@ fn i2p(v: ValueRef, t: TypeRef) -> ValueRef {\n     ret llvm::LLVMConstIntToPtr(v, t);\n }\n \n-fn declare_intrinsics(llmod: ModuleRef) -> hashmap[str, ValueRef] {\n+fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n     let T_memmove32_args: [TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n     let T_memmove64_args: [TypeRef] ="}, {"sha": "78200726b2d8002c77655f834e4a150da6491a64", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -77,7 +77,7 @@ fn bind_for_pat(p: &@ast::pat, br: &match_branch, val: ValueRef) {\n     }\n }\n \n-type enter_pat = fn(&@ast::pat) -> option::t[[@ast::pat]] ;\n+type enter_pat = fn(&@ast::pat) -> option::t<[@ast::pat]> ;\n \n fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n     let result = ~[];\n@@ -98,7 +98,7 @@ fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n }\n \n fn enter_default(m: &match, col: uint, val: ValueRef) -> match {\n-    fn e(p: &@ast::pat) -> option::t[[@ast::pat]] {\n+    fn e(p: &@ast::pat) -> option::t<[@ast::pat]> {\n         ret if matches_always(p) { some(~[]) } else { none };\n     }\n     ret enter_match(m, col, val, e);\n@@ -108,7 +108,7 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n              tag_size: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(ccx: &@crate_ctxt, dummy: &@ast::pat, opt: &opt, size: uint,\n-         p: &@ast::pat) -> option::t[[@ast::pat]] {\n+         p: &@ast::pat) -> option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_tag(ctor, subpats) {\n             ret if opt_eq(variant_opt(ccx, p.id), opt) {\n@@ -128,7 +128,7 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n    match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: &@ast::pat, fields: &[ast::ident], p: &@ast::pat) ->\n-       option::t[[@ast::pat]] {\n+       option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n             let pats = ~[];\n@@ -150,7 +150,7 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n     fn e(dummy: &@ast::pat, n_elts: uint, p: &@ast::pat)\n-        -> option::t[[@ast::pat]] {\n+        -> option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_tup(elts) { ret some(elts); }\n           _ { ret some(vec::init_elt(dummy, n_elts)); }\n@@ -161,7 +161,7 @@ fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n \n fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t[[@ast::pat]] {\n+    fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_box(sub) { ret some(~[sub]); }\n           _ { ret some(~[dummy]); }\n@@ -431,7 +431,7 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n // Returns false for unreachable blocks\n fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n                      ids: &ast::pat_id_map) -> bool {\n-    fn assoc(key: str, list: &bind_map) -> option::t[ValueRef] {\n+    fn assoc(key: str, list: &bind_map) -> option::t<ValueRef> {\n         for elt: {ident: ast::ident, val: ValueRef} in list {\n             if str::eq(elt.ident, key) { ret some(elt.val); }\n         }\n@@ -486,7 +486,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n     // Cached fail-on-fallthrough block\n     let fail_cx = @mutable none;\n     fn mk_fail(cx: &@block_ctxt, sp: &span,\n-               done: @mutable option::t[BasicBlockRef]) -> BasicBlockRef {\n+               done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n         let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n         trans::trans_fail(fail_cx, some(sp), \"non-exhaustive match failure\");\n@@ -517,7 +517,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n \n // Not alt-related, but similar to the pattern-munging code above\n fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n-                        table: hashmap[ast::node_id, ValueRef],\n+                        table: hashmap<ast::node_id, ValueRef>,\n                         make_copy: bool)\n     -> @block_ctxt {\n     let ccx = bcx.fcx.lcx.ccx;"}, {"sha": "fbec26fc64650787397b0cbeac51bbc5fbb911ac", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -75,10 +75,10 @@ type tydesc_info =\n      tydesc: ValueRef,\n      size: ValueRef,\n      align: ValueRef,\n-     mutable copy_glue: option::t[ValueRef],\n-     mutable drop_glue: option::t[ValueRef],\n-     mutable free_glue: option::t[ValueRef],\n-     mutable cmp_glue: option::t[ValueRef],\n+     mutable copy_glue: option::t<ValueRef>,\n+     mutable drop_glue: option::t<ValueRef>,\n+     mutable free_glue: option::t<ValueRef>,\n+     mutable cmp_glue: option::t<ValueRef>,\n      ty_params: [uint]};\n \n /*\n@@ -110,32 +110,32 @@ type crate_ctxt = {\n     llmod: ModuleRef,\n     td: target_data,\n     tn: type_names,\n-    externs: hashmap[str, ValueRef],\n-    intrinsics: hashmap[str, ValueRef],\n+    externs: hashmap<str, ValueRef>,\n+    intrinsics: hashmap<str, ValueRef>,\n \n     // A mapping from the def_id of each item in this crate to the address\n     // of the first instruction of the item's definition in the executable\n     // we're generating.\n-    item_ids: hashmap[ast::node_id, ValueRef],\n+    item_ids: hashmap<ast::node_id, ValueRef>,\n     ast_map: ast_map::map,\n-    item_symbols: hashmap[ast::node_id, str],\n-    mutable main_fn: option::t[ValueRef],\n+    item_symbols: hashmap<ast::node_id, str>,\n+    mutable main_fn: option::t<ValueRef>,\n     link_meta: link::link_meta,\n-    // TODO: hashmap[tup(tag_id,subtys), @tag_info]\n-    tag_sizes: hashmap[ty::t, uint],\n-    discrims: hashmap[ast::node_id, ValueRef],\n-    discrim_symbols: hashmap[ast::node_id, str],\n-    fn_pairs: hashmap[ast::node_id, ValueRef],\n-    consts: hashmap[ast::node_id, ValueRef],\n-    obj_methods: hashmap[ast::node_id, ()],\n-    tydescs: hashmap[ty::t, @tydesc_info],\n-    module_data: hashmap[str, ValueRef],\n-    lltypes: hashmap[ty::t, TypeRef],\n+    // TODO: hashmap<tup(tag_id,subtys), @tag_info>\n+    tag_sizes: hashmap<ty::t, uint>,\n+    discrims: hashmap<ast::node_id, ValueRef>,\n+    discrim_symbols: hashmap<ast::node_id, str>,\n+    fn_pairs: hashmap<ast::node_id, ValueRef>,\n+    consts: hashmap<ast::node_id, ValueRef>,\n+    obj_methods: hashmap<ast::node_id, ()>,\n+    tydescs: hashmap<ty::t, @tydesc_info>,\n+    module_data: hashmap<str, ValueRef>,\n+    lltypes: hashmap<ty::t, TypeRef>,\n     glues: @glue_fns,\n     names: namegen,\n     sha: std::sha1::sha1,\n-    type_sha1s: hashmap[ty::t, str],\n-    type_short_names: hashmap[ty::t, str],\n+    type_sha1s: hashmap<ty::t, str>,\n+    type_short_names: hashmap<ty::t, str>,\n     tcx: ty::ctxt,\n     stats: stats,\n     upcalls: @upcall::upcalls,\n@@ -216,37 +216,37 @@ type fn_ctxt = {\n \n     // The 'self' object currently in use in this function, if there\n     // is one.\n-    mutable llself: option::t[val_self_pair],\n+    mutable llself: option::t<val_self_pair>,\n \n     // If this function is actually a iter, a block containing the\n     // code called whenever the iter calls 'put'.\n-    mutable lliterbody: option::t[ValueRef],\n+    mutable lliterbody: option::t<ValueRef>,\n \n     // If this function is actually a iter, the type of the function\n     // that that we call when we call 'put'. Having to track this is\n     // pretty irritating. We have to do it because we need the type if\n     // we are going to put the iterbody into a closure (if it appears\n     // in a for-each inside of an iter).\n-    mutable iterbodyty: option::t[ty::t],\n+    mutable iterbodyty: option::t<ty::t>,\n \n     // The next four items: hash tables mapping from AST def_ids to\n     // LLVM-stuff-in-the-frame.\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: hashmap[ast::node_id, ValueRef],\n+    llargs: hashmap<ast::node_id, ValueRef>,\n \n     // Maps fields in objects to pointers into the interior of\n     // llself's body.\n-    llobjfields: hashmap[ast::node_id, ValueRef],\n+    llobjfields: hashmap<ast::node_id, ValueRef>,\n \n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: hashmap[ast::node_id, ValueRef],\n+    lllocals: hashmap<ast::node_id, ValueRef>,\n \n     // The same as above, but for variables accessed via the frame\n     // pointer we pass into an iter, for access to the static\n     // environment of the iter-calling frame.\n-    llupvars: hashmap[ast::node_id, ValueRef],\n+    llupvars: hashmap<ast::node_id, ValueRef>,\n \n     // For convenience, a vector of the incoming tydescs for each of\n     // this functions type parameters, fetched via llvm::LLVMGetParam.\n@@ -263,7 +263,7 @@ type fn_ctxt = {\n     // when information about both \"[T]\" and \"T\" are available.  When\n     // such a tydesc is created, we cache it in the derived_tydescs\n     // table for the next time that such a tydesc is needed.\n-    derived_tydescs: hashmap[ty::t, derived_tydesc_info],\n+    derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n \n     // The node_id of the function, or -1 if it doesn't correspond to\n     // a user-defined function.\n@@ -350,7 +350,7 @@ tag block_kind {\n     // which block to jump to in the case of \"continue\" or \"break\", with the\n     // \"continue\" block optional, because \"while\" and \"do while\" don't support\n     // \"continue\" (TODO: is this intentional?)\n-    LOOP_SCOPE_BLOCK(option::t[@block_ctxt], @block_ctxt);\n+    LOOP_SCOPE_BLOCK(option::t<@block_ctxt>, @block_ctxt);\n \n \n     // A non-scope block is a basic block created as a translation artifact\n@@ -397,7 +397,7 @@ type block_ctxt = {\n     fcx: @fn_ctxt\n };\n \n-// FIXME: we should be able to use option::t[@block_parent] here but\n+// FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n tag block_parent { parent_none; parent_some(@block_ctxt); }\n "}, {"sha": "d8f08f7fc2bd5299cd17eb6faf78049446957526", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -423,7 +423,7 @@ fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n // ones that we don't need forwarding slots for.\n fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n                 addtl_meths: [@ast::method]) ->\n-    option::t[vtbl_mthd] {\n+    option::t<vtbl_mthd> {\n \n     // Since m is a fwding_mthd, and we're checking to see if it's in\n     // addtl_meths (which only contains normal_mthds), we can't just check if\n@@ -448,7 +448,7 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd,\n // object, and return a pointer to it.\n fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n                ob: &ast::_obj, ty_params: &[ast::ty_param],\n-               inner_obj_ty: option::t[ty::t],\n+               inner_obj_ty: option::t<ty::t>,\n                additional_field_tys: &[ty::t]) -> ValueRef {\n \n     let llmethods: [ValueRef] = ~[];\n@@ -892,7 +892,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n // object body: [tydesc, [typaram, ...], [field, ...], inner_obj].\n fn create_object_body_type(tcx: &ty::ctxt, fields_ty: &[ty::t],\n                            typarams_ty: &[ty::t],\n-                           maybe_inner_obj_ty: option::t[ty::t]) -> ty::t {\n+                           maybe_inner_obj_ty: option::t<ty::t>) -> ty::t {\n \n     let tydesc_ty: ty::t = ty::mk_type(tcx);\n     let typarams_ty_tup: ty::t = ty::mk_tup(tcx, typarams_ty);"}, {"sha": "cf52ea94537fe13d9183f83d777e4538b3dc0c19", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -208,11 +208,11 @@ Both types store an ident and span, for error-logging purposes.\n */\n type pred_args_ = {args: [@constr_arg_use], bit_num: uint};\n \n-type pred_args = spanned[pred_args_];\n+type pred_args = spanned<pred_args_>;\n \n // The attached node ID is the *defining* node ID\n // for this local.\n-type constr_arg_use = spanned[constr_arg_general_[inst]];\n+type constr_arg_use = spanned<constr_arg_general_<inst>>;\n \n tag constraint {\n     cinit(uint, span, ident);\n@@ -232,11 +232,11 @@ tag tsconstr {\n     npred(path, def_id, [@constr_arg_use]);\n }\n \n-type sp_constr = spanned[tsconstr];\n+type sp_constr = spanned<tsconstr>;\n \n type norm_constraint = {bit_num: uint, c: sp_constr};\n \n-type constr_map = @std::map::hashmap[def_id, constraint];\n+type constr_map = @std::map::hashmap<def_id, constraint>;\n \n /* Contains stuff that has to be computed up front */\n type fn_info =\n@@ -295,7 +295,7 @@ type node_ann_table = @mutable [mutable ts_ann];\n \n \n /* mapping from function name to fn_info map */\n-type fn_info_map = @std::map::hashmap[node_id, fn_info];\n+type fn_info_map = @std::map::hashmap<node_id, fn_info>;\n \n type fn_ctxt =\n     {enclosing: fn_info,\n@@ -318,7 +318,7 @@ fn add_node(ccx: &crate_ctxt, i: node_id, a: &ts_ann) {\n     ccx.node_anns.(i) = a;\n }\n \n-fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t[ts_ann] {\n+fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t<ts_ann> {\n     if i as uint < vec::len(*ccx.node_anns) {\n         ret some[ts_ann](ccx.node_anns.(i));\n     } else { ret none[ts_ann]; }\n@@ -547,10 +547,10 @@ fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n     }\n }\n \n-fn node_id_to_def(ccx: &crate_ctxt, id: node_id) -> option::t[def] {\n+fn node_id_to_def(ccx: &crate_ctxt, id: node_id) -> option::t<def> {\n     ret ccx.tcx.def_map.find(id);\n }\n-fn node_id_to_def_upvar(cx: &fn_ctxt, id: node_id) -> option::t[def] {\n+fn node_id_to_def_upvar(cx: &fn_ctxt, id: node_id) -> option::t<def> {\n     ret freevars::def_lookup(cx.ccx.tcx, cx.id, id);\n }\n \n@@ -704,7 +704,7 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n     }\n }\n \n-fn pred_args_matches(pattern: &[constr_arg_general_[inst]],\n+fn pred_args_matches(pattern: &[constr_arg_general_<inst>],\n                      desc: &pred_args) -> bool {\n     let i = 0u;\n     for c: @constr_arg_use in desc.node.args {\n@@ -729,8 +729,8 @@ fn pred_args_matches(pattern: &[constr_arg_general_[inst]],\n     ret true;\n }\n \n-fn find_instance_(pattern: &[constr_arg_general_[inst]],\n-                  descs: &[pred_args]) -> option::t[uint] {\n+fn find_instance_(pattern: &[constr_arg_general_<inst>],\n+                  descs: &[pred_args]) -> option::t<uint> {\n     for d: pred_args in descs {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n@@ -764,7 +764,7 @@ fn find_instances(fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n     rslt\n }\n \n-fn find_in_subst(id: node_id, s: &subst) -> option::t[inst] {\n+fn find_in_subst(id: node_id, s: &subst) -> option::t<inst> {\n     for p: {from: inst, to: inst} in s {\n         if id == p.from.node { ret some(p.to); }\n     }\n@@ -775,9 +775,9 @@ fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(stuff: &[constr_arg_general_[inst]]) -> str {\n+fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> str {\n     let rslt = \"<\";\n-    for i: constr_arg_general_[inst] in stuff {\n+    for i: constr_arg_general_<inst> in stuff {\n         rslt +=\n             \" \" +\n                 alt i {\n@@ -790,8 +790,8 @@ fn insts_to_str(stuff: &[constr_arg_general_[inst]]) -> str {\n     rslt\n }\n \n-fn replace(subst: subst, d: pred_args) -> [constr_arg_general_[inst]] {\n-    let rslt: [constr_arg_general_[inst]] = ~[];\n+fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n+    let rslt: [constr_arg_general_<inst>] = ~[];\n     for c: @constr_arg_use in d.node.args {\n         alt c.node {\n           carg_ident(p) {\n@@ -808,7 +808,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_[inst]] {\n     }\n \n     /*\n-    for (constr_arg_general_[tup(ident, def_id)] p in rslt) {\n+    for (constr_arg_general_<tup(ident, def_id)> p in rslt) {\n         alt (p) {\n             case (carg_ident(?p)) {\n                 log_err p._0;\n@@ -849,11 +849,11 @@ fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n     }\n }\n \n-fn local_node_id_to_def(fcx: &fn_ctxt, i: &node_id) -> option::t[def] {\n+fn local_node_id_to_def(fcx: &fn_ctxt, i: &node_id) -> option::t<def> {\n     fcx.ccx.tcx.def_map.find(i)\n }\n \n-fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t[def_id] {\n+fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t<def_id> {\n     alt local_node_id_to_def(fcx, i) {\n       some(def_local(d_id)) { some(d_id) }\n       some(def_arg(a_id)) { some(a_id) }\n@@ -862,7 +862,7 @@ fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t[def_id] {\n }\n \n fn local_node_id_to_local_def_id(fcx: &fn_ctxt, i: &node_id) ->\n-   option::t[node_id] {\n+   option::t<node_id> {\n     alt local_node_id_to_def(fcx, i) {\n       some(def_local(d_id)) { some(d_id.node) }\n       some(def_arg(a_id)) { some(a_id.node) }\n@@ -1052,7 +1052,7 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n \n // default function visitor\n fn do_nothing[T](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident,\n-                 iid: node_id, cx: &T, v: &visit::vt[T]) {\n+                 iid: node_id, cx: &T, v: &visit::vt<T>) {\n }\n \n \n@@ -1077,7 +1077,7 @@ fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n     ret respan(c.span, tconstr);\n }\n \n-type binding = {lhs: [inst], rhs: option::t[initializer]};\n+type binding = {lhs: [inst], rhs: option::t<initializer>};\n \n fn local_to_bindings(loc : &@local) -> binding {\n     let lhs = ~[];"}, {"sha": "f61604e1ec4942183532bec36e6bebc7175cb36a", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -139,21 +139,21 @@ fn declare_var(fcx: &fn_ctxt, c: &tsconstr, pre: prestate) -> prestate {\n }\n \n fn relax_precond_expr(e: &@expr, cx: &relax_ctxt,\n-                      vt: &visit::vt[relax_ctxt]) {\n+                      vt: &visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, expr_precond(cx.fcx.ccx, e));\n     visit::visit_expr(e, cx, vt);\n }\n \n fn relax_precond_stmt(s: &@stmt, cx: &relax_ctxt,\n-                      vt: &visit::vt[relax_ctxt]) {\n+                      vt: &visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, stmt_precond(cx.fcx.ccx, *s));\n     visit::visit_stmt(s, cx, vt);\n }\n \n type relax_ctxt = {fcx:fn_ctxt, i:node_id};\n \n fn relax_precond_block_inner(b: &blk, cx: &relax_ctxt,\n-                             vt: &visit::vt[relax_ctxt]) {\n+                             vt: &visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, block_precond(cx.fcx.ccx, b));\n     visit::visit_block(b, cx, vt);\n }\n@@ -166,7 +166,7 @@ fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b:&blk) {\n           visit_expr: relax_precond_expr,\n           visit_stmt: relax_precond_stmt,\n           visit_item: (fn (i: &@item, cx: &relax_ctxt,\n-                           vt: &visit::vt[relax_ctxt]) {})\n+                           vt: &visit::vt<relax_ctxt>) {})\n           with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);"}, {"sha": "061ccd4811dc1201ed05be08a0c10e5685075850", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -61,7 +61,7 @@ fn check_unused_vars(fcx: &fn_ctxt) {\n     }\n }\n \n-fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt[fn_ctxt]) {\n+fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     visit::visit_expr(e, fcx, v);\n \n     let prec: precond = expr_precond(fcx.ccx, e);\n@@ -92,7 +92,7 @@ fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt[fn_ctxt]) {\n     }\n }\n \n-fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt[fn_ctxt]) {\n+fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     visit::visit_stmt(s, fcx, v);\n \n     let a = stmt_to_ann(fcx.ccx, *s);\n@@ -184,7 +184,7 @@ fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &[ast::ty_param], id: node_id,\n }\n \n fn fn_states(f: &_fn, tps: &[ast::ty_param], sp: &span, i: &fn_ident,\n-             id: node_id, ccx: &crate_ctxt, v: &visit::vt[crate_ctxt]) {\n+             id: node_id, ccx: &crate_ctxt, v: &visit::vt<crate_ctxt>) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */\n "}, {"sha": "912bf1bd5e85b47cb273dfa80cdb2e334501e17e", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -13,7 +13,7 @@ import syntax::ast::respan;\n \n type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n-fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt[ctxt]) {\n+fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt<ctxt>) {\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(id) { id } };\n         log \"collect_local: pushing \" + ident;\n@@ -22,7 +22,7 @@ fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt[ctxt]) {\n     visit::visit_local(loc, cx, v);\n }\n \n-fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt[ctxt]) {\n+fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n     alt e.node {\n       expr_check(_, ch) { *cx.cs += ~[expr_to_constr(cx.tcx, ch)]; }\n       expr_if_check(ex, _, _) { *cx.cs += ~[expr_to_constr(cx.tcx, ex)]; }"}, {"sha": "9f7678878df157c33aecffc7a00f196ea5f20da4", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -157,7 +157,7 @@ fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n-                  maybe_alt: &option::t[@expr], id: node_id, chck: &if_ty) {\n+                  maybe_alt: &option::t<@expr>, id: node_id, chck: &if_ty) {\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n     alt maybe_alt {\n@@ -553,7 +553,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n         let cmodes = callee_modes(fcx, operator.id);\n         let modes = ~[];\n         let i = 0;\n-        for expr_opt: option::t[@expr] in maybe_args {\n+        for expr_opt: option::t<@expr> in maybe_args {\n             alt expr_opt {\n               none. {/* no-op */ }\n               some(expr) {\n@@ -723,7 +723,7 @@ fn find_pre_post_fn(fcx: &fn_ctxt, f: &_fn) {\n }\n \n fn fn_pre_post(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n-               id: node_id, ccx: &crate_ctxt, v: &visit::vt[crate_ctxt]) {\n+               id: node_id, ccx: &crate_ctxt, v: &visit::vt<crate_ctxt>) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     assert (ccx.fm.contains_key(id));\n     let fcx ="}, {"sha": "787f3ba2e031041af70dd0912d48b484bdf3b51c", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -84,7 +84,7 @@ fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding])\n }\n \n fn find_pre_post_state_sub(fcx: &fn_ctxt, pres: &prestate, e: &@expr,\n-                           parent: node_id, c: option::t[tsconstr]) -> bool {\n+                           parent: node_id, c: option::t<tsconstr>) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, e);\n \n     changed = set_prestate_ann(fcx.ccx, parent, pres) || changed;\n@@ -238,7 +238,7 @@ fn gen_if_local(fcx: &fn_ctxt, p: &poststate, e: &@expr) -> bool {\n }\n \n fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n-                  maybe_alt: &option::t[@expr], id: node_id, chk: &if_ty,\n+                  maybe_alt: &option::t<@expr>, id: node_id, chk: &if_ty,\n                   pres: &prestate) -> bool {\n     let changed =\n         set_prestate_ann(fcx.ccx, id, pres) |\n@@ -328,7 +328,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n         let callee_ops = callee_arg_init_ops(fcx, operator.id);\n         let ops = ~[];\n         let i = 0;\n-        for a_opt: option::t[@expr] in maybe_args {\n+        for a_opt: option::t<@expr> in maybe_args {\n             alt a_opt {\n               none. {/* no-op */ }\n               some(a) {"}, {"sha": "c4d3cc0c3844215bfca080cad8ba553e85d24b59", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -199,14 +199,14 @@ type method =\n      cf: controlflow,\n      constrs: [@constr]};\n \n-type constr_table = hashmap[ast::node_id, [constr]];\n+type constr_table = hashmap<ast::node_id, [constr]>;\n \n type mt = {ty: t, mut: ast::mutability};\n \n \n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n-type creader_cache = hashmap[{cnum: int, pos: uint, len: uint}, ty::t];\n+type creader_cache = hashmap<{cnum: int, pos: uint, len: uint}, ty::t>;\n \n type ctxt =\n \n@@ -219,11 +219,11 @@ type ctxt =\n       freevars: freevars::freevar_map,\n       tcache: type_cache,\n       rcache: creader_cache,\n-      short_names_cache: hashmap[t, str],\n-      has_pointer_cache: hashmap[t, bool],\n-      kind_cache: hashmap[t, ast::kind],\n-      owns_heap_mem_cache: hashmap[t, bool],\n-      ast_ty_to_ty_cache: hashmap[@ast::ty, option::t[t]]};\n+      short_names_cache: hashmap<t, str>,\n+      has_pointer_cache: hashmap<t, bool>,\n+      kind_cache: hashmap<t, ast::kind>,\n+      owns_heap_mem_cache: hashmap<t, bool>,\n+      ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>};\n \n type ty_ctxt = ctxt;\n \n@@ -239,7 +239,7 @@ fn method_ty_to_fn_ty(cx: &ctxt, m: method) -> t {\n // Never construct these manually. These are interned.\n type raw_t =\n     {struct: sty,\n-     cname: option::t[str],\n+     cname: option::t<str>,\n      hash: uint,\n      has_params: bool,\n      has_vars: bool};\n@@ -284,9 +284,9 @@ tag sty {\n \n // In the middle end, constraints have a def_id attached, referring\n // to the definition of the operator in the constraint.\n-type constr_general[ARG] = spanned[constr_general_[ARG, def_id]];\n-type type_constr = constr_general[path];\n-type constr = constr_general[uint];\n+type constr_general[ARG] = spanned<constr_general_<ARG, def_id>>;\n+type type_constr = constr_general<path>;\n+type constr = constr_general<uint>;\n \n // Data structures used in type unification\n tag type_err {\n@@ -308,7 +308,7 @@ tag type_err {\n \n type ty_param_kinds_and_ty = {kinds: [ast::kind], ty: t};\n \n-type type_cache = hashmap[ast::def_id, ty_param_kinds_and_ty];\n+type type_cache = hashmap<ast::def_id, ty_param_kinds_and_ty>;\n \n const idx_nil: uint = 0u;\n \n@@ -352,12 +352,12 @@ const idx_bot: uint = 19u;\n \n const idx_first_others: uint = 20u;\n \n-type type_store = interner::interner[@raw_t];\n+type type_store = interner::interner<@raw_t>;\n \n-type ty_param_substs_opt_and_ty = {substs: option::t[[ty::t]], ty: ty::t};\n+type ty_param_substs_opt_and_ty = {substs: option::t<[ty::t]>, ty: ty::t};\n \n type node_type_table =\n-    @smallintmap::smallintmap[ty::ty_param_substs_opt_and_ty];\n+    @smallintmap::smallintmap<ty::ty_param_substs_opt_and_ty>;\n \n fn populate_type_store(cx: &ctxt) {\n     intern(cx, ty_nil, none);\n@@ -421,7 +421,7 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map, amap: ast_map::map,\n \n \n // Type constructors\n-fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n+fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t<str>) -> @raw_t {\n     let cname = none;\n     let h = hash_type_info(st, cname);\n     let has_params: bool = false;\n@@ -502,11 +502,11 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, in_cname: &option::t[str]) -> @raw_t {\n           has_vars: has_vars};\n }\n \n-fn intern(cx: &ctxt, st: &sty, cname: &option::t[str]) {\n+fn intern(cx: &ctxt, st: &sty, cname: &option::t<str>) {\n     interner::intern(*cx.ts, mk_raw_ty(cx, st, cname));\n }\n \n-fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t[str]) -> t {\n+fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<str>) -> t {\n     let raw_type = mk_raw_ty(cx, st, cname);\n     ret interner::intern(*cx.ts, raw_type);\n }\n@@ -621,7 +621,7 @@ fn struct(cx: &ctxt, typ: &t) -> sty {\n \n \n // Returns the canonical name of the given type.\n-fn cname(cx: &ctxt, typ: &t) -> option::t[str] {\n+fn cname(cx: &ctxt, typ: &t) -> option::t<str> {\n     ret interner::get(*cx.ts, typ).cname;\n }\n \n@@ -1363,7 +1363,7 @@ fn type_is_pod(cx : &ctxt, ty : &t) -> bool {\n     ret result;\n }\n \n-fn type_param(cx: &ctxt, ty: &t) -> option::t[uint] {\n+fn type_param(cx: &ctxt, ty: &t) -> option::t<uint> {\n     alt struct(cx, ty) {\n       ty_param(id,_) { ret some(id); }\n       _ {/* fall through */ }\n@@ -1536,7 +1536,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n }\n \n-fn hash_type_info(st: &sty, cname_opt: &option::t[str]) -> uint {\n+fn hash_type_info(st: &sty, cname_opt: &option::t<str>) -> uint {\n     let h = hash_type_structure(st);\n     alt cname_opt {\n       none. {/* no-op */ }\n@@ -1554,8 +1554,8 @@ fn hash_ty(typ: &t) -> uint { ret typ; }\n // users should use `eq_ty()` instead.\n fn eq_int(x: &uint, y: &uint) -> bool { ret x == y; }\n \n-fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg[T],\n-             b: @sp_constr_arg[T]) -> bool {\n+fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg<T>,\n+             b: @sp_constr_arg<T>) -> bool {\n     alt a.node {\n       ast::carg_base. {\n         alt b.node { ast::carg_base. { ret true; } _ { ret false; } }\n@@ -1569,10 +1569,10 @@ fn arg_eq[T](eq: &fn(&T, &T) -> bool , a: @sp_constr_arg[T],\n     }\n }\n \n-fn args_eq[T](eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg[T]],\n-              b: &[@sp_constr_arg[T]]) -> bool {\n+fn args_eq[T](eq: fn(&T, &T) -> bool , a: &[@sp_constr_arg<T>],\n+              b: &[@sp_constr_arg<T>]) -> bool {\n     let i: uint = 0u;\n-    for arg: @sp_constr_arg[T] in a {\n+    for arg: @sp_constr_arg<T> in a {\n         if !arg_eq(eq, arg, b.(i)) { ret false; }\n         i += 1u;\n     }\n@@ -2008,7 +2008,7 @@ fn is_lval(expr: &@ast::expr) -> bool {\n     }\n }\n \n-fn occurs_check_fails(tcx: &ctxt, sp: &option::t[span], vid: int, rt: &t)\n+fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: &t)\n     -> bool {\n     if (!type_contains_vars(tcx, rt)) {\n         // Fast path\n@@ -2066,7 +2066,7 @@ mod unify {\n \n     }\n     type var_bindings =\n-        {sets: ufind::ufind, types: smallintmap::smallintmap[t]};\n+        {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n     type ctxt = {vb: @var_bindings, tcx: ty_ctxt};\n \n@@ -2198,7 +2198,7 @@ mod unify {\n \n     // Unifies two mutability flags.\n     fn unify_mut(expected: ast::mutability, actual: ast::mutability) ->\n-       option::t[ast::mutability] {\n+       option::t<ast::mutability> {\n         if expected == actual { ret some(expected); }\n         if expected == ast::maybe_mut { ret some(actual); }\n         if actual == ast::maybe_mut { ret some(expected); }\n@@ -2736,7 +2736,7 @@ mod unify {\n         while i < vec::len[ufind::node](vb.sets.nodes) {\n             let sets = \"\";\n             let j = 0u;\n-            while j < vec::len[option::t[uint]](vb.sets.nodes) {\n+            while j < vec::len[option::t<uint>](vb.sets.nodes) {\n                 if ufind::find(vb.sets, j) == i {\n                     sets += #fmt(\" %u\", j);\n                 }\n@@ -2756,10 +2756,10 @@ mod unify {\n     //    Takes an optional span - complain about occurs check violations\n     //    iff the span is present (so that if we already know we're going\n     //    to error anyway, we don't complain)\n-    fn fixup_vars(tcx: ty_ctxt, sp: &option::t[span],\n+    fn fixup_vars(tcx: ty_ctxt, sp: &option::t<span>,\n                   vb: @var_bindings, typ: t) -> fixup_result {\n-        fn subst_vars(tcx: ty_ctxt, sp: &option::t[span], vb: @var_bindings,\n-                      unresolved: @mutable option::t[int], vid: int) -> t {\n+        fn subst_vars(tcx: ty_ctxt, sp: &option::t<span>, vb: @var_bindings,\n+                      unresolved: @mutable option::t<int>, vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n             // doesn't allow returning anything but a t.\n             if vid as uint >= ufind::set_count(vb.sets) {\n@@ -2789,7 +2789,7 @@ mod unify {\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n-    fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t[span],\n+    fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t<span>,\n                         vb: &@var_bindings, vid: int) ->\n        fixup_result {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n@@ -3090,8 +3090,8 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n     ret tbl.(tycat(cx, ty)).(opcat(op));\n }\n \n-fn ast_constr_to_constr[T](tcx: ty::ctxt, c: &@ast::constr_general[T]) ->\n-   @ty::constr_general[T] {\n+fn ast_constr_to_constr[T](tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n+   @ty::constr_general<T> {\n     alt tcx.def_map.find(c.node.id) {\n       some(ast::def_fn(pred_id, ast::pure_fn.)) {\n         ret @respan(c.span,"}, {"sha": "7d5d3acf951a0f81967854333f005182a5810eec", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -49,15 +49,15 @@ import syntax::print::pprust::*;\n \n export check_crate;\n \n-type ty_table = hashmap[ast::def_id, ty::t];\n+type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an object.\n tag obj_info {\n     // Regular objects have a node_id at compile time.\n     regular_obj([ast::obj_field], ast::node_id);\n     // Anonymous objects only have a type at compile time.  It's optional\n     // because not all anonymous objects have a inner_obj to attach to.\n-    anon_obj([ast::obj_field], option::t[ty::sty]);\n+    anon_obj([ast::obj_field], option::t<ty::sty>);\n }\n \n type crate_ctxt = {mutable obj_infos: [obj_info], tcx: ty::ctxt};\n@@ -70,8 +70,8 @@ type fn_ctxt =\n      purity: ast::purity,\n      proto: ast::proto,\n      var_bindings: @ty::unify::var_bindings,\n-     locals: hashmap[ast::node_id, int],\n-     local_names: hashmap[ast::node_id, ast::ident],\n+     locals: hashmap<ast::node_id, int>,\n+     local_names: hashmap<ast::node_id, ast::ident>,\n      next_var_id: @mutable int,\n      mutable fixups: [ast::node_id],\n      ccx: @crate_ctxt};\n@@ -235,7 +235,7 @@ fn structure_of(fcx: &@fn_ctxt, sp: &span, typ: ty::t) -> ty::sty {\n // Returns the one-level-deep structure of the given type or none if it\n // is not known yet.\n fn structure_of_maybe(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n-   option::t[ty::sty] {\n+   option::t<ty::sty> {\n     let r =\n         ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n     ret alt r {\n@@ -433,7 +433,7 @@ fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: &@ast::ty) -> ty::t {\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: &@ast::ty)\n-    -> option::t[ty::t] {\n+    -> option::t<ty::t> {\n     alt ast_ty.node {\n       ast::ty_infer. { none }\n       _ { some(ast_ty_to_ty_crate(ccx, ast_ty)) }\n@@ -544,7 +544,7 @@ mod collect {\n     fn ty_of_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t ,\n                      ty_of_arg: &fn(&ast::arg) -> arg , decl: &ast::fn_decl,\n                      proto: ast::proto, ty_params: &[ast::ty_param],\n-                     def_id: &option::t[ast::def_id]) ->\n+                     def_id: &option::t<ast::def_id>) ->\n        ty::ty_param_kinds_and_ty {\n         let input_tys = ~[];\n         for a: ast::arg in decl.inputs { input_tys += ~[ty_of_arg(a)]; }\n@@ -775,7 +775,7 @@ mod collect {\n         }\n         ret meths;\n     }\n-    fn convert(cx: @ctxt, abi: @mutable option::t[ast::native_abi],\n+    fn convert(cx: @ctxt, abi: @mutable option::t<ast::native_abi>,\n                it: &@ast::item) {\n         alt it.node {\n           ast::item_mod(_) {\n@@ -850,7 +850,7 @@ mod collect {\n           }\n         }\n     }\n-    fn convert_native(cx: @ctxt, abi: @mutable option::t[ast::native_abi],\n+    fn convert_native(cx: @ctxt, abi: @mutable option::t<ast::native_abi>,\n                       i: &@ast::native_item) {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n@@ -1077,7 +1077,7 @@ mod writeback {\n     export resolve_type_vars_in_expr;\n \n     fn resolve_type_vars_in_type(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n-       option::t[ty::t] {\n+       option::t<ty::t> {\n         if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n         alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp),\n                                   fcx.var_bindings, typ) {\n@@ -1120,7 +1120,7 @@ mod writeback {\n         // As soon as we hit an error we have to stop resolving\n         // the entire function\n         {fcx: @fn_ctxt, mutable success: bool};\n-    type wb_vt = visit::vt[wb_ctxt];\n+    type wb_vt = visit::vt<wb_ctxt>;\n \n     fn visit_stmt(s: &@ast::stmt, wbcx: &wb_ctxt, v: &wb_vt) {\n         if !wbcx.success { ret; }\n@@ -1197,13 +1197,13 @@ mod writeback {\n // for them before typechecking the function.\n type gather_result =\n     {var_bindings: @ty::unify::var_bindings,\n-     locals: hashmap[ast::node_id, int],\n-     local_names: hashmap[ast::node_id, ast::ident],\n+     locals: hashmap<ast::node_id, int>,\n+     local_names: hashmap<ast::node_id, ast::ident>,\n      next_var_id: @mutable int};\n \n // Used only as a helper for check_fn.\n fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n-                 old_fcx: &option::t[@fn_ctxt]) -> gather_result {\n+                 old_fcx: &option::t<@fn_ctxt>) -> gather_result {\n     let {vb, locals, local_names, nvi} = alt old_fcx {\n       none. {\n         { vb: ty::unify::mk_var_bindings(),\n@@ -1226,7 +1226,7 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n         ret rv;\n     };\n     let assign = lambda(nid: ast::node_id, ident: &ast::ident,\n-                        ty_opt: option::t[ty::t]) {\n+                        ty_opt: option::t<ty::t>) {\n         let var_id = next_var_id();\n         locals.insert(nid, var_id);\n         local_names.insert(nid, ident);\n@@ -1263,14 +1263,14 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     }\n \n     // Add explicitly-declared locals.\n-    let visit_local = lambda(local: &@ast::local, e: &(), v: &visit::vt[()]) {\n+    let visit_local = lambda(local: &@ast::local, e: &(), v: &visit::vt<()>) {\n         let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n         assign(local.node.id, ident_for_local(local), local_ty);\n         visit::visit_local(local, e, v);\n     };\n \n     // Add pattern bindings.\n-    let visit_pat = lambda(p: &@ast::pat, e: &(), v: &visit::vt[()]) {\n+    let visit_pat = lambda(p: &@ast::pat, e: &(), v: &visit::vt<()>) {\n         alt p.node {\n           ast::pat_bind(ident) {\n             assign(p.id, ident, none);\n@@ -1283,8 +1283,8 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     // Don't descend into fns and items\n     fn visit_fn[E](f: &ast::_fn, tp: &[ast::ty_param], sp: &span,\n                    i: &ast::fn_ident, id: ast::node_id, e: &E,\n-                   v: &visit::vt[E]) { }\n-    fn visit_item[E](i: &@ast::item, e: &E, v: &visit::vt[E]) { }\n+                   v: &visit::vt<E>) { }\n+    fn visit_item[E](i: &@ast::item, e: &E, v: &visit::vt<E>) { }\n \n     let visit =\n         @{visit_local: visit_local,\n@@ -1538,7 +1538,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                          args: &[option::t[@ast::expr]],\n+                          args: &[option::t<@ast::expr>],\n                           call_kind: call_kind) -> bool {\n         // Check the function.\n         let bot = check_expr(fcx, f);\n@@ -1587,7 +1587,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n \n         // Check that the correct number of arguments were supplied.\n         let expected_arg_count = vec::len[ty::arg](arg_tys);\n-        let supplied_arg_count = vec::len[option::t[@ast::expr]](args);\n+        let supplied_arg_count = vec::len[option::t<@ast::expr>](args);\n         if expected_arg_count != supplied_arg_count {\n             fcx.ccx.tcx.sess.span_fatal(sp,\n                                         #fmt(\"this function takes %u \\\n@@ -1612,7 +1612,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         let check_args = lambda(check_blocks: bool) -> bool {\n             let i = 0u;\n             let bot = false;\n-            for a_opt: option::t[@ast::expr] in args {\n+            for a_opt: option::t<@ast::expr> in args {\n                 alt a_opt {\n                   some(a) {\n                     let is_block =\n@@ -1647,7 +1647,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     // A generic function for checking call expressions\n     fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n                   args: &[@ast::expr], call_kind: call_kind) -> bool {\n-        let args_opt_0: [option::t[@ast::expr]] = ~[];\n+        let args_opt_0: [option::t<@ast::expr>] = ~[];\n         for arg: @ast::expr in args {\n             args_opt_0 += ~[some[@ast::expr](arg)];\n         }\n@@ -1745,7 +1745,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n     // A generic function for checking the then and else in an if\n     // or if-check\n     fn check_then_else(fcx: &@fn_ctxt, thn: &ast::blk,\n-                       elsopt: &option::t[@ast::expr], id: ast::node_id,\n+                       elsopt: &option::t<@ast::expr>, id: ast::node_id,\n                        sp: &span) -> bool {\n         let then_bot = check_block(fcx, thn);\n         let els_bot = false;\n@@ -2093,7 +2093,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             // For each blank argument, add the type of that argument\n             // to the resulting function type.\n             let i = 0u;\n-            while i < vec::len[option::t[@ast::expr]](args) {\n+            while i < vec::len[option::t<@ast::expr>](args) {\n                 alt args.(i) {\n                   some(_) {/* no-op */ }\n                   none. { arg_tys_1 += ~[arg_tys.(i)]; }\n@@ -2113,9 +2113,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       }\n       ast::expr_self_method(ident) {\n         let t = ty::mk_nil(tcx);\n-        let this_obj_sty: option::t[ty::sty] =\n+        let this_obj_sty: option::t<ty::sty> =\n             some(structure_of(fcx, expr.span, ty::mk_nil(tcx)));\n-        let this_obj_info: option::t[obj_info] = get_obj_info(fcx.ccx);\n+        let this_obj_info: option::t<obj_info> = get_obj_info(fcx.ccx);\n         alt this_obj_info {\n           some(oinfo) {\n             alt oinfo {\n@@ -2205,7 +2205,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n       }\n       ast::expr_rec(fields, base) {\n         alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n-        let fields_t: [spanned[field]] = ~[];\n+        let fields_t: [spanned<field>] = ~[];\n         for f: ast::field in fields {\n             bot |= check_expr(fcx, f.node.expr);\n             let expr_t = expr_ty(tcx, f.node.expr);\n@@ -2218,7 +2218,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n         }\n         alt base {\n           none. {\n-            fn get_node(f: &spanned[field]) -> field { f.node }\n+            fn get_node(f: &spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(get_node, fields_t));\n             write::ty_only_fixup(fcx, id, typ);\n           }\n@@ -2234,7 +2234,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n               }\n             }\n             write::ty_only_fixup(fcx, id, bexpr_t);\n-            for f: spanned[ty::field] in fields_t {\n+            for f: spanned<ty::field> in fields_t {\n                 let found = false;\n                 for bf: ty::field in base_fields {\n                     if str::eq(f.node.ident, bf.ident) {\n@@ -2362,7 +2362,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             // type.\n             let inner_obj_methods: [ty::method] = ~[];\n             let inner_obj_ty: ty::t = ty::mk_nil(tcx);\n-            let inner_obj_sty: option::t[ty::sty] = none;\n+            let inner_obj_sty: option::t<ty::sty> = none;\n             alt ao.inner_obj {\n               none. { }\n               some(e) {\n@@ -2399,7 +2399,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr,\n             fn filtering_fn(ccx: @crate_ctxt,\n                             m: &ty::method,\n                             outer_obj_methods: [@ast::method]) ->\n-                option::t[ty::method] {\n+                option::t<ty::method> {\n \n                 for om: @ast::method in outer_obj_methods {\n                     if str::eq(om.node.ident, m.ident) {\n@@ -2473,7 +2473,7 @@ fn next_ty_var(fcx: &@fn_ctxt) -> ty::t {\n     ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n }\n \n-fn get_obj_info(ccx: &@crate_ctxt) -> option::t[obj_info] {\n+fn get_obj_info(ccx: &@crate_ctxt) -> option::t<obj_info> {\n     ret vec::last[obj_info](ccx.obj_infos);\n }\n \n@@ -2578,7 +2578,7 @@ fn check_const(ccx: &@crate_ctxt, sp: &span, e: &@ast::expr,\n }\n \n fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n-            old_fcx: &option::t[@fn_ctxt]) {\n+            old_fcx: &option::t<@fn_ctxt>) {\n     let decl = f.decl;\n     let body = f.body;\n     let gather_result = gather_locals(ccx, f, id, old_fcx);"}, {"sha": "05a9f86d04e9e96109e32627f61b59e0a1f1a83c", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -6,7 +6,7 @@ import codemap::span;\n import codemap::filename;\n \n type spanned[T] = {node: T, span: span};\n-fn respan[T](sp: &span, t: &T) -> spanned[T] { ret {node: t, span: sp}; }\n+fn respan[T](sp: &span, t: &T) -> spanned<T> { ret {node: t, span: sp}; }\n \n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n@@ -18,14 +18,14 @@ fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n type ident = str;\n // Functions may or may not have names.\n-type fn_ident = option::t[ident];\n+type fn_ident = option::t<ident>;\n \n // FIXME: with typestate constraint, could say\n // idents and types are the same length, and are\n // non-empty\n type path_ = {global: bool, idents: [ident], types: [@ty]};\n \n-type path = spanned[path_];\n+type path = spanned<path_>;\n \n fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n \n@@ -90,7 +90,7 @@ fn def_id_of_def(d: def) -> def_id {\n // used to drive conditional compilation\n type crate_cfg = [@meta_item];\n \n-type crate = spanned[crate_];\n+type crate = spanned<crate_>;\n \n type crate_ =\n     {directives: [@crate_directive],\n@@ -99,29 +99,29 @@ type crate_ =\n      config: crate_cfg};\n \n tag crate_directive_ {\n-    cdir_src_mod(ident, option::t[filename], [attribute]);\n+    cdir_src_mod(ident, option::t<filename>, [attribute]);\n     cdir_dir_mod(ident,\n-                 option::t[filename],\n+                 option::t<filename>,\n                  [@crate_directive],\n                  [attribute]);\n     cdir_view_item(@view_item);\n     cdir_syntax(path);\n     cdir_auth(path, _auth);\n }\n \n-type crate_directive = spanned[crate_directive_];\n+type crate_directive = spanned<crate_directive_>;\n \n-type meta_item = spanned[meta_item_];\n+type meta_item = spanned<meta_item_>;\n \n tag meta_item_ {\n     meta_word(ident);\n     meta_list(ident, [@meta_item]);\n     meta_name_value(ident, lit);\n }\n \n-type blk = spanned[blk_];\n+type blk = spanned<blk_>;\n \n-type blk_ = {stmts: [@stmt], expr: option::t[@expr], id: node_id};\n+type blk_ = {stmts: [@stmt], expr: option::t<@expr>, id: node_id};\n \n type pat = {id: node_id, node: pat_, span: span};\n \n@@ -137,7 +137,7 @@ tag pat_ {\n     pat_box(@pat);\n }\n \n-type pat_id_map = std::map::hashmap[str, ast::node_id];\n+type pat_id_map = std::map::hashmap<str, ast::node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n@@ -252,7 +252,7 @@ fn unop_to_str(op: unop) -> str {\n \n tag mode { val; alias(bool); move; }\n \n-type stmt = spanned[stmt_];\n+type stmt = spanned<stmt_>;\n \n tag stmt_ {\n     stmt_decl(@decl, node_id);\n@@ -267,20 +267,20 @@ type initializer = {op: init_op, expr: @expr};\n \n type local_ = {ty: @ty,\n                pat: @pat,\n-               init: option::t[initializer],\n+               init: option::t<initializer>,\n                id: node_id};\n \n-type local = spanned[local_];\n+type local = spanned<local_>;\n \n-type decl = spanned[decl_];\n+type decl = spanned<decl_>;\n \n tag decl_ { decl_local([@local]); decl_item(@item); }\n \n type arm = {pats: [@pat], body: blk};\n \n type field_ = {mut: mutability, ident: ident, expr: @expr};\n \n-type field = spanned[field_];\n+type field = spanned<field_>;\n \n tag spawn_dom { dom_implicit; dom_thread; }\n \n@@ -293,16 +293,16 @@ type expr = {id: node_id, node: expr_, span: span};\n \n tag expr_ {\n     expr_vec([@expr], mutability, seq_kind);\n-    expr_rec([field], option::t[@expr]);\n+    expr_rec([field], option::t<@expr>);\n     expr_call(@expr, [@expr]);\n     expr_tup([@expr]);\n     expr_self_method(ident);\n-    expr_bind(@expr, [option::t[@expr]]);\n+    expr_bind(@expr, [option::t<@expr>]);\n     expr_binary(binop, @expr, @expr);\n     expr_unary(unop, @expr);\n     expr_lit(@lit);\n     expr_cast(@expr, @ty);\n-    expr_if(@expr, blk, option::t[@expr]);\n+    expr_if(@expr, blk, option::t<@expr>);\n     expr_ternary(@expr, @expr, @expr);\n     expr_while(@expr, blk);\n     expr_for(@local, @expr, blk);\n@@ -323,11 +323,11 @@ tag expr_ {\n     expr_field(@expr, ident);\n     expr_index(@expr, @expr);\n     expr_path(path);\n-    expr_fail(option::t[@expr]);\n+    expr_fail(option::t<@expr>);\n     expr_break;\n     expr_cont;\n-    expr_ret(option::t[@expr]);\n-    expr_put(option::t[@expr]);\n+    expr_ret(option::t<@expr>);\n+    expr_put(option::t<@expr>);\n     expr_be(@expr);\n     expr_log(int, @expr);\n     /* just an assert, no significance to typestate */\n@@ -336,22 +336,22 @@ tag expr_ {\n     expr_check(check_mode, @expr);\n     /* FIXME Would be nice if expr_check desugared\n        to expr_if_check. */\n-    expr_if_check(@expr, blk, option::t[@expr]);\n+    expr_if_check(@expr, blk, option::t<@expr>);\n     expr_anon_obj(anon_obj);\n     expr_mac(mac);\n     expr_uniq(@expr);\n }\n \n-type mac = spanned[mac_];\n+type mac = spanned<mac_>;\n \n tag mac_ {\n-    mac_invoc(path, @expr, option::t[str]);\n+    mac_invoc(path, @expr, option::t<str>);\n     mac_embed_type(@ty);\n     mac_embed_block(blk);\n     mac_ellipsis;\n }\n \n-type lit = spanned[lit_];\n+type lit = spanned<lit_>;\n \n tag lit_ {\n     lit_str(str, seq_kind);\n@@ -386,11 +386,11 @@ type ty_method_ =\n      cf: controlflow,\n      constrs: [@constr]};\n \n-type ty_field = spanned[ty_field_];\n+type ty_field = spanned<ty_field_>;\n \n-type ty_arg = spanned[ty_arg_];\n+type ty_arg = spanned<ty_arg_>;\n \n-type ty_method = spanned[ty_method_];\n+type ty_method = spanned<ty_method_>;\n \n tag ty_mach {\n     ty_i8;\n@@ -420,7 +420,7 @@ fn ty_mach_to_str(tm: ty_mach) -> str {\n     }\n }\n \n-type ty = spanned[ty_];\n+type ty = spanned<ty_>;\n \n tag ty_ {\n     ty_nil;\n@@ -470,26 +470,26 @@ declarations, and ident for uses.\n */\n tag constr_arg_general_[T] { carg_base; carg_ident(T); carg_lit(@lit); }\n \n-type fn_constr_arg = constr_arg_general_[uint];\n-type sp_constr_arg[T] = spanned[constr_arg_general_[T]];\n-type ty_constr_arg = sp_constr_arg[path];\n-type constr_arg = spanned[fn_constr_arg];\n+type fn_constr_arg = constr_arg_general_<uint>;\n+type sp_constr_arg[T] = spanned<constr_arg_general_<T>>;\n+type ty_constr_arg = sp_constr_arg<path>;\n+type constr_arg = spanned<fn_constr_arg>;\n \n // Constrained types' args are parameterized by paths, since\n // we refer to paths directly and not by indices.\n // The implicit root of such path, in the constraint-list for a\n // constrained type, is * (referring to the base record)\n \n type constr_general_[ARG, ID] =\n-    {path: path, args: [@spanned[constr_arg_general_[ARG]]], id: ID};\n+    {path: path, args: [@spanned<constr_arg_general_<ARG>>], id: ID};\n \n // In the front end, constraints have a node ID attached.\n // Typeck turns this to a def_id, using the output of resolve.\n-type constr_general[ARG] = spanned[constr_general_[ARG, node_id]];\n-type constr_ = constr_general_[uint, node_id];\n-type constr = spanned[constr_general_[uint, node_id]];\n-type ty_constr_ = ast::constr_general_[ast::path, ast::node_id];\n-type ty_constr = spanned[ty_constr_];\n+type constr_general[ARG] = spanned<constr_general_<ARG, node_id>>;\n+type constr_ = constr_general_<uint, node_id>;\n+type constr = spanned<constr_general_<uint, node_id>>;\n+type ty_constr_ = ast::constr_general_<ast::path, ast::node_id>;\n+type ty_constr = spanned<ty_constr_>;\n \n /* The parser generates ast::constrs; resolve generates\n  a mapping from each function to a list of ty::constr_defs,\n@@ -521,7 +521,7 @@ type _fn = {decl: fn_decl, proto: proto, body: blk};\n \n type method_ = {ident: ident, meth: _fn, id: node_id};\n \n-type method = spanned[method_];\n+type method = spanned<method_>;\n \n type obj_field = {mut: mutability, ty: @ty, ident: ident, id: node_id};\n type anon_obj_field =\n@@ -531,10 +531,10 @@ type _obj = {fields: [obj_field], methods: [@method]};\n \n type anon_obj =\n     // New fields and methods, if they exist.\n-    {fields: option::t[[anon_obj_field]],\n+    {fields: option::t<[anon_obj_field]>,\n      methods: [@method],\n      // inner_obj: the original object being extended, if it exists.\n-     inner_obj: option::t[@expr]};\n+     inner_obj: option::t<@expr>};\n \n type _mod = {view_items: [@view_item], items: [@item]};\n \n@@ -556,9 +556,9 @@ type variant_arg = {ty: @ty, id: node_id};\n \n type variant_ = {name: str, args: [variant_arg], id: node_id};\n \n-type variant = spanned[variant_];\n+type variant = spanned<variant_>;\n \n-type view_item = spanned[view_item_];\n+type view_item = spanned<view_item_>;\n \n tag view_item_ {\n     view_item_use(ident, [@meta_item], node_id);\n@@ -571,7 +571,7 @@ type obj_def_ids = {ty: node_id, ctor: node_id};\n \n \n // Meta-data associated with an item\n-type attribute = spanned[attribute_];\n+type attribute = spanned<attribute_>;\n \n \n // Distinguishes between attributes that decorate items and attributes that\n@@ -607,7 +607,7 @@ type native_item =\n \n tag native_item_ {\n     native_item_ty;\n-    native_item_fn(option::t[str], fn_decl, [ty_param]);\n+    native_item_fn(option::t<str>, fn_decl, [ty_param]);\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {"}, {"sha": "a2542e5fddf537f83320d947903aa75bdc67b19b", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -95,10 +95,10 @@ fn span_to_str(sp: &span, cm: &codemap) -> str {\n     ret res;\n }\n \n-fn emit_diagnostic(sp: &option::t[span], msg: &str, kind: &str, color: u8,\n+fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n                    cm: &codemap) {\n     let ss = \"<input>:0:0:0:0\";\n-    let maybe_lines: option::t[@file_lines] = none;\n+    let maybe_lines: option::t<@file_lines> = none;\n     alt sp {\n       some(ssp) {\n         ss = span_to_str(ssp, cm);\n@@ -119,8 +119,8 @@ fn emit_diagnostic(sp: &option::t[span], msg: &str, kind: &str, color: u8,\n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n \n-fn maybe_highlight_lines(sp: &option::t[span], cm: &codemap,\n-                         maybe_lines: option::t[@file_lines]) {\n+fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n+                         maybe_lines: option::t<@file_lines>) {\n \n     alt maybe_lines {\n       some(lines) {\n@@ -187,13 +187,13 @@ fn maybe_highlight_lines(sp: &option::t[span], cm: &codemap,\n     }\n }\n \n-fn emit_warning(sp: &option::t[span], msg: &str, cm: &codemap) {\n+fn emit_warning(sp: &option::t<span>, msg: &str, cm: &codemap) {\n     emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n }\n-fn emit_error(sp: &option::t[span], msg: &str, cm: &codemap) {\n+fn emit_error(sp: &option::t<span>, msg: &str, cm: &codemap) {\n     emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n }\n-fn emit_note(sp: &option::t[span], msg: &str, cm: &codemap) {\n+fn emit_note(sp: &option::t<span>, msg: &str, cm: &codemap) {\n     emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n }\n "}, {"sha": "5a9b3ac1d190e1652312e226622ee2f8584649b3", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -7,10 +7,10 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander =\n-    fn(&ext_ctxt, span, @ast::expr, option::t[str]) -> @ast::expr ;\n+    fn(&ext_ctxt, span, @ast::expr, option::t<str>) -> @ast::expr ;\n type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n-    fn(&ext_ctxt, span, @ast::expr, option::t[str]) -> macro_def ;\n+    fn(&ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def ;\n \n tag syntax_extension {\n     normal(syntax_expander);\n@@ -19,7 +19,7 @@ tag syntax_extension {\n \n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n-fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n+fn syntax_expander_table() -> hashmap<str, syntax_extension> {\n     let syntax_expanders = new_str_hash[syntax_extension]();\n     syntax_expanders.insert(\"fmt\", normal(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\"env\", normal(ext::env::expand_syntax_ext));"}, {"sha": "43ec2488816da6a2c9c6b4aadf1d8470f999748d", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -3,7 +3,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t[str]) -> @ast::expr {\n+                     body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#concat_idents requires a vector argument .\") }"}, {"sha": "498792b80b0d2de34410c9d811fc78f495f7c28d", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -11,7 +11,7 @@ import base::*;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t[str]) -> @ast::expr {\n+                     body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#env requires arguments of the form `[...]`.\") }\n@@ -20,7 +20,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n         cx.span_fatal(sp, \"malformed #env call\");\n     }\n     // FIXME: if this was more thorough it would manufacture an\n-    // option::t[str] rather than just an maybe-empty string.\n+    // option::t<str> rather than just an maybe-empty string.\n \n     let var = expr_to_str(cx, args.(0), \"#env requires a string\");\n     alt generic_os::getenv(var) {"}, {"sha": "044bee4ba2be8b6ebd429b3b9ab72d07da9c1391", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -14,7 +14,7 @@ import syntax::fold::*;\n import syntax::ext::base::*;\n \n \n-fn expand_expr(exts: &hashmap[str, syntax_extension], cx: &ext_ctxt,\n+fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n                e: &expr_, fld: ast_fold,\n                orig: &fn(&expr_, ast_fold) -> expr_ ) -> expr_ {\n     ret alt e {"}, {"sha": "fd0ba7d4d012043674093d34bc93e5c5d1305d98", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -16,7 +16,7 @@ import codemap::span;\n export expand_syntax_ext;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n-                     body: option::t[str]) -> @ast::expr {\n+                     body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#fmt requires arguments of the form `[...]`.\") }"}, {"sha": "841f8221e3ebcd470db169af2903af63cb2d5ed3", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -4,7 +4,7 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t[str]) -> @ast::expr {\n+                     body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ { cx.span_fatal(sp, \"#ident_to_str requires a vector argument .\") }"}, {"sha": "34c240a985cd6aba7f114ee28a58850ecb392d0b", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -3,11 +3,11 @@ import base::*;\n import syntax::ast;\n \n fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     body: option::t[str]) -> @ast::expr {\n+                     body: option::t<str>) -> @ast::expr {\n \n     cx.print_backtrace();\n     std::io::stdout().write_line(print::pprust::expr_to_str(arg));\n \n     //trivial expression\n     ret @{id: cx.next_id(), node: ast::expr_rec(~[], option::none), span: sp};\n-}\n\\ No newline at end of file\n+}"}, {"sha": "aae2404f57bf0350b4e7999befe2a23afc2c585d", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -32,7 +32,7 @@ import ast::mac_invoc;\n \n export add_new_extension;\n \n-fn path_to_ident(pth: &path) -> option::t[ident] {\n+fn path_to_ident(pth: &path) -> option::t<ident> {\n     if vec::len(pth.node.idents) == 1u && vec::len(pth.node.types) == 0u {\n         ret some(pth.node.idents.(0u));\n     }\n@@ -43,13 +43,13 @@ fn path_to_ident(pth: &path) -> option::t[ident] {\n type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n-tag arb_depth[T] { leaf(T); seq(@[arb_depth[T]], span); }\n+tag arb_depth[T] { leaf(T); seq(@[arb_depth<T>], span); }\n \n \n tag matchable {\n     match_expr(@expr);\n     match_path(path);\n-    match_ident(ast::spanned[ident]);\n+    match_ident(ast::spanned<ident>);\n     match_ty(@ty);\n     match_block(ast::blk);\n     match_exact; /* don't bind anything, just verify the AST traversal */\n@@ -88,11 +88,11 @@ fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n // If we want better match failure error messages (like in Fortifying Syntax),\n // we'll want to return something indicating amount of progress and location\n // of failure instead of `none`.\n-type match_result = option::t[arb_depth[matchable]];\n+type match_result = option::t<arb_depth<matchable>>;\n type selector = fn(&matchable) -> match_result ;\n \n fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n-    -> {pre: [@expr], rep: option::t[@expr], post: [@expr]} {\n+    -> {pre: [@expr], rep: option::t<@expr>, post: [@expr]} {\n     let idx: uint = 0u;\n     let res = none;\n     for elt: @expr in elts {\n@@ -121,16 +121,16 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr])\n     }\n }\n \n-fn option_flatten_map[T, U](f: &fn(&T) -> option::t[U] , v: &[T]) ->\n-   option::t[[U]] {\n+fn option_flatten_map[T, U](f: &fn(&T) -> option::t<U>, v: &[T]) ->\n+   option::t<[U]> {\n     let res = ~[];\n     for elem: T in v {\n         alt f(elem) { none. { ret none; } some(fv) { res += ~[fv]; } }\n     }\n     ret some(res);\n }\n \n-fn a_d_map(ad: &arb_depth[matchable], f: &selector) -> match_result {\n+fn a_d_map(ad: &arb_depth<matchable>, f: &selector) -> match_result {\n     alt ad {\n       leaf(x) { ret f(x); }\n       seq(ads, span) {\n@@ -155,9 +155,9 @@ fn compose_sels(s1: selector, s2: selector) -> selector {\n \n \n type binders =\n-    {real_binders: hashmap[ident, selector],\n+    {real_binders: hashmap<ident, selector>,\n      mutable literal_ast_matchers: [selector]};\n-type bindings = hashmap[ident, arb_depth[matchable]];\n+type bindings = hashmap<ident, arb_depth<matchable>>;\n \n fn acumm_bindings(cx: &ext_ctxt, b_dest: &bindings, b_src: &bindings) { }\n \n@@ -182,8 +182,8 @@ fn pattern_to_selectors(cx: &ext_ctxt, e: @expr) -> binders {\n bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n-fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t[bindings] {\n-    let res = new_str_hash[arb_depth[matchable]]();\n+fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n+    let res = new_str_hash[arb_depth<matchable>]();\n     //need to do this first, to check vec lengths.\n     for sel: selector in b.literal_ast_matchers {\n         alt sel(match_expr(e)) { none. { ret none; } _ { } }\n@@ -230,9 +230,9 @@ fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n \n \n /* helper: descend into a matcher */\n-fn follow(m: &arb_depth[matchable], idx_path: @mutable [uint]) ->\n-   arb_depth[matchable] {\n-    let res: arb_depth[matchable] = m;\n+fn follow(m: &arb_depth<matchable>, idx_path: @mutable [uint]) ->\n+   arb_depth<matchable> {\n+    let res: arb_depth<matchable> = m;\n     for idx: uint in *idx_path {\n         alt res {\n           leaf(_) { ret res;/* end of the line */ }\n@@ -242,8 +242,8 @@ fn follow(m: &arb_depth[matchable], idx_path: @mutable [uint]) ->\n     ret res;\n }\n \n-fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t[arb_depth[matchable]],\n-                    idx_path: @mutable [uint]) -> option::t[matchable] {\n+fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n+                    idx_path: @mutable [uint]) -> option::t<matchable> {\n     alt mmaybe {\n       none. { ret none }\n       some(m) {\n@@ -262,9 +262,9 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t[arb_depth[matchable]],\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n iter free_vars(b: &bindings, e: @expr) -> ident {\n-    let idents: hashmap[ident, ()] = new_str_hash[()]();\n+    let idents: hashmap<ident, ()> = new_str_hash[()]();\n     fn mark_ident(i: &ident, fld: ast_fold, b: &bindings,\n-                  idents: &hashmap[ident, ()]) -> ident {\n+                  idents: &hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }\n         ret i;\n     }\n@@ -290,7 +290,7 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n         alt repeat_me_maybe {\n           none. {}\n           some(repeat_me) {\n-            let repeat: option::t[{rep_count: uint, name: ident}] = none;\n+            let repeat: option::t<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n             the leaves, which are just duplicated */\n             for each fv: ident in free_vars(b, repeat_me) {\n@@ -533,7 +533,7 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n     }\n }\n \n-fn block_to_ident(blk: &blk_) -> option::t[ident] {\n+fn block_to_ident(blk: &blk_) -> option::t<ident> {\n     if vec::len(blk.stmts) != 0u { ret none; }\n     ret alt blk.expr {\n           some(expr) {\n@@ -676,15 +676,15 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], repeat_after: bool,\n }\n \n fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                     body: option::t[str]) -> base::macro_def {\n+                     body: option::t<str>) -> base::macro_def {\n     let args: [@ast::expr] = alt arg.node {\n       ast::expr_vec(elts, _, _) { elts }\n       _ {\n         cx.span_fatal(sp, \"#macro requires arguments of the form `[...]`.\")\n       }\n     };\n \n-    let macro_name: option::t[str] = none;\n+    let macro_name: option::t<str> = none;\n     let clauses: [@clause] = ~[];\n     for arg: @expr in args {\n         alt arg.node {\n@@ -753,7 +753,7 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n          ext: normal(ext)};\n \n     fn generic_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                         body: option::t[str], clauses: [@clause]) -> @expr {\n+                         body: option::t<str>, clauses: [@clause]) -> @expr {\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) {"}, {"sha": "ca318f191d835feb0b7811395f3b2543ced70041", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -497,7 +497,7 @@ fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n          id: l.id};\n }\n \n-/* temporarily eta-expand because of a compiler bug with using `fn[T]` as a\n+/* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n fn noop_map_exprs(f: fn(&@expr) -> @expr , es: [@expr]) -> [@expr] {\n     ret vec::map(f, es);"}, {"sha": "2d92da322733ffadc5ebda776590cc16819276ea", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -20,7 +20,7 @@ type reader =\n         fn init() ;\n         fn bump() ;\n         fn get_str_from(uint) -> str ;\n-        fn get_interner() -> @interner::interner[str] ;\n+        fn get_interner() -> @interner::interner<str> ;\n         fn get_chpos() -> uint ;\n         fn get_byte_pos() -> uint ;\n         fn get_col() -> uint ;\n@@ -29,7 +29,7 @@ type reader =\n     };\n \n fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n-              itr: @interner::interner[str]) -> reader {\n+              itr: @interner::interner<str>) -> reader {\n     obj reader(cm: codemap::codemap,\n                src: str,\n                len: uint,\n@@ -39,7 +39,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n                mutable chpos: uint,\n                mutable strs: [str],\n                fm: codemap::filemap,\n-               itr: @interner::interner[str]) {\n+               itr: @interner::interner<str>) {\n         fn is_eof() -> bool { ret ch == -1 as char; }\n         fn get_str_from(start: uint) -> str {\n             // I'm pretty skeptical about this subtraction. What if there's a\n@@ -74,7 +74,7 @@ fn new_reader(cm: &codemap::codemap, src: str, filemap: codemap::filemap,\n                 ch = next.ch;\n             } else { ch = -1 as char; }\n         }\n-        fn get_interner() -> @interner::interner[str] { ret itr; }\n+        fn get_interner() -> @interner::interner<str> { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n         fn err(m: str) {\n@@ -173,7 +173,7 @@ fn digits_to_string(s: str) -> int {\n     ret accum_int;\n }\n \n-fn scan_exponent(rdr: &reader) -> option::t[str] {\n+fn scan_exponent(rdr: &reader) -> option::t<str> {\n     let c = rdr.curr();\n     let rslt = \"\";\n     if c == 'e' || c == 'E' {"}, {"sha": "3bdeef0c0117236691be596e57916ccd20cfc9e8", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -52,7 +52,7 @@ type parser =\n         fn get_str(token::str_num) -> str ;\n         fn get_reader() -> lexer::reader ;\n         fn get_filemap() -> codemap::filemap ;\n-        fn get_bad_expr_words() -> hashmap[str, ()] ;\n+        fn get_bad_expr_words() -> hashmap<str, ()> ;\n         fn get_chpos() -> uint ;\n         fn get_byte_pos() -> uint ;\n         fn get_id() -> node_id ;\n@@ -84,7 +84,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n                      mutable restr: restriction,\n                      rdr: lexer::reader,\n                      precs: @[op_spec],\n-                     bad_words: hashmap[str, ()]) {\n+                     bad_words: hashmap<str, ()>) {\n         fn peek() -> token::token { ret tok; }\n         fn bump() {\n             last_tok_span = tok_span;\n@@ -132,7 +132,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         }\n         fn get_reader() -> lexer::reader { ret rdr; }\n         fn get_filemap() -> codemap::filemap { ret rdr.get_filemap(); }\n-        fn get_bad_expr_words() -> hashmap[str, ()] { ret bad_words; }\n+        fn get_bad_expr_words() -> hashmap<str, ()> { ret bad_words; }\n         fn get_chpos() -> uint { ret rdr.get_chpos(); }\n         fn get_byte_pos() -> uint { ret rdr.get_byte_pos(); }\n         fn get_id() -> node_id { ret next_node_id(sess); }\n@@ -148,7 +148,7 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n // These are the words that shouldn't be allowed as value identifiers,\n // because, if used at the start of a line, they will cause the line to be\n // interpreted as a specific kind of statement, which would be confusing.\n-fn bad_expr_word_table() -> hashmap[str, ()] {\n+fn bad_expr_word_table() -> hashmap<str, ()> {\n     let words = new_str_hash();\n     words.insert(\"mod\", ());\n     words.insert(\"if\", ());\n@@ -224,7 +224,7 @@ fn expect_gt(p: &parser) {\n     }\n }\n \n-fn spanned[T](lo: uint, hi: uint, node: &T) -> spanned[T] {\n+fn spanned[T](lo: uint, hi: uint, node: &T) -> spanned<T> {\n     ret {node: node, span: ast::mk_sp(lo, hi)};\n }\n \n@@ -429,9 +429,9 @@ fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n }\n \n \n-fn parse_constrs[T](pser: fn(&parser) -> @ast::constr_general[T] , p: &parser)\n-   -> [@ast::constr_general[T]] {\n-    let constrs: [@ast::constr_general[T]] = ~[];\n+fn parse_constrs[T](pser: fn(&parser) -> @ast::constr_general<T>, p: &parser)\n+   -> [@ast::constr_general<T>] {\n+    let constrs: [@ast::constr_general<T>] = ~[];\n     while true {\n         let constr = pser(p);\n         constrs += ~[constr];\n@@ -643,7 +643,7 @@ fn parse_fn_block_arg(p: &parser) -> ast::arg {\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt[T](sep: option::t[token::token],\n+fn parse_seq_to_before_gt[T](sep: option::t<token::token>,\n                              f: fn(&parser) -> T, p: &parser) -> [T] {\n     let first = true;\n     let v = ~[];\n@@ -660,16 +660,16 @@ fn parse_seq_to_before_gt[T](sep: option::t[token::token],\n     ret v;\n }\n \n-fn parse_seq_to_gt[T](sep: option::t[token::token], f: fn(&parser) -> T,\n+fn parse_seq_to_gt[T](sep: option::t<token::token>, f: fn(&parser) -> T,\n                       p: &parser) -> [T] {\n     let v = parse_seq_to_before_gt(sep, f, p);\n     expect_gt(p);\n \n     ret v;\n }\n \n-fn parse_seq_lt_gt[T](sep: option::t[token::token], f: fn(&parser) -> T,\n-                      p: &parser) -> spanned[[T]] {\n+fn parse_seq_lt_gt[T](sep: option::t<token::token>, f: fn(&parser) -> T,\n+                      p: &parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, token::LT);\n     let result = parse_seq_to_before_gt[T](sep, f, p);\n@@ -678,14 +678,14 @@ fn parse_seq_lt_gt[T](sep: option::t[token::token], f: fn(&parser) -> T,\n     ret spanned(lo, hi, result);\n }\n \n-fn parse_seq_to_end[T](ket: token::token, sep: option::t[token::token],\n+fn parse_seq_to_end[T](ket: token::token, sep: option::t<token::token>,\n                        f: fn(&parser) -> T , p: &parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n-fn parse_seq_to_before_end[T](ket: token::token, sep: option::t[token::token],\n+fn parse_seq_to_before_end[T](ket: token::token, sep: option::t<token::token>,\n                               f: fn(&parser) -> T , p: &parser) -> [T] {\n     let first: bool = true;\n     let v: [T] = ~[];\n@@ -701,8 +701,8 @@ fn parse_seq_to_before_end[T](ket: token::token, sep: option::t[token::token],\n \n \n fn parse_seq[T](bra: token::token, ket: token::token,\n-                sep: option::t[token::token], f: fn(&parser) -> T ,\n-                p: &parser) -> spanned[[T]] {\n+                sep: option::t<token::token>, f: fn(&parser) -> T ,\n+                p: &parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, bra);\n     let result = parse_seq_to_before_end[T](ket, sep, f, p);\n@@ -955,15 +955,15 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         // Anonymous object\n \n         // Only make people type () if they're actually adding new fields\n-        let fields: option::t[[ast::anon_obj_field]] = none;\n+        let fields: option::t<[ast::anon_obj_field]> = none;\n         if p.peek() == token::LPAREN {\n             p.bump();\n             fields =\n                 some(parse_seq_to_end(token::RPAREN, some(token::COMMA),\n                                       parse_anon_obj_field, p));\n         }\n         let meths: [@ast::method] = ~[];\n-        let inner_obj: option::t[@ast::expr] = none;\n+        let inner_obj: option::t<@ast::expr> = none;\n         expect(p, token::LBRACE);\n         while p.peek() != token::RBRACE {\n             if eat_word(p, \"with\") {\n@@ -982,7 +982,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ex = ast::expr_anon_obj(ob);\n     } else if (eat_word(p, \"bind\")) {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-        fn parse_expr_opt(p: &parser) -> option::t[@ast::expr] {\n+        fn parse_expr_opt(p: &parser) -> option::t<@ast::expr> {\n             alt p.peek() {\n               token::UNDERSCORE. { p.bump(); ret none; }\n               _ { ret some(parse_expr(p)); }\n@@ -1329,13 +1329,13 @@ fn parse_assign_expr(p: &parser) -> @ast::expr {\n fn parse_if_expr_1(p: &parser) ->\n    {cond: @ast::expr,\n     then: ast::blk,\n-    els: option::t[@ast::expr],\n+    els: option::t<@ast::expr>,\n     lo: uint,\n     hi: uint} {\n     let lo = p.get_last_lo_pos();\n     let cond = parse_expr(p);\n     let thn = parse_block(p);\n-    let els: option::t[@ast::expr] = none;\n+    let els: option::t<@ast::expr> = none;\n     let hi = thn.span.hi;\n     if eat_word(p, \"else\") {\n         let elexpr = parse_else_expr(p);\n@@ -1437,7 +1437,7 @@ fn parse_expr_res(p: &parser, r: restriction) -> @ast::expr {\n     ret e;\n }\n \n-fn parse_initializer(p: &parser) -> option::t[ast::initializer] {\n+fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n     alt p.peek() {\n       token::EQ. {\n         p.bump();\n@@ -1653,7 +1653,7 @@ fn parse_source_stmt(p: &parser) -> @ast::stmt {\n     }\n }\n \n-fn stmt_to_expr(stmt: @ast::stmt) -> option::t[@ast::expr] {\n+fn stmt_to_expr(stmt: @ast::stmt) -> option::t<@ast::expr> {\n     ret alt stmt.node { ast::stmt_expr(e, _) { some(e) } _ { none } };\n }\n \n@@ -1724,7 +1724,7 @@ fn parse_block(p: &parser) -> ast::blk {\n // some blocks start with \"#{\"...\n fn parse_block_tail(p: &parser, lo: uint) -> ast::blk {\n     let stmts: [@ast::stmt] = ~[];\n-    let expr: option::t[@ast::expr] = none;\n+    let expr: option::t<@ast::expr> = none;\n     while p.peek() != token::RBRACE {\n         alt p.peek() {\n           token::SEMI. {\n@@ -1796,7 +1796,7 @@ fn parse_ty_params(p: &parser) -> [ast::ty_param] {\n \n fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness)\n         -> ast::fn_decl {\n-    let inputs: ast::spanned[[ast::arg]] =\n+    let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n                   p);\n     let rslt: ty_or_bang;\n@@ -1835,7 +1835,7 @@ fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness)\n }\n \n fn parse_fn_block_decl(p: &parser) -> ast::fn_decl {\n-    let inputs: ast::spanned[[ast::arg]] =\n+    let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::BINOP(token::OR), token::BINOP(token::OR),\n                   some(token::COMMA), parse_fn_block_arg, p);\n     ret {inputs: inputs.node,\n@@ -1910,7 +1910,7 @@ fn parse_item_obj(p: &parser, attrs: &[ast::attribute]) ->\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n-    let fields: ast::spanned[[ast::obj_field]] =\n+    let fields: ast::spanned<[ast::obj_field]> =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_obj_field, p);\n     let meths: [@ast::method] = ~[];\n@@ -2171,7 +2171,7 @@ fn parse_auth(p: &parser) -> ast::_auth {\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t[@ast::item] {\n+fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t<@ast::item> {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n     } else if (eat_word(p, \"inline\")) {\n@@ -2207,7 +2207,7 @@ fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t[@ast::item] {\n \n // A type to distingush between the parsing of item attributes or syntax\n // extensions, which both begin with token.POUND\n-type attr_or_ext = option::t[either::t[[ast::attribute], @ast::expr]];\n+type attr_or_ext = option::t<either::t<[ast::attribute], @ast::expr>>;\n \n fn parse_outer_attrs_or_ext(p: &parser) -> attr_or_ext {\n     if p.peek() == token::POUND {\n@@ -2311,7 +2311,7 @@ fn parse_use(p: &parser) -> ast::view_item_ {\n }\n \n fn parse_rest_import_name(p: &parser, first: ast::ident,\n-                          def_ident: option::t[ast::ident]) ->\n+                          def_ident: option::t<ast::ident>) ->\n    ast::view_item_ {\n     let identifiers: [ast::ident] = ~[first];\n     let glob: bool = false;"}, {"sha": "330b859aa85dec4488bbf9cfdc7500b555faf27a", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -40,9 +40,9 @@ fn no_ann() -> pp_ann {\n \n type ps =\n     @{s: pp::printer,\n-      cm: option::t[codemap],\n-      comments: option::t[[lexer::cmnt]],\n-      literals: option::t[[lexer::lit]],\n+      cm: option::t<codemap>,\n+      comments: option::t<[lexer::cmnt]>,\n+      literals: option::t<[lexer::lit]>,\n       mutable cur_cmnt: uint,\n       mutable cur_lit: uint,\n       mutable boxes: [pp::breaks],\n@@ -619,7 +619,7 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n     // followed by a unary op statement. In those cases we have to add an\n     // extra semi to make sure the unop is not parsed as a binop with the\n     // if/alt/block expression.\n-    fn maybe_protect_unop(s: &ps, last: &option::t[@ast::stmt],\n+    fn maybe_protect_unop(s: &ps, last: &option::t<@ast::stmt>,\n                           next: &expr_or_stmt) {\n         let last_expr_is_block = alt last {\n           option::some(@{node: ast::stmt_expr(e, _), _}) {\n@@ -651,13 +651,13 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n }\n \n fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n-            elseopt: &option::t[@ast::expr], chk: bool) {\n+            elseopt: &option::t<@ast::expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n     print_expr(s, test);\n     space(s.s);\n     print_block(s, blk);\n-    fn do_else(s: &ps, els: option::t[@ast::expr]) {\n+    fn do_else(s: &ps, els: option::t<@ast::expr>) {\n         alt els {\n           some(_else) {\n             alt _else.node {\n@@ -773,7 +773,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         print_ident(s, ident);\n       }\n       ast::expr_bind(func, args) {\n-        fn print_opt(s: &ps, expr: &option::t[@ast::expr]) {\n+        fn print_opt(s: &ps, expr: &option::t<@ast::expr>) {\n             alt expr {\n               some(expr) { print_expr(s, expr); }\n               _ { word(s.s, \"_\"); }\n@@ -1325,7 +1325,7 @@ fn print_mt(s: &ps, mt: &ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t[str],\n+fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<str>,\n                inputs: &[ast::ty_arg], output: &@ast::ty,\n                cf: &ast::controlflow, constrs: &[@ast::constr]) {\n     ibox(s, indent_unit);\n@@ -1355,7 +1355,7 @@ fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t[str],\n }\n \n fn maybe_print_trailing_comment(s: &ps, span: codemap::span,\n-                                next_pos: option::t[uint]) {\n+                                next_pos: option::t<uint>) {\n     let cm;\n     alt s.cm { some(ccm) { cm = ccm; } _ { ret; } }\n     alt next_comment(s) {\n@@ -1431,7 +1431,7 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n \n fn lit_to_str(l: &@ast::lit) -> str { be to_str(l, print_literal); }\n \n-fn next_lit(s: &ps) -> option::t[lexer::lit] {\n+fn next_lit(s: &ps) -> option::t<lexer::lit> {\n     alt s.literals {\n       some(lits) {\n         if s.cur_lit < vec::len(lits) {\n@@ -1523,7 +1523,7 @@ fn to_str[T](t: &T, f: fn(&ps, &T) ) -> str {\n     ret writer.get_str();\n }\n \n-fn next_comment(s: &ps) -> option::t[lexer::cmnt] {\n+fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n     alt s.comments {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {\n@@ -1537,18 +1537,18 @@ fn next_comment(s: &ps) -> option::t[lexer::cmnt] {\n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n fn constr_args_to_str[T](f: &fn(&T) -> str ,\n-                         args: &[@ast::sp_constr_arg[T]]) -> str {\n+                         args: &[@ast::sp_constr_arg<T>]) -> str {\n     let comma = false;\n     let s = \"(\";\n-    for a: @ast::sp_constr_arg[T] in args {\n+    for a: @ast::sp_constr_arg<T> in args {\n         if comma { s += \", \"; } else { comma = true; }\n         s += constr_arg_to_str[T](f, a.node);\n     }\n     s += \")\";\n     ret s;\n }\n \n-fn constr_arg_to_str[T](f: &fn(&T) -> str , c: &ast::constr_arg_general_[T])\n+fn constr_arg_to_str[T](f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>)\n    -> str {\n     alt c {\n       ast::carg_base. { ret \"*\"; }"}, {"sha": "ad92513ede0866d855624f3e07bf0558f6ea59ff", "filename": "src/comp/syntax/untyped_ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Funtyped_ast.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -9,9 +9,9 @@ import codemap::span;\n import codemap::filename;\n \n tag ast_node {\n-    branch(node_name, option::t[span], (@ast_node)[]);\n+    branch(node_name, option::t<span>, (@ast_node)[]);\n     i_seq((@ast_node)[]);\n-    i_opt(option::t[@ast_node]);\n+    i_opt(option::t<@ast_node>);\n     l_bool(bool);\n     l_ident(ident);\n     l_fn_ident(fn_ident);\n@@ -44,8 +44,8 @@ tag ast_node {\n     l_attr_style;\n \n     // these could be avoided, at the cost of making #br_* more convoluted\n-    l_optional_filename(option::t[filename]);\n-    l_optional_string(option::t[str]);\n+    l_optional_filename(option::t<filename>);\n+    l_optional_string(option::t<str>);\n     l_seq_ident(ident[]);\n     l_seq_ty_param(ty_param[]);\n \n@@ -245,7 +245,7 @@ type ctx = {\n \n /** Type of failure function: to be invoked if typification fails.\n     It's hopefully a bug for this to be invoked without a span. */\n-type ff = fn(sp: option::t[span], msg: str) -> !;\n+type ff = fn(sp: option::t<span>, msg: str) -> !;\n \n fn dummy() {\n \n@@ -384,8 +384,8 @@ fn seq_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n }\n \n fn opt_cv[T](conversion: fn (&ctx, &@ast_node) -> T)\n-    -> fn (&ctx, @ast_node) -> option::t[T] {\n-    ret lambda(ctx: &ctx, ut: @ast_node) -> option::t[T] {\n+    -> fn (&ctx, @ast_node) -> option::t<T> {\n+    ret lambda(ctx: &ctx, ut: @ast_node) -> option::t<T> {\n         ret alt *ut {\n           i_opt(ut_maybe) { option::map(bind conversion(ctx, _), ut_maybe) }\n           branch(_, sp, _) {"}, {"sha": "b0838d5329de12ecfb049839e5c0ed8d653cec8a", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -11,17 +11,17 @@ import std::option::none;\n import std::option::some;\n \n type interner[T] =\n-    {map: hashmap[T, uint],\n+    {map: hashmap<T, uint>,\n      mutable vect: [T],\n-     hasher: hashfn[T],\n-     eqer: eqfn[T]};\n+     hasher: hashfn<T>,\n+     eqer: eqfn<T>};\n \n-fn mk[@T](hasher: hashfn[T], eqer: eqfn[T]) -> interner[T] {\n+fn mk[@T](hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     let m = map::mk_hashmap[T, uint](hasher, eqer);\n     ret {map: m, mutable vect: ~[], hasher: hasher, eqer: eqer};\n }\n \n-fn intern[@T](itr: &interner[T], val: &T) -> uint {\n+fn intern[@T](itr: &interner<T>, val: &T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n@@ -33,7 +33,7 @@ fn intern[@T](itr: &interner[T], val: &T) -> uint {\n     }\n }\n \n-fn get[T](itr: &interner[T], idx: uint) -> T { ret itr.vect.(idx); }\n+fn get[T](itr: &interner<T>, idx: uint) -> T { ret itr.vect.(idx); }\n \n-fn len[T](itr : &interner[T]) -> uint { ret vec::len(itr.vect); }\n+fn len[T](itr : &interner<T>) -> uint { ret vec::len(itr.vect); }\n "}, {"sha": "8f4323e5c17296e858f79b2049f562e99c222042", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -14,28 +14,28 @@ import codemap::span;\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n // hold functions that take visitors. A vt tag is used to break the cycle.\n-tag vt[E] { mk_vt(visitor[E]); }\n+tag vt[E] { mk_vt(visitor<E>); }\n \n type visitor[E] =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n-    @{visit_mod: fn(&_mod, &span, &E, &vt[E]) ,\n-      visit_view_item: fn(&@view_item, &E, &vt[E]) ,\n-      visit_native_item: fn(&@native_item, &E, &vt[E]) ,\n-      visit_item: fn(&@item, &E, &vt[E]) ,\n-      visit_local: fn(&@local, &E, &vt[E]) ,\n-      visit_block: fn(&ast::blk, &E, &vt[E]) ,\n-      visit_stmt: fn(&@stmt, &E, &vt[E]) ,\n-      visit_arm: fn(&arm, &E, &vt[E]) ,\n-      visit_pat: fn(&@pat, &E, &vt[E]) ,\n-      visit_decl: fn(&@decl, &E, &vt[E]) ,\n-      visit_expr: fn(&@expr, &E, &vt[E]) ,\n-      visit_ty: fn(&@ty, &E, &vt[E]) ,\n-      visit_constr: fn(&path, &span, node_id, &E, &vt[E]) ,\n+    @{visit_mod: fn(&_mod, &span, &E, &vt<E>),\n+      visit_view_item: fn(&@view_item, &E, &vt<E>),\n+      visit_native_item: fn(&@native_item, &E, &vt<E>),\n+      visit_item: fn(&@item, &E, &vt<E>),\n+      visit_local: fn(&@local, &E, &vt<E>),\n+      visit_block: fn(&ast::blk, &E, &vt<E>),\n+      visit_stmt: fn(&@stmt, &E, &vt<E>),\n+      visit_arm: fn(&arm, &E, &vt<E>),\n+      visit_pat: fn(&@pat, &E, &vt<E>),\n+      visit_decl: fn(&@decl, &E, &vt<E>),\n+      visit_expr: fn(&@expr, &E, &vt<E>),\n+      visit_ty: fn(&@ty, &E, &vt<E>),\n+      visit_constr: fn(&path, &span, node_id, &E, &vt<E>),\n       visit_fn:\n-          fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt[E]) };\n+          fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt<E>) };\n \n-fn default_visitor[E]() -> visitor[E] {\n+fn default_visitor[E]() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod[E](_, _, _, _),\n           visit_view_item: bind visit_view_item[E](_, _, _),\n           visit_native_item: bind visit_native_item[E](_, _, _),\n@@ -52,11 +52,11 @@ fn default_visitor[E]() -> visitor[E] {\n           visit_fn: bind visit_fn[E](_, _, _, _, _, _, _)};\n }\n \n-fn visit_crate[E](c: &crate, e: &E, v: &vt[E]) {\n+fn visit_crate[E](c: &crate, e: &E, v: &vt<E>) {\n     v.visit_mod(c.node.module, c.span, e, v);\n }\n \n-fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt[E]) {\n+fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt<E>) {\n     alt cd.node {\n       cdir_src_mod(_, _, _) { }\n       cdir_dir_mod(_, _, cdirs, _) {\n@@ -70,20 +70,20 @@ fn visit_crate_directive[E](cd: &@crate_directive, e: &E, v: &vt[E]) {\n     }\n }\n \n-fn visit_mod[E](m: &_mod, sp: &span, e: &E, v: &vt[E]) {\n+fn visit_mod[E](m: &_mod, sp: &span, e: &E, v: &vt<E>) {\n     for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n     for i: @item in m.items { v.visit_item(i, e, v); }\n }\n \n-fn visit_view_item[E](vi: &@view_item, e: &E, v: &vt[E]) { }\n+fn visit_view_item[E](vi: &@view_item, e: &E, v: &vt<E>) { }\n \n-fn visit_local[E](loc: &@local, e: &E, v: &vt[E]) {\n+fn visit_local[E](loc: &@local, e: &E, v: &vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n     alt loc.node.init { none. { } some(i) { v.visit_expr(i.expr, e, v); } }\n }\n \n-fn visit_item[E](i: &@item, e: &E, v: &vt[E]) {\n+fn visit_item[E](i: &@item, e: &E, v: &vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(f, tp) { v.visit_fn(f, tp, i.span, some(i.ident), i.id, e, v); }\n@@ -111,7 +111,7 @@ fn visit_item[E](i: &@item, e: &E, v: &vt[E]) {\n     }\n }\n \n-fn visit_ty[E](t: &@ty, e: &E, v: &vt[E]) {\n+fn visit_ty[E](t: &@ty, e: &E, v: &vt<E>) {\n     alt t.node {\n       ty_nil. {/* no-op */ }\n       ty_bot. {/* no-op */ }\n@@ -153,7 +153,7 @@ fn visit_ty[E](t: &@ty, e: &E, v: &vt[E]) {\n       ty_type. {/* no-op */ }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n-        for tc: @spanned[constr_general_[path, node_id]] in cs {\n+        for tc: @spanned<constr_general_<path, node_id>> in cs {\n             v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n         }\n       }\n@@ -162,11 +162,11 @@ fn visit_ty[E](t: &@ty, e: &E, v: &vt[E]) {\n }\n \n fn visit_constr[E](operator: &path, sp: &span, id: node_id, e: &E,\n-                   v: &vt[E]) {\n+                   v: &vt<E>) {\n     // default\n }\n \n-fn visit_pat[E](p: &@pat, e: &E, v: &vt[E]) {\n+fn visit_pat[E](p: &@pat, e: &E, v: &vt<E>) {\n     alt p.node {\n       pat_tag(path, children) {\n         for tp: @ty in path.node.types { v.visit_ty(tp, e, v); }\n@@ -183,14 +183,14 @@ fn visit_pat[E](p: &@pat, e: &E, v: &vt[E]) {\n     }\n }\n \n-fn visit_native_item[E](ni: &@native_item, e: &E, v: &vt[E]) {\n+fn visit_native_item[E](ni: &@native_item, e: &E, v: &vt<E>) {\n     alt ni.node {\n       native_item_fn(_, fd, _) { visit_fn_decl(fd, e, v); }\n       native_item_ty. { }\n     }\n }\n \n-fn visit_fn_decl[E](fd: &fn_decl, e: &E, v: &vt[E]) {\n+fn visit_fn_decl[E](fd: &fn_decl, e: &E, v: &vt<E>) {\n     for a: arg in fd.inputs { v.visit_ty(a.ty, e, v); }\n     for c: @constr in fd.constraints {\n         v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n@@ -199,25 +199,25 @@ fn visit_fn_decl[E](fd: &fn_decl, e: &E, v: &vt[E]) {\n }\n \n fn visit_fn[E](f: &_fn, tp: &[ty_param], sp: &span, i: &fn_ident, id: node_id,\n-               e: &E, v: &vt[E]) {\n+               e: &E, v: &vt<E>) {\n     visit_fn_decl(f.decl, e, v);\n     v.visit_block(f.body, e, v);\n }\n \n-fn visit_block[E](b: &ast::blk, e: &E, v: &vt[E]) {\n+fn visit_block[E](b: &ast::blk, e: &E, v: &vt<E>) {\n     for s: @stmt in b.node.stmts { v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n-fn visit_stmt[E](s: &@stmt, e: &E, v: &vt[E]) {\n+fn visit_stmt[E](s: &@stmt, e: &E, v: &vt<E>) {\n     alt s.node {\n       stmt_decl(d, _) { v.visit_decl(d, e, v); }\n       stmt_expr(ex, _) { v.visit_expr(ex, e, v); }\n       stmt_crate_directive(cd) { visit_crate_directive(cd, e, v); }\n     }\n }\n \n-fn visit_decl[E](d: &@decl, e: &E, v: &vt[E]) {\n+fn visit_decl[E](d: &@decl, e: &E, v: &vt<E>) {\n     alt d.node {\n       decl_local(locs) {\n         for loc: @ast::local in locs { v.visit_local(loc, e, v); }\n@@ -226,15 +226,15 @@ fn visit_decl[E](d: &@decl, e: &E, v: &vt[E]) {\n     }\n }\n \n-fn visit_expr_opt[E](eo: option::t[@expr], e: &E, v: &vt[E]) {\n+fn visit_expr_opt[E](eo: option::t<@expr>, e: &E, v: &vt<E>) {\n     alt eo { none. { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n-fn visit_exprs[E](exprs: &[@expr], e: &E, v: &vt[E]) {\n+fn visit_exprs[E](exprs: &[@expr], e: &E, v: &vt<E>) {\n     for ex: @expr in exprs { v.visit_expr(ex, e, v); }\n }\n \n-fn visit_mac[E](m: mac, e: &E, v: &vt[E]) {\n+fn visit_mac[E](m: mac, e: &E, v: &vt<E>) {\n     alt m.node {\n       ast::mac_invoc(pth, arg, body) { visit_expr(arg, e, v); }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n@@ -243,7 +243,7 @@ fn visit_mac[E](m: mac, e: &E, v: &vt[E]) {\n     }\n }\n \n-fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n+fn visit_expr[E](ex: &@expr, e: &E, v: &vt<E>) {\n     alt ex.node {\n       expr_vec(es, _, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n@@ -260,7 +260,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n       expr_self_method(_) { }\n       expr_bind(callee, args) {\n         v.visit_expr(callee, e, v);\n-        for eo: option::t[@expr] in args { visit_expr_opt(eo, e, v); }\n+        for eo: option::t<@expr> in args { visit_expr_opt(eo, e, v); }\n       }\n       expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_unary(_, a) { v.visit_expr(a, e, v); }\n@@ -338,7 +338,7 @@ fn visit_expr[E](ex: &@expr, e: &E, v: &vt[E]) {\n     }\n }\n \n-fn visit_arm[E](a: &arm, e: &E, v: &vt[E]) {\n+fn visit_arm[E](a: &arm, e: &E, v: &vt<E>) {\n     for p: @pat in a.pats { v.visit_pat(p, e, v); }\n     v.visit_block(a.body, e, v);\n }\n@@ -384,64 +384,64 @@ fn default_simple_visitor() -> simple_visitor {\n               }};\n }\n \n-fn mk_simple_visitor(v: &simple_visitor) -> vt[()] {\n-    fn v_mod(f: fn(&_mod, &span) , m: &_mod, sp: &span, e: &(), v: &vt[()]) {\n+fn mk_simple_visitor(v: &simple_visitor) -> vt<()> {\n+    fn v_mod(f: fn(&_mod, &span) , m: &_mod, sp: &span, e: &(), v: &vt<()>) {\n         f(m, sp);\n         visit_mod(m, sp, e, v);\n     }\n-    fn v_view_item(f: fn(&@view_item) , vi: &@view_item, e: &(), v: &vt[()]) {\n+    fn v_view_item(f: fn(&@view_item) , vi: &@view_item, e: &(), v: &vt<()>) {\n         f(vi);\n         visit_view_item(vi, e, v);\n     }\n     fn v_native_item(f: fn(&@native_item) , ni: &@native_item, e: &(),\n-                     v: &vt[()]) {\n+                     v: &vt<()>) {\n         f(ni);\n         visit_native_item(ni, e, v);\n     }\n-    fn v_item(f: fn(&@item) , i: &@item, e: &(), v: &vt[()]) {\n+    fn v_item(f: fn(&@item) , i: &@item, e: &(), v: &vt<()>) {\n         f(i);\n         visit_item(i, e, v);\n     }\n-    fn v_local(f: fn(&@local) , l: &@local, e: &(), v: &vt[()]) {\n+    fn v_local(f: fn(&@local) , l: &@local, e: &(), v: &vt<()>) {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: fn(&ast::blk) , bl: &ast::blk, e: &(), v: &vt[()]) {\n+    fn v_block(f: fn(&ast::blk) , bl: &ast::blk, e: &(), v: &vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n-    fn v_stmt(f: fn(&@stmt) , st: &@stmt, e: &(), v: &vt[()]) {\n+    fn v_stmt(f: fn(&@stmt) , st: &@stmt, e: &(), v: &vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: fn(&arm) , a: &arm, e: &(), v: &vt[()]) {\n+    fn v_arm(f: fn(&arm) , a: &arm, e: &(), v: &vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n-    fn v_pat(f: fn(&@pat) , p: &@pat, e: &(), v: &vt[()]) {\n+    fn v_pat(f: fn(&@pat) , p: &@pat, e: &(), v: &vt<()>) {\n         f(p);\n         visit_pat(p, e, v);\n     }\n-    fn v_decl(f: fn(&@decl) , d: &@decl, e: &(), v: &vt[()]) {\n+    fn v_decl(f: fn(&@decl) , d: &@decl, e: &(), v: &vt<()>) {\n         f(d);\n         visit_decl(d, e, v);\n     }\n-    fn v_expr(f: fn(&@expr) , ex: &@expr, e: &(), v: &vt[()]) {\n+    fn v_expr(f: fn(&@expr) , ex: &@expr, e: &(), v: &vt<()>) {\n         f(ex);\n         visit_expr(ex, e, v);\n     }\n-    fn v_ty(f: fn(&@ty) , ty: &@ty, e: &(), v: &vt[()]) {\n+    fn v_ty(f: fn(&@ty) , ty: &@ty, e: &(), v: &vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n     fn v_constr(f: fn(&path, &span, node_id) , pt: &path, sp: &span,\n-                id: node_id, e: &(), v: &vt[()]) {\n+                id: node_id, e: &(), v: &vt<()>) {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n     fn v_fn(f: fn(&_fn, &[ty_param], &span, &fn_ident, node_id) , ff: &_fn,\n             tps: &[ty_param], sp: &span, ident: &fn_ident, id: node_id,\n-            e: &(), v: &vt[()]) {\n+            e: &(), v: &vt<()>) {\n         f(ff, tps, sp, ident, id);\n         visit_fn(ff, tps, sp, ident, id, e, v);\n     }"}, {"sha": "d64d553c312ff851b1d6c35352d9b64081c22ab5", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -28,7 +28,7 @@ import print::pprust::print_type;\n import print::pprust::print_literal;\n import print::pp::mk_printer;\n \n-type flag = hashmap[str, ()];\n+type flag = hashmap<str, ()>;\n \n fn def_eq(a: &ast::def_id, b: &ast::def_id) -> bool {\n     ret a.crate == b.crate && a.node == b.node;\n@@ -41,9 +41,9 @@ fn hash_def(d: &ast::def_id) -> uint {\n     ret h;\n }\n \n-fn new_def_hash[@V]() -> std::map::hashmap[ast::def_id, V] {\n-    let hasher: std::map::hashfn[ast::def_id] = hash_def;\n-    let eqer: std::map::eqfn[ast::def_id] = def_eq;\n+fn new_def_hash[@V]() -> std::map::hashmap<ast::def_id, V> {\n+    let hasher: std::map::hashfn<ast::def_id> = hash_def;\n+    let eqer: std::map::eqfn<ast::def_id> = def_eq;\n     ret std::map::mk_hashmap[ast::def_id, V](hasher, eqer);\n }\n "}, {"sha": "e79eeb224b1a0ee299826e2a3d222e3373b59ec3", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4a0f997fb01b9cbb650532fea1278159faff064/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=e4a0f997fb01b9cbb650532fea1278159faff064", "patch": "@@ -41,7 +41,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         let s = mode_str(input.mode);\n         ret s + ty_to_str(cx, input.ty);\n     }\n-    fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t[ast::ident],\n+    fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n                  inputs: &[arg], output: t, cf: ast::controlflow,\n                  constrs: &[@constr]) -> str {\n         let s = proto_to_str(proto);\n@@ -92,7 +92,7 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n       ty_istr. { s += \"istr\"; }\n       ty_box(tm) { s += \"@\" + mt_to_str(cx, tm); }\n       ty_uniq(t) { s += \"~\" + ty_to_str(cx, t); }\n-      ty_vec(tm) { s += \"vec[\" + mt_to_str(cx, tm) + \"]\"; }\n+      ty_vec(tm) { s += \"vec<\" + mt_to_str(cx, tm) + \">\"; }\n       ty_ivec(tm) { s += \"[\" + mt_to_str(cx, tm) + \"]\"; }\n       ty_type. { s += \"type\"; }\n       ty_rec(elems) {\n@@ -162,7 +162,7 @@ fn constrs_str(constrs: &[@constr]) -> str {\n     ret s;\n }\n \n-fn ty_constr_to_str[Q](c: &@ast::spanned[ast::constr_general_[ast::path, Q]])\n+fn ty_constr_to_str[Q](c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n    -> str {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str[ast::path](path_to_str, c.node.args);"}]}