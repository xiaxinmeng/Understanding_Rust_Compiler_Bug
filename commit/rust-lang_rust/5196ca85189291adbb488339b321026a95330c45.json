{"sha": "5196ca85189291adbb488339b321026a95330c45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOTZjYTg1MTg5MjkxYWRiYjQ4ODMzOWIzMjEwMjZhOTUzMzBjNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-23T03:54:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-23T03:54:10Z"}, "message": "Auto merge of #37681 - nrc:crate-metadata, r=@alexcrichton\n\nadd --crate-type metadata\n\nr? @alexcrichton", "tree": {"sha": "964d130609bc82c03bc10f440f883a3460e4adba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/964d130609bc82c03bc10f440f883a3460e4adba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5196ca85189291adbb488339b321026a95330c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5196ca85189291adbb488339b321026a95330c45", "html_url": "https://github.com/rust-lang/rust/commit/5196ca85189291adbb488339b321026a95330c45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5196ca85189291adbb488339b321026a95330c45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cabe2151299c63497abc3a20bd08c04c0cd32a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cabe2151299c63497abc3a20bd08c04c0cd32a3", "html_url": "https://github.com/rust-lang/rust/commit/1cabe2151299c63497abc3a20bd08c04c0cd32a3"}, {"sha": "af1b19555ce636788c19dba979b57536792d90e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/af1b19555ce636788c19dba979b57536792d90e9", "html_url": "https://github.com/rust-lang/rust/commit/af1b19555ce636788c19dba979b57536792d90e9"}], "stats": {"total": 455, "additions": 374, "deletions": 81}, "files": [{"sha": "a7f28dd6d58c4009711d14d1cefdafc1b47761ef", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -56,12 +56,13 @@ pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-// Where a crate came from on the local filesystem. One of these two options\n+// Where a crate came from on the local filesystem. One of these three options\n // must be non-None.\n #[derive(PartialEq, Clone, Debug)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n+    pub rmeta: Option<(PathBuf, PathKind)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n@@ -76,6 +77,30 @@ pub enum DepKind {\n     Explicit,\n }\n \n+#[derive(PartialEq, Clone, Debug)]\n+pub enum LibSource {\n+    Some(PathBuf),\n+    MetadataOnly,\n+    None,\n+}\n+\n+impl LibSource {\n+    pub fn is_some(&self) -> bool {\n+        if let LibSource::Some(_) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn option(&self) -> Option<PathBuf> {\n+        match *self {\n+            LibSource::Some(ref p) => Some(p.clone()),\n+            LibSource::MetadataOnly | LibSource::None => None,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Debug, PartialEq, Clone, RustcEncodable, RustcDecodable)]\n pub enum LinkagePreference {\n     RequireDynamic,\n@@ -244,7 +269,7 @@ pub trait CrateStore<'tcx> {\n     // utility functions\n     fn metadata_filename(&self) -> &str;\n     fn metadata_section_name(&self, target: &Target) -> &str;\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>;\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>;\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource;\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n     fn encode_metadata<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -427,7 +452,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // utility functions\n     fn metadata_filename(&self) -> &str { bug!(\"metadata_filename\") }\n     fn metadata_section_name(&self, target: &Target) -> &str { bug!(\"metadata_section_name\") }\n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n         { vec![] }\n     fn used_crate_source(&self, cnum: CrateNum) -> CrateSource { bug!(\"used_crate_source\") }\n     fn extern_mod_stmt_cnum(&self, emod_id: ast::NodeId) -> Option<CrateNum> { None }"}, {"sha": "ee7f13f9e6e2266ddfafe6e0aa8b4dc629e6b560", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -114,7 +114,7 @@ fn calculate_type(sess: &session::Session,\n \n         // No linkage happens with rlibs, we just needed the metadata (which we\n         // got long ago), so don't bother with anything.\n-        config::CrateTypeRlib => return Vec::new(),\n+        config::CrateTypeRlib | config::CrateTypeMetadata => return Vec::new(),\n \n         // Staticlibs and cdylibs must have all static dependencies. If any fail\n         // to be found, we generate some nice pretty errors.\n@@ -192,7 +192,7 @@ fn calculate_type(sess: &session::Session,\n         if src.dylib.is_none() &&\n            !formats.contains_key(&cnum) &&\n            sess.cstore.dep_kind(cnum) == DepKind::Explicit {\n-            assert!(src.rlib.is_some());\n+            assert!(src.rlib.is_some() || src.rmeta.is_some());\n             info!(\"adding staticlib: {}\", sess.cstore.crate_name(cnum));\n             add_library(sess, cnum, RequireStatic, &mut formats);\n             ret[cnum.as_usize() - 1] = Linkage::Static;"}, {"sha": "35e0e494771ba131a46b6a488beb2b7a5147e823", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n     fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> ReachableContext<'a, 'tcx> {\n         let any_library = tcx.sess.crate_types.borrow().iter().any(|ty| {\n             *ty == config::CrateTypeRlib || *ty == config::CrateTypeDylib ||\n-            *ty == config::CrateTypeProcMacro\n+            *ty == config::CrateTypeProcMacro || *ty == config::CrateTypeMetadata\n         });\n         ReachableContext {\n             tcx: tcx,"}, {"sha": "30690c099194f644308b86cff6153a9a8f7a311e", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -75,7 +75,8 @@ fn verify(sess: &Session, items: &lang_items::LanguageItems) {\n             config::CrateTypeCdylib |\n             config::CrateTypeExecutable |\n             config::CrateTypeStaticlib => true,\n-            config::CrateTypeRlib => false,\n+            config::CrateTypeRlib |\n+            config::CrateTypeMetadata => false,\n         }\n     });\n     if !needs_check {"}, {"sha": "f3677b8081953a2013543967cdf246b8247356e9", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -78,18 +78,6 @@ pub enum OutputType {\n     DepInfo,\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum ErrorOutputType {\n-    HumanReadable(ColorConfig),\n-    Json,\n-}\n-\n-impl Default for ErrorOutputType {\n-    fn default() -> ErrorOutputType {\n-        ErrorOutputType::HumanReadable(ColorConfig::Auto)\n-    }\n-}\n-\n impl OutputType {\n     fn is_compatible_with_codegen_units_and_single_output_file(&self) -> bool {\n         match *self {\n@@ -125,6 +113,18 @@ impl OutputType {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum ErrorOutputType {\n+    HumanReadable(ColorConfig),\n+    Json,\n+}\n+\n+impl Default for ErrorOutputType {\n+    fn default() -> ErrorOutputType {\n+        ErrorOutputType::HumanReadable(ColorConfig::Auto)\n+    }\n+}\n+\n // Use tree-based collections to cheaply get a deterministic Hash implementation.\n // DO NOT switch BTreeMap out for an unsorted container type! That would break\n // dependency tracking for commandline arguments.\n@@ -483,6 +483,7 @@ pub enum CrateType {\n     CrateTypeStaticlib,\n     CrateTypeCdylib,\n     CrateTypeProcMacro,\n+    CrateTypeMetadata,\n }\n \n #[derive(Clone, Hash)]\n@@ -1147,7 +1148,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              assumed.\", \"[KIND=]NAME\"),\n         opt::multi_s(\"\", \"crate-type\", \"Comma separated list of types of crates\n                                     for the compiler to emit\",\n-                   \"[bin|lib|rlib|dylib|cdylib|staticlib]\"),\n+                   \"[bin|lib|rlib|dylib|cdylib|staticlib|metadata]\"),\n         opt::opt_s(\"\", \"crate-name\", \"Specify the name of the crate being built\",\n                \"NAME\"),\n         opt::multi_s(\"\", \"emit\", \"Comma separated list of types of output for \\\n@@ -1539,6 +1540,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n                 \"cdylib\"    => CrateTypeCdylib,\n                 \"bin\"       => CrateTypeExecutable,\n                 \"proc-macro\" => CrateTypeProcMacro,\n+                \"metadata\"  => CrateTypeMetadata,\n                 _ => {\n                     return Err(format!(\"unknown crate type: `{}`\",\n                                        part));\n@@ -1623,6 +1625,7 @@ impl fmt::Display for CrateType {\n             CrateTypeStaticlib => \"staticlib\".fmt(f),\n             CrateTypeCdylib => \"cdylib\".fmt(f),\n             CrateTypeProcMacro => \"proc-macro\".fmt(f),\n+            CrateTypeMetadata => \"metadata\".fmt(f),\n         }\n     }\n }"}, {"sha": "5cbb8f93fc9d40433f0c322c111de97c21b18bc2", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -1182,6 +1182,9 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                          Some(ref n) if *n == \"rlib\" => {\n                              Some(config::CrateTypeRlib)\n                          }\n+                         Some(ref n) if *n == \"metadata\" => {\n+                             Some(config::CrateTypeMetadata)\n+                         }\n                          Some(ref n) if *n == \"dylib\" => {\n                              Some(config::CrateTypeDylib)\n                          }"}, {"sha": "27c00481bfd3adad17006212acada0650b339915", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -44,6 +44,7 @@ use log;\n pub struct Library {\n     pub dylib: Option<(PathBuf, PathKind)>,\n     pub rlib: Option<(PathBuf, PathKind)>,\n+    pub rmeta: Option<(PathBuf, PathKind)>,\n     pub metadata: MetadataBlob,\n }\n \n@@ -62,10 +63,11 @@ fn dump_crates(cstore: &CStore) {\n         info!(\"  cnum: {}\", data.cnum);\n         info!(\"  hash: {}\", data.hash());\n         info!(\"  reqd: {:?}\", data.dep_kind.get());\n-        let CrateSource { dylib, rlib } = data.source.clone();\n+        let CrateSource { dylib, rlib, rmeta } = data.source.clone();\n         dylib.map(|dl| info!(\"  dylib: {}\", dl.0.display()));\n         rlib.map(|rl|  info!(\"   rlib: {}\", rl.0.display()));\n-    })\n+        rmeta.map(|rl| info!(\"   rmeta: {}\", rl.0.display()));\n+    });\n }\n \n #[derive(Debug)]\n@@ -278,14 +280,15 @@ impl<'a> CrateLoader<'a> {\n                 ident: ident.to_string(),\n                 dylib: lib.dylib.clone().map(|p| p.0),\n                 rlib:  lib.rlib.clone().map(|p| p.0),\n+                rmeta: lib.rmeta.clone().map(|p| p.0),\n             })\n         } else {\n             None\n         };\n         // Maintain a reference to the top most crate.\n         let root = if root.is_some() { root } else { &crate_paths };\n \n-        let Library { dylib, rlib, metadata } = lib;\n+        let Library { dylib, rlib, rmeta, metadata } = lib;\n \n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n@@ -305,6 +308,7 @@ impl<'a> CrateLoader<'a> {\n             source: cstore::CrateSource {\n                 dylib: dylib,\n                 rlib: rlib,\n+                rmeta: rmeta,\n             },\n         });\n \n@@ -767,7 +771,8 @@ impl<'a> CrateLoader<'a> {\n                 config::CrateTypeProcMacro |\n                 config::CrateTypeCdylib |\n                 config::CrateTypeStaticlib => need_lib_alloc = true,\n-                config::CrateTypeRlib => {}\n+                config::CrateTypeRlib |\n+                config::CrateTypeMetadata => {}\n             }\n         }\n         if !need_lib_alloc && !need_exe_alloc { return }"}, {"sha": "7c1834c1576a8f1f5e8d5318a5c92121652e960b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -25,7 +25,6 @@ use rustc::util::nodemap::{FxHashMap, NodeMap, NodeSet, DefIdMap};\n \n use std::cell::{RefCell, Cell};\n use std::rc::Rc;\n-use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n@@ -34,7 +33,7 @@ use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n pub use rustc::middle::cstore::{NativeStatic, NativeFramework, NativeUnknown};\n-pub use rustc::middle::cstore::{CrateSource, LinkMeta};\n+pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n \n // A map from external crate numbers (as decoded from some crate file) to\n // local crate numbers (as generated during this session). Each external\n@@ -45,6 +44,7 @@ pub type CrateNumMap = IndexVec<CrateNum, CrateNum>;\n pub enum MetadataBlob {\n     Inflated(Bytes),\n     Archive(locator::ArchiveMetadata),\n+    Raw(Vec<u8>),\n }\n \n /// Holds information about a syntax_pos::FileMap imported from another crate.\n@@ -186,7 +186,7 @@ impl CStore {\n     // positions.\n     pub fn do_get_used_crates(&self,\n                               prefer: LinkagePreference)\n-                              -> Vec<(CrateNum, Option<PathBuf>)> {\n+                              -> Vec<(CrateNum, LibSource)> {\n         let mut ordering = Vec::new();\n         for (&num, _) in self.metas.borrow().iter() {\n             self.push_dependencies_in_postorder(&mut ordering, num);\n@@ -202,6 +202,16 @@ impl CStore {\n                     LinkagePreference::RequireDynamic => data.source.dylib.clone().map(|p| p.0),\n                     LinkagePreference::RequireStatic => data.source.rlib.clone().map(|p| p.0),\n                 };\n+                let path = match path {\n+                    Some(p) => LibSource::Some(p),\n+                    None => {\n+                        if data.source.rmeta.is_some() {\n+                            LibSource::MetadataOnly\n+                        } else {\n+                            LibSource::None\n+                        }\n+                    }\n+                };\n                 Some((cnum, path))\n             })\n             .collect::<Vec<_>>();"}, {"sha": "ead933384b96d9b4e18bbfbe807270c406e83c02", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -13,7 +13,7 @@ use encoder;\n use locator;\n use schema;\n \n-use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, DepKind, ExternCrate};\n+use rustc::middle::cstore::{InlinedItem, CrateStore, CrateSource, LibSource, DepKind, ExternCrate};\n use rustc::middle::cstore::{NativeLibrary, LinkMeta, LinkagePreference, LoadedMacro};\n use rustc::hir::def::{self, Def};\n use rustc::middle::lang_items;\n@@ -28,7 +28,6 @@ use rustc::mir::Mir;\n use rustc::util::nodemap::{NodeSet, DefIdMap};\n use rustc_back::PanicStrategy;\n \n-use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::new_parser_from_source_str;\n@@ -545,7 +544,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         locator::meta_section_name(target)\n     }\n \n-    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, Option<PathBuf>)>\n+    fn used_crates(&self, prefer: LinkagePreference) -> Vec<(CrateNum, LibSource)>\n     {\n         self.do_get_used_crates(prefer)\n     }"}, {"sha": "8a187bb97969a385145c1e098a26e60c8ea28b01", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -88,8 +88,9 @@ pub trait Metadata<'a, 'tcx>: Copy {\n impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a MetadataBlob {\n     fn raw_bytes(self) -> &'a [u8] {\n         match *self {\n-            MetadataBlob::Inflated(ref vec) => &vec[..],\n+            MetadataBlob::Inflated(ref vec) => vec,\n             MetadataBlob::Archive(ref ar) => ar.as_slice(),\n+            MetadataBlob::Raw(ref vec) => vec,\n         }\n     }\n }"}, {"sha": "be9284baa74cbabe6f37d9c7e3b9e36b1894fe7e", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 58, "deletions": 31, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -53,6 +53,13 @@\n //! is a platform-defined dynamic library. Each library has a metadata somewhere\n //! inside of it.\n //!\n+//! A third kind of dependency is an rmeta file. These are metadata files and do\n+//! not contain any code, etc. To a first approximation, these are treated in the\n+//! same way as rlibs. Where there is both an rlib and an rmeta file, the rlib\n+//! gets priority (even if the rmeta file is newer). An rmeta file is only\n+//! useful for checking a downstream crate, attempting to link one will cause an\n+//! error.\n+//!\n //! When translating a crate name to a crate on the filesystem, we all of a\n //! sudden need to take into account both rlibs and dylibs! Linkage later on may\n //! use either one of these files, as each has their pros/cons. The job of crate\n@@ -233,8 +240,8 @@ use rustc_back::target::Target;\n \n use std::cmp;\n use std::fmt;\n-use std::fs;\n-use std::io;\n+use std::fs::{self, File};\n+use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n use std::ptr;\n use std::slice;\n@@ -276,33 +283,31 @@ pub struct CratePaths {\n     pub ident: String,\n     pub dylib: Option<PathBuf>,\n     pub rlib: Option<PathBuf>,\n+    pub rmeta: Option<PathBuf>,\n }\n \n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n #[derive(Copy, Clone, PartialEq)]\n enum CrateFlavor {\n     Rlib,\n+    Rmeta,\n     Dylib,\n }\n \n impl fmt::Display for CrateFlavor {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(match *self {\n             CrateFlavor::Rlib => \"rlib\",\n+            CrateFlavor::Rmeta => \"rmeta\",\n             CrateFlavor::Dylib => \"dylib\",\n         })\n     }\n }\n \n impl CratePaths {\n     fn paths(&self) -> Vec<PathBuf> {\n-        match (&self.dylib, &self.rlib) {\n-            (&None, &None) => vec![],\n-            (&Some(ref p), &None) |\n-            (&None, &Some(ref p)) => vec![p.clone()],\n-            (&Some(ref p1), &Some(ref p2)) => vec![p1.clone(), p2.clone()],\n-        }\n+        self.dylib.iter().chain(self.rlib.iter()).chain(self.rmeta.iter()).cloned().collect()\n     }\n }\n \n@@ -458,32 +463,35 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n-                (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], true)\n-            } else if file.starts_with(&dylib_prefix) &&\n-                                         file.ends_with(&dypair.1) {\n-                (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], false)\n-            } else {\n-                if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n-                    staticlibs.push(CrateMismatch {\n-                        path: path.to_path_buf(),\n-                        got: \"static\".to_string(),\n-                    });\n-                }\n-                return FileDoesntMatch;\n-            };\n+            let (hash, found_kind) =\n+                if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rlib\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rlib\".len())], CrateFlavor::Rlib)\n+                } else if file.starts_with(&rlib_prefix[..]) && file.ends_with(\".rmeta\") {\n+                    (&file[(rlib_prefix.len())..(file.len() - \".rmeta\".len())], CrateFlavor::Rmeta)\n+                } else if file.starts_with(&dylib_prefix) &&\n+                                             file.ends_with(&dypair.1) {\n+                    (&file[(dylib_prefix.len())..(file.len() - dypair.1.len())], CrateFlavor::Dylib)\n+                } else {\n+                    if file.starts_with(&staticlib_prefix[..]) && file.ends_with(&staticpair.1) {\n+                        staticlibs.push(CrateMismatch {\n+                            path: path.to_path_buf(),\n+                            got: \"static\".to_string(),\n+                        });\n+                    }\n+                    return FileDoesntMatch;\n+                };\n             info!(\"lib candidate: {}\", path.display());\n \n             let hash_str = hash.to_string();\n             let slot = candidates.entry(hash_str)\n-                .or_insert_with(|| (FxHashMap(), FxHashMap()));\n-            let (ref mut rlibs, ref mut dylibs) = *slot;\n+                .or_insert_with(|| (FxHashMap(), FxHashMap(), FxHashMap()));\n+            let (ref mut rlibs, ref mut rmetas, ref mut dylibs) = *slot;\n             fs::canonicalize(path)\n                 .map(|p| {\n-                    if rlib {\n-                        rlibs.insert(p, kind);\n-                    } else {\n-                        dylibs.insert(p, kind);\n+                    match found_kind {\n+                        CrateFlavor::Rlib => { rlibs.insert(p, kind); }\n+                        CrateFlavor::Rmeta => { rmetas.insert(p, kind); }\n+                        CrateFlavor::Dylib => { dylibs.insert(p, kind); }\n                     }\n                     FileMatches\n                 })\n@@ -500,15 +508,17 @@ impl<'a> Context<'a> {\n         // libraries corresponds to the crate id and hash criteria that this\n         // search is being performed for.\n         let mut libraries = FxHashMap();\n-        for (_hash, (rlibs, dylibs)) in candidates {\n+        for (_hash, (rlibs, rmetas, dylibs)) in candidates {\n             let mut slot = None;\n             let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+            let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n             let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n             if let Some((h, m)) = slot {\n                 libraries.insert(h,\n                                  Library {\n                                      dylib: dylib,\n                                      rlib: rlib,\n+                                     rmeta: rmeta,\n                                      metadata: m,\n                                  });\n             }\n@@ -704,6 +714,7 @@ impl<'a> Context<'a> {\n         let sess = self.sess;\n         let dylibname = self.dylibname();\n         let mut rlibs = FxHashMap();\n+        let mut rmetas = FxHashMap();\n         let mut dylibs = FxHashMap();\n         {\n             let locs = locs.map(|l| PathBuf::from(l)).filter(|loc| {\n@@ -722,7 +733,8 @@ impl<'a> Context<'a> {\n                         return false;\n                     }\n                 };\n-                if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n+                if file.starts_with(\"lib\") &&\n+                   (file.ends_with(\".rlib\") || file.ends_with(\".rmeta\")) {\n                     return true;\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n@@ -745,6 +757,8 @@ impl<'a> Context<'a> {\n             for loc in locs {\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n                     rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n+                    rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 } else {\n                     dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n                 }\n@@ -754,16 +768,18 @@ impl<'a> Context<'a> {\n         // Extract the rlib/dylib pair.\n         let mut slot = None;\n         let rlib = self.extract_one(rlibs, CrateFlavor::Rlib, &mut slot);\n+        let rmeta = self.extract_one(rmetas, CrateFlavor::Rmeta, &mut slot);\n         let dylib = self.extract_one(dylibs, CrateFlavor::Dylib, &mut slot);\n \n-        if rlib.is_none() && dylib.is_none() {\n+        if rlib.is_none() && rmeta.is_none() && dylib.is_none() {\n             return None;\n         }\n         match slot {\n             Some((_, metadata)) => {\n                 Some(Library {\n                     dylib: dylib,\n                     rlib: rlib,\n+                    rmeta: rmeta,\n                     metadata: metadata,\n                 })\n             }\n@@ -851,6 +867,15 @@ fn get_metadata_section_imp(target: &Target,\n                 Ok(blob)\n             }\n         };\n+    } else if flavor == CrateFlavor::Rmeta {\n+        let mut file = File::open(filename).map_err(|_|\n+            format!(\"could not open file: '{}'\", filename.display()))?;\n+        let mut buf = vec![];\n+        file.read_to_end(&mut buf).map_err(|_|\n+            format!(\"failed to read rlib metadata: '{}'\", filename.display()))?;\n+        let blob = MetadataBlob::Raw(buf);\n+        verify_decompressed_encoding_version(&blob, filename)?;\n+        return Ok(blob);\n     }\n     unsafe {\n         let buf = common::path2cstr(filename);\n@@ -934,6 +959,8 @@ pub fn list_file_metadata(target: &Target, path: &Path, out: &mut io::Write) ->\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {\n         CrateFlavor::Rlib\n+    } else if filename.ends_with(\".rmeta\") {\n+        CrateFlavor::Rmeta\n     } else {\n         CrateFlavor::Dylib\n     };"}, {"sha": "11ab6dcaa87f99fa02a99fac8d9068d8c462d2c1", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -231,7 +231,7 @@ impl<'a> ArchiveBuilder<'a> {\n     }\n \n     fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n-        let kind = &self.config.sess.target.target.options.archive_format[..];\n+        let kind = &*self.config.sess.target.target.options.archive_format;\n         kind.parse().map_err(|_| kind)\n     }\n "}, {"sha": "648dc4c24c9a658c79426f2b53d2f5c707ca7f6a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 23, "deletions": 14, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -19,7 +19,7 @@ use session::config::{OutputFilenames, Input, OutputType};\n use session::filesearch;\n use session::search_paths::PathKind;\n use session::Session;\n-use middle::cstore::{self, LinkMeta, NativeLibrary};\n+use middle::cstore::{self, LinkMeta, NativeLibrary, LibSource};\n use middle::cstore::{LinkagePreference, NativeLibraryKind};\n use middle::dependency_format::Linkage;\n use CrateTranslation;\n@@ -124,7 +124,6 @@ pub fn find_crate_name(sess: Option<&Session>,\n     }\n \n     \"rust_out\".to_string()\n-\n }\n \n pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n@@ -264,6 +263,9 @@ pub fn filename_for_input(sess: &Session,\n         config::CrateTypeRlib => {\n             outputs.out_directory.join(&format!(\"lib{}.rlib\", libname))\n         }\n+        config::CrateTypeMetadata => {\n+            outputs.out_directory.join(&format!(\"lib{}.rmeta\", libname))\n+        }\n         config::CrateTypeCdylib |\n         config::CrateTypeProcMacro |\n         config::CrateTypeDylib => {\n@@ -299,7 +301,7 @@ pub fn each_linked_rlib(sess: &Session,\n                    .or_else(|| fmts.get(&config::CrateTypeCdylib))\n                    .or_else(|| fmts.get(&config::CrateTypeProcMacro));\n     let fmts = fmts.unwrap_or_else(|| {\n-        bug!(\"could not find formats for rlibs\")\n+        bug!(\"could not find formats for rlibs\");\n     });\n     for (cnum, path) in crates {\n         match fmts[cnum.as_usize() - 1] {\n@@ -308,8 +310,12 @@ pub fn each_linked_rlib(sess: &Session,\n         }\n         let name = sess.cstore.crate_name(cnum).clone();\n         let path = match path {\n-            Some(p) => p,\n-            None => {\n+            LibSource::Some(p) => p,\n+            LibSource::MetadataOnly => {\n+                sess.fatal(&format!(\"could not find rlib for: `{}`, found rmeta (metadata) file\",\n+                                    name));\n+            }\n+            LibSource::None => {\n                 sess.fatal(&format!(\"could not find rlib for: `{}`\", name));\n             }\n         };\n@@ -353,6 +359,9 @@ fn link_binary_output(sess: &Session,\n         config::CrateTypeStaticlib => {\n             link_staticlib(sess, &objects, &out_filename, tmpdir.path());\n         }\n+        config::CrateTypeMetadata => {\n+            emit_metadata(sess, trans, &out_filename);\n+        }\n         _ => {\n             link_natively(sess, crate_type, &objects, &out_filename, trans,\n                           outputs, tmpdir.path());\n@@ -391,6 +400,13 @@ fn archive_config<'a>(sess: &'a Session,\n     }\n }\n \n+fn emit_metadata<'a>(sess: &'a Session, trans: &CrateTranslation, out_filename: &Path) {\n+    let result = fs::File::create(out_filename).and_then(|mut f| f.write_all(&trans.metadata));\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));\n+    }\n+}\n+\n // Create an 'rlib'\n //\n // An rlib in its current incarnation is essentially a renamed .a file. The\n@@ -404,6 +420,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                  tmpdir: &Path) -> ArchiveBuilder<'a> {\n     info!(\"preparing rlib from {:?} to {:?}\", objects, out_filename);\n     let mut ab = ArchiveBuilder::new(archive_config(sess, out_filename, None));\n+\n     for obj in objects {\n         ab.add_file(obj);\n     }\n@@ -465,15 +482,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // here so concurrent builds in the same directory don't try to use\n             // the same filename for metadata (stomping over one another)\n             let metadata = tmpdir.join(sess.cstore.metadata_filename());\n-            match fs::File::create(&metadata).and_then(|mut f| {\n-                f.write_all(&trans.metadata)\n-            }) {\n-                Ok(..) => {}\n-                Err(e) => {\n-                    sess.fatal(&format!(\"failed to write {}: {}\",\n-                                        metadata.display(), e));\n-                }\n-            }\n+            emit_metadata(sess, trans, &metadata);\n             ab.add_file(&metadata);\n \n             // For LTO purposes, the bytecode of this library is also inserted"}, {"sha": "ccaa0d4e1b1b059de8214d48454ea049d7897eac", "filename": "src/librustc_trans/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Frpath.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -14,9 +14,10 @@ use std::path::{Path, PathBuf};\n use std::fs;\n \n use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::LibSource;\n \n pub struct RPathConfig<'a> {\n-    pub used_crates: Vec<(CrateNum, Option<PathBuf>)>,\n+    pub used_crates: Vec<(CrateNum, LibSource)>,\n     pub out_filename: PathBuf,\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n@@ -35,7 +36,7 @@ pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {\n     debug!(\"preparing the RPATH!\");\n \n     let libs = config.used_crates.clone();\n-    let libs = libs.into_iter().filter_map(|(_, l)| l).collect::<Vec<_>>();\n+    let libs = libs.into_iter().filter_map(|(_, l)| l.option()).collect::<Vec<_>>();\n     let rpaths = get_rpaths(config, &libs[..]);\n     flags.extend_from_slice(&rpaths_to_flags(&rpaths[..]));\n "}, {"sha": "4353c7bd58645fb1a8b957cd8b3de5243935a9ee", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -1260,7 +1260,8 @@ fn write_metadata(cx: &SharedCrateContext,\n             config::CrateTypeStaticlib |\n             config::CrateTypeCdylib => MetadataKind::None,\n \n-            config::CrateTypeRlib => MetadataKind::Uncompressed,\n+            config::CrateTypeRlib |\n+            config::CrateTypeMetadata => MetadataKind::Uncompressed,\n \n             config::CrateTypeDylib |\n             config::CrateTypeProcMacro => MetadataKind::Compressed,\n@@ -1600,7 +1601,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_module_sources::assert_module_sources(tcx, &modules);\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n-    if tcx.sess.opts.debugging_opts.no_trans {\n+    if tcx.sess.opts.debugging_opts.no_trans ||\n+       tcx.sess.crate_types.borrow().iter().all(|ct| ct == &config::CrateTypeMetadata) {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n         return CrateTranslation {\n             modules: modules,"}, {"sha": "7bd1a96f452d83a53c47aaeb4cbe7a397c08b466", "filename": "src/test/compile-fail/auxiliary/rmeta_meta.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_meta.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"metadata\"]\n+\n+pub struct Foo {\n+    pub field: i32,\n+}"}, {"sha": "6096c4df05bb0349d8961399905c4294ce4c1798", "filename": "src/test/compile-fail/auxiliary/rmeta_rlib.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauxiliary%2Frmeta_rlib.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub struct Foo {\n+    pub field: i32,\n+}"}, {"sha": "f2ac37a2ce9f597925d07daa1bde884abc3ca770", "filename": "src/test/compile-fail/rmeta-lib-pass.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta-lib-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta-lib-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta-lib-pass.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rmeta_rlib.rs\n+// no-prefer-dynamic\n+// must-compile-successfully\n+\n+// Check that building a metadata crate works with a dependent, rlib crate.\n+// This is a cfail test since there is no executable to run.\n+\n+#![crate_type=\"metadata\"]\n+\n+extern crate rmeta_rlib;\n+use rmeta_rlib::Foo;\n+\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n+}"}, {"sha": "2c0b6f77c1e08114d0239f36fac1192e5f71d86f", "filename": "src/test/compile-fail/rmeta-pass.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta-pass.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rmeta_meta.rs\n+// no-prefer-dynamic\n+// must-compile-successfully\n+\n+// Check that building a metadata crate works with a dependent, metadata-only\n+// crate.\n+// This is a cfail test since there is no executable to run.\n+\n+#![crate_type=\"metadata\"]\n+\n+extern crate rmeta_meta;\n+use rmeta_meta::Foo;\n+\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n+}"}, {"sha": "e81e0541096d62c9bca728ef0101907600fcd8ac", "filename": "src/test/compile-fail/rmeta.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+// Check that building a metadata crate finds an error.\n+\n+#![crate_type=\"metadata\"]\n+\n+fn main() {\n+    let _ = Foo; //~ ERROR unresolved name `Foo`\n+}"}, {"sha": "3b7d1f3cc904ac2ff37e52c5588a935bf6c27d29", "filename": "src/test/compile-fail/rmeta_lib.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta_lib.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rmeta_meta.rs\n+// no-prefer-dynamic\n+// error-pattern: crate `rmeta_meta` required to be available in rlib, but it was not available\n+\n+// Check that building a non-metadata crate fails if a dependent crate is\n+// metadata-only.\n+\n+extern crate rmeta_meta;\n+use rmeta_meta::Foo;\n+\n+fn main() {\n+    let _ = Foo { field: 42 };\n+}"}, {"sha": "1c922c281397a8f45102c2d64a909a2819b05000", "filename": "src/test/compile-fail/rmeta_meta_main.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta_meta_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Fcompile-fail%2Frmeta_meta_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frmeta_meta_main.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:rmeta_meta.rs\n+// no-prefer-dynamic\n+\n+// Check that building a metadata crate finds an error with a dependent,\n+// metadata-only crate.\n+\n+#![crate_type=\"metadata\"]\n+\n+extern crate rmeta_meta;\n+use rmeta_meta::Foo;\n+\n+fn main() {\n+    let _ = Foo { field2: 42 }; //~ ERROR struct `rmeta_meta::Foo` has no field named `field2`\n+}"}, {"sha": "28c11315fa1cd2f247350109e8695ddefdf82b27", "filename": "src/test/run-pass/auxiliary/rmeta_rlib.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rlib.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"rlib\"]\n+#![crate_name=\"rmeta_aux\"]\n+\n+pub struct Foo {\n+    pub field: i32,\n+}"}, {"sha": "394845b66f3d3a105694589464d879349d60096a", "filename": "src/test/run-pass/auxiliary/rmeta_rmeta.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Frmeta_rmeta.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"metadata\"]\n+#![crate_name=\"rmeta_aux\"]\n+\n+pub struct Foo {\n+    pub field2: i32,\n+}"}, {"sha": "11684d8663af8ee9c75f3e21081c50b665ed5a16", "filename": "src/test/run-pass/rmeta.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Frun-pass%2Frmeta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5196ca85189291adbb488339b321026a95330c45/src%2Ftest%2Frun-pass%2Frmeta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frmeta.rs?ref=5196ca85189291adbb488339b321026a95330c45", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that using rlibs and rmeta dep crates work together. Specifically, that\n+// there can be both an rmeta and an rlib file and rustc will prefer the rlib.\n+\n+// aux-build:rmeta_rmeta.rs\n+// aux-build:rmeta_rlib.rs\n+\n+extern crate rmeta_aux;\n+use rmeta_aux::Foo;\n+\n+pub fn main() {\n+    let _ = Foo { field: 42 };\n+}"}]}