{"sha": "d3c70b8af516497cbc817f4b5d907ff7cf91661f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzcwYjhhZjUxNjQ5N2NiYzgxN2Y0YjVkOTA3ZmY3Y2Y5MTY2MWY=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-08T03:43:18Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-09T19:25:21Z"}, "message": "rustc_data_structures: use IndexSet in TransitiveRelation", "tree": {"sha": "2ce063b3856962d40d78b5071ab637373b72c0bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce063b3856962d40d78b5071ab637373b72c0bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c70b8af516497cbc817f4b5d907ff7cf91661f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c70b8af516497cbc817f4b5d907ff7cf91661f", "html_url": "https://github.com/rust-lang/rust/commit/d3c70b8af516497cbc817f4b5d907ff7cf91661f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c70b8af516497cbc817f4b5d907ff7cf91661f/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f71f0f2b54981d4cc7a99201d180e787c13ca6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f71f0f2b54981d4cc7a99201d180e787c13ca6d", "html_url": "https://github.com/rust-lang/rust/commit/1f71f0f2b54981d4cc7a99201d180e787c13ca6d"}], "stats": {"total": 39, "additions": 13, "deletions": 26}, "files": [{"sha": "7d137a55033f7ac89ee6e3a038c3f78a1c451b5f", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d3c70b8af516497cbc817f4b5d907ff7cf91661f/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c70b8af516497cbc817f4b5d907ff7cf91661f/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=d3c70b8af516497cbc817f4b5d907ff7cf91661f", "patch": "@@ -1,4 +1,4 @@\n-use crate::fx::FxHashMap;\n+use crate::fx::FxIndexSet;\n use crate::stable_hasher::{HashStable, StableHasher};\n use crate::sync::Lock;\n use rustc_index::bit_set::BitMatrix;\n@@ -13,10 +13,7 @@ mod tests;\n #[derive(Clone, Debug)]\n pub struct TransitiveRelation<T: Eq + Hash> {\n     // List of elements. This is used to map from a T to a usize.\n-    elements: Vec<T>,\n-\n-    // Maps each element to an index.\n-    map: FxHashMap<T, Index>,\n+    elements: FxIndexSet<T>,\n \n     // List of base edges in the graph. Require to compute transitive\n     // closure.\n@@ -39,7 +36,6 @@ impl<T: Eq + Hash> Default for TransitiveRelation<T> {\n     fn default() -> Self {\n         TransitiveRelation {\n             elements: Default::default(),\n-            map: Default::default(),\n             edges: Default::default(),\n             closure: Default::default(),\n         }\n@@ -65,20 +61,16 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     }\n \n     fn index(&self, a: &T) -> Option<Index> {\n-        self.map.get(a).cloned()\n+        self.elements.get_index_of(a).map(Index)\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n-        let &mut TransitiveRelation { ref mut elements, ref mut closure, ref mut map, .. } = self;\n-\n-        *map.entry(a.clone()).or_insert_with(|| {\n-            elements.push(a);\n-\n+        let (index, added) = self.elements.insert_full(a);\n+        if added {\n             // if we changed the dimensions, clear the cache\n-            *closure.get_mut() = None;\n-\n-            Index(elements.len() - 1)\n-        })\n+            *self.closure.get_mut() = None;\n+        }\n+        Index(index)\n     }\n \n     /// Applies the (partial) function to each edge and returns a new\n@@ -430,14 +422,11 @@ where\n {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n         d.read_struct(\"TransitiveRelation\", 2, |d| {\n-            let elements: Vec<T> = d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?;\n-            let edges = d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?;\n-            let map = elements\n-                .iter()\n-                .enumerate()\n-                .map(|(index, elem)| (elem.clone(), Index(index)))\n-                .collect();\n-            Ok(TransitiveRelation { elements, edges, map, closure: Lock::new(None) })\n+            Ok(TransitiveRelation {\n+                elements: d.read_struct_field(\"elements\", 0, |d| Decodable::decode(d))?,\n+                edges: d.read_struct_field(\"edges\", 1, |d| Decodable::decode(d))?,\n+                closure: Lock::new(None),\n+            })\n         })\n     }\n }\n@@ -452,8 +441,6 @@ where\n         let TransitiveRelation {\n             ref elements,\n             ref edges,\n-            // \"map\" is just a copy of elements vec\n-            map: _,\n             // \"closure\" is just a copy of the data above\n             closure: _,\n         } = *self;"}]}