{"sha": "28ddd7a4ef30a89091dbf48cae18f571326510fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZGRkN2E0ZWYzMGE4OTA5MWRiZjQ4Y2FlMThmNTcxMzI2NTEwZmI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-29T16:27:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-01T08:17:03Z"}, "message": "rustc: use hir::ItemLocalId instead of ast::NodeId in CFG.", "tree": {"sha": "f6b1fc399b6e9a26dd0ba28e946dbfe780152ae0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b1fc399b6e9a26dd0ba28e946dbfe780152ae0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ddd7a4ef30a89091dbf48cae18f571326510fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ddd7a4ef30a89091dbf48cae18f571326510fb", "html_url": "https://github.com/rust-lang/rust/commit/28ddd7a4ef30a89091dbf48cae18f571326510fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ddd7a4ef30a89091dbf48cae18f571326510fb/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45d31e73108b2a92d45a1a82b3e2846348112f57", "url": "https://api.github.com/repos/rust-lang/rust/commits/45d31e73108b2a92d45a1a82b3e2846348112f57", "html_url": "https://github.com/rust-lang/rust/commit/45d31e73108b2a92d45a1a82b3e2846348112f57"}], "stats": {"total": 465, "additions": 249, "deletions": 216}, "files": [{"sha": "1448fb7c528c6243597894df1a76270398f2f074", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::graph;\n use cfg::*;\n use middle::region::CodeExtent;\n use ty::{self, TyCtxt};\n-use syntax::ast;\n use syntax::ptr::P;\n \n use hir::{self, PatKind};\n@@ -30,13 +29,13 @@ struct CFGBuilder<'a, 'tcx: 'a> {\n \n #[derive(Copy, Clone)]\n struct BlockScope {\n-    block_expr_id: ast::NodeId, // id of breakable block expr node\n+    block_expr_id: hir::ItemLocalId, // id of breakable block expr node\n     break_index: CFGIndex, // where to go on `break`\n }\n \n #[derive(Copy, Clone)]\n struct LoopScope {\n-    loop_id: ast::NodeId,     // id of loop/while node\n+    loop_id: hir::ItemLocalId,     // id of loop/while node\n     continue_index: CFGIndex, // where to go on a `loop`\n     break_index: CFGIndex,    // where to go on a `break`\n }\n@@ -70,6 +69,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cfg_builder.add_contained_edge(body_exit, fn_exit);\n     let CFGBuilder { graph, .. } = cfg_builder;\n     CFG {\n+        owner_def_id,\n         graph,\n         entry,\n         exit: fn_exit,\n@@ -79,10 +79,10 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn block(&mut self, blk: &hir::Block, pred: CFGIndex) -> CFGIndex {\n         if blk.targeted_by_break {\n-            let expr_exit = self.add_ast_node(blk.id, &[]);\n+            let expr_exit = self.add_ast_node(blk.hir_id.local_id, &[]);\n \n             self.breakable_block_scopes.push(BlockScope {\n-                block_expr_id: blk.id,\n+                block_expr_id: blk.hir_id.local_id,\n                 break_index: expr_exit,\n             });\n \n@@ -104,21 +104,22 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             let expr_exit = self.opt_expr(&blk.expr, stmts_exit);\n \n-            self.add_ast_node(blk.id, &[expr_exit])\n+            self.add_ast_node(blk.hir_id.local_id, &[expr_exit])\n         }\n     }\n \n     fn stmt(&mut self, stmt: &hir::Stmt, pred: CFGIndex) -> CFGIndex {\n+        let hir_id = self.tcx.hir.node_to_hir_id(stmt.node.id());\n         match stmt.node {\n-            hir::StmtDecl(ref decl, id) => {\n+            hir::StmtDecl(ref decl, _) => {\n                 let exit = self.decl(&decl, pred);\n-                self.add_ast_node(id, &[exit])\n+                self.add_ast_node(hir_id.local_id, &[exit])\n             }\n \n-            hir::StmtExpr(ref expr, id) |\n-            hir::StmtSemi(ref expr, id) => {\n+            hir::StmtExpr(ref expr, _) |\n+            hir::StmtSemi(ref expr, _) => {\n                 let exit = self.expr(&expr, pred);\n-                self.add_ast_node(id, &[exit])\n+                self.add_ast_node(hir_id.local_id, &[exit])\n             }\n         }\n     }\n@@ -140,31 +141,31 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             PatKind::Path(_) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n-            PatKind::Wild => self.add_ast_node(pat.id, &[pred]),\n+            PatKind::Wild => self.add_ast_node(pat.hir_id.local_id, &[pred]),\n \n             PatKind::Box(ref subpat) |\n             PatKind::Ref(ref subpat, _) |\n             PatKind::Binding(.., Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n-                self.add_ast_node(pat.id, &[subpat_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[subpat_exit])\n             }\n \n             PatKind::TupleStruct(_, ref subpats, _) |\n             PatKind::Tuple(ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter(), pred);\n-                self.add_ast_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n             PatKind::Struct(_, ref subpats, _) => {\n                 let pats_exit = self.pats_all(subpats.iter().map(|f| &f.node.pat), pred);\n-                self.add_ast_node(pat.id, &[pats_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[pats_exit])\n             }\n \n             PatKind::Slice(ref pre, ref vec, ref post) => {\n                 let pre_exit = self.pats_all(pre.iter(), pred);\n                 let vec_exit = self.pats_all(vec.iter(), pre_exit);\n                 let post_exit = self.pats_all(post.iter(), vec_exit);\n-                self.add_ast_node(pat.id, &[post_exit])\n+                self.add_ast_node(pat.hir_id.local_id, &[post_exit])\n             }\n         }\n     }\n@@ -180,7 +181,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         match expr.node {\n             hir::ExprBlock(ref blk) => {\n                 let blk_exit = self.block(&blk, pred);\n-                self.add_ast_node(expr.id, &[blk_exit])\n+                self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }\n \n             hir::ExprIf(ref cond, ref then, None) => {\n@@ -200,7 +201,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let cond_exit = self.expr(&cond, pred);                // 1\n                 let then_exit = self.expr(&then, cond_exit);          // 2\n-                self.add_ast_node(expr.id, &[cond_exit, then_exit])      // 3,4\n+                self.add_ast_node(expr.hir_id.local_id, &[cond_exit, then_exit])      // 3,4\n             }\n \n             hir::ExprIf(ref cond, ref then, Some(ref otherwise)) => {\n@@ -221,7 +222,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let cond_exit = self.expr(&cond, pred);                // 1\n                 let then_exit = self.expr(&then, cond_exit);          // 2\n                 let else_exit = self.expr(&otherwise, cond_exit);      // 3\n-                self.add_ast_node(expr.id, &[then_exit, else_exit])      // 4, 5\n+                self.add_ast_node(expr.hir_id.local_id, &[then_exit, else_exit])      // 4, 5\n             }\n \n             hir::ExprWhile(ref cond, ref body, _) => {\n@@ -245,12 +246,12 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n \n                 // Create expr_exit without pred (cond_exit)\n-                let expr_exit = self.add_ast_node(expr.id, &[]);         // 3\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);         // 3\n \n                 // The LoopScope needs to be on the loop_scopes stack while evaluating the\n                 // condition and the body of the loop (both can break out of the loop)\n                 self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n+                    loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit\n                 });\n@@ -282,9 +283,9 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 // may cause additional edges.\n \n                 let loopback = self.add_dummy_node(&[pred]);              // 1\n-                let expr_exit = self.add_ast_node(expr.id, &[]);          // 2\n+                let expr_exit = self.add_ast_node(expr.hir_id.local_id, &[]);          // 2\n                 self.loop_scopes.push(LoopScope {\n-                    loop_id: expr.id,\n+                    loop_id: expr.hir_id.local_id,\n                     continue_index: loopback,\n                     break_index: expr_exit,\n                 });\n@@ -295,7 +296,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             hir::ExprMatch(ref discr, ref arms, _) => {\n-                self.match_(expr.id, &discr, &arms, pred)\n+                self.match_(expr.hir_id.local_id, &discr, &arms, pred)\n             }\n \n             hir::ExprBinary(op, ref l, ref r) if op.node.is_lazy() => {\n@@ -315,30 +316,30 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 //\n                 let l_exit = self.expr(&l, pred);                      // 1\n                 let r_exit = self.expr(&r, l_exit);                    // 2\n-                self.add_ast_node(expr.id, &[l_exit, r_exit])            // 3,4\n+                self.add_ast_node(expr.hir_id.local_id, &[l_exit, r_exit])            // 3,4\n             }\n \n             hir::ExprRet(ref v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let b = self.add_ast_node(expr.id, &[v_exit]);\n+                let b = self.add_ast_node(expr.hir_id.local_id, &[v_exit]);\n                 self.add_returning_edge(expr, b);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprBreak(destination, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let (scope_id, break_dest) =\n+                let (target_scope, break_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Break);\n-                let b = self.add_ast_node(expr.id, &[v]);\n-                self.add_exiting_edge(expr, b, scope_id, break_dest);\n+                let b = self.add_ast_node(expr.hir_id.local_id, &[v]);\n+                self.add_exiting_edge(expr, b, target_scope, break_dest);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(destination) => {\n-                let (scope_id, cont_dest) =\n+                let (target_scope, cont_dest) =\n                     self.find_scope_edge(expr, destination, ScopeCfKind::Continue);\n-                let a = self.add_ast_node(expr.id, &[pred]);\n-                self.add_exiting_edge(expr, a, scope_id, cont_dest);\n+                let a = self.add_ast_node(expr.hir_id.local_id, &[pred]);\n+                self.add_exiting_edge(expr, a, target_scope, cont_dest);\n                 self.add_unreachable_node()\n             }\n \n@@ -397,7 +398,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n                 let post_outputs = self.exprs(outputs.iter().map(|e| &*e), pred);\n                 let post_inputs = self.exprs(inputs.iter().map(|e| &*e), post_outputs);\n-                self.add_ast_node(expr.id, &[post_inputs])\n+                self.add_ast_node(expr.hir_id.local_id, &[post_inputs])\n             }\n \n             hir::ExprClosure(..) |\n@@ -444,10 +445,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         //! Handles case of an expression that evaluates `subexprs` in order\n \n         let subexprs_exit = self.exprs(subexprs, pred);\n-        self.add_ast_node(expr.id, &[subexprs_exit])\n+        self.add_ast_node(expr.hir_id.local_id, &[subexprs_exit])\n     }\n \n-    fn match_(&mut self, id: ast::NodeId, discr: &hir::Expr,\n+    fn match_(&mut self, id: hir::ItemLocalId, discr: &hir::Expr,\n               arms: &[hir::Arm], pred: CFGIndex) -> CFGIndex {\n         // The CFG for match expression is quite complex, so no ASCII\n         // art for it (yet).\n@@ -552,8 +553,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         self.add_node(CFGNodeData::Dummy, preds)\n     }\n \n-    fn add_ast_node(&mut self, id: ast::NodeId, preds: &[CFGIndex]) -> CFGIndex {\n-        assert!(id != ast::DUMMY_NODE_ID);\n+    fn add_ast_node(&mut self, id: hir::ItemLocalId, preds: &[CFGIndex]) -> CFGIndex {\n         self.add_node(CFGNodeData::AST(id), preds)\n     }\n \n@@ -579,14 +579,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn add_exiting_edge(&mut self,\n                         from_expr: &hir::Expr,\n                         from_index: CFGIndex,\n-                        scope_id: ast::NodeId,\n+                        target_scope: CodeExtent,\n                         to_index: CFGIndex) {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n         let mut scope = CodeExtent::Misc(from_expr.id);\n-        let target_scope = CodeExtent::Misc(scope_id);\n         let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n-            data.exiting_scopes.push(scope.node_id());\n+            data.exiting_scopes.push(self.tcx.hir.node_to_hir_id(scope.node_id()).local_id);\n             scope = region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n@@ -607,13 +606,13 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn find_scope_edge(&self,\n                   expr: &hir::Expr,\n                   destination: hir::Destination,\n-                  scope_cf_kind: ScopeCfKind) -> (ast::NodeId, CFGIndex) {\n+                  scope_cf_kind: ScopeCfKind) -> (CodeExtent, CFGIndex) {\n \n         match destination.target_id {\n             hir::ScopeTarget::Block(block_expr_id) => {\n                 for b in &self.breakable_block_scopes {\n-                    if b.block_expr_id == block_expr_id {\n-                        return (block_expr_id, match scope_cf_kind {\n+                    if b.block_expr_id == self.tcx.hir.node_to_hir_id(block_expr_id).local_id {\n+                        return (CodeExtent::Misc(block_expr_id), match scope_cf_kind {\n                             ScopeCfKind::Break => b.break_index,\n                             ScopeCfKind::Continue => bug!(\"can't continue to block\"),\n                         });\n@@ -623,8 +622,8 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n             hir::ScopeTarget::Loop(hir::LoopIdResult::Ok(loop_id)) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id {\n-                        return (loop_id, match scope_cf_kind {\n+                    if l.loop_id == self.tcx.hir.node_to_hir_id(loop_id).local_id {\n+                        return (CodeExtent::Misc(loop_id), match scope_cf_kind {\n                             ScopeCfKind::Break => l.break_index,\n                             ScopeCfKind::Continue => l.continue_index,\n                         });"}, {"sha": "fa034744b62e21b2c3b660e66a7e9bcc1ac97c57", "filename": "src/librustc/cfg/graphviz.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fgraphviz.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -15,40 +15,47 @@\n use graphviz as dot;\n use graphviz::IntoCow;\n \n-use syntax::ast;\n-\n-use hir::map as hir_map;\n use cfg;\n+use hir;\n+use ty::TyCtxt;\n \n pub type Node<'a> = (cfg::CFGIndex, &'a cfg::CFGNode);\n pub type Edge<'a> = &'a cfg::CFGEdge;\n \n-pub struct LabelledCFG<'a, 'hir: 'a> {\n-    pub hir_map: &'a hir_map::Map<'hir>,\n+pub struct LabelledCFG<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub cfg: &'a cfg::CFG,\n     pub name: String,\n     /// `labelled_edges` controls whether we emit labels on the edges\n     pub labelled_edges: bool,\n }\n \n-fn replace_newline_with_backslash_l(s: String) -> String {\n-    // Replacing newlines with \\\\l causes each line to be left-aligned,\n-    // improving presentation of (long) pretty-printed expressions.\n-    if s.contains(\"\\n\") {\n-        let mut s = s.replace(\"\\n\", \"\\\\l\");\n-        // Apparently left-alignment applies to the line that precedes\n-        // \\l, not the line that follows; so, add \\l at end of string\n-        // if not already present, ensuring last line gets left-aligned\n-        // as well.\n-        let mut last_two: Vec<_> =\n-            s.chars().rev().take(2).collect();\n-        last_two.reverse();\n-        if last_two != ['\\\\', 'l'] {\n-            s.push_str(\"\\\\l\");\n+impl<'a, 'tcx> LabelledCFG<'a, 'tcx> {\n+    fn local_id_to_string(&self, local_id: hir::ItemLocalId) -> String {\n+        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+            owner: self.tcx.closure_base_def_id(self.cfg.owner_def_id).index,\n+            local_id\n+        });\n+        let s = self.tcx.hir.node_to_string(node_id);\n+\n+        // Replacing newlines with \\\\l causes each line to be left-aligned,\n+        // improving presentation of (long) pretty-printed expressions.\n+        if s.contains(\"\\n\") {\n+            let mut s = s.replace(\"\\n\", \"\\\\l\");\n+            // Apparently left-alignment applies to the line that precedes\n+            // \\l, not the line that follows; so, add \\l at end of string\n+            // if not already present, ensuring last line gets left-aligned\n+            // as well.\n+            let mut last_two: Vec<_> =\n+                s.chars().rev().take(2).collect();\n+            last_two.reverse();\n+            if last_two != ['\\\\', 'l'] {\n+                s.push_str(\"\\\\l\");\n+            }\n+            s\n+        } else {\n+            s\n         }\n-        s\n-    } else {\n-        s\n     }\n }\n \n@@ -66,12 +73,10 @@ impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n             dot::LabelText::LabelStr(\"entry\".into_cow())\n         } else if i == self.cfg.exit {\n             dot::LabelText::LabelStr(\"exit\".into_cow())\n-        } else if n.data.id() == ast::DUMMY_NODE_ID {\n+        } else if n.data.id() == hir::DUMMY_ITEM_LOCAL_ID {\n             dot::LabelText::LabelStr(\"(dummy_node)\".into_cow())\n         } else {\n-            let s = self.hir_map.node_to_string(n.data.id());\n-            // left-aligns the lines\n-            let s = replace_newline_with_backslash_l(s);\n+            let s = self.local_id_to_string(n.data.id());\n             dot::LabelText::EscStr(s.into_cow())\n         }\n     }\n@@ -82,15 +87,13 @@ impl<'a, 'hir> dot::Labeller<'a> for LabelledCFG<'a, 'hir> {\n             return dot::LabelText::EscStr(label.into_cow());\n         }\n         let mut put_one = false;\n-        for (i, &node_id) in e.data.exiting_scopes.iter().enumerate() {\n+        for (i, &id) in e.data.exiting_scopes.iter().enumerate() {\n             if put_one {\n                 label.push_str(\",\\\\l\");\n             } else {\n                 put_one = true;\n             }\n-            let s = self.hir_map.node_to_string(node_id);\n-            // left-aligns the lines\n-            let s = replace_newline_with_backslash_l(s);\n+            let s = self.local_id_to_string(id);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n                                    &s[..]));"}, {"sha": "b379d3956e944b01b399b508ae025241ac12450b", "filename": "src/librustc/cfg/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fmod.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -13,40 +13,41 @@\n \n use rustc_data_structures::graph;\n use ty::TyCtxt;\n-use syntax::ast;\n use hir;\n+use hir::def_id::DefId;\n \n mod construct;\n pub mod graphviz;\n \n pub struct CFG {\n+    pub owner_def_id: DefId,\n     pub graph: CFGGraph,\n     pub entry: CFGIndex,\n     pub exit: CFGIndex,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub enum CFGNodeData {\n-    AST(ast::NodeId),\n+    AST(hir::ItemLocalId),\n     Entry,\n     Exit,\n     Dummy,\n     Unreachable,\n }\n \n impl CFGNodeData {\n-    pub fn id(&self) -> ast::NodeId {\n+    pub fn id(&self) -> hir::ItemLocalId {\n         if let CFGNodeData::AST(id) = *self {\n             id\n         } else {\n-            ast::DUMMY_NODE_ID\n+            hir::DUMMY_ITEM_LOCAL_ID\n         }\n     }\n }\n \n #[derive(Debug)]\n pub struct CFGEdgeData {\n-    pub exiting_scopes: Vec<ast::NodeId>\n+    pub exiting_scopes: Vec<hir::ItemLocalId>\n }\n \n pub type CFGIndex = graph::NodeIndex;\n@@ -63,7 +64,7 @@ impl CFG {\n         construct::construct(tcx, body)\n     }\n \n-    pub fn node_is_reachable(&self, id: ast::NodeId) -> bool {\n+    pub fn node_is_reachable(&self, id: hir::ItemLocalId) -> bool {\n         self.graph.depth_traverse(self.entry, graph::OUTGOING)\n                   .any(|idx| self.graph.node_data(idx).id() == id)\n     }"}, {"sha": "e54df2d50d8ebde88366df3f70c8fbb2f6b50eab", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -26,7 +26,7 @@ use syntax_pos::Span;\n \n use hir::*;\n use hir::print::Nested;\n-use util::nodemap::DefIdMap;\n+use util::nodemap::{DefIdMap, FxHashMap};\n \n use arena::TypedArena;\n use std::cell::RefCell;\n@@ -251,6 +251,9 @@ pub struct Map<'hir> {\n \n     /// Bodies inlined from other crates are cached here.\n     inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n+\n+    /// The reverse mapping of `node_to_hir_id`.\n+    hir_to_node_id: FxHashMap<HirId, NodeId>,\n }\n \n impl<'hir> Map<'hir> {\n@@ -339,6 +342,11 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn hir_to_node_id(&self, hir_id: HirId) -> NodeId {\n+        self.hir_to_node_id[&hir_id]\n+    }\n+\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n         self.definitions.node_to_hir_id(node_id)\n@@ -1021,10 +1029,15 @@ pub fn map_crate<'hir>(forest: &'hir mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n+    // Build the reverse mapping of `node_to_hir_id`.\n+    let hir_to_node_id = definitions.node_to_hir_id.iter_enumerated()\n+        .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n+\n     let map = Map {\n         forest,\n         dep_graph: forest.dep_graph.clone(),\n         map,\n+        hir_to_node_id,\n         definitions,\n         inlined_bodies: RefCell::new(DefIdMap()),\n     };"}, {"sha": "e88678dea1d747d485c0c72af523c2ee58be2f3e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -20,12 +20,11 @@ use ty::TyCtxt;\n use std::io;\n use std::mem;\n use std::usize;\n-use syntax::ast;\n use syntax::print::pprust::PrintState;\n \n use rustc_data_structures::graph::OUTGOING;\n \n-use util::nodemap::NodeMap;\n+use util::nodemap::FxHashMap;\n use hir;\n use hir::intravisit::{self, IdRange};\n use hir::print as pprust;\n@@ -56,7 +55,7 @@ pub struct DataFlowContext<'a, 'tcx: 'a, O> {\n \n     // mapping from node to cfg node index\n     // FIXME (#6298): Shouldn't this go with CFG?\n-    nodeid_to_index: NodeMap<Vec<CFGIndex>>,\n+    local_id_to_index: FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n \n     // Bit sets per cfg node.  The following three fields (`gens`, `kills`,\n     // and `on_entry`) all have the same structure. For each id in\n@@ -97,15 +96,16 @@ struct PropagationContext<'a, 'b: 'a, 'tcx: 'b, O: 'a> {\n     changed: bool\n }\n \n-fn get_cfg_indices<'a>(id: ast::NodeId, index: &'a NodeMap<Vec<CFGIndex>>) -> &'a [CFGIndex] {\n-    let opt_indices = index.get(&id);\n-    opt_indices.map(|v| &v[..]).unwrap_or(&[])\n+fn get_cfg_indices<'a>(id: hir::ItemLocalId,\n+                       index: &'a FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>)\n+                       -> &'a [CFGIndex] {\n+    index.get(&id).map_or(&[], |v| &v[..])\n }\n \n impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n-    fn has_bitset_for_nodeid(&self, n: ast::NodeId) -> bool {\n-        assert!(n != ast::DUMMY_NODE_ID);\n-        self.nodeid_to_index.contains_key(&n)\n+    fn has_bitset_for_local_id(&self, n: hir::ItemLocalId) -> bool {\n+        assert!(n != hir::DUMMY_ITEM_LOCAL_ID);\n+        self.local_id_to_index.contains_key(&n)\n     }\n }\n \n@@ -117,19 +117,20 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n            ps: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n         let id = match node {\n-            pprust::NodeName(_) => ast::CRATE_NODE_ID,\n-            pprust::NodeExpr(expr) => expr.id,\n-            pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) | pprust::NodeSubItem(_) => ast::CRATE_NODE_ID,\n-            pprust::NodePat(pat) => pat.id\n+            pprust::NodeName(_) => return Ok(()),\n+            pprust::NodeExpr(expr) => expr.hir_id.local_id,\n+            pprust::NodeBlock(blk) => blk.hir_id.local_id,\n+            pprust::NodeItem(_) |\n+            pprust::NodeSubItem(_) => return Ok(()),\n+            pprust::NodePat(pat) => pat.hir_id.local_id\n         };\n \n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return Ok(());\n         }\n \n         assert!(self.bits_per_id > 0);\n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let on_entry = &self.on_entry[start.. end];\n@@ -157,17 +158,18 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             };\n \n             ps.synth_comment(\n-                format!(\"id {}: {}{}{}{}\", id, entry_str,\n+                format!(\"id {}: {}{}{}{}\", id.as_usize(), entry_str,\n                         gens_str, action_kills_str, scope_kills_str))?;\n             ps.s.space()?;\n         }\n         Ok(())\n     }\n }\n \n-fn build_nodeid_to_index(body: Option<&hir::Body>,\n-                         cfg: &cfg::CFG) -> NodeMap<Vec<CFGIndex>> {\n-    let mut index = NodeMap();\n+fn build_local_id_to_index(body: Option<&hir::Body>,\n+                           cfg: &cfg::CFG)\n+                           -> FxHashMap<hir::ItemLocalId, Vec<CFGIndex>> {\n+    let mut index = FxHashMap();\n \n     // FIXME (#6298): Would it be better to fold formals from decl\n     // into cfg itself?  i.e. introduce a fn-based flow-graph in\n@@ -188,14 +190,14 @@ fn build_nodeid_to_index(body: Option<&hir::Body>,\n \n     /// Add mappings from the ast nodes for the formal bindings to\n     /// the entry-node in the graph.\n-    fn add_entries_from_fn_body(index: &mut NodeMap<Vec<CFGIndex>>,\n+    fn add_entries_from_fn_body(index: &mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n                                 body: &hir::Body,\n                                 entry: CFGIndex) {\n         use hir::intravisit::Visitor;\n \n         struct Formals<'a> {\n             entry: CFGIndex,\n-            index: &'a mut NodeMap<Vec<CFGIndex>>,\n+            index: &'a mut FxHashMap<hir::ItemLocalId, Vec<CFGIndex>>,\n         }\n         let mut formals = Formals { entry: entry, index: index };\n         for arg in &body.arguments {\n@@ -207,7 +209,7 @@ fn build_nodeid_to_index(body: Option<&hir::Body>,\n             }\n \n             fn visit_pat(&mut self, p: &hir::Pat) {\n-                self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n+                self.index.entry(p.hir_id.local_id).or_insert(vec![]).push(self.entry);\n                 intravisit::walk_pat(self, p)\n             }\n         }\n@@ -259,13 +261,13 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         let kills2 = zeroes;\n         let on_entry = vec![entry; num_nodes * words_per_id];\n \n-        let nodeid_to_index = build_nodeid_to_index(body, cfg);\n+        let local_id_to_index = build_local_id_to_index(body, cfg);\n \n         DataFlowContext {\n             tcx,\n             analysis_name,\n             words_per_id,\n-            nodeid_to_index,\n+            local_id_to_index,\n             bits_per_id,\n             oper,\n             gens,\n@@ -275,29 +277,29 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n     }\n \n-    pub fn add_gen(&mut self, id: ast::NodeId, bit: usize) {\n+    pub fn add_gen(&mut self, id: hir::ItemLocalId, bit: usize) {\n         //! Indicates that `id` generates `bit`\n-        debug!(\"{} add_gen(id={}, bit={})\",\n+        debug!(\"{} add_gen(id={:?}, bit={})\",\n                self.analysis_name, id, bit);\n-        assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.local_id_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let gens = &mut self.gens[start.. end];\n             set_bit(gens, bit);\n         }\n     }\n \n-    pub fn add_kill(&mut self, kind: KillFrom, id: ast::NodeId, bit: usize) {\n+    pub fn add_kill(&mut self, kind: KillFrom, id: hir::ItemLocalId, bit: usize) {\n         //! Indicates that `id` kills `bit`\n-        debug!(\"{} add_kill(id={}, bit={})\",\n+        debug!(\"{} add_kill(id={:?}, bit={})\",\n                self.analysis_name, id, bit);\n-        assert!(self.nodeid_to_index.contains_key(&id));\n+        assert!(self.local_id_to_index.contains_key(&id));\n         assert!(self.bits_per_id > 0);\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let kills = match kind {\n@@ -341,15 +343,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n     }\n \n \n-    pub fn each_bit_on_entry<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n+    pub fn each_bit_on_entry<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n         F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit that is set on entry to `id`.\n         //! Only useful after `propagate()` has been called.\n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return true;\n         }\n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             if !self.each_bit_for_node(EntryOrExit::Entry, cfgidx, |i| f(i)) {\n                 return false;\n@@ -387,11 +389,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         self.each_bit(slice, f)\n     }\n \n-    pub fn each_gen_bit<F>(&self, id: ast::NodeId, mut f: F) -> bool where\n+    pub fn each_gen_bit<F>(&self, id: hir::ItemLocalId, mut f: F) -> bool where\n         F: FnMut(usize) -> bool,\n     {\n         //! Iterates through each bit in the gen set for `id`.\n-        if !self.has_bitset_for_nodeid(id) {\n+        if !self.has_bitset_for_local_id(id) {\n             return true;\n         }\n \n@@ -401,11 +403,11 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             return true;\n         }\n \n-        let indices = get_cfg_indices(id, &self.nodeid_to_index);\n+        let indices = get_cfg_indices(id, &self.local_id_to_index);\n         for &cfgidx in indices {\n             let (start, end) = self.compute_id_range(cfgidx);\n             let gens = &self.gens[start.. end];\n-            debug!(\"{} each_gen_bit(id={}, gens={})\",\n+            debug!(\"{} each_gen_bit(id={:?}, gens={})\",\n                    self.analysis_name, id, bits_to_string(gens));\n             if !self.each_bit(gens, |i| f(i)) {\n                 return false;\n@@ -472,26 +474,26 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             let mut orig_kills = self.scope_kills[start.. end].to_vec();\n \n             let mut changed = false;\n-            for &node_id in &edge.data.exiting_scopes {\n-                let opt_cfg_idx = self.nodeid_to_index.get(&node_id);\n+            for &id in &edge.data.exiting_scopes {\n+                let opt_cfg_idx = self.local_id_to_index.get(&id);\n                 match opt_cfg_idx {\n                     Some(indices) => {\n                         for &cfg_idx in indices {\n                             let (start, end) = self.compute_id_range(cfg_idx);\n                             let kills = &self.scope_kills[start.. end];\n                             if bitwise(&mut orig_kills, kills, &Union) {\n-                                debug!(\"scope exits: scope id={} \\\n+                                debug!(\"scope exits: scope id={:?} \\\n                                         (node={:?} of {:?}) added killset: {}\",\n-                                       node_id, cfg_idx, indices,\n+                                       id, cfg_idx, indices,\n                                        bits_to_string(kills));\n                                 changed = true;\n                             }\n                         }\n                     }\n                     None => {\n                         debug!(\"{} add_kills_from_flow_exits flow_exit={:?} \\\n-                                no cfg_idx for exiting_scope={}\",\n-                               self.analysis_name, flow_exit, node_id);\n+                                no cfg_idx for exiting_scope={:?}\",\n+                               self.analysis_name, flow_exit, id);\n                     }\n                 }\n             }\n@@ -559,7 +561,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         // Iterate over nodes in reverse postorder\n         for &node_index in nodes_po.iter().rev() {\n             let node = cfg.graph.node(node_index);\n-            debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n+            debug!(\"DataFlowContext::walk_cfg idx={:?} id={:?} begin in_out={}\",\n                    node_index, node.data.id(), bits_to_string(in_out));\n \n             let (start, end) = self.dfcx.compute_id_range(node_index);"}, {"sha": "e83c79fb4a414daefa48a8d2acac28ab40f5fbe1", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -103,7 +103,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         debug!(\"consume(consume_id={}, cmt={:?}, mode={:?})\",\n                consume_id, cmt, mode);\n \n-        self.consume_common(consume_id, consume_span, cmt, mode);\n+        let hir_id = self.tcx().hir.node_to_hir_id(consume_id);\n+        self.consume_common(hir_id.local_id, consume_span, cmt, mode);\n     }\n \n     fn matched_pat(&mut self,\n@@ -120,7 +121,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                cmt,\n                mode);\n \n-        self.consume_common(consume_pat.id, consume_pat.span, cmt, mode);\n+        self.consume_common(consume_pat.hir_id.local_id, consume_pat.span, cmt, mode);\n     }\n \n     fn borrow(&mut self,\n@@ -136,15 +137,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                borrow_id, cmt, loan_region,\n                bk, loan_cause);\n \n+        let hir_id = self.tcx().hir.node_to_hir_id(borrow_id);\n         if let Some(lp) = opt_loan_path(&cmt) {\n             let moved_value_use_kind = match loan_cause {\n                 euv::ClosureCapture(_) => MovedInCapture,\n                 _ => MovedInUse,\n             };\n-            self.check_if_path_is_moved(borrow_id, borrow_span, moved_value_use_kind, &lp);\n+            self.check_if_path_is_moved(hir_id.local_id, borrow_span, moved_value_use_kind, &lp);\n         }\n \n-        self.check_for_conflicting_loans(borrow_id);\n+        self.check_for_conflicting_loans(hir_id.local_id);\n     }\n \n     fn mutate(&mut self,\n@@ -163,7 +165,8 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // have to be *FULLY* initialized, but we still\n                     // must be careful lest it contains derefs of\n                     // pointers.\n-                    self.check_if_assigned_path_is_moved(assignee_cmt.id,\n+                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n+                    self.check_if_assigned_path_is_moved(hir_id.local_id,\n                                                          assignment_span,\n                                                          MovedInUse,\n                                                          &lp);\n@@ -172,14 +175,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n                     // In a case like `path += 1`, then path must be\n                     // fully initialized, since we will read it before\n                     // we write it.\n-                    self.check_if_path_is_moved(assignee_cmt.id,\n+                    let hir_id = self.tcx().hir.node_to_hir_id(assignee_cmt.id);\n+                    self.check_if_path_is_moved(hir_id.local_id,\n                                                 assignment_span,\n                                                 MovedInUse,\n                                                 &lp);\n                 }\n             }\n         }\n-        self.check_assignment(assignment_id, assignment_span, assignee_cmt);\n+        self.check_assignment(self.tcx().hir.node_to_hir_id(assignment_id).local_id,\n+                              assignment_span, assignee_cmt);\n     }\n \n     fn decl_without_init(&mut self, _id: ast::NodeId, _span: Span) { }\n@@ -220,7 +225,7 @@ fn compatible_borrow_kinds(borrow_kind1: ty::BorrowKind,\n impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.bccx.tcx }\n \n-    pub fn each_issued_loan<F>(&self, node: ast::NodeId, mut op: F) -> bool where\n+    pub fn each_issued_loan<F>(&self, node: hir::ItemLocalId, mut op: F) -> bool where\n         F: FnMut(&Loan<'tcx>) -> bool,\n     {\n         //! Iterates over each loan that has been issued\n@@ -241,7 +246,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        self.each_issued_loan(scope.node_id(), |loan| {\n+        self.each_issued_loan(self.tcx().hir.node_to_hir_id(scope.node_id()).local_id, |loan| {\n             if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n@@ -325,7 +330,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return true;\n     }\n \n-    pub fn loans_generated_by(&self, node: ast::NodeId) -> Vec<usize> {\n+    pub fn loans_generated_by(&self, node: hir::ItemLocalId) -> Vec<usize> {\n         //! Returns a vector of the loans that are generated as\n         //! we enter `node`.\n \n@@ -337,7 +342,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         return result;\n     }\n \n-    pub fn check_for_conflicting_loans(&self, node: ast::NodeId) {\n+    pub fn check_for_conflicting_loans(&self, node: hir::ItemLocalId) {\n         //! Checks to see whether any of the loans that are issued\n         //! on entrance to `node` conflict with loans that have already been\n         //! issued when we enter `node` (for example, we do not\n@@ -590,7 +595,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn consume_common(&self,\n-                      id: ast::NodeId,\n+                      id: hir::ItemLocalId,\n                       span: Span,\n                       cmt: mc::cmt<'tcx>,\n                       mode: euv::ConsumeMode) {\n@@ -628,7 +633,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_for_copy_of_frozen_path(&self,\n-                                     id: ast::NodeId,\n+                                     id: hir::ItemLocalId,\n                                      span: Span,\n                                      copy_path: &LoanPath<'tcx>) {\n         match self.analyze_restrictions_on_use(id, copy_path, ty::ImmBorrow) {\n@@ -649,7 +654,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_for_move_of_borrowed_path(&self,\n-                                       id: ast::NodeId,\n+                                       id: hir::ItemLocalId,\n                                        span: Span,\n                                        move_path: &LoanPath<'tcx>,\n                                        move_kind: move_data::MoveKind) {\n@@ -699,18 +704,21 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     pub fn analyze_restrictions_on_use(&self,\n-                                       expr_id: ast::NodeId,\n+                                       expr_id: hir::ItemLocalId,\n                                        use_path: &LoanPath<'tcx>,\n                                        borrow_kind: ty::BorrowKind)\n                                        -> UseError<'tcx> {\n-        debug!(\"analyze_restrictions_on_use(expr_id={}, use_path={:?})\",\n-               self.tcx().hir.node_to_string(expr_id),\n-               use_path);\n+        debug!(\"analyze_restrictions_on_use(expr_id={:?}, use_path={:?})\",\n+               expr_id, use_path);\n \n         let mut ret = UseOk;\n \n+        let node_id = self.tcx().hir.hir_to_node_id(hir::HirId {\n+            owner: self.tcx().closure_base_def_id(self.bccx.owner_def_id).index,\n+            local_id: expr_id\n+        });\n         self.each_in_scope_loan_affecting_path(\n-            region::CodeExtent::Misc(expr_id), use_path, |loan| {\n+            region::CodeExtent::Misc(node_id), use_path, |loan| {\n             if !compatible_borrow_kinds(loan.kind, borrow_kind) {\n                 ret = UseWhileBorrowed(loan.loan_path.clone(), loan.span);\n                 false\n@@ -725,11 +733,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// Reports an error if `expr` (which should be a path)\n     /// is using a moved/uninitialized value\n     fn check_if_path_is_moved(&self,\n-                              id: ast::NodeId,\n+                              id: hir::ItemLocalId,\n                               span: Span,\n                               use_kind: MovedValueUseKind,\n                               lp: &Rc<LoanPath<'tcx>>) {\n-        debug!(\"check_if_path_is_moved(id={}, use_kind={:?}, lp={:?})\",\n+        debug!(\"check_if_path_is_moved(id={:?}, use_kind={:?}, lp={:?})\",\n                id, use_kind, lp);\n \n         // FIXME (22079): if you find yourself tempted to cut and paste\n@@ -772,7 +780,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     /// (*p).x = 22; // not ok, p is uninitialized, can't deref\n     /// ```\n     fn check_if_assigned_path_is_moved(&self,\n-                                       id: ast::NodeId,\n+                                       id: hir::ItemLocalId,\n                                        span: Span,\n                                        use_kind: MovedValueUseKind,\n                                        lp: &Rc<LoanPath<'tcx>>)\n@@ -822,14 +830,18 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n     }\n \n     fn check_assignment(&self,\n-                        assignment_id: ast::NodeId,\n+                        assignment_id: hir::ItemLocalId,\n                         assignment_span: Span,\n                         assignee_cmt: mc::cmt<'tcx>) {\n         debug!(\"check_assignment(assignee_cmt={:?})\", assignee_cmt);\n \n         // Check that we don't invalidate any outstanding loans\n         if let Some(loan_path) = opt_loan_path(&assignee_cmt) {\n-            let scope = region::CodeExtent::Misc(assignment_id);\n+            let node_id = self.tcx().hir.hir_to_node_id(hir::HirId {\n+                owner: self.tcx().closure_base_def_id(self.bccx.owner_def_id).index,\n+                local_id: assignment_id\n+            });\n+            let scope = region::CodeExtent::Misc(node_id);\n             self.each_in_scope_loan_affecting_path(scope, &loan_path, |loan| {\n                 self.report_illegal_mutation(assignment_span, &loan_path, loan);\n                 false"}, {"sha": "465457f5ab39a56a01e54412945bf2969d32c73a", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -27,7 +27,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::*;\n \n struct GatherMoveInfo<'tcx> {\n-    id: ast::NodeId,\n+    id: hir::ItemLocalId,\n     kind: MoveKind,\n     cmt: mc::cmt<'tcx>,\n     span_path_opt: Option<MovePlace<'tcx>>\n@@ -79,13 +79,14 @@ pub fn gather_decl<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                              var_id: ast::NodeId,\n                              var_ty: Ty<'tcx>) {\n     let loan_path = Rc::new(LoanPath::new(LpVar(var_id), var_ty));\n-    move_data.add_move(bccx.tcx, loan_path, var_id, Declared);\n+    let hir_id = bccx.tcx.hir.node_to_hir_id(var_id);\n+    move_data.add_move(bccx.tcx, loan_path, hir_id.local_id, Declared);\n }\n \n pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                        move_data: &MoveData<'tcx>,\n                                        move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                       move_expr_id: ast::NodeId,\n+                                       move_expr_id: hir::ItemLocalId,\n                                        cmt: mc::cmt<'tcx>,\n                                        move_reason: euv::MoveReason) {\n     let kind = match move_reason {\n@@ -118,7 +119,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         _ => None,\n     };\n     let move_info = GatherMoveInfo {\n-        id: move_pat.id,\n+        id: move_pat.hir_id.local_id,\n         kind: MovePat,\n         cmt,\n         span_path_opt: pat_span_path_opt,\n@@ -135,7 +136,7 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                          move_data: &MoveData<'tcx>,\n                          move_error_collector: &mut MoveErrorCollector<'tcx>,\n                          move_info: GatherMoveInfo<'tcx>) {\n-    debug!(\"gather_move(move_id={}, cmt={:?})\",\n+    debug!(\"gather_move(move_id={:?}, cmt={:?})\",\n            move_info.id, move_info.cmt);\n \n     let potentially_illegal_move =\n@@ -161,10 +162,10 @@ fn gather_move<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n pub fn gather_assignment<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                    move_data: &MoveData<'tcx>,\n-                                   assignment_id: ast::NodeId,\n+                                   assignment_id: hir::ItemLocalId,\n                                    assignment_span: Span,\n                                    assignee_loan_path: Rc<LoanPath<'tcx>>,\n-                                   assignee_id: ast::NodeId,\n+                                   assignee_id: hir::ItemLocalId,\n                                    mode: euv::MutateMode) {\n     move_data.add_assignment(bccx.tcx,\n                              assignee_loan_path,"}, {"sha": "e14edc43904eac7813b3c79dac14b8983eab433f", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -44,7 +44,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         bccx,\n         all_loans: Vec::new(),\n         item_ub: region::CodeExtent::Misc(body.node_id),\n-        move_data: MoveData::new(),\n+        move_data: MoveData::default(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n@@ -79,7 +79,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n             euv::Move(move_reason) => {\n                 gather_moves::gather_move_from_expr(\n                     self.bccx, &self.move_data, &mut self.move_error_collector,\n-                    consume_id, cmt, move_reason);\n+                    self.bccx.tcx.hir.node_to_hir_id(consume_id).local_id, cmt, move_reason);\n             }\n             euv::Copy => { }\n         }\n@@ -272,8 +272,12 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     self.mark_loan_path_as_mutated(&lp);\n                 }\n                 gather_moves::gather_assignment(self.bccx, &self.move_data,\n-                                                assignment_id, assignment_span,\n-                                                lp, cmt.id, mode);\n+                                                self.bccx.tcx.hir.node_to_hir_id(assignment_id)\n+                                                    .local_id,\n+                                                assignment_span,\n+                                                lp,\n+                                                self.bccx.tcx.hir.node_to_hir_id(cmt.id).local_id,\n+                                                mode);\n             }\n             None => {\n                 // This can occur with e.g. `*foo() = 5`.  In such"}, {"sha": "0b62da306db47f3febe02cc85b8e8094a7adbbfc", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -167,9 +167,11 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n                              id_range,\n                              all_loans.len());\n     for (loan_idx, loan) in all_loans.iter().enumerate() {\n-        loan_dfcx.add_gen(loan.gen_scope.node_id(), loan_idx);\n+        loan_dfcx.add_gen(this.tcx.hir.node_to_hir_id(loan.gen_scope.node_id()).local_id,\n+                          loan_idx);\n         loan_dfcx.add_kill(KillFrom::ScopeEnd,\n-                           loan.kill_scope.node_id(), loan_idx);\n+                           this.tcx.hir.node_to_hir_id(loan.kill_scope.node_id()).local_id,\n+                           loan_idx);\n     }\n     loan_dfcx.add_kills_from_flow_exits(cfg);\n     loan_dfcx.propagate(cfg, this.body);\n@@ -640,19 +642,22 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         // Get type of value and span where it was previously\n         // moved.\n+        let node_id = self.tcx.hir.hir_to_node_id(hir::HirId {\n+            owner: self.tcx.closure_base_def_id(self.owner_def_id).index,\n+            local_id: the_move.id\n+        });\n         let (move_span, move_note) = match the_move.kind {\n             move_data::Declared => {\n                 unreachable!();\n             }\n \n             move_data::MoveExpr |\n-            move_data::MovePat =>\n-                (self.tcx.hir.span(the_move.id), \"\"),\n+            move_data::MovePat => (self.tcx.hir.span(node_id), \"\"),\n \n             move_data::Captured =>\n-                (match self.tcx.hir.expect_expr(the_move.id).node {\n+                (match self.tcx.hir.expect_expr(node_id).node {\n                     hir::ExprClosure(.., fn_decl_span, _) => fn_decl_span,\n-                    ref r => bug!(\"Captured({}) maps to non-closure: {:?}\",\n+                    ref r => bug!(\"Captured({:?}) maps to non-closure: {:?}\",\n                                   the_move.id, r),\n                 }, \" (into closure)\"),\n         };"}, {"sha": "79a4a4f9f4d5b02d2a2bdf61effa47c460da33bb", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -23,16 +23,16 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::nodemap::{FxHashMap, NodeSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n use std::usize;\n-use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::intravisit::IdRange;\n \n+#[derive(Default)]\n pub struct MoveData<'tcx> {\n     /// Move paths. See section \"Move paths\" in `README.md`.\n     pub paths: RefCell<Vec<MovePath<'tcx>>>,\n@@ -54,7 +54,7 @@ pub struct MoveData<'tcx> {\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n-    pub assignee_ids: RefCell<NodeSet>,\n+    pub assignee_ids: RefCell<FxHashSet<hir::ItemLocalId>>,\n }\n \n pub struct FlowedMoveData<'a, 'tcx: 'a> {\n@@ -133,7 +133,7 @@ pub struct Move {\n     pub path: MovePathIndex,\n \n     /// id of node that is doing the move.\n-    pub id: ast::NodeId,\n+    pub id: hir::ItemLocalId,\n \n     /// Kind of move, for error messages.\n     pub kind: MoveKind,\n@@ -148,13 +148,13 @@ pub struct Assignment {\n     pub path: MovePathIndex,\n \n     /// id where assignment occurs\n-    pub id: ast::NodeId,\n+    pub id: hir::ItemLocalId,\n \n     /// span of node where assignment occurs\n     pub span: Span,\n \n     /// id for l-value expression on lhs of assignment\n-    pub assignee_id: ast::NodeId,\n+    pub assignee_id: hir::ItemLocalId,\n }\n \n #[derive(Clone, Copy)]\n@@ -189,17 +189,6 @@ fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n }\n \n impl<'a, 'tcx> MoveData<'tcx> {\n-    pub fn new() -> MoveData<'tcx> {\n-        MoveData {\n-            paths: RefCell::new(Vec::new()),\n-            path_map: RefCell::new(FxHashMap()),\n-            moves: RefCell::new(Vec::new()),\n-            path_assignments: RefCell::new(Vec::new()),\n-            var_assignments: RefCell::new(Vec::new()),\n-            assignee_ids: RefCell::new(NodeSet()),\n-        }\n-    }\n-\n     /// return true if there are no trackable assignments or moves\n     /// in this move data - that means that there is nothing that\n     /// could cause a borrow error.\n@@ -345,7 +334,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Adds a new move entry for a move of `lp` that occurs at location `id` with kind `kind`.\n     pub fn add_move(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     orig_lp: Rc<LoanPath<'tcx>>,\n-                    id: ast::NodeId,\n+                    id: hir::ItemLocalId,\n                     kind: MoveKind) {\n         // Moving one union field automatically moves all its fields. Also move siblings of\n         // all parent union fields, moves do not propagate upwards automatically.\n@@ -373,9 +362,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn add_move_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        lp: Rc<LoanPath<'tcx>>,\n-                       id: ast::NodeId,\n+                       id: hir::ItemLocalId,\n                        kind: MoveKind) {\n-        debug!(\"add_move(lp={:?}, id={}, kind={:?})\",\n+        debug!(\"add_move(lp={:?}, id={:?}, kind={:?})\",\n                lp,\n                id,\n                kind);\n@@ -398,9 +387,9 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// `span`.\n     pub fn add_assignment(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           lp: Rc<LoanPath<'tcx>>,\n-                          assign_id: ast::NodeId,\n+                          assign_id: hir::ItemLocalId,\n                           span: Span,\n-                          assignee_id: ast::NodeId,\n+                          assignee_id: hir::ItemLocalId,\n                           mode: euv::MutateMode) {\n         // Assigning to one union field automatically assigns to all its fields.\n         if let LpExtend(ref base_lp, mutbl, LpInterior(opt_variant_id, interior)) = lp.kind {\n@@ -429,11 +418,11 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn add_assignment_helper(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              lp: Rc<LoanPath<'tcx>>,\n-                             assign_id: ast::NodeId,\n+                             assign_id: hir::ItemLocalId,\n                              span: Span,\n-                             assignee_id: ast::NodeId,\n+                             assignee_id: hir::ItemLocalId,\n                              mode: euv::MutateMode) {\n-        debug!(\"add_assignment(lp={:?}, assign_id={}, assignee_id={}\",\n+        debug!(\"add_assignment(lp={:?}, assign_id={:?}, assignee_id={:?}\",\n                lp, assign_id, assignee_id);\n \n         let path_index = self.move_path(tcx, lp.clone());\n@@ -496,7 +485,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(bccx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n-                    self.kill_moves(path, kill_scope.node_id(),\n+                    self.kill_moves(path,\n+                                    bccx.tcx.hir.node_to_hir_id(kill_scope.node_id()).local_id,\n                                     KillFrom::ScopeEnd, dfcx_moves);\n                 }\n                 LpExtend(..) => {}\n@@ -511,7 +501,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = lp.kill_scope(bccx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n-                                         kill_scope.node_id(),\n+                                         bccx.tcx.hir.node_to_hir_id(kill_scope.node_id())\n+                                            .local_id,\n                                          assignment_index);\n                 }\n                 LpExtend(..) => {\n@@ -579,7 +570,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n     fn kill_moves(&self,\n                   path: MovePathIndex,\n-                  kill_id: ast::NodeId,\n+                  kill_id: hir::ItemLocalId,\n                   kill_kind: KillFrom,\n                   dfcx_moves: &mut MoveDataFlow) {\n         // We can only perform kills for paths that refer to a unique location,\n@@ -589,7 +580,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         let loan_path = self.path_loan_path(path);\n         if loan_path_is_precise(&loan_path) {\n             self.each_applicable_move(path, |move_index| {\n-                debug!(\"kill_moves add_kill {:?} kill_id={} move_index={}\",\n+                debug!(\"kill_moves add_kill {:?} kill_id={:?} move_index={}\",\n                        kill_kind, kill_id, move_index.get());\n                 dfcx_moves.add_kill(kill_kind, kill_id, move_index.get());\n                 true\n@@ -642,7 +633,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     }\n \n     pub fn kind_of_move_of_path(&self,\n-                                id: ast::NodeId,\n+                                id: hir::ItemLocalId,\n                                 loan_path: &Rc<LoanPath<'tcx>>)\n                                 -> Option<MoveKind> {\n         //! Returns the kind of a move of `loan_path` by `id`, if one exists.\n@@ -667,7 +658,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// have occurred on entry to `id` without an intervening assignment. In other words, any moves\n     /// that would invalidate a reference to `loan_path` at location `id`.\n     pub fn each_move_of<F>(&self,\n-                           id: ast::NodeId,\n+                           id: hir::ItemLocalId,\n                            loan_path: &Rc<LoanPath<'tcx>>,\n                            mut f: F)\n                            -> bool where\n@@ -724,7 +715,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     /// Iterates through every assignment to `loan_path` that may have occurred on entry to `id`.\n     /// `loan_path` must be a single variable.\n     pub fn each_assignment_of<F>(&self,\n-                                 id: ast::NodeId,\n+                                 id: hir::ItemLocalId,\n                                  loan_path: &Rc<LoanPath<'tcx>>,\n                                  mut f: F)\n                                  -> bool where"}, {"sha": "22867ba5b55a4ae779ebef38fa6469abc5e90ed0", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -52,7 +52,7 @@ pub struct DataflowLabeller<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n     fn dataflow_for(&self, e: EntryOrExit, n: &Node<'a>) -> String {\n         let id = n.1.data.id();\n-        debug!(\"dataflow_for({:?}, id={}) {:?}\", e, id, self.variants);\n+        debug!(\"dataflow_for({:?}, id={:?}) {:?}\", e, id, self.variants);\n         let mut sets = \"\".to_string();\n         let mut seen_one = false;\n         for &variant in &self.variants {"}, {"sha": "6a58b7fb75360ba040058d142624c99bce0168e0", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -765,7 +765,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n     let cfg = cfg::CFG::new(tcx, &body);\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n-        hir_map: &tcx.hir,\n+        tcx,\n         cfg: &cfg,\n         name: format!(\"node_{}\", code.id()),\n         labelled_edges,"}, {"sha": "0fe30dcabb00de89dca3b5ef48984b79b1c1f552", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ddd7a4ef30a89091dbf48cae18f571326510fb/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=28ddd7a4ef30a89091dbf48cae18f571326510fb", "patch": "@@ -850,23 +850,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             }\n             visited.insert(cfg_id);\n \n-            let node_id = cfg.graph.node_data(idx).id();\n-\n             // is this a recursive call?\n-            let self_recursive = if node_id != ast::DUMMY_NODE_ID {\n-                match method {\n+            let local_id = cfg.graph.node_data(idx).id();\n+            if local_id != hir::DUMMY_ITEM_LOCAL_ID {\n+                let node_id = cx.tcx.hir.hir_to_node_id(hir::HirId {\n+                    owner: cx.tcx.closure_base_def_id(cfg.owner_def_id).index,\n+                    local_id\n+                });\n+                let self_recursive = match method {\n                     Some(ref method) => expr_refers_to_this_method(cx, method, node_id),\n                     None => expr_refers_to_this_fn(cx, id, node_id),\n+                };\n+                if self_recursive {\n+                    self_call_spans.push(cx.tcx.hir.span(node_id));\n+                    // this is a self call, so we shouldn't explore past\n+                    // this node in the CFG.\n+                    continue;\n                 }\n-            } else {\n-                false\n-            };\n-            if self_recursive {\n-                self_call_spans.push(cx.tcx.hir.span(node_id));\n-                // this is a self call, so we shouldn't explore past\n-                // this node in the CFG.\n-                continue;\n             }\n+\n             // add the successors of this node to explore the graph further.\n             for (_, edge) in cfg.graph.outgoing_edges(idx) {\n                 let target_idx = edge.target();"}]}