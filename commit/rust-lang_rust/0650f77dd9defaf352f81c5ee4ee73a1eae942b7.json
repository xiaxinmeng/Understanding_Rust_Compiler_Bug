{"sha": "0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NTBmNzdkZDlkZWZhZjM1MmY4MWM1ZWU0ZWU3M2ExZWFlOTQyYjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-10T16:04:41Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-14T13:19:27Z"}, "message": "internal: remove one more immutable tree", "tree": {"sha": "4758b6ea999292cf18a078dd942f51621a2d68ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4758b6ea999292cf18a078dd942f51621a2d68ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "html_url": "https://github.com/rust-lang/rust/commit/0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab528e85f71da188722ae031b31a3a70bac1cadd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab528e85f71da188722ae031b31a3a70bac1cadd", "html_url": "https://github.com/rust-lang/rust/commit/ab528e85f71da188722ae031b31a3a70bac1cadd"}], "stats": {"total": 113, "additions": 57, "deletions": 56}, "files": [{"sha": "a19b8339c8bf3903f5fca62d804d415c1ab1f254", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -1295,9 +1295,9 @@ checksum = \"f497285884f3fcff424ffc933e56d7cbca511def0c9831a7f9b5f6153e3cc89b\"\n \n [[package]]\n name = \"rowan\"\n-version = \"0.13.0-pre.5\"\n+version = \"0.13.0-pre.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"32a5fc82ed0b7e7fba157331f0d8f64abd73bced6e7ac2a4dfa0c4cf0ab584e8\"\n+checksum = \"82ccc04e145e9a5ab51b9c12a81d77c4a8250d87a407ab02ac650451141ff00d\"\n dependencies = [\n  \"countme\",\n  \"hashbrown\","}, {"sha": "475ef99b57331677c5573f6bc23d5ac096bdb206", "filename": "crates/ide_db/src/helpers/merge_imports.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fmerge_imports.rs?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -2,8 +2,9 @@\n use std::cmp::Ordering;\n \n use itertools::{EitherOrBoth, Itertools};\n-use syntax::ast::{\n-    self, edit::AstNodeEdit, make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner,\n+use syntax::{\n+    ast::{self, make, AstNode, AttrsOwner, PathSegmentKind, VisibilityOwner},\n+    ted,\n };\n \n /// What type of merges are allowed.\n@@ -65,7 +66,7 @@ pub fn try_merge_trees(\n     } else {\n         (lhs.split_prefix(&lhs_prefix), rhs.split_prefix(&rhs_prefix))\n     };\n-    recursive_merge(&lhs, &rhs, merge)\n+    recursive_merge(&lhs, &rhs, merge).map(|it| it.clone_for_update())\n }\n \n /// Recursively \"zips\" together lhs and rhs.\n@@ -78,7 +79,8 @@ fn recursive_merge(\n         .use_tree_list()\n         .into_iter()\n         .flat_map(|list| list.use_trees())\n-        // we use Option here to early return from this function(this is not the same as a `filter` op)\n+        // We use Option here to early return from this function(this is not the\n+        // same as a `filter` op).\n         .map(|tree| match merge.is_tree_allowed(&tree) {\n             true => Some(tree),\n             false => None,\n@@ -111,8 +113,10 @@ fn recursive_merge(\n                     let tree_is_self = |tree: ast::UseTree| {\n                         tree.path().as_ref().map(path_is_self).unwrap_or(false)\n                     };\n-                    // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n-                    // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n+                    // Check if only one of the two trees has a tree list, and\n+                    // whether that then contains `self` or not. If this is the\n+                    // case we can skip this iteration since the path without\n+                    // the list is already included in the other one via `self`.\n                     let tree_contains_self = |tree: &ast::UseTree| {\n                         tree.use_tree_list()\n                             .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n@@ -127,9 +131,11 @@ fn recursive_merge(\n                         _ => (),\n                     }\n \n-                    // glob imports arent part of the use-tree lists so we need to special handle them here as well\n-                    // this special handling is only required for when we merge a module import into a glob import of said module\n-                    // see the `merge_self_glob` or `merge_mod_into_glob` tests\n+                    // Glob imports aren't part of the use-tree lists so we need\n+                    // to special handle them here as well this special handling\n+                    // is only required for when we merge a module import into a\n+                    // glob import of said module see the `merge_self_glob` or\n+                    // `merge_mod_into_glob` tests.\n                     if lhs_t.star_token().is_some() || rhs_t.star_token().is_some() {\n                         *lhs_t = make::use_tree(\n                             make::path_unqualified(make::path_segment_self()),\n@@ -165,11 +171,11 @@ fn recursive_merge(\n         }\n     }\n \n-    Some(if let Some(old) = lhs.use_tree_list() {\n-        lhs.replace_descendant(old, make::use_tree_list(use_trees)).clone_for_update()\n-    } else {\n-        lhs.clone()\n-    })\n+    let lhs = lhs.clone_subtree().clone_for_update();\n+    if let Some(old) = lhs.use_tree_list() {\n+        ted::replace(old.syntax(), make::use_tree_list(use_trees).syntax().clone_for_update());\n+    }\n+    ast::UseTree::cast(lhs.syntax().clone_subtree())\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both."}, {"sha": "747f0b9eb1c5b12ee1844e5fc51a12f0abe049b5", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -13,7 +13,7 @@ doctest = false\n [dependencies]\n cov-mark = { version = \"1.1\", features = [\"thread-local\"] }\n itertools = \"0.10.0\"\n-rowan = \"=0.13.0-pre.5\"\n+rowan = \"=0.13.0-pre.6\"\n rustc_lexer = { version = \"716.0.0\", package = \"rustc-ap-rustc_lexer\" }\n rustc-hash = \"1.1.0\"\n arrayvec = \"0.7\""}, {"sha": "825ea318589741b2e717811d75595cdbf35c4615", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 4, "deletions": 31, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -337,7 +337,7 @@ enum InsertPos {\n }\n \n #[derive(Default)]\n-pub struct SyntaxRewriter<'a> {\n+pub(crate) struct SyntaxRewriter<'a> {\n     //FIXME: add debug_assertions that all elements are in fact from the same file.\n     replacements: FxHashMap<SyntaxElement, Replacement>,\n     insertions: IndexMap<InsertPos, Vec<SyntaxElement>>,\n@@ -354,13 +354,13 @@ impl fmt::Debug for SyntaxRewriter<'_> {\n }\n \n impl SyntaxRewriter<'_> {\n-    pub fn replace<T: Clone + Into<SyntaxElement>>(&mut self, what: &T, with: &T) {\n+    pub(crate) fn replace<T: Clone + Into<SyntaxElement>>(&mut self, what: &T, with: &T) {\n         let what = what.clone().into();\n         let replacement = Replacement::Single(with.clone().into());\n         self.replacements.insert(what, replacement);\n     }\n \n-    pub fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n+    pub(crate) fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n         let _p = profile::span(\"rewrite\");\n \n         if self.replacements.is_empty() && self.insertions.is_empty() {\n@@ -370,37 +370,10 @@ impl SyntaxRewriter<'_> {\n         with_green(node, green)\n     }\n \n-    pub fn rewrite_ast<N: AstNode>(self, node: &N) -> N {\n+    pub(crate) fn rewrite_ast<N: AstNode>(self, node: &N) -> N {\n         N::cast(self.rewrite(node.syntax())).unwrap()\n     }\n \n-    /// Returns a node that encompasses all replacements to be done by this rewriter.\n-    ///\n-    /// Passing the returned node to `rewrite` will apply all replacements queued up in `self`.\n-    ///\n-    /// Returns `None` when there are no replacements.\n-    pub fn rewrite_root(&self) -> Option<SyntaxNode> {\n-        let _p = profile::span(\"rewrite_root\");\n-        fn element_to_node_or_parent(element: &SyntaxElement) -> Option<SyntaxNode> {\n-            match element {\n-                SyntaxElement::Node(it) => Some(it.clone()),\n-                SyntaxElement::Token(it) => it.parent(),\n-            }\n-        }\n-\n-        self.replacements\n-            .keys()\n-            .filter_map(element_to_node_or_parent)\n-            .chain(self.insertions.keys().filter_map(|pos| match pos {\n-                InsertPos::FirstChildOf(it) => Some(it.clone()),\n-                InsertPos::After(it) => element_to_node_or_parent(it),\n-            }))\n-            // If we only have one replacement/insertion, we must return its parent node, since `rewrite` does\n-            // not replace the node passed to it.\n-            .map(|it| it.parent().unwrap_or(it))\n-            .fold1(|a, b| least_common_ancestor(&a, &b).unwrap())\n-    }\n-\n     fn replacement(&self, element: &SyntaxElement) -> Option<Replacement> {\n         self.replacements.get(element).cloned()\n     }"}, {"sha": "a8071b51d2f8a42acb60640a381405054657f74d", "filename": "crates/syntax/src/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast.rs?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -47,6 +47,12 @@ pub trait AstNode {\n     {\n         Self::cast(self.syntax().clone_for_update()).unwrap()\n     }\n+    fn clone_subtree(&self) -> Self\n+    where\n+        Self: Sized,\n+    {\n+        Self::cast(self.syntax().clone_subtree()).unwrap()\n+    }\n }\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes."}, {"sha": "de04c8620a62e9c3c476f4f58bbbfc7ebeb46334", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -12,7 +12,7 @@\n use itertools::Itertools;\n use stdx::{format_to, never};\n \n-use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, SyntaxToken};\n+use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxToken};\n \n /// While the parent module defines basic atomic \"constructors\", the `ext`\n /// module defines shortcuts for common things.\n@@ -601,17 +601,11 @@ fn ast_from_text<N: AstNode>(text: &str) -> N {\n             panic!(\"Failed to make ast node `{}` from text {}\", std::any::type_name::<N>(), text)\n         }\n     };\n-    let node = node.syntax().clone();\n-    let node = unroot(node);\n-    let node = N::cast(node).unwrap();\n+    let node = node.clone_subtree();\n     assert_eq!(node.syntax().text_range().start(), 0.into());\n     node\n }\n \n-fn unroot(n: SyntaxNode) -> SyntaxNode {\n-    SyntaxNode::new_root(n.green().into())\n-}\n-\n pub fn token(kind: SyntaxKind) -> SyntaxToken {\n     tokens::SOURCE_FILE\n         .tree()"}, {"sha": "f22b697681485a5ed3969a769205079b182a1a54", "filename": "docs/dev/style.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/0650f77dd9defaf352f81c5ee4ee73a1eae942b7/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=0650f77dd9defaf352f81c5ee4ee73a1eae942b7", "patch": "@@ -951,6 +951,28 @@ match p.current() {\n \n ## Documentation\n \n+Style inline code comments as proper sentences.\n+Start with a capital letter, end with a dot.\n+\n+```rust\n+// GOOD\n+\n+// Only simple single segment paths are allowed.\n+MergeBehavior::Last => {\n+    tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n+}\n+\n+// BAD\n+\n+// only simple single segment paths are allowed\n+MergeBehavior::Last => {\n+    tree.use_tree_list().is_none() && tree.path().map(path_len) <= Some(1)\n+}\n+```\n+\n+**Rationale:** writing a sentence (or maybe even a paragraph) rather just \"a comment\" creates a more appropriate frame of mind.\n+It tricks you into writing down more of the context you keep in your head while coding.\n+\n For `.md` and `.adoc` files, prefer a sentence-per-line format, don't wrap lines.\n If the line is too long, you want to split the sentence in two :-)\n "}]}