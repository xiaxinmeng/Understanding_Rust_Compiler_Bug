{"sha": "a9cc5066ee61f20e7cc59141d5c7213a452a2778", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2M1MDY2ZWU2MWYyMGU3Y2M1OTE0MWQ1YzcyMTNhNDUyYTI3Nzg=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-30T23:01:07Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-31T01:38:15Z"}, "message": "Change syntax extension syntax: `#m[...]` -> `m!{...}`.", "tree": {"sha": "e65d0e9b5a3d3abf723d596a32785b5655505af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e65d0e9b5a3d3abf723d596a32785b5655505af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9cc5066ee61f20e7cc59141d5c7213a452a2778", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cc5066ee61f20e7cc59141d5c7213a452a2778", "html_url": "https://github.com/rust-lang/rust/commit/a9cc5066ee61f20e7cc59141d5c7213a452a2778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9cc5066ee61f20e7cc59141d5c7213a452a2778/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650fb06d68771828406f4f27e3af5db9c11311c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/650fb06d68771828406f4f27e3af5db9c11311c5", "html_url": "https://github.com/rust-lang/rust/commit/650fb06d68771828406f4f27e3af5db9c11311c5"}], "stats": {"total": 5519, "additions": 2760, "deletions": 2759}, "files": [{"sha": "a0d52bb9fd5d0c6135a7739f0d6103809611c668", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 74, "deletions": 74, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -369,7 +369,7 @@ fn rest(s: ~str, start: uint) -> ~str {\n fn need_dir(s: ~str) {\n     if os::path_is_dir(s) { ret; }\n     if !os::make_dir(s, 493_i32 /* oct: 755 */) {\n-        fail #fmt[\"can't make_dir %s\", s];\n+        fail fmt!{\"can't make_dir %s\", s};\n     }\n }\n \n@@ -387,7 +387,7 @@ fn valid_pkg_name(s: ~str) -> bool {\n \n fn parse_source(name: ~str, j: json::json) -> source {\n     if !valid_pkg_name(name) {\n-        fail #fmt(\"'%s' is an invalid source name\", name);\n+        fail fmt!{\"'%s' is an invalid source name\", name};\n     }\n \n     alt j {\n@@ -438,11 +438,11 @@ fn try_parse_sources(filename: ~str, sources: map::hashmap<~str, source>) {\n         ok(json::dict(j)) {\n           for j.each |k, v| {\n                 sources.insert(k, parse_source(k, v));\n-                #debug(\"source: %s\", k);\n+                debug!{\"source: %s\", k};\n             }\n         }\n         ok(_) { fail ~\"malformed sources.json\"; }\n-        err(e) { fail #fmt(\"%s:%s\", filename, e.to_str()); }\n+        err(e) { fail fmt!{\"%s:%s\", filename, e.to_str()}; }\n     }\n }\n \n@@ -565,7 +565,7 @@ fn load_source_info(c: cargo, src: source) {\n                  ~\"(source info is not a dict)\");\n         }\n         err(e) {\n-            warn(#fmt(\"%s:%s\", src.name, e.to_str()));\n+            warn(fmt!{\"%s:%s\", src.name, e.to_str()});\n         }\n     };\n }\n@@ -594,7 +594,7 @@ fn load_source_packages(c: cargo, src: source) {\n                  ~\"(packages is not a list)\");\n         }\n         err(e) {\n-            warn(#fmt(\"%s:%s\", src.name, e.to_str()));\n+            warn(fmt!{\"%s:%s\", src.name, e.to_str()});\n         }\n     };\n }\n@@ -603,7 +603,7 @@ fn build_cargo_options(argv: ~[~str]) -> options {\n     let match = alt getopts::getopts(argv, opts()) {\n         result::ok(m) { m }\n         result::err(f) {\n-            fail #fmt[\"%s\", getopts::fail_str(f)];\n+            fail fmt!{\"%s\", getopts::fail_str(f)};\n         }\n     };\n \n@@ -713,11 +713,11 @@ fn run_in_buildpath(what: ~str, path: ~str, subdir: ~str, cf: ~str,\n                     extra_flags: ~[~str]) -> option<~str> {\n     let buildpath = path::connect(path, subdir);\n     need_dir(buildpath);\n-    #debug(\"%s: %s -> %s\", what, cf, buildpath);\n+    debug!{\"%s: %s -> %s\", what, cf, buildpath};\n     let p = run::program_output(rustc_sysroot(),\n                                 ~[~\"--out-dir\", buildpath, cf] + extra_flags);\n     if p.status != 0 {\n-        error(#fmt[\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out]);\n+        error(fmt!{\"rustc failed: %d\\n%s\\n%s\", p.status, p.err, p.out});\n         ret none;\n     }\n     some(buildpath)\n@@ -744,15 +744,15 @@ fn install_one_crate(c: cargo, path: ~str, cf: ~str) {\n         if (exec_suffix != ~\"\" && str::ends_with(ct, exec_suffix)) ||\n             (exec_suffix == ~\"\" && !str::starts_with(path::basename(ct),\n                                                     ~\"lib\")) {\n-            #debug(\"  bin: %s\", ct);\n+            debug!{\"  bin: %s\", ct};\n             install_to_dir(ct, c.bindir);\n             if c.opts.mode == system_mode {\n                 // FIXME (#2662): Put this file in PATH / symlink it so it can\n                 // be used as a generic executable\n                 // `cargo install -G rustray` and `rustray file.obj`\n             }\n         } else {\n-            #debug(\"  lib: %s\", ct);\n+            debug!{\"  lib: %s\", ct};\n             install_to_dir(ct, c.libdir);\n         }\n     }\n@@ -764,15 +764,15 @@ fn rustc_sysroot() -> ~str {\n         some(path) {\n             let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n             let rustc = path::normalize(path::connect_many(path));\n-            #debug(\"  rustc: %s\", rustc);\n+            debug!{\"  rustc: %s\", rustc};\n             rustc\n         }\n         none { ~\"rustc\" }\n     }\n }\n \n fn install_source(c: cargo, path: ~str) {\n-    #debug(\"source: %s\", path);\n+    debug!{\"source: %s\", path};\n     os::change_dir(path);\n \n     let mut cratefiles = ~[];\n@@ -798,7 +798,7 @@ fn install_source(c: cargo, path: ~str) {\n                     let wd_base = c.workdir + path::path_sep();\n                     let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n                         some(wd) { wd }\n-                        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n+                        none { fail fmt!{\"needed temp dir: %s\", wd_base}; }\n                     };\n \n                     install_query(c, wd, query);\n@@ -831,7 +831,7 @@ fn install_curl(c: cargo, wd: ~str, url: ~str) {\n     let p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                          tarpath, url]);\n     if p.status != 0 {\n-        fail #fmt[\"fetch of %s failed: %s\", url, p.err];\n+        fail fmt!{\"fetch of %s failed: %s\", url, p.err};\n     }\n     run::run_program(~\"tar\", ~[~\"-x\", ~\"--strip-components=1\",\n                              ~\"-C\", wd, ~\"-f\", tarpath]);\n@@ -852,7 +852,7 @@ fn install_package(c: cargo, src: ~str, wd: ~str, pkg: package) {\n         _ { ~\"curl\" }\n     };\n \n-    info(#fmt[\"installing %s/%s via %s...\", src, pkg.name, method]);\n+    info(fmt!{\"installing %s/%s via %s...\", src, pkg.name, method});\n \n     alt method {\n         ~\"git\" { install_git(c, wd, url, copy pkg.ref); }\n@@ -1082,15 +1082,15 @@ fn cmd_install(c: cargo) unsafe {\n     let wd_base = c.workdir + path::path_sep();\n     let wd = alt tempfile::mkdtemp(wd_base, ~\"\") {\n         some(wd) { wd }\n-        none { fail #fmt(\"needed temp dir: %s\", wd_base); }\n+        none { fail fmt!{\"needed temp dir: %s\", wd_base}; }\n     };\n \n     if vec::len(c.opts.free) == 2u {\n         let cwd = os::getcwd();\n         let status = run::run_program(~\"cp\", ~[~\"-R\", cwd, wd]);\n \n         if status != 0 {\n-            fail #fmt(\"could not copy directory: %s\", cwd);\n+            fail fmt!{\"could not copy directory: %s\", cwd};\n         }\n \n         install_source(c, wd);\n@@ -1126,7 +1126,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     let mut has_src_file = false;\n \n     if !os::copy_file(path::connect(url, ~\"packages.json\"), pkgfile) {\n-        error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+        error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n         ret false;\n     }\n \n@@ -1142,7 +1142,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n-                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n                 ret false;\n             }\n             pgp::add(c.root, keyfile);\n@@ -1154,17 +1154,17 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n-                error(#fmt[\"signature verification failed for source %s\",\n-                          name]);\n+                error(fmt!{\"signature verification failed for source %s\",\n+                          name});\n                 ret false;\n             }\n \n             if has_src_file {\n                 let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n \n                 if !e {\n-                    error(#fmt[\"signature verification failed for source %s\",\n-                              name]);\n+                    error(fmt!{\"signature verification failed for source %s\",\n+                              name});\n                     ret false;\n                 }\n             }\n@@ -1184,7 +1184,7 @@ fn sync_one_file(c: cargo, dir: ~str, src: source) -> bool {\n     os::remove_file(pkgfile);\n     os::remove_file(sigfile);\n \n-    info(#fmt[\"synced source: %s\", name]);\n+    info(fmt!{\"synced source: %s\", name});\n \n     ret true;\n }\n@@ -1200,7 +1200,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n     fn rollback(name: ~str, dir: ~str, insecure: bool) {\n         fn msg(name: ~str, insecure: bool) {\n-            error(#fmt[\"could not rollback source: %s\", name]);\n+            error(fmt!{\"could not rollback source: %s\", name});\n \n             if insecure {\n                 warn(~\"a past security check failed on source \" +\n@@ -1226,20 +1226,20 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n         let p = run::program_output(~\"git\", ~[~\"clone\", url, dir]);\n \n         if p.status != 0 {\n-            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n             ret false;\n         }\n     }\n     else {\n         if !os::change_dir(dir) {\n-            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n             ret false;\n         }\n \n         let p = run::program_output(~\"git\", ~[~\"pull\"]);\n \n         if p.status != 0 {\n-            error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+            error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n             ret false;\n         }\n     }\n@@ -1251,7 +1251,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n-                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n                 rollback(name, dir, false);\n                 ret false;\n             }\n@@ -1264,8 +1264,8 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n-                error(#fmt[\"signature verification failed for source %s\",\n-                          name]);\n+                error(fmt!{\"signature verification failed for source %s\",\n+                          name});\n                 rollback(name, dir, false);\n                 ret false;\n             }\n@@ -1274,8 +1274,8 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n                 let e = pgp::verify(c.root, srcfile, srcsigfile, f);\n \n                 if !e {\n-                    error(#fmt[\"signature verification failed for source %s\",\n-                              name]);\n+                    error(fmt!{\"signature verification failed for source %s\",\n+                              name});\n                     rollback(name, dir, false);\n                     ret false;\n                 }\n@@ -1286,7 +1286,7 @@ fn sync_one_git(c: cargo, dir: ~str, src: source) -> bool {\n \n     os::remove_file(keyfile);\n \n-    info(#fmt[\"synced source: %s\", name]);\n+    info(fmt!{\"synced source: %s\", name});\n \n     ret true;\n }\n@@ -1312,7 +1312,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                                 ~[~\"-f\", ~\"-s\", ~\"-o\", pkgfile, url]);\n \n     if p.status != 0 {\n-        error(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+        error(fmt!{\"fetch for source %s (url %s) failed\", name, url});\n         ret false;\n     }\n     if smart {\n@@ -1331,7 +1331,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n             let p = run::program_output(~\"curl\",\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\", keyfile, u]);\n             if p.status != 0 {\n-                error(#fmt[\"fetch for source %s (key %s) failed\", name, u]);\n+                error(fmt!{\"fetch for source %s (key %s) failed\", name, u});\n                 ret false;\n             }\n             pgp::add(c.root, keyfile);\n@@ -1350,15 +1350,15 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n             let mut p = run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\",\n                         sigfile, url]);\n             if p.status != 0 {\n-                error(#fmt[\"fetch for source %s (sig %s) failed\", name, url]);\n+                error(fmt!{\"fetch for source %s (sig %s) failed\", name, url});\n                 ret false;\n             }\n \n             let r = pgp::verify(c.root, pkgfile, sigfile, f);\n \n             if !r {\n-                error(#fmt[\"signature verification failed for source %s\",\n-                          name]);\n+                error(fmt!{\"signature verification failed for source %s\",\n+                          name});\n                 ret false;\n             }\n \n@@ -1369,8 +1369,8 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n                                         ~[~\"-f\", ~\"-s\", ~\"-o\",\n                                           srcsigfile, url]);\n                 if p.status != 0 {\n-                    error(#fmt[\"fetch for source %s (sig %s) failed\",\n-                          name, url]);\n+                    error(fmt!{\"fetch for source %s (sig %s) failed\",\n+                          name, url});\n                     ret false;\n                 }\n \n@@ -1398,7 +1398,7 @@ fn sync_one_curl(c: cargo, dir: ~str, src: source) -> bool {\n     os::remove_file(pkgfile);\n     os::remove_file(sigfile);\n \n-    info(#fmt[\"synced source: %s\", name]);\n+    info(fmt!{\"synced source: %s\", name});\n \n     ret true;\n }\n@@ -1407,7 +1407,7 @@ fn sync_one(c: cargo, src: source) {\n     let name = src.name;\n     let dir = path::connect(c.sourcedir, name);\n \n-    info(#fmt[\"syncing source: %s...\", name]);\n+    info(fmt!{\"syncing source: %s...\", name});\n \n     need_dir(dir);\n \n@@ -1434,28 +1434,28 @@ fn cmd_init(c: cargo) {\n     let p =\n         run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", srcfile, srcurl]);\n     if p.status != 0 {\n-        error(#fmt[\"fetch of sources.json failed: %s\", p.out]);\n+        error(fmt!{\"fetch of sources.json failed: %s\", p.out});\n         ret;\n     }\n \n     let p =\n         run::program_output(~\"curl\", ~[~\"-f\", ~\"-s\", ~\"-o\", sigfile, sigurl]);\n     if p.status != 0 {\n-        error(#fmt[\"fetch of sources.json.sig failed: %s\", p.out]);\n+        error(fmt!{\"fetch of sources.json.sig failed: %s\", p.out});\n         ret;\n     }\n \n     let r = pgp::verify(c.root, srcfile, sigfile, pgp::signing_key_fp());\n     if !r {\n-        error(#fmt[\"signature verification failed for '%s'\", srcfile]);\n+        error(fmt!{\"signature verification failed for '%s'\", srcfile});\n         ret;\n     }\n \n     copy_warn(srcfile, destsrcfile);\n     os::remove_file(srcfile);\n     os::remove_file(sigfile);\n \n-    info(#fmt[\"initialized .cargo in %s\", c.root]);\n+    info(fmt!{\"initialized .cargo in %s\", c.root});\n }\n \n fn print_pkg(s: source, p: package) {\n@@ -1496,14 +1496,14 @@ fn cmd_list(c: cargo) {\n     if vec::len(c.opts.free) >= 3u {\n         do vec::iter_between(c.opts.free, 2u, vec::len(c.opts.free)) |name| {\n             if !valid_pkg_name(name) {\n-                error(#fmt(\"'%s' is an invalid source name\", name));\n+                error(fmt!{\"'%s' is an invalid source name\", name});\n             } else {\n                 alt c.sources.find(name) {\n                     some(source) {\n                         print_source(source);\n                     }\n                     none {\n-                        error(#fmt(\"no such source: %s\", name));\n+                        error(fmt!{\"no such source: %s\", name});\n                     }\n                 }\n             }\n@@ -1533,17 +1533,17 @@ fn cmd_search(c: cargo) {\n             n += 1;\n         }\n     });\n-    info(#fmt[\"found %d packages\", n]);\n+    info(fmt!{\"found %d packages\", n});\n }\n \n fn install_to_dir(srcfile: ~str, destdir: ~str) {\n     let newfile = path::connect(destdir, path::basename(srcfile));\n \n     let status = run::run_program(~\"cp\", ~[~\"-r\", srcfile, newfile]);\n     if status == 0 {\n-        info(#fmt[\"installed: '%s'\", newfile]);\n+        info(fmt!{\"installed: '%s'\", newfile});\n     } else {\n-        error(#fmt[\"could not install: '%s'\", newfile]);\n+        error(fmt!{\"could not install: '%s'\", newfile});\n     }\n }\n \n@@ -1601,22 +1601,22 @@ fn dump_sources(c: cargo) {\n             writer.write_str(json::to_str(root));\n         }\n         result::err(e) {\n-            error(#fmt(\"could not dump sources: %s\", e));\n+            error(fmt!{\"could not dump sources: %s\", e});\n         }\n     }\n }\n \n fn copy_warn(srcfile: ~str, destfile: ~str) {\n     if !os::copy_file(srcfile, destfile) {\n-        warn(#fmt[\"copying %s to %s failed\", srcfile, destfile]);\n+        warn(fmt!{\"copying %s to %s failed\", srcfile, destfile});\n     }\n }\n \n fn cmd_sources(c: cargo) {\n     if vec::len(c.opts.free) < 3u {\n         for c.sources.each_value |v| {\n-            info(#fmt(\"%s (%s) via %s\",\n-                      v.name, v.url, v.method));\n+            info(fmt!{\"%s (%s) via %s\",\n+                      v.name, v.url, v.method});\n         }\n         ret;\n     }\n@@ -1641,13 +1641,13 @@ fn cmd_sources(c: cargo) {\n             let url = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(#fmt(\"'%s' is an invalid source name\", name));\n+                error(fmt!{\"'%s' is an invalid source name\", name});\n                 ret;\n             }\n \n             alt c.sources.find(name) {\n                 some(source) {\n-                    error(#fmt(\"source already exists: %s\", name));\n+                    error(fmt!{\"source already exists: %s\", name});\n                 }\n                 none {\n                     c.sources.insert(name, @{\n@@ -1658,7 +1658,7 @@ fn cmd_sources(c: cargo) {\n                         mut keyfp: none,\n                         mut packages: ~[mut]\n                     });\n-                    info(#fmt(\"added source: %s\", name));\n+                    info(fmt!{\"added source: %s\", name});\n                 }\n             }\n         }\n@@ -1671,17 +1671,17 @@ fn cmd_sources(c: cargo) {\n             let name = c.opts.free[3u];\n \n             if !valid_pkg_name(name) {\n-                error(#fmt(\"'%s' is an invalid source name\", name));\n+                error(fmt!{\"'%s' is an invalid source name\", name});\n                 ret;\n             }\n \n             alt c.sources.find(name) {\n                 some(source) {\n                     c.sources.remove(name);\n-                    info(#fmt(\"removed source: %s\", name));\n+                    info(fmt!{\"removed source: %s\", name});\n                 }\n                 none {\n-                    error(#fmt(\"no such source: %s\", name));\n+                    error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n@@ -1695,7 +1695,7 @@ fn cmd_sources(c: cargo) {\n             let url = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(#fmt(\"'%s' is an invalid source name\", name));\n+                error(fmt!{\"'%s' is an invalid source name\", name});\n                 ret;\n             }\n \n@@ -1709,10 +1709,10 @@ fn cmd_sources(c: cargo) {\n \n                     c.sources.insert(name, source);\n \n-                    info(#fmt(\"changed source url: '%s' to '%s'\", old, url));\n+                    info(fmt!{\"changed source url: '%s' to '%s'\", old, url});\n                 }\n                 none {\n-                    error(#fmt(\"no such source: %s\", name));\n+                    error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n@@ -1726,7 +1726,7 @@ fn cmd_sources(c: cargo) {\n             let method = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(#fmt(\"'%s' is an invalid source name\", name));\n+                error(fmt!{\"'%s' is an invalid source name\", name});\n                 ret;\n             }\n \n@@ -1742,11 +1742,11 @@ fn cmd_sources(c: cargo) {\n \n                     c.sources.insert(name, source);\n \n-                    info(#fmt(\"changed source method: '%s' to '%s'\", old,\n-                         method));\n+                    info(fmt!{\"changed source method: '%s' to '%s'\", old,\n+                         method});\n                 }\n                 none {\n-                    error(#fmt(\"no such source: %s\", name));\n+                    error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }\n@@ -1760,22 +1760,22 @@ fn cmd_sources(c: cargo) {\n             let newn = c.opts.free[4u];\n \n             if !valid_pkg_name(name) {\n-                error(#fmt(\"'%s' is an invalid source name\", name));\n+                error(fmt!{\"'%s' is an invalid source name\", name});\n                 ret;\n             }\n             if !valid_pkg_name(newn) {\n-                error(#fmt(\"'%s' is an invalid source name\", newn));\n+                error(fmt!{\"'%s' is an invalid source name\", newn});\n                 ret;\n             }\n \n             alt c.sources.find(name) {\n                 some(source) {\n                     c.sources.remove(name);\n                     c.sources.insert(newn, source);\n-                    info(#fmt(\"renamed source: %s to %s\", name, newn));\n+                    info(fmt!{\"renamed source: %s to %s\", name, newn});\n                 }\n                 none {\n-                    error(#fmt(\"no such source: %s\", name));\n+                    error(fmt!{\"no such source: %s\", name});\n                 }\n             }\n         }"}, {"sha": "066b9c78ee9d7fce7dbe222e34362de90e0bf1d1", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -68,20 +68,20 @@ fn parse_config(args: ~[~str]) -> config {\n \n fn log_config(config: config) {\n     let c = config;\n-    logv(c, #fmt[\"configuration:\"]);\n-    logv(c, #fmt[\"compile_lib_path: %s\", config.compile_lib_path]);\n-    logv(c, #fmt[\"run_lib_path: %s\", config.run_lib_path]);\n-    logv(c, #fmt[\"rustc_path: %s\", config.rustc_path]);\n-    logv(c, #fmt[\"src_base: %s\", config.src_base]);\n-    logv(c, #fmt[\"build_base: %s\", config.build_base]);\n-    logv(c, #fmt[\"stage_id: %s\", config.stage_id]);\n-    logv(c, #fmt[\"mode: %s\", mode_str(config.mode)]);\n-    logv(c, #fmt[\"run_ignored: %b\", config.run_ignored]);\n-    logv(c, #fmt[\"filter: %s\", opt_str(config.filter)]);\n-    logv(c, #fmt[\"runtool: %s\", opt_str(config.runtool)]);\n-    logv(c, #fmt[\"rustcflags: %s\", opt_str(config.rustcflags)]);\n-    logv(c, #fmt[\"verbose: %b\", config.verbose]);\n-    logv(c, #fmt[\"\\n\"]);\n+    logv(c, fmt!{\"configuration:\"});\n+    logv(c, fmt!{\"compile_lib_path: %s\", config.compile_lib_path});\n+    logv(c, fmt!{\"run_lib_path: %s\", config.run_lib_path});\n+    logv(c, fmt!{\"rustc_path: %s\", config.rustc_path});\n+    logv(c, fmt!{\"src_base: %s\", config.src_base});\n+    logv(c, fmt!{\"build_base: %s\", config.build_base});\n+    logv(c, fmt!{\"stage_id: %s\", config.stage_id});\n+    logv(c, fmt!{\"mode: %s\", mode_str(config.mode)});\n+    logv(c, fmt!{\"run_ignored: %b\", config.run_ignored});\n+    logv(c, fmt!{\"filter: %s\", opt_str(config.filter)});\n+    logv(c, fmt!{\"runtool: %s\", opt_str(config.runtool)});\n+    logv(c, fmt!{\"rustcflags: %s\", opt_str(config.rustcflags)});\n+    logv(c, fmt!{\"verbose: %b\", config.verbose});\n+    logv(c, fmt!{\"\\n\"});\n }\n \n fn opt_str(maybestr: option<~str>) -> ~str {\n@@ -134,11 +134,11 @@ fn test_opts(config: config) -> test::test_opts {\n }\n \n fn make_tests(config: config) -> ~[test::test_desc] {\n-    #debug(\"making tests from %s\", config.src_base);\n+    debug!{\"making tests from %s\", config.src_base};\n     let mut tests = ~[];\n     for os::list_dir_path(config.src_base).each |file| {\n         let file = file;\n-        #debug(\"inspecting file %s\", file);\n+        debug!{\"inspecting file %s\", file};\n         if is_test(config, file) {\n             vec::push(tests, make_test(config, file))\n         }\n@@ -177,7 +177,7 @@ fn make_test(config: config, testfile: ~str) ->\n }\n \n fn make_test_name(config: config, testfile: ~str) -> ~str {\n-    #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n+    fmt!{\"[%s] %s\", mode_str(config.mode), testfile}\n }\n \n fn make_test_closure(config: config, testfile: ~str) -> test::test_fn {"}, {"sha": "e44c80e79b9aa41399251615fc1fa4c709b4703e", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -47,7 +47,7 @@ fn parse_expected(line_num: uint, line: ~str) -> ~[expected_error] unsafe {\n     while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n     let msg = str::slice(line, idx, len);\n \n-    #debug(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n+    debug!{\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg};\n \n     ret ~[{line: line_num - adjust_line, kind: kind, msg: msg}];\n }"}, {"sha": "c5101174424784746f563c1f97117010ac6fe11f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -110,7 +110,7 @@ fn parse_exec_env(line: ~str) -> option<(~str, ~str)> {\n         alt strs.len() {\n           1u { (strs[0], ~\"\") }\n           2u { (strs[0], strs[1]) }\n-          n { fail #fmt[\"Expected 1 or 2 strings, not %u\", n]; }\n+          n { fail fmt!{\"Expected 1 or 2 strings, not %u\", n}; }\n         }\n     }\n }\n@@ -139,7 +139,7 @@ fn parse_name_value_directive(line: ~str,\n         option::some(colon) {\n             let value = str::slice(line, colon + str::len(keycolon),\n                                    str::len(line));\n-            #debug(\"%s: %s\", directive,  value);\n+            debug!{\"%s: %s\", directive,  value};\n             option::some(value)\n         }\n         option::none { option::none }"}, {"sha": "e708af2d6a3859f74f28c55abb5b20c52291c58c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,7 +16,7 @@ fn run(config: config, testfile: ~str) {\n         // We're going to be dumping a lot of info. Start on a new line.\n         io::stdout().write_str(~\"\\n\\n\");\n     }\n-    #debug(\"running %s\", testfile);\n+    debug!{\"running %s\", testfile};\n     let props = load_props(testfile);\n     alt config.mode {\n       mode_compile_fail { run_cfail_test(config, props, testfile); }\n@@ -68,8 +68,8 @@ fn check_correct_failure_status(procres: procres) {\n     const rust_err: int = 101;\n     if procres.status != rust_err {\n         fatal_procres(\n-            #fmt(\"failure produced the wrong error code: %d\",\n-                 procres.status),\n+            fmt!{\"failure produced the wrong error code: %d\",\n+                 procres.status},\n             procres);\n     }\n }\n@@ -96,11 +96,11 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n \n     let mut round = 0;\n     while round < rounds {\n-        logv(config, #fmt[\"pretty-printing round %d\", round]);\n+        logv(config, fmt!{\"pretty-printing round %d\", round});\n         let procres = print_source(config, testfile, srcs[round]);\n \n         if procres.status != 0 {\n-            fatal_procres(#fmt[\"pretty-printing failed in round %d\", round],\n+            fatal_procres(fmt!{\"pretty-printing failed in round %d\", round},\n                           procres);\n         }\n \n@@ -151,7 +151,7 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n             let msg =\n-                #fmt[\"\\n\\\n+                fmt!{\"\\n\\\n expected:\\n\\\n ------------------------------------------\\n\\\n %s\\n\\\n@@ -161,7 +161,7 @@ actual:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-                     expected, actual];\n+                     expected, actual};\n             io::stdout().write_str(msg);\n             fail;\n         }\n@@ -201,10 +201,10 @@ fn check_error_patterns(props: test_props,\n     let mut done = false;\n     for str::split_char(procres.stderr, '\\n').each |line| {\n         if str::contains(line, next_err_pat) {\n-            #debug(\"found error pattern %s\", next_err_pat);\n+            debug!{\"found error pattern %s\", next_err_pat};\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n-                #debug(\"found all error patterns\");\n+                debug!{\"found all error patterns\"};\n                 done = true;\n                 break;\n             }\n@@ -217,11 +217,11 @@ fn check_error_patterns(props: test_props,\n         vec::slice(props.error_patterns, next_err_idx,\n                    vec::len(props.error_patterns));\n     if vec::len(missing_patterns) == 1u {\n-        fatal_procres(#fmt[\"error pattern '%s' not found!\",\n-                           missing_patterns[0]], procres);\n+        fatal_procres(fmt!{\"error pattern '%s' not found!\",\n+                           missing_patterns[0]}, procres);\n     } else {\n         for missing_patterns.each |pattern| {\n-            error(#fmt[\"error pattern '%s' not found!\", pattern]);\n+            error(fmt!{\"error pattern '%s' not found!\", pattern});\n         }\n         fatal_procres(~\"multiple error patterns not found\", procres);\n     }\n@@ -240,7 +240,7 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n     }\n \n     let prefixes = vec::map(expected_errors, |ee| {\n-        #fmt(\"%s:%u:\", testfile, ee.line)\n+        fmt!{\"%s:%u:\", testfile, ee.line}\n     });\n \n     // Scan and extract our error/warning messages,\n@@ -253,8 +253,8 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n         let mut was_expected = false;\n         for vec::eachi(expected_errors) |i, ee| {\n             if !found_flags[i] {\n-                #debug[\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n-                       prefixes[i], ee.kind, ee.msg, line];\n+                debug!{\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n+                       prefixes[i], ee.kind, ee.msg, line};\n                 if (str::starts_with(line, prefixes[i]) &&\n                     str::contains(line, ee.kind) &&\n                     str::contains(line, ee.msg)) {\n@@ -272,16 +272,16 @@ fn check_expected_errors(expected_errors: ~[errors::expected_error],\n \n         if !was_expected && (str::contains(line, ~\"error\") ||\n                              str::contains(line, ~\"warning\")) {\n-            fatal_procres(#fmt[\"unexpected error pattern '%s'!\", line],\n+            fatal_procres(fmt!{\"unexpected error pattern '%s'!\", line},\n                           procres);\n         }\n     }\n \n     for uint::range(0u, vec::len(found_flags)) |i| {\n         if !found_flags[i] {\n             let ee = expected_errors[i];\n-            fatal_procres(#fmt[\"expected %s on line %u not found: %s\",\n-                               ee.kind, ee.line, ee.msg], procres);\n+            fatal_procres(fmt!{\"expected %s on line %u not found: %s\",\n+                               ee.kind, ee.line, ee.msg}, procres);\n         }\n     }\n }\n@@ -330,7 +330,7 @@ fn compose_and_run_compiler(\n                                      config.compile_lib_path, option::none);\n         if auxres.status != 0 {\n             fatal_procres(\n-                #fmt[\"auxiliary build of %s failed to compile: \", abs_ab],\n+                fmt!{\"auxiliary build of %s failed to compile: \", abs_ab},\n                 auxres);\n         }\n     }\n@@ -342,7 +342,7 @@ fn compose_and_run_compiler(\n fn ensure_dir(path: path) {\n     if os::path_is_dir(path) { ret; }\n     if !os::make_dir(path, 0x1c0i32) {\n-        fail #fmt(\"can't make dir %s\", path);\n+        fail fmt!{\"can't make dir %s\", path};\n     }\n }\n \n@@ -414,7 +414,7 @@ fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n-            logv(config, #fmt[\"executing %s\", cmdline]);\n+            logv(config, fmt!{\"executing %s\", cmdline});\n             cmdline\n         };\n     let res = procsrv::run(lib_path, prog, args, env, input);\n@@ -430,19 +430,19 @@ fn program_output(config: config, testfile: ~str, lib_path: ~str, prog: ~str,\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n fn make_cmdline(_libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n-    #fmt[\"%s %s\", prog, str::connect(args, ~\" \")]\n+    fmt!{\"%s %s\", prog, str::connect(args, ~\" \")}\n }\n \n #[cfg(target_os = \"win32\")]\n fn make_cmdline(libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n-    #fmt[\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n-         str::connect(args, ~\" \")]\n+    fmt!{\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n+         str::connect(args, ~\" \")}\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n fn lib_path_cmd_prefix(path: ~str) -> ~str {\n-    #fmt[\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)]\n+    fmt!{\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)}\n }\n \n fn dump_output(config: config, testfile: ~str, out: ~str, err: ~str) {\n@@ -475,13 +475,13 @@ fn output_testname(testfile: ~str) -> ~str {\n fn output_base_name(config: config, testfile: ~str) -> ~str {\n     let base = config.build_base;\n     let filename = output_testname(testfile);\n-    #fmt[\"%s%s.%s\", base, filename, config.stage_id]\n+    fmt!{\"%s%s.%s\", base, filename, config.stage_id}\n }\n \n fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n     if config.verbose {\n-        let sep1 = #fmt[\"------%s------------------------------\", ~\"stdout\"];\n-        let sep2 = #fmt[\"------%s------------------------------\", ~\"stderr\"];\n+        let sep1 = fmt!{\"------%s------------------------------\", ~\"stdout\"};\n+        let sep2 = fmt!{\"------%s------------------------------\", ~\"stderr\"};\n         let sep3 = ~\"------------------------------------------\";\n         io::stdout().write_line(sep1);\n         io::stdout().write_line(out);\n@@ -491,13 +491,13 @@ fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n     }\n }\n \n-fn error(err: ~str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n+fn error(err: ~str) { io::stdout().write_line(fmt!{\"\\nerror: %s\", err}); }\n \n fn fatal(err: ~str) -> ! { error(err); fail; }\n \n fn fatal_procres(err: ~str, procres: procres) -> ! {\n     let msg =\n-        #fmt[\"\\n\\\n+        fmt!{\"\\n\\\n error: %s\\n\\\n command: %s\\n\\\n stdout:\\n\\\n@@ -509,7 +509,7 @@ stderr:\\n\\\n %s\\n\\\n ------------------------------------------\\n\\\n \\n\",\n-             err, procres.cmdline, procres.stdout, procres.stderr];\n+             err, procres.cmdline, procres.stdout, procres.stderr};\n     io::stdout().write_str(msg);\n     fail;\n }"}, {"sha": "fec0fc84bc30a249c34b344f845132c827151292", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ fn make_new_path(path: ~str) -> ~str {\n     // maintain the current value while adding our own\n     alt getenv(lib_path_env_var()) {\n       option::some(curr) {\n-        #fmt[\"%s%s%s\", path, path_div(), curr]\n+        fmt!{\"%s%s%s\", path, path_div(), curr}\n       }\n       option::none { path }\n     }"}, {"sha": "abfcac55534f7f9a77a0a88c9ccabaf841938227", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -26,5 +26,5 @@ fn main() {\n     assert (!vec_equal(~[5, 5], ~[4, 5], builtin_equal_int));\n     assert (vec_equal(~[5, 5], ~[5, 5], builtin_equal_int));\n \n-    #error(\"Pass\");\n+    error!{\"Pass\"};\n }"}, {"sha": "ea10ff580494be6e3a3895e7b3dca5f2fe79f3c2", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -246,8 +246,8 @@ fn check_variants_T<T: copy>(\n   replacer: fn@(ast::crate, uint, T, test_mode) -> ast::crate,\n   cx: context\n   ) {\n-    #error(\"%s contains %u %s objects\", filename,\n-           vec::len(things), thing_label);\n+    error!{\"%s contains %u %s objects\", filename,\n+           vec::len(things), thing_label};\n \n     let L = vec::len(things);\n \n@@ -277,9 +277,9 @@ fn check_variants_T<T: copy>(\n                     check_roundtrip_convergence(str3, 1u);\n                   }\n                   tm_run {\n-                    let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\",\n+                    let file_label = fmt!{\"rusttmp/%s_%s_%u_%u\",\n                                           last_part(filename),\n-                                          thing_label, i, j);\n+                                          thing_label, i, j};\n                     let safe_to_run = !(content_is_dangerous_to_run(*str3)\n                                         || has_raw_pointers(*crate2));\n                     check_whole_compiler(*str3, file_label, safe_to_run);\n@@ -389,7 +389,7 @@ fn check_compiling(filename: ~str) -> happiness {\n          stage1/bin/rustc\",\n         ~[filename]);\n \n-    //#error(\"Status: %d\", p.status);\n+    //error!{\"Status: %d\", p.status};\n     if p.status == 0 {\n         passed\n     } else if p.err != ~\"\" {\n@@ -519,9 +519,9 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n     }\n \n     if oldv == newv {\n-        #error(\"Converged after %u iterations\", i);\n+        error!{\"Converged after %u iterations\", i};\n     } else {\n-        #error(\"Did not converge after %u iterations!\", i);\n+        error!{\"Did not converge after %u iterations!\", i};\n         write_file(~\"round-trip-a.rs\", *oldv);\n         write_file(~\"round-trip-b.rs\", *newv);\n         run::run_program(~\"diff\",\n@@ -532,12 +532,12 @@ fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n }\n \n fn check_convergence(files: ~[~str]) {\n-    #error(\"pp convergence tests: %u files\", vec::len(files));\n+    error!{\"pp convergence tests: %u files\", vec::len(files)};\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n             let s = @result::get(io::read_whole_file_str(file));\n             if !content_might_not_converge(*s) {\n-                #error(\"pp converge: %s\", file);\n+                error!{\"pp converge: %s\", file};\n                 // Change from 7u to 2u once\n                 // https://github.com/mozilla/rust/issues/850 is fixed\n                 check_roundtrip_convergence(s, 7u);\n@@ -549,8 +549,8 @@ fn check_convergence(files: ~[~str]) {\n fn check_variants(files: ~[~str], cx: context) {\n     for files.each |file| {\n         if cx.mode == tm_converge && file_might_not_converge(file) {\n-            #error(\"Skipping convergence test based on\\\n-                    file_might_not_converge\");\n+            error!{\"Skipping convergence test based on\\\n+                    file_might_not_converge\"};\n             again;\n         }\n \n@@ -572,7 +572,7 @@ fn check_variants(files: ~[~str], cx: context) {\n                 file,\n                 s, ~[], sess);\n         io::with_str_reader(*s, |rdr| {\n-            #error(\"%s\",\n+            error!{\"%s\",\n                    as_str(|a| pprust::print_crate(\n                        sess.cm,\n                        // Assuming no token_trees\n@@ -583,29 +583,29 @@ fn check_variants(files: ~[~str], cx: context) {\n                        file,\n                        rdr, a,\n                        pprust::no_ann(),\n-                       false) ))\n+                       false) )}\n         });\n         check_variants_of_ast(*crate, sess.cm, file, cx);\n     }\n }\n \n fn main(args: ~[~str]) {\n     if vec::len(args) != 2u {\n-        #error(\"usage: %s <testdir>\", args[0]);\n+        error!{\"usage: %s <testdir>\", args[0]};\n         ret;\n     }\n     let mut files = ~[];\n     let root = args[1];\n \n     find_rust_files(files, root);\n-    #error(\"== check_convergence ==\");\n+    error!{\"== check_convergence ==\"};\n     check_convergence(files);\n-    #error(\"== check_variants: converge ==\");\n+    error!{\"== check_variants: converge ==\"};\n     check_variants(files, { mode: tm_converge });\n-    #error(\"== check_variants: run ==\");\n+    error!{\"== check_variants: run ==\"};\n     check_variants(files, { mode: tm_run });\n \n-    #error(\"Fuzzer done\");\n+    error!{\"Fuzzer done\"};\n }\n \n // Local Variables:"}, {"sha": "7eec13c1b1ac597466e3d9dfac828cc95fb70fa2", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -21,7 +21,7 @@ combinations at the moment.\n \n Example:\n \n-#debug(\"hello, %s!\", \"world\");\n+debug!{\"hello, %s!\", \"world\"};\n \n */\n \n@@ -438,7 +438,7 @@ mod test {\n     #[test]\n     fn fmt_slice() {\n         let s = \"abc\";\n-        let _s = #fmt(\"%s\", s);\n+        let _s = fmt!{\"%s\", s};\n     }\n }\n "}, {"sha": "83dc6b7178b702ae93a17699885fcdfcf1e5aa0e", "filename": "src/libcore/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@\n  * ~~~\n  * let delayed_fib = future::spawn {|| fib(5000) };\n  * make_a_sandwich();\n- * io::println(#fmt(\"fib(5000) = %?\", delayed_fib.get()))\n+ * io::println(fmt!{\"fib(5000) = %?\", delayed_fib.get()})\n  * ~~~\n  */\n "}, {"sha": "1445c43df79cb91539312a0d4f4901703fd55ae2", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -20,35 +20,35 @@ pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n     let mut v2 : u64 = k0 ^ 0x6c79_6765_6e65_7261;\n     let mut v3 : u64 = k1 ^ 0x7465_6462_7974_6573;\n \n-    #macro([#u8to64_le(buf,i),\n+    #macro[[#u8to64_le(buf,i),\n             (buf[0+i] as u64 |\n              buf[1+i] as u64 << 8 |\n              buf[2+i] as u64 << 16 |\n              buf[3+i] as u64 << 24 |\n              buf[4+i] as u64 << 32 |\n              buf[5+i] as u64 << 40 |\n              buf[6+i] as u64 << 48 |\n-             buf[7+i] as u64 << 56)]);\n+             buf[7+i] as u64 << 56)]];\n \n-    #macro([#rotl(x,b), (x << b) | (x >> (64 - b))]);\n+    #macro[[#rotl(x,b), (x << b) | (x >> (64 - b))]];\n \n-    #macro([#compress(v0,v1,v2,v3), {\n+    #macro[[#compress(v0,v1,v2,v3), {\n         v0 += v1; v1 = #rotl(v1, 13); v1 ^= v0; v0 = #rotl(v0, 32);\n         v2 += v3; v3 = #rotl(v3, 16); v3 ^= v2;\n         v0 += v3; v3 = #rotl(v3, 21); v3 ^= v0;\n         v2 += v1; v1 = #rotl(v1, 17); v1 ^= v2; v2 = #rotl(v2, 32);\n-    }]);\n+    }]];\n \n     let len = vec::len(buf);\n     let end = len & (!0x7);\n     let left = len & 0x7;\n \n     let mut i = 0;\n     while i < end {\n-        let m = #u8to64_le(buf, i);\n+        let m = u8to64_le!{buf, i};\n         v3 ^= m;\n-        #compress(v0,v1,v2,v3);\n-        #compress(v0,v1,v2,v3);\n+        compress!{v0,v1,v2,v3};\n+        compress!{v0,v1,v2,v3};\n         v0 ^= m;\n         i += 8;\n     }\n@@ -64,16 +64,16 @@ pure fn hash_bytes_keyed(buf: &[const u8], k0: u64, k1: u64) -> u64 {\n     if left > 6 { b |= buf[i + 6] as u64 << 48; }\n \n     v3 ^= b;\n-    #compress(v0,v1,v2,v3);\n-    #compress(v0,v1,v2,v3);\n+    compress!{v0,v1,v2,v3};\n+    compress!{v0,v1,v2,v3};\n     v0 ^= b;\n \n     v2 ^= 0xff;\n \n-    #compress(v0,v1,v2,v3);\n-    #compress(v0,v1,v2,v3);\n-    #compress(v0,v1,v2,v3);\n-    #compress(v0,v1,v2,v3);\n+    compress!{v0,v1,v2,v3};\n+    compress!{v0,v1,v2,v3};\n+    compress!{v0,v1,v2,v3};\n+    compress!{v0,v1,v2,v3};\n \n     ret v0 ^ v1 ^ v2 ^ v3;\n }\n@@ -127,11 +127,11 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n                 t += 1;\n             }\n \n-            let m = #u8to64_le(st.tail, 0);\n+            let m = u8to64_le!{st.tail, 0};\n \n             st.v3 ^= m;\n-            #compress(st.v0, st.v1, st.v2, st.v3);\n-            #compress(st.v0, st.v1, st.v2, st.v3);\n+            compress!{st.v0, st.v1, st.v2, st.v3};\n+            compress!{st.v0, st.v1, st.v2, st.v3};\n             st.v0 ^= m;\n \n             st.ntail = 0;\n@@ -143,11 +143,11 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n \n         let mut i = needed;\n         while i < end {\n-            let mi = #u8to64_le(msg, i);\n+            let mi = u8to64_le!{msg, i};\n \n             st.v3 ^= mi;\n-            #compress(st.v0, st.v1, st.v2, st.v3);\n-            #compress(st.v0, st.v1, st.v2, st.v3);\n+            compress!{st.v0, st.v1, st.v2, st.v3};\n+            compress!{st.v0, st.v1, st.v2, st.v3};\n             st.v0 ^= mi;\n \n             i += 8;\n@@ -179,15 +179,15 @@ fn siphash(key0 : u64, key1 : u64) -> streaming {\n         if st.ntail > 6 { b |= st.tail[6] as u64 << 48; }\n \n         v3 ^= b;\n-        #compress(v0, v1, v2, v3);\n-        #compress(v0, v1, v2, v3);\n+        compress!{v0, v1, v2, v3};\n+        compress!{v0, v1, v2, v3};\n         v0 ^= b;\n \n         v2 ^= 0xff;\n-        #compress(v0, v1, v2, v3);\n-        #compress(v0, v1, v2, v3);\n-        #compress(v0, v1, v2, v3);\n-        #compress(v0, v1, v2, v3);\n+        compress!{v0, v1, v2, v3};\n+        compress!{v0, v1, v2, v3};\n+        compress!{v0, v1, v2, v3};\n+        compress!{v0, v1, v2, v3};\n \n         let h = v0 ^ v1 ^ v2 ^ v3;\n \n@@ -323,18 +323,18 @@ fn test_siphash() {\n     }\n \n     while t < 64 {\n-        #debug(\"siphash test %?\", t);\n-        let vec = #u8to64_le(vecs[t], 0);\n+        debug!{\"siphash test %?\", t};\n+        let vec = u8to64_le!{vecs[t], 0};\n         let out = hash_bytes_keyed(buf, k0, k1);\n-        #debug(\"got %?, expected %?\", out, vec);\n+        debug!{\"got %?, expected %?\", out, vec};\n         assert vec == out;\n \n         stream_full.reset();\n         stream_full.input(buf);\n         let f = stream_full.result_str();\n         let i = stream_inc.result_str();\n         let v = to_hex_str(vecs[t]);\n-        #debug[\"%d: (%s) => inc=%s full=%s\", t, v, i, f];\n+        debug!{\"%d: (%s) => inc=%s full=%s\", t, v, i, f};\n \n         assert f == i && f == v;\n "}, {"sha": "acde4ad4265fee3f5eb5c2617369e7080ec5fcfa", "filename": "src/libcore/int-template.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fint-template.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -144,8 +144,8 @@ impl times of iter::times for T {\n         `for int::range(0, x) |_i| { /* anything */ }`.\"]\n     fn times(it: fn() -> bool) {\n         if self < 0 {\n-            fail #fmt(\"The .times method expects a nonnegative number, \\\n-                       but found %?\", self);\n+            fail fmt!{\"The .times method expects a nonnegative number, \\\n+                       but found %?\", self};\n         }\n         let mut i = self;\n         while i > 0 {\n@@ -161,8 +161,8 @@ impl timesi of iter::timesi for T {\n     fn timesi(it: fn(uint) -> bool) {\n         let slf = self as uint;\n         if slf < 0u {\n-            fail #fmt(\"The .timesi method expects a nonnegative number, \\\n-                       but found %?\", self);\n+            fail fmt!{\"The .timesi method expects a nonnegative number, \\\n+                       but found %?\", self};\n         }\n         let mut i = 0u;\n         while i < slf {"}, {"sha": "e83842232e6ff5263cc9f7dde2385ca837895a3c", "filename": "src/libcore/io.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -291,7 +291,7 @@ impl of reader for byte_buf {\n         ret b as int;\n     }\n     // FIXME (#2738): implement this\n-    fn unread_byte(_byte: int) { #error(\"Unimplemented: unread_byte\"); fail; }\n+    fn unread_byte(_byte: int) { error!{\"Unimplemented: unread_byte\"}; fail; }\n     fn eof() -> bool { self.pos == self.len }\n     fn seek(offset: int, whence: seek_style) {\n         let pos = self.pos;\n@@ -357,7 +357,7 @@ impl of writer for *libc::FILE {\n             let nout = libc::fwrite(vbuf as *c_void, len as size_t,\n                                     1u as size_t, self);\n             if nout < 1 as size_t {\n-                #error(\"error writing buffer\");\n+                error!{\"error writing buffer\"};\n                 log(error, os::last_os_error());\n                 fail;\n             }\n@@ -392,7 +392,7 @@ impl of writer for fd_t {\n                 let vb = ptr::const_offset(vbuf, count) as *c_void;\n                 let nout = libc::write(self, vb, len as size_t);\n                 if nout < 0 as ssize_t {\n-                    #error(\"error writing buffer\");\n+                    error!{\"error writing buffer\"};\n                     log(error, os::last_os_error());\n                     fail;\n                 }\n@@ -401,11 +401,11 @@ impl of writer for fd_t {\n         }\n     }\n     fn seek(_offset: int, _whence: seek_style) {\n-        #error(\"need 64-bit foreign calls for seek, sorry\");\n+        error!{\"need 64-bit foreign calls for seek, sorry\"};\n         fail;\n     }\n     fn tell() -> uint {\n-        #error(\"need 64-bit foreign calls for tell, sorry\");\n+        error!{\"need 64-bit foreign calls for tell, sorry\"};\n         fail;\n     }\n     fn flush() -> int { 0 }\n@@ -452,7 +452,7 @@ fn mk_file_writer(path: ~str, flags: ~[fileflag])\n                    (S_IRUSR | S_IWUSR) as c_int)\n     };\n     if fd < (0 as c_int) {\n-        result::err(#fmt(\"error opening %s: %s\", path, os::last_os_error()))\n+        result::err(fmt!{\"error opening %s: %s\", path, os::last_os_error()})\n     } else {\n         result::ok(fd_writer(fd, true))\n     }"}, {"sha": "e54fbabb0aa8f52eabefed058b3adefb28d3e298", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -169,7 +169,7 @@ fn max<A:copy,IA:base_iter<A>>(self: IA) -> A {\n #[test]\n fn test_enumerate() {\n     enumerate([\"0\", \"1\", \"2\"]) {|i,j|\n-        assert #fmt[\"%u\",i] == j;\n+        assert fmt!{\"%u\",i} == j;\n     }\n }\n \n@@ -247,7 +247,7 @@ fn test_flat_map_with_list() {\n     let a = bind vec::iter(~[0, 1, 2, 3], _);\n     let b = bind flat_map(a, repeat, _);\n     let c = to_vec(b);\n-    #debug[\"c = %?\", c];\n+    debug!{\"c = %?\", c};\n     assert c == ~[1, 2, 2, 3, 3, 3];\n }\n \n@@ -258,7 +258,7 @@ fn test_repeat() {\n         c += ~[(i * i)];\n         i += 1u;\n     };\n-    #debug[\"c = %?\", c];\n+    debug!{\"c = %?\", c};\n     assert c == ~[0u, 1u, 4u, 9u, 16u];\n }\n "}, {"sha": "4edf5af5f80a68fe14eb6df107a396c938c28e20", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -995,7 +995,7 @@ mod tests {\n       assert (libc::fclose(ostream) == (0u as c_int));\n       let rs = os::copy_file(in, out);\n       if (!os::path_exists(in)) {\n-        fail (#fmt(\"%s doesn't exist\", in));\n+        fail (fmt!{\"%s doesn't exist\", in});\n       }\n       assert(rs);\n       let rslt = run::run_program(~\"diff\", ~[in, out]);"}, {"sha": "873ffd05aa572a53a605b31e7d3a6c0df1981efe", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -222,15 +222,15 @@ class buffer_resource<T: send> {\n     let buffer: ~buffer<T>;\n     new(+b: ~buffer<T>) {\n         //let p = ptr::addr_of(*b);\n-        //#error(\"take %?\", p);\n+        //error!{\"take %?\", p};\n         atomic_add_acq(b.header.ref_count, 1);\n         self.buffer = b;\n     }\n \n     drop unsafe {\n         let b = move!{self.buffer};\n         //let p = ptr::addr_of(*b);\n-        //#error(\"drop %?\", p);\n+        //error!{\"drop %?\", p};\n         let old_count = atomic_sub_rel(b.header.ref_count, 1);\n         //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n         if old_count == 1 {\n@@ -262,7 +262,7 @@ fn send<T: send, Tbuffer: send>(-p: send_packet_buffered<T, Tbuffer>,\n       }\n       full { fail ~\"duplicate send\" }\n       blocked {\n-        #debug(\"waking up task for %?\", p_);\n+        debug!{\"waking up task for %?\", p_};\n         alt p.header.blocked_task {\n           some(task) {\n             rustrt::task_signal_event(\n@@ -301,7 +301,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n                                        blocked);\n         alt old_state {\n           empty {\n-            #debug(\"no data available on %?, going to sleep.\", p_);\n+            debug!{\"no data available on %?, going to sleep.\", p_};\n             if count == 0 {\n                 wait_event(this);\n             }\n@@ -314,7 +314,7 @@ fn try_recv<T: send, Tbuffer: send>(-p: recv_packet_buffered<T, Tbuffer>)\n                 // sometimes blocking the thing we are waiting on.\n                 task::yield();\n             }\n-            #debug(\"woke up, p.state = %?\", copy p.header.state);\n+            debug!{\"woke up, p.state = %?\", copy p.header.state};\n           }\n           blocked {\n             if first {\n@@ -418,7 +418,7 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n     }\n \n     while !data_avail {\n-        #debug(\"sleeping on %? packets\", pkts.len());\n+        debug!{\"sleeping on %? packets\", pkts.len()};\n         let event = wait_event(this) as *packet_header;\n         let pos = vec::position(pkts, |p| p == event);\n \n@@ -428,16 +428,16 @@ fn wait_many(pkts: &[*packet_header]) -> uint {\n             data_avail = true;\n           }\n           none {\n-            #debug(\"ignoring spurious event, %?\", event);\n+            debug!{\"ignoring spurious event, %?\", event};\n           }\n         }\n     }\n \n-    #debug(\"%?\", pkts[ready_packet]);\n+    debug!{\"%?\", pkts[ready_packet]};\n \n     for pkts.each |p| { unsafe{ (*p).unblock()} }\n \n-    #debug(\"%?, %?\", ready_packet, pkts[ready_packet]);\n+    debug!{\"%?, %?\", ready_packet, pkts[ready_packet]};\n \n     unsafe {\n         assert (*pkts[ready_packet]).state == full\n@@ -510,7 +510,7 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n     let mut p: option<*packet<T>>;\n     let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n-        //#debug(\"take send %?\", p);\n+        //debug!{\"take send %?\", p};\n         self.p = some(p);\n         unsafe {\n             self.buffer = some(\n@@ -520,17 +520,17 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n     }\n     drop {\n         //if self.p != none {\n-        //    #debug(\"drop send %?\", option::get(self.p));\n+        //    debug!{\"drop send %?\", option::get(self.p)};\n         //}\n         if self.p != none {\n             let mut p = none;\n             p <-> self.p;\n             sender_terminate(option::unwrap(p))\n         }\n-        //unsafe { #error(\"send_drop: %?\",\n+        //unsafe { error!{\"send_drop: %?\",\n         //                if self.buffer == none {\n         //                    \"none\"\n-        //                } else { \"some\" }); }\n+        //                } else { \"some\" }}; }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -553,7 +553,7 @@ class send_packet_buffered<T: send, Tbuffer: send> {\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n-        //#error(\"send reuse_buffer\");\n+        //error!{\"send reuse_buffer\"};\n         let mut tmp = none;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)\n@@ -570,7 +570,7 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     let mut p: option<*packet<T>>;\n     let mut buffer: option<buffer_resource<Tbuffer>>;\n     new(p: *packet<T>) {\n-        //#debug(\"take recv %?\", p);\n+        //debug!{\"take recv %?\", p};\n         self.p = some(p);\n         unsafe {\n             self.buffer = some(\n@@ -580,17 +580,17 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n     drop {\n         //if self.p != none {\n-        //    #debug(\"drop recv %?\", option::get(self.p));\n+        //    debug!{\"drop recv %?\", option::get(self.p)};\n         //}\n         if self.p != none {\n             let mut p = none;\n             p <-> self.p;\n             receiver_terminate(option::unwrap(p))\n         }\n-        //unsafe { #error(\"recv_drop: %?\",\n+        //unsafe { error!{\"recv_drop: %?\",\n         //                if self.buffer == none {\n         //                    \"none\"\n-        //                } else { \"some\" }); }\n+        //                } else { \"some\" }}; }\n     }\n     fn unwrap() -> *packet<T> {\n         let mut p = none;\n@@ -613,7 +613,7 @@ class recv_packet_buffered<T: send, Tbuffer: send> : selectable {\n     }\n \n     fn reuse_buffer() -> buffer_resource<Tbuffer> {\n-        //#error(\"recv reuse_buffer\");\n+        //error!{\"recv reuse_buffer\"};\n         let mut tmp = none;\n         tmp <-> self.buffer;\n         option::unwrap(tmp)"}, {"sha": "00bbe3d032a325b7f4b5bef385f846ab2a35444c", "filename": "src/libcore/priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fpriv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fpriv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpriv.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -65,7 +65,7 @@ unsafe fn chan_from_global_ptr<T: send>(\n         log(debug,~\"BEFORE COMPARE AND SWAP\");\n         let swapped = compare_and_swap(\n             global, 0u, unsafe::reinterpret_cast(ch));\n-        log(debug,#fmt(\"AFTER .. swapped? %?\", swapped));\n+        log(debug,fmt!{\"AFTER .. swapped? %?\", swapped});\n \n         if swapped {\n             // Success!"}, {"sha": "85e5b43a9986956a081f97f4fabd6d196036179d", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -327,7 +327,7 @@ mod tests {\n         let ra = rand::seeded_rng(seed);\n         // Regression test that isaac is actually using the above vector\n         let r = ra.next();\n-        #error(\"%?\", r);\n+        error!{\"%?\", r};\n         assert r == 890007737u32 // on x86_64\n             || r == 2935188040u32; // on x86\n     }"}, {"sha": "2e9fd9775366fb8000300d382ef649c3477f54ab", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -21,7 +21,7 @@ pure fn get<T: copy, U>(res: result<T, U>) -> T {\n     alt res {\n       ok(t) { t }\n       err(the_err) {\n-        unchecked{ fail #fmt(\"get called on error result: %?\", the_err); }\n+        unchecked{ fail fmt!{\"get called on error result: %?\", the_err}; }\n       }\n     }\n }"}, {"sha": "f2e3981fd87f5f1e97d9dd3c8bb51612be20d0d1", "filename": "src/libcore/run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -103,7 +103,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n \n         for vec::each(es) |e| {\n             let (k,v) = e;\n-            let t = @(#fmt(\"%s=%s\", k, v));\n+            let t = @(fmt!{\"%s=%s\", k, v});\n             vec::push(tmps, t);\n             vec::push_all(ptrs, str::as_c_str(*t, |b| ~[b]));\n         }\n@@ -130,7 +130,7 @@ fn with_envp<T>(env: option<~[(~str,~str)]>,\n             let mut blk : ~[u8] = ~[];\n             for vec::each(es) |e| {\n                 let (k,v) = e;\n-                let t = #fmt(\"%s=%s\", k, v);\n+                let t = fmt!{\"%s=%s\", k, v};\n                 let mut v : ~[u8] = ::unsafe::reinterpret_cast(t);\n                 blk += v;\n                 ::unsafe::forget(v);\n@@ -329,7 +329,7 @@ fn program_output(prog: ~str, args: ~[~str]) ->\n fn writeclose(fd: c_int, s: ~str) {\n     import io::writer_util;\n \n-    #error(\"writeclose %d, %s\", fd as int, s);\n+    error!{\"writeclose %d, %s\", fd as int, s};\n     let writer = io::fd_writer(fd, false);\n     writer.write_str(s);\n "}, {"sha": "24af1d0aedfafa24a1a1c0312d925833809dd343", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -78,7 +78,7 @@ mod linear {\n         pure fn next_bucket(idx: uint, len_buckets: uint) -> uint {\n             let n = (idx + 1) % len_buckets;\n             unsafe{ // argh. log not considered pure.\n-                #debug[\"next_bucket(%?, %?) = %?\", idx, len_buckets, n];\n+                debug!{\"next_bucket(%?, %?) = %?\", idx, len_buckets, n};\n             }\n             ret n;\n         }\n@@ -163,15 +163,15 @@ mod linear {\n                                               unsafe{borrow(k)}) {\n               table_full => {fail ~\"Internal logic error\";}\n               found_hole(idx) {\n-                #debug[\"insert fresh (%?->%?) at idx %?, hash %?\",\n-                       k, v, idx, hash];\n+                debug!{\"insert fresh (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n                 self.size += 1;\n                 ret true;\n               }\n               found_entry(idx) => {\n-                #debug[\"insert overwrite (%?->%?) at idx %?, hash %?\",\n-                       k, v, idx, hash];\n+                debug!{\"insert overwrite (%?->%?) at idx %?, hash %?\",\n+                       k, v, idx, hash};\n                 self.buckets[idx] = some({hash: hash, key: k, value: v});\n                 ret false;\n               }\n@@ -269,7 +269,7 @@ mod linear {\n         fn get(k: &K) -> V {\n             let value = self.find(k);\n             if value.is_none() {\n-                fail #fmt[\"No entry found for key: %?\", k];\n+                fail fmt!{\"No entry found for key: %?\", k};\n             }\n             option::unwrap(value)\n         }"}, {"sha": "3539f41100668ad1daea5d9dbd052ce17f2c3eb4", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,7 +16,7 @@ class frame {\n \n fn walk_stack(visit: fn(frame) -> bool) {\n \n-    #debug(\"beginning stack walk\");\n+    debug!{\"beginning stack walk\"};\n \n     do frame_address |frame_pointer| {\n         let mut frame_address: *word = unsafe {\n@@ -25,14 +25,14 @@ fn walk_stack(visit: fn(frame) -> bool) {\n         loop {\n             let fr = frame(frame_address);\n \n-            #debug(\"frame: %x\", unsafe { reinterpret_cast(fr.fp) });\n+            debug!{\"frame: %x\", unsafe { reinterpret_cast(fr.fp) }};\n             visit(fr);\n \n             unsafe {\n                 let next_fp: **word = reinterpret_cast(frame_address);\n                 frame_address = *next_fp;\n                 if *frame_address == 0u {\n-                    #debug(\"encountered task_start_wrapper. ending walk\");\n+                    debug!{\"encountered task_start_wrapper. ending walk\"};\n                     // This is the task_start_wrapper_frame. There is\n                     // no stack beneath it and it is a foreign frame.\n                     break;"}, {"sha": "6c443dc294afbfc7373ae65e80e6a03b5a9bb220", "filename": "src/libcore/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1461,7 +1461,7 @@ pure fn is_char_boundary(s: &str, index: uint) -> bool {\n  * let i = 0u;\n  * while i < str::len(s) {\n  *     let {ch, next} = str::char_range_at(s, i);\n- *     std::io::println(#fmt(\"%u: %c\",i,ch));\n+ *     std::io::println(fmt!{\"%u: %c\",i,ch});\n  *     i = next;\n  * }\n  * ~~~\n@@ -2141,7 +2141,7 @@ mod tests {\n         fn t(s: ~str, c: char, u: ~[~str]) {\n             log(debug, ~\"split_byte: \" + s);\n             let v = split_char(s, c);\n-            #debug(\"split_byte to: %?\", v);\n+            debug!{\"split_byte to: %?\", v};\n             assert vec::all2(v, u, |a,b| a == b);\n         }\n         t(~\"abc.hello.there\", '.', ~[~\"abc\", ~\"hello\", ~\"there\"]);\n@@ -2170,8 +2170,8 @@ mod tests {\n         fn t(s: ~str, c: char, n: uint, u: ~[~str]) {\n             log(debug, ~\"splitn_byte: \" + s);\n             let v = splitn_char(s, c, n);\n-            #debug(\"split_byte to: %?\", v);\n-            #debug(\"comparing vs. %?\", u);\n+            debug!{\"split_byte to: %?\", v};\n+            debug!{\"comparing vs. %?\", u};\n             assert vec::all2(v, u, |a,b| a == b);\n         }\n         t(~\"abc.hello.there\", '.', 0u, ~[~\"abc.hello.there\"]);"}, {"sha": "f71f991c9f8862d12baf4afe24fa15eacdf338b4", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -278,37 +278,37 @@ mod tests {\n         fn reccyeq(a: reccy, b: reccy) -> bool {\n             ret a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n         }\n-        #debug(\"*** test boxes\");\n+        debug!{\"*** test boxes\"};\n         test_boxes(@5, @72, @64, @175);\n-        #debug(\"*** end test boxes\");\n-        #debug(\"test parameterized: int\");\n+        debug!{\"*** end test boxes\"};\n+        debug!{\"test parameterized: int\"};\n         let eq1: eqfn<int> = inteq;\n         test_parameterized::<int>(eq1, 5, 72, 64, 175);\n-        #debug(\"*** test parameterized: @int\");\n+        debug!{\"*** test parameterized: @int\"};\n         let eq2: eqfn<@int> = intboxeq;\n         test_parameterized::<@int>(eq2, @5, @72, @64, @175);\n-        #debug(\"*** end test parameterized @int\");\n-        #debug(\"test parameterized: taggy\");\n+        debug!{\"*** end test parameterized @int\"};\n+        debug!{\"test parameterized: taggy\"};\n         let eq3: eqfn<taggy> = taggyeq;\n         test_parameterized::<taggy>(eq3, one(1), two(1, 2), three(1, 2, 3),\n                                     two(17, 42));\n \n-        #debug(\"*** test parameterized: taggypar<int>\");\n+        debug!{\"*** test parameterized: taggypar<int>\"};\n         let eq4: eqfn<taggypar<int>> = |x,y| taggypareq::<int>(x, y);\n         test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n                                             twopar::<int>(1, 2),\n                                             threepar::<int>(1, 2, 3),\n                                             twopar::<int>(17, 42));\n-        #debug(\"*** end test parameterized: taggypar::<int>\");\n+        debug!{\"*** end test parameterized: taggypar::<int>\"};\n \n-        #debug(\"*** test parameterized: reccy\");\n+        debug!{\"*** test parameterized: reccy\"};\n         let reccy1: reccy = {x: 1, y: 2, t: one(1)};\n         let reccy2: reccy = {x: 345, y: 2, t: two(1, 2)};\n         let reccy3: reccy = {x: 1, y: 777, t: three(1, 2, 3)};\n         let reccy4: reccy = {x: 19, y: 252, t: two(17, 42)};\n         let eq5: eqfn<reccy> = reccyeq;\n         test_parameterized::<reccy>(eq5, reccy1, reccy2, reccy3, reccy4);\n-        #debug(\"*** end test parameterized: reccy\");\n-        #debug(\"*** done\");\n+        debug!{\"*** end test parameterized: reccy\"};\n+        debug!{\"*** done\"};\n     }\n }"}, {"sha": "d5d1e70bc7b66df769981aa11d4f28d98d7ce83a", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -80,7 +80,7 @@ fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n                  (data[start + 2u] as uint) << 8u |\n                  (data[start + 3u] as uint),\n              next: start + 4u};\n-    } else { #error(\"vint too big\"); fail; }\n+    } else { error!{\"vint too big\"}; fail; }\n }\n \n fn doc(data: @~[u8]) -> doc {\n@@ -112,7 +112,7 @@ fn get_doc(d: doc, tg: uint) -> doc {\n     alt maybe_get_doc(d, tg) {\n       some(d) { ret d; }\n       none {\n-        #error(\"failed to find block with tag %u\", tg);\n+        error!{\"failed to find block with tag %u\", tg};\n         fail;\n       }\n     }\n@@ -200,7 +200,7 @@ fn write_sized_vuint(w: io::writer, n: uint, size: uint) {\n         w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                  (n >> 8_u) as u8, n as u8]);\n       }\n-      _ { fail #fmt(\"vint to write too big: %?\", n); }\n+      _ { fail fmt!{\"vint to write too big: %?\", n}; }\n     };\n }\n \n@@ -209,7 +209,7 @@ fn write_vuint(w: io::writer, n: uint) {\n     if n < 0x4000_u { write_sized_vuint(w, n, 2u); ret; }\n     if n < 0x200000_u { write_sized_vuint(w, n, 3u); ret; }\n     if n < 0x10000000_u { write_sized_vuint(w, n, 4u); ret; }\n-    fail #fmt(\"vint to write too big: %?\", n);\n+    fail fmt!{\"vint to write too big: %?\", n};\n }\n \n fn writer(w: io::writer) -> writer {\n@@ -220,7 +220,7 @@ fn writer(w: io::writer) -> writer {\n // FIXME (#2741): Provide a function to write the standard ebml header.\n impl writer for writer {\n     fn start_tag(tag_id: uint) {\n-        #debug[\"Start tag %u\", tag_id];\n+        debug!{\"Start tag %u\", tag_id};\n \n         // Write the enum ID:\n         write_vuint(self.writer, tag_id);\n@@ -239,7 +239,7 @@ impl writer for writer {\n         write_sized_vuint(self.writer, size, 4u);\n         self.writer.seek(cur_pos as int, io::seek_set);\n \n-        #debug[\"End tag (size = %u)\", size];\n+        debug!{\"End tag (size = %u)\", size};\n     }\n \n     fn wr_tag(tag_id: uint, blk: fn()) {\n@@ -309,12 +309,12 @@ impl writer for writer {\n     }\n \n     fn wr_bytes(b: &[u8]) {\n-        #debug[\"Write %u bytes\", vec::len(b)];\n+        debug!{\"Write %u bytes\", vec::len(b)};\n         self.writer.write(b);\n     }\n \n     fn wr_str(s: ~str) {\n-        #debug[\"Write str: %?\", s];\n+        debug!{\"Write str: %?\", s};\n         self.writer.write(str::bytes(s));\n     }\n }\n@@ -437,29 +437,29 @@ impl deserializer_priv for ebml_deserializer {\n                 self.pos = r_doc.end;\n                 let str = ebml::doc_as_str(r_doc);\n                 if lbl != str {\n-                    fail #fmt[\"Expected label %s but found %s\", lbl, str];\n+                    fail fmt!{\"Expected label %s but found %s\", lbl, str};\n                 }\n             }\n         }\n     }\n \n     fn next_doc(exp_tag: ebml_serializer_tag) -> ebml::doc {\n-        #debug[\". next_doc(exp_tag=%?)\", exp_tag];\n+        debug!{\". next_doc(exp_tag=%?)\", exp_tag};\n         if self.pos >= self.parent.end {\n             fail ~\"no more documents in current node!\";\n         }\n         let {tag: r_tag, doc: r_doc} =\n             ebml::doc_at(self.parent.data, self.pos);\n-        #debug[\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+        debug!{\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n                copy self.parent.start, copy self.parent.end,\n-               copy self.pos, r_tag, r_doc.start, r_doc.end];\n+               copy self.pos, r_tag, r_doc.start, r_doc.end};\n         if r_tag != (exp_tag as uint) {\n-            fail #fmt[\"expected EMBL doc with tag %? but found tag %?\",\n-                      exp_tag, r_tag];\n+            fail fmt!{\"expected EMBL doc with tag %? but found tag %?\",\n+                      exp_tag, r_tag};\n         }\n         if r_doc.end > self.parent.end {\n-            fail #fmt[\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n-                      r_doc.end, self.parent.end];\n+            fail fmt!{\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                      r_doc.end, self.parent.end};\n         }\n         self.pos = r_doc.end;\n         ret r_doc;\n@@ -478,7 +478,7 @@ impl deserializer_priv for ebml_deserializer {\n \n     fn _next_uint(exp_tag: ebml_serializer_tag) -> uint {\n         let r = ebml::doc_as_u32(self.next_doc(exp_tag));\n-        #debug[\"_next_uint exp_tag=%? result=%?\", exp_tag, r];\n+        debug!{\"_next_uint exp_tag=%? result=%?\", exp_tag, r};\n         ret r as uint;\n     }\n }\n@@ -493,7 +493,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n     fn read_uint() -> uint {\n         let v = ebml::doc_as_u64(self.next_doc(es_uint));\n         if v > (core::uint::max_value as u64) {\n-            fail #fmt[\"uint %? too large for this architecture\", v];\n+            fail fmt!{\"uint %? too large for this architecture\", v};\n         }\n         ret v as uint;\n     }\n@@ -505,7 +505,7 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n     fn read_int() -> int {\n         let v = ebml::doc_as_u64(self.next_doc(es_int)) as i64;\n         if v > (int::max_value as i64) || v < (int::min_value as i64) {\n-            fail #fmt[\"int %? out of range for this architecture\", v];\n+            fail fmt!{\"int %? out of range for this architecture\", v};\n         }\n         ret v as int;\n     }\n@@ -520,67 +520,67 @@ impl deserializer of serialization::deserializer for ebml_deserializer {\n \n     // Compound types:\n     fn read_enum<T:copy>(name: ~str, f: fn() -> T) -> T {\n-        #debug[\"read_enum(%s)\", name];\n+        debug!{\"read_enum(%s)\", name};\n         self._check_label(name);\n         self.push_doc(self.next_doc(es_enum), f)\n     }\n \n     fn read_enum_variant<T:copy>(f: fn(uint) -> T) -> T {\n-        #debug[\"read_enum_variant()\"];\n+        debug!{\"read_enum_variant()\"};\n         let idx = self._next_uint(es_enum_vid);\n-        #debug[\"  idx=%u\", idx];\n+        debug!{\"  idx=%u\", idx};\n         do self.push_doc(self.next_doc(es_enum_body)) {\n             f(idx)\n         }\n     }\n \n     fn read_enum_variant_arg<T:copy>(idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_enum_variant_arg(idx=%u)\", idx];\n+        debug!{\"read_enum_variant_arg(idx=%u)\", idx};\n         f()\n     }\n \n     fn read_vec<T:copy>(f: fn(uint) -> T) -> T {\n-        #debug[\"read_vec()\"];\n+        debug!{\"read_vec()\"};\n         do self.push_doc(self.next_doc(es_vec)) {\n             let len = self._next_uint(es_vec_len);\n-            #debug[\"  len=%u\", len];\n+            debug!{\"  len=%u\", len};\n             f(len)\n         }\n     }\n \n     fn read_vec_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_vec_elt(idx=%u)\", idx];\n+        debug!{\"read_vec_elt(idx=%u)\", idx};\n         self.push_doc(self.next_doc(es_vec_elt), f)\n     }\n \n     fn read_box<T:copy>(f: fn() -> T) -> T {\n-        #debug[\"read_box()\"];\n+        debug!{\"read_box()\"};\n         f()\n     }\n \n     fn read_uniq<T:copy>(f: fn() -> T) -> T {\n-        #debug[\"read_uniq()\"];\n+        debug!{\"read_uniq()\"};\n         f()\n     }\n \n     fn read_rec<T:copy>(f: fn() -> T) -> T {\n-        #debug[\"read_rec()\"];\n+        debug!{\"read_rec()\"};\n         f()\n     }\n \n     fn read_rec_field<T:copy>(f_name: ~str, f_idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_rec_field(%s, idx=%u)\", f_name, f_idx];\n+        debug!{\"read_rec_field(%s, idx=%u)\", f_name, f_idx};\n         self._check_label(f_name);\n         f()\n     }\n \n     fn read_tup<T:copy>(sz: uint, f: fn() -> T) -> T {\n-        #debug[\"read_tup(sz=%u)\", sz];\n+        debug!{\"read_tup(sz=%u)\", sz};\n         f()\n     }\n \n     fn read_tup_elt<T:copy>(idx: uint, f: fn() -> T) -> T {\n-        #debug[\"read_tup_elt(idx=%u)\", idx];\n+        debug!{\"read_tup_elt(idx=%u)\", idx};\n         f()\n     }\n }\n@@ -631,14 +631,14 @@ fn test_option_int() {\n     }\n \n     fn test_v(v: option<int>) {\n-        #debug[\"v == %?\", v];\n+        debug!{\"v == %?\", v};\n         let mbuf = io::mem_buffer();\n         let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n         serialize_0(ebml_w, v);\n         let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n         let deser = ebml_deserializer(ebml_doc);\n         let v1 = deserialize_0(deser);\n-        #debug[\"v1 == %?\", v1];\n+        debug!{\"v1 == %?\", v1};\n         assert v == v1;\n     }\n "}, {"sha": "3cafc11852585c330a9dd24e1425d3b109540aca", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -314,7 +314,7 @@ fn getopts(args: ~[~str], opts: ~[opt]) -> result unsafe {\n fn opt_vals(m: match, nm: ~str) -> ~[optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n-          none { #error(\"No option '%s' defined\", nm); fail }\n+          none { error!{\"No option '%s' defined\", nm}; fail }\n         };\n }\n "}, {"sha": "ee265269872e5256d81ddaf3a79243f7a8c577ce", "filename": "src/libstd/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -632,7 +632,7 @@ impl of to_str::to_str for json {\n \n impl of to_str::to_str for error {\n     fn to_str() -> ~str {\n-        #fmt(\"%u:%u: %s\", self.line, self.col, *self.msg)\n+        fmt!{\"%u:%u: %s\", self.line, self.col, *self.msg}\n     }\n }\n "}, {"sha": "c660adc527fd40690fffa79b28449927e6f2a9c4", "filename": "src/libstd/map.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -122,16 +122,16 @@ mod chained {\n             loop {\n                 alt copy e0.next {\n                   absent {\n-                    #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                           comp, h, idx);\n+                    debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n+                           comp, h, idx};\n                     ret not_found;\n                   }\n                   present(e1) {\n                     comp += 1u;\n                     if e1.hash == h && self.eqer(e1.key, k) {\n-                        #debug(\"search_tbl: present, comp %u, \\\n+                        debug!{\"search_tbl: present, comp %u, \\\n                                 hash %u, idx %u\",\n-                               comp, h, idx);\n+                               comp, h, idx};\n                         ret found_after(e0, e1);\n                     } else {\n                         e0 = e1;\n@@ -145,14 +145,14 @@ mod chained {\n             let idx = h % vec::len(self.chains);\n             alt copy self.chains[idx] {\n               absent {\n-                #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n-                       0u, h, idx);\n+                debug!{\"search_tbl: absent, comp %u, hash %u, idx %u\",\n+                       0u, h, idx};\n                 ret not_found;\n               }\n               present(e) {\n                 if e.hash == h && self.eqer(e.key, k) {\n-                    #debug(\"search_tbl: present, comp %u, hash %u, idx %u\",\n-                           1u, h, idx);\n+                    debug!{\"search_tbl: present, comp %u, hash %u, idx %u\",\n+                           1u, h, idx};\n                     ret found_first(idx, e);\n                 } else {\n                     ret self.search_rem(k, h, idx, e);\n@@ -248,7 +248,7 @@ mod chained {\n         fn get(k: K) -> V {\n             alt self.find(k) {\n               some(v) => {v}\n-              none => {fail #fmt[\"Key not found in table: %?\", k]}\n+              none => {fail fmt!{\"Key not found in table: %?\", k}}\n             }\n         }\n \n@@ -427,14 +427,14 @@ mod tests {\n \n     #[test]\n     fn test_simple() {\n-        #debug(\"*** starting test_simple\");\n+        debug!{\"*** starting test_simple\"};\n         fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n         fn uint_id(&&x: uint) -> uint { x }\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n         let hasher_str: map::hashfn<~str> = str::hash;\n         let eqer_str: map::eqfn<~str> = str::eq;\n-        #debug(\"uint -> uint\");\n+        debug!{\"uint -> uint\"};\n         let hm_uu: map::hashmap<uint, uint> =\n             map::hashmap::<uint, uint>(hasher_uint, eqer_uint);\n         assert (hm_uu.insert(10u, 12u));\n@@ -450,7 +450,7 @@ mod tests {\n         let ten: ~str = ~\"ten\";\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n-        #debug(\"str -> uint\");\n+        debug!{\"str -> uint\"};\n         let hm_su: map::hashmap<~str, uint> =\n             map::hashmap::<~str, uint>(hasher_str, eqer_str);\n         assert (hm_su.insert(~\"ten\", 12u));\n@@ -464,7 +464,7 @@ mod tests {\n         assert (hm_su.get(~\"twelve\") == 14u);\n         assert (!hm_su.insert(~\"twelve\", 12u));\n         assert (hm_su.get(~\"twelve\") == 12u);\n-        #debug(\"uint -> str\");\n+        debug!{\"uint -> str\"};\n         let hm_us: map::hashmap<uint, ~str> =\n             map::hashmap::<uint, ~str>(hasher_uint, eqer_uint);\n         assert (hm_us.insert(10u, ~\"twelve\"));\n@@ -477,7 +477,7 @@ mod tests {\n         assert (str::eq(hm_us.get(12u), ~\"fourteen\"));\n         assert (!hm_us.insert(12u, ~\"twelve\"));\n         assert (str::eq(hm_us.get(12u), ~\"twelve\"));\n-        #debug(\"str -> str\");\n+        debug!{\"str -> str\"};\n         let hm_ss: map::hashmap<~str, ~str> =\n             map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n@@ -490,7 +490,7 @@ mod tests {\n         assert (str::eq(hm_ss.get(~\"twelve\"), ~\"fourteen\"));\n         assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n         assert (str::eq(hm_ss.get(~\"twelve\"), ~\"twelve\"));\n-        #debug(\"*** finished test_simple\");\n+        debug!{\"*** finished test_simple\"};\n     }\n \n \n@@ -499,56 +499,56 @@ mod tests {\n     */\n     #[test]\n     fn test_growth() {\n-        #debug(\"*** starting test_growth\");\n+        debug!{\"*** starting test_growth\"};\n         let num_to_insert: uint = 64u;\n         fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n         fn uint_id(&&x: uint) -> uint { x }\n-        #debug(\"uint -> uint\");\n+        debug!{\"uint -> uint\"};\n         let hasher_uint: map::hashfn<uint> = uint_id;\n         let eqer_uint: map::eqfn<uint> = eq_uint;\n         let hm_uu: map::hashmap<uint, uint> =\n             map::hashmap::<uint, uint>(hasher_uint, eqer_uint);\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm_uu.insert(i, i * i));\n-            #debug(\"inserting %u -> %u\", i, i*i);\n+            debug!{\"inserting %u -> %u\", i, i*i};\n             i += 1u;\n         }\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n-            #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n+            debug!{\"get(%u) = %u\", i, hm_uu.get(i)};\n             assert (hm_uu.get(i) == i * i);\n             i += 1u;\n         }\n         assert (hm_uu.insert(num_to_insert, 17u));\n         assert (hm_uu.get(num_to_insert) == 17u);\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n-            #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n+            debug!{\"get(%u) = %u\", i, hm_uu.get(i)};\n             assert (hm_uu.get(i) == i * i);\n             i += 1u;\n         }\n-        #debug(\"str -> str\");\n+        debug!{\"str -> str\"};\n         let hasher_str: map::hashfn<~str> = str::hash;\n         let eqer_str: map::eqfn<~str> = str::eq;\n         let hm_ss: map::hashmap<~str, ~str> =\n             map::hashmap::<~str, ~str>(hasher_str, eqer_str);\n         i = 0u;\n         while i < num_to_insert {\n             assert hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u));\n-            #debug(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n+            debug!{\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n-                   uint::to_str(i*i, 2u));\n+                   uint::to_str(i*i, 2u)};\n             i += 1u;\n         }\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n-            #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n+            debug!{\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n-                   hm_ss.get(uint::to_str(i, 2u)));\n+                   hm_ss.get(uint::to_str(i, 2u))};\n             assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n                             uint::to_str(i * i, 2u)));\n             i += 1u;\n@@ -557,22 +557,22 @@ mod tests {\n                              uint::to_str(17u, 2u)));\n         assert (str::eq(hm_ss.get(uint::to_str(num_to_insert, 2u)),\n                         uint::to_str(17u, 2u)));\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n-            #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n+            debug!{\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str(i, 2u),\n-                   hm_ss.get(uint::to_str(i, 2u)));\n+                   hm_ss.get(uint::to_str(i, 2u))};\n             assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n                             uint::to_str(i * i, 2u)));\n             i += 1u;\n         }\n-        #debug(\"*** finished test_growth\");\n+        debug!{\"*** finished test_growth\"};\n     }\n \n     #[test]\n     fn test_removal() {\n-        #debug(\"*** starting test_removal\");\n+        debug!{\"*** starting test_removal\"};\n         let num_to_insert: uint = 64u;\n         fn eq(&&x: uint, &&y: uint) -> bool { ret x == y; }\n         fn hash(&&u: uint) -> uint {\n@@ -591,12 +591,12 @@ mod tests {\n         let mut i: uint = 0u;\n         while i < num_to_insert {\n             assert (hm.insert(i, i * i));\n-            #debug(\"inserting %u -> %u\", i, i*i);\n+            debug!{\"inserting %u -> %u\", i, i*i};\n             i += 1u;\n         }\n         assert (hm.size() == num_to_insert);\n-        #debug(\"-----\");\n-        #debug(\"removing evens\");\n+        debug!{\"-----\"};\n+        debug!{\"removing evens\"};\n         i = 0u;\n         while i < num_to_insert {\n             let v = hm.remove(i);\n@@ -607,44 +607,44 @@ mod tests {\n             i += 2u;\n         }\n         assert (hm.size() == num_to_insert / 2u);\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 1u;\n         while i < num_to_insert {\n-            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            debug!{\"get(%u) = %u\", i, hm.get(i)};\n             assert (hm.get(i) == i * i);\n             i += 2u;\n         }\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 1u;\n         while i < num_to_insert {\n-            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            debug!{\"get(%u) = %u\", i, hm.get(i)};\n             assert (hm.get(i) == i * i);\n             i += 2u;\n         }\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n             assert (hm.insert(i, i * i));\n-            #debug(\"inserting %u -> %u\", i, i*i);\n+            debug!{\"inserting %u -> %u\", i, i*i};\n             i += 2u;\n         }\n         assert (hm.size() == num_to_insert);\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         i = 0u;\n         while i < num_to_insert {\n-            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            debug!{\"get(%u) = %u\", i, hm.get(i)};\n             assert (hm.get(i) == i * i);\n             i += 1u;\n         }\n-        #debug(\"-----\");\n+        debug!{\"-----\"};\n         assert (hm.size() == num_to_insert);\n         i = 0u;\n         while i < num_to_insert {\n-            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            debug!{\"get(%u) = %u\", i, hm.get(i)};\n             assert (hm.get(i) == i * i);\n             i += 1u;\n         }\n-        #debug(\"*** finished test_removal\");\n+        debug!{\"*** finished test_removal\"};\n     }\n \n     #[test]"}, {"sha": "38b6d6194eb9b378d5be7e863712ede90ceba7ca", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -92,7 +92,7 @@ fn get_addr(++node: ~str, iotask: iotask)\n         -> result::result<~[ip_addr], ip_get_addr_err> unsafe {\n     do comm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| {\n-            log(debug, #fmt(\"slice len %?\", len));\n+            log(debug, fmt!{\"slice len %?\", len});\n             let handle = create_uv_getaddrinfo_t();\n             let handle_ptr = ptr::addr_of(handle);\n             let handle_data: get_addr_data = {\n@@ -167,10 +167,10 @@ mod v4 {\n             }\n         });\n         if vec::len(parts) != 4u {\n-                result::err(#fmt(\"'%s' doesn't have 4 parts\", ip))\n+                result::err(fmt!{\"'%s' doesn't have 4 parts\", ip})\n                 }\n         else if vec::contains(parts, 256u) {\n-                result::err(#fmt(\"invalid octal in addr '%s'\", ip))\n+                result::err(fmt!{\"invalid octal in addr '%s'\", ip})\n                 }\n         else {\n             result::ok({a: parts[0] as u8, b: parts[1] as u8,\n@@ -191,8 +191,8 @@ mod v4 {\n \n             let new_addr = uv_ip4_addr(ip, 22);\n             let reformatted_name = uv_ip4_name(&new_addr);\n-            log(debug, #fmt(\"try_parse_addr: input ip: %s reparsed ip: %s\",\n-                            ip, reformatted_name));\n+            log(debug, fmt!{\"try_parse_addr: input ip: %s reparsed ip: %s\",\n+                            ip, reformatted_name});\n             let ref_ip_rep_result = parse_to_ipv4_rep(reformatted_name);\n             if result::is_err(ref_ip_rep_result) {\n                 let err_str = result::get_err(ref_ip_rep_result);\n@@ -238,13 +238,13 @@ mod v6 {\n             // need to figure out how to establish a parse failure..\n             let new_addr = uv_ip6_addr(ip, 22);\n             let reparsed_name = uv_ip6_name(&new_addr);\n-            log(debug, #fmt(\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n-                            ip, reparsed_name));\n+            log(debug, fmt!{\"v6::try_parse_addr ip: '%s' reparsed '%s'\",\n+                            ip, reparsed_name});\n             // '::' appears to be uv_ip6_name() returns for bogus\n             // parses..\n             if  ip != ~\"::\" && reparsed_name == ~\"::\" {\n-                result::err({err_msg:#fmt(\"failed to parse '%s'\",\n-                                           ip)})\n+                result::err({err_msg:fmt!{\"failed to parse '%s'\",\n+                                           ip}})\n             }\n             else {\n                 result::ok(ipv6(new_addr))\n@@ -265,7 +265,7 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n     if status == 0i32 {\n         if res != (ptr::null::<addrinfo>()) {\n             let mut out_vec = ~[];\n-            log(debug, #fmt(\"initial addrinfo: %?\", res));\n+            log(debug, fmt!{\"initial addrinfo: %?\", res});\n             let mut curr_addr = res;\n             loop {\n                 let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n@@ -292,11 +292,11 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,\n                 }\n                 else {\n                     curr_addr = next_addr;\n-                    log(debug, #fmt(\"next_addr addrinfo: %?\", curr_addr));\n+                    log(debug, fmt!{\"next_addr addrinfo: %?\", curr_addr});\n                 }\n             }\n-            log(debug, #fmt(\"successful process addrinfo result, len: %?\",\n-                            vec::len(out_vec)));\n+            log(debug, fmt!{\"successful process addrinfo result, len: %?\",\n+                            vec::len(out_vec)});\n             (*handle_data).output_ch.send(result::ok(out_vec));\n         }\n         else {\n@@ -328,19 +328,19 @@ mod test {\n     fn test_ip_ipv6_parse_and_format_ip() {\n         let localhost_str = ~\"::1\";\n         let format_result = format_addr(v6::parse_addr(localhost_str));\n-        log(debug, #fmt(\"results: expected: '%s' actual: '%s'\",\n-            localhost_str, format_result));\n+        log(debug, fmt!{\"results: expected: '%s' actual: '%s'\",\n+            localhost_str, format_result});\n         assert format_result == localhost_str;\n     }\n     #[test]\n     fn test_ip_ipv4_bad_parse() {\n         alt v4::try_parse_addr(~\"b4df00d\") {\n           result::err(err_info) {\n-            log(debug, #fmt(\"got error as expected %?\", err_info));\n+            log(debug, fmt!{\"got error as expected %?\", err_info});\n             assert true;\n           }\n           result::ok(addr) {\n-            fail #fmt(\"Expected failure, but got addr %?\", addr);\n+            fail fmt!{\"Expected failure, but got addr %?\", addr};\n           }\n         }\n     }\n@@ -349,11 +349,11 @@ mod test {\n     fn test_ip_ipv6_bad_parse() {\n         alt v6::try_parse_addr(~\"::,~2234k;\") {\n           result::err(err_info) {\n-            log(debug, #fmt(\"got error as expected %?\", err_info));\n+            log(debug, fmt!{\"got error as expected %?\", err_info});\n             assert true;\n           }\n           result::ok(addr) {\n-            fail #fmt(\"Expected failure, but got addr %?\", addr);\n+            fail fmt!{\"Expected failure, but got addr %?\", addr};\n           }\n         }\n     }\n@@ -369,8 +369,8 @@ mod test {\n         // note really sure how to realiably test/assert\n         // this.. mostly just wanting to see it work, atm.\n         let results = result::unwrap(ga_result);\n-        log(debug, #fmt(\"test_get_addr: Number of results for %s: %?\",\n-                        localhost_name, vec::len(results)));\n+        log(debug, fmt!{\"test_get_addr: Number of results for %s: %?\",\n+                        localhost_name, vec::len(results)});\n         for vec::each(results) |r| {\n             let ipv_prefix = alt r {\n               ipv4(_) {\n@@ -380,8 +380,8 @@ mod test {\n                 ~\"IPv6\"\n               }\n             };\n-            log(debug, #fmt(\"test_get_addr: result %s: '%s'\",\n-                            ipv_prefix, format_addr(r)));\n+            log(debug, fmt!{\"test_get_addr: result %s: '%s'\",\n+                            ipv_prefix, format_addr(r)});\n         }\n         // at least one result.. this is going to vary from system\n         // to system, based on stuff like the contents of /etc/hosts"}, {"sha": "d70d9b40de8a38460bbe9003ed26d2c8912c469b", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -142,15 +142,15 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n         iotask: iotask\n     };\n     let socket_data_ptr = ptr::addr_of(*socket_data);\n-    log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n+    log(debug, fmt!{\"tcp_connect result_ch %?\", conn_data.result_ch});\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n-    log(debug, #fmt(\"stream_handle_ptr outside interact %?\",\n-        stream_handle_ptr));\n+    log(debug, fmt!{\"stream_handle_ptr outside interact %?\",\n+        stream_handle_ptr});\n     do iotask::interact(iotask) |loop_ptr| {\n         log(debug, ~\"in interact cb for tcp client connect..\");\n-        log(debug, #fmt(\"stream_handle_ptr in interact %?\",\n-            stream_handle_ptr));\n+        log(debug, fmt!{\"stream_handle_ptr in interact %?\",\n+            stream_handle_ptr});\n         alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n           0i32 {\n             log(debug, ~\"tcp_init successful\");\n@@ -167,7 +167,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                     // info.. should probably add an additional\n                     // rust type that actually is closer to\n                     // what the libuv API expects (ip str + port num)\n-                    log(debug, #fmt(\"addr: %?\", addr));\n+                    log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n                     uv::ll::tcp_connect(\n                         connect_req_ptr,\n@@ -176,7 +176,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                         tcp_connect_on_connect_cb)\n                   }\n                   ip::ipv6(addr) {\n-                    log(debug, #fmt(\"addr: %?\", addr));\n+                    log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_connect6(\n                         connect_req_ptr,\n@@ -334,7 +334,7 @@ fn read_start(sock: tcp_socket)\n fn read_stop(sock: tcp_socket,\n              -read_port: comm::port<result::result<~[u8], tcp_err_data>>) ->\n     result::result<(), tcp_err_data> unsafe {\n-    log(debug, #fmt(\"taking the read_port out of commission %?\", read_port));\n+    log(debug, fmt!{\"taking the read_port out of commission %?\", read_port});\n     let socket_data = ptr::addr_of(*sock.socket_data);\n     read_stop_common_impl(socket_data)\n }\n@@ -622,13 +622,13 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                 let addr_str = ip::format_addr(loc_ip);\n                 let bind_result = alt loc_ip {\n                   ip::ipv4(addr) {\n-                    log(debug, #fmt(\"addr: %?\", addr));\n+                    log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip4_addr(addr_str, port as int);\n                     uv::ll::tcp_bind(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n                   }\n                   ip::ipv6(addr) {\n-                    log(debug, #fmt(\"addr: %?\", addr));\n+                    log(debug, fmt!{\"addr: %?\", addr});\n                     let in_addr = uv::ll::ip6_addr(addr_str, port as int);\n                     uv::ll::tcp_bind6(server_stream_ptr,\n                                      ptr::addr_of(in_addr))\n@@ -668,8 +668,8 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n     alt setup_result {\n       some(err_data) {\n         do iotask::interact(iotask) |loop_ptr| {\n-            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr));\n+            log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr});\n             (*server_data_ptr).active = false;\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n@@ -684,8 +684,8 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n             result::err(address_in_use)\n           }\n           _ {\n-            log(debug, #fmt(\"Got '%s' '%s' libuv error\",\n-                            err_data.err_name, err_data.err_msg));\n+            log(debug, fmt!{\"Got '%s' '%s' libuv error\",\n+                            err_data.err_name, err_data.err_msg});\n             result::err(\n                 generic_listen_err(err_data.err_name, err_data.err_msg))\n           }\n@@ -695,8 +695,8 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n         on_establish_cb(kill_ch);\n         let kill_result = comm::recv(kill_po);\n         do iotask::interact(iotask) |loop_ptr| {\n-            log(debug, #fmt(\"tcp::listen post-kill recv hl interact %?\",\n-                            loop_ptr));\n+            log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n+                            loop_ptr});\n             (*server_data_ptr).active = false;\n             uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n         };\n@@ -776,8 +776,8 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n                 if err_data.err_name == ~\"EOF\" {\n                     break;\n                 } else {\n-                    #debug(\"ERROR sock_buf as io::reader.read err %? %?\",\n-                           err_data.err_name, err_data.err_msg);\n+                    debug!{\"ERROR sock_buf as io::reader.read err %? %?\",\n+                           err_data.err_name, err_data.err_msg};\n \n                     ret 0;\n                 }\n@@ -809,7 +809,7 @@ impl tcp_socket_buf of io::reader for @tcp_socket_buf {\n         false // noop\n     }\n     fn seek(dist: int, seek: io::seek_style) {\n-        log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+        log(debug, fmt!{\"tcp_socket_buf seek stub %? %?\", dist, seek});\n         // noop\n     }\n     fn tell() -> uint {\n@@ -826,12 +826,12 @@ impl tcp_socket_buf of io::writer for @tcp_socket_buf {\n                                         vec::slice(data, 0, vec::len(data)));\n         if w_result.is_err() {\n             let err_data = w_result.get_err();\n-            log(debug, #fmt(\"ERROR sock_buf as io::writer.writer err: %? %?\",\n-                             err_data.err_name, err_data.err_msg));\n+            log(debug, fmt!{\"ERROR sock_buf as io::writer.writer err: %? %?\",\n+                             err_data.err_name, err_data.err_msg});\n         }\n     }\n     fn seek(dist: int, seek: io::seek_style) {\n-      log(debug, #fmt(\"tcp_socket_buf seek stub %? %?\", dist, seek));\n+      log(debug, fmt!{\"tcp_socket_buf seek stub %? %?\", dist, seek});\n         // noop\n     }\n     fn tell() -> uint {\n@@ -856,14 +856,14 @@ fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n     let close_data_ptr = ptr::addr_of(close_data);\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n-        log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n-            stream_handle_ptr, loop_ptr));\n+        log(debug, fmt!{\"interact dtor for tcp_socket stream %? loop %?\",\n+            stream_handle_ptr, loop_ptr});\n         uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                        close_data_ptr);\n         uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n     };\n     comm::recv(closed_po);\n-    log(debug, #fmt(\"about to free socket_data at %?\", socket_data));\n+    log(debug, fmt!{\"about to free socket_data at %?\", socket_data});\n     rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                        as *libc::c_void);\n     log(debug, ~\"exiting dtor for tcp_socket\");\n@@ -946,7 +946,7 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     let start_ch = comm::chan(start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n-        log(debug, #fmt(\"in tcp::read_start interact cb %?\", loop_ptr));\n+        log(debug, fmt!{\"in tcp::read_start interact cb %?\", loop_ptr});\n         alt uv::ll::read_start(stream_handle_ptr as *uv::ll::uv_stream_t,\n                                on_alloc_cb,\n                                on_tcp_read_cb) {\n@@ -990,7 +990,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     };\n     let write_data_ptr = ptr::addr_of(write_data);\n     do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n-        log(debug, #fmt(\"in interact cb for tcp::write %?\", loop_ptr));\n+        log(debug, fmt!{\"in interact cb for tcp::write %?\", loop_ptr});\n         alt uv::ll::write(write_req_ptr,\n                           stream_handle_ptr,\n                           write_buf_vec_ptr,\n@@ -1096,17 +1096,17 @@ impl of to_tcp_err_iface for uv::ll::uv_err_data {\n extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n                     nread: libc::ssize_t,\n                     ++buf: uv::ll::uv_buf_t) unsafe {\n-    log(debug, #fmt(\"entering on_tcp_read_cb stream: %? nread: %?\",\n-                    stream, nread));\n+    log(debug, fmt!{\"entering on_tcp_read_cb stream: %? nread: %?\",\n+                    stream, nread});\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n     let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n         as *tcp_socket_data;\n     alt nread as int {\n       // incoming err.. probably eof\n       -1 {\n         let err_data = uv::ll::get_last_err_data(loop_ptr).to_tcp_err();\n-        log(debug, #fmt(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n-                        err_data.err_name, err_data.err_msg));\n+        log(debug, fmt!{\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n+                        err_data.err_name, err_data.err_msg});\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         comm::send(reader_ch, result::err(err_data));\n       }\n@@ -1115,7 +1115,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n       // have data\n       _ {\n         // we have data\n-        log(debug, #fmt(\"tcp on_read_cb nread: %d\", nread as int));\n+        log(debug, fmt!{\"tcp on_read_cb nread: %d\", nread as int});\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let new_bytes = vec::unsafe::from_buf(buf_base, nread as uint);\n@@ -1131,10 +1131,10 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n     -> uv::ll::uv_buf_t unsafe {\n     log(debug, ~\"tcp read on_alloc_cb!\");\n     let char_ptr = uv::ll::malloc_buf_base_of(suggested_size);\n-    log(debug, #fmt(\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+    log(debug, fmt!{\"tcp read on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                      handle,\n                      char_ptr as uint,\n-                     suggested_size as uint));\n+                     suggested_size as uint});\n     uv::ll::buf_init(char_ptr, suggested_size as uint)\n }\n \n@@ -1180,19 +1180,19 @@ extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle) as\n         *connect_req_data;\n     comm::send((*data).closed_signal_ch, ());\n-    log(debug, #fmt(\"exiting steam_error_close_cb for %?\", handle));\n+    log(debug, fmt!{\"exiting steam_error_close_cb for %?\", handle});\n }\n \n extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n-    log(debug, #fmt(\"closed client tcp handle %?\", handle));\n+    log(debug, fmt!{\"closed client tcp handle %?\", handle});\n }\n \n extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n                                    status: libc::c_int) unsafe {\n     let conn_data_ptr = (uv::ll::get_data_for_req(connect_req_ptr)\n                       as *connect_req_data);\n     let result_ch = (*conn_data_ptr).result_ch;\n-    log(debug, #fmt(\"tcp_connect result_ch %?\", result_ch));\n+    log(debug, fmt!{\"tcp_connect result_ch %?\", result_ch});\n     let tcp_stream_ptr =\n         uv::ll::get_stream_handle_from_connect_req(connect_req_ptr);\n     alt status {\n@@ -1204,8 +1204,8 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n         log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-        log(debug, #fmt(\"err_data %? %?\", err_data.err_name,\n-                        err_data.err_msg));\n+        log(debug, fmt!{\"err_data %? %?\", err_data.err_name,\n+                        err_data.err_msg});\n         comm::send(result_ch, conn_failure(err_data));\n         uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n                                        conn_data_ptr);\n@@ -1334,10 +1334,10 @@ mod test {\n         assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n         let actual_req = comm::recv(server_result_po);\n-        log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req));\n-        log(debug, #fmt(\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp));\n+        log(debug, fmt!{\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req});\n+        log(debug, fmt!{\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp});\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n@@ -1476,27 +1476,27 @@ mod test {\n         };\n \n         let actual_req = comm::recv(server_result_po);\n-        log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n-                       expected_req, actual_req));\n-        log(debug, #fmt(\"RESP: expected: '%s' actual: '%s'\",\n-                       expected_resp, actual_resp));\n+        log(debug, fmt!{\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req});\n+        log(debug, fmt!{\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp});\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n \n     fn buf_write(+w: io::writer, val: ~str) {\n-        log(debug, #fmt(\"BUF_WRITE: val len %?\", str::len(val)));\n+        log(debug, fmt!{\"BUF_WRITE: val len %?\", str::len(val)});\n         do str::byte_slice(val) |b_slice| {\n-            log(debug, #fmt(\"BUF_WRITE: b_slice len %?\",\n-                            vec::len(b_slice)));\n+            log(debug, fmt!{\"BUF_WRITE: b_slice len %?\",\n+                            vec::len(b_slice)});\n             w.write(b_slice)\n         }\n     }\n \n     fn buf_read(+r: io::reader, len: uint) -> ~str {\n         let new_bytes = r.read_bytes(len);\n-        log(debug, #fmt(\"in buf_read.. new_bytes len: %?\",\n-                        vec::len(new_bytes)));\n+        log(debug, fmt!{\"in buf_read.. new_bytes len: %?\",\n+                        vec::len(new_bytes)});\n         str::from_bytes(new_bytes)\n     }\n \n@@ -1508,8 +1508,8 @@ mod test {\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                log(debug, #fmt(\"establish_cb %?\",\n-                    kill_ch));\n+                log(debug, fmt!{\"establish_cb %?\",\n+                    kill_ch});\n                 comm::send(cont_ch, ());\n             },\n             // risky to run this on the loop, but some users\n@@ -1541,8 +1541,8 @@ mod test {\n                         alt received_req_bytes {\n                           result::ok(data) {\n                             log(debug, ~\"SERVER: got REQ str::from_bytes..\");\n-                            log(debug, #fmt(\"SERVER: REQ data len: %?\",\n-                                            vec::len(data)));\n+                            log(debug, fmt!{\"SERVER: REQ data len: %?\",\n+                                            vec::len(data)});\n                             server_ch.send(\n                                 str::from_bytes(data));\n                             log(debug, ~\"SERVER: before write\");\n@@ -1551,8 +1551,8 @@ mod test {\n                             comm::send(kill_ch, none);\n                           }\n                           result::err(err_data) {\n-                            log(debug, #fmt(\"SERVER: error recvd: %s %s\",\n-                                err_data.err_name, err_data.err_msg));\n+                            log(debug, fmt!{\"SERVER: error recvd: %s %s\",\n+                                err_data.err_name, err_data.err_msg});\n                             comm::send(kill_ch, some(err_data));\n                             server_ch.send(~\"\");\n                           }\n@@ -1569,8 +1569,8 @@ mod test {\n         if result::is_err(listen_result) {\n             alt result::get_err(listen_result) {\n               generic_listen_err(name, msg) {\n-                fail #fmt(\"SERVER: exited abnormally name %s msg %s\",\n-                                name, msg);\n+                fail fmt!{\"SERVER: exited abnormally name %s msg %s\",\n+                                name, msg};\n               }\n               access_denied {\n                 fail ~\"SERVER: exited abnormally, got access denied..\";\n@@ -1581,7 +1581,7 @@ mod test {\n             }\n         }\n         let ret_val = server_ch.recv();\n-        log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n+        log(debug, fmt!{\"SERVER: exited and got ret val: '%s'\", ret_val});\n         ret_val\n     }\n \n@@ -1591,12 +1591,12 @@ mod test {\n         let listen_result = listen(server_ip_addr, server_port, 128u, iotask,\n             // on_establish_cb -- called when listener is set up\n             |kill_ch| {\n-                log(debug, #fmt(\"establish_cb %?\",\n-                    kill_ch));\n+                log(debug, fmt!{\"establish_cb %?\",\n+                    kill_ch});\n             },\n             |new_conn, kill_ch| {\n-                fail #fmt(\"SERVER: shouldn't be called.. %? %?\",\n-                           new_conn, kill_ch);\n+                fail fmt!{\"SERVER: shouldn't be called.. %? %?\",\n+                           new_conn, kill_ch};\n         });\n         // err check on listen_result\n         if result::is_err(listen_result) {\n@@ -1632,8 +1632,8 @@ mod test {\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n                 let ret_val = client_ch.recv();\n-                log(debug, #fmt(\"CLIENT: after client_ch recv ret: '%s'\",\n-                   ret_val));\n+                log(debug, fmt!{\"CLIENT: after client_ch recv ret: '%s'\",\n+                   ret_val});\n                 ok(ret_val)\n             }\n         }\n@@ -1645,8 +1645,8 @@ mod test {\n         if result::is_err(write_result) {\n             log(debug, ~\"tcp_write_single: write failed!\");\n             let err_data = result::get_err(write_result);\n-            log(debug, #fmt(\"tcp_write_single err name: %s msg: %s\",\n-                err_data.err_name, err_data.err_msg));\n+            log(debug, fmt!{\"tcp_write_single err name: %s msg: %s\",\n+                err_data.err_name, err_data.err_msg});\n             // meh. torn on what to do here.\n             fail ~\"tcp_write_single failed\";\n         }"}, {"sha": "928f8bc9399fc9bada7450a74bada92821cddef3", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -72,7 +72,7 @@ fn query_to_str(query: query) -> ~str {\n     let mut strvec = ~[];\n     for query.each |kv| {\n         let (k, v) = kv;\n-        strvec += ~[#fmt(\"%s=%s\", k, v)];\n+        strvec += ~[fmt!{\"%s=%s\", k, v}];\n     };\n     ret str::connect(strvec, ~\"&\");\n }"}, {"sha": "65aa077ef87b2361744b5f7cb0bee3e789cedd3b", "filename": "src/libstd/par.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -53,11 +53,11 @@ fn map_slices<A: copy send, B: copy send>(\n                         let len = end - base;\n                         let slice = (ptr::offset(p, base),\n                                      len * sys::size_of::<A>());\n-                        log(info, #fmt(\"pre-slice: %?\", (base, slice)));\n+                        log(info, fmt!{\"pre-slice: %?\", (base, slice)});\n                         let slice : &[A] =\n                             unsafe::reinterpret_cast(slice);\n-                        log(info, #fmt(\"slice: %?\",\n-                                       (base, vec::len(slice), end - base)));\n+                        log(info, fmt!{\"slice: %?\",\n+                                       (base, vec::len(slice), end - base)});\n                         assert(vec::len(slice) == end - base);\n                         f(base, slice)\n                     }\n@@ -68,7 +68,7 @@ fn map_slices<A: copy send, B: copy send>(\n         }\n         log(info, ~\"tasks spawned\");\n \n-        log(info, #fmt(\"num_tasks: %?\", (num_tasks, futures.len())));\n+        log(info, fmt!{\"num_tasks: %?\", (num_tasks, futures.len())});\n         assert(num_tasks == futures.len());\n \n         let r = do futures.map() |ys| {"}, {"sha": "6122474c06d50b655773d92e85b6fe219a81e79e", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -8,63 +8,63 @@ impl of serializer for writer {\n     }\n \n     fn emit_uint(v: uint) {\n-        self.write_str(#fmt[\"%?u\", v]);\n+        self.write_str(fmt!{\"%?u\", v});\n     }\n \n     fn emit_u64(v: u64) {\n-        self.write_str(#fmt[\"%?_u64\", v]);\n+        self.write_str(fmt!{\"%?_u64\", v});\n     }\n \n     fn emit_u32(v: u32) {\n-        self.write_str(#fmt[\"%?_u32\", v]);\n+        self.write_str(fmt!{\"%?_u32\", v});\n     }\n \n     fn emit_u16(v: u16) {\n-        self.write_str(#fmt[\"%?_u16\", v]);\n+        self.write_str(fmt!{\"%?_u16\", v});\n     }\n \n     fn emit_u8(v: u8) {\n-        self.write_str(#fmt[\"%?_u8\", v]);\n+        self.write_str(fmt!{\"%?_u8\", v});\n     }\n \n     fn emit_int(v: int) {\n-        self.write_str(#fmt[\"%?\", v]);\n+        self.write_str(fmt!{\"%?\", v});\n     }\n \n     fn emit_i64(v: i64) {\n-        self.write_str(#fmt[\"%?_i64\", v]);\n+        self.write_str(fmt!{\"%?_i64\", v});\n     }\n \n     fn emit_i32(v: i32) {\n-        self.write_str(#fmt[\"%?_i32\", v]);\n+        self.write_str(fmt!{\"%?_i32\", v});\n     }\n \n     fn emit_i16(v: i16) {\n-        self.write_str(#fmt[\"%?_i16\", v]);\n+        self.write_str(fmt!{\"%?_i16\", v});\n     }\n \n     fn emit_i8(v: i8) {\n-        self.write_str(#fmt[\"%?_i8\", v]);\n+        self.write_str(fmt!{\"%?_i8\", v});\n     }\n \n     fn emit_bool(v: bool) {\n-        self.write_str(#fmt[\"%b\", v]);\n+        self.write_str(fmt!{\"%b\", v});\n     }\n \n     fn emit_float(v: float) {\n-        self.write_str(#fmt[\"%?_f\", v]);\n+        self.write_str(fmt!{\"%?_f\", v});\n     }\n \n     fn emit_f64(v: f64) {\n-        self.write_str(#fmt[\"%?_f64\", v]);\n+        self.write_str(fmt!{\"%?_f64\", v});\n     }\n \n     fn emit_f32(v: f32) {\n-        self.write_str(#fmt[\"%?_f32\", v]);\n+        self.write_str(fmt!{\"%?_f32\", v});\n     }\n \n     fn emit_str(v: ~str) {\n-        self.write_str(#fmt[\"%?\", v]);\n+        self.write_str(fmt!{\"%?\", v});\n     }\n \n     fn emit_enum(_name: ~str, f: fn()) {"}, {"sha": "37f829396ab250e2b281a75258d42a1c0ba88a74", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -27,7 +27,7 @@ fn mk<T: copy>() -> smallintmap<T> {\n  */\n #[inline(always)]\n fn insert<T: copy>(self: smallintmap<T>, key: uint, val: T) {\n-    //io::println(#fmt(\"%?\", key));\n+    //io::println(fmt!{\"%?\", key});\n     self.v.grow_set_elt(key, none, some(val));\n }\n \n@@ -49,7 +49,7 @@ pure fn find<T: copy>(self: smallintmap<T>, key: uint) -> option<T> {\n  */\n pure fn get<T: copy>(self: smallintmap<T>, key: uint) -> T {\n     alt find(self, key) {\n-      none { #error(\"smallintmap::get(): key not present\"); fail; }\n+      none { error!{\"smallintmap::get(): key not present\"}; fail; }\n       some(v) { ret v; }\n     }\n }"}, {"sha": "95dbf5f97dccf361ac4dc6731ab1da7e423a2f81", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -253,7 +253,7 @@ mod test_qsort {\n         let pairs = vec::zip(expected, immut_names);\n         for vec::each(pairs) |p| {\n             let (a, b) = p;\n-            #debug(\"%d %d\", a, b);\n+            debug!{\"%d %d\", a, b};\n             assert (a == b);\n         }\n     }"}, {"sha": "f9e4f94ed80ffbfdd1e411b099cf13ed326ad34d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -109,9 +109,9 @@ fn run_tests_console(opts: test_opts,\n           te_filtered(filtered_tests) {\n             st.total = vec::len(filtered_tests);\n             let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n-            st.out.write_line(#fmt[\"\\nrunning %u %s\", st.total, noun]);\n+            st.out.write_line(fmt!{\"\\nrunning %u %s\", st.total, noun});\n           }\n-          te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n+          te_wait(test) { st.out.write_str(fmt!{\"test %s ... \", test.name}); }\n           te_result(test, result) {\n             alt st.log_out {\n                 some(f) {\n@@ -146,7 +146,7 @@ fn run_tests_console(opts: test_opts,\n             alt io::file_writer(path, ~[io::create, io::truncate]) {\n                 result::ok(w) { some(w) }\n                 result::err(s) {\n-                    fail(#fmt(\"can't open output file: %s\", s))\n+                    fail(fmt!{\"can't open output file: %s\", s})\n                 }\n             }\n         }\n@@ -172,23 +172,23 @@ fn run_tests_console(opts: test_opts,\n         print_failures(st);\n     }\n \n-    st.out.write_str(#fmt[\"\\nresult: \"]);\n+    st.out.write_str(fmt!{\"\\nresult: \"});\n     if success {\n         // There's no parallelism at this point so it's safe to use color\n         write_ok(st.out, true);\n     } else { write_failed(st.out, true); }\n-    st.out.write_str(#fmt[\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n-                          st.failed, st.ignored]);\n+    st.out.write_str(fmt!{\". %u passed; %u failed; %u ignored\\n\\n\", st.passed,\n+                          st.failed, st.ignored});\n \n     ret success;\n \n     fn write_log(out: io::writer, result: test_result, test: test_desc) {\n-        out.write_line(#fmt(\"%s %s\",\n+        out.write_line(fmt!{\"%s %s\",\n                     alt result {\n                         tr_ok { ~\"ok\" }\n                         tr_failed { ~\"failed\" }\n                         tr_ignored { ~\"ignored\" }\n-                    }, test.name));\n+                    }, test.name});\n     }\n \n     fn write_ok(out: io::writer, use_color: bool) {\n@@ -220,7 +220,7 @@ fn print_failures(st: console_test_state) {\n     let failures = vec::map(failures, |test| test.name);\n     let failures = sort::merge_sort(str::le, failures);\n     for vec::each(failures) |name| {\n-        st.out.write_line(#fmt[\"    %s\", name]);\n+        st.out.write_line(fmt!{\"    %s\", name});\n     }\n }\n \n@@ -281,7 +281,7 @@ fn run_tests(opts: test_opts, tests: ~[test_desc],\n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n-    #debug(\"using %u test tasks\", concurrency);\n+    debug!{\"using %u test tasks\", concurrency};\n \n     let total = vec::len(filtered_tests);\n     let mut run_idx = 0u;"}, {"sha": "7cbf16f2ec0f9dedf66fefd504122f424071cc5f", "filename": "src/libstd/time.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -200,9 +200,9 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n         if c == ch {\n             ok(next)\n         } else {\n-            err(#fmt(\"Expected %?, found %?\",\n+            err(fmt!{\"Expected %?, found %?\",\n                 str::from_char(c),\n-                str::from_char(ch)))\n+                str::from_char(ch)})\n         }\n     }\n \n@@ -525,7 +525,7 @@ fn strptime(s: ~str, format: ~str) -> result<tm, ~str> {\n           }\n           '%' { parse_char(s, pos, '%') }\n           ch {\n-            err(#fmt(\"unknown formatting type: %?\", str::from_char(ch)))\n+            err(fmt!{\"unknown formatting type: %?\", str::from_char(ch)})\n           }\n         }\n     }\n@@ -643,70 +643,70 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n               11 { ~\"Dec\" }\n             }\n           }\n-          'C' { #fmt(\"%02d\", (tm.tm_year as int + 1900) / 100) }\n+          'C' { fmt!{\"%02d\", (tm.tm_year as int + 1900) / 100} }\n           'c' {\n-            #fmt(\"%s %s %s %s %s\",\n+            fmt!{\"%s %s %s %s %s\",\n                 parse_type('a', tm),\n                 parse_type('b', tm),\n                 parse_type('e', tm),\n                 parse_type('T', tm),\n-                parse_type('Y', tm))\n+                parse_type('Y', tm)}\n           }\n           'D' | 'x' {\n-            #fmt(\"%s/%s/%s\",\n+            fmt!{\"%s/%s/%s\",\n                 parse_type('m', tm),\n                 parse_type('d', tm),\n-                parse_type('y', tm))\n+                parse_type('y', tm)}\n           }\n-          'd' { #fmt(\"%02d\", tm.tm_mday as int) }\n-          'e' { #fmt(\"%2d\", tm.tm_mday as int) }\n+          'd' { fmt!{\"%02d\", tm.tm_mday as int} }\n+          'e' { fmt!{\"%2d\", tm.tm_mday as int} }\n           'F' {\n-            #fmt(\"%s-%s-%s\",\n+            fmt!{\"%s-%s-%s\",\n                 parse_type('Y', tm),\n                 parse_type('m', tm),\n-                parse_type('d', tm))\n+                parse_type('d', tm)}\n           }\n           //'G' {}\n           //'g' {}\n-          'H' { #fmt(\"%02d\", tm.tm_hour as int) }\n+          'H' { fmt!{\"%02d\", tm.tm_hour as int} }\n           'I' {\n             let mut h = tm.tm_hour as int;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            #fmt(\"%02d\", h)\n+            fmt!{\"%02d\", h}\n           }\n-          'j' { #fmt(\"%03d\", tm.tm_yday as int + 1) }\n-          'k' { #fmt(\"%2d\", tm.tm_hour as int) }\n+          'j' { fmt!{\"%03d\", tm.tm_yday as int + 1} }\n+          'k' { fmt!{\"%2d\", tm.tm_hour as int} }\n           'l' {\n             let mut h = tm.tm_hour as int;\n             if h == 0 { h = 12 }\n             if h > 12 { h -= 12 }\n-            #fmt(\"%2d\", h)\n+            fmt!{\"%2d\", h}\n           }\n-          'M' { #fmt(\"%02d\", tm.tm_min as int) }\n-          'm' { #fmt(\"%02d\", tm.tm_mon as int + 1) }\n+          'M' { fmt!{\"%02d\", tm.tm_min as int} }\n+          'm' { fmt!{\"%02d\", tm.tm_mon as int + 1} }\n           'n' { ~\"\\n\" }\n           'P' { if tm.tm_hour as int < 12 { ~\"am\" } else { ~\"pm\" } }\n           'p' { if tm.tm_hour as int < 12 { ~\"AM\" } else { ~\"PM\" } }\n           'R' {\n-            #fmt(\"%s:%s\",\n+            fmt!{\"%s:%s\",\n                 parse_type('H', tm),\n-                parse_type('M', tm))\n+                parse_type('M', tm)}\n           }\n           'r' {\n-            #fmt(\"%s:%s:%s %s\",\n+            fmt!{\"%s:%s:%s %s\",\n                 parse_type('I', tm),\n                 parse_type('M', tm),\n                 parse_type('S', tm),\n-                parse_type('p', tm))\n+                parse_type('p', tm)}\n           }\n-          'S' { #fmt(\"%02d\", tm.tm_sec as int) }\n-          's' { #fmt(\"%d\", tm.to_timespec().sec as int) }\n+          'S' { fmt!{\"%02d\", tm.tm_sec as int} }\n+          's' { fmt!{\"%d\", tm.to_timespec().sec as int} }\n           'T' | 'X' {\n-            #fmt(\"%s:%s:%s\",\n+            fmt!{\"%s:%s:%s\",\n                 parse_type('H', tm),\n                 parse_type('M', tm),\n-                parse_type('S', tm))\n+                parse_type('S', tm)}\n           }\n           't' { ~\"\\t\" }\n           //'U' {}\n@@ -716,24 +716,24 @@ fn strftime(format: ~str, tm: tm) -> ~str {\n           }\n           //'V' {}\n           'v' {\n-            #fmt(\"%s-%s-%s\",\n+            fmt!{\"%s-%s-%s\",\n                 parse_type('e', tm),\n                 parse_type('b', tm),\n-                parse_type('Y', tm))\n+                parse_type('Y', tm)}\n           }\n           //'W' {}\n           'w' { int::str(tm.tm_wday as int) }\n           //'X' {}\n           //'x' {}\n           'Y' { int::str(tm.tm_year as int + 1900) }\n-          'y' { #fmt(\"%02d\", (tm.tm_year as int + 1900) % 100) }\n+          'y' { fmt!{\"%02d\", (tm.tm_year as int + 1900) % 100} }\n           'Z' { tm.tm_zone }\n           'z' {\n             let sign = if tm.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(tm.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            #fmt(\"%c%02d%02d\", sign, h as int, m as int)\n+            fmt!{\"%c%02d%02d\", sign, h as int, m as int}\n           }\n           //'+' {}\n           '%' { ~\"%\" }\n@@ -824,7 +824,7 @@ impl tm for tm {\n             let mut m = i32::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n             m -= h * 60_i32;\n-            s + #fmt(\"%c%02d:%02d\", sign, h as int, m as int)\n+            s + fmt!{\"%c%02d:%02d\", sign, h as int, m as int}\n         }\n     }\n }\n@@ -905,7 +905,7 @@ mod tests {\n         let time = { sec: 1234567890_i64, nsec: 54321_i32 };\n         let local = at(time);\n \n-        #error(\"time_at: %?\", local);\n+        error!{\"time_at: %?\", local};\n \n         assert local.tm_sec == 30_i32;\n         assert local.tm_min == 31_i32;\n@@ -1111,7 +1111,7 @@ mod tests {\n         let utc   = at_utc(time);\n         let local = at(time);\n \n-        #error(\"test_ctime: %? %?\", utc.ctime(), local.ctime());\n+        error!{\"test_ctime: %? %?\", utc.ctime(), local.ctime()};\n \n         assert utc.ctime()   == ~\"Fri Feb 13 23:31:30 2009\";\n         assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";"}, {"sha": "6b0b4eb2f17a8b9530c7d8a8ea58d716cb17b250", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -106,8 +106,8 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n     // FIXME: This could be written clearer (#2618)\n     either::either(\n         |left_val| {\n-            log(debug, #fmt(\"recv_time .. left_val %?\",\n-                           left_val));\n+            log(debug, fmt!{\"recv_time .. left_val %?\",\n+                           left_val});\n             none\n         }, |right_val| {\n             some(right_val)\n@@ -118,7 +118,7 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n // INTERNAL API\n extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n                                 status: libc::c_int) unsafe {\n-    log(debug, #fmt(\"delayed_send_cb handle %? status %?\", handle, status));\n+    log(debug, fmt!{\"delayed_send_cb handle %? status %?\", handle, status});\n     let timer_done_ch =\n         *(uv::ll::get_data_for_uv_handle(handle) as *comm::chan<()>);\n     let stop_result = uv::ll::timer_stop(handle);\n@@ -134,7 +134,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n }\n \n extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n-    log(debug, #fmt(\"delayed_send_close_cb handle %?\", handle));\n+    log(debug, fmt!{\"delayed_send_close_cb handle %?\", handle});\n     let timer_done_ch =\n         *(uv::ll::get_data_for_uv_handle(handle) as *comm::chan<()>);\n     comm::send(timer_done_ch, ());"}, {"sha": "d3b9795b85b14a939db667f6110173f4fcbcc7af", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -36,43 +36,43 @@ fn get_monitor_task_gl() -> iotask unsafe {\n \n     let monitor_loop_chan_ptr = rustrt::rust_uv_get_kernel_global_chan_ptr();\n \n-    #debug(\"ENTERING global_loop::get() loop chan: %?\",\n-           monitor_loop_chan_ptr);\n+    debug!{\"ENTERING global_loop::get() loop chan: %?\",\n+           monitor_loop_chan_ptr};\n \n     let builder_fn = || {\n         task::task().sched_mode(task::single_threaded).unlinked()\n     };\n \n-    #debug(\"before priv::chan_from_global_ptr\");\n+    debug!{\"before priv::chan_from_global_ptr\"};\n     type monchan = chan<iotask>;\n \n     let monitor_ch = do chan_from_global_ptr::<monchan>(monitor_loop_chan_ptr,\n                                                         builder_fn) |msg_po| {\n-        #debug(\"global monitor task starting\");\n+        debug!{\"global monitor task starting\"};\n \n         // As a weak task the runtime will notify us when to exit\n         do weaken_task() |weak_exit_po| {\n-            #debug(\"global monitor task is now weak\");\n+            debug!{\"global monitor task is now weak\"};\n             let hl_loop = spawn_loop();\n             loop {\n-                #debug(\"in outer_loop...\");\n+                debug!{\"in outer_loop...\"};\n                 alt select2(weak_exit_po, msg_po) {\n                   left(weak_exit) {\n                     // all normal tasks have ended, tell the\n                     // libuv loop to tear_down, then exit\n-                    #debug(\"weak_exit_po recv'd msg: %?\", weak_exit);\n+                    debug!{\"weak_exit_po recv'd msg: %?\", weak_exit};\n                     iotask::exit(hl_loop);\n                     break;\n                   }\n                   right(fetch_ch) {\n-                    #debug(\"hl_loop req recv'd: %?\", fetch_ch);\n+                    debug!{\"hl_loop req recv'd: %?\", fetch_ch};\n                     fetch_ch.send(hl_loop);\n                   }\n                 }\n             }\n-            #debug(\"global monitor task is leaving weakend state\");\n+            debug!{\"global monitor task is leaving weakend state\"};\n         };\n-        #debug(\"global monitor task exiting\");\n+        debug!{\"global monitor task exiting\"};\n     };\n \n     // once we have a chan to the monitor loop, we ask it for\n@@ -89,14 +89,14 @@ fn spawn_loop() -> iotask unsafe {\n             // The I/O loop task also needs to be weak so it doesn't keep\n             // the runtime alive\n             do weaken_task |weak_exit_po| {\n-                #debug(\"global libuv task is now weak %?\", weak_exit_po);\n+                debug!{\"global libuv task is now weak %?\", weak_exit_po};\n                 task_body();\n \n                 // We don't wait for the exit message on weak_exit_po\n                 // because the monitor task will tell the uv loop when to\n                 // exit\n \n-                #debug(\"global libuv task is leaving weakened state\");\n+                debug!{\"global libuv task is leaving weakened state\"};\n             }\n         }\n     };\n@@ -110,8 +110,8 @@ mod test {\n             timer_ptr as *libc::c_void) as *comm::chan<bool>;\n         let exit_ch = *exit_ch_ptr;\n         comm::send(exit_ch, true);\n-        log(debug, #fmt(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n-                       exit_ch_ptr));\n+        log(debug, fmt!{\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n+                       exit_ch_ptr});\n     }\n     extern fn simple_timer_cb(timer_ptr: *ll::uv_timer_t,\n                              _status: libc::c_int) unsafe {\n@@ -131,8 +131,8 @@ mod test {\n         let exit_po = comm::port::<bool>();\n         let exit_ch = comm::chan(exit_po);\n         let exit_ch_ptr = ptr::addr_of(exit_ch);\n-        log(debug, #fmt(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n-                       exit_ch_ptr));\n+        log(debug, fmt!{\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n+                       exit_ch_ptr});\n         let timer_handle = ll::timer_t();\n         let timer_ptr = ptr::addr_of(timer_handle);\n         do iotask::interact(iotask) |loop_ptr| {"}, {"sha": "bc9878ccc40eb1aa0275c89e32573e6c7d34fa86", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -29,9 +29,9 @@ fn spawn_iotask(-task: task::task_builder) -> iotask {\n     do listen |iotask_ch| {\n \n         do task.sched_mode(task::single_threaded).spawn {\n-            #debug(\"entering libuv task\");\n+            debug!{\"entering libuv task\"};\n             run_loop(iotask_ch);\n-            #debug(\"libuv task exiting\");\n+            debug!{\"libuv task exiting\"};\n         };\n \n         iotask_ch.recv()\n@@ -136,8 +136,8 @@ fn send_msg(iotask: iotask,\n extern fn wake_up_cb(async_handle: *ll::uv_async_t,\n                     status: int) unsafe {\n \n-    log(debug, #fmt(\"wake_up_cb extern.. handle: %? status: %?\",\n-                     async_handle, status));\n+    log(debug, fmt!{\"wake_up_cb extern.. handle: %? status: %?\",\n+                     async_handle, status});\n \n     let loop_ptr = ll::get_loop_for_uv_handle(async_handle);\n     let data = ll::get_data_for_uv_handle(async_handle) as *iotask_loop_data;\n@@ -164,22 +164,22 @@ fn begin_teardown(data: *iotask_loop_data) unsafe {\n extern fn tear_down_close_cb(handle: *ll::uv_async_t) unsafe {\n     let loop_ptr = ll::get_loop_for_uv_handle(handle);\n     let loop_refs = ll::loop_refcount(loop_ptr);\n-    log(debug, #fmt(\"tear_down_close_cb called, closing handle at %? refs %?\",\n-                    handle, loop_refs));\n+    log(debug, fmt!{\"tear_down_close_cb called, closing handle at %? refs %?\",\n+                    handle, loop_refs});\n     assert loop_refs == 1i32;\n }\n \n #[cfg(test)]\n mod test {\n     extern fn async_close_cb(handle: *ll::uv_async_t) unsafe {\n-        log(debug, #fmt(\"async_close_cb handle %?\", handle));\n+        log(debug, fmt!{\"async_close_cb handle %?\", handle});\n         let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n                         as *ah_data)).exit_ch;\n         comm::send(exit_ch, ());\n     }\n     extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n         unsafe {\n-        log(debug, #fmt(\"async_handle_cb handle %? status %?\",handle,status));\n+        log(debug, fmt!{\"async_handle_cb handle %? status %?\",handle,status});\n         ll::close(handle, async_close_cb);\n     }\n     type ah_data = {\n@@ -217,13 +217,13 @@ mod test {\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n-        log(debug, #fmt(\"lifetime_handle_close ptr %?\", handle));\n+        log(debug, fmt!{\"lifetime_handle_close ptr %?\", handle});\n     }\n \n     extern fn lifetime_async_callback(handle: *libc::c_void,\n                                      status: libc::c_int) {\n-        log(debug, #fmt(\"lifetime_handle_close ptr %? status %?\",\n-                        handle, status));\n+        log(debug, fmt!{\"lifetime_handle_close ptr %? status %?\",\n+                        handle, status});\n     }\n \n     #[test]"}, {"sha": "96c3b5b1609ceae30068aadfc732540e7aba8dd2", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -705,8 +705,8 @@ unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n                       addr_ptr: *sockaddr_in,\n                       ++after_connect_cb: *u8)\n -> libc::c_int {\n-    log(debug, #fmt(\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n-                    (*addr_ptr).sin_port as uint, after_connect_cb as uint));\n+    log(debug, fmt!{\"b4 foreign tcp_connect--addr port: %u cb: %u\",\n+                    (*addr_ptr).sin_port as uint, after_connect_cb as uint});\n     ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n                                     after_connect_cb, addr_ptr);\n }\n@@ -786,20 +786,20 @@ unsafe fn async_send(async_handle: *uv_async_t) {\n unsafe fn buf_init(++input: *u8, len: uint) -> uv_buf_t {\n     let out_buf = { base: ptr::null(), len: 0 as libc::size_t };\n     let out_buf_ptr = ptr::addr_of(out_buf);\n-    log(debug, #fmt(\"buf_init - input %u len %u out_buf: %u\",\n+    log(debug, fmt!{\"buf_init - input %u len %u out_buf: %u\",\n                      input as uint,\n                      len as uint,\n-                     out_buf_ptr as uint));\n+                     out_buf_ptr as uint});\n     // yuck :/\n     rustrt::rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n     //let result = rustrt::rust_uv_buf_init_2(input, len as size_t);\n     log(debug, ~\"after rust_uv_buf_init\");\n     let res_base = get_base_from_buf(out_buf);\n     let res_len = get_len_from_buf(out_buf);\n     //let res_base = get_base_from_buf(result);\n-    log(debug, #fmt(\"buf_init - result %u len %u\",\n+    log(debug, fmt!{\"buf_init - result %u len %u\",\n                      res_base as uint,\n-                     res_len as uint));\n+                     res_len as uint});\n     ret out_buf;\n     //ret result;\n }\n@@ -843,8 +843,8 @@ unsafe fn ip6_name(src: &sockaddr_in6) -> ~str {\n                        0u8,0u8,0u8,0u8,0u8,0u8];\n     do vec::as_buf(dst) |dst_buf, size| {\n         let src_unsafe_ptr = src as *sockaddr_in6;\n-        log(debug, #fmt(\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n-                        src_unsafe_ptr, src));\n+        log(debug, fmt!{\"val of src *sockaddr_in6: %? sockaddr_in6: %?\",\n+                        src_unsafe_ptr, src});\n         let result = rustrt::rust_uv_ip6_name(src_unsafe_ptr,\n                                               dst_buf, size as libc::size_t);\n         alt result {\n@@ -964,8 +964,8 @@ unsafe fn get_last_err_info(uv_loop: *libc::c_void) -> ~str {\n     let err_ptr = ptr::addr_of(err);\n     let err_name = str::unsafe::from_c_str(err_name(err_ptr));\n     let err_msg = str::unsafe::from_c_str(strerror(err_ptr));\n-    ret #fmt(\"LIBUV ERROR: name: %s msg: %s\",\n-                    err_name, err_msg);\n+    ret fmt!{\"LIBUV ERROR: name: %s msg: %s\",\n+                    err_name, err_msg};\n }\n \n unsafe fn get_last_err_data(uv_loop: *libc::c_void) -> uv_err_data {\n@@ -1015,31 +1015,31 @@ mod test {\n     };\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n-        log(debug, #fmt(\"after uv_close! handle ptr: %?\",\n-                        handle));\n+        log(debug, fmt!{\"after uv_close! handle ptr: %?\",\n+                        handle});\n     }\n \n     extern fn on_alloc_cb(handle: *libc::c_void,\n                          ++suggested_size: libc::size_t)\n         -> uv_buf_t unsafe {\n         log(debug, ~\"on_alloc_cb!\");\n         let char_ptr = malloc_buf_base_of(suggested_size);\n-        log(debug, #fmt(\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n+        log(debug, fmt!{\"on_alloc_cb h: %? char_ptr: %u sugsize: %u\",\n                          handle,\n                          char_ptr as uint,\n-                         suggested_size as uint));\n+                         suggested_size as uint});\n         ret buf_init(char_ptr, suggested_size as uint);\n     }\n \n     extern fn on_read_cb(stream: *uv_stream_t,\n                         nread: libc::ssize_t,\n                         ++buf: uv_buf_t) unsafe {\n         let nread = nread as int;\n-        log(debug, #fmt(\"CLIENT entering on_read_cb nred: %d\",\n-                        nread));\n+        log(debug, fmt!{\"CLIENT entering on_read_cb nred: %d\",\n+                        nread});\n         if (nread > 0) {\n             // we have data\n-            log(debug, #fmt(\"CLIENT read: data! nread: %d\", nread));\n+            log(debug, fmt!{\"CLIENT read: data! nread: %d\", nread});\n             read_stop(stream);\n             let client_data =\n                 get_data_for_uv_handle(stream as *libc::c_void)\n@@ -1067,20 +1067,20 @@ mod test {\n \n     extern fn on_write_complete_cb(write_req: *uv_write_t,\n                                   status: libc::c_int) unsafe {\n-        log(debug, #fmt(\"CLIENT beginning on_write_complete_cb status: %d\",\n-                         status as int));\n+        log(debug, fmt!{\"CLIENT beginning on_write_complete_cb status: %d\",\n+                         status as int});\n         let stream = get_stream_handle_from_write_req(write_req);\n-        log(debug, #fmt(\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n-            stream as int, write_req as int));\n+        log(debug, fmt!{\"CLIENT on_write_complete_cb: tcp:%d write_handle:%d\",\n+            stream as int, write_req as int});\n         let result = read_start(stream, on_alloc_cb, on_read_cb);\n-        log(debug, #fmt(\"CLIENT ending on_write_complete_cb .. status: %d\",\n-                         result as int));\n+        log(debug, fmt!{\"CLIENT ending on_write_complete_cb .. status: %d\",\n+                         result as int});\n     }\n \n     extern fn on_connect_cb(connect_req_ptr: *uv_connect_t,\n                                  status: libc::c_int) unsafe {\n-        log(debug, #fmt(\"beginning on_connect_cb .. status: %d\",\n-                         status as int));\n+        log(debug, fmt!{\"beginning on_connect_cb .. status: %d\",\n+                         status as int});\n         let stream =\n             get_stream_handle_from_connect_req(connect_req_ptr);\n         if (status == 0i32) {\n@@ -1089,14 +1089,14 @@ mod test {\n                 connect_req_ptr as *libc::c_void)\n                 as *request_wrapper;\n             let write_handle = (*client_data).write_req;\n-            log(debug, #fmt(\"on_connect_cb: tcp: %d write_hdl: %d\",\n-                            stream as int, write_handle as int));\n+            log(debug, fmt!{\"on_connect_cb: tcp: %d write_hdl: %d\",\n+                            stream as int, write_handle as int});\n             let write_result = write(write_handle,\n                               stream as *libc::c_void,\n                               (*client_data).req_buf,\n                               on_write_complete_cb);\n-            log(debug, #fmt(\"on_connect_cb: write() status: %d\",\n-                             write_result as int));\n+            log(debug, fmt!{\"on_connect_cb: write() status: %d\",\n+                             write_result as int});\n         }\n         else {\n             let test_loop = get_loop_for_uv_handle(\n@@ -1123,17 +1123,17 @@ mod test {\n         // data field in our uv_connect_t struct\n         let req_str_bytes = str::bytes(req_str);\n         let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str_bytes);\n-        log(debug, #fmt(\"req_msg ptr: %u\", req_msg_ptr as uint));\n+        log(debug, fmt!{\"req_msg ptr: %u\", req_msg_ptr as uint});\n         let req_msg = ~[\n             buf_init(req_msg_ptr, vec::len(req_str_bytes))\n         ];\n         // this is the enclosing record, we'll pass a ptr to\n         // this to C..\n         let write_handle = write_t();\n         let write_handle_ptr = ptr::addr_of(write_handle);\n-        log(debug, #fmt(\"tcp req: tcp stream: %d write_handle: %d\",\n+        log(debug, fmt!{\"tcp req: tcp stream: %d write_handle: %d\",\n                          tcp_handle_ptr as int,\n-                         write_handle_ptr as int));\n+                         write_handle_ptr as int});\n         let client_data = { writer_handle: write_handle_ptr,\n                     req_buf: ptr::addr_of(req_msg),\n                     read_chan: client_chan };\n@@ -1147,12 +1147,12 @@ mod test {\n             let addr = ip4_addr(ip, port);\n             // FIXME ref #2064\n             let addr_ptr = ptr::addr_of(addr);\n-            log(debug, #fmt(\"after build addr in rust. port: %u\",\n-                             addr.sin_port as uint));\n+            log(debug, fmt!{\"after build addr in rust. port: %u\",\n+                             addr.sin_port as uint});\n \n             // this should set up the connection request..\n-            log(debug, #fmt(\"b4 call tcp_connect connect cb: %u \",\n-                            on_connect_cb as uint));\n+            log(debug, fmt!{\"b4 call tcp_connect connect cb: %u \",\n+                            on_connect_cb as uint});\n             let tcp_connect_result = tcp_connect(\n                 connect_req_ptr, tcp_handle_ptr,\n                 addr_ptr, on_connect_cb);\n@@ -1183,8 +1183,8 @@ mod test {\n     }\n \n     extern fn server_after_close_cb(handle: *libc::c_void) unsafe {\n-        log(debug, #fmt(\"SERVER server stream closed, should exit.. h: %?\",\n-                   handle));\n+        log(debug, fmt!{\"SERVER server stream closed, should exit.. h: %?\",\n+                   handle});\n     }\n \n     extern fn client_stream_after_close_cb(handle: *libc::c_void)\n@@ -1212,15 +1212,15 @@ mod test {\n         let nread = nread as int;\n         if (nread > 0) {\n             // we have data\n-            log(debug, #fmt(\"SERVER read: data! nread: %d\", nread));\n+            log(debug, fmt!{\"SERVER read: data! nread: %d\", nread});\n \n             // pull out the contents of the write from the client\n             let buf_base = get_base_from_buf(buf);\n             let buf_len = get_len_from_buf(buf) as uint;\n-            log(debug, #fmt(\"SERVER buf base: %u, len: %u, nread: %d\",\n+            log(debug, fmt!{\"SERVER buf base: %u, len: %u, nread: %d\",\n                             buf_base as uint,\n                             buf_len as uint,\n-                            nread));\n+                            nread});\n             let bytes = vec::unsafe::from_buf(buf_base, buf_len);\n             let request_str = str::from_bytes(bytes);\n \n@@ -1240,8 +1240,8 @@ mod test {\n                     client_stream_ptr as *libc::c_void,\n                     (*client_data).server_resp_buf,\n                     after_server_resp_write);\n-                log(debug, #fmt(\"SERVER: resp write result: %d\",\n-                            write_result as int));\n+                log(debug, fmt!{\"SERVER: resp write result: %d\",\n+                            write_result as int});\n                 if (write_result != 0i32) {\n                     log(debug, ~\"bad result for server resp write()\");\n                     log(debug, get_last_err_info(\n@@ -1275,8 +1275,8 @@ mod test {\n                                server_stream_ptr as *libc::c_void);\n         if status != 0i32 {\n             let err_msg = get_last_err_info(test_loop);\n-            log(debug, #fmt(\"server_connect_cb: non-zero status: %?\",\n-                         err_msg));\n+            log(debug, fmt!{\"server_connect_cb: non-zero status: %?\",\n+                         err_msg});\n             ret;\n         }\n         let server_data = get_data_for_uv_handle(\n@@ -1303,20 +1303,20 @@ mod test {\n                     log(debug, ~\"successful server read start\");\n                 }\n                 else {\n-                    log(debug, #fmt(\"server_connection_cb: bad read:%d\",\n-                                    read_result as int));\n+                    log(debug, fmt!{\"server_connection_cb: bad read:%d\",\n+                                    read_result as int});\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, #fmt(\"server_connection_cb: bad accept: %d\",\n-                            accept_result as int));\n+                log(debug, fmt!{\"server_connection_cb: bad accept: %d\",\n+                            accept_result as int});\n                 assert false;\n             }\n         }\n         else {\n-            log(debug, #fmt(\"server_connection_cb: bad client init: %d\",\n-                        client_init_result as int));\n+            log(debug, fmt!{\"server_connection_cb: bad client init: %d\",\n+                        client_init_result as int});\n             assert false;\n         }\n     }\n@@ -1335,8 +1335,8 @@ mod test {\n     };\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n-        log(debug, #fmt(\"SERVER: closing async cb... h: %?\",\n-                   handle));\n+        log(debug, fmt!{\"SERVER: closing async cb... h: %?\",\n+                   handle});\n     }\n \n     extern fn continue_async_cb(async_handle: *uv_async_t,\n@@ -1371,7 +1371,7 @@ mod test {\n \n         let resp_str_bytes = str::bytes(server_resp_msg);\n         let resp_msg_ptr: *u8 = vec::unsafe::to_ptr(resp_str_bytes);\n-        log(debug, #fmt(\"resp_msg ptr: %u\", resp_msg_ptr as uint));\n+        log(debug, fmt!{\"resp_msg ptr: %u\", resp_msg_ptr as uint});\n         let resp_msg = ~[\n             buf_init(resp_msg_ptr, vec::len(resp_str_bytes))\n         ];\n@@ -1430,26 +1430,26 @@ mod test {\n                         log(debug, ~\"server uv::run() has returned\");\n                     }\n                     else {\n-                        log(debug, #fmt(\"uv_async_init failure: %d\",\n-                                async_result as int));\n+                        log(debug, fmt!{\"uv_async_init failure: %d\",\n+                                async_result as int});\n                         assert false;\n                     }\n                 }\n                 else {\n-                    log(debug, #fmt(\"non-zero result on uv_listen: %d\",\n-                                listen_result as int));\n+                    log(debug, fmt!{\"non-zero result on uv_listen: %d\",\n+                                listen_result as int});\n                     assert false;\n                 }\n             }\n             else {\n-                log(debug, #fmt(\"non-zero result on uv_tcp_bind: %d\",\n-                            bind_result as int));\n+                log(debug, fmt!{\"non-zero result on uv_tcp_bind: %d\",\n+                            bind_result as int});\n                 assert false;\n             }\n         }\n         else {\n-            log(debug, #fmt(\"non-zero result on uv_tcp_init: %d\",\n-                        tcp_init_result as int));\n+            log(debug, fmt!{\"non-zero result on uv_tcp_init: %d\",\n+                        tcp_init_result as int});\n             assert false;\n         }\n         loop_delete(test_loop);\n@@ -1526,8 +1526,8 @@ mod test {\n     fn test_uv_ll_struct_size_uv_tcp_t() {\n         let foreign_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n         let rust_handle_size = sys::size_of::<uv_tcp_t>();\n-        let output = #fmt(\"uv_tcp_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_tcp_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1537,8 +1537,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_connect_t_size();\n         let rust_handle_size = sys::size_of::<uv_connect_t>();\n-        let output = #fmt(\"uv_connect_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_connect_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1548,8 +1548,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_buf_t_size();\n         let rust_handle_size = sys::size_of::<uv_buf_t>();\n-        let output = #fmt(\"uv_buf_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_buf_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1559,8 +1559,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_write_t_size();\n         let rust_handle_size = sys::size_of::<uv_write_t>();\n-        let output = #fmt(\"uv_write_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_write_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1571,8 +1571,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_sockaddr_in_size();\n         let rust_handle_size = sys::size_of::<sockaddr_in>();\n-        let output = #fmt(\"sockaddr_in -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"sockaddr_in -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1582,8 +1582,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_sockaddr_in6_size();\n         let rust_handle_size = sys::size_of::<sockaddr_in6>();\n-        let output = #fmt(\"sockaddr_in6 -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"sockaddr_in6 -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         // FIXME #1645 .. rust appears to pad structs to the nearest byte..?\n         // .. can't get the uv::ll::sockaddr_in6 to == 28 :/\n@@ -1597,8 +1597,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_addr_in_size();\n         let rust_handle_size = sys::size_of::<addr_in>();\n-        let output = #fmt(\"addr_in -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"addr_in -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         // FIXME #1645 .. see note above about struct padding\n         assert (4u+foreign_handle_size as uint) == rust_handle_size;\n@@ -1610,8 +1610,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_async_t_size();\n         let rust_handle_size = sys::size_of::<uv_async_t>();\n-        let output = #fmt(\"uv_async_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_async_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1622,8 +1622,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_timer_t_size();\n         let rust_handle_size = sys::size_of::<uv_timer_t>();\n-        let output = #fmt(\"uv_timer_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_timer_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1635,8 +1635,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_uv_getaddrinfo_t_size();\n         let rust_handle_size = sys::size_of::<uv_getaddrinfo_t>();\n-        let output = #fmt(\"uv_getaddrinfo_t -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"uv_getaddrinfo_t -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }\n@@ -1648,8 +1648,8 @@ mod test {\n         let foreign_handle_size =\n             rustrt::rust_uv_helper_addrinfo_size();\n         let rust_handle_size = sys::size_of::<addrinfo>();\n-        let output = #fmt(\"addrinfo -- foreign: %u rust: %u\",\n-                          foreign_handle_size as uint, rust_handle_size);\n+        let output = fmt!{\"addrinfo -- foreign: %u rust: %u\",\n+                          foreign_handle_size as uint, rust_handle_size};\n         log(debug, output);\n         assert foreign_handle_size as uint == rust_handle_size;\n     }"}, {"sha": "ebe7a7eb36ad6281f564c68f49bb96237e5443f5", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -24,7 +24,7 @@ fn path_ident_to_str(p: path, i: ident) -> ~str {\n     if vec::is_empty(p) {\n         /* FIXME (#2543) */ copy *i\n     } else {\n-        #fmt[\"%s::%s\", path_to_str(p), *i]\n+        fmt!{\"%s::%s\", path_to_str(p), *i}\n     }\n }\n \n@@ -270,46 +270,46 @@ fn map_expr(ex: @expr, cx: ctx, v: vt) {\n fn node_id_to_str(map: map, id: node_id) -> ~str {\n     alt map.find(id) {\n       none {\n-        #fmt[\"unknown node (id=%d)\", id]\n+        fmt!{\"unknown node (id=%d)\", id}\n       }\n       some(node_item(item, path)) {\n-        #fmt[\"item %s (id=%?)\", path_ident_to_str(*path, item.ident), id]\n+        fmt!{\"item %s (id=%?)\", path_ident_to_str(*path, item.ident), id}\n       }\n       some(node_foreign_item(item, abi, path)) {\n-        #fmt[\"foreign item %s with abi %? (id=%?)\",\n-             path_ident_to_str(*path, item.ident), abi, id]\n+        fmt!{\"foreign item %s with abi %? (id=%?)\",\n+             path_ident_to_str(*path, item.ident), abi, id}\n       }\n       some(node_method(m, impl_did, path)) {\n-        #fmt[\"method %s in %s (id=%?)\",\n-             *m.ident, path_to_str(*path), id]\n+        fmt!{\"method %s in %s (id=%?)\",\n+             *m.ident, path_to_str(*path), id}\n       }\n       some(node_variant(variant, def_id, path)) {\n-        #fmt[\"variant %s in %s (id=%?)\",\n-             *variant.node.name, path_to_str(*path), id]\n+        fmt!{\"variant %s in %s (id=%?)\",\n+             *variant.node.name, path_to_str(*path), id}\n       }\n       some(node_expr(expr)) {\n-        #fmt[\"expr %s (id=%?)\",\n-             pprust::expr_to_str(expr), id]\n+        fmt!{\"expr %s (id=%?)\",\n+             pprust::expr_to_str(expr), id}\n       }\n       // FIXMEs are as per #2410\n       some(node_export(_, path)) {\n-        #fmt[\"export %s (id=%?)\", // add more info here\n-             path_to_str(*path), id]\n+        fmt!{\"export %s (id=%?)\", // add more info here\n+             path_to_str(*path), id}\n       }\n       some(node_arg(_, _)) { // add more info here\n-        #fmt[\"arg (id=%?)\", id]\n+        fmt!{\"arg (id=%?)\", id}\n       }\n       some(node_local(_)) { // add more info here\n-        #fmt[\"local (id=%?)\", id]\n+        fmt!{\"local (id=%?)\", id}\n       }\n       some(node_ctor(*)) { // add more info here\n-        #fmt[\"node_ctor (id=%?)\", id]\n+        fmt!{\"node_ctor (id=%?)\", id}\n       }\n       some(node_dtor(*)) { // add more info here\n-        #fmt[\"node_dtor (id=%?)\", id]\n+        fmt!{\"node_dtor (id=%?)\", id}\n       }\n       some(node_block(_)) {\n-        #fmt[\"block\"]\n+        fmt!{\"block\"}\n       }\n     }\n }"}, {"sha": "5801bc895e56c4cb396f008567f1d493a610c973", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -197,12 +197,12 @@ fn find_meta_items_by_name(metas: ~[@ast::meta_item], +name: ~str) ->\n  * comparison is performed structurally.\n  */\n fn contains(haystack: ~[@ast::meta_item], needle: @ast::meta_item) -> bool {\n-    #debug(\"looking for %s\",\n-           print::pprust::meta_item_to_str(*needle));\n+    debug!{\"looking for %s\",\n+           print::pprust::meta_item_to_str(*needle)};\n     for haystack.each |item| {\n-        #debug(\"looking in %s\",\n-               print::pprust::meta_item_to_str(*item));\n-        if eq(item, needle) { #debug(\"found it!\"); ret true; }\n+        debug!{\"looking in %s\",\n+               print::pprust::meta_item_to_str(*item)};\n+        if eq(item, needle) { debug!{\"found it!\"}; ret true; }\n     }\n     #debug(\"found it not :(\");\n     ret false;\n@@ -323,7 +323,7 @@ fn find_linkage_attrs(attrs: ~[ast::attribute]) -> ~[ast::attribute] {\n     for find_attrs_by_name(attrs, ~\"link\").each |attr| {\n         alt attr.node.value.node {\n           ast::meta_list(_, _) { vec::push(found, attr) }\n-          _ { #debug(\"ignoring link attribute that has incorrect type\"); }\n+          _ { debug!{\"ignoring link attribute that has incorrect type\"}; }\n         }\n     }\n     ret found;\n@@ -399,7 +399,7 @@ fn require_unique_names(diagnostic: span_handler,\n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if map.contains_key(*name) {\n             diagnostic.span_fatal(meta.span,\n-                                  #fmt[\"duplicate meta item `%s`\", *name]);\n+                                  fmt!{\"duplicate meta item `%s`\", *name});\n         }\n         map.insert(*name, ());\n     }"}, {"sha": "0c211395223ebe651efa9c41d17d56d747019033", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -73,7 +73,7 @@ fn new_filemap(+filename: filename, src: @~str,\n fn mk_substr_filename(cm: codemap, sp: span) -> ~str\n {\n     let pos = lookup_char_pos(cm, sp.lo);\n-    ret #fmt(\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col);\n+    ret fmt!{\"<%s:%u:%u>\", pos.file.name, pos.line, pos.col};\n }\n \n fn next_line(file: filemap, chpos: uint, byte_pos: uint) {\n@@ -93,7 +93,7 @@ fn lookup_line(map: codemap, pos: uint, lookup: lookup_fn)\n         if lookup(map.files[m].start_pos) > pos { b = m; } else { a = m; }\n     }\n     if (a >= len) {\n-        fail #fmt(\"position %u does not resolve to a source location\", pos)\n+        fail fmt!{\"position %u does not resolve to a source location\", pos}\n     }\n     let f = map.files[a];\n     a = 0u;\n@@ -166,15 +166,15 @@ type span = {lo: uint, hi: uint, expn_info: expn_info};\n fn span_to_str_no_adj(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos(cm, sp.lo);\n     let hi = lookup_char_pos(cm, sp.hi);\n-    ret #fmt(\"%s:%u:%u: %u:%u\", lo.file.name,\n-             lo.line, lo.col, hi.line, hi.col)\n+    ret fmt!{\"%s:%u:%u: %u:%u\", lo.file.name,\n+             lo.line, lo.col, hi.line, hi.col}\n }\n \n fn span_to_str(sp: span, cm: codemap) -> ~str {\n     let lo = lookup_char_pos_adj(cm, sp.lo);\n     let hi = lookup_char_pos_adj(cm, sp.hi);\n-    ret #fmt(\"%s:%u:%u: %u:%u\", lo.filename,\n-             lo.line, lo.col, hi.line, hi.col)\n+    ret fmt!{\"%s:%u:%u: %u:%u\", lo.filename,\n+             lo.line, lo.col, hi.line, hi.col}\n }\n \n type file_lines = {file: filemap, lines: ~[uint]};"}, {"sha": "4a6935f7fc8aa9edd8ce1b9a62f375c052c5e5b8", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -90,8 +90,8 @@ impl codemap_handler of handler for handler_t {\n         alt self.err_count {\n           0u { ret; }\n           1u { s = ~\"aborting due to previous error\"; }\n-          _  { s = #fmt[\"aborting due to %u previous errors\",\n-                        self.err_count]; }\n+          _  { s = fmt!{\"aborting due to %u previous errors\",\n+                        self.err_count}; }\n         }\n         self.fatal(s);\n     }\n@@ -111,7 +111,7 @@ impl codemap_handler of handler for handler_t {\n }\n \n fn ice_msg(msg: ~str) -> ~str {\n-    #fmt[\"internal compiler error: %s\", msg]\n+    fmt!{\"internal compiler error: %s\", msg}\n }\n \n fn mk_span_handler(handler: handler, cm: codemap::codemap) -> span_handler {\n@@ -166,16 +166,16 @@ fn print_diagnostic(topic: ~str, lvl: level, msg: ~str) {\n     let use_color = term::color_supported() &&\n         io::stderr().get_type() == io::screen;\n     if str::is_not_empty(topic) {\n-        io::stderr().write_str(#fmt[\"%s \", topic]);\n+        io::stderr().write_str(fmt!{\"%s \", topic});\n     }\n     if use_color {\n         term::fg(io::stderr(), diagnosticcolor(lvl));\n     }\n-    io::stderr().write_str(#fmt[\"%s:\", diagnosticstr(lvl)]);\n+    io::stderr().write_str(fmt!{\"%s:\", diagnosticstr(lvl)});\n     if use_color {\n         term::reset(io::stderr());\n     }\n-    io::stderr().write_str(#fmt[\" %s\\n\", msg]);\n+    io::stderr().write_str(fmt!{\" %s\\n\", msg});\n }\n \n fn emit(cmsp: option<(codemap::codemap, span)>,\n@@ -210,13 +210,13 @@ fn highlight_lines(cm: codemap::codemap, sp: span,\n     }\n     // Print the offending lines\n     for display_lines.each |line| {\n-        io::stderr().write_str(#fmt[\"%s:%u \", fm.name, line + 1u]);\n+        io::stderr().write_str(fmt!{\"%s:%u \", fm.name, line + 1u});\n         let s = codemap::get_line(fm, line as int) + ~\"\\n\";\n         io::stderr().write_str(s);\n     }\n     if elided {\n         let last_line = display_lines[vec::len(display_lines) - 1u];\n-        let s = #fmt[\"%s:%u \", fm.name, last_line + 1u];\n+        let s = fmt!{\"%s:%u \", fm.name, last_line + 1u};\n         let mut indent = str::len(s);\n         let mut out = ~\"\";\n         while indent > 0u { out += ~\" \"; indent -= 1u; }\n@@ -255,7 +255,7 @@ fn print_macro_backtrace(cm: codemap::codemap, sp: span) {\n         let ss = option::map_default(ei.callie.span, @~\"\",\n                                      |span| @codemap::span_to_str(span, cm));\n         print_diagnostic(*ss, note,\n-                         #fmt(\"in expansion of #%s\", ei.callie.name));\n+                         fmt!{\"in expansion of #%s\", ei.callie.name});\n         let ss = codemap::span_to_str(ei.call_site, cm);\n         print_diagnostic(ss, note, ~\"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);"}, {"sha": "57b6dc13b8a39f9071a3cab465abb1f4cf49cbfd", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -348,7 +348,7 @@ fn ser_variant(cx: ext_ctxt,\n                argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n     let vnames = do vec::from_fn(vec::len(tys)) |i| {\n-        @#fmt[\"__v%u\", i]\n+        @fmt!{\"__v%u\", i}\n     };\n     let pats = do vec::from_fn(vec::len(tys)) |i| {\n         cx.binder_pat(tys[i].span, vnames[i])\n@@ -398,13 +398,13 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n \n       ast::ty_bot {\n         cx.span_err(\n-            ty.span, #fmt[\"Cannot serialize bottom type\"]);\n+            ty.span, fmt!{\"Cannot serialize bottom type\"});\n         ~[]\n       }\n \n       ast::ty_box(mt) {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        ~[#ast(stmt){$(s).emit_box($(l));}]\n+        ~[#ast[stmt]{$(s).emit_box($(l));}]\n       }\n \n       // For unique evecs/estrs, just pass through to underlying vec or str\n@@ -414,7 +414,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n \n       ast::ty_uniq(mt) {\n         let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n-        ~[#ast(stmt){$(s).emit_uniq($(l));}]\n+        ~[#ast[stmt]{$(s).emit_uniq($(l));}]\n       }\n \n       ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n@@ -433,10 +433,10 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n             let f = cx.lit_str(fld.span, fld.node.ident);\n             let i = cx.lit_uint(fld.span, fidx);\n             let l = ser_lambda(cx, tps, fld.node.mt.ty, cx.clone(s), vf);\n-            #ast(stmt){$(s).emit_rec_field($(f), $(i), $(l));}\n+            #ast[stmt]{$(s).emit_rec_field($(f), $(i), $(l));}\n         };\n         let fld_lambda = cx.lambda(cx.blk(ty.span, fld_stmts));\n-        ~[#ast(stmt){$(s).emit_rec($(fld_lambda));}]\n+        ~[#ast[stmt]{$(s).emit_rec($(fld_lambda));}]\n       }\n \n       ast::ty_fn(_, _) {\n@@ -514,7 +514,7 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n                             cx.clone(s),\n                             cx.at(ty.span, #ast{ __e })))));\n \n-        ~[#ast(stmt){\n+        ~[#ast[stmt]{\n             std::serialization::emit_from_vec($(s), $(v), |__e| $(ser_e))\n         }]\n       }\n@@ -544,7 +544,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n              ident: @(~\"__s\" + *tp.ident),\n              id: cx.next_id()});\n \n-    #debug[\"tp_inputs = %?\", tp_inputs];\n+    debug!{\"tp_inputs = %?\", tp_inputs};\n \n \n     let ser_inputs: ~[ast::arg] =\n@@ -565,8 +565,8 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n             *tp.ident,\n             fn@(v: @ast::expr) -> ~[@ast::stmt] {\n                 let f = cx.var_ref(span, arg_ident);\n-                #debug[\"serializing type arg %s\", *arg_ident];\n-                ~[#ast(stmt){$(f)($(v));}]\n+                debug!{\"serializing type arg %s\", *arg_ident};\n+                ~[#ast[stmt]{$(f)($(v));}]\n             });\n     }\n \n@@ -755,7 +755,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n              ident: @(~\"__d\" + *tp.ident),\n              id: cx.next_id()});\n \n-    #debug[\"tp_inputs = %?\", tp_inputs];\n+    debug!{\"tp_inputs = %?\", tp_inputs};\n \n     let deser_inputs: ~[ast::arg] =\n         vec::append(~[{mode: ast::expl(ast::by_ref),\n@@ -792,7 +792,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n                          with cloned}\n                     }));\n \n-    let deser_blk = cx.expr_blk(f(cx, tps_map, #ast(expr){__d}));\n+    let deser_blk = cx.expr_blk(f(cx, tps_map, #ast[expr]{__d}));\n \n     @{ident: @(~\"deserialize_\" + *name),\n       attrs: ~[],\n@@ -864,7 +864,7 @@ fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: ast::ident,\n     };\n     let lam = cx.lambda(cx.blk(e_span, ~[cx.alt_stmt(arms, e_span, v)]));\n     let e_name = cx.lit_str(e_span, e_name);\n-    ~[#ast(stmt){ $(s).emit_enum($(e_name), $(lam)) }]\n+    ~[#ast[stmt]{ $(s).emit_enum($(e_name), $(lam)) }]\n }\n \n fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: ast::ident,"}, {"sha": "c6889eb9c1d48b204b585aade6bed1aa2c20e019", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -243,22 +243,22 @@ fn get_mac_args(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n             alt max {\n               some(max) if ! (min <= elts_len && elts_len <= max) {\n                 cx.span_fatal(sp,\n-                              #fmt[\"#%s takes between %u and %u arguments.\",\n-                                   name, min, max]);\n+                              fmt!{\"#%s takes between %u and %u arguments.\",\n+                                   name, min, max});\n               }\n               none if ! (min <= elts_len) {\n-                cx.span_fatal(sp, #fmt[\"#%s needs at least %u arguments.\",\n-                                       name, min]);\n+                cx.span_fatal(sp, fmt!{\"#%s needs at least %u arguments.\",\n+                                       name, min});\n               }\n               _ { ret elts; /* we're good */}\n             }\n           }\n           _ {\n-            cx.span_fatal(sp, #fmt[\"#%s: malformed invocation\", name])\n+            cx.span_fatal(sp, fmt!{\"#%s: malformed invocation\", name})\n           }\n         }\n       }\n-      none {cx.span_fatal(sp, #fmt[\"#%s: missing arguments\", name])}\n+      none {cx.span_fatal(sp, fmt!{\"#%s: missing arguments\", name})}\n     }\n }\n "}, {"sha": "3805f1a19c66fb5d261fd39dd413d90bd87e154b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -29,12 +29,12 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                 alt exts.find(*extname) {\n                   none {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"macro undefined: '%s'\", *extname])\n+                                  fmt!{\"macro undefined: '%s'\", *extname})\n                   }\n                   some(item_decorator(_)) {\n                     cx.span_fatal(\n                         pth.span,\n-                        #fmt[\"%s can only be used as a decorator\", *extname]);\n+                        fmt!{\"%s can only be used as a decorator\", *extname});\n                   }\n                   some(normal({expander: exp, span: exp_sp})) {\n                     let expanded = exp(cx, mac.span, args, body);\n@@ -54,8 +54,8 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   some(expr_tt(_)) {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"this tt-style macro should be \\\n-                                        invoked '%s!{...}'\", *extname])\n+                                  fmt!{\"this tt-style macro should be \\\n+                                        invoked '%s!{...}'\", *extname})\n                   }\n                   some(item_tt(*)) {\n                     cx.span_fatal(pth.span,\n@@ -72,14 +72,14 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                 alt exts.find(*extname) {\n                   none {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"macro undefined: '%s'\", *extname])\n+                                  fmt!{\"macro undefined: '%s'\", *extname})\n                   }\n                   some(expr_tt({expander: exp, span: exp_sp})) {\n                     let expanded = alt exp(cx, mac.span, tts) {\n                       mr_expr(e) { e }\n                       _ { cx.span_fatal(\n-                          pth.span, #fmt[\"non-expr macro in expr pos: %s\",\n-                                         *extname]) }\n+                          pth.span, fmt!{\"non-expr macro in expr pos: %s\",\n+                                         *extname}) }\n                     };\n \n                     cx.bt_push(expanded_from({call_site: s,\n@@ -106,8 +106,8 @@ fn expand_expr(exts: hashmap<~str, syntax_extension>, cx: ext_ctxt,\n                   }\n                   _ {\n                     cx.span_fatal(pth.span,\n-                                  #fmt[\"'%s' is not a tt-style macro\",\n-                                       *extname])\n+                                  fmt!{\"'%s' is not a tt-style macro\",\n+                                       *extname})\n                   }\n \n                 }\n@@ -203,7 +203,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n         alt exts.find(*extname) {\n           none {\n             cx.span_fatal(pth.span,\n-                          #fmt(\"macro undefined: '%s'\", *extname))\n+                          fmt!{\"macro undefined: '%s'\", *extname})\n           }\n           some(item_tt(expand)) {\n             let expanded = expand.expander(cx, it.span, it.ident, tts);\n@@ -224,7 +224,7 @@ fn expand_item_mac(exts: hashmap<~str, syntax_extension>,\n             ret maybe_it\n           }\n           _ { cx.span_fatal(it.span,\n-                            #fmt(\"%s is not a legal here\", *extname)) }\n+                            fmt!{\"%s is not a legal here\", *extname}) }\n         }\n       }\n       _ {\n@@ -246,10 +246,10 @@ fn new_span(cx: ext_ctxt, sp: span) -> span {\n fn core_macros() -> ~str {\n     ret\n ~\"{\n-    #macro([#error[f, ...], log(core::error, #fmt[f, ...])]);\n-    #macro([#warn[f, ...], log(core::warn, #fmt[f, ...])]);\n-    #macro([#info[f, ...], log(core::info, #fmt[f, ...])]);\n-    #macro([#debug[f, ...], log(core::debug, #fmt[f, ...])]);\n+    #macro[[#error[f, ...], log(core::error, #fmt[f, ...])]];\n+    #macro[[#warn[f, ...], log(core::warn, #fmt[f, ...])]];\n+    #macro[[#info[f, ...], log(core::info, #fmt[f, ...])]];\n+    #macro[[#debug[f, ...], log(core::debug, #fmt[f, ...])]];\n }\";\n }\n "}, {"sha": "d8549ca21c80186945d392879d21ccc797565629", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -18,7 +18,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n         expr_to_str(cx, args[0],\n                     ~\"first argument to #fmt must be a string literal.\");\n     let fmtspan = args[0].span;\n-    #debug(\"Format string:\");\n+    debug!{\"Format string:\"};\n     log(debug, fmt);\n     fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: ~str) -> ! {\n         cx.span_fatal(sp, msg);\n@@ -189,15 +189,15 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n     fn log_conv(c: conv) {\n         alt c.param {\n           some(p) { log(debug, ~\"param: \" + int::to_str(p, 10u)); }\n-          _ { #debug(\"param: none\"); }\n+          _ { debug!{\"param: none\"}; }\n         }\n         for c.flags.each |f| {\n             alt f {\n-              flag_left_justify { #debug(\"flag: left justify\"); }\n-              flag_left_zero_pad { #debug(\"flag: left zero pad\"); }\n-              flag_space_for_sign { #debug(\"flag: left space pad\"); }\n-              flag_sign_always { #debug(\"flag: sign always\"); }\n-              flag_alternate { #debug(\"flag: alternate\"); }\n+              flag_left_justify { debug!{\"flag: left justify\"}; }\n+              flag_left_zero_pad { debug!{\"flag: left zero pad\"}; }\n+              flag_space_for_sign { debug!{\"flag: left space pad\"}; }\n+              flag_sign_always { debug!{\"flag: sign always\"}; }\n+              flag_alternate { debug!{\"flag: alternate\"}; }\n             }\n         }\n         alt c.width {\n@@ -207,8 +207,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             log(debug,\n                      ~\"width: count is param \" + int::to_str(i, 10u));\n           }\n-          count_is_next_param { #debug(\"width: count is next param\"); }\n-          count_implied { #debug(\"width: count is implied\"); }\n+          count_is_next_param { debug!{\"width: count is next param\"}; }\n+          count_implied { debug!{\"width: count is implied\"}; }\n         }\n         alt c.precision {\n           count_is(i) { log(debug,\n@@ -217,29 +217,29 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n             log(debug,\n                      ~\"prec: count is param \" + int::to_str(i, 10u));\n           }\n-          count_is_next_param { #debug(\"prec: count is next param\"); }\n-          count_implied { #debug(\"prec: count is implied\"); }\n+          count_is_next_param { debug!{\"prec: count is next param\"}; }\n+          count_implied { debug!{\"prec: count is implied\"}; }\n         }\n         alt c.ty {\n-          ty_bool { #debug(\"type: bool\"); }\n-          ty_str { #debug(\"type: str\"); }\n-          ty_char { #debug(\"type: char\"); }\n+          ty_bool { debug!{\"type: bool\"}; }\n+          ty_str { debug!{\"type: str\"}; }\n+          ty_char { debug!{\"type: char\"}; }\n           ty_int(s) {\n             alt s {\n-              signed { #debug(\"type: signed\"); }\n-              unsigned { #debug(\"type: unsigned\"); }\n+              signed { debug!{\"type: signed\"}; }\n+              unsigned { debug!{\"type: unsigned\"}; }\n             }\n           }\n-          ty_bits { #debug(\"type: bits\"); }\n+          ty_bits { debug!{\"type: bits\"}; }\n           ty_hex(cs) {\n             alt cs {\n-              case_upper { #debug(\"type: uhex\"); }\n-              case_lower { #debug(\"type: lhex\"); }\n+              case_upper { debug!{\"type: uhex\"}; }\n+              case_lower { debug!{\"type: lhex\"}; }\n             }\n           }\n-          ty_octal { #debug(\"type: octal\"); }\n-          ty_float { #debug(\"type: float\"); }\n-          ty_poly { #debug(\"type: poly\"); }\n+          ty_octal { debug!{\"type: octal\"}; }\n+          ty_float { debug!{\"type: float\"}; }\n+          ty_poly { debug!{\"type: poly\"}; }\n         }\n     }\n     let fmt_sp = args[0].span;\n@@ -258,7 +258,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n                               ~\"not enough arguments to #fmt \" +\n                                   ~\"for the given format string\");\n             }\n-            #debug(\"Building conversion:\");\n+            debug!{\"Building conversion:\"};\n             log_conv(conv);\n             let arg_expr = args[n];\n             let c_expr = make_new_conv(cx, fmt_sp, conv, arg_expr);\n@@ -270,8 +270,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span,\n \n     if expected_nargs < nargs {\n         cx.span_fatal\n-            (sp, #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n-                           nargs, expected_nargs]);\n+            (sp, fmt!{\"too many arguments to #fmt. found %u, expected %u\",\n+                           nargs, expected_nargs});\n     }\n \n     let arg_vec = mk_fixed_vec_e(cx, fmt_sp, piece_exprs);"}, {"sha": "24ac18ada6a58764623dded4dd1cda374eeb994a", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -36,9 +36,9 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n         if state.messages.len() == 0 {\n             self.span_warn(\n                 state.span, // use a real span!\n-                #fmt(\"state %s contains no messages, \\\n+                fmt!{\"state %s contains no messages, \\\n                       consider stepping to a terminal state instead\",\n-                     *state.name))\n+                     *state.name})\n         }\n     }\n \n@@ -52,20 +52,20 @@ impl proto_check of proto::visitor<(), (), ()>  for ext_ctxt {\n                 // track span information.\n                 self.span_err(\n                     proto.get_state(next).span,\n-                    #fmt(\"message %s steps to undefined state, %s\",\n-                         *name, *next));\n+                    fmt!{\"message %s steps to undefined state, %s\",\n+                         *name, *next});\n             }\n             else {\n                 let next = proto.get_state(next);\n \n                 if next.ty_params.len() != next_tys.len() {\n                     self.span_err(\n                         next.span, // use a real span\n-                        #fmt(\"message %s target (%s) \\\n+                        fmt!{\"message %s target (%s) \\\n                               needs %u type parameters, but got %u\",\n                              *name, *next.name,\n                              next.ty_params.len(),\n-                             next_tys.len()));\n+                             next_tys.len()});\n                 }\n             }\n           }"}, {"sha": "87179accefa3a8115d11544edce15c57a6ca1cb8", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -35,7 +35,7 @@ import proto::methods;\n import ast_builder::empty_span;\n \n fn analyze(proto: protocol, _cx: ext_ctxt) {\n-    #debug(\"initializing colive analysis\");\n+    debug!{\"initializing colive analysis\"};\n     let num_states = proto.num_states();\n     let colive = do (copy proto.states).map_to_vec |state| {\n         let bv = ~bitv(num_states, false);\n@@ -49,7 +49,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     let mut changed = true;\n     while changed {\n         changed = false;\n-        #debug(\"colive iteration %?\", i);\n+        debug!{\"colive iteration %?\", i};\n         for colive.eachi |i, this_colive| {\n             let this = proto.get_state_by_id(i);\n             for this_colive.ones |j| {\n@@ -62,7 +62,7 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n         i += 1;\n     }\n \n-    #debug(\"colive analysis complete\");\n+    debug!{\"colive analysis complete\"};\n \n     // Determine if we're bounded\n     let mut self_live = ~[];\n@@ -75,20 +75,20 @@ fn analyze(proto: protocol, _cx: ext_ctxt) {\n     if self_live.len() > 0 {\n         let states = str::connect(self_live.map(|s| *s.name), ~\" \");\n \n-        #debug(\"protocol %s is unbounded due to loops involving: %s\",\n-               *proto.name, states);\n+        debug!{\"protocol %s is unbounded due to loops involving: %s\",\n+               *proto.name, states};\n \n         // Someday this will be configurable with a warning\n         //cx.span_warn(empty_span(),\n-        //              #fmt(\"protocol %s is unbounded due to loops \\\n+        //              fmt!{\"protocol %s is unbounded due to loops \\\n         //                    involving these states: %s\",\n         //                   *proto.name,\n-        //                   states));\n+        //                   states});\n \n         proto.bounded = some(false);\n     }\n     else {\n-        #debug(\"protocol %s is bounded. yay!\", *proto.name);\n+        debug!{\"protocol %s is bounded. yay!\", *proto.name};\n         proto.bounded = some(true);\n     }\n }\n\\ No newline at end of file"}, {"sha": "32df5ed472aa8977141e016b2ba143d0386a1b5b", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -46,10 +46,10 @@ trait gen_init {\n \n impl compile of gen_send for message {\n     fn gen_send(cx: ext_ctxt) -> @ast::item {\n-        #debug(\"pipec: gen_send\");\n+        debug!{\"pipec: gen_send\"};\n         alt self {\n           message(id, span, tys, this, some({state: next, tys: next_tys})) {\n-            #debug(\"pipec: next state exists\");\n+            debug!{\"pipec: next state exists\"};\n             let next = this.proto.get_state(next);\n             assert next_tys.len() == next.ty_params.len();\n             let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n@@ -78,12 +78,12 @@ impl compile of gen_send for message {\n                 };\n \n                 body += \"let b = pipe.reuse_buffer();\\n\";\n-                body += #fmt(\"let %s = pipes::send_packet_buffered(\\\n+                body += fmt!{\"let %s = pipes::send_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             sp, *next.name);\n-                body += #fmt(\"let %s = pipes::recv_packet_buffered(\\\n+                             sp, *next.name};\n+                body += fmt!{\"let %s = pipes::recv_packet_buffered(\\\n                               ptr::addr_of(b.buffer.data.%s));\\n\",\n-                             rp, *next.name);\n+                             rp, *next.name};\n             }\n             else {\n                 let pat = alt (this.dir, next.dir) {\n@@ -93,15 +93,15 @@ impl compile of gen_send for message {\n                   (recv, recv) { ~\"(c, s)\" }\n                 };\n \n-                body += #fmt(\"let %s = pipes::entangle();\\n\", pat);\n+                body += fmt!{\"let %s = pipes::entangle();\\n\", pat};\n             }\n-            body += #fmt(\"let message = %s::%s(%s);\\n\",\n+            body += fmt!{\"let message = %s::%s(%s);\\n\",\n                          *this.proto.name,\n                          *self.name(),\n                          str::connect(vec::append_one(arg_names, @~\"s\")\n                                       .map(|x| *x),\n-                                      ~\", \"));\n-            body += #fmt(\"pipes::send(pipe, message);\\n\");\n+                                      ~\", \")};\n+            body += fmt!{\"pipes::send(pipe, message);\\n\"};\n             // return the new channel\n             body += ~\"c }\";\n \n@@ -117,7 +117,7 @@ impl compile of gen_send for message {\n           }\n \n           message(id, span, tys, this, none) {\n-            #debug(\"pipec: no next state\");\n+            debug!{\"pipec: no next state\"};\n             let arg_names = tys.mapi(|i, _ty| @(~\"x_\" + i.to_str()));\n \n             let args_ast = (arg_names, tys).map(\n@@ -140,11 +140,11 @@ impl compile of gen_send for message {\n             };\n \n             let mut body = ~\"{ \";\n-            body += #fmt(\"let message = %s::%s%s;\\n\",\n+            body += fmt!{\"let message = %s::%s%s;\\n\",\n                          *this.proto.name,\n                          *self.name(),\n-                         message_args);\n-            body += #fmt(\"pipes::send(pipe, message);\\n\");\n+                         message_args};\n+            body += fmt!{\"pipes::send(pipe, message);\\n\"};\n             body += ~\" }\";\n \n             let body = cx.parse_expr(body);\n@@ -166,7 +166,7 @@ impl compile of gen_send for message {\n \n impl compile of to_type_decls for state {\n     fn to_type_decls(cx: ext_ctxt) -> ~[@ast::item] {\n-        #debug(\"pipec: to_type_decls\");\n+        debug!{\"pipec: to_type_decls\"};\n         // This compiles into two different type declarations. Say the\n         // state is called ping. This will generate both `ping` and\n         // `ping_message`. The first contains data that the user cares\n@@ -206,7 +206,7 @@ impl compile of to_type_decls for state {\n     }\n \n     fn to_endpoint_decls(cx: ext_ctxt, dir: direction) -> ~[@ast::item] {\n-        #debug(\"pipec: to_endpoint_decls\");\n+        debug!{\"pipec: to_endpoint_decls\"};\n         let dir = alt dir {\n           send { (*self).dir }\n           recv { (*self).dir.reverse() }\n@@ -250,7 +250,7 @@ impl compile of gen_init for protocol {\n     fn gen_init(cx: ext_ctxt) -> @ast::item {\n         let ext_cx = cx;\n \n-        #debug(\"gen_init\");\n+        debug!{\"gen_init\"};\n         let start_state = self.states[0];\n \n         let body = if !self.is_bounded() {\n@@ -277,12 +277,12 @@ impl compile of gen_init for protocol {\n             }\n         };\n \n-        cx.parse_item(#fmt(\"fn init%s() -> (client::%s, server::%s)\\\n+        cx.parse_item(fmt!{\"fn init%s() -> (client::%s, server::%s)\\\n                             { import pipes::has_buffer; %s }\",\n                            start_state.ty_params.to_source(),\n                            start_state.to_ty(cx).to_source(),\n                            start_state.to_ty(cx).to_source(),\n-                           body.to_source()))\n+                           body.to_source()})\n     }\n \n     fn gen_buffer_init(ext_cx: ext_ctxt) -> @ast::expr {\n@@ -293,7 +293,7 @@ impl compile of gen_init for protocol {\n     }\n \n     fn gen_init_bounded(ext_cx: ext_ctxt) -> @ast::expr {\n-        #debug(\"gen_init_bounded\");\n+        debug!{\"gen_init_bounded\"};\n         let buffer_fields = self.gen_buffer_init(ext_cx);\n \n         let buffer = #ast {\n@@ -305,9 +305,9 @@ impl compile of gen_init for protocol {\n             ext_cx.block(\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n-                        #fmt(\"data.%s.set_buffer(buffer)\", *s.name))),\n+                        fmt!{\"data.%s.set_buffer(buffer)\", *s.name})),\n                 ext_cx.parse_expr(\n-                    #fmt(\"ptr::addr_of(data.%s)\", *self.states[0].name))));\n+                    fmt!{\"ptr::addr_of(data.%s)\", *self.states[0].name})));\n \n         #ast {{\n             let buffer = $(buffer);\n@@ -442,7 +442,7 @@ impl parse_utils of ext_ctxt_parse_utils for ext_ctxt {\n         alt res {\n           some(ast) { ast }\n           none {\n-            #error(\"Parse error with ```\\n%s\\n```\", s);\n+            error!{\"Parse error with ```\\n%s\\n```\", s};\n             fail\n           }\n         }"}, {"sha": "b9f77ea3fc2cbec006bfa7609d215ad050847cee", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -158,9 +158,9 @@ class protocol_ {\n         let bounded = self.bounded.get();\n         bounded\n         //if bounded && self.has_ty_params() {\n-        //    #debug(\"protocol %s has is bounded, but type parameters\\\n+        //    debug!{\"protocol %s has is bounded, but type parameters\\\n         //            are not yet supported.\",\n-        //           *self.name);\n+        //           *self.name};\n         //    false\n         //}\n         //else { bounded }"}, {"sha": "c027963cefabe2575b35f43ffd7a76402da5ad16", "filename": "src/libsyntax/ext/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fqquote.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -185,7 +185,7 @@ fn finish<T: qq_helper>\n {\n     let cm = ecx.codemap();\n     let str = @codemap::span_to_snippet(body.span, cm);\n-    #debug[\"qquote--str==%?\", str];\n+    debug!{\"qquote--str==%?\", str};\n     let fname = codemap::mk_substr_filename(cm, body.span);\n     let node = parse_from_source_str\n         (f, fname, codemap::fss_internal(body.span), str,\n@@ -211,7 +211,7 @@ fn finish<T: qq_helper>\n     do str::chars_iter(*str) |ch| {\n         if (j < g_len && i == cx.gather[j].lo) {\n             assert ch == '$';\n-            let repl = #fmt(\"$%u \", j);\n+            let repl = fmt!{\"$%u \", j};\n             state = skip(str::char_len(repl));\n             str2 += repl;\n         }"}, {"sha": "b261e7657a21f3601abd2c59dfe8a1a095aad79c", "filename": "src/libsyntax/ext/simplext.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsimplext.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -289,9 +289,9 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mut ~[uint],\n                         let len = vec::len(*ms);\n                         if old_len != len {\n                             let msg =\n-                                #fmt[\"'%s' occurs %u times, but \", *fv, len] +\n-                                    #fmt[\"'%s' occurs %u times\", *old_name,\n-                                         old_len];\n+                                fmt!{\"'%s' occurs %u times, but \", *fv, len} +\n+                                    fmt!{\"'%s' occurs %u times\", *old_name,\n+                                         old_len};\n                             cx.span_fatal(repeat_me.span, msg);\n                         }\n                       }"}, {"sha": "226292086f8952c0562a2dae8c45f6979f81ca20", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -13,23 +13,23 @@ export expand_include;\n export expand_include_str;\n export expand_include_bin;\n \n-/* #line(): expands to the current line number */\n+/* line!{}: expands to the current line number */\n fn expand_line(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n                _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"line\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     ret mk_uint(cx, sp, loc.line);\n }\n \n-/* #col(): expands to the current column number */\n+/* col!{}: expands to the current column number */\n fn expand_col(cx: ext_ctxt, sp: span, arg: ast::mac_arg,\n               _body: ast::mac_body) -> @ast::expr {\n     get_mac_args(cx, sp, arg, 0u, option::some(0u), ~\"col\");\n     let loc = codemap::lookup_char_pos(cx.codemap(), sp.lo);\n     ret mk_uint(cx, sp, loc.col);\n }\n \n-/* #file(): expands to the current filename */\n+/* file!{}: expands to the current filename */\n /* The filemap (`loc.file`) contains a bunch more information we could spit\n  * out if we wanted. */\n fn expand_file(cx: ext_ctxt, sp: span, arg: ast::mac_arg,"}, {"sha": "c7a2713c26e49362d12e04ed62367773d7b6b721", "filename": "src/libsyntax/ext/tt/earley_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fearley_parser.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -274,13 +274,13 @@ fn parse(sess: parse_sess, cfg: ast::crate_cfg, rdr: reader, ms: ~[matcher])\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     alt ei.elts[ei.idx].node {\n                       match_nonterminal(bind,name,_) {\n-                        #fmt[\"%s ('%s')\", *name, *bind]\n+                        fmt!{\"%s ('%s')\", *name, *bind}\n                       }\n                       _ { fail; } } }), ~\" or \");\n-                ret failure(sp, #fmt[\n+                ret failure(sp, fmt!{\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\",\n-                    nts, next_eis.len()]);\n+                    nts, next_eis.len()});\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n                 ret failure(sp, ~\"No rules expected the token \"\n                             + to_str(*rdr.interner(), tok));"}, {"sha": "9ab6261052acade5d817ac5e27fbe94d67783c84", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -111,9 +111,9 @@ fn lockstep_iter_size(&&t: token_tree, &&r: tt_reader) -> lis {\n               lis_contradiction(_) { rhs }\n               lis_constraint(r_len, _) if l_len == r_len { lhs }\n               lis_constraint(r_len, r_id) {\n-                lis_contradiction(#fmt[\"Inconsistent lockstep iteration: \\\n+                lis_contradiction(fmt!{\"Inconsistent lockstep iteration: \\\n                                         '%s' has %u items, but '%s' has %u\",\n-                                       *l_id, l_len, *r_id, r_len])\n+                                       *l_id, l_len, *r_id, r_len})\n               }\n             }\n           }\n@@ -233,8 +233,8 @@ fn tt_next_token(&&r: tt_reader) -> {tok: token, sp: span} {\n               matched_seq(*) {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n-                    #fmt[\"variable '%s' is still repeating at this depth\",\n-                         *ident]);\n+                    fmt!{\"variable '%s' is still repeating at this depth\",\n+                         *ident});\n               }\n             }\n           }"}, {"sha": "c9224c2817f3c00b4bb762b5b939601fbeb73402", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -119,7 +119,7 @@ fn consume_non_eol_whitespace(rdr: string_reader) {\n }\n \n fn push_blank_line_comment(rdr: string_reader, &comments: ~[cmnt]) {\n-    #debug(\">>> blank-line comment\");\n+    debug!{\">>> blank-line comment\"};\n     let v: ~[~str] = ~[];\n     vec::push(comments, {style: blank_line, lines: v, pos: rdr.chpos});\n }\n@@ -137,9 +137,9 @@ fn consume_whitespace_counting_blank_lines(rdr: string_reader,\n \n fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n-    #debug(\">>> shebang comment\");\n+    debug!{\">>> shebang comment\"};\n     let p = rdr.chpos;\n-    #debug(\"<<< shebang comment\");\n+    debug!{\"<<< shebang comment\"};\n     vec::push(comments, {\n         style: if code_to_the_left { trailing } else { isolated },\n         lines: ~[read_one_line_comment(rdr)],\n@@ -149,7 +149,7 @@ fn read_shebang_comment(rdr: string_reader, code_to_the_left: bool,\n \n fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n-    #debug(\">>> line comments\");\n+    debug!{\">>> line comments\"};\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n     while rdr.curr == '/' && nextch(rdr) == '/' {\n@@ -161,7 +161,7 @@ fn read_line_comments(rdr: string_reader, code_to_the_left: bool,\n         vec::push(lines, line);\n         consume_non_eol_whitespace(rdr);\n     }\n-    #debug(\"<<< line comments\");\n+    debug!{\"<<< line comments\"};\n     if !lines.is_empty() {\n         vec::push(comments, {\n             style: if code_to_the_left { trailing } else { isolated },\n@@ -192,7 +192,7 @@ fn trim_whitespace_prefix_and_push_line(&lines: ~[~str],\n \n fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n                                                         &comments: ~[cmnt]) {\n-    #debug(\">>> block comment\");\n+    debug!{\">>> block comment\"};\n     let p = rdr.chpos;\n     let mut lines: ~[~str] = ~[];\n     let mut col: uint = rdr.col;\n@@ -214,7 +214,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n     let mut curr_line = ~\"/*\";\n     let mut level: int = 1;\n     while level > 0 {\n-        #debug(\"=== block comment level %d\", level);\n+        debug!{\"=== block comment level %d\", level};\n         if is_eof(rdr) {(rdr as reader).fatal(~\"unterminated block comment\");}\n         if rdr.curr == '\\n' {\n             trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n@@ -245,7 +245,7 @@ fn read_block_comment(rdr: string_reader, code_to_the_left: bool,\n     if !is_eof(rdr) && rdr.curr != '\\n' && vec::len(lines) == 1u {\n         style = mixed;\n     }\n-    #debug(\"<<< block comment\");\n+    debug!{\"<<< block comment\"};\n     vec::push(comments, {style: style, lines: lines, pos: p});\n }\n \n@@ -257,15 +257,15 @@ fn peeking_at_comment(rdr: string_reader) -> bool {\n \n fn consume_comment(rdr: string_reader, code_to_the_left: bool,\n                    &comments: ~[cmnt]) {\n-    #debug(\">>> consume comment\");\n+    debug!{\">>> consume comment\"};\n     if rdr.curr == '/' && nextch(rdr) == '/' {\n         read_line_comments(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '/' && nextch(rdr) == '*' {\n         read_block_comment(rdr, code_to_the_left, comments);\n     } else if rdr.curr == '#' && nextch(rdr) == '!' {\n         read_shebang_comment(rdr, code_to_the_left, comments);\n     } else { fail; }\n-    #debug(\"<<< consume comment\");\n+    debug!{\"<<< consume comment\"};\n }\n \n type lit = {lit: ~str, pos: uint};"}, {"sha": "314d0494bfba9d6b2a8f4fe823ef3cbedb0502ea", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -113,7 +113,7 @@ impl parser_common of parser_common for parser {\n     // A sanity check that the word we are asking for is a known keyword\n     fn require_keyword(word: ~str) {\n         if !self.keywords.contains_key(word) {\n-            self.bug(#fmt(\"unknown keyword: %s\", word));\n+            self.bug(fmt!{\"unknown keyword: %s\", word});\n         }\n     }\n "}, {"sha": "8a53625be1eb2e208bfc8a52807fbfe75a8d484b", "filename": "src/libsyntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -20,9 +20,9 @@ fn eval_crate_directives(cx: ctx,\n fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n                                 prefix: ~str, suffix: option<~str>)\n     -> (ast::_mod, ~[ast::attribute]) {\n-    #debug(\"eval crate prefix: %s\", prefix);\n-    #debug(\"eval crate suffix: %s\",\n-           option::get_default(suffix, ~\"none\"));\n+    debug!{\"eval crate prefix: %s\", prefix};\n+    debug!{\"eval crate suffix: %s\",\n+           option::get_default(suffix, ~\"none\")};\n     let (cview_items, citems, cattrs)\n         = parse_companion_mod(cx, prefix, suffix);\n     let mut view_items: ~[@ast::view_item] = ~[];\n@@ -63,9 +63,9 @@ fn parse_companion_mod(cx: ctx, prefix: ~str, suffix: option<~str>)\n     }\n \n     let modpath = companion_file(prefix, suffix);\n-    #debug(\"looking for companion mod %s\", modpath);\n+    debug!{\"looking for companion mod %s\", modpath};\n     if file_exists(modpath) {\n-        #debug(\"found companion mod\");\n+        debug!{\"found companion mod\"};\n         let (p0, r0) = new_parser_etc_from_file(cx.sess, cx.cfg,\n                                                 modpath, SOURCE_FILE);\n         let inner_attrs = p0.parse_inner_attrs_and_next();"}, {"sha": "08ec1c5f242c777a6f47465d5e248fcb5bef8e4b", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -417,8 +417,8 @@ fn scan_number(c: char, rdr: string_reader) -> token::token {\n         }\n         let parsed = option::get(u64::from_str_radix(num_str, base as u64));\n \n-        #debug[\"lexing %s as an unsuffixed integer literal\",\n-               num_str];\n+        debug!{\"lexing %s as an unsuffixed integer literal\",\n+               num_str};\n         ret token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }\n@@ -429,7 +429,7 @@ fn scan_numeric_escape(rdr: string_reader, n_hex_digits: uint) -> char {\n         let n = rdr.curr;\n         bump(rdr);\n         if !is_hex_digit(n) {\n-            rdr.fatal(#fmt[\"illegal numeric character escape: %d\", n as int]);\n+            rdr.fatal(fmt!{\"illegal numeric character escape: %d\", n as int});\n         }\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n@@ -572,7 +572,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n               'u' { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 {\n-                rdr.fatal(#fmt[\"unknown character escape: %d\", c2 as int]);\n+                rdr.fatal(fmt!{\"unknown character escape: %d\", c2 as int});\n               }\n             }\n         }\n@@ -587,8 +587,8 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n         bump(rdr);\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {\n-                rdr.fatal(#fmt[\"unterminated double quote string: %s\",\n-                               get_str_from(rdr, n)]);\n+                rdr.fatal(fmt!{\"unterminated double quote string: %s\",\n+                               get_str_from(rdr, n)});\n             }\n \n             let ch = rdr.curr;\n@@ -614,7 +614,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n                     str::push_char(accum_str, scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 {\n-                    rdr.fatal(#fmt[\"unknown string escape: %d\", c2 as int]);\n+                    rdr.fatal(fmt!{\"unknown string escape: %d\", c2 as int});\n                   }\n                 }\n               }\n@@ -649,7 +649,7 @@ fn next_token_inner(rdr: string_reader) -> token::token {\n       '/' { ret binop(rdr, token::SLASH); }\n       '^' { ret binop(rdr, token::CARET); }\n       '%' { ret binop(rdr, token::PERCENT); }\n-      c { rdr.fatal(#fmt[\"unknown start of token: %d\", c as int]); }\n+      c { rdr.fatal(fmt!{\"unknown start of token: %d\", c as int}); }\n     }\n }\n "}, {"sha": "1445dc30d103a2f4421eeac0e47f7cbc80626d3b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -273,21 +273,21 @@ class parser {\n             let tps = p.parse_ty_params();\n             let d = p.parse_ty_fn_decl(pur);\n             let hi = p.last_span.hi;\n-            #debug[\"parse_trait_methods(): trait method signature ends in \\\n+            debug!{\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n-                   token_to_str(p.reader, p.token)];\n+                   token_to_str(p.reader, p.token)};\n             alt p.token {\n               token::SEMI {\n                 p.bump();\n-                #debug[\"parse_trait_methods(): parsing required method\"];\n+                debug!{\"parse_trait_methods(): parsing required method\"};\n                 // NB: at the moment, visibility annotations on required\n                 // methods are ignored; this could change.\n                 required({ident: ident, attrs: attrs,\n                           decl: {purity: pur with d}, tps: tps,\n                           span: mk_sp(lo, hi)})\n               }\n               token::LBRACE {\n-                #debug[\"parse_trait_methods(): parsing provided method\"];\n+                debug!{\"parse_trait_methods(): parsing provided method\"};\n                 let (inner_attrs, body) =\n                     p.parse_inner_attrs_and_block(true);\n                 let attrs = vec::append(attrs, inner_attrs);\n@@ -632,7 +632,7 @@ class parser {\n     }\n \n     fn parse_path_with_tps(colons: bool) -> @path {\n-        #debug[\"parse_path_with_tps(colons=%b)\", colons];\n+        debug!{\"parse_path_with_tps(colons=%b)\", colons};\n \n         let lo = self.span.lo;\n         let path = self.parse_path_without_tps();\n@@ -1479,9 +1479,9 @@ class parser {\n             // There may be other types of expressions that can\n             // represent the callee in `for` and `do` expressions\n             // but they aren't represented by tests\n-            #debug(\"sugary call on %?\", e.node);\n+            debug!{\"sugary call on %?\", e.node};\n             self.span_fatal(\n-                lo, #fmt(\"`%s` must be followed by a block call\", keyword));\n+                lo, fmt!{\"`%s` must be followed by a block call\", keyword});\n           }\n         }\n     }\n@@ -2321,7 +2321,7 @@ class parser {\n                 attrs = vec::append(attrs_remaining, attrs);\n                 first = false;\n             }\n-            #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n+            debug!{\"parse_mod_items: parse_item(attrs=%?)\", attrs};\n             let vis = self.parse_visibility(private);\n             alt self.parse_item(attrs, vis) {\n               some(i) { vec::push(items, i); }\n@@ -2330,7 +2330,7 @@ class parser {\n                            token_to_str(self.reader, self.token) + ~\"`\");\n               }\n             }\n-            #debug[\"parse_mod_items: attrs=%?\", attrs];\n+            debug!{\"parse_mod_items: attrs=%?\", attrs};\n         }\n \n         if first && attrs_remaining.len() > 0u {\n@@ -2603,7 +2603,7 @@ class parser {\n         let lo = self.span.lo;\n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        #debug(\"parsed view_path: %s\", *first_ident);\n+        debug!{\"parsed view_path: %s\", *first_ident};\n         alt self.token {\n           token::EQ {\n             // x = foo::bar"}, {"sha": "d01a111364a4b0e8bbbd1107da4411ac0a881443", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -63,7 +63,7 @@ enum token { STRING(@~str, int), BREAK(break_t), BEGIN(begin_t), END, EOF, }\n \n fn tok_str(++t: token) -> ~str {\n     alt t {\n-      STRING(s, len) { ret #fmt[\"STR(%s,%d)\", *s, len]; }\n+      STRING(s, len) { ret fmt!{\"STR(%s,%d)\", *s, len}; }\n       BREAK(_) { ret ~\"BREAK\"; }\n       BEGIN(_) { ret ~\"BEGIN\"; }\n       END { ret ~\"END\"; }\n@@ -81,7 +81,7 @@ fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n     while i != right && L != 0u {\n         L -= 1u;\n         if i != left { s += ~\", \"; }\n-        s += #fmt[\"%d=%s\", szs[i], tok_str(toks[i])];\n+        s += fmt!{\"%d=%s\", szs[i], tok_str(toks[i])};\n         i += 1u;\n         i %= n;\n     }\n@@ -99,7 +99,7 @@ fn mk_printer(out: io::writer, linewidth: uint) -> printer {\n     // Yes 3, it makes the ring buffers big enough to never\n     // fall behind.\n     let n: uint = 3u * linewidth;\n-    #debug(\"mk_printer %u\", linewidth);\n+    debug!{\"mk_printer %u\", linewidth};\n     let token: ~[mut token] = vec::to_mut(vec::from_elem(n, EOF));\n     let size: ~[mut int] = vec::to_mut(vec::from_elem(n, 0));\n     let scan_stack: ~[mut uint] = vec::to_mut(vec::from_elem(n, 0u));\n@@ -235,7 +235,7 @@ impl printer for printer {\n     // be very careful with this!\n     fn replace_last_token(t: token) { self.token[self.right] = t; }\n     fn pretty_print(t: token) {\n-        #debug(\"pp ~[%u,%u]\", self.left, self.right);\n+        debug!{\"pp ~[%u,%u]\", self.left, self.right};\n         alt t {\n           EOF {\n             if !self.scan_stack_empty {\n@@ -252,17 +252,17 @@ impl printer for printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            #debug(\"pp BEGIN/buffer ~[%u,%u]\", self.left, self.right);\n+            debug!{\"pp BEGIN/buffer ~[%u,%u]\", self.left, self.right};\n             self.token[self.right] = t;\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n           END {\n             if self.scan_stack_empty {\n-                #debug(\"pp END/print ~[%u,%u]\", self.left, self.right);\n+                debug!{\"pp END/print ~[%u,%u]\", self.left, self.right};\n                 self.print(t, 0);\n             } else {\n-                #debug(\"pp END/buffer ~[%u,%u]\", self.left, self.right);\n+                debug!{\"pp END/buffer ~[%u,%u]\", self.left, self.right};\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = -1;\n@@ -276,7 +276,7 @@ impl printer for printer {\n                 self.left = 0u;\n                 self.right = 0u;\n             } else { self.advance_right(); }\n-            #debug(\"pp BREAK/buffer ~[%u,%u]\", self.left, self.right);\n+            debug!{\"pp BREAK/buffer ~[%u,%u]\", self.left, self.right};\n             self.check_stack(0);\n             self.scan_push(self.right);\n             self.token[self.right] = t;\n@@ -285,10 +285,10 @@ impl printer for printer {\n           }\n           STRING(s, len) {\n             if self.scan_stack_empty {\n-                #debug(\"pp STRING/print ~[%u,%u]\", self.left, self.right);\n+                debug!{\"pp STRING/print ~[%u,%u]\", self.left, self.right};\n                 self.print(t, len);\n             } else {\n-                #debug(\"pp STRING/buffer ~[%u,%u]\", self.left, self.right);\n+                debug!{\"pp STRING/buffer ~[%u,%u]\", self.left, self.right};\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = len;\n@@ -299,14 +299,14 @@ impl printer for printer {\n         }\n     }\n     fn check_stream() {\n-        #debug(\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n-               self.left, self.right, self.left_total, self.right_total);\n+        debug!{\"check_stream ~[%u, %u] with left_total=%d, right_total=%d\",\n+               self.left, self.right, self.left_total, self.right_total};\n         if self.right_total - self.left_total > self.space {\n-            #debug(\"scan window is %d, longer than space on line (%d)\",\n-                   self.right_total - self.left_total, self.space);\n+            debug!{\"scan window is %d, longer than space on line (%d)\",\n+                   self.right_total - self.left_total, self.space};\n             if !self.scan_stack_empty {\n                 if self.left == self.scan_stack[self.bottom] {\n-                    #debug(\"setting %u to infinity and popping\", self.left);\n+                    debug!{\"setting %u to infinity and popping\", self.left};\n                     self.size[self.scan_pop_bottom()] = size_infinity;\n                 }\n             }\n@@ -315,7 +315,7 @@ impl printer for printer {\n         }\n     }\n     fn scan_push(x: uint) {\n-        #debug(\"scan_push %u\", x);\n+        debug!{\"scan_push %u\", x};\n         if self.scan_stack_empty {\n             self.scan_stack_empty = false;\n         } else {\n@@ -351,8 +351,8 @@ impl printer for printer {\n         assert (self.right != self.left);\n     }\n     fn advance_left(++x: token, L: int) {\n-        #debug(\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n-               self.left, L);\n+        debug!{\"advnce_left ~[%u,%u], sizeof(%u)=%d\", self.left, self.right,\n+               self.left, L};\n         if L >= 0 {\n             self.print(x, L);\n             alt x {\n@@ -392,13 +392,13 @@ impl printer for printer {\n         }\n     }\n     fn print_newline(amount: int) {\n-        #debug(\"NEWLINE %d\", amount);\n+        debug!{\"NEWLINE %d\", amount};\n         self.out.write_str(~\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }\n     fn indent(amount: int) {\n-        #debug(\"INDENT %d\", amount);\n+        debug!{\"INDENT %d\", amount};\n         self.pending_indentation += amount;\n     }\n     fn get_top() -> print_stack_elt {\n@@ -417,55 +417,55 @@ impl printer for printer {\n         self.out.write_str(s);\n     }\n     fn print(x: token, L: int) {\n-        #debug(\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n-               self.space);\n+        debug!{\"print %s %d (remaining line space=%d)\", tok_str(x), L,\n+               self.space};\n         log(debug, buf_str(self.token, self.size, self.left, self.right, 6u));\n         alt x {\n           BEGIN(b) {\n             if L > self.space {\n                 let col = self.margin - self.space + b.offset;\n-                #debug(\"print BEGIN -> push broken block at col %d\", col);\n+                debug!{\"print BEGIN -> push broken block at col %d\", col};\n                 self.print_stack.push({offset: col,\n                                        pbreak: broken(b.breaks)});\n             } else {\n-                #debug(\"print BEGIN -> push fitting block\");\n+                debug!{\"print BEGIN -> push fitting block\"};\n                 self.print_stack.push({offset: 0,\n                                        pbreak: fits});\n             }\n           }\n           END {\n-            #debug(\"print END -> pop END\");\n+            debug!{\"print END -> pop END\"};\n             assert (self.print_stack.len() != 0u);\n             self.print_stack.pop();\n           }\n           BREAK(b) {\n             let top = self.get_top();\n             alt top.pbreak {\n               fits {\n-                #debug(\"print BREAK in fitting block\");\n+                debug!{\"print BREAK in fitting block\"};\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n               broken(consistent) {\n-                #debug(\"print BREAK in consistent block\");\n+                debug!{\"print BREAK in consistent block\"};\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n               broken(inconsistent) {\n                 if L > self.space {\n-                    #debug(\"print BREAK w/ newline in inconsistent\");\n+                    debug!{\"print BREAK w/ newline in inconsistent\"};\n                     self.print_newline(top.offset + b.offset);\n                     self.space = self.margin - (top.offset + b.offset);\n                 } else {\n-                    #debug(\"print BREAK w/o newline in inconsistent\");\n+                    debug!{\"print BREAK w/o newline in inconsistent\"};\n                     self.indent(b.blank_space);\n                     self.space -= b.blank_space;\n                 }\n               }\n             }\n           }\n           STRING(s, len) {\n-            #debug(\"print STRING\");\n+            debug!{\"print STRING\"};\n             assert (L == len);\n             // assert L <= space;\n             self.space -= len;"}, {"sha": "3c1252d3ddceeb876a39bd79a95252c682a177be", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -872,14 +872,14 @@ fn print_mac(s: ps, m: ast::mac) {\n         bclose(s, m.span);\n       }\n       ast::mac_ellipsis { word(s.s, ~\"...\"); }\n-      ast::mac_var(v) { word(s.s, #fmt(\"$%u\", v)); }\n+      ast::mac_var(v) { word(s.s, fmt!{\"$%u\", v}); }\n       _ { /* fixme */ }\n     }\n }\n \n fn print_vstore(s: ps, t: ast::vstore) {\n     alt t {\n-      ast::vstore_fixed(some(i)) { word(s.s, #fmt(\"%u\", i)); }\n+      ast::vstore_fixed(some(i)) { word(s.s, fmt!{\"%u\", i}); }\n       ast::vstore_fixed(none) { word(s.s, ~\"_\"); }\n       ast::vstore_uniq { word(s.s, ~\"~\"); }\n       ast::vstore_box { word(s.s, ~\"@\"); }"}, {"sha": "fede7d55af9667ecca3a7ae90f7bb4bacc0a058b", "filename": "src/rustc/back/link.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Flink.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -343,7 +343,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                               metas: provided_metas,\n                               dep_hashes: ~[@~str]) -> ~str {\n         fn len_and_str(s: ~str) -> ~str {\n-            ret #fmt[\"%u_%s\", str::len(s), s];\n+            ret fmt!{\"%u_%s\", str::len(s), s};\n         }\n \n         fn len_and_str_lit(l: ast::lit) -> ~str {\n@@ -379,8 +379,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n \n     fn warn_missing(sess: session, name: ~str, default: ~str) {\n         if !sess.building_library { ret; }\n-        sess.warn(#fmt[\"missing crate link meta `%s`, using `%s` as default\",\n-                       name, default]);\n+        sess.warn(fmt!{\"missing crate link meta `%s`, using `%s` as default\",\n+                       name, default});\n     }\n \n     fn crate_meta_name(sess: session, _crate: ast::crate,\n@@ -393,8 +393,8 @@ fn build_link_meta(sess: session, c: ast::crate, output: ~str,\n                         let mut os =\n                             str::split_char(path::basename(output), '.');\n                         if (vec::len(os) < 2u) {\n-                            sess.fatal(#fmt(\"output file name `%s` doesn't\\\n-                              appear to have an extension\", output));\n+                            sess.fatal(fmt!{\"output file name `%s` doesn't\\\n+                              appear to have an extension\", output});\n                         }\n                         vec::pop(os);\n                         str::connect(os, ~\".\")\n@@ -505,7 +505,7 @@ fn mangle(ss: path) -> ~str {\n     for ss.each |s| {\n         alt s { path_name(s) | path_mod(s) {\n           let sani = sanitize(*s);\n-          n += #fmt[\"%u%s\", str::len(sani), sani];\n+          n += fmt!{\"%u%s\", str::len(sani), sani};\n         } }\n     }\n     n += ~\"E\"; // End name-sequence.\n@@ -576,12 +576,12 @@ fn link_binary(sess: session,\n \n     let output = if sess.building_library {\n         let long_libname =\n-            os::dll_filename(#fmt(\"%s-%s-%s\",\n-                                  *lm.name, lm.extras_hash, *lm.vers));\n-        #debug(\"link_meta.name:  %s\", *lm.name);\n-        #debug(\"long_libname: %s\", long_libname);\n-        #debug(\"out_filename: %s\", out_filename);\n-        #debug(\"dirname(out_filename): %s\", path::dirname(out_filename));\n+            os::dll_filename(fmt!{\"%s-%s-%s\",\n+                                  *lm.name, lm.extras_hash, *lm.vers});\n+        debug!{\"link_meta.name:  %s\", *lm.name};\n+        debug!{\"long_libname: %s\", long_libname};\n+        debug!{\"out_filename: %s\", out_filename};\n+        debug!{\"dirname(out_filename): %s\", path::dirname(out_filename)};\n \n         path::connect(path::dirname(out_filename), long_libname)\n     } else { out_filename };\n@@ -698,14 +698,14 @@ fn link_binary(sess: session,\n     // extern libraries might live, based on the addl_lib_search_paths\n     vec::push_all(cc_args, rpath::get_rpath_flags(sess, output));\n \n-    #debug(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n+    debug!{\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \")};\n     // We run 'cc' here\n     let prog = run::program_output(cc_prog, cc_args);\n     if 0 != prog.status {\n-        sess.err(#fmt[\"linking with `%s` failed with code %d\",\n-                      cc_prog, prog.status]);\n-        sess.note(#fmt[\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, ~\" \")]);\n+        sess.err(fmt!{\"linking with `%s` failed with code %d\",\n+                      cc_prog, prog.status});\n+        sess.note(fmt!{\"%s arguments: %s\",\n+                       cc_prog, str::connect(cc_args, ~\" \")});\n         sess.note(prog.err + prog.out);\n         sess.abort_if_errors();\n     }\n@@ -718,8 +718,8 @@ fn link_binary(sess: session,\n     // Remove the temporary object file if we aren't saving temps\n     if !sess.opts.save_temps {\n         if ! os::remove_file(obj_filename) {\n-            sess.warn(#fmt[\"failed to delete object file `%s`\",\n-                           obj_filename]);\n+            sess.warn(fmt!{\"failed to delete object file `%s`\",\n+                           obj_filename});\n         }\n     }\n }"}, {"sha": "4f85fb48f2a9563e623c718c85c12751f6f020aa", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -21,7 +21,7 @@ fn get_rpath_flags(sess: session::session, out_filename: ~str) -> ~[~str] {\n         ret ~[];\n     }\n \n-    #debug(\"preparing the RPATH!\");\n+    debug!{\"preparing the RPATH!\"};\n \n     let cwd = os::getcwd();\n     let sysroot = sess.filesearch.sysroot();\n@@ -45,20 +45,20 @@ fn get_sysroot_absolute_rt_lib(sess: session::session) -> path::path {\n }\n \n fn rpaths_to_flags(rpaths: ~[~str]) -> ~[~str] {\n-    vec::map(rpaths, |rpath| #fmt(\"-Wl,-rpath,%s\",rpath) )\n+    vec::map(rpaths, |rpath| fmt!{\"-Wl,-rpath,%s\",rpath} )\n }\n \n fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n               output: path::path, libs: ~[path::path],\n               target_triple: ~str) -> ~[~str] {\n-    #debug(\"cwd: %s\", cwd);\n-    #debug(\"sysroot: %s\", sysroot);\n-    #debug(\"output: %s\", output);\n-    #debug(\"libs:\");\n+    debug!{\"cwd: %s\", cwd};\n+    debug!{\"sysroot: %s\", sysroot};\n+    debug!{\"output: %s\", output};\n+    debug!{\"libs:\"};\n     for libs.each |libpath| {\n-        #debug(\"    %s\", libpath);\n+        debug!{\"    %s\", libpath};\n     }\n-    #debug(\"target_triple: %s\", target_triple);\n+    debug!{\"target_triple: %s\", target_triple};\n \n     // Use relative paths to the libraries. Binaries can be moved\n     // as long as they maintain the relative relationship to the\n@@ -73,9 +73,9 @@ fn get_rpaths(os: session::os, cwd: path::path, sysroot: path::path,\n     let fallback_rpaths = ~[get_install_prefix_rpath(cwd, target_triple)];\n \n     fn log_rpaths(desc: ~str, rpaths: ~[~str]) {\n-        #debug(\"%s rpaths:\", desc);\n+        debug!{\"%s rpaths:\", desc};\n         for rpaths.each |rpath| {\n-            #debug(\"    %s\", rpath);\n+            debug!{\"    %s\", rpath};\n         }\n     }\n \n@@ -124,8 +124,8 @@ fn get_rpath_relative_to_output(os: session::os,\n fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     assert path::path_is_absolute(abs1);\n     assert path::path_is_absolute(abs2);\n-    #debug(\"finding relative path from %s to %s\",\n-           abs1, abs2);\n+    debug!{\"finding relative path from %s to %s\",\n+           abs1, abs2};\n     let normal1 = path::normalize(abs1);\n     let normal2 = path::normalize(abs2);\n     let split1 = path::split(normal1);\n@@ -171,7 +171,7 @@ fn get_absolute(cwd: path::path, lib: path::path) -> path::path {\n }\n \n fn get_install_prefix_rpath(cwd: path::path, target_triple: ~str) -> ~str {\n-    let install_prefix = #env(\"CFG_PREFIX\");\n+    let install_prefix = env!{\"CFG_PREFIX\"};\n \n     if install_prefix == ~\"\" {\n         fail ~\"rustc compiled without CFG_PREFIX environment variable\";\n@@ -222,7 +222,7 @@ mod test {\n     #[test]\n     fn test_prefix_rpath() {\n         let res = get_install_prefix_rpath(~\"/usr/lib\", ~\"triple\");\n-        let d = path::connect(#env(\"CFG_PREFIX\"), ~\"/lib/rustc/triple/lib\");\n+        let d = path::connect(env!{\"CFG_PREFIX\"}, ~\"/lib/rustc/triple/lib\");\n         assert str::ends_with(res, d);\n     }\n "}, {"sha": "7be6103e34f4d41391849e5a988a49c728ff5053", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -115,8 +115,8 @@ fn time<T>(do_it: bool, what: ~str, thunk: fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n-    io::stdout().write_str(#fmt(\"time: %3.3f s\\t%s\\n\",\n-                                end - start, what));\n+    io::stdout().write_str(fmt!{\"time: %3.3f s\\t%s\\n\",\n+                                end - start, what});\n     ret rv;\n }\n \n@@ -397,7 +397,7 @@ fn host_triple() -> ~str {\n     // FIXME (#2400): Instead of grabbing the host triple we really should\n     // be grabbing (at compile time) the target triple that this rustc is\n     // built with and calling that (at runtime) the host triple.\n-    let ht = #env(\"CFG_HOST_TRIPLE\");\n+    let ht = env!{\"CFG_HOST_TRIPLE\"};\n     ret if ht != ~\"\" {\n             ht\n         } else {\n@@ -432,8 +432,8 @@ fn build_session_options(match: getopts::match,\n             let lint_name = str::replace(lint_name, ~\"-\", ~\"_\");\n             alt lint_dict.find(lint_name) {\n               none {\n-                early_error(demitter, #fmt(\"unknown %s flag: %s\",\n-                                           level_name, lint_name));\n+                early_error(demitter, fmt!{\"unknown %s flag: %s\",\n+                                           level_name, lint_name});\n               }\n               some(lint) {\n                 vec::push(lint_opts, (lint.lint, level));\n@@ -452,7 +452,7 @@ fn build_session_options(match: getopts::match,\n             if name == debug_flag { this_bit = bit; break; }\n         }\n         if this_bit == 0u {\n-            early_error(demitter, #fmt(\"unknown debug flag: %s\", debug_flag))\n+            early_error(demitter, fmt!{\"unknown debug flag: %s\", debug_flag})\n         }\n         debugging_opts |= this_bit;\n     }"}, {"sha": "4e457bde04467ebdef5619f612b9416ada3b7926", "filename": "src/rustc/driver/rustc.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Frustc.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -27,14 +27,14 @@ import io::reader_util;\n \n fn version(argv0: ~str) {\n     let mut vers = ~\"unknown version\";\n-    let env_vers = #env[\"CFG_VERSION\"];\n+    let env_vers = env!{\"CFG_VERSION\"};\n     if str::len(env_vers) != 0u { vers = env_vers; }\n-    io::println(#fmt(\"%s %s\", argv0, vers));\n-    io::println(#fmt(\"host: %s\", host_triple()));\n+    io::println(fmt!{\"%s %s\", argv0, vers});\n+    io::println(fmt!{\"host: %s\", host_triple()});\n }\n \n fn usage(argv0: ~str) {\n-    io::println(#fmt(\"Usage: %s [options] <input>\\n\", argv0) +\n+    io::println(fmt!{\"Usage: %s [options] <input>\\n\", argv0} +\n                  ~\"\n Options:\n \n@@ -91,31 +91,31 @@ fn describe_warnings() {\n     fn padded(max: uint, s: ~str) -> ~str {\n         str::from_bytes(vec::from_elem(max - s.len(), ' ' as u8)) + s\n     }\n-    io::println(#fmt(\"\\nAvailable lint checks:\\n\"));\n-    io::println(#fmt(\"    %s  %7.7s  %s\",\n-                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n-    io::println(#fmt(\"    %s  %7.7s  %s\\n\",\n-                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n+    io::println(fmt!{\"\\nAvailable lint checks:\\n\"});\n+    io::println(fmt!{\"    %s  %7.7s  %s\",\n+                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"});\n+    io::println(fmt!{\"    %s  %7.7s  %s\\n\",\n+                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"});\n     for lint_dict.each |k, v| {\n         let k = str::replace(k, ~\"_\", ~\"-\");\n-        io::println(#fmt(\"    %s  %7.7s  %s\",\n+        io::println(fmt!{\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n                          alt v.default {\n                              lint::allow { ~\"allow\" }\n                              lint::warn { ~\"warn\" }\n                              lint::deny { ~\"deny\" }\n                              lint::forbid { ~\"forbid\" }\n                          },\n-                         v.desc));\n+                         v.desc});\n     }\n     io::println(~\"\");\n }\n \n fn describe_debug_flags() {\n-    io::println(#fmt(\"\\nAvailable debug options:\\n\"));\n+    io::println(fmt!{\"\\nAvailable debug options:\\n\"});\n     for session::debugging_opts_map().each |pair| {\n         let (name, desc, _) = pair;\n-        io::println(#fmt(\"    -Z%-20s -- %s\", name, desc));\n+        io::println(fmt!{\"    -Z%-20s -- %s\", name, desc});\n     }\n }\n "}, {"sha": "920d4e2ee8c50a051fde4d1f2643d1d53c9bc049", "filename": "src/rustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fintrinsic_inject.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@ export inject_intrinsic;\n fn inject_intrinsic(sess: session,\n                     crate: @ast::crate) -> @ast::crate {\n \n-    let intrinsic_module = @#include_str(\"intrinsic.rs\");\n+    let intrinsic_module = @include_str!{\"intrinsic.rs\"};\n \n     let item = parse::parse_item_from_source_str(~\"<intrinsic>\",\n                                                  intrinsic_module,"}, {"sha": "1cf825a5e6b5fadc69eeae19beea0cb80634e373", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -99,7 +99,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n    option<@ast::item> {\n \n     vec::push(cx.path, i.ident);\n-    #debug(\"current path: %s\", ast_util::path_name_i(cx.path));\n+    debug!{\"current path: %s\", ast_util::path_name_i(cx.path)};\n \n     if is_test_fn(i) {\n         alt i.node {\n@@ -109,12 +109,12 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n                 ~\"unsafe functions cannot be used for tests\");\n           }\n           _ {\n-            #debug(\"this is a test function\");\n+            debug!{\"this is a test function\"};\n             let test = {span: i.span,\n                         path: cx.path, ignore: is_ignored(cx, i),\n                         should_fail: should_fail(i)};\n             cx.testfns.push(test);\n-            #debug(\"have %u test functions\", cx.testfns.len());\n+            debug!{\"have %u test functions\", cx.testfns.len()};\n           }\n         }\n     }\n@@ -201,7 +201,7 @@ fn mk_test_module(cx: test_ctxt) -> @ast::item {\n          vis: ast::public,\n          span: dummy_sp()};\n \n-    #debug(\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item));\n+    debug!{\"Synthetic test module:\\n%s\\n\", pprust::item_to_str(@item)};\n \n     ret @item;\n }\n@@ -276,7 +276,7 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n }\n \n fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n-    #debug(\"building test vector from %u tests\", cx.testfns.len());\n+    debug!{\"building test vector from %u tests\", cx.testfns.len()};\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n         vec::push(descs, mk_test_desc_rec(cx, test));\n@@ -296,7 +296,7 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = test.path;\n \n-    #debug(\"encoding %s\", ast_util::path_name_i(path));\n+    debug!{\"encoding %s\", ast_util::path_name_i(path)};\n \n     let name_lit: ast::lit =\n         nospan(ast::lit_str(@ast_util::path_name_i(path)));"}, {"sha": "68fcb8c918335939d96b99c73640161e8584b7c1", "filename": "src/rustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flib%2Fllvm.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1090,7 +1090,7 @@ fn type_to_str_inner(names: type_names, outer0: ~[TypeRef], ty: TypeRef) ->\n             if addrspace == 0u {\n                 ~\"\"\n             } else {\n-                #fmt(\"addrspace(%u)\", addrspace)\n+                fmt!{\"addrspace(%u)\", addrspace}\n             }\n         };\n         ret addrstr + ~\"*\" +"}, {"sha": "03e5fde96a05bdf1f1ad547de73b6f135a155526", "filename": "src/rustc/metadata/creader.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcreader.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -43,16 +43,16 @@ type cache_entry = {\n };\n \n fn dump_crates(crate_cache: dvec<cache_entry>) {\n-    #debug(\"resolved crates:\");\n+    debug!{\"resolved crates:\"};\n     for crate_cache.each |entry| {\n-        #debug(\"cnum: %?\", entry.cnum);\n-        #debug(\"span: %?\", entry.span);\n-        #debug(\"hash: %?\", entry.hash);\n+        debug!{\"cnum: %?\", entry.cnum};\n+        debug!{\"span: %?\", entry.span};\n+        debug!{\"hash: %?\", entry.hash};\n         let attrs = ~[\n             attr::mk_attr(attr::mk_list_item(@~\"link\", *entry.metas))\n         ];\n         for attr::find_linkage_attrs(attrs).each |attr| {\n-            #debug(\"meta: %s\", pprust::attr_to_str(attr));\n+            debug!{\"meta: %s\", pprust::attr_to_str(attr)};\n         }\n     }\n }\n@@ -77,7 +77,7 @@ fn warn_if_multiple_versions(diag: span_handler,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                #fmt(\"using multiple versions of crate `%s`\", *name));\n+                fmt!{\"using multiple versions of crate `%s`\", *name});\n             for matches.each |match| {\n                 diag.span_note(match.span, ~\"used here\");\n                 let attrs = ~[\n@@ -102,7 +102,7 @@ type env = @{diag: span_handler,\n fn visit_view_item(e: env, i: @ast::view_item) {\n     alt i.node {\n       ast::view_item_use(ident, meta_items, id) {\n-        #debug(\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items);\n+        debug!{\"resolving use stmt. ident: %?, meta: %?\", ident, meta_items};\n         let cnum = resolve_crate(e, ident, meta_items, ~\"\", i.span);\n         cstore::add_use_stmt_cnum(e.cstore, id, cnum);\n       }\n@@ -238,24 +238,24 @@ fn resolve_crate(e: env, ident: ast::ident, metas: ~[@ast::meta_item],\n \n // Go through the crate metadata and load any crates that it references\n fn resolve_crate_deps(e: env, cdata: @~[u8]) -> cstore::cnum_map {\n-    #debug(\"resolving deps of external crate\");\n+    debug!{\"resolving deps of external crate\"};\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers\n     let cnum_map = int_hash::<ast::crate_num>();\n     for decoder::get_crate_deps(cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n-        #debug(\"resolving dep crate %s ver: %s hash: %s\",\n-               *dep.name, *dep.vers, *dep.hash);\n+        debug!{\"resolving dep crate %s ver: %s hash: %s\",\n+               *dep.name, *dep.vers, *dep.hash};\n         alt existing_match(e, metas_with_ident(cname, cmetas), *dep.hash) {\n           some(local_cnum) {\n-            #debug(\"already have it\");\n+            debug!{\"already have it\"};\n             // We've already seen this crate\n             cnum_map.insert(extrn_cnum, local_cnum);\n           }\n           none {\n-            #debug(\"need to load it\");\n+            debug!{\"need to load it\"};\n             // This is a new one so we've got to load it\n             // FIXME (#2404): Need better error reporting than just a bogus\n             // span."}, {"sha": "91a22b9fe2f23e105c76887d2d0be1e4df1b9276", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -46,7 +46,7 @@ fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n                path: ~[ast::ident]) -> ~[ast::def] {\n     let mut result = ~[];\n-    #debug(\"lookup_defs: path = %? cnum = %?\", path, cnum);\n+    debug!{\"lookup_defs: path = %? cnum = %?\", path, cnum};\n     for resolve_path(cstore, cnum, path).each |elt| {\n         let (c, data, def) = elt;\n         vec::push(result, decoder::lookup_def(c, data, def));\n@@ -68,8 +68,8 @@ fn resolve_path(cstore: cstore::cstore, cnum: ast::crate_num,\n                 path: ~[ast::ident]) ->\n     ~[(ast::crate_num, @~[u8], ast::def_id)] {\n     let cm = cstore::get_crate_data(cstore, cnum);\n-    #debug(\"resolve_path %s in crates[%d]:%s\",\n-           ast_util::path_name_i(path), cnum, cm.name);\n+    debug!{\"resolve_path %s in crates[%d]:%s\",\n+           ast_util::path_name_i(path), cnum, cm.name};\n     let mut result = ~[];\n     for decoder::resolve_path(path, cm.data).each |def| {\n         if def.crate == ast::local_crate {\n@@ -181,17 +181,17 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n     let all_items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n-    #debug(\"Looking up %?\", class_id);\n+    debug!{\"Looking up %?\", class_id};\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),\n-                           || #fmt(\"get_field_type: class ID %? not found\",\n-                                   class_id) );\n-    #debug(\"looking up %? : %?\", def, class_doc);\n+                           || fmt!{\"get_field_type: class ID %? not found\",\n+                                   class_id} );\n+    debug!{\"looking up %? : %?\", def, class_doc};\n     let the_field = expect(tcx.diag,\n         decoder::maybe_find_item(def.node, class_doc),\n-        || #fmt(\"get_field_type: in class %?, field ID %? not found\",\n-                 class_id, def) );\n-    #debug(\"got field data %?\", the_field);\n+        || fmt!{\"get_field_type: in class %?, field ID %? not found\",\n+                 class_id, def} );\n+    debug!{\"got field data %?\", the_field};\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ret {bounds: @~[], rp: false, ty: ty};\n }"}, {"sha": "fd541c33d2d651130d8bb3e6ecf07f21f01a142f", "filename": "src/rustc/metadata/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcstore.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -160,16 +160,16 @@ fn get_dep_hashes(cstore: cstore) -> ~[@~str] {\n     for p(cstore).use_crate_map.each_value |cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n-        #debug(\"Add hash[%s]: %s\", cdata.name, *hash);\n+        debug!{\"Add hash[%s]: %s\", cdata.name, *hash};\n         vec::push(result, {name: @cdata.name, hash: hash});\n     };\n     fn lteq(a: crate_hash, b: crate_hash) -> bool {\n         ret *a.name <= *b.name;\n     }\n     let sorted = std::sort::merge_sort(lteq, result);\n-    #debug(\"sorted:\");\n+    debug!{\"sorted:\"};\n     for sorted.each |x| {\n-        #debug(\"  hash[%s]: %s\", *x.name, *x.hash);\n+        debug!{\"  hash[%s]: %s\", *x.name, *x.hash};\n     }\n     fn mapper(ch: crate_hash) -> @~str { ret ch.hash; }\n     ret vec::map(sorted, mapper);"}, {"sha": "ba5ff3a6a9d5f4d8fb98de8a23f2ed80ba77fab1", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -100,7 +100,7 @@ fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n fn lookup_item(item_id: int, data: @~[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::doc(data), tag_items);\n     alt maybe_find_item(item_id, items) {\n-       none { fail(#fmt(\"lookup_item: id not found: %d\", item_id)); }\n+       none { fail(fmt!{\"lookup_item: id not found: %d\", item_id}); }\n        some(d) { d }\n     }\n }\n@@ -231,7 +231,7 @@ fn resolve_path(path: ~[ast::ident], data: @~[u8]) -> ~[ast::def_id] {\n     let paths = ebml::get_doc(md, tag_paths);\n     let eqer = |a| eq_item(a, s);\n     let mut result: ~[ast::def_id] = ~[];\n-    #debug(\"resolve_path: looking up %s\", s);\n+    debug!{\"resolve_path: looking up %s\", s};\n     for lookup_hash(paths, eqer, hash_path(s)).each |doc| {\n         let did_doc = ebml::get_doc(doc, tag_def_id);\n         vec::push(result, ebml::with_doc_data(did_doc, |d| parse_def_id(d)));\n@@ -295,7 +295,7 @@ fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n       'I' { dl_def(ast::def_ty(did)) }\n       'i' { dl_impl(did) }\n       'g' | 'j' { dl_field }\n-      ch { fail #fmt(\"unexpected family code: '%c'\", ch) }\n+      ch { fail fmt!{\"unexpected family code: '%c'\", ch} }\n     }\n }\n \n@@ -351,8 +351,8 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n     let mut found = none;\n     let cls_items = alt maybe_find_item(id, items) {\n             some(it) { it }\n-            none { fail (#fmt(\"get_class_method: class id not found \\\n-             when looking up method %s\", *name)) }};\n+            none { fail (fmt!{\"get_class_method: class id not found \\\n+             when looking up method %s\", *name}) }};\n     for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = class_member_id(mid, cdata);\n         if item_name(mid) == name {\n@@ -361,7 +361,7 @@ fn get_class_method(cdata: cmd, id: ast::node_id,\n     }\n     alt found {\n       some(found) { found }\n-      none { fail (#fmt(\"get_class_method: no method named %s\", *name)) }\n+      none { fail (fmt!{\"get_class_method: no method named %s\", *name}) }\n     }\n }\n \n@@ -370,8 +370,8 @@ fn class_dtor(cdata: cmd, id: ast::node_id) -> option<ast::def_id> {\n     let mut found = none;\n     let cls_items = alt maybe_find_item(id, items) {\n             some(it) { it }\n-            none     { fail (#fmt(\"class_dtor: class id not found \\\n-              when looking up dtor for %d\", id)); }\n+            none     { fail (fmt!{\"class_dtor: class id not found \\\n+              when looking up dtor for %d\", id}); }\n     };\n     for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n          let doc1 = ebml::get_doc(doc, tag_def_id);\n@@ -431,7 +431,7 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n                 let def_id = class_member_id(item_doc, cdata);\n \n                 // Construct the def for this item.\n-                #debug(\"(each_path) yielding explicit item: %s\", name);\n+                debug!{\"(each_path) yielding explicit item: %s\", name};\n                 let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n \n                 // Hand the information off to the iteratee.\n@@ -468,17 +468,17 @@ fn each_path(cdata: cmd, f: fn(path_entry) -> bool) {\n             // Get the item.\n             alt maybe_find_item(def_id.node, items) {\n                 none {\n-                    #debug(\"(each_path) ignoring implicit item: %s\",\n-                            *path);\n+                    debug!{\"(each_path) ignoring implicit item: %s\",\n+                            *path};\n                 }\n                 some(item_doc) {\n                     // Construct the def for this item.\n                     let def_like = item_to_def_like(item_doc, def_id,\n                                                     cdata.cnum);\n \n                     // Hand the information off to the iteratee.\n-                    #debug(\"(each_path) yielding implicit item: %s\",\n-                            *path);\n+                    debug!{\"(each_path) yielding implicit item: %s\",\n+                            *path};\n                     let this_path_entry = path_entry(*path, def_like);\n                     if (!f(this_path_entry)) {\n                         broken = true;      // XXX: This is awful.\n@@ -511,7 +511,7 @@ fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n                       decode_inlined_item: decode_inlined_item\n                      ) -> csearch::found_ast {\n-    #debug(\"Looking up item: %d\", id);\n+    debug!{\"Looking up item: %d\", id};\n     let item_doc = lookup_item(id, cdata.data);\n     let path = vec::init(item_path(item_doc));\n     alt decode_inlined_item(cdata, tcx, path, item_doc) {\n@@ -594,8 +594,8 @@ fn get_impls_for_mod(cdata: cmd,\n     for ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n         let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n-        #debug(\"(get impls for mod) getting did %? for '%?'\",\n-               local_did, name);\n+        debug!{\"(get impls for mod) getting did %? for '%?'\",\n+               local_did, name};\n           // The impl may be defined in a different crate. Ask the caller\n           // to give us the metadata\n         let impl_cdata = get_cdata(local_did.crate);\n@@ -723,7 +723,7 @@ fn describe_def(items: ebml::doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { ret ~\"external\"; }\n     let it = alt maybe_find_item(id.node, items) {\n         some(it) { it }\n-        none { fail (#fmt(\"describe_def: item not found %?\", id)); }\n+        none { fail (fmt!{\"describe_def: item not found %?\", id}); }\n     };\n     ret item_family_to_str(item_family(it));\n }\n@@ -800,15 +800,15 @@ fn get_attributes(md: ebml::doc) -> ~[ast::attribute] {\n \n fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n     for get_meta_items(meta_items).each |mi| {\n-        out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n+        out.write_str(fmt!{\"%s\\n\", pprust::meta_item_to_str(*mi)});\n     }\n }\n \n fn list_crate_attributes(md: ebml::doc, hash: @~str, out: io::writer) {\n-    out.write_str(#fmt(\"=Crate Attributes (%s)=\\n\", *hash));\n+    out.write_str(fmt!{\"=Crate Attributes (%s)=\\n\", *hash});\n \n     for get_attributes(md).each |attr| {\n-        out.write_str(#fmt[\"%s\\n\", pprust::attribute_to_str(attr)]);\n+        out.write_str(fmt!{\"%s\\n\", pprust::attribute_to_str(attr)});\n     }\n \n     out.write_str(~\"\\n\\n\");\n@@ -843,8 +843,8 @@ fn list_crate_deps(data: @~[u8], out: io::writer) {\n     out.write_str(~\"=External Dependencies=\\n\");\n \n     for get_crate_deps(data).each |dep| {\n-        out.write_str(#fmt[\"%d %s-%s-%s\\n\",\n-                           dep.cnum, *dep.name, *dep.hash, *dep.vers]);\n+        out.write_str(fmt!{\"%d %s-%s-%s\\n\",\n+                           dep.cnum, *dep.name, *dep.hash, *dep.vers});\n     }\n \n     out.write_str(~\"\\n\");\n@@ -871,8 +871,8 @@ fn list_crate_items(bytes: @~[u8], md: ebml::doc, out: io::writer) {\n     do iter_crate_items(bytes) |tag, path, did| {\n       // Don't print out any metadata info about intrinsics\n        if tag != tag_paths_foreign_path {\n-            out.write_str(#fmt[\"%s (%s)\\n\", path,\n-                               describe_def(items, did)]);\n+            out.write_str(fmt!{\"%s (%s)\\n\", path,\n+                               describe_def(items, did)});\n        }\n     }\n     out.write_str(~\"\\n\");"}, {"sha": "ee4a8bdd63faa4823404d0708692f39327a3ba08", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -273,7 +273,7 @@ fn encode_family(ebml_w: ebml::writer, c: char) {\n     ebml_w.end_tag();\n }\n \n-fn def_to_str(did: def_id) -> ~str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n+fn def_to_str(did: def_id) -> ~str { ret fmt!{\"%d:%d\", did.crate, did.node}; }\n \n fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n@@ -318,7 +318,7 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n       some(x) { x }\n       none {\n         ecx.diag.handler().bug(\n-            #fmt(\"encode_symbol: id not found %d\", id));\n+            fmt!{\"encode_symbol: id not found %d\", id});\n       }\n     };\n     ebml_w.writer.write(str::bytes(sym));\n@@ -400,17 +400,17 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::writer, md: _mod,\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n     encode_name(ebml_w, name);\n-    #debug(\"(encoding info for module) encoding info for module ID %d\", id);\n+    debug!{\"(encoding info for module) encoding info for module ID %d\", id};\n     // the impl map contains ref_ids\n     let impls = ecx.impl_map(id);\n     for impls.each |i| {\n         let (ident, did) = i;\n-        #debug(\"(encoding info for module) ... encoding impl %s (%?/%?), \\\n+        debug!{\"(encoding info for module) ... encoding impl %s (%?/%?), \\\n                 exported? %?\",\n                *ident,\n                did,\n                ast_map::node_id_to_str(ecx.tcx.items, did.node),\n-               ast_util::is_exported(ident, md));\n+               ast_util::is_exported(ident, md)};\n \n         ebml_w.start_tag(tag_mod_impl);\n         alt ecx.tcx.items.find(did.node) {\n@@ -456,7 +456,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n           vec::push(*index, {val: id, pos: ebml_w.writer.tell()});\n           vec::push(*global_index, {val: id, pos: ebml_w.writer.tell()});\n           ebml_w.start_tag(tag_items_data_item);\n-          #debug(\"encode_info_for_class: doing %s %d\", *nm, id);\n+          debug!{\"encode_info_for_class: doing %s %d\", *nm, id};\n           encode_visibility(ebml_w, vis);\n           encode_name(ebml_w, nm);\n           encode_path(ebml_w, path, ast_map::path_name(nm));\n@@ -473,7 +473,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           {val: m.id, pos: ebml_w.writer.tell()});\n                 let impl_path = vec::append_one(path,\n                                                 ast_map::path_name(m.ident));\n-                #debug(\"encode_info_for_class: doing %s %d\", *m.ident, m.id);\n+                debug!{\"encode_info_for_class: doing %s %d\", *m.ident, m.id};\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n                                        should_inline(m.attrs), id, m,\n                                        vec::append(class_tps, m.tps));\n@@ -496,8 +496,8 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_family(ebml_w, purity_fn_family(decl.purity));\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n-        #debug(\"fn name = %s ty = %s its node id = %d\", *ident,\n-               util::ppaux::ty_to_str(ecx.tcx, its_ty), id);\n+        debug!{\"fn name = %s ty = %s its node id = %d\", *ident,\n+               util::ppaux::ty_to_str(ecx.tcx, its_ty), id};\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n         alt item {\n@@ -515,7 +515,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n-    #debug(\"encode_info_for_method: %d %s %u\", m.id, *m.ident, all_tps.len());\n+    debug!{\"encode_info_for_method: %d %s %u\", m.id, *m.ident, all_tps.len()};\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     encode_family(ebml_w, purity_fn_family(m.decl.purity));\n@@ -838,8 +838,8 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                 /* encode ctor, then encode items */\n                 alt i.node {\n                    item_class(tps, _, _, some(ctor), m_dtor) {\n-                       #debug(\"encoding info for ctor %s %d\", *i.ident,\n-                              ctor.node.id);\n+                       debug!{\"encoding info for ctor %s %d\", *i.ident,\n+                              ctor.node.id};\n                        vec::push(*index, {\n                             val: ctor.node.id,\n                             pos: ebml_w.writer.tell()"}, {"sha": "9e68ce12a3c629c99bc3de5cb2adb1047b9be6fc", "filename": "src/rustc/metadata/filesearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ffilesearch.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -62,7 +62,7 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n     }\n \n     let sysroot = get_sysroot(maybe_sysroot);\n-    #debug(\"using sysroot = %s\", sysroot);\n+    debug!{\"using sysroot = %s\", sysroot};\n     {sysroot: sysroot,\n      addl_lib_search_paths: addl_lib_search_paths,\n      target_triple: target_triple} as filesearch\n@@ -71,16 +71,16 @@ fn mk_filesearch(maybe_sysroot: option<path>,\n fn search<T: copy>(filesearch: filesearch, pick: pick<T>) -> option<T> {\n     let mut rslt = none;\n     for filesearch.lib_search_paths().each |lib_search_path| {\n-        #debug(\"searching %s\", lib_search_path);\n+        debug!{\"searching %s\", lib_search_path};\n         for os::list_dir_path(lib_search_path).each |path| {\n-            #debug(\"testing %s\", path);\n+            debug!{\"testing %s\", path};\n             let maybe_picked = pick(path);\n             if option::is_some(maybe_picked) {\n-                #debug(\"picked %s\", path);\n+                debug!{\"picked %s\", path};\n                 rslt = maybe_picked;\n                 break;\n             } else {\n-                #debug(\"rejected %s\", path);\n+                debug!{\"rejected %s\", path};\n             }\n         }\n         if option::is_some(rslt) { break; }\n@@ -172,7 +172,7 @@ fn get_cargo_lib_path_nearest() -> result<path, ~str> {\n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n fn libdir() -> ~str {\n-   let libdir = #env(\"CFG_LIBDIR\");\n+   let libdir = env!{\"CFG_LIBDIR\"};\n    if str::is_empty(libdir) {\n       fail ~\"rustc compiled without CFG_LIBDIR environment variable\";\n    }"}, {"sha": "76cfba66b733e14e30ba9786e4153eb934e96703", "filename": "src/rustc/metadata/loader.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Floader.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -41,7 +41,7 @@ fn load_library_crate(cx: ctxt) -> {ident: ~str, data: @~[u8]} {\n       some(t) { ret t; }\n       none {\n         cx.diag.span_fatal(\n-            cx.span, #fmt[\"can't find crate for `%s`\", *cx.ident]);\n+            cx.span, fmt!{\"can't find crate for `%s`\", *cx.ident});\n       }\n     }\n }\n@@ -71,27 +71,27 @@ fn find_library_crate_aux(cx: ctxt,\n \n     let mut matches = ~[];\n     filesearch::search(filesearch, |path| {\n-        #debug(\"inspecting file %s\", path);\n+        debug!{\"inspecting file %s\", path};\n         let f: ~str = path::basename(path);\n         if !(str::starts_with(f, prefix) && str::ends_with(f, suffix)) {\n-            #debug(\"skipping %s, doesn't look like %s*%s\", path, prefix,\n-                   suffix);\n+            debug!{\"skipping %s, doesn't look like %s*%s\", path, prefix,\n+                   suffix};\n             option::none::<()>\n         } else {\n-            #debug(\"%s is a candidate\", path);\n+            debug!{\"%s is a candidate\", path};\n             alt get_metadata_section(cx.os, path) {\n               option::some(cvec) {\n                 if !crate_matches(cvec, cx.metas, cx.hash) {\n-                    #debug(\"skipping %s, metadata doesn't match\", path);\n+                    debug!{\"skipping %s, metadata doesn't match\", path};\n                     option::none::<()>\n                 } else {\n-                    #debug(\"found %s with matching metadata\", path);\n+                    debug!{\"found %s with matching metadata\", path};\n                     vec::push(matches, {ident: path, data: cvec});\n                     option::none::<()>\n                 }\n               }\n               _ {\n-                #debug(\"could not load metadata for %s\", path);\n+                debug!{\"could not load metadata for %s\", path};\n                 option::none::<()>\n               }\n             }\n@@ -104,10 +104,10 @@ fn find_library_crate_aux(cx: ctxt,\n         some(matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, #fmt(\"multiple matching crates for `%s`\", *crate_name));\n+            cx.span, fmt!{\"multiple matching crates for `%s`\", *crate_name});\n         cx.diag.handler().note(~\"candidates:\");\n         for matches.each |match| {\n-            cx.diag.handler().note(#fmt(\"path: %s\", match.ident));\n+            cx.diag.handler().note(fmt!{\"path: %s\", match.ident});\n             let attrs = decoder::get_crate_attributes(match.data);\n             note_linkage_attrs(cx.diag, attrs);\n         }\n@@ -133,7 +133,7 @@ fn crate_name_from_metas(metas: ~[@ast::meta_item]) -> @~str {\n \n fn note_linkage_attrs(diag: span_handler, attrs: ~[ast::attribute]) {\n     for attr::find_linkage_attrs(attrs).each |attr| {\n-        diag.handler().note(#fmt(\"meta: %s\", pprust::attr_to_str(attr)));\n+        diag.handler().note(fmt!{\"meta: %s\", pprust::attr_to_str(attr)});\n     }\n }\n \n@@ -151,18 +151,18 @@ fn crate_matches(crate_data: @~[u8], metas: ~[@ast::meta_item],\n fn metadata_matches(extern_metas: ~[@ast::meta_item],\n                     local_metas: ~[@ast::meta_item]) -> bool {\n \n-    #debug(\"matching %u metadata requirements against %u items\",\n-           vec::len(local_metas), vec::len(extern_metas));\n+    debug!{\"matching %u metadata requirements against %u items\",\n+           vec::len(local_metas), vec::len(extern_metas)};\n \n-    #debug(\"crate metadata:\");\n+    debug!{\"crate metadata:\"};\n     for extern_metas.each |have| {\n-        #debug(\"  %s\", pprust::meta_item_to_str(*have));\n+        debug!{\"  %s\", pprust::meta_item_to_str(*have)};\n     }\n \n     for local_metas.each |needed| {\n-        #debug(\"looking for %s\", pprust::meta_item_to_str(*needed));\n+        debug!{\"looking for %s\", pprust::meta_item_to_str(*needed)};\n         if !attr::contains(extern_metas, needed) {\n-            #debug(\"missing %s\", pprust::meta_item_to_str(*needed));\n+            debug!{\"missing %s\", pprust::meta_item_to_str(*needed)};\n             ret false;\n         }\n     }"}, {"sha": "fad9d2d942fc88dba687385924e9ef52872f739a", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -297,16 +297,16 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       }\n       'B' { ty::mk_opaque_box(st.tcx) }\n       'a' {\n-          #debug(\"saw a class\");\n+          debug!{\"saw a class\"};\n           assert (next(st) == '[');\n-          #debug(\"saw a [\");\n+          debug!{\"saw a [\"};\n           let did = parse_def(st, conv);\n-          #debug(\"parsed a def_id %?\", did);\n+          debug!{\"parsed a def_id %?\", did};\n           let substs = parse_substs(st, conv);\n           assert (next(st) == ']');\n           ret ty::mk_class(st.tcx, did, substs);\n       }\n-      c { #error(\"unexpected char in type string: %c\", c); fail;}\n+      c { error!{\"unexpected char in type string: %c\", c}; fail;}\n     }\n }\n \n@@ -389,21 +389,21 @@ fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let len = vec::len(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }\n     if colon_idx == len {\n-        #error(\"didn't find ':' when parsing def id\");\n+        error!{\"didn't find ':' when parsing def id\"};\n         fail;\n     }\n     let crate_part = vec::slice(buf, 0u, colon_idx);\n     let def_part = vec::slice(buf, colon_idx + 1u, len);\n \n     let crate_num = alt uint::parse_buf(crate_part, 10u) {\n        some(cn) { cn as int }\n-       none { fail (#fmt(\"internal error: parse_def_id: crate number \\\n-         expected, but found %?\", crate_part)); }\n+       none { fail (fmt!{\"internal error: parse_def_id: crate number \\\n+         expected, but found %?\", crate_part}); }\n     };\n     let def_num = alt uint::parse_buf(def_part, 10u) {\n        some(dn) { dn as int }\n-       none { fail (#fmt(\"internal error: parse_def_id: id expected, but \\\n-         found %?\", def_part)); }\n+       none { fail (fmt!{\"internal error: parse_def_id: id expected, but \\\n+         found %?\", def_part}); }\n     };\n     ret {crate: crate_num, node: def_num};\n }"}, {"sha": "7bcf6d778418475ca7c1d5927bd3651e6ab77e85", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -293,15 +293,15 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_opaque_closure_ptr(ty::ck_uniq) { w.write_str(&\"C~\"); }\n       ty::ty_opaque_box { w.write_char('B'); }\n       ty::ty_class(def, substs) {\n-          #debug(\"~~~~ %s\", ~\"a[\");\n+          debug!{\"~~~~ %s\", ~\"a[\"};\n           w.write_str(&\"a[\");\n           let s = cx.ds(def);\n-          #debug(\"~~~~ %s\", s);\n+          debug!{\"~~~~ %s\", s};\n           w.write_str(s);\n-          #debug(\"~~~~ %s\", ~\"|\");\n+          debug!{\"~~~~ %s\", ~\"|\"};\n           w.write_char('|');\n           enc_substs(w, cx, substs);\n-          #debug(\"~~~~ %s\", ~\"]\");\n+          debug!{\"~~~~ %s\", ~\"]\"};\n           w.write_char(']');\n       }\n     }"}, {"sha": "bbbf894779267fda7e61d331dc4d42eefefa15a4", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -89,9 +89,9 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n-    #debug[\"> Encoding inlined item: %s::%s (%u)\",\n+    debug!{\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path), *ii.ident(),\n-           ebml_w.writer.tell()];\n+           ebml_w.writer.tell()};\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n     do ebml_w.wr_tag(c::tag_ast as uint) {\n@@ -100,9 +100,9 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n     }\n \n-    #debug[\"< Encoded inlined fn: %s::%s (%u)\",\n+    debug!{\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path), *ii.ident(),\n-           ebml_w.writer.tell()];\n+           ebml_w.writer.tell()};\n }\n \n fn decode_inlined_item(cdata: cstore::crate_metadata,\n@@ -114,7 +114,7 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n     alt par_doc.opt_child(c::tag_ast) {\n       none { none }\n       some(ast_doc) {\n-        #debug[\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)];\n+        debug!{\"> Decoding inlined fn: %s::?\", ast_map::path_to_str(path)};\n         let ast_dsr = ebml::ebml_deserializer(ast_doc);\n         let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n@@ -125,14 +125,14 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n         let ii = renumber_ast(xcx, raw_ii);\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, ii);\n-        #debug[\"Fn named: %s\", *ii.ident()];\n+        debug!{\"Fn named: %s\", *ii.ident()};\n         decode_side_tables(xcx, ast_doc);\n-        #debug[\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path), *ii.ident()];\n+        debug!{\"< Decoded inlined fn: %s::%s\",\n+               ast_map::path_to_str(path), *ii.ident()};\n         alt ii {\n           ast::ii_item(i) {\n-            #debug(\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n-                   syntax::print::pprust::item_to_str(i));\n+            debug!{\">>> DECODED ITEM >>>\\n%s\\n<<< DECODED ITEM <<<\",\n+                   syntax::print::pprust::item_to_str(i)};\n           }\n           _ { }\n         }\n@@ -641,7 +641,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n-    #debug[\"Encoding side tables for id %d\", id];\n+    debug!{\"Encoding side tables for id %d\", id};\n \n     do option::iter(tcx.def_map.find(id)) |def| {\n         do ebml_w.tag(c::tag_table_def) {\n@@ -833,9 +833,9 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n         let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n-        #debug[\">> Side table document with tag 0x%x \\\n+        debug!{\">> Side table document with tag 0x%x \\\n                 found for id %d (orig %d)\",\n-               tag, id, id0];\n+               tag, id, id0};\n \n         if tag == (c::tag_table_mutbl as uint) {\n             dcx.maps.mutbl_map.insert(id, ());\n@@ -884,11 +884,11 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.tcx.borrowings.insert(id, borrow);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n-                    #fmt[\"unknown tag found in side tables: %x\", tag]);\n+                    fmt!{\"unknown tag found in side tables: %x\", tag});\n             }\n         }\n \n-        #debug[\">< Side table doc loaded\"];\n+        debug!{\">< Side table doc loaded\"};\n     }\n }\n \n@@ -931,45 +931,45 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n-    #debug[\"in_item = %s\", pprust::item_to_str(in_item)];\n+    debug!{\"in_item = %s\", pprust::item_to_str(in_item)};\n     let mbuf = io::mem_buffer();\n     let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n     encode_item_ast(ebml_w, in_item);\n     let ebml_doc = ebml::doc(@io::mem_buffer_buf(mbuf));\n     let out_item = decode_item_ast(ebml_doc);\n-    #debug[\"out_item = %s\", pprust::item_to_str(out_item)];\n+    debug!{\"out_item = %s\", pprust::item_to_str(out_item)};\n \n     let exp_str =\n         io::with_str_writer(|w| ast::serialize_item(w, *in_item) );\n     let out_str =\n         io::with_str_writer(|w| ast::serialize_item(w, *out_item) );\n \n-    #debug[\"expected string: %s\", exp_str];\n-    #debug[\"actual string  : %s\", out_str];\n+    debug!{\"expected string: %s\", exp_str};\n+    debug!{\"actual string  : %s\", out_str};\n \n     assert exp_str == out_str;\n }\n \n #[test]\n fn test_basic() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast(item){\n+    roundtrip(#ast[item]{\n         fn foo() {}\n     });\n }\n \n #[test]\n fn test_smalltalk() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast(item){\n+    roundtrip(#ast[item]{\n         fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n     });\n }\n \n #[test]\n fn test_more() {\n     let ext_cx = mk_ctxt();\n-    roundtrip(#ast(item){\n+    roundtrip(#ast[item]{\n         fn foo(x: uint, y: uint) -> uint {\n             let z = x + y;\n             ret z;\n@@ -980,14 +980,14 @@ fn test_more() {\n #[test]\n fn test_simplification() {\n     let ext_cx = mk_ctxt();\n-    let item_in = ast::ii_item(#ast(item) {\n+    let item_in = ast::ii_item(#ast[item] {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n             fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n             ret {eq_fn: eq_int, mut data: ~[]};\n         }\n     });\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::ii_item(#ast(item) {\n+    let item_exp = ast::ii_item(#ast[item] {\n         fn new_int_alist<B: copy>() -> alist<int, B> {\n             ret {eq_fn: eq_int, mut data: ~[]};\n         }"}, {"sha": "2c326aa68ef7316368b7ab3c44d145c9ede30864", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -255,24 +255,24 @@ fn check_crate(tcx: ty::ctxt,\n \n     if tcx.sess.borrowck_stats() {\n         io::println(~\"--- borrowck stats ---\");\n-        io::println(#fmt[\"paths requiring guarantees: %u\",\n-                        bccx.guaranteed_paths]);\n-        io::println(#fmt[\"paths requiring loans     : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_same)]);\n-        io::println(#fmt[\"paths requiring imm loans : %s\",\n-                         make_stat(bccx, bccx.loaned_paths_imm)]);\n-        io::println(#fmt[\"stable paths              : %s\",\n-                         make_stat(bccx, bccx.stable_paths)]);\n-        io::println(#fmt[\"paths requiring purity    : %s\",\n-                         make_stat(bccx, bccx.req_pure_paths)]);\n+        io::println(fmt!{\"paths requiring guarantees: %u\",\n+                        bccx.guaranteed_paths});\n+        io::println(fmt!{\"paths requiring loans     : %s\",\n+                         make_stat(bccx, bccx.loaned_paths_same)});\n+        io::println(fmt!{\"paths requiring imm loans : %s\",\n+                         make_stat(bccx, bccx.loaned_paths_imm)});\n+        io::println(fmt!{\"stable paths              : %s\",\n+                         make_stat(bccx, bccx.stable_paths)});\n+        io::println(fmt!{\"paths requiring purity    : %s\",\n+                         make_stat(bccx, bccx.req_pure_paths)});\n     }\n \n     ret (bccx.root_map, bccx.mutbl_map);\n \n     fn make_stat(bccx: borrowck_ctxt, stat: uint) -> ~str {\n         let stat_f = stat as float;\n         let total = bccx.guaranteed_paths as float;\n-        #fmt[\"%u (%.0f%%)\", stat  , stat_f * 100f / total]\n+        fmt!{\"%u (%.0f%%)\", stat  , stat_f * 100f / total}\n     }\n }\n \n@@ -465,8 +465,8 @@ impl error_methods for borrowck_ctxt {\n     fn report(err: bckerr) {\n         self.span_err(\n             err.cmt.span,\n-            #fmt[\"illegal borrow: %s\",\n-                 self.bckerr_code_to_str(err.code)]);\n+            fmt!{\"illegal borrow: %s\",\n+                 self.bckerr_code_to_str(err.code)});\n     }\n \n     fn span_err(s: span, m: ~str) {\n@@ -499,15 +499,15 @@ impl to_str_methods for borrowck_ctxt {\n           cat_special(sk_heap_upvar) { ~\"heap-upvar\" }\n           cat_stack_upvar(_) { ~\"stack-upvar\" }\n           cat_rvalue { ~\"rvalue\" }\n-          cat_local(node_id) { #fmt[\"local(%d)\", node_id] }\n-          cat_binding(node_id) { #fmt[\"binding(%d)\", node_id] }\n-          cat_arg(node_id) { #fmt[\"arg(%d)\", node_id] }\n+          cat_local(node_id) { fmt!{\"local(%d)\", node_id} }\n+          cat_binding(node_id) { fmt!{\"binding(%d)\", node_id} }\n+          cat_arg(node_id) { fmt!{\"arg(%d)\", node_id} }\n           cat_deref(cmt, derefs, ptr) {\n-            #fmt[\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n-                 self.ptr_sigil(ptr), derefs]\n+            fmt!{\"%s->(%s, %u)\", self.cat_to_repr(cmt.cat),\n+                 self.ptr_sigil(ptr), derefs}\n           }\n           cat_comp(cmt, comp) {\n-            #fmt[\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)]\n+            fmt!{\"%s.%s\", self.cat_to_repr(cmt.cat), self.comp_to_repr(comp)}\n           }\n           cat_discr(cmt, _) { self.cat_to_repr(cmt.cat) }\n         }\n@@ -542,29 +542,29 @@ impl to_str_methods for borrowck_ctxt {\n     fn lp_to_str(lp: @loan_path) -> ~str {\n         alt *lp {\n           lp_local(node_id) {\n-            #fmt[\"local(%d)\", node_id]\n+            fmt!{\"local(%d)\", node_id}\n           }\n           lp_arg(node_id) {\n-            #fmt[\"arg(%d)\", node_id]\n+            fmt!{\"arg(%d)\", node_id}\n           }\n           lp_deref(lp, ptr) {\n-            #fmt[\"%s->(%s)\", self.lp_to_str(lp),\n-                 self.ptr_sigil(ptr)]\n+            fmt!{\"%s->(%s)\", self.lp_to_str(lp),\n+                 self.ptr_sigil(ptr)}\n           }\n           lp_comp(lp, comp) {\n-            #fmt[\"%s.%s\", self.lp_to_str(lp),\n-                 self.comp_to_repr(comp)]\n+            fmt!{\"%s.%s\", self.lp_to_str(lp),\n+                 self.comp_to_repr(comp)}\n           }\n         }\n     }\n \n     fn cmt_to_repr(cmt: cmt) -> ~str {\n-        #fmt[\"{%s id:%d m:%s lp:%s ty:%s}\",\n+        fmt!{\"{%s id:%d m:%s lp:%s ty:%s}\",\n              self.cat_to_repr(cmt.cat),\n              cmt.id,\n              self.mut_to_str(cmt.mutbl),\n              cmt.lp.map_default(~\"none\", |p| self.lp_to_str(p) ),\n-             ty_to_str(self.tcx, cmt.ty)]\n+             ty_to_str(self.tcx, cmt.ty)}\n     }\n \n     fn cmt_to_str(cmt: cmt) -> ~str {\n@@ -580,8 +580,8 @@ impl to_str_methods for borrowck_ctxt {\n           cat_local(_) { mut_str + ~\" local variable\" }\n           cat_binding(_) { ~\"pattern binding\" }\n           cat_arg(_) { ~\"argument\" }\n-          cat_deref(_, _, pk) { #fmt[\"dereference of %s %s pointer\",\n-                                     mut_str, self.ptr_sigil(pk)] }\n+          cat_deref(_, _, pk) { fmt!{\"dereference of %s %s pointer\",\n+                                     mut_str, self.ptr_sigil(pk)} }\n           cat_stack_upvar(_) {\n             ~\"captured outer \" + mut_str + ~\" variable in a stack closure\"\n           }\n@@ -610,8 +610,8 @@ impl to_str_methods for borrowck_ctxt {\n     fn bckerr_code_to_str(code: bckerr_code) -> ~str {\n         alt code {\n           err_mutbl(req, act) {\n-            #fmt[\"creating %s alias to aliasable, %s memory\",\n-                 self.mut_to_str(req), self.mut_to_str(act)]\n+            fmt!{\"creating %s alias to aliasable, %s memory\",\n+                 self.mut_to_str(req), self.mut_to_str(act)}\n           }\n           err_mut_uniq {\n             ~\"unique value in aliasable, mutable location\"\n@@ -626,16 +626,16 @@ impl to_str_methods for borrowck_ctxt {\n             ~\"rooting is not permitted\"\n           }\n           err_out_of_root_scope(super_scope, sub_scope) {\n-            #fmt[\"managed value would have to be rooted for lifetime %s, \\\n+            fmt!{\"managed value would have to be rooted for lifetime %s, \\\n                   but can only be rooted for lifetime %s\",\n                  self.region_to_str(sub_scope),\n-                 self.region_to_str(super_scope)]\n+                 self.region_to_str(super_scope)}\n           }\n           err_out_of_scope(super_scope, sub_scope) {\n-            #fmt[\"borrowed pointer has lifetime %s, \\\n+            fmt!{\"borrowed pointer has lifetime %s, \\\n                   but the borrowed value only has lifetime %s\",\n                  self.region_to_str(sub_scope),\n-                 self.region_to_str(super_scope)]\n+                 self.region_to_str(super_scope)}\n           }\n         }\n     }"}, {"sha": "6f5b5d139d3074999c2d3bf741bd49893aeb6625", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -89,8 +89,8 @@ fn deref_kind(tcx: ty::ctxt, t: ty::t) -> deref_kind {\n       some(k) {k}\n       none {\n         tcx.sess.bug(\n-            #fmt[\"deref_cat() invoked on non-derefable type %s\",\n-                 ty_to_str(tcx, t)]);\n+            fmt!{\"deref_cat() invoked on non-derefable type %s\",\n+                 ty_to_str(tcx, t)});\n       }\n     }\n }\n@@ -118,15 +118,15 @@ impl public_methods for borrowck_ctxt {\n           _ {\n             self.tcx.sess.span_bug(\n                 expr.span,\n-                #fmt[\"Borrowing of non-derefable type `%s`\",\n-                     ty_to_str(self.tcx, expr_ty)]);\n+                fmt!{\"Borrowing of non-derefable type `%s`\",\n+                     ty_to_str(self.tcx, expr_ty)});\n           }\n         }\n     }\n \n     fn cat_expr(expr: @ast::expr) -> cmt {\n-        #debug[\"cat_expr: id=%d expr=%s\",\n-               expr.id, pprust::expr_to_str(expr)];\n+        debug!{\"cat_expr: id=%d expr=%s\",\n+               expr.id, pprust::expr_to_str(expr)};\n \n         let tcx = self.tcx;\n         let expr_ty = tcx.ty(expr);\n@@ -142,8 +142,8 @@ impl public_methods for borrowck_ctxt {\n               none {\n                 tcx.sess.span_bug(\n                     e_base.span,\n-                    #fmt[\"Explicit deref of non-derefable type `%s`\",\n-                         ty_to_str(tcx, tcx.ty(e_base))]);\n+                    fmt!{\"Explicit deref of non-derefable type `%s`\",\n+                         ty_to_str(tcx, tcx.ty(e_base))});\n               }\n             }\n           }\n@@ -318,8 +318,8 @@ impl public_methods for borrowck_ctxt {\n           none {\n             self.tcx.sess.span_bug(\n                 node.span(),\n-                #fmt[\"Cannot find field `%s` in type `%s`\",\n-                     *f_name, ty_to_str(self.tcx, base_cmt.ty)]);\n+                fmt!{\"Cannot find field `%s` in type `%s`\",\n+                     *f_name, ty_to_str(self.tcx, base_cmt.ty)});\n           }\n         };\n         let m = self.inherited_mutability(base_cmt.mutbl, f_mutbl);\n@@ -382,8 +382,8 @@ impl public_methods for borrowck_ctxt {\n           none {\n             self.tcx.sess.span_bug(\n                 expr.span,\n-                #fmt[\"Explicit index of non-index type `%s`\",\n-                     ty_to_str(self.tcx, base_cmt.ty)]);\n+                fmt!{\"Explicit index of non-index type `%s`\",\n+                     ty_to_str(self.tcx, base_cmt.ty)});\n           }\n         };\n "}, {"sha": "4306d457378e6297ed6ce0628b9e463f0fed6fcf", "filename": "src/rustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -157,12 +157,12 @@ impl methods for check_loan_ctxt {\n                                 callee_span: span) {\n         let tcx = self.tcx();\n \n-        #debug[\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n+        debug!{\"check_pure_callee_or_arg(pc=%?, expr=%?, \\\n                 callee_id=%d, ty=%s)\",\n                pc,\n                opt_expr.map(|e| pprust::expr_to_str(e) ),\n                callee_id,\n-               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id))];\n+               ty_to_str(self.tcx(), ty::node_id_to_type(tcx, callee_id))};\n \n         // Purity rules: an expr B is a legal callee or argument to a\n         // call within a pure function A if at least one of the\n@@ -202,8 +202,8 @@ impl methods for check_loan_ctxt {\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn {\n                 self.report_purity_error(\n                     pc, callee_span,\n-                    #fmt[\"access to %s function\",\n-                         pprust::purity_to_str(fn_ty.purity)]);\n+                    fmt!{\"access to %s function\",\n+                         pprust::purity_to_str(fn_ty.purity)});\n               }\n             }\n           }\n@@ -257,14 +257,14 @@ impl methods for check_loan_ctxt {\n                       (m_mutbl, m_imm) | (m_imm, m_mutbl) {\n                         self.bccx.span_err(\n                             new_loan.cmt.span,\n-                            #fmt[\"loan of %s as %s \\\n+                            fmt!{\"loan of %s as %s \\\n                                   conflicts with prior loan\",\n                                  self.bccx.cmt_to_str(new_loan.cmt),\n-                                 self.bccx.mut_to_str(new_loan.mutbl)]);\n+                                 self.bccx.mut_to_str(new_loan.mutbl)});\n                         self.bccx.span_note(\n                             old_loan.cmt.span,\n-                            #fmt[\"prior loan as %s granted here\",\n-                                 self.bccx.mut_to_str(old_loan.mutbl)]);\n+                            fmt!{\"prior loan as %s granted here\",\n+                                 self.bccx.mut_to_str(old_loan.mutbl)});\n                       }\n                     }\n                 }\n@@ -294,8 +294,8 @@ impl methods for check_loan_ctxt {\n     fn check_assignment(at: assignment_type, ex: @ast::expr) {\n         let cmt = self.bccx.cat_expr(ex);\n \n-        #debug[\"check_assignment(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt)];\n+        debug!{\"check_assignment(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt)};\n \n         if self.in_ctor && self.is_self_field(cmt)\n             && at.checked_by_liveness() {\n@@ -354,12 +354,12 @@ impl methods for check_loan_ctxt {\n               m_imm {\n                 self.bccx.span_err(\n                     ex.span,\n-                    #fmt[\"%s prohibited due to outstanding loan\",\n-                         at.ing_form(self.bccx.cmt_to_str(cmt))]);\n+                    fmt!{\"%s prohibited due to outstanding loan\",\n+                         at.ing_form(self.bccx.cmt_to_str(cmt))});\n                 self.bccx.span_note(\n                     loan.cmt.span,\n-                    #fmt[\"loan of %s granted here\",\n-                         self.bccx.cmt_to_str(loan.cmt)]);\n+                    fmt!{\"loan of %s granted here\",\n+                         self.bccx.cmt_to_str(loan.cmt)});\n                 ret;\n               }\n             }\n@@ -386,17 +386,17 @@ impl methods for check_loan_ctxt {\n           pc_pure_fn {\n             self.tcx().sess.span_err(\n                 sp,\n-                #fmt[\"%s prohibited in pure context\", msg]);\n+                fmt!{\"%s prohibited in pure context\", msg});\n           }\n           pc_cmt(e) {\n             if self.reported.insert(e.cmt.id, ()) {\n                 self.tcx().sess.span_err(\n                     e.cmt.span,\n-                    #fmt[\"illegal borrow unless pure: %s\",\n-                         self.bccx.bckerr_code_to_str(e.code)]);\n+                    fmt!{\"illegal borrow unless pure: %s\",\n+                         self.bccx.bckerr_code_to_str(e.code)});\n                 self.tcx().sess.span_note(\n                     sp,\n-                    #fmt[\"impure due to %s\", msg]);\n+                    fmt!{\"impure due to %s\", msg});\n             }\n           }\n         }\n@@ -408,8 +408,8 @@ impl methods for check_loan_ctxt {\n     }\n \n     fn check_move_out_from_cmt(cmt: cmt) {\n-        #debug[\"check_move_out_from_cmt(cmt=%s)\",\n-               self.bccx.cmt_to_repr(cmt)];\n+        debug!{\"check_move_out_from_cmt(cmt=%s)\",\n+               self.bccx.cmt_to_repr(cmt)};\n \n         alt cmt.cat {\n           // Rvalues, locals, and arguments can be moved:\n@@ -427,7 +427,7 @@ impl methods for check_loan_ctxt {\n           _ {\n             self.bccx.span_err(\n                 cmt.span,\n-                #fmt[\"moving out of %s\", self.bccx.cmt_to_str(cmt)]);\n+                fmt!{\"moving out of %s\", self.bccx.cmt_to_str(cmt)});\n             ret;\n           }\n         }\n@@ -442,12 +442,12 @@ impl methods for check_loan_ctxt {\n         for self.walk_loans_of(cmt.id, lp) |loan| {\n             self.bccx.span_err(\n                 cmt.span,\n-                #fmt[\"moving out of %s prohibited due to outstanding loan\",\n-                     self.bccx.cmt_to_str(cmt)]);\n+                fmt!{\"moving out of %s prohibited due to outstanding loan\",\n+                     self.bccx.cmt_to_str(cmt)});\n             self.bccx.span_note(\n                 loan.cmt.span,\n-                #fmt[\"loan of %s granted here\",\n-                     self.bccx.cmt_to_str(loan.cmt)]);\n+                fmt!{\"loan of %s granted here\",\n+                     self.bccx.cmt_to_str(loan.cmt)});\n             ret;\n         }\n     }\n@@ -462,8 +462,8 @@ impl methods for check_loan_ctxt {\n           some(lp) { lp }\n         };\n         for self.walk_loans_of(cmt.id, lp) |_loan| {\n-            #debug[\"Removing last use entry %? due to outstanding loan\",\n-                   expr.id];\n+            debug!{\"Removing last use entry %? due to outstanding loan\",\n+                   expr.id};\n             self.bccx.last_use_map.remove(expr.id);\n             ret;\n         }\n@@ -507,7 +507,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                      sp: span, id: ast::node_id, &&self: check_loan_ctxt,\n                      visitor: visit::vt<check_loan_ctxt>) {\n \n-    #debug[\"purity on entry=%?\", copy self.declared_purity];\n+    debug!{\"purity on entry=%?\", copy self.declared_purity};\n     do save_and_restore(self.in_ctor) {\n         do save_and_restore(self.declared_purity) {\n             do save_and_restore(self.fn_args) {\n@@ -543,7 +543,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n             }\n         }\n     }\n-    #debug[\"purity on exit=%?\", copy self.declared_purity];\n+    debug!{\"purity on exit=%?\", copy self.declared_purity};\n }\n \n fn check_loans_in_local(local: @ast::local,"}, {"sha": "4b9015eec67e71bb229249a04d560cd934f88b62", "filename": "src/rustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -90,7 +90,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n     let tcx = bccx.tcx;\n     let old_root_ub = self.root_ub;\n \n-    #debug[\"req_loans_in_expr(ex=%s)\", pprust::expr_to_str(ex)];\n+    debug!{\"req_loans_in_expr(ex=%s)\", pprust::expr_to_str(ex)};\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.borrowings.find(ex.id).each |borrow| {\n@@ -258,10 +258,10 @@ impl methods for gather_loan_ctxt {\n \n         self.bccx.guaranteed_paths += 1;\n \n-        #debug[\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n+        debug!{\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n                self.bccx.cmt_to_repr(cmt),\n                self.bccx.mut_to_str(req_mutbl),\n-               region_to_str(self.tcx(), scope_r)];\n+               region_to_str(self.tcx(), scope_r)};\n         let _i = indenter();\n \n         alt cmt.lp {\n@@ -290,7 +290,7 @@ impl methods for gather_loan_ctxt {\n                         if self.tcx().sess.borrowck_note_loan() {\n                             self.bccx.span_note(\n                                 cmt.span,\n-                                #fmt[\"immutable loan required\"]);\n+                                fmt!{\"immutable loan required\"});\n                         }\n                     } else {\n                         self.bccx.loaned_paths_same += 1;\n@@ -344,7 +344,7 @@ impl methods for gather_loan_ctxt {\n                     if self.tcx().sess.borrowck_note_pure() {\n                         self.bccx.span_note(\n                             cmt.span,\n-                            #fmt[\"purity required\"]);\n+                            fmt!{\"purity required\"});\n                     }\n                   }\n                   _ => {\n@@ -443,9 +443,9 @@ impl methods for gather_loan_ctxt {\n         // in the alt, the id of `local(x)->@` is the `@y` pattern,\n         // and the id of `local(x)->@->@` is the id of the `y` pattern.\n \n-        #debug[\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n+        debug!{\"gather_pat: id=%d pat=%s cmt=%s arm_id=%d alt_id=%d\",\n                pat.id, pprust::pat_to_str(pat),\n-               self.bccx.cmt_to_repr(cmt), arm_id, alt_id];\n+               self.bccx.cmt_to_repr(cmt), arm_id, alt_id};\n         let _i = indenter();\n \n         let tcx = self.tcx();\n@@ -463,8 +463,8 @@ impl methods for gather_loan_ctxt {\n .find(pat.id) {\n               some(ast::def_variant(enum_did, _)) {enum_did}\n               e {tcx.sess.span_bug(pat.span,\n-                                   #fmt[\"resolved to %?, \\\n-                                         not variant\", e])}\n+                                   fmt!{\"resolved to %?, \\\n+                                         not variant\", e})}\n             };\n \n             for subpats.each |subpat| {\n@@ -475,11 +475,11 @@ impl methods for gather_loan_ctxt {\n \n           ast::pat_ident(_, none) if self.pat_is_variant(pat) {\n             // nullary variant\n-            #debug[\"nullary variant\"];\n+            debug!{\"nullary variant\"};\n           }\n           ast::pat_ident(id, o_pat) {\n             // x or x @ p --- `x` must remain valid for the scope of the alt\n-            #debug[\"defines identifier %s\", pprust::path_to_str(id)];\n+            debug!{\"defines identifier %s\", pprust::path_to_str(id)};\n \n             // Note: there is a discussion of the function of\n             // cat_discr in the method preserve():"}, {"sha": "b466cfd3a43e1ab5065a14700451c5d87ac2aebe", "filename": "src/rustc/middle/borrowck/loan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -58,9 +58,9 @@ impl loan_methods for loan_ctxt {\n     }\n \n     fn loan(cmt: cmt, req_mutbl: ast::mutability) -> bckres<()> {\n-        #debug[\"loan(%s, %s)\",\n+        debug!{\"loan(%s, %s)\",\n                self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(req_mutbl)];\n+               self.bccx.mut_to_str(req_mutbl)};\n         let _i = indenter();\n \n         // see stable() above; should only be called when `cmt` is lendable"}, {"sha": "e1e97c0dc6f794d5b3cfca28d1d3cd1b420642e0", "filename": "src/rustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -58,9 +58,9 @@ impl private_methods for &preserve_ctxt {\n     fn tcx() -> ty::ctxt { self.bccx.tcx }\n \n     fn preserve(cmt: cmt) -> bckres<preserve_condition> {\n-        #debug[\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n+        debug!{\"preserve(cmt=%s, root_ub=%?, root_managed_data=%b)\",\n                self.bccx.cmt_to_repr(cmt), self.root_ub,\n-               self.root_managed_data];\n+               self.root_managed_data};\n         let _i = indenter();\n \n         alt cmt.cat {\n@@ -148,7 +148,7 @@ impl private_methods for &preserve_ctxt {\n             // otherwise we have no guarantee the pointer will stay\n             // live, so we must root the pointer (i.e., inc the ref\n             // count) for the duration of the loan.\n-            #debug[\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl)];\n+            debug!{\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl)};\n             if base.mutbl == m_imm {\n                 let non_rooting_ctxt =\n                     preserve_ctxt({root_managed_data: false with **self});\n@@ -157,12 +157,12 @@ impl private_methods for &preserve_ctxt {\n                     ok(pc_ok)\n                   }\n                   ok(pc_if_pure(_)) {\n-                    #debug[\"must root @T, otherwise purity req'd\"];\n+                    debug!{\"must root @T, otherwise purity req'd\"};\n                     self.attempt_root(cmt, base, derefs)\n                   }\n                   err(e) => {\n-                    #debug[\"must root @T, err: %s\",\n-                           self.bccx.bckerr_code_to_str(e.code)];\n+                    debug!{\"must root @T, err: %s\",\n+                           self.bccx.bckerr_code_to_str(e.code)};\n                     self.attempt_root(cmt, base, derefs)\n                   }\n                 }"}, {"sha": "b45d7d66e9e878c7e1d88dd77a08c8b17ee59e72", "filename": "src/rustc/middle/capture.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcapture.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -43,16 +43,16 @@ fn check_capture_clause(tcx: ty::ctxt,\n         if !vec::any(*freevars, |fv| fv.def == cap_def ) {\n             tcx.sess.span_warn(\n                 cap_item.span,\n-                #fmt(\"captured variable `%s` not used in closure\",\n-                     *cap_item.name));\n+                fmt!{\"captured variable `%s` not used in closure\",\n+                     *cap_item.name});\n         }\n \n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;\n         if !seen_defs.insert(cap_def_id, ()) {\n             tcx.sess.span_err(\n                 cap_item.span,\n-                #fmt(\"variable `%s` captured more than once\",\n-                     *cap_item.name));\n+                fmt!{\"variable `%s` captured more than once\",\n+                     *cap_item.name});\n         }\n     }\n }\n@@ -67,8 +67,8 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     // first add entries for anything explicitly named in the cap clause\n \n     for (*cap_clause).each |cap_item| {\n-        #debug(\"Doing capture var: %s (%?)\",\n-               *cap_item.name, cap_item.id);\n+        debug!{\"Doing capture var: %s (%?)\",\n+               *cap_item.name, cap_item.id};\n \n         let cap_def = tcx.def_map.get(cap_item.id);\n         let cap_def_id = ast_util::def_id_of_def(cap_def).node;"}, {"sha": "8707cabfdf7d55439b97b2a4f12290904f15f06e", "filename": "src/rustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fkind.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -213,7 +213,7 @@ fn check_block(b: blk, cx: ctx, v: visit::vt<ctx>) {\n }\n \n fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n-    #debug[\"kind::check_expr(%s)\", expr_to_str(e)];\n+    debug!{\"kind::check_expr(%s)\", expr_to_str(e)};\n     alt e.node {\n       expr_assign(_, ex) |\n       expr_unary(box(_), ex) | expr_unary(uniq(_), ex) |\n@@ -296,10 +296,10 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             };\n             if vec::len(ts) != vec::len(*bounds) {\n               // Fail earlier to make debugging easier\n-              fail #fmt(\"Internal error: in kind::check_expr, length \\\n+              fail fmt!{\"Internal error: in kind::check_expr, length \\\n                   mismatch between actual and declared bounds: actual = \\\n                   %s (%u tys), declared = %? (%u tys)\",\n-                  tys_to_str(cx.tcx, ts), ts.len(), *bounds, (*bounds).len());\n+                  tys_to_str(cx.tcx, ts), ts.len(), *bounds, (*bounds).len()};\n             }\n             do vec::iter2(ts, *bounds) |ty, bound| {\n                 check_bounds(cx, e.id, e.span, ty, bound)\n@@ -419,7 +419,7 @@ fn check_imm_free_var(cx: ctx, def: def, sp: span) {\n       _ {\n         cx.tcx.sess.span_bug(\n             sp,\n-            #fmt[\"unknown def for free variable: %?\", def]);\n+            fmt!{\"unknown def for free variable: %?\", def});\n       }\n     }\n }\n@@ -510,7 +510,7 @@ fn check_cast_for_escaping_regions(\n       some(ty::re_bound(*)) | some(ty::re_var(*)) => {\n         cx.tcx.sess.span_bug(\n             source.span,\n-            #fmt[\"bad region found in kind: %?\", target_substs.self_r]);\n+            fmt!{\"bad region found in kind: %?\", target_substs.self_r});\n       }\n     }\n "}, {"sha": "d14d2d5a0c62f2b1d59166c98e680ed3387eae9c", "filename": "src/rustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flang_items.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -132,8 +132,8 @@ class LanguageItemCollector {\n                     some(original_def_id)\n                             if original_def_id != item_def_id => {\n \n-                        self.session.err(#fmt(\"duplicate entry for `%s`\",\n-                                              value));\n+                        self.session.err(fmt!{\"duplicate entry for `%s`\",\n+                                              value});\n                     }\n                     some(_) | none => {\n                         // OK.\n@@ -191,7 +191,7 @@ class LanguageItemCollector {\n         for self.item_refs.each |key, item_ref| {\n             alt copy *item_ref {\n                 none => {\n-                    self.session.err(#fmt(\"no item found for `%s`\", key));\n+                    self.session.err(fmt!{\"no item found for `%s`\", key});\n                 }\n                 some(did) => {\n                     // OK."}, {"sha": "94be6865094ab3d35b46317f91d15c23e89d046c", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -253,8 +253,8 @@ impl methods for ctxt {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n                     meta.span,\n-                    #fmt(\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), *lintname));\n+                    fmt!{\"unknown `%s` attribute: `%s`\",\n+                         level_to_str(level), *lintname});\n               }\n               some(lint) {\n \n@@ -263,9 +263,9 @@ impl methods for ctxt {\n                     self.span_lint(\n                         forbid,\n                         meta.span,\n-                        #fmt(\"%s(%s) overruled by outer forbid(%s)\",\n+                        fmt!{\"%s(%s) overruled by outer forbid(%s)\",\n                              level_to_str(level),\n-                             *lintname, *lintname));\n+                             *lintname, *lintname});\n                 }\n \n                 // we do multiple unneeded copies of the\n@@ -435,7 +435,7 @@ fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n \n fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n             _body: ast::blk, span: span, id: ast::node_id) {\n-    #debug[\"lint check_fn fk=%? id=%?\", fk, id];\n+    debug!{\"lint check_fn fk=%? id=%?\", fk, id};\n \n     // don't complain about blocks, since they tend to get their modes\n     // specified from the outside\n@@ -450,10 +450,10 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n         let mut counter = 0;\n         do vec::iter2(fn_ty.inputs, decl.inputs) |arg_ty, arg_ast| {\n             counter += 1;\n-            #debug[\"arg %d, ty=%s, mode=%s\",\n+            debug!{\"arg %d, ty=%s, mode=%s\",\n                    counter,\n                    ty_to_str(tcx, arg_ty.ty),\n-                   mode_to_str(arg_ast.mode)];\n+                   mode_to_str(arg_ast.mode)};\n             alt arg_ast.mode {\n               ast::expl(ast::by_copy) => {\n                 /* always allow by-copy */\n@@ -463,7 +463,7 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n                 tcx.sess.span_lint(\n                     deprecated_mode, id, id,\n                     span,\n-                    #fmt[\"argument %d uses an explicit mode\", counter]);\n+                    fmt!{\"argument %d uses an explicit mode\", counter});\n               }\n \n               ast::infer(_) {\n@@ -472,9 +472,9 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n                     tcx.sess.span_lint(\n                         deprecated_mode, id, id,\n                         span,\n-                        #fmt[\"argument %d uses the default mode \\\n+                        fmt!{\"argument %d uses the default mode \\\n                               but shouldn't\",\n-                             counter]);\n+                             counter});\n                 }\n               }\n             }"}, {"sha": "e7d88b9b2b8511457cc66e291d8843ffa4b061f8", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -153,11 +153,11 @@ fn check_crate(tcx: ty::ctxt,\n }\n \n impl of to_str::to_str for live_node {\n-    fn to_str() -> ~str { #fmt[\"ln(%u)\", *self] }\n+    fn to_str() -> ~str { fmt!{\"ln(%u)\", *self} }\n }\n \n impl of to_str::to_str for variable {\n-    fn to_str() -> ~str { #fmt[\"v(%u)\", *self] }\n+    fn to_str() -> ~str { fmt!{\"v(%u)\", *self} }\n }\n \n // ______________________________________________________________________\n@@ -243,7 +243,7 @@ class ir_maps {\n         vec::push(self.lnks, lnk);\n         self.num_live_nodes += 1u;\n \n-        #debug[\"%s is of kind %?\", ln.to_str(), lnk];\n+        debug!{\"%s is of kind %?\", ln.to_str(), lnk};\n \n         ln\n     }\n@@ -252,7 +252,7 @@ class ir_maps {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n-        #debug[\"%s is node %d\", ln.to_str(), node_id];\n+        debug!{\"%s is node %d\", ln.to_str(), node_id};\n     }\n \n     fn add_variable(vk: var_kind) -> variable {\n@@ -271,7 +271,7 @@ class ir_maps {\n           }\n         }\n \n-        #debug[\"%s is %?\", v.to_str(), vk];\n+        debug!{\"%s is %?\", v.to_str(), vk};\n \n         v\n     }\n@@ -281,7 +281,7 @@ class ir_maps {\n           some(var) {var}\n           none {\n             self.tcx.sess.span_bug(\n-                span, #fmt(\"No variable registered for id %d\", node_id));\n+                span, fmt!{\"No variable registered for id %d\", node_id});\n           }\n         }\n     }\n@@ -314,7 +314,7 @@ class ir_maps {\n \n     fn add_last_use(expr_id: node_id, var: variable) {\n         let vk = self.var_kinds[*var];\n-        #debug[\"Node %d is a last use of variable %?\", expr_id, vk];\n+        debug!{\"Node %d is a last use of variable %?\", expr_id, vk};\n         alt vk {\n           vk_arg(id, name, by_move) |\n           vk_arg(id, name, by_copy) |\n@@ -332,25 +332,25 @@ class ir_maps {\n           }\n           vk_arg(_, _, by_ref) | vk_arg(_, _, by_mutbl_ref) |\n           vk_arg(_, _, by_val) | vk_self | vk_field(_) | vk_implicit_ret {\n-            #debug[\"--but it is not owned\"];\n+            debug!{\"--but it is not owned\"};\n           }\n         }\n     }\n }\n \n fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n             sp: span, id: node_id, &&self: @ir_maps, v: vt<@ir_maps>) {\n-    #debug[\"visit_fn: id=%d\", id];\n+    debug!{\"visit_fn: id=%d\", id};\n     let _i = util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n     let fn_maps = @ir_maps(self.tcx, self.method_map,\n                            self.last_use_map);\n \n-    #debug[\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint];\n+    debug!{\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint};\n \n     for decl.inputs.each |arg| {\n-        #debug[\"adding argument %d\", arg.id];\n+        debug!{\"adding argument %d\", arg.id};\n         let mode = ty::resolved_mode(self.tcx, arg.mode);\n         (*fn_maps).add_variable(vk_arg(arg.id, arg.ident, mode));\n     };\n@@ -405,7 +405,7 @@ fn add_class_fields(self: @ir_maps, did: def_id) {\n fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |p_id, sp, path| {\n-        #debug[\"adding local variable %d\", p_id];\n+        debug!{\"adding local variable %d\", p_id};\n         let name = ast_util::path_to_ident(path);\n         (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n         (*self).add_variable(vk_local(p_id, name));\n@@ -418,7 +418,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) {\n         let def = self.tcx.def_map.get(expr.id);\n-        #debug[\"expr %d: path that leads to %?\", expr.id, def];\n+        debug!{\"expr %d: path that leads to %?\", expr.id, def};\n         if relevant_def(def).is_some() {\n             (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n         }\n@@ -540,8 +540,8 @@ class liveness {\n             // code have to agree about which AST nodes are worth\n             // creating liveness nodes for.\n             self.tcx.sess.span_bug(\n-                span, #fmt[\"No live node registered for node %d\",\n-                           node_id]);\n+                span, fmt!{\"No live node registered for node %d\",\n+                           node_id});\n           }\n         }\n     }\n@@ -664,7 +664,7 @@ class liveness {\n             wr.write_str(~\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(~\") of kind \");\n-            wr.write_str(#fmt[\"%?\", copy self.ir.lnks[*ln]]);\n+            wr.write_str(fmt!{\"%?\", copy self.ir.lnks[*ln]});\n             wr.write_str(~\" reads\");\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             wr.write_str(~\"  writes\");\n@@ -695,8 +695,8 @@ class liveness {\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             self.users[idx] = self.users[succ_idx]\n         });\n-        #debug[\"init_from_succ(ln=%s, succ=%s)\",\n-               self.ln_str(ln), self.ln_str(succ_ln)];\n+        debug!{\"init_from_succ(ln=%s, succ=%s)\",\n+               self.ln_str(ln), self.ln_str(succ_ln)};\n     }\n \n     fn merge_from_succ(ln: live_node, succ_ln: live_node,\n@@ -715,8 +715,8 @@ class liveness {\n             }\n         }\n \n-        #debug[\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n-               ln.to_str(), self.ln_str(succ_ln), first_merge, changed];\n+        debug!{\"merge_from_succ(ln=%s, succ=%s, first_merge=%b, changed=%b)\",\n+               ln.to_str(), self.ln_str(succ_ln), first_merge, changed};\n         ret changed;\n \n         fn copy_if_invalid(src: live_node, &dst: live_node) -> bool {\n@@ -738,8 +738,8 @@ class liveness {\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n \n-        #debug[\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n-               idx, self.ln_str(writer)];\n+        debug!{\"%s defines %s (idx=%u): %s\", writer.to_str(), var.to_str(),\n+               idx, self.ln_str(writer)};\n     }\n \n     // Either read, write, or both depending on the acc bitset\n@@ -762,8 +762,8 @@ class liveness {\n             self.users[idx].used = true;\n         }\n \n-        #debug[\"%s accesses[%x] %s: %s\",\n-               ln.to_str(), acc, var.to_str(), self.ln_str(ln)];\n+        debug!{\"%s accesses[%x] %s: %s\",\n+               ln.to_str(), acc, var.to_str(), self.ln_str(ln)};\n     }\n \n     // _______________________________________________________________________\n@@ -778,14 +778,14 @@ class liveness {\n             });\n \n         // hack to skip the loop unless #debug is enabled:\n-        #debug[\"^^ liveness computation results for body %d (entry=%s)\",\n+        debug!{\"^^ liveness computation results for body %d (entry=%s)\",\n                {\n                    for uint::range(0u, self.ir.num_live_nodes) |ln_idx| {\n                        #debug[\"%s\", self.ln_str(live_node(ln_idx))];\n                    }\n                    body.node.id\n                },\n-               entry_ln.to_str()];\n+               entry_ln.to_str()};\n \n         entry_ln\n     }\n@@ -1373,7 +1373,7 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n         // No initializer: the variable might be unused; if not, it\n         // should not be live at this point.\n \n-        #debug[\"check_local() with no initializer\"];\n+        debug!{\"check_local() with no initializer\"};\n         do (*self).pat_bindings(local.node.pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 alt (*self).live_on_exit(ln, var) {\n@@ -1487,7 +1487,7 @@ impl check_methods for @liveness {\n               none { /* ok */ }\n               some(lnk_exit) {\n                 self.tcx.sess.span_err(\n-                    sp, #fmt[\"field `self.%s` is never initialized\", *nm]);\n+                    sp, fmt!{\"field `self.%s` is never initialized\", *nm});\n               }\n               some(lnk) {\n                 self.report_illegal_read(\n@@ -1525,8 +1525,8 @@ impl check_methods for @liveness {\n     }\n \n     fn check_move_from_var(span: span, ln: live_node, var: variable) {\n-        #debug[\"check_move_from_var(%s, %s)\",\n-               ln.to_str(), var.to_str()];\n+        debug!{\"check_move_from_var(%s, %s)\",\n+               ln.to_str(), var.to_str()};\n \n         alt (*self).live_on_exit(ln, var) {\n           none { }\n@@ -1546,8 +1546,8 @@ impl check_methods for @liveness {\n     }\n \n     fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n-        #debug[\"check_move_from_expr(node %d: %s)\",\n-               expr.id, expr_to_str(expr)];\n+        debug!{\"check_move_from_expr(node %d: %s)\",\n+               expr.id, expr_to_str(expr)};\n \n         if self.ir.method_map.contains_key(expr.id) {\n             // actually an rvalue, since this calls a method\n@@ -1643,7 +1643,7 @@ impl check_methods for @liveness {\n           some(lnk) {\n             self.tcx.sess.span_bug(\n                 orig_span,\n-                #fmt[\"illegal writer: %?\", lnk]);\n+                fmt!{\"illegal writer: %?\", lnk});\n           }\n           none {}\n         }\n@@ -1662,14 +1662,14 @@ impl check_methods for @liveness {\n               vk_arg(_, name, _) {\n                 self.tcx.sess.span_err(\n                     move_span,\n-                    #fmt[\"illegal move from argument `%s`, which is not \\\n-                          copy or move mode\", *name]);\n+                    fmt!{\"illegal move from argument `%s`, which is not \\\n+                          copy or move mode\", *name});\n                 ret;\n               }\n               vk_field(name) {\n                 self.tcx.sess.span_err(\n                     move_span,\n-                    #fmt[\"illegal move from field `%s`\", *name]);\n+                    fmt!{\"illegal move from field `%s`\", *name});\n                 ret;\n               }\n               vk_self {\n@@ -1682,8 +1682,8 @@ impl check_methods for @liveness {\n               vk_local(*) | vk_implicit_ret {\n                 self.tcx.sess.span_bug(\n                     move_span,\n-                    #fmt[\"illegal reader (%?) for `%?`\",\n-                         lnk, vk]);\n+                    fmt!{\"illegal reader (%?) for `%?`\",\n+                         lnk, vk});\n               }\n             }\n         }\n@@ -1708,18 +1708,18 @@ impl check_methods for @liveness {\n           lnk_freevar(span) {\n             self.tcx.sess.span_err(\n                 span,\n-                #fmt[\"capture of %s: `%s`\", msg, *name]);\n+                fmt!{\"capture of %s: `%s`\", msg, *name});\n           }\n           lnk_expr(span) {\n             self.tcx.sess.span_err(\n                 span,\n-                #fmt[\"use of %s: `%s`\", msg, *name]);\n+                fmt!{\"use of %s: `%s`\", msg, *name});\n           }\n           lnk_exit |\n           lnk_vdef(_) {\n             self.tcx.sess.span_bug(\n                 chk_span,\n-                #fmt[\"illegal reader: %?\", lnk]);\n+                fmt!{\"illegal reader: %?\", lnk});\n           }\n         }\n     }\n@@ -1776,11 +1776,11 @@ impl check_methods for @liveness {\n \n                 if is_assigned {\n                     self.tcx.sess.span_warn(\n-                        sp, #fmt[\"variable `%s` is assigned to, \\\n-                                  but never used\", *name]);\n+                        sp, fmt!{\"variable `%s` is assigned to, \\\n+                                  but never used\", *name});\n                 } else {\n                     self.tcx.sess.span_warn(\n-                        sp, #fmt[\"unused variable: `%s`\", *name]);\n+                        sp, fmt!{\"unused variable: `%s`\", *name});\n                 }\n             }\n             ret true;\n@@ -1793,7 +1793,7 @@ impl check_methods for @liveness {\n             for self.should_warn(var).each |name| {\n                 self.tcx.sess.span_warn(\n                     sp,\n-                    #fmt[\"value assigned to `%s` is never read\", *name]);\n+                    fmt!{\"value assigned to `%s` is never read\", *name});\n             }\n         }\n     }"}, {"sha": "e6b2209b44a4505e4212bafbe877ffcc252b7c9c", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -187,7 +187,7 @@ fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     alt cx.parent {\n       none { /* no-op */ }\n       some(parent_id) {\n-        #debug[\"parent of node %d is node %d\", child_id, parent_id];\n+        debug!{\"parent of node %d is node %d\", child_id, parent_id};\n         cx.region_map.insert(child_id, parent_id);\n       }\n     }\n@@ -232,11 +232,11 @@ fn resolve_expr(expr: @ast::expr, cx: ctxt, visitor: visit::vt<ctxt>) {\n     let mut new_cx = cx;\n     alt expr.node {\n       ast::expr_call(*) => {\n-        #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n+        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr)};\n         new_cx.parent = some(expr.id);\n       }\n       ast::expr_alt(subexpr, _, _) => {\n-        #debug[\"node %d: %s\", expr.id, pprust::expr_to_str(expr)];\n+        debug!{\"node %d: %s\", expr.id, pprust::expr_to_str(expr)};\n         new_cx.parent = some(expr.id);\n       }\n       ast::expr_fn(_, _, _, cap_clause) |\n@@ -289,9 +289,9 @@ fn resolve_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n       }\n     };\n \n-    #debug[\"visiting fn with body %d. cx.parent: %? \\\n+    debug!{\"visiting fn with body %d. cx.parent: %? \\\n             fn_cx.parent: %?\",\n-           body.node.id, cx.parent, fn_cx.parent];\n+           body.node.id, cx.parent, fn_cx.parent};\n \n     for decl.inputs.each |input| {\n         cx.region_map.insert(input.id, body.node.id);\n@@ -367,19 +367,19 @@ impl methods for determine_rp_ctxt {\n     fn add_rp(id: ast::node_id) {\n         assert id != 0;\n         if self.region_paramd_items.insert(id, ()) {\n-            #debug[\"add region-parameterized item: %d (%s)\",\n-                   id, ast_map::node_id_to_str(self.ast_map, id)];\n+            debug!{\"add region-parameterized item: %d (%s)\",\n+                   id, ast_map::node_id_to_str(self.ast_map, id)};\n             self.worklist.push(id);\n         } else {\n-            #debug[\"item %d already region-parameterized\", id];\n+            debug!{\"item %d already region-parameterized\", id};\n         }\n     }\n \n     fn add_dep(from: ast::node_id, to: ast::node_id) {\n-        #debug[\"add dependency from %d -> %d (%s -> %s)\",\n+        debug!{\"add dependency from %d -> %d (%s -> %s)\",\n                from, to,\n                ast_map::node_id_to_str(self.ast_map, from),\n-               ast_map::node_id_to_str(self.ast_map, to)];\n+               ast_map::node_id_to_str(self.ast_map, to)};\n         let vec = alt self.dep_map.find(from) {\n             some(vec) => {vec}\n             none => {\n@@ -436,7 +436,7 @@ impl methods for determine_rp_ctxt {\n         let old_anon_implies_rp = self.anon_implies_rp;\n         self.item_id = item_id;\n         self.anon_implies_rp = anon_implies_rp;\n-        #debug[\"with_item_id(%d, %b)\", item_id, anon_implies_rp];\n+        debug!{\"with_item_id(%d, %b)\", item_id, anon_implies_rp};\n         let _i = util::common::indenter();\n         f();\n         self.item_id = old_item_id;\n@@ -488,7 +488,7 @@ fn determine_rp_in_ty(ty: @ast::ty,\n     alt ty.node {\n       ast::ty_rptr(r, _) |\n       ast::ty_path(@{rp: some(r), _}, _) => {\n-        #debug[\"referenced type with regions %s\", pprust::ty_to_str(ty)];\n+        debug!{\"referenced type with regions %s\", pprust::ty_to_str(ty)};\n         if cx.region_is_relevant(r) {\n             cx.add_rp(cx.item_id);\n         }\n@@ -510,8 +510,8 @@ fn determine_rp_in_ty(ty: @ast::ty,\n             } else {\n                 let cstore = cx.sess.cstore;\n                 if csearch::get_region_param(cstore, did) {\n-                    #debug[\"reference to external, rp'd type %s\",\n-                           pprust::ty_to_str(ty)];\n+                    debug!{\"reference to external, rp'd type %s\",\n+                           pprust::ty_to_str(ty)};\n                     cx.add_rp(cx.item_id);\n                 }\n             }\n@@ -560,7 +560,7 @@ fn determine_rp_in_crate(sess: session,\n     // propagate indirect dependencies\n     while cx.worklist.len() != 0 {\n         let id = cx.worklist.pop();\n-        #debug[\"popped %d from worklist\", id];\n+        debug!{\"popped %d from worklist\", id};\n         alt cx.dep_map.find(id) {\n           none {}\n           some(vec) {"}, {"sha": "1965d5289beea5730dce0ae510f55b1b218d9409", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 216, "deletions": 216, "changes": 432, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1218,9 +1218,9 @@ class Resolver {\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.node.id;\n \n-            #debug(\"(building reduced graph for block) creating a new \\\n+            debug!{\"(building reduced graph for block) creating a new \\\n                     anonymous module for block %d\",\n-                   block_id);\n+                   block_id};\n \n             let parent_module = self.get_module_from_parent(parent);\n             let new_module = @Module(BlockParentLink(parent_module, block_id),\n@@ -1245,10 +1245,10 @@ class Resolver {\n         for each_path(self.session.cstore, get(root.def_id).crate)\n                 |path_entry| {\n \n-            #debug(\"(building reduced graph for external crate) found path \\\n+            debug!{\"(building reduced graph for external crate) found path \\\n                     entry: %s (%?)\",\n                    path_entry.path_string,\n-                   path_entry.def_like);\n+                   path_entry.def_like};\n \n             let mut pieces = split_str(path_entry.path_string, ~\"::\");\n             let final_ident = pop(pieces);\n@@ -1267,8 +1267,8 @@ class Resolver {\n                 // Define or reuse the module node.\n                 alt child_name_bindings.module_def {\n                     NoModuleDef {\n-                        #debug(\"(building reduced graph for external crate) \\\n-                                autovivifying %s\", ident);\n+                        debug!{\"(building reduced graph for external crate) \\\n+                                autovivifying %s\", ident};\n                         let parent_link = self.get_parent_link(new_parent,\n                                                                atom);\n                         (*child_name_bindings).define_module(parent_link,\n@@ -1292,9 +1292,9 @@ class Resolver {\n                         def_mod(def_id) | def_foreign_mod(def_id) {\n                             alt copy child_name_bindings.module_def {\n                                 NoModuleDef {\n-                                    #debug(\"(building reduced graph for \\\n+                                    debug!{\"(building reduced graph for \\\n                                             external crate) building module \\\n-                                            %s\", final_ident);\n+                                            %s\", final_ident};\n                                     let parent_link =\n                                         self.get_parent_link(new_parent,\n                                                              atom);\n@@ -1339,34 +1339,34 @@ class Resolver {\n                                                 }\n                                             }\n \n-                                            #debug(\"(building reduced graph \\\n+                                            debug!{\"(building reduced graph \\\n                                                      for external crate) \\\n                                                      ... creating import \\\n-                                                     resolution\");\n+                                                     resolution\"};\n \n                                             new_parent.import_resolutions.\n                                                 insert(atom, resolution);\n                                         }\n                                     }\n                                 }\n                                 ModuleDef(module) {\n-                                    #debug(\"(building reduced graph for \\\n+                                    debug!{\"(building reduced graph for \\\n                                             external crate) already created \\\n-                                            module\");\n+                                            module\"};\n                                     module.def_id = some(def_id);\n                                     modules.insert(def_id, module);\n                                 }\n                             }\n                         }\n                         def_fn(def_id, _) | def_const(def_id) |\n                         def_variant(_, def_id) {\n-                            #debug(\"(building reduced graph for external \\\n-                                    crate) building value %s\", final_ident);\n+                            debug!{\"(building reduced graph for external \\\n+                                    crate) building value %s\", final_ident};\n                             (*child_name_bindings).define_value(def);\n                         }\n                         def_ty(def_id) {\n-                            #debug(\"(building reduced graph for external \\\n-                                    crate) building type %s\", final_ident);\n+                            debug!{\"(building reduced graph for external \\\n+                                    crate) building type %s\", final_ident};\n \n                             // If this is a trait, add all the method names\n                             // to the trait info.\n@@ -1380,10 +1380,10 @@ class Resolver {\n                                     let interned_method_names =\n                                         @atom_hashmap();\n                                     for method_names.each |method_name| {\n-                                        #debug(\"(building reduced graph for \\\n+                                        debug!{\"(building reduced graph for \\\n                                                  external crate) ... adding \\\n                                                  trait method '%?'\",\n-                                               method_name);\n+                                               method_name};\n                                         let atom =\n                                             (*self.atom_table).intern\n                                                 (method_name);\n@@ -1398,10 +1398,10 @@ class Resolver {\n                             (*child_name_bindings).define_type(def);\n                         }\n                         def_class(def_id, has_constructor) {\n-                            #debug(\"(building reduced graph for external \\\n+                            debug!{\"(building reduced graph for external \\\n                                     crate) building type %s (value? %d)\",\n                                     final_ident,\n-                                    if has_constructor { 1 } else { 0 });\n+                                    if has_constructor { 1 } else { 0 }};\n                             (*child_name_bindings).define_type(def);\n \n                             if has_constructor {\n@@ -1412,7 +1412,7 @@ class Resolver {\n                         def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n                         def_use(*) | def_upvar(*) | def_region(*) |\n                           def_typaram_binder(*) {\n-                            fail #fmt(\"didn't expect `%?`\", def);\n+                            fail fmt!{\"didn't expect `%?`\", def};\n                         }\n                     }\n                 }\n@@ -1421,12 +1421,12 @@ class Resolver {\n                     // written, we can't process this impl now. We'll get it\n                     // later.\n \n-                    #debug(\"(building reduced graph for external crate) \\\n-                            ignoring impl %s\", final_ident);\n+                    debug!{\"(building reduced graph for external crate) \\\n+                            ignoring impl %s\", final_ident};\n                 }\n                 dl_field {\n-                    #debug(\"(building reduced graph for external crate) \\\n-                            ignoring field %s\", final_ident);\n+                    debug!{\"(building reduced graph for external crate) \\\n+                            ignoring field %s\", final_ident};\n                 }\n             }\n         }\n@@ -1462,16 +1462,16 @@ class Resolver {\n         // by the fact that they have no def ID, which we do here in order to\n         // skip them.\n \n-        #debug(\"(building reduced graph for impls in external crate) looking \\\n+        debug!{\"(building reduced graph for impls in external crate) looking \\\n                 for impls in `%s` (%?)\",\n                self.module_to_str(module),\n-               copy module.def_id);\n+               copy module.def_id};\n \n         alt module.def_id {\n             none {\n-                #debug(\"(building reduced graph for impls in external \\\n+                debug!{\"(building reduced graph for impls in external \\\n                         module) no def ID for `%s`, skipping\",\n-                       self.module_to_str(module));\n+                       self.module_to_str(module)};\n                 ret;\n             }\n             some(_) {\n@@ -1492,11 +1492,11 @@ class Resolver {\n             }\n             def_ids.insert(implementation.did, ());\n \n-            #debug(\"(building reduced graph for impls in external module) \\\n+            debug!{\"(building reduced graph for impls in external module) \\\n                     added impl `%s` (%?) to `%s`\",\n                    *implementation.ident,\n                    implementation.did,\n-                   self.module_to_str(module));\n+                   self.module_to_str(module)};\n \n             let name = (*self.atom_table).intern(implementation.ident);\n \n@@ -1559,14 +1559,14 @@ class Resolver {\n         let mut i = 0u;\n         let mut prev_unresolved_imports = 0u;\n         loop {\n-            #debug(\"(resolving imports) iteration %u, %u imports left\",\n-                   i, self.unresolved_imports);\n+            debug!{\"(resolving imports) iteration %u, %u imports left\",\n+                   i, self.unresolved_imports};\n \n             let module_root = (*self.graph_root).get_module();\n             self.resolve_imports_for_module_subtree(module_root);\n \n             if self.unresolved_imports == 0u {\n-                #debug(\"(resolving imports) success\");\n+                debug!{\"(resolving imports) success\"};\n                 break;\n             }\n \n@@ -1586,8 +1586,8 @@ class Resolver {\n      * submodules.\n      */\n     fn resolve_imports_for_module_subtree(module: @Module) {\n-        #debug(\"(resolving imports for module subtree) resolving %s\",\n-               self.module_to_str(module));\n+        debug!{\"(resolving imports for module subtree) resolving %s\",\n+               self.module_to_str(module)};\n         self.resolve_imports_for_module(module);\n \n         for module.children.each |_name, child_node| {\n@@ -1609,9 +1609,9 @@ class Resolver {\n     /// Attempts to resolve imports for the given module only.\n     fn resolve_imports_for_module(module: @Module) {\n         if (*module).all_imports_resolved() {\n-            #debug(\"(resolving imports for module) all imports resolved for \\\n+            debug!{\"(resolving imports for module) all imports resolved for \\\n                    %s\",\n-                   self.module_to_str(module));\n+                   self.module_to_str(module)};\n             ret;\n         }\n \n@@ -1652,10 +1652,10 @@ class Resolver {\n         let mut resolution_result;\n         let module_path = import_directive.module_path;\n \n-        #debug(\"(resolving import for module) resolving import `%s::...` in \\\n+        debug!{\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n                *(*self.atom_table).atoms_to_str((*module_path).get()),\n-               self.module_to_str(module));\n+               self.module_to_str(module)};\n \n         // One-level renaming imports of the form `import foo = bar;` are\n         // handled specially.\n@@ -1736,16 +1736,16 @@ class Resolver {\n                              target: Atom, source: Atom)\n                           -> ResolveResult<()> {\n \n-        #debug(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n+        debug!{\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n                *(*self.atom_table).atom_to_str(target),\n                self.module_to_str(containing_module),\n                *(*self.atom_table).atom_to_str(source),\n-               self.module_to_str(module));\n+               self.module_to_str(module)};\n \n         if !self.name_is_exported(containing_module, source) {\n-            #debug(\"(resolving single import) name `%s` is unexported\",\n-                   *(*self.atom_table).atom_to_str(source));\n+            debug!{\"(resolving single import) name `%s` is unexported\",\n+                   *(*self.atom_table).atom_to_str(source)};\n             ret Failed;\n         }\n \n@@ -1800,8 +1800,8 @@ class Resolver {\n                 // able to resolve this import.\n \n                 if containing_module.glob_count > 0u {\n-                    #debug(\"(resolving single import) unresolved glob; \\\n-                            bailing out\");\n+                    debug!{\"(resolving single import) unresolved glob; \\\n+                            bailing out\"};\n                     ret Indeterminate;\n                 }\n \n@@ -1883,8 +1883,8 @@ class Resolver {\n                     }\n                     some(_) {\n                         // The import is unresolved. Bail out.\n-                        #debug(\"(resolving single import) unresolved import; \\\n-                                bailing out\");\n+                        debug!{\"(resolving single import) unresolved import; \\\n+                                bailing out\"};\n                         ret Indeterminate;\n                     }\n                 }\n@@ -1897,13 +1897,13 @@ class Resolver {\n \n         alt module_result {\n             BoundResult(target_module, name_bindings) {\n-                #debug(\"(resolving single import) found module binding\");\n+                debug!{\"(resolving single import) found module binding\"};\n                 import_resolution.module_target =\n                     some(Target(target_module, name_bindings));\n             }\n             UnboundResult {\n-                #debug(\"(resolving single import) didn't find module \\\n-                        binding\");\n+                debug!{\"(resolving single import) didn't find module \\\n+                        binding\"};\n             }\n             UnknownResult {\n                 fail ~\"module result should be known at this point\";\n@@ -1954,7 +1954,7 @@ class Resolver {\n         assert import_resolution.outstanding_references >= 1u;\n         import_resolution.outstanding_references -= 1u;\n \n-        #debug(\"(resolving single import) successfully resolved import\");\n+        debug!{\"(resolving single import) successfully resolved import\"};\n         ret Success(());\n     }\n \n@@ -1976,8 +1976,8 @@ class Resolver {\n         // (including globs).\n \n         if !(*containing_module).all_imports_resolved() {\n-            #debug(\"(resolving glob import) target module has unresolved \\\n-                    imports; bailing out\");\n+            debug!{\"(resolving glob import) target module has unresolved \\\n+                    imports; bailing out\"};\n             ret Indeterminate;\n         }\n \n@@ -1988,15 +1988,15 @@ class Resolver {\n                 |atom, target_import_resolution| {\n \n             if !self.name_is_exported(containing_module, atom) {\n-                #debug(\"(resolving glob import) name `%s` is unexported\",\n-                       *(*self.atom_table).atom_to_str(atom));\n+                debug!{\"(resolving glob import) name `%s` is unexported\",\n+                       *(*self.atom_table).atom_to_str(atom)};\n                 again;\n             }\n \n-            #debug(\"(resolving glob import) writing module resolution \\\n+            debug!{\"(resolving glob import) writing module resolution \\\n                     %? into `%s`\",\n                    is_none(target_import_resolution.module_target),\n-                   self.module_to_str(module));\n+                   self.module_to_str(module)};\n \n             // Here we merge two import resolutions.\n             alt module.import_resolutions.find(atom) {\n@@ -2065,8 +2065,8 @@ class Resolver {\n         // Add all children from the containing module.\n         for containing_module.children.each |atom, name_bindings| {\n             if !self.name_is_exported(containing_module, atom) {\n-                #debug(\"(resolving glob import) name `%s` is unexported\",\n-                       *(*self.atom_table).atom_to_str(atom));\n+                debug!{\"(resolving glob import) name `%s` is unexported\",\n+                       *(*self.atom_table).atom_to_str(atom)};\n                 again;\n             }\n \n@@ -2084,36 +2084,36 @@ class Resolver {\n             }\n \n \n-            #debug(\"(resolving glob import) writing resolution `%s` in `%s` \\\n+            debug!{\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`\",\n                    *(*self.atom_table).atom_to_str(atom),\n                    self.module_to_str(containing_module),\n-                   self.module_to_str(module));\n+                   self.module_to_str(module)};\n \n             // Merge the child item into the import resolution.\n             if (*name_bindings).defined_in_namespace(ModuleNS) {\n-                #debug(\"(resolving glob import) ... for module target\");\n+                debug!{\"(resolving glob import) ... for module target\"};\n                 dest_import_resolution.module_target =\n                     some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(ValueNS) {\n-                #debug(\"(resolving glob import) ... for value target\");\n+                debug!{\"(resolving glob import) ... for value target\"};\n                 dest_import_resolution.value_target =\n                     some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(TypeNS) {\n-                #debug(\"(resolving glob import) ... for type target\");\n+                debug!{\"(resolving glob import) ... for type target\"};\n                 dest_import_resolution.type_target =\n                     some(Target(containing_module, name_bindings));\n             }\n             if (*name_bindings).defined_in_namespace(ImplNS) {\n-                #debug(\"(resolving glob import) ... for impl target\");\n+                debug!{\"(resolving glob import) ... for impl target\"};\n                 (*dest_import_resolution.impl_target).push\n                     (@Target(containing_module, name_bindings));\n             }\n         }\n \n-        #debug(\"(resolving glob import) successfully resolved import\");\n+        debug!{\"(resolving glob import) successfully resolved import\"};\n         ret Success(());\n     }\n \n@@ -2142,19 +2142,19 @@ class Resolver {\n                     ret Failed;\n                 }\n                 Indeterminate {\n-                    #debug(\"(resolving module path for import) module \\\n+                    debug!{\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n-                            *(*self.atom_table).atom_to_str(name));\n+                            *(*self.atom_table).atom_to_str(name)};\n                     ret Indeterminate;\n                 }\n                 Success(target) {\n                     alt target.bindings.module_def {\n                         NoModuleDef {\n                             // Not a module.\n                             self.session.span_err(span,\n-                                                  #fmt(\"not a module: %s\",\n+                                                  fmt!{\"not a module: %s\",\n                                                        *(*self.atom_table).\n-                                                         atom_to_str(name)));\n+                                                         atom_to_str(name)});\n                             ret Failed;\n                         }\n                         ModuleDef(module) {\n@@ -2183,10 +2183,10 @@ class Resolver {\n         let module_path_len = (*module_path).len();\n         assert module_path_len > 0u;\n \n-        #debug(\"(resolving module path for import) processing `%s` rooted at \\\n+        debug!{\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n                *(*self.atom_table).atoms_to_str((*module_path).get()),\n-               self.module_to_str(module));\n+               self.module_to_str(module)};\n \n         // The first element of the module path must be in the current scope\n         // chain.\n@@ -2199,8 +2199,8 @@ class Resolver {\n                 ret Failed;\n             }\n             Indeterminate {\n-                #debug(\"(resolving module path for import) indeterminate; \\\n-                        bailing\");\n+                debug!{\"(resolving module path for import) indeterminate; \\\n+                        bailing\"};\n                 ret Indeterminate;\n             }\n             Success(resulting_module) {\n@@ -2220,11 +2220,11 @@ class Resolver {\n                                      namespace: Namespace)\n                                   -> ResolveResult<Target> {\n \n-        #debug(\"(resolving item in lexical scope) resolving `%s` in \\\n+        debug!{\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n                *(*self.atom_table).atom_to_str(name),\n                namespace,\n-               self.module_to_str(module));\n+               self.module_to_str(module)};\n \n         // The current module node is handled specially. First, check for\n         // its immediate children.\n@@ -2251,9 +2251,9 @@ class Resolver {\n                 alt (*import_resolution).target_for_namespace(namespace) {\n                     none {\n                         // Not found; continue.\n-                        #debug(\"(resolving item in lexical scope) found \\\n+                        debug!{\"(resolving item in lexical scope) found \\\n                                 import resolution, but not in namespace %?\",\n-                               namespace);\n+                               namespace};\n                     }\n                     some(target) {\n                         import_resolution.used = true;\n@@ -2270,8 +2270,8 @@ class Resolver {\n             alt search_module.parent_link {\n                 NoParentLink {\n                     // No more parents. This module was unresolved.\n-                    #debug(\"(resolving item in lexical scope) unresolved \\\n-                            module\");\n+                    debug!{\"(resolving item in lexical scope) unresolved \\\n+                            module\"};\n                     ret Failed;\n                 }\n                 ModuleParentLink(parent_module_node, _) |\n@@ -2290,8 +2290,8 @@ class Resolver {\n                     // We couldn't see through the higher scope because of an\n                     // unresolved import higher up. Bail.\n \n-                    #debug(\"(resolving item in lexical scope) indeterminate \\\n-                            higher scope; bailing\");\n+                    debug!{\"(resolving item in lexical scope) indeterminate \\\n+                            higher scope; bailing\"};\n                     ret Indeterminate;\n                 }\n                 Success(target) {\n@@ -2309,8 +2309,8 @@ class Resolver {\n             Success(target) {\n                 alt target.bindings.module_def {\n                     NoModuleDef {\n-                        #error(\"!!! (resolving module in lexical scope) module\n-                                wasn't actually a module!\");\n+                        error!{\"!!! (resolving module in lexical scope) module\n+                                wasn't actually a module!\"};\n                         ret Failed;\n                     }\n                     ModuleDef(module) {\n@@ -2319,13 +2319,13 @@ class Resolver {\n                 }\n             }\n             Indeterminate {\n-                #debug(\"(resolving module in lexical scope) indeterminate; \\\n-                        bailing\");\n+                debug!{\"(resolving module in lexical scope) indeterminate; \\\n+                        bailing\"};\n                 ret Indeterminate;\n             }\n             Failed {\n-                #debug(\"(resolving module in lexical scope) failed to \\\n-                        resolve\");\n+                debug!{\"(resolving module in lexical scope) failed to \\\n+                        resolve\"};\n                 ret Failed;\n             }\n         }\n@@ -2347,13 +2347,13 @@ class Resolver {\n                               xray: XrayFlag)\n                            -> ResolveResult<Target> {\n \n-        #debug(\"(resolving name in module) resolving `%s` in `%s`\",\n+        debug!{\"(resolving name in module) resolving `%s` in `%s`\",\n                *(*self.atom_table).atom_to_str(name),\n-               self.module_to_str(module));\n+               self.module_to_str(module)};\n \n         if xray == NoXray && !self.name_is_exported(module, name) {\n-            #debug(\"(resolving name in module) name `%s` is unexported\",\n-                   *(*self.atom_table).atom_to_str(name));\n+            debug!{\"(resolving name in module) name `%s` is unexported\",\n+                   *(*self.atom_table).atom_to_str(name)};\n             ret Failed;\n         }\n \n@@ -2362,7 +2362,7 @@ class Resolver {\n             some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) {\n \n-                #debug(\"(resolving name in module) found node as child\");\n+                debug!{\"(resolving name in module) found node as child\"};\n                 ret Success(Target(module, name_bindings));\n             }\n             some(_) | none {\n@@ -2374,28 +2374,28 @@ class Resolver {\n         // we bail out; we don't know its imports yet.\n \n         if module.glob_count > 0u {\n-            #debug(\"(resolving name in module) module has glob; bailing out\");\n+            debug!{\"(resolving name in module) module has glob; bailing out\"};\n             ret Indeterminate;\n         }\n \n         // Otherwise, we check the list of resolved imports.\n         alt module.import_resolutions.find(name) {\n             some(import_resolution) {\n                 if import_resolution.outstanding_references != 0u {\n-                    #debug(\"(resolving name in module) import unresolved; \\\n-                            bailing out\");\n+                    debug!{\"(resolving name in module) import unresolved; \\\n+                            bailing out\"};\n                     ret Indeterminate;\n                 }\n \n                 alt (*import_resolution).target_for_namespace(namespace) {\n                     none {\n-                        #debug(\"(resolving name in module) name found, but \\\n+                        debug!{\"(resolving name in module) name found, but \\\n                                 not in namespace %?\",\n-                               namespace);\n+                               namespace};\n                     }\n                     some(target) {\n-                        #debug(\"(resolving name in module) resolved to \\\n-                                import\");\n+                        debug!{\"(resolving name in module) resolved to \\\n+                                import\"};\n                         import_resolution.used = true;\n                         ret Success(copy target);\n                     }\n@@ -2407,8 +2407,8 @@ class Resolver {\n         }\n \n         // We're out of luck.\n-        #debug(\"(resolving name in module) failed to resolve %s\",\n-               *(*self.atom_table).atom_to_str(name));\n+        debug!{\"(resolving name in module) failed to resolve %s\",\n+               *(*self.atom_table).atom_to_str(name)};\n         ret Failed;\n     }\n \n@@ -2433,81 +2433,81 @@ class Resolver {\n             }\n         }\n \n-        #debug(\"(resolving one-level naming result) resolving import `%s` = \\\n+        debug!{\"(resolving one-level naming result) resolving import `%s` = \\\n                 `%s` in `%s`\",\n                 *(*self.atom_table).atom_to_str(target_name),\n                 *(*self.atom_table).atom_to_str(source_name),\n-                self.module_to_str(module));\n+                self.module_to_str(module)};\n \n         // Find the matching items in the lexical scope chain for every\n         // namespace. If any of them come back indeterminate, this entire\n         // import is indeterminate.\n \n         let mut module_result;\n-        #debug(\"(resolving one-level naming result) searching for module\");\n+        debug!{\"(resolving one-level naming result) searching for module\"};\n         alt self.resolve_item_in_lexical_scope(module,\n                                                source_name,\n                                                ModuleNS) {\n \n             Failed {\n-                #debug(\"(resolving one-level renaming import) didn't find \\\n-                        module result\");\n+                debug!{\"(resolving one-level renaming import) didn't find \\\n+                        module result\"};\n                 module_result = none;\n             }\n             Indeterminate {\n-                #debug(\"(resolving one-level renaming import) module result \\\n-                        is indeterminate; bailing\");\n+                debug!{\"(resolving one-level renaming import) module result \\\n+                        is indeterminate; bailing\"};\n                 ret Indeterminate;\n             }\n             Success(name_bindings) {\n-                #debug(\"(resolving one-level renaming import) module result \\\n-                        found\");\n+                debug!{\"(resolving one-level renaming import) module result \\\n+                        found\"};\n                 module_result = some(copy name_bindings);\n             }\n         }\n \n         let mut value_result;\n-        #debug(\"(resolving one-level naming result) searching for value\");\n+        debug!{\"(resolving one-level naming result) searching for value\"};\n         alt self.resolve_item_in_lexical_scope(module,\n                                                source_name,\n                                                ValueNS) {\n \n             Failed {\n-                #debug(\"(resolving one-level renaming import) didn't find \\\n-                        value result\");\n+                debug!{\"(resolving one-level renaming import) didn't find \\\n+                        value result\"};\n                 value_result = none;\n             }\n             Indeterminate {\n-                #debug(\"(resolving one-level renaming import) value result \\\n-                        is indeterminate; bailing\");\n+                debug!{\"(resolving one-level renaming import) value result \\\n+                        is indeterminate; bailing\"};\n                 ret Indeterminate;\n             }\n             Success(name_bindings) {\n-                #debug(\"(resolving one-level renaming import) value result \\\n-                        found\");\n+                debug!{\"(resolving one-level renaming import) value result \\\n+                        found\"};\n                 value_result = some(copy name_bindings);\n             }\n         }\n \n         let mut type_result;\n-        #debug(\"(resolving one-level naming result) searching for type\");\n+        debug!{\"(resolving one-level naming result) searching for type\"};\n         alt self.resolve_item_in_lexical_scope(module,\n                                                source_name,\n                                                TypeNS) {\n \n             Failed {\n-                #debug(\"(resolving one-level renaming import) didn't find \\\n-                        type result\");\n+                debug!{\"(resolving one-level renaming import) didn't find \\\n+                        type result\"};\n                 type_result = none;\n             }\n             Indeterminate {\n-                #debug(\"(resolving one-level renaming import) type result is \\\n-                        indeterminate; bailing\");\n+                debug!{\"(resolving one-level renaming import) type result is \\\n+                        indeterminate; bailing\"};\n                 ret Indeterminate;\n             }\n             Success(name_bindings) {\n-                #debug(\"(resolving one-level renaming import) type result \\\n-                        found\");\n+                debug!{\"(resolving one-level renaming import) type result \\\n+                        found\"};\n                 type_result = some(copy name_bindings);\n             }\n         }\n@@ -2530,24 +2530,24 @@ class Resolver {\n         //\n \n         let mut impl_result;\n-        #debug(\"(resolving one-level naming result) searching for impl\");\n+        debug!{\"(resolving one-level naming result) searching for impl\"};\n         alt self.resolve_item_in_lexical_scope(module,\n                                                source_name,\n                                                ImplNS) {\n \n             Failed {\n-                #debug(\"(resolving one-level renaming import) didn't find \\\n-                        impl result\");\n+                debug!{\"(resolving one-level renaming import) didn't find \\\n+                        impl result\"};\n                 impl_result = none;\n             }\n             Indeterminate {\n-                #debug(\"(resolving one-level renaming import) impl result is \\\n-                        indeterminate; bailing\");\n+                debug!{\"(resolving one-level renaming import) impl result is \\\n+                        indeterminate; bailing\"};\n                 ret Indeterminate;\n             }\n             Success(name_bindings) {\n-                #debug(\"(resolving one-level renaming import) impl result \\\n-                        found\");\n+                debug!{\"(resolving one-level renaming import) impl result \\\n+                        found\"};\n                 impl_result = some(@copy name_bindings);\n             }\n         }\n@@ -2569,11 +2569,11 @@ class Resolver {\n                       import resolution name by now\";\n             }\n             some(import_resolution) {\n-                #debug(\"(resolving one-level renaming import) writing module \\\n+                debug!{\"(resolving one-level renaming import) writing module \\\n                         result %? for `%s` into `%s`\",\n                        is_none(module_result),\n                        *(*self.atom_table).atom_to_str(target_name),\n-                       self.module_to_str(module));\n+                       self.module_to_str(module)};\n \n                 import_resolution.module_target = module_result;\n                 import_resolution.value_target = value_result;\n@@ -2593,7 +2593,7 @@ class Resolver {\n             }\n         }\n \n-        #debug(\"(resolving one-level renaming import) successfully resolved\");\n+        debug!{\"(resolving one-level renaming import) successfully resolved\"};\n         ret Success(());\n     }\n \n@@ -2649,9 +2649,9 @@ class Resolver {\n             }\n             some(_) {\n                 // Bail out.\n-                #debug(\"(recording exports for module subtree) not recording \\\n+                debug!{\"(recording exports for module subtree) not recording \\\n                         exports for `%s`\",\n-                       self.module_to_str(module));\n+                       self.module_to_str(module)};\n                 ret;\n             }\n         }\n@@ -2735,9 +2735,9 @@ class Resolver {\n             }\n             some(_) {\n                 // Bail out.\n-                #debug(\"(building impl scopes for module subtree) not \\\n+                debug!{\"(building impl scopes for module subtree) not \\\n                         resolving implementations for `%s`\",\n-                       self.module_to_str(module));\n+                       self.module_to_str(module)};\n                 ret;\n             }\n         }\n@@ -2763,9 +2763,9 @@ class Resolver {\n     fn build_impl_scope_for_module(module: @Module) {\n         let mut impl_scope = ~[];\n \n-        #debug(\"(building impl scope for module) processing module %s (%?)\",\n+        debug!{\"(building impl scope for module) processing module %s (%?)\",\n                self.module_to_str(module),\n-               copy module.def_id);\n+               copy module.def_id};\n \n         // Gather up all direct children implementations in the module.\n         for module.children.each |_impl_name, child_name_bindings| {\n@@ -2774,20 +2774,20 @@ class Resolver {\n             }\n         }\n \n-        #debug(\"(building impl scope for module) found %u impl(s) as direct \\\n+        debug!{\"(building impl scope for module) found %u impl(s) as direct \\\n                 children\",\n-               impl_scope.len());\n+               impl_scope.len()};\n \n         // Gather up all imports.\n         for module.import_resolutions.each |_impl_name, import_resolution| {\n             for (*import_resolution.impl_target).each |impl_target| {\n-                #debug(\"(building impl scope for module) found impl def\");\n+                debug!{\"(building impl scope for module) found impl def\"};\n                 impl_scope += impl_target.bindings.impl_defs;\n             }\n         }\n \n-        #debug(\"(building impl scope for module) found %u impl(s) in total\",\n-               impl_scope.len());\n+        debug!{\"(building impl scope for module) found %u impl(s) in total\",\n+               impl_scope.len()};\n \n         // Determine the parent's implementation scope.\n         let mut parent_impl_scopes;\n@@ -2840,17 +2840,17 @@ class Resolver {\n             some(name) {\n                 alt orig_module.children.find(name) {\n                     none {\n-                        #debug(\"!!! (with scope) didn't find `%s` in `%s`\",\n+                        debug!{\"!!! (with scope) didn't find `%s` in `%s`\",\n                                *(*self.atom_table).atom_to_str(name),\n-                               self.module_to_str(orig_module));\n+                               self.module_to_str(orig_module)};\n                     }\n                     some(name_bindings) {\n                         alt (*name_bindings).get_module_if_available() {\n                             none {\n-                                #debug(\"!!! (with scope) didn't find module \\\n+                                debug!{\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n                                        *(*self.atom_table).atom_to_str(name),\n-                                       self.module_to_str(orig_module));\n+                                       self.module_to_str(orig_module)};\n                             }\n                             some(module) {\n                                 self.current_module = module;\n@@ -2995,7 +2995,7 @@ class Resolver {\n \n     // XXX: This shouldn't be unsafe!\n     fn resolve_crate() unsafe {\n-        #debug(\"(resolving crate) starting\");\n+        debug!{\"(resolving crate) starting\"};\n \n         // To avoid a failure in metadata encoding later, we have to add the\n         // crate-level implementation scopes\n@@ -3022,7 +3022,7 @@ class Resolver {\n     }\n \n     fn resolve_item(item: @item, visitor: ResolveVisitor) {\n-        #debug(\"(resolving item) resolving %s\", *item.ident);\n+        debug!{\"(resolving item) resolving %s\", *item.ident};\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n@@ -3198,8 +3198,8 @@ class Resolver {\n                 for (*type_parameters).eachi |index, type_parameter| {\n                     let name =\n                         (*self.atom_table).intern(type_parameter.ident);\n-                    #debug(\"with_type_parameter_rib: %d %d\", node_id,\n-                           type_parameter.id);\n+                    debug!{\"with_type_parameter_rib: %d %d\", node_id,\n+                           type_parameter.id};\n                     let def_like = dl_def(def_ty_param\n                         (local_def(type_parameter.id),\n                          index + initial_index));\n@@ -3304,8 +3304,8 @@ class Resolver {\n \n                         self.resolve_type(argument.ty, visitor);\n \n-                        #debug(\"(resolving function) recorded argument `%s`\",\n-                               *(*self.atom_table).atom_to_str(name));\n+                        debug!{\"(resolving function) recorded argument `%s`\",\n+                               *(*self.atom_table).atom_to_str(name)};\n                     }\n \n                     self.resolve_type(declaration.output, visitor);\n@@ -3315,7 +3315,7 @@ class Resolver {\n             // Resolve the function body.\n             self.resolve_block(block, visitor);\n \n-            #debug(\"(resolving function) leaving function\");\n+            debug!{\"(resolving function) leaving function\"};\n         }\n \n         (*self.value_ribs).pop();\n@@ -3372,7 +3372,7 @@ class Resolver {\n                         // definition of the interface into the definition\n                         // map.\n \n-                        #debug(\"(resolving class) found trait def: %?\", def);\n+                        debug!{\"(resolving class) found trait def: %?\", def};\n \n                         self.record_def(interface.ref_id, def);\n \n@@ -3530,7 +3530,7 @@ class Resolver {\n                       visitor: ResolveVisitor) {\n \n         // Write the implementations in scope into the module metadata.\n-        #debug(\"(resolving module) resolving module ID %d\", id);\n+        debug!{\"(resolving module) resolving module ID %d\", id};\n         self.impl_map.insert(id, self.current_module.impl_scopes);\n \n         visit_mod(module, span, id, (), visitor);\n@@ -3577,9 +3577,9 @@ class Resolver {\n        */\n       for arm.pats.each |p| {\n          do pat_util::pat_bindings(self.def_map, p) |_id, sp, pth| {\n-             self.session.span_note(sp, #fmt(\"Treating %s as a variable \\\n+             self.session.span_note(sp, fmt!{\"Treating %s as a variable \\\n                binding, because it does not denote any variant in scope\",\n-                                             path_to_str(pth)));\n+                                             path_to_str(pth)});\n          }\n       };\n     }\n@@ -3616,16 +3616,16 @@ class Resolver {\n     }\n \n     fn resolve_block(block: blk, visitor: ResolveVisitor) {\n-        #debug(\"(resolving block) entering block\");\n+        debug!{\"(resolving block) entering block\"};\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n         alt self.current_module.anonymous_children.find(block.node.id) {\n             none { /* Nothing to do. */ }\n             some(anonymous_module) {\n-                #debug(\"(resolving block) found anonymous module, moving \\\n-                        down\");\n+                debug!{\"(resolving block) found anonymous module, moving \\\n+                        down\"};\n                 self.current_module = anonymous_module;\n             }\n         }\n@@ -3637,7 +3637,7 @@ class Resolver {\n         self.current_module = orig_module;\n \n         (*self.value_ribs).pop();\n-        #debug(\"(resolving block) leaving block\");\n+        debug!{\"(resolving block) leaving block\"};\n     }\n \n     fn resolve_type(ty: @ty, visitor: ResolveVisitor) {\n@@ -3652,8 +3652,8 @@ class Resolver {\n                 let mut result_def;\n                 alt self.resolve_path(path, TypeNS, true, visitor) {\n                     some(def) {\n-                        #debug(\"(resolving type) resolved `%s` to type\",\n-                               *path.idents.last());\n+                        debug!{\"(resolving type) resolved `%s` to type\",\n+                               *path.idents.last()};\n                         result_def = some(def);\n                     }\n                     none {\n@@ -3690,17 +3690,17 @@ class Resolver {\n                 alt copy result_def {\n                     some(def) {\n                         // Write the result into the def map.\n-                        #debug(\"(resolving type) writing resolution for `%s` \\\n+                        debug!{\"(resolving type) writing resolution for `%s` \\\n                                 (id %d)\",\n                                connect(path.idents.map(|x| *x), ~\"::\"),\n-                               path_id);\n+                               path_id};\n                         self.record_def(path_id, def);\n                     }\n                     none {\n                         self.session.span_err\n-                            (ty.span, #fmt(\"use of undeclared type name `%s`\",\n+                            (ty.span, fmt!{\"use of undeclared type name `%s`\",\n                                            connect(path.idents.map(|x| *x),\n-                                                   ~\"::\")));\n+                                                   ~\"::\")});\n                     }\n                 }\n             }\n@@ -3738,20 +3738,20 @@ class Resolver {\n \n                     alt self.resolve_enum_variant_or_const(atom) {\n                         FoundEnumVariant(def) if mode == RefutableMode {\n-                            #debug(\"(resolving pattern) resolving `%s` to \\\n+                            debug!{\"(resolving pattern) resolving `%s` to \\\n                                     enum variant\",\n-                                   *path.idents[0]);\n+                                   *path.idents[0]};\n \n                             self.record_def(pattern.id, def);\n                         }\n                         FoundEnumVariant(_) {\n                             self.session.span_err(pattern.span,\n-                                                  #fmt(\"declaration of `%s` \\\n+                                                  fmt!{\"declaration of `%s` \\\n                                                         shadows an enum \\\n                                                         that's in scope\",\n                                                        *(*self.atom_table).\n                                                             atom_to_str\n-                                                            (atom)));\n+                                                            (atom)});\n                         }\n                         FoundConst {\n                             self.session.span_err(pattern.span,\n@@ -3760,8 +3760,8 @@ class Resolver {\n                                                    in scope\");\n                         }\n                         EnumVariantOrConstNotFound {\n-                            #debug(\"(resolving pattern) binding `%s`\",\n-                                   *path.idents[0]);\n+                            debug!{\"(resolving pattern) binding `%s`\",\n+                                   *path.idents[0]};\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -3804,9 +3804,9 @@ class Resolver {\n                                       // in the same disjunct, which is an\n                                       // error\n                                      self.session.span_err(pattern.span,\n-                                       #fmt(\"Identifier %s is bound more \\\n+                                       fmt!{\"Identifier %s is bound more \\\n                                              than once in the same pattern\",\n-                                            path_to_str(path)));\n+                                            path_to_str(path)});\n                                   }\n                                   // Not bound in the same pattern: do nothing\n                                 }\n@@ -3833,9 +3833,9 @@ class Resolver {\n                         }\n                         some(_) {\n                             self.session.span_err(path.span,\n-                                                  #fmt(\"not an enum \\\n+                                                  fmt!{\"not an enum \\\n                                                         variant: %s\",\n-                                                       *path.idents.last()));\n+                                                       *path.idents.last()});\n                         }\n                         none {\n                             self.session.span_err(path.span,\n@@ -3962,9 +3962,9 @@ class Resolver {\n                                          -> NameDefinition {\n \n         if xray == NoXray && !self.name_is_exported(containing_module, name) {\n-            #debug(\"(resolving definition of name in module) name `%s` is \\\n+            debug!{\"(resolving definition of name in module) name `%s` is \\\n                     unexported\",\n-                   *(*self.atom_table).atom_to_str(name));\n+                   *(*self.atom_table).atom_to_str(name)};\n             ret NoNameDefinition;\n         }\n \n@@ -4044,9 +4044,9 @@ class Resolver {\n \n             Failed {\n                 self.session.span_err(path.span,\n-                                      #fmt(\"use of undeclared module `%s`\",\n+                                      fmt!{\"use of undeclared module `%s`\",\n                                             *(*self.atom_table).atoms_to_str\n-                                              ((*module_path_atoms).get())));\n+                                              ((*module_path_atoms).get())});\n                 ret none;\n             }\n \n@@ -4067,11 +4067,11 @@ class Resolver {\n             NoNameDefinition {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(path.span,\n-                                      #fmt(\"unresolved name: %s::%s\",\n+                                      fmt!{\"unresolved name: %s::%s\",\n                                            *(*self.atom_table).atoms_to_str\n                                                ((*module_path_atoms).get()),\n                                            *(*self.atom_table).atom_to_str\n-                                               (name)));\n+                                               (name)});\n                 ret none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) {\n@@ -4098,9 +4098,9 @@ class Resolver {\n \n             Failed {\n                 self.session.span_err(path.span,\n-                                      #fmt(\"use of undeclared module `::%s`\",\n+                                      fmt!{\"use of undeclared module `::%s`\",\n                                             *(*self.atom_table).atoms_to_str\n-                                              ((*module_path_atoms).get())));\n+                                              ((*module_path_atoms).get())});\n                 ret none;\n             }\n \n@@ -4121,11 +4121,11 @@ class Resolver {\n             NoNameDefinition {\n                 // We failed to resolve the name. Report an error.\n                 self.session.span_err(path.span,\n-                                      #fmt(\"unresolved name: %s::%s\",\n+                                      fmt!{\"unresolved name: %s::%s\",\n                                            *(*self.atom_table).atoms_to_str\n                                                ((*module_path_atoms).get()),\n                                            *(*self.atom_table).atom_to_str\n-                                               (name)));\n+                                               (name)});\n                 ret none;\n             }\n             ChildNameDefinition(def) | ImportNameDefinition(def) {\n@@ -4159,10 +4159,10 @@ class Resolver {\n \n         alt copy search_result {\n             some(dl_def(def)) {\n-                #debug(\"(resolving path in local ribs) resolved `%s` to \\\n+                debug!{\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n                        *(*self.atom_table).atom_to_str(name),\n-                       def);\n+                       def};\n                 ret some(def);\n             }\n             some(dl_field) | some(dl_impl(_)) | none {\n@@ -4189,9 +4189,9 @@ class Resolver {\n                               bindings with no def for that namespace?!\";\n                     }\n                     some(def) {\n-                        #debug(\"(resolving item path in lexical scope) \\\n+                        debug!{\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n-                               *(*self.atom_table).atom_to_str(name));\n+                               *(*self.atom_table).atom_to_str(name)};\n                         ret some(def);\n                     }\n                 }\n@@ -4228,15 +4228,15 @@ class Resolver {\n                 alt self.resolve_path(path, ValueNS, true, visitor) {\n                     some(def) {\n                         // Write the result into the def map.\n-                        #debug(\"(resolving expr) resolved `%s`\",\n-                               connect(path.idents.map(|x| *x), ~\"::\"));\n+                        debug!{\"(resolving expr) resolved `%s`\",\n+                               connect(path.idents.map(|x| *x), ~\"::\")};\n                         self.record_def(expr.id, def);\n                     }\n                     none {\n                         self.session.span_err(expr.span,\n-                                              #fmt(\"unresolved name: %s\",\n+                                              fmt!{\"unresolved name: %s\",\n                                               connect(path.idents.map(|x| *x),\n-                                                      ~\"::\")));\n+                                                      ~\"::\")});\n                     }\n                 }\n \n@@ -4280,11 +4280,11 @@ class Resolver {\n                     }\n                     _ {\n                         self.session.span_err(path.span,\n-                                              #fmt(\"`%s` does not name a \\\n+                                              fmt!{\"`%s` does not name a \\\n                                                     structure\",\n                                                    connect(path.idents.map\n                                                            (|x| *x),\n-                                                           ~\"::\")));\n+                                                           ~\"::\")});\n                     }\n                 }\n \n@@ -4450,11 +4450,11 @@ class Resolver {\n \n         alt self.trait_info.find(trait_def_id) {\n             some(trait_info) if trait_info.contains_key(name) {\n-                #debug(\"(adding trait info if containing method) found trait \\\n+                debug!{\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\",\n                        trait_def_id.crate,\n                        trait_def_id.node,\n-                       *(*self.atom_table).atom_to_str(name));\n+                       *(*self.atom_table).atom_to_str(name)};\n                 (*found_traits).push(trait_def_id);\n             }\n             some(_) | none {\n@@ -4470,7 +4470,7 @@ class Resolver {\n     }\n \n     fn record_def(node_id: node_id, def: def) {\n-        #debug(\"(recording def) recording %? for %?\", def, node_id);\n+        debug!{\"(recording def) recording %? for %?\", def, node_id};\n         self.def_map.insert(node_id, def);\n     }\n \n@@ -4503,9 +4503,9 @@ class Resolver {\n             }\n             some(_) {\n                 // Bail out.\n-                #debug(\"(checking for unused imports in module subtree) not \\\n+                debug!{\"(checking for unused imports in module subtree) not \\\n                         checking for unused imports for `%s`\",\n-                       self.module_to_str(module));\n+                       self.module_to_str(module)};\n                 ret;\n             }\n         }\n@@ -4600,14 +4600,14 @@ class Resolver {\n     }\n \n     fn dump_module(module: @Module) {\n-        #debug(\"Dump of module `%s`:\", self.module_to_str(module));\n+        debug!{\"Dump of module `%s`:\", self.module_to_str(module)};\n \n-        #debug(\"Children:\");\n+        debug!{\"Children:\"};\n         for module.children.each |name, _child| {\n-            #debug(\"* %s\", *(*self.atom_table).atom_to_str(name));\n+            debug!{\"* %s\", *(*self.atom_table).atom_to_str(name)};\n         }\n \n-        #debug(\"Import resolutions:\");\n+        debug!{\"Import resolutions:\"};\n         for module.import_resolutions.each |name, import_resolution| {\n             let mut module_repr;\n             alt (*import_resolution).target_for_namespace(ModuleNS) {\n@@ -4645,24 +4645,24 @@ class Resolver {\n                 }\n             }\n \n-            #debug(\"* %s:%s%s%s%s\",\n+            debug!{\"* %s:%s%s%s%s\",\n                    *(*self.atom_table).atom_to_str(name),\n-                   module_repr, value_repr, type_repr, impl_repr);\n+                   module_repr, value_repr, type_repr, impl_repr};\n         }\n     }\n \n     fn dump_impl_scopes(impl_scopes: ImplScopes) {\n-        #debug(\"Dump of impl scopes:\");\n+        debug!{\"Dump of impl scopes:\"};\n \n         let mut i = 0u;\n         let mut impl_scopes = impl_scopes;\n         loop {\n             alt *impl_scopes {\n                 cons(impl_scope, rest_impl_scopes) {\n-                    #debug(\"Impl scope %u:\", i);\n+                    debug!{\"Impl scope %u:\", i};\n \n                     for (*impl_scope).each |implementation| {\n-                        #debug(\"Impl: %s\", *implementation.ident);\n+                        debug!{\"Impl: %s\", *implementation.ident};\n                     }\n \n                     i += 1u;"}, {"sha": "2e5d5051a79f5dd027edff0923af3fd0a9c5096f", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 85, "deletions": 85, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -67,8 +67,8 @@ enum dest {\n \n fn dest_str(ccx: @crate_ctxt, d: dest) -> ~str {\n     alt d {\n-      by_val(v) { #fmt[\"by_val(%s)\", val_str(ccx.tn, *v)] }\n-      save_in(v) { #fmt[\"save_in(%s)\", val_str(ccx.tn, v)] }\n+      by_val(v) { fmt!{\"by_val(%s)\", val_str(ccx.tn, *v)} }\n+      save_in(v) { fmt!{\"save_in(%s)\", val_str(ccx.tn, v)} }\n       ignore { ~\"ignore\" }\n     }\n }\n@@ -100,7 +100,7 @@ trait get_insn_ctxt {\n \n impl ccx_icx of get_insn_ctxt for @crate_ctxt {\n     fn insn_ctxt(s: ~str) -> icx_popper {\n-        #debug(\"new insn_ctxt: %s\", s);\n+        debug!{\"new insn_ctxt: %s\", s};\n         if self.sess.count_llvm_insns() {\n             vec::push(*self.stats.llvm_insn_ctxt, s);\n         }\n@@ -496,7 +496,7 @@ fn declare_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n         mangle_internal_name_by_type_only(ccx, t, @~\"tydesc\")\n     } else { mangle_internal_name_by_seq(ccx, @~\"tydesc\") };\n     note_unique_llvm_symbol(ccx, name);\n-    log(debug, #fmt(\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name));\n+    log(debug, fmt!{\"+++ declare_tydesc %s %s\", ty_to_str(ccx.tcx, t), name});\n     let gvar = str::as_c_str(name, |buf| {\n         llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n     });\n@@ -1091,60 +1091,60 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n         alt ti.take_glue {\n           some(_) { }\n           none {\n-            #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"+++ lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n             let glue_fn = declare_generic_glue\n                 (ccx, ti.ty, T_glue_fn(ccx), ~\"take\");\n             ti.take_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn,\n                               make_take_glue, ~\"take\");\n-            #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"--- lazily_emit_tydesc_glue TAKE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n         }\n     } else if field == abi::tydesc_field_drop_glue {\n         alt ti.drop_glue {\n           some(_) { }\n           none {\n-            #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"+++ lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n             let glue_fn =\n                 declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), ~\"drop\");\n             ti.drop_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn,\n                               make_drop_glue, ~\"drop\");\n-            #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"--- lazily_emit_tydesc_glue DROP %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n         }\n     } else if field == abi::tydesc_field_free_glue {\n         alt ti.free_glue {\n           some(_) { }\n           none {\n-            #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n             let glue_fn =\n                 declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), ~\"free\");\n             ti.free_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn,\n                               make_free_glue, ~\"free\");\n-            #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"--- lazily_emit_tydesc_glue FREE %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n         }\n     } else if field == abi::tydesc_field_visit_glue {\n         alt ti.visit_glue {\n           some(_) { }\n           none {\n-            #debug(\"+++ lazily_emit_tydesc_glue VISIT %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"+++ lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n             let glue_fn =\n                 declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), ~\"visit\");\n             ti.visit_glue = some(glue_fn);\n             make_generic_glue(ccx, ti.ty, glue_fn,\n                               make_visit_glue, ~\"visit\");\n-            #debug(\"--- lazily_emit_tydesc_glue VISIT %s\",\n-                   ppaux::ty_to_str(ccx.tcx, ti.ty));\n+            debug!{\"--- lazily_emit_tydesc_glue VISIT %s\",\n+                   ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n         }\n     }\n@@ -1698,7 +1698,7 @@ fn trans_eager_binop(cx: block, span: span, op: ast::binop, lhs: ValueRef,\n \n fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n                    dst: @ast::expr, src: @ast::expr) -> block {\n-    #debug[\"%s\", expr_to_str(ex)];\n+    debug!{\"%s\", expr_to_str(ex)};\n     let _icx = bcx.insn_ctxt(~\"trans_assign_op\");\n     let t = expr_ty(bcx, src);\n     let lhs_res = trans_lval(bcx, dst);\n@@ -1708,8 +1708,8 @@ fn trans_assign_op(bcx: block, ex: @ast::expr, op: ast::binop,\n     alt bcx.ccx().maps.method_map.find(ex.id) {\n       some(origin) {\n         let bcx = lhs_res.bcx;\n-        #debug[\"user-defined method callee_id: %s\",\n-               ast_map::node_id_to_str(bcx.tcx().items, ex.callee_id)];\n+        debug!{\"user-defined method callee_id: %s\",\n+               ast_map::node_id_to_str(bcx.tcx().items, ex.callee_id)};\n         let fty = node_id_type(bcx, ex.callee_id);\n \n         let dty = expr_ty(bcx, dst);\n@@ -1745,7 +1745,7 @@ fn root_value(bcx: block, val: ValueRef, ty: ty::t,\n     if bcx.sess().trace() {\n         trans_trace(\n             bcx, none,\n-            #fmt[\"preserving until end of scope %d\", scope_id]);\n+            fmt!{\"preserving until end of scope %d\", scope_id});\n     }\n \n     let root_loc = alloca_zeroed(bcx, type_of(bcx.ccx(), ty));\n@@ -1764,9 +1764,9 @@ fn autoderef(cx: block, e_id: ast::node_id,\n     let ccx = cx.ccx();\n     let mut derefs = 0u;\n     while derefs < max {\n-        #debug[\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n+        debug!{\"autoderef(e_id=%d, v1=%s, t1=%s, derefs=%u)\",\n                e_id, val_str(ccx.tn, v1), ppaux::ty_to_str(ccx.tcx, t1),\n-               derefs];\n+               derefs};\n \n         // root the autoderef'd value, if necessary:\n         derefs += 1u;\n@@ -2113,8 +2113,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n \n     alt ccx.monomorphized.find(hash_id) {\n       some(val) {\n-        #debug[\"leaving monomorphic fn %s\",\n-               ty::item_path_str(ccx.tcx, fn_id)];\n+        debug!{\"leaving monomorphic fn %s\",\n+               ty::item_path_str(ccx.tcx, fn_id)};\n         ret {val: val, must_cast: must_cast};\n       }\n       none {}\n@@ -2124,9 +2124,9 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     let mut llitem_ty = tpt.ty;\n \n     let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n-     || #fmt(\"While monomorphizing %?, couldn't find it in the item map \\\n+     || fmt!{\"While monomorphizing %?, couldn't find it in the item map \\\n         (may have attempted to monomorphize an item defined in a different \\\n-        crate?)\", fn_id));\n+        crate?)\", fn_id});\n     // Get the path so that we can create a symbol\n     let (pt, name, span) = alt map_node {\n       ast_map::node_item(i, pt) { (pt, i.ident, i.span) }\n@@ -2250,7 +2250,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id,\n     };\n     ccx.monomorphizing.insert(fn_id, depth);\n \n-    #debug[\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id)];\n+    debug!{\"leaving monomorphic fn %s\", ty::item_path_str(ccx.tcx, fn_id)};\n     {val: lldecl, must_cast: must_cast}\n }\n \n@@ -2260,8 +2260,8 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n     alt ccx.external.find(fn_id) {\n       some(some(node_id)) {\n         // Already inline\n-        #debug[\"maybe_instantiate_inline(%s): already inline as node id %d\",\n-               ty::item_path_str(ccx.tcx, fn_id), node_id];\n+        debug!{\"maybe_instantiate_inline(%s): already inline as node id %d\",\n+               ty::item_path_str(ccx.tcx, fn_id), node_id};\n         local_def(node_id)\n       }\n       some(none) { fn_id } // Not inlinable\n@@ -2448,8 +2448,8 @@ fn trans_local_var(cx: block, def: ast::def) -> local_var_result {\n         ret {val: slf, kind: lv_owned};\n       }\n       _ {\n-        cx.sess().unimpl(#fmt(\"unsupported def type in trans_local_def: %?\",\n-                              def));\n+        cx.sess().unimpl(fmt!{\"unsupported def type in trans_local_def: %?\",\n+                              def});\n       }\n     }\n }\n@@ -2534,7 +2534,7 @@ fn trans_rec_field_inner(bcx: block, val: ValueRef, ty: ty::t,\n \n     let ix = field_idx_strict(bcx.tcx(), sp, field, fields);\n \n-    #debug(\"val = %s ix = %u\", bcx.val_str(val), ix);\n+    debug!{\"val = %s ix = %u\", bcx.val_str(val), ix};\n \n     /* self is a class with a dtor, which means we\n        have to select out the object itself\n@@ -2586,8 +2586,8 @@ fn trans_index(cx: block, ex: @ast::expr, base: @ast::expr,\n         len = Sub(bcx, len, C_uint(bcx.ccx(), 1u));\n     }\n \n-    #debug(\"trans_index: base %s\", val_str(bcx.ccx().tn, base));\n-    #debug(\"trans_index: len %s\", val_str(bcx.ccx().tn, len));\n+    debug!{\"trans_index: base %s\", val_str(bcx.ccx().tn, base)};\n+    debug!{\"trans_index: len %s\", val_str(bcx.ccx().tn, len)};\n \n     let bounds_check = ICmp(bcx, lib::llvm::IntUGE, scaled_ix, len);\n     let bcx = do with_cond(bcx, bounds_check) |bcx| {\n@@ -2645,8 +2645,8 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n         let lv = unrooted(cx, e);\n \n         if !cx.sess().no_asm_comments() {\n-            add_comment(cx, #fmt[\"preserving until end of scope %d\",\n-                                 scope_id]);\n+            add_comment(cx, fmt!{\"preserving until end of scope %d\",\n+                                 scope_id});\n         }\n \n         let _icx = lv.bcx.insn_ctxt(~\"root_value_lval\");\n@@ -2707,7 +2707,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n  * wrong address space and thus be the wrong type.\n  */\n fn non_gc_box_cast(cx: block, val: ValueRef) -> ValueRef {\n-    #debug(\"non_gc_box_cast\");\n+    debug!{\"non_gc_box_cast\"};\n     add_comment(cx, ~\"non_gc_box_cast\");\n     assert(llvm::LLVMGetPointerAddressSpace(val_ty(val)) as uint == 1u);\n     let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n@@ -2856,7 +2856,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n                   &temp_cleanups: ~[ValueRef], ret_flag: option<ValueRef>,\n                   derefs: uint)\n     -> result {\n-    #debug(\"+++ trans_arg_expr on %s\", expr_to_str(e));\n+    debug!{\"+++ trans_arg_expr on %s\", expr_to_str(e)};\n     let _icx = cx.insn_ctxt(~\"trans_arg_expr\");\n     let ccx = cx.ccx();\n     let e_ty = expr_ty(cx, e);\n@@ -2881,7 +2881,7 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n \n     // auto-deref value as required (this only applies to method\n     // call receivers) of method\n-    #debug(\"   pre-deref value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n+    debug!{\"   pre-deref value: %s\", val_str(lv.bcx.ccx().tn, lv.val)};\n     let {lv, e_ty} = if derefs == 0u {\n       {lv: lv, e_ty: e_ty}\n     } else {\n@@ -2893,11 +2893,11 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     };\n \n     // borrow value (convert from @T to &T and so forth)\n-    #debug(\"   pre-adaptation value: %s\", val_str(lv.bcx.ccx().tn, lv.val));\n+    debug!{\"   pre-adaptation value: %s\", val_str(lv.bcx.ccx().tn, lv.val)};\n     let {lv, ty: e_ty} = adapt_borrowed_value(lv, e, e_ty);\n     let mut bcx = lv.bcx;\n     let mut val = lv.val;\n-    #debug(\"   adapted value: %s\", val_str(bcx.ccx().tn, val));\n+    debug!{\"   adapted value: %s\", val_str(bcx.ccx().tn, val)};\n \n     // finally, deal with the various modes\n     let arg_mode = ty::resolved_mode(ccx.tcx, arg.mode);\n@@ -2949,11 +2949,11 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     }\n \n     if !is_bot && arg.ty != e_ty || ty::type_has_params(arg.ty) {\n-        #debug(\"   casting from %s\", val_str(bcx.ccx().tn, val));\n+        debug!{\"   casting from %s\", val_str(bcx.ccx().tn, val)};\n         val = PointerCast(bcx, val, lldestty);\n     }\n \n-    #debug(\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val));\n+    debug!{\"--- trans_arg_expr passing %s\", val_str(bcx.ccx().tn, val)};\n     ret rslt(bcx, val);\n }\n \n@@ -2994,9 +2994,9 @@ fn adapt_borrowed_value(lv: lval_result,\n         let (base, len) = tvec::get_base_and_len(bcx, val, e_ty);\n         let p = alloca(bcx, T_struct(~[T_ptr(llunit_ty), ccx.int_type]));\n \n-        #debug(\"adapt_borrowed_value: adapting %s to %s\",\n+        debug!{\"adapt_borrowed_value: adapting %s to %s\",\n                val_str(bcx.ccx().tn, val),\n-               val_str(bcx.ccx().tn, p));\n+               val_str(bcx.ccx().tn, p)};\n \n         Store(bcx, base, GEPi(bcx, p, ~[0u, abi::slice_elt_base]));\n         Store(bcx, len, GEPi(bcx, p, ~[0u, abi::slice_elt_len]));\n@@ -3013,8 +3013,8 @@ fn adapt_borrowed_value(lv: lval_result,\n \n       _ {\n         bcx.tcx().sess.span_bug(\n-            e.span, #fmt[\"cannot borrow a value of type %s\",\n-                         ppaux::ty_to_str(bcx.tcx(), e_ty)]);\n+            e.span, fmt!{\"cannot borrow a value of type %s\",\n+                         ppaux::ty_to_str(bcx.tcx(), e_ty)});\n       }\n     }\n }\n@@ -3566,9 +3566,9 @@ fn lval_result_to_result(lv: lval_result, ty: ty::t) -> result {\n fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n                     root_loc: ValueRef, ty: ty::t) {\n \n-    #debug[\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n+    debug!{\"add_root_cleanup(bcx=%s, scope_id=%d, root_loc=%s, ty=%s)\",\n            bcx.to_str(), scope_id, val_str(bcx.ccx().tn, root_loc),\n-           ppaux::ty_to_str(bcx.ccx().tcx, ty)];\n+           ppaux::ty_to_str(bcx.ccx().tcx, ty)};\n \n     let bcx_scope = find_bcx_for_scope(bcx, scope_id);\n     add_clean_temp_mem(bcx_scope, root_loc, ty);\n@@ -3582,7 +3582,7 @@ fn add_root_cleanup(bcx: block, scope_id: ast::node_id,\n                 alt bcx_sid.parent {\n                   none {\n                     bcx.tcx().sess.bug(\n-                        #fmt[\"no enclosing scope with id %d\", scope_id]);\n+                        fmt!{\"no enclosing scope with id %d\", scope_id});\n                   }\n                   some(bcx_par) { bcx_par }\n                 }\n@@ -3607,16 +3607,16 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     ret alt bcx.ccx().maps.root_map.find({id:e.id, derefs:0u}) {\n       none { unrooted(bcx, e, dest) }\n       some(scope_id) {\n-        #debug[\"expression %d found in root map with scope %d\",\n-               e.id, scope_id];\n+        debug!{\"expression %d found in root map with scope %d\",\n+               e.id, scope_id};\n \n         let ty = expr_ty(bcx, e);\n         let root_loc = alloca_zeroed(bcx, type_of(bcx.ccx(), ty));\n         let bcx = unrooted(bcx, e, save_in(root_loc));\n \n         if !bcx.sess().no_asm_comments() {\n-            add_comment(bcx, #fmt[\"preserving until end of scope %d\",\n-                                  scope_id]);\n+            add_comment(bcx, fmt!{\"preserving until end of scope %d\",\n+                                  scope_id});\n         }\n \n         let _icx = bcx.insn_ctxt(~\"root_value_expr\");\n@@ -3668,9 +3668,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n           ast::expr_fn_block(decl, body, cap_clause) {\n             alt check ty::get(expr_ty(bcx, e)).struct {\n               ty::ty_fn({proto, _}) {\n-                #debug(\"translating fn_block %s with type %s\",\n+                debug!{\"translating fn_block %s with type %s\",\n                        expr_to_str(e),\n-                       ppaux::ty_to_str(tcx, expr_ty(bcx, e)));\n+                       ppaux::ty_to_str(tcx, expr_ty(bcx, e))};\n                 ret closure::trans_expr_fn(bcx, proto, decl, body,\n                                            e.id, cap_clause, none, dest);\n               }\n@@ -3793,13 +3793,13 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             let ptr_ty = expr_ty(bcx, e);\n             let ptr_ptr_val = alloc_ty(bcx, ptr_ty);\n \n-            #debug[\"ptr_ty = %s\", ppaux::ty_to_str(tcx, ptr_ty)];\n-            #debug[\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)];\n+            debug!{\"ptr_ty = %s\", ppaux::ty_to_str(tcx, ptr_ty)};\n+            debug!{\"ptr_ptr_val = %s\", val_str(ccx.tn, ptr_ptr_val)};\n \n             let void_ty = ty::mk_nil_ptr(tcx);\n             let llvoid_ty = type_of(ccx, void_ty);\n             let voidval = PointerCast(bcx, ptr_ptr_val, T_ptr(llvoid_ty));\n-            #debug[\"voidval = %s\", val_str(ccx.tn, voidval)];\n+            debug!{\"voidval = %s\", val_str(ccx.tn, voidval)};\n \n             let static_ti = get_tydesc(ccx, expr_ty(bcx, val));\n             lazily_emit_all_tydesc_glue(ccx, static_ti);\n@@ -3813,9 +3813,9 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                 arg_vals(~[lltydesc]),\n                 save_in(voidval));\n \n-            #debug[\"dest = %s\", dest_str(ccx, dest)];\n+            debug!{\"dest = %s\", dest_str(ccx, dest)};\n             let ptr_val = Load(bcx, ptr_ptr_val);\n-            #debug[\"ptr_val = %s\", val_str(ccx.tn, ptr_val)];\n+            debug!{\"ptr_val = %s\", val_str(ccx.tn, ptr_val)};\n             let bcx = trans_expr(bcx, val, save_in(ptr_val));\n             store_in_dest(bcx, ptr_val, dest)\n           }\n@@ -3832,8 +3832,8 @@ fn lval_to_dps(bcx: block, e: @ast::expr, dest: dest) -> block {\n     let ty = expr_ty(bcx, e);\n     let lv = trans_lval(bcx, e);\n     let last_use = (lv.kind == lv_owned && last_use_map.contains_key(e.id));\n-    #debug[\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n-           lv.kind as int];\n+    debug!{\"is last use (%s) = %b, %d\", expr_to_str(e), last_use,\n+           lv.kind as int};\n     lval_result_to_dps(lv, ty, last_use, dest)\n }\n \n@@ -4166,7 +4166,7 @@ fn init_local(bcx: block, local: @ast::local) -> block {\n \n fn trans_stmt(cx: block, s: ast::stmt) -> block {\n     let _icx = cx.insn_ctxt(~\"trans_stmt\");\n-    #debug[\"trans_stmt(%s)\", stmt_to_str(s)];\n+    debug!{\"trans_stmt(%s)\", stmt_to_str(s)};\n \n     if !cx.sess().no_asm_comments() {\n         add_span_comment(cx, s.span, stmt_to_str(s));\n@@ -4303,12 +4303,12 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n     let mut cur = bcx, bcx = bcx;\n     let is_lpad = leave == none;\n     loop {\n-        #debug[\"cleanup_and_leave: leaving %s\", cur.to_str()];\n+        debug!{\"cleanup_and_leave: leaving %s\", cur.to_str()};\n \n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, none,\n-                #fmt[\"cleanup_and_leave(%s)\", cur.to_str()]);\n+                fmt!{\"cleanup_and_leave(%s)\", cur.to_str()});\n         }\n \n         alt cur.kind {\n@@ -5076,8 +5076,8 @@ fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path,\n     let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n     ccx.item_symbols.insert(node_id, ps);\n \n-    #debug[\"register_fn_fuller created fn %s for item %d with path %s\",\n-           val_str(ccx.tn, llfn), node_id, ast_map::path_to_str(path)];\n+    debug!{\"register_fn_fuller created fn %s for item %d with path %s\",\n+           val_str(ccx.tn, llfn), node_id, ast_map::path_to_str(path)};\n \n     let is_main = is_main_name(path) && !ccx.sess.building_library;\n     if is_main { create_main_wrapper(ccx, sp, llfn, node_type); }\n@@ -5218,8 +5218,8 @@ fn get_dtor_symbol(ccx: @crate_ctxt, path: path, id: ast::node_id,\n                mono_ty)\n          }\n          none {\n-             ccx.sess.bug(#fmt(\"get_dtor_symbol: not monomorphizing and \\\n-               couldn't find a symbol for dtor %?\", path));\n+             ccx.sess.bug(fmt!{\"get_dtor_symbol: not monomorphizing and \\\n+               couldn't find a symbol for dtor %?\", path});\n          }\n        }\n      }\n@@ -5436,7 +5436,7 @@ fn trap(bcx: block) {\n \n fn push_rtcall(ccx: @crate_ctxt, name: ~str, did: ast::def_id) {\n     if ccx.rtcalls.contains_key(name) {\n-        fail #fmt(\"multiple definitions for runtime call %s\", name);\n+        fail fmt!{\"multiple definitions for runtime call %s\", name};\n     }\n     ccx.rtcalls.insert(name, did);\n }\n@@ -5506,7 +5506,7 @@ fn gather_rtcalls(ccx: @crate_ctxt, crate: @ast::crate) {\n         ~[~\"exchange_free\", ~\"exchange_malloc\", ~\"fail\", ~\"free\", ~\"malloc\"];\n     for vec::each(expected_rtcalls) |name| {\n         if !ccx.rtcalls.contains_key(name) {\n-            fail #fmt(\"no definition for runtime call %s\", name);\n+            fail fmt!{\"no definition for runtime call %s\", name};\n         }\n     }\n }\n@@ -5777,25 +5777,25 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     write_metadata(ccx, crate);\n     if ccx.sess.trans_stats() {\n         io::println(~\"--- trans stats ---\");\n-        io::println(#fmt(\"n_static_tydescs: %u\",\n-                         ccx.stats.n_static_tydescs));\n-        io::println(#fmt(\"n_glues_created: %u\",\n-                         ccx.stats.n_glues_created));\n-        io::println(#fmt(\"n_null_glues: %u\", ccx.stats.n_null_glues));\n-        io::println(#fmt(\"n_real_glues: %u\", ccx.stats.n_real_glues));\n+        io::println(fmt!{\"n_static_tydescs: %u\",\n+                         ccx.stats.n_static_tydescs});\n+        io::println(fmt!{\"n_glues_created: %u\",\n+                         ccx.stats.n_glues_created});\n+        io::println(fmt!{\"n_null_glues: %u\", ccx.stats.n_null_glues});\n+        io::println(fmt!{\"n_real_glues: %u\", ccx.stats.n_real_glues});\n \n         // FIXME (#2280): this temporary shouldn't be\n         // necessary, but seems to be, for borrowing.\n         let times = copy *ccx.stats.fn_times;\n         for vec::each(times) |timing| {\n-            io::println(#fmt(\"time: %s took %d ms\", timing.ident,\n-                             timing.time));\n+            io::println(fmt!{\"time: %s took %d ms\", timing.ident,\n+                             timing.time});\n         }\n     }\n \n     if ccx.sess.count_llvm_insns() {\n         for ccx.stats.llvm_insns.each |k, v| {\n-            io::println(#fmt(\"%-7u %s\", v, k));\n+            io::println(fmt!{\"%-7u %s\", v, k});\n         }\n     }\n     ret (llmod, link_meta);"}, {"sha": "5fa90ecece2c712ba87967cb8a38b588b0494ce7", "filename": "src/rustc/middle/trans/build.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -139,10 +139,10 @@ fn Invoke(cx: block, Fn: ValueRef, Args: ~[ValueRef],\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    #debug[\"Invoke(%s with arguments (%s))\",\n+    debug!{\"Invoke(%s with arguments (%s))\",\n            val_str(cx.ccx().tn, Fn),\n            str::connect(vec::map(Args, |a| val_str(cx.ccx().tn, a)),\n-                        ~\", \")];\n+                        ~\", \")};\n     unsafe {\n         count_insn(cx, ~\"invoke\");\n         llvm::LLVMBuildInvoke(B(cx), Fn, vec::unsafe::to_ptr(Args),\n@@ -410,9 +410,9 @@ fn Load(cx: block, PointerVal: ValueRef) -> ValueRef {\n \n fn Store(cx: block, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { ret; }\n-    #debug[\"Store %s -> %s\",\n+    debug!{\"Store %s -> %s\",\n            val_str(cx.ccx().tn, Val),\n-           val_str(cx.ccx().tn, Ptr)];\n+           val_str(cx.ccx().tn, Ptr)};\n     count_insn(cx, ~\"store\");\n     llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n@@ -670,9 +670,9 @@ fn Call(cx: block, Fn: ValueRef, Args: ~[ValueRef]) -> ValueRef {\n     unsafe {\n         count_insn(cx, ~\"call\");\n \n-        #debug[\"Call(Fn=%s, Args=%?)\",\n+        debug!{\"Call(Fn=%s, Args=%?)\",\n                val_str(cx.ccx().tn, Fn),\n-               Args.map(|arg| val_str(cx.ccx().tn, arg))];\n+               Args.map(|arg| val_str(cx.ccx().tn, arg))};\n \n         ret llvm::LLVMBuildCall(B(cx), Fn, vec::unsafe::to_ptr(Args),\n                                 Args.len() as c_uint, noname());"}, {"sha": "c216b890ace80dedb42180438df5456f60a98347", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -102,12 +102,12 @@ enum environment_value {\n \n fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> ~str {\n     alt ev {\n-      env_copy(v, t, lk) { #fmt(\"copy(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)) }\n-      env_move(v, t, lk) { #fmt(\"move(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)) }\n-      env_ref(v, t, lk) { #fmt(\"ref(%s,%s)\", val_str(ccx.tn, v),\n-                                ty_to_str(ccx.tcx, t)) }\n+      env_copy(v, t, lk) { fmt!{\"copy(%s,%s)\", val_str(ccx.tn, v),\n+                                ty_to_str(ccx.tcx, t)} }\n+      env_move(v, t, lk) { fmt!{\"move(%s,%s)\", val_str(ccx.tn, v),\n+                                ty_to_str(ccx.tcx, t)} }\n+      env_ref(v, t, lk) { fmt!{\"ref(%s,%s)\", val_str(ccx.tn, v),\n+                                ty_to_str(ccx.tcx, t)} }\n     }\n }\n \n@@ -131,7 +131,7 @@ fn mk_closure_tys(tcx: ty::ctxt,\n         });\n     }\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    #debug[\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)];\n+    debug!{\"cdata_ty=%s\", ty_to_str(tcx, cdata_ty)};\n     ret cdata_ty;\n }\n \n@@ -201,16 +201,16 @@ fn store_environment(bcx: block,\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mutbl:ast::m_imm});\n \n     let llbox = PointerCast(bcx, llbox, type_of(ccx, cboxptr_ty));\n-    #debug[\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)];\n+    debug!{\"tuplify_box_ty = %s\", ty_to_str(tcx, cbox_ty)};\n \n     // Copy expr values into boxed bindings.\n     let mut bcx = bcx;\n     do vec::iteri(bound_values) |i, bv| {\n-        #debug[\"Copy %s into closure\", ev_to_str(ccx, bv)];\n+        debug!{\"Copy %s into closure\", ev_to_str(ccx, bv)};\n \n         if !ccx.sess.no_asm_comments() {\n-            add_comment(bcx, #fmt(\"Copy %s into closure\",\n-                                  ev_to_str(ccx, bv)));\n+            add_comment(bcx, fmt!{\"Copy %s into closure\",\n+                                  ev_to_str(ccx, bv)});\n         }\n \n         let bound_data = GEPi(bcx, llbox,\n@@ -231,9 +231,9 @@ fn store_environment(bcx: block,\n             bcx = move_val(bcx, INIT, bound_data, src, ty);\n           }\n           env_ref(val, ty, lv_owned) {\n-            #debug[\"> storing %s into %s\",\n+            debug!{\"> storing %s into %s\",\n                    val_str(bcx.ccx().tn, val),\n-                   val_str(bcx.ccx().tn, bound_data)];\n+                   val_str(bcx.ccx().tn, bound_data)};\n             Store(bcx, val, bound_data);\n           }\n           env_ref(val, ty, lv_owned_imm) {\n@@ -265,11 +265,11 @@ fn build_closure(bcx0: block,\n \n     // Package up the captured upvars\n     do vec::iter(cap_vars) |cap_var| {\n-        #debug[\"Building closure: captured variable %?\", cap_var];\n+        debug!{\"Building closure: captured variable %?\", cap_var};\n         let lv = trans_local_var(bcx, cap_var.def);\n         let nid = ast_util::def_id_of_def(cap_var.def).node;\n-        #debug[\"Node id is %s\",\n-               syntax::ast_map::node_id_to_str(bcx.ccx().tcx.items, nid)];\n+        debug!{\"Node id is %s\",\n+               syntax::ast_map::node_id_to_str(bcx.ccx().tcx.items, nid)};\n         let mut ty = node_id_type(bcx, nid);\n         alt cap_var.mode {\n           capture::cap_ref {"}, {"sha": "bfb7676024ae4dee39c6c148dd8b158a16fab941", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -248,9 +248,9 @@ fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n \n fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n-    #debug[\"add_clean(%s, %s, %s)\",\n+    debug!{\"add_clean(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty)];\n+           ty_to_str(cx.ccx().tcx, ty)};\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups, clean(|a| base::drop_ty(a, val, ty),\n@@ -260,9 +260,9 @@ fn add_clean(cx: block, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n-    #debug[\"add_clean_temp(%s, %s, %s)\",\n+    debug!{\"add_clean_temp(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty)];\n+           ty_to_str(cx.ccx().tcx, ty)};\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     fn do_drop(bcx: block, val: ValueRef, ty: ty::t) ->\n        block {\n@@ -280,9 +280,9 @@ fn add_clean_temp(cx: block, val: ValueRef, ty: ty::t) {\n }\n fn add_clean_temp_mem(cx: block, val: ValueRef, ty: ty::t) {\n     if !ty::type_needs_drop(cx.tcx(), ty) { ret; }\n-    #debug[\"add_clean_temp_mem(%s, %s, %s)\",\n+    debug!{\"add_clean_temp_mem(%s, %s, %s)\",\n            cx.to_str(), val_str(cx.ccx().tn, val),\n-           ty_to_str(cx.ccx().tcx, ty)];\n+           ty_to_str(cx.ccx().tcx, ty)};\n     let cleanup_type = cleanup_type(cx.tcx(), ty);\n     do in_scope_cx(cx) |info| {\n         vec::push(info.cleanups,\n@@ -459,8 +459,8 @@ fn in_scope_cx(cx: block, f: fn(scope_info)) {\n fn block_parent(cx: block) -> block {\n     alt cx.parent {\n       some(b) { b }\n-      none    { cx.sess().bug(#fmt(\"block_parent called on root block %?\",\n-                                   cx)); }\n+      none    { cx.sess().bug(fmt!{\"block_parent called on root block %?\",\n+                                   cx}); }\n     }\n }\n \n@@ -480,10 +480,10 @@ impl bcx_cxs for block {\n     fn to_str() -> ~str {\n         alt self.node_info {\n           some(node_info) {\n-            #fmt[\"[block %d]\", node_info.id]\n+            fmt!{\"[block %d]\", node_info.id}\n           }\n           none {\n-            #fmt[\"[block %x]\", ptr::addr_of(*self) as uint]\n+            fmt!{\"[block %x]\", ptr::addr_of(*self) as uint}\n           }\n         }\n     }\n@@ -997,8 +997,8 @@ fn field_idx_strict(cx: ty::ctxt, sp: span, ident: ast::ident,\n                     fields: ~[ty::field])\n     -> uint {\n     alt ty::field_idx(ident, fields) {\n-       none { cx.sess.span_bug(sp, #fmt(\"base expr doesn't appear to \\\n-                 have a field named %s\", *ident)); }\n+       none { cx.sess.span_bug(sp, fmt!{\"base expr doesn't appear to \\\n+                 have a field named %s\", *ident}); }\n        some(i) { i }\n     }\n }"}, {"sha": "3197dc0088463e4db49a1f824abd28d003fa052b", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -178,7 +178,7 @@ fn create_compile_unit(cx: @crate_ctxt)\n                          lli32(DW_LANG_RUST),\n                          llstr(crate_name),\n                          llstr(work_dir),\n-                         llstr(#env[\"CFG_VERSION\"]),\n+                         llstr(env!{\"CFG_VERSION\"}),\n                          lli1(true), // deprecated: main compile unit\n                          lli1(cx.sess.opts.optimize != 0u),\n                          llstr(~\"\"), // flags (???)\n@@ -734,7 +734,7 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let cx = fcx.ccx;\n     let dbg_cx = option::get(cx.dbg_cx);\n \n-    #debug(\"~~\");\n+    debug!{\"~~\"};\n     log(debug, fcx.id);\n \n     let sp = option::get(fcx.span);"}, {"sha": "5313cee2323b5e642f03f01b7d01c40a47819bba", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -937,10 +937,10 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n               ast_map::node_expr(e) { e.span }\n             };\n             ccx.sess.span_fatal(\n-                sp, #fmt(\"reinterpret_cast called on types \\\n+                sp, fmt!{\"reinterpret_cast called on types \\\n                           with different size: %s (%u) to %s (%u)\",\n                          ty_to_str(ccx.tcx, tp_ty), tp_sz,\n-                         ty_to_str(ccx.tcx, substs.tys[1]), out_sz));\n+                         ty_to_str(ccx.tcx, substs.tys[1]), out_sz});\n         }\n         if !ty::type_is_nil(substs.tys[1]) {\n             let cast = PointerCast(bcx, get_param(decl, first_real_arg),"}, {"sha": "0250b17f6fe1028810f77701abcc2e4ec78a548f", "filename": "src/rustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -177,8 +177,8 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n                 some(d) {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n-                none      { cx.tcx.sess.span_bug(e.span, #fmt(\"Unbound node \\\n-                  id %? while traversing %s\", e.id, expr_to_str(e))); }\n+                none      { cx.tcx.sess.span_bug(e.span, fmt!{\"Unbound node \\\n+                  id %? while traversing %s\", e.id, expr_to_str(e)}); }\n             }\n           }\n           expr_field(_, _, _) {"}, {"sha": "82cb96f660d2b748736eb47373272e9f230c0e57", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -62,15 +62,15 @@ impl methods for reflector {\n         let get_lval = |bcx| {\n             let callee =\n                 impl::trans_trait_callee(bcx, v, mth_ty, mth_idx);\n-            #debug(\"calling mth ty %s, lltype %s\",\n+            debug!{\"calling mth ty %s, lltype %s\",\n                    ty_to_str(bcx.ccx().tcx, mth_ty),\n-                   val_str(bcx.ccx().tn, callee.val));\n+                   val_str(bcx.ccx().tn, callee.val)};\n             callee\n         };\n-        #debug(\"passing %u args:\", vec::len(args));\n+        debug!{\"passing %u args:\", vec::len(args)};\n         let bcx = self.bcx;\n         for args.eachi |i, a| {\n-            #debug(\"arg %u: %s\", i, val_str(bcx.ccx().tn, a));\n+            debug!{\"arg %u: %s\", i, val_str(bcx.ccx().tn, a)};\n         }\n         let d = empty_dest_cell();\n         let bcx =\n@@ -111,8 +111,8 @@ impl methods for reflector {\n     fn visit_ty(t: ty::t) {\n \n         let bcx = self.bcx;\n-        #debug(\"reflect::visit_ty %s\",\n-               ty_to_str(bcx.ccx().tcx, t));\n+        debug!{\"reflect::visit_ty %s\",\n+               ty_to_str(bcx.ccx().tcx, t)};\n \n         alt ty::get(t).struct {\n           ty::ty_bot { self.leaf(~\"bot\") }"}, {"sha": "bfd2f18bac95c8f8613388c16fd0fd2a095673e7", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -189,9 +189,9 @@ fn trans_evec(bcx: block, args: ~[@ast::expr],\n \n     // Store the individual elements.\n     let mut i = 0u, temp_cleanups = ~[val];\n-    #debug(\"trans_evec: v: %s, dataptr: %s\",\n+    debug!{\"trans_evec: v: %s, dataptr: %s\",\n            val_str(ccx.tn, val),\n-           val_str(ccx.tn, dataptr));\n+           val_str(ccx.tn, dataptr)};\n     for vec::each(args) |e| {\n         let lleltptr = InBoundsGEP(bcx, dataptr, ~[C_uint(ccx, i)]);\n         bcx = base::trans_expr_save_in(bcx, e, lleltptr);\n@@ -259,7 +259,7 @@ fn get_base_and_len(cx: block, v: ValueRef, e_ty: ty::t)\n         (base, len)\n       }\n       ty::vstore_uniq | ty::vstore_box {\n-        #debug[\"get_base_and_len: %s\", val_str(ccx.tn, v)];\n+        debug!{\"get_base_and_len: %s\", val_str(ccx.tn, v)};\n         let body = tvec::get_bodyptr(cx, v);\n         (tvec::get_dataptr(cx, body), tvec::get_fill(cx, body))\n       }\n@@ -276,13 +276,13 @@ fn trans_estr(bcx: block, s: @~str, vstore: ast::vstore,\n       ast::vstore_fixed(_)\n       {\n         // \"hello\"/_  =>  \"hello\"/5  =>  ~[i8 x 6] in llvm\n-        #debug(\"trans_estr: fixed: %s\", *s);\n+        debug!{\"trans_estr: fixed: %s\", *s};\n         C_postr(*s)\n       }\n \n       ast::vstore_slice(_) {\n         // \"hello\"  =>  (*i8, 6u) in llvm\n-        #debug(\"trans_estr: slice '%s'\", *s);\n+        debug!{\"trans_estr: slice '%s'\", *s};\n         C_estr_slice(ccx, *s)\n       }\n \n@@ -303,7 +303,7 @@ fn trans_estr(bcx: block, s: @~str, vstore: ast::vstore,\n       }\n     };\n \n-    #debug(\"trans_estr: type: %s\", val_str(ccx.tn, c));\n+    debug!{\"trans_estr: type: %s\", val_str(ccx.tn, c)};\n     base::store_in_dest(bcx, c, dest)\n }\n "}, {"sha": "d06bf94f5e185a61db928d988d296086a097a437", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -66,7 +66,7 @@ fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n }\n \n fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n-    #debug(\"type_of %?: %?\", t, ty::get(t));\n+    debug!{\"type_of %?: %?\", t, ty::get(t)};\n \n     // Check the cache.\n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n@@ -197,7 +197,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n \n-    #debug(\"type_of_enum %?: %?\", t, ty::get(t));\n+    debug!{\"type_of_enum %?: %?\", t, ty::get(t)};\n \n     // Every enum type has a unique name. When we find our roots\n     // for GC and unwinding we will use this name to rediscover\n@@ -233,7 +233,7 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n         (~\"class\", did, substs.tps)\n       }\n     };\n-    ret #fmt(\n+    ret fmt!{\n         \"%s %s[#%d]\",\n         name,\n         util::ppaux::parameterized(\n@@ -242,7 +242,7 @@ fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n             none,\n             tps),\n         did.crate\n-    );\n+    };\n }\n \n fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {"}, {"sha": "6bb19724afe40c84dc45dadf916ba04b62ddd9c7", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -61,8 +61,8 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     }\n     let map_node = alt ccx.tcx.items.find(fn_id_loc.node) {\n         some(x) { x }\n-        none    { ccx.sess.bug(#fmt(\"type_uses_for: unbound item ID %?\",\n-                                    fn_id_loc)); }\n+        none    { ccx.sess.bug(fmt!{\"type_uses_for: unbound item ID %?\",\n+                                    fn_id_loc}); }\n     };\n     alt check map_node {\n       ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |"}, {"sha": "27379552a8c8efb3346f2de15fa7c8dd8ac26867", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -40,8 +40,8 @@ fn duplicate(bcx: block, v: ValueRef, t: ty::t) -> result {\n     let src_box = v;\n     let src_body = opaque_box_body(bcx, content_ty, src_box);\n     let src_body = load_if_immediate(bcx, src_body, content_ty);\n-    #debug(\"ST: %?\", val_str(bcx.ccx().tn, src_body));\n-    #debug(\"DT: %?\", val_str(bcx.ccx().tn, dst_body));\n+    debug!{\"ST: %?\", val_str(bcx.ccx().tn, src_body)};\n+    debug!{\"DT: %?\", val_str(bcx.ccx().tn, dst_body)};\n     let bcx = copy_val(bcx, INIT, dst_body, src_body, content_ty);\n \n     let src_tydesc_ptr = GEPi(bcx, src_box,"}, {"sha": "f4b2e5e6442e9bd6c1c406b593091878ba074d59", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,8 +16,8 @@ fn collect_ids_block(b: blk, rs: @mut ~[node_id]) {\n fn collect_ids_stmt(s: @stmt, rs: @mut ~[node_id]) {\n     alt s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n-        #debug[\"node_id %s\", int::str(id)];\n-        #debug[\"%s\", stmt_to_str(*s)];\n+        debug!{\"node_id %s\", int::str(id)};\n+        debug!{\"%s\", stmt_to_str(*s)};\n         vec::push(*rs, id);\n       }\n     }"}, {"sha": "0f8185a0ee91a98cabfc09dc69d9051657d5d81f", "filename": "src/rustc/middle/tstate/auxiliary.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -49,10 +49,10 @@ fn comma_str(args: ~[@constr_arg_use]) -> ~str {\n }\n \n fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> ~str {\n-    ret #fmt(\"%s(%s) - arising from %s\",\n+    ret fmt!{\"%s(%s) - arising from %s\",\n              path_to_str(c.node.path),\n              comma_str(c.node.args),\n-             codemap::span_to_str(c.span, tcx.sess.codemap));\n+             codemap::span_to_str(c.span, tcx.sess.codemap)};\n }\n \n fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> ~str {\n@@ -110,36 +110,36 @@ fn log_cond_err(v: ~[uint]) { log(error, tos(v)); }\n fn log_pp(pp: pre_and_post) {\n     let p1 = pp.precondition.to_vec();\n     let p2 = pp.postcondition.to_vec();\n-    #debug(\"pre:\");\n+    debug!{\"pre:\"};\n     log_cond(p1);\n-    #debug(\"post:\");\n+    debug!{\"post:\"};\n     log_cond(p2);\n }\n \n fn log_pp_err(pp: pre_and_post) {\n     let p1 = pp.precondition.to_vec();\n     let p2 = pp.postcondition.to_vec();\n-    #error(\"pre:\");\n+    error!{\"pre:\"};\n     log_cond_err(p1);\n-    #error(\"post:\");\n+    error!{\"post:\"};\n     log_cond_err(p2);\n }\n \n fn log_states(pp: pre_and_post_state) {\n     let p1 = pp.prestate.to_vec();\n     let p2 = pp.poststate.to_vec();\n-    #debug(\"prestate:\");\n+    debug!{\"prestate:\"};\n     log_cond(p1);\n-    #debug(\"poststate:\");\n+    debug!{\"poststate:\"};\n     log_cond(p2);\n }\n \n fn log_states_err(pp: pre_and_post_state) {\n     let p1 = pp.prestate.to_vec();\n     let p2 = pp.poststate.to_vec();\n-    #error(\"prestate:\");\n+    error!{\"prestate:\"};\n     log_cond_err(p1);\n-    #error(\"poststate:\");\n+    error!{\"poststate:\"};\n     log_cond_err(p2);\n }\n \n@@ -263,20 +263,20 @@ fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option<ts_ann> {\n fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n     alt get_ts_ann(ccx, id) {\n       none {\n-        #error(\"node_id_to_ts_ann: no ts_ann for node_id %d\", id);\n+        error!{\"node_id_to_ts_ann: no ts_ann for node_id %d\", id};\n         fail;\n       }\n       some(tt) { ret tt; }\n     }\n }\n \n fn node_id_to_poststate(ccx: crate_ctxt, id: node_id) -> poststate {\n-    #debug(\"node_id_to_poststate\");\n+    debug!{\"node_id_to_poststate\"};\n     ret node_id_to_ts_ann(ccx, id).states.poststate;\n }\n \n fn stmt_to_ann(ccx: crate_ctxt, s: stmt) -> ts_ann {\n-    #debug(\"stmt_to_ann\");\n+    debug!{\"stmt_to_ann\"};\n     alt s.node {\n       stmt_decl(_, id) | stmt_expr(_, id) | stmt_semi(_, id) {\n         ret node_id_to_ts_ann(ccx, id);\n@@ -287,14 +287,14 @@ fn stmt_to_ann(ccx: crate_ctxt, s: stmt) -> ts_ann {\n \n /* fails if e has no annotation */\n fn expr_states(ccx: crate_ctxt, e: @expr) -> pre_and_post_state {\n-    #debug(\"expr_states\");\n+    debug!{\"expr_states\"};\n     ret node_id_to_ts_ann(ccx, e.id).states;\n }\n \n \n /* fails if e has no annotation */\n fn expr_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n-    #debug(\"expr_pp\");\n+    debug!{\"expr_pp\"};\n     ret node_id_to_ts_ann(ccx, e.id).conditions;\n }\n \n@@ -305,7 +305,7 @@ fn stmt_pp(ccx: crate_ctxt, s: stmt) -> pre_and_post {\n \n /* fails if b has no annotation */\n fn block_pp(ccx: crate_ctxt, b: blk) -> pre_and_post {\n-    #debug(\"block_pp\");\n+    debug!{\"block_pp\"};\n     ret node_id_to_ts_ann(ccx, b.node.id).conditions;\n }\n \n@@ -320,7 +320,7 @@ fn clear_precond(ccx: crate_ctxt, id: node_id) {\n }\n \n fn block_states(ccx: crate_ctxt, b: blk) -> pre_and_post_state {\n-    #debug(\"block_states\");\n+    debug!{\"block_states\"};\n     ret node_id_to_ts_ann(ccx, b.node.id).states;\n }\n \n@@ -381,43 +381,43 @@ fn block_poststate(ccx: crate_ctxt, b: blk) -> poststate {\n }\n \n fn set_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n-    #debug(\"set_prestate_ann\");\n+    debug!{\"set_prestate_ann\"};\n     ret set_prestate(node_id_to_ts_ann(ccx, id), pre);\n }\n \n fn extend_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n-    #debug(\"extend_prestate_ann\");\n+    debug!{\"extend_prestate_ann\"};\n     ret extend_prestate(node_id_to_ts_ann(ccx, id).states.prestate, pre);\n }\n \n fn set_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) -> bool {\n-    #debug(\"set_poststate_ann\");\n+    debug!{\"set_poststate_ann\"};\n     ret set_poststate(node_id_to_ts_ann(ccx, id), post);\n }\n \n fn extend_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) ->\n    bool {\n-    #debug(\"extend_poststate_ann\");\n+    debug!{\"extend_poststate_ann\"};\n     ret extend_poststate(node_id_to_ts_ann(ccx, id).states.poststate, post);\n }\n \n fn set_pre_and_post(ccx: crate_ctxt, id: node_id, pre: precond,\n                     post: postcond) {\n-    #debug(\"set_pre_and_post\");\n+    debug!{\"set_pre_and_post\"};\n     let tt = node_id_to_ts_ann(ccx, id);\n     set_precondition(tt, pre);\n     set_postcondition(tt, post);\n }\n \n fn copy_pre_post(ccx: crate_ctxt, id: node_id, sub: @expr) {\n-    #debug(\"set_pre_and_post\");\n+    debug!{\"set_pre_and_post\"};\n     let p = expr_pp(ccx, sub);\n     copy_pre_post_(ccx, id, p.precondition, p.postcondition);\n }\n \n fn copy_pre_post_(ccx: crate_ctxt, id: node_id, pre: prestate,\n                   post: poststate) {\n-    #debug(\"set_pre_and_post\");\n+    debug!{\"set_pre_and_post\"};\n     let tt = node_id_to_ts_ann(ccx, id);\n     set_precondition(tt, pre);\n     set_postcondition(tt, post);\n@@ -460,7 +460,7 @@ fn constraints_expr(cx: ty::ctxt, e: @expr) -> ~[@ty::constr] {\n fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n     alt cx.def_map.find(id) {\n       none {\n-        #error(\"node_id_to_def: node_id %d has no def\", id);\n+        error!{\"node_id_to_def: node_id %d has no def\", id};\n         fail;\n       }\n       some(d) { ret d; }\n@@ -498,8 +498,8 @@ fn constraints(fcx: fn_ctxt) -> ~[norm_constraint] {\n // should freeze it at some earlier point.\n fn match_args(fcx: fn_ctxt, occs: @dvec<pred_args>,\n               occ: ~[@constr_arg_use]) -> uint {\n-    #debug(\"match_args: looking at %s\",\n-           constr_args_to_str(fn@(i: inst) -> ~str { ret *i.ident; }, occ));\n+    debug!{\"match_args: looking at %s\",\n+           constr_args_to_str(fn@(i: inst) -> ~str { ret *i.ident; }, occ)};\n     for (*occs).each |pd| {\n         log(debug,\n                  ~\"match_args: candidate \" + pred_args_to_str(pd));\n@@ -530,8 +530,8 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n           }\n           some(what) {\n               tcx.sess.span_bug(e.span,\n-                 #fmt(\"exprs_to_constr_args: non-local variable %? \\\n-                                     as pred arg\", what));\n+                 fmt!{\"exprs_to_constr_args: non-local variable %? \\\n+                                     as pred arg\", what});\n           }\n           none {\n               tcx.sess.span_bug(e.span,\n@@ -824,9 +824,9 @@ fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n     do option::iter(d) |d_id| {\n         do for_constraints_mentioning(fcx, d_id) |c| {\n-                #debug(\"clearing constraint %u %s\",\n+                debug!{\"clearing constraint %u %s\",\n                        c.bit_num,\n-                       constraint_to_str(fcx.ccx.tcx, c.c));\n+                       constraint_to_str(fcx.ccx.tcx, c.c)};\n                 clear_in_postcond(c.bit_num,\n                                   node_id_to_ts_ann(fcx.ccx,\n                                                     parent_exp).conditions);"}, {"sha": "f1dc6a566af245eb4e87a2800a77e576a0e74695", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -46,11 +46,11 @@ fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     let prec: precond = ann_precond(a);\n     let pres: prestate = ann_prestate(a);\n \n-    #debug(\"check_states_stmt:\");\n+    debug!{\"check_states_stmt:\"};\n     log(debug, print::pprust::stmt_to_str(*s));\n-    #debug(\"prec = \");\n+    debug!{\"prec = \"};\n     log_tritv(fcx, prec);\n-    #debug(\"pres = \");\n+    debug!{\"pres = \"};\n     log_tritv(fcx, pres);\n \n     if !implies(pres, prec) {"}, {"sha": "448b7a5231f5e65c5376b1f79d24eaa6d45e2c62", "filename": "src/rustc/middle/tstate/collect_locals.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -87,15 +87,15 @@ fn contains_constrained_calls(tcx: ty::ctxt, body: blk) -> bool {\n \n     fn visit_expr(e: @expr, &&cx: cx, v: visit::vt<cx>) {\n         import syntax::print::pprust;\n-        #debug(\"visiting %?\", pprust::expr_to_str(e));\n+        debug!{\"visiting %?\", pprust::expr_to_str(e)};\n \n         visit::visit_expr(e, cx, v);\n \n         if constraints_expr(cx.tcx, e).is_not_empty() {\n-            #debug(\"has constraints\");\n+            debug!{\"has constraints\"};\n             cx.has = true;\n         } else {\n-            #debug(\"has not constraints\");\n+            debug!{\"has not constraints\"};\n         }\n     }\n }\n@@ -140,7 +140,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n          used_vars: v,\n          ignore: ignore};\n     ccx.fm.insert(id, rslt);\n-    #debug(\"%s has %u constraints\", *name, num_constraints(rslt));\n+    debug!{\"%s has %u constraints\", *name, num_constraints(rslt)};\n }\n \n "}, {"sha": "08f0736c1dac95f6ecb3ceba772deac56c27989f", "filename": "src/rustc/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,12 +16,12 @@ import driver::session::session;\n import std::map::hashmap;\n \n fn find_pre_post_mod(_m: _mod) -> _mod {\n-    #debug(\"implement find_pre_post_mod!\");\n+    debug!{\"implement find_pre_post_mod!\"};\n     fail;\n }\n \n fn find_pre_post_foreign_mod(_m: foreign_mod) -> foreign_mod {\n-    #debug(\"implement find_pre_post_foreign_mod\");\n+    debug!{\"implement find_pre_post_foreign_mod\"};\n     fail;\n }\n \n@@ -66,7 +66,7 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n    be the union of all postconditions for <args> */\n fn find_pre_post_exprs(fcx: fn_ctxt, args: ~[@expr], id: node_id) {\n     if vec::len::<@expr>(args) > 0u {\n-        #debug[\"find_pre_post_exprs: oper = %s\", expr_to_str(args[0])];\n+        debug!{\"find_pre_post_exprs: oper = %s\", expr_to_str(args[0])};\n     }\n     fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n     for args.each |e| { do_one(fcx, e); }\n@@ -452,7 +452,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n }\n \n fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n-    #debug[\"stmt = %s\", stmt_to_str(s)];\n+    debug!{\"stmt = %s\", stmt_to_str(s)};\n     alt s.node {\n       stmt_decl(adecl, id) {\n         alt adecl.node {"}, {"sha": "9c4285774f771a5db95a3bb6eddd16ac59c9c83c", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -174,9 +174,9 @@ fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n     // bug)\n     if vec::len(bs) != vec::len(ops) {\n         fcx.ccx.tcx.sess.span_bug(a.span,\n-                                  #fmt[\"mismatched arg lengths: \\\n+                                  fmt!{\"mismatched arg lengths: \\\n                                         %u exprs vs. %u ops\",\n-                                       vec::len(bs), vec::len(ops)]);\n+                                       vec::len(bs), vec::len(ops)});\n     }\n     ret find_pre_post_state_exprs(fcx, pres, id, ops,\n                                    bs, cf) || changed;\n@@ -299,7 +299,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n                                       return_val);\n       }\n       expr_call(operator, operands, _) {\n-        #debug[\"hey it's a call: %s\", expr_to_str(e)];\n+        debug!{\"hey it's a call: %s\", expr_to_str(e)};\n         ret find_pre_post_state_call(fcx, pres, operator, e.id,\n                                      callee_arg_init_ops(fcx, operator.id),\n                                      operands,\n@@ -505,10 +505,10 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n     let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n \n-    #debug[\"[ %s ]\", *fcx.name];\n-    #debug[\"*At beginning: stmt = %s\", stmt_to_str(*s)];\n-    #debug[\"*prestate = %s\", stmt_ann.states.prestate.to_str()];\n-    #debug[\"*poststate = %s\", stmt_ann.states.prestate.to_str()];\n+    debug!{\"[ %s ]\", *fcx.name};\n+    debug!{\"*At beginning: stmt = %s\", stmt_to_str(*s)};\n+    debug!{\"*prestate = %s\", stmt_ann.states.prestate.to_str()};\n+    debug!{\"*poststate = %s\", stmt_ann.states.prestate.to_str()};\n \n     alt s.node {\n       stmt_decl(adecl, id) {\n@@ -524,10 +524,10 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n             let mut changed =\n                 set_poststate(stmt_ann, c_and_p.post) | c_and_p.changed;\n \n-            #debug[\"Summary: stmt = %s\", stmt_to_str(*s)];\n-            #debug[\"prestate = %s\", stmt_ann.states.prestate.to_str()];\n-            #debug[\"poststate = %s\", stmt_ann.states.poststate.to_str()];\n-            #debug[\"changed = %s\", bool::to_str(changed)];\n+            debug!{\"Summary: stmt = %s\", stmt_to_str(*s)};\n+            debug!{\"prestate = %s\", stmt_ann.states.prestate.to_str()};\n+            debug!{\"poststate = %s\", stmt_ann.states.poststate.to_str()};\n+            debug!{\"changed = %s\", bool::to_str(changed)};\n \n             ret changed;\n           }\n@@ -544,10 +544,10 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n                 set_poststate(stmt_ann, expr_poststate(fcx.ccx, ex));\n \n \n-        #debug[\"Finally: %s\", stmt_to_str(*s)];\n-        #debug[\"prestate = %s\", stmt_ann.states.prestate.to_str()];\n-        #debug[\"poststate = %s\", stmt_ann.states.poststate.to_str()];\n-        #debug[\"changed = %s\", bool::to_str(changed)];\n+        debug!{\"Finally: %s\", stmt_to_str(*s)};\n+        debug!{\"prestate = %s\", stmt_ann.states.prestate.to_str()};\n+        debug!{\"poststate = %s\", stmt_ann.states.poststate.to_str()};\n+        debug!{\"changed = %s\", bool::to_str(changed)};\n \n         ret changed;\n       }\n@@ -602,7 +602,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n     let mut changed = find_pre_post_state_block(fcx, block_pre, f_body);\n \n     /*\n-        #error(\"find_pre_post_state_fn\");\n+        error!{\"find_pre_post_state_fn\"};\n         log(error, changed);\n         fcx.ccx.tcx.sess.span_note(f_body.span, fcx.name);\n     */"}, {"sha": "cb0550550910b1026e86c7c99aaa946d8fde9570", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -483,17 +483,17 @@ iface vid {\n \n impl of vid for tv_vid {\n     fn to_uint() -> uint { *self }\n-    fn to_str() -> ~str { #fmt[\"<V%u>\", self.to_uint()] }\n+    fn to_str() -> ~str { fmt!{\"<V%u>\", self.to_uint()} }\n }\n \n impl of vid for tvi_vid {\n     fn to_uint() -> uint { *self }\n-    fn to_str() -> ~str { #fmt[\"<VI%u>\", self.to_uint()] }\n+    fn to_str() -> ~str { fmt!{\"<VI%u>\", self.to_uint()} }\n }\n \n impl of vid for region_vid {\n     fn to_uint() -> uint { *self }\n-    fn to_str() -> ~str { #fmt[\"<R%u>\", self.to_uint()] }\n+    fn to_str() -> ~str { fmt!{\"<R%u>\", self.to_uint()} }\n }\n \n trait purity_to_str {\n@@ -1050,23 +1050,23 @@ fn substs_is_noop(substs: substs) -> bool {\n }\n \n fn substs_to_str(cx: ctxt, substs: substs) -> ~str {\n-    #fmt[\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n+    fmt!{\"substs(self_r=%s, self_ty=%s, tps=%?)\",\n          substs.self_r.map_default(~\"none\", |r| region_to_str(cx, r)),\n          substs.self_ty.map_default(~\"none\", |t| ty_to_str(cx, t)),\n-         substs.tps.map(|t| ty_to_str(cx, t))]\n+         substs.tps.map(|t| ty_to_str(cx, t))}\n }\n \n fn subst(cx: ctxt,\n          substs: substs,\n          typ: t) -> t {\n \n-    #debug[\"subst(substs=%s, typ=%s)\",\n+    debug!{\"subst(substs=%s, typ=%s)\",\n            substs_to_str(cx, substs),\n-           ty_to_str(cx, typ)];\n+           ty_to_str(cx, typ)};\n \n     if substs_is_noop(substs) { ret typ; }\n     let r = do_subst(cx, substs, typ);\n-    #debug[\"  r = %s\", ty_to_str(cx, r)];\n+    debug!{\"  r = %s\", ty_to_str(cx, r)};\n     ret r;\n \n     fn do_subst(cx: ctxt,\n@@ -1799,27 +1799,27 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n     fn type_requires(cx: ctxt, seen: @mut ~[def_id],\n                      r_ty: t, ty: t) -> bool {\n-        #debug[\"type_requires(%s, %s)?\",\n+        debug!{\"type_requires(%s, %s)?\",\n                ty_to_str(cx, r_ty),\n-               ty_to_str(cx, ty)];\n+               ty_to_str(cx, ty)};\n \n         let r = {\n             get(r_ty).struct == get(ty).struct ||\n                 subtypes_require(cx, seen, r_ty, ty)\n         };\n \n-        #debug[\"type_requires(%s, %s)? %b\",\n+        debug!{\"type_requires(%s, %s)? %b\",\n                ty_to_str(cx, r_ty),\n                ty_to_str(cx, ty),\n-               r];\n+               r};\n         ret r;\n     }\n \n     fn subtypes_require(cx: ctxt, seen: @mut ~[def_id],\n                         r_ty: t, ty: t) -> bool {\n-        #debug[\"subtypes_require(%s, %s)?\",\n+        debug!{\"subtypes_require(%s, %s)?\",\n                ty_to_str(cx, r_ty),\n-               ty_to_str(cx, ty)];\n+               ty_to_str(cx, ty)};\n \n         let r = alt get(ty).struct {\n           ty_nil |\n@@ -1895,10 +1895,10 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           }\n         };\n \n-        #debug[\"subtypes_require(%s, %s)? %b\",\n+        debug!{\"subtypes_require(%s, %s)? %b\",\n                ty_to_str(cx, r_ty),\n                ty_to_str(cx, ty),\n-               r];\n+               r};\n \n         ret r;\n     }\n@@ -1910,7 +1910,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n    bool {\n     let sty = get(ty).struct;\n-    #debug(\"type_structurally_contains: %s\", ty_to_str(cx, ty));\n+    debug!{\"type_structurally_contains: %s\", ty_to_str(cx, ty)};\n     if test(sty) { ret true; }\n     alt sty {\n       ty_enum(did, substs) {\n@@ -2232,8 +2232,8 @@ fn hash_type_structure(st: sty) -> uint {\n fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     alt smallintmap::find(*cx.node_types, id as uint) {\n        some(t) { t }\n-       none { cx.sess.bug(#fmt(\"node_id_to_type: unbound node ID %s\",\n-                               ast_map::node_id_to_str(cx.items, id))); }\n+       none { cx.sess.bug(fmt!{\"node_id_to_type: unbound node ID %s\",\n+                               ast_map::node_id_to_str(cx.items, id)}); }\n     }\n }\n \n@@ -2298,15 +2298,15 @@ fn is_pred_ty(fty: t) -> bool {\n fn ty_var_id(typ: t) -> tv_vid {\n     alt get(typ).struct {\n       ty_var(vid) { ret vid; }\n-      _ { #error(\"ty_var_id called on non-var ty\"); fail; }\n+      _ { error!{\"ty_var_id called on non-var ty\"}; fail; }\n     }\n }\n \n fn ty_var_integral_id(typ: t) -> tvi_vid {\n     alt get(typ).struct {\n       ty_var_integral(vid) { ret vid; }\n-      _ { #error(\"ty_var_integral_id called on ty other than \\\n-                  ty_var_integral\");\n+      _ { error!{\"ty_var_integral_id called on ty other than \\\n+                  ty_var_integral\"};\n          fail; }\n     }\n }\n@@ -2462,7 +2462,7 @@ fn canon_mode(cx: ctxt, m0: ast::mode) -> ast::mode {\n fn resolved_mode(cx: ctxt, m: ast::mode) -> ast::rmode {\n     alt canon_mode(cx, m) {\n       ast::infer(_) {\n-        cx.sess.bug(#fmt[\"mode %? was never resolved\", m]);\n+        cx.sess.bug(fmt!{\"mode %? was never resolved\", m});\n       }\n       ast::expl(m0) { m0 }\n     }\n@@ -2510,7 +2510,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n         ty_to_str(cx, t)\n       }\n \n-      ty_enum(id, _) { #fmt[\"enum %s\", item_path_str(cx, id)] }\n+      ty_enum(id, _) { fmt!{\"enum %s\", item_path_str(cx, id)} }\n       ty_box(_) { ~\"@-ptr\" }\n       ty_uniq(_) { ~\"~-ptr\" }\n       ty_evec(_, _) { ~\"vector\" }\n@@ -2519,8 +2519,8 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rptr(_, _) { ~\"&-ptr\" }\n       ty_rec(_) { ~\"record\" }\n       ty_fn(_) { ~\"fn\" }\n-      ty_trait(id, _) { #fmt[\"trait %s\", item_path_str(cx, id)] }\n-      ty_class(id, _) { #fmt[\"class %s\", item_path_str(cx, id)] }\n+      ty_trait(id, _) { fmt!{\"trait %s\", item_path_str(cx, id)} }\n+      ty_class(id, _) { fmt!{\"class %s\", item_path_str(cx, id)} }\n       ty_tup(_) { ~\"tuple\" }\n       ty_var(_) { ~\"variable\" }\n       ty_var_integral(_) { ~\"integral variable\" }\n@@ -2547,12 +2547,12 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n             ~\" function was expected\";\n       }\n       terr_purity_mismatch(f1, f2) {\n-        ret #fmt[\"expected %s fn but found %s fn\",\n-                 purity_to_str(f1), purity_to_str(f2)];\n+        ret fmt!{\"expected %s fn but found %s fn\",\n+                 purity_to_str(f1), purity_to_str(f2)};\n       }\n       terr_proto_mismatch(e, a) {\n-        ret #fmt[\"closure protocol mismatch (%s vs %s)\",\n-                 proto_to_str(e), proto_to_str(a)];\n+        ret fmt!{\"closure protocol mismatch (%s vs %s)\",\n+                 proto_to_str(e), proto_to_str(a)};\n       }\n       terr_mutability { ret ~\"values differ in mutability\"; }\n       terr_box_mutability { ret ~\"boxed values differ in mutability\"; }\n@@ -2585,22 +2585,22 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n             ~\" but found \" + mode_to_str(a_mode);\n       }\n       terr_regions_differ(subregion, superregion) {\n-        ret #fmt(\"references with lifetime %s do not necessarily \\\n+        ret fmt!{\"references with lifetime %s do not necessarily \\\n                   outlive references with lifetime %s\",\n                  region_to_str(cx, subregion),\n-                 region_to_str(cx, superregion));\n+                 region_to_str(cx, superregion)};\n       }\n       terr_vstores_differ(k, e_vs, a_vs) {\n-        ret #fmt(\"%s storage differs: expected %s but found %s\",\n+        ret fmt!{\"%s storage differs: expected %s but found %s\",\n                  terr_vstore_kind_to_str(k),\n                  vstore_to_str(cx, e_vs),\n-                 vstore_to_str(cx, a_vs));\n+                 vstore_to_str(cx, a_vs)};\n       }\n       terr_in_field(err, fname) {\n-        ret #fmt(\"in field `%s`, %s\", *fname, type_err_to_str(cx, *err));\n+        ret fmt!{\"in field `%s`, %s\", *fname, type_err_to_str(cx, *err)};\n       }\n       terr_sorts(exp, act) {\n-        ret #fmt(\"%s vs %s\", ty_sort_str(cx, exp), ty_sort_str(cx, act));\n+        ret fmt!{\"%s vs %s\", ty_sort_str(cx, exp), ty_sort_str(cx, act)};\n       }\n       terr_self_substs {\n         ret ~\"inconsistent self substitution\"; // XXX this is more of a bug\n@@ -2638,7 +2638,7 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n \n fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n     if id.crate == ast::local_crate {\n-        #debug(\"(impl_traits) searching for trait impl %?\", id);\n+        debug!{\"(impl_traits) searching for trait impl %?\", id};\n         alt cx.items.find(id.node) {\n            some(ast_map::node_item(@{\n                         node: ast::item_impl(_, trait_refs, _, _),\n@@ -2654,12 +2654,12 @@ fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n              alt cx.def_map.find(id.node) {\n                some(def_ty(trait_id)) {\n                    // XXX: Doesn't work cross-crate.\n-                   #debug(\"(impl_traits) found trait id %?\", trait_id);\n+                   debug!{\"(impl_traits) found trait id %?\", trait_id};\n                    ~[node_id_to_type(cx, trait_id.node)]\n                }\n                some(x) {\n-                 cx.sess.bug(#fmt(\"impl_traits: trait ref is in trait map \\\n-                                   but is bound to %?\", x));\n+                 cx.sess.bug(fmt!{\"impl_traits: trait ref is in trait map \\\n+                                   but is bound to %?\", x});\n                }\n                none {\n                  ~[]\n@@ -2765,7 +2765,7 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n           ast_map::node_local(_) | ast_map::node_export(_, _) |\n           ast_map::node_block(_) {\n-            cx.sess.bug(#fmt[\"cannot find item_path for node %?\", node]);\n+            cx.sess.bug(fmt!{\"cannot find item_path for node %?\", node});\n           }\n         }\n     }\n@@ -2899,8 +2899,8 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n          }\n        }\n        _ {\n-           cx.sess.bug(#fmt(\"class ID not bound to an item: %s\",\n-                            ast_map::node_id_to_str(cx.items, did.node)));\n+           cx.sess.bug(fmt!{\"class ID not bound to an item: %s\",\n+                            ast_map::node_id_to_str(cx.items, did.node)});\n        }\n     }\n         }\n@@ -2962,8 +2962,8 @@ fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n              ret ast_util::local_def(m.id);\n          }\n        }\n-       cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a method \\\n-           named %s\", *name));\n+       cx.sess.span_fatal(sp, fmt!{\"Class doesn't have a method \\\n+           named %s\", *name});\n     }\n     else {\n       csearch::get_class_method(cx.sess.cstore, did, name)"}, {"sha": "2338aa6368ce5abdc1f6ce70ad37ef08c668b8b4", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -167,7 +167,7 @@ enum crate_ctxt {\n \n // Functions that write types into the node type table\n fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n-    #debug[\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)];\n+    debug!{\"write_ty_to_tcx(%d, %s)\", node_id, ty_to_str(tcx, ty)};\n     smallintmap::insert(*tcx.node_types, node_id as uint, ty);\n }\n fn write_substs_to_tcx(tcx: ty::ctxt,\n@@ -266,10 +266,10 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n               arg_is_argv_ty(tcx, inputs[0]);\n         if !ok {\n                 tcx.sess.span_err(main_span,\n-                   #fmt(\"Wrong type in main function: found `%s`, \\\n+                   fmt!{\"Wrong type in main function: found `%s`, \\\n                    expected `extern fn(~[str]) -> ()` \\\n                    or `extern fn() -> ()`\",\n-                         ty_to_str(tcx, main_t)));\n+                         ty_to_str(tcx, main_t)});\n          }\n       }\n       _ {"}, {"sha": "341d9460c4b315ab3dd4c1853cc55899715c9a47", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -87,8 +87,8 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     let {bounds: decl_bounds, rp: decl_rp, ty: decl_ty} =\n         self.get_item_ty(did);\n \n-    #debug[\"ast_path_to_substs_and_ty: did=%? decl_rp=%b\",\n-           did, decl_rp];\n+    debug!{\"ast_path_to_substs_and_ty: did=%? decl_rp=%b\",\n+           did, decl_rp};\n \n     // If the type is parameterized by the self region, then replace self\n     // region with the current anon region binding (in other words,\n@@ -100,9 +100,9 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n       (false, some(_)) {\n         tcx.sess.span_err(\n             path.span,\n-            #fmt[\"no region bound is allowed on `%s`, \\\n+            fmt!{\"no region bound is allowed on `%s`, \\\n                   which is not declared as containing region pointers\",\n-                 ty::item_path_str(tcx, did)]);\n+                 ty::item_path_str(tcx, did)});\n         none\n       }\n       (true, none) {\n@@ -119,8 +119,8 @@ fn ast_path_to_substs_and_ty<AC: ast_conv, RS: region_scope copy owned>(\n     if !vec::same_length(*decl_bounds, path.types) {\n         self.tcx().sess.span_fatal(\n             path.span,\n-            #fmt[\"wrong number of type arguments: expected %u but found %u\",\n-                 (*decl_bounds).len(), path.types.len()]);\n+            fmt!{\"wrong number of type arguments: expected %u but found %u\",\n+                 (*decl_bounds).len(), path.types.len()});\n     }\n     let tps = path.types.map(|a_t| ast_ty_to_ty(self, rscope, a_t));\n \n@@ -266,8 +266,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n       }\n       ast::ty_path(path, id) {\n         let a_def = alt tcx.def_map.find(id) {\n-          none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n-                                                       path_to_str(path))); }\n+          none { tcx.sess.span_fatal(ast_ty.span, fmt!{\"unbound path %s\",\n+                                                       path_to_str(path)}); }\n           some(d) { d }};\n         alt a_def {\n           ast::def_ty(did) | ast::def_class(did, _) {\n@@ -322,8 +322,8 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy owned>(\n                         |ty| {\n                             tcx.sess.span_err(\n                                 a_t.span,\n-                                #fmt[\"bound not allowed on a %s\",\n-                                     ty::ty_sort_str(tcx, ty.ty)]);\n+                                fmt!{\"bound not allowed on a %s\",\n+                                     ty::ty_sort_str(tcx, ty.ty)});\n                             ty.ty\n                         })\n       }\n@@ -400,7 +400,7 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy owned>(\n     decl: ast::fn_decl,\n     expected_tys: expected_tys) -> ty::fn_ty {\n \n-    #debug[\"ty_of_fn_decl\"];\n+    debug!{\"ty_of_fn_decl\"};\n     do indent {\n         // new region names that appear inside of the fn decl are bound to\n         // that function type"}, {"sha": "1f589a1b9608a0c93975c05dce0113979827e1e4", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -201,10 +201,10 @@ fn check_fn(ccx: @crate_ctxt,\n     let arg_tys = fn_ty.inputs.map(|a| a.ty);\n     let ret_ty = fn_ty.output;\n \n-    #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n+    debug!{\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n            arg_tys.map(|a| ty_to_str(tcx, a)),\n            ty_to_str(tcx, ret_ty),\n-           option::map(self_ty, |st| ty_to_str(tcx, st))];\n+           option::map(self_ty, |st| ty_to_str(tcx, st))};\n \n     // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n@@ -299,8 +299,8 @@ fn check_fn(ccx: @crate_ctxt,\n         // Add formal parameters.\n         do vec::iter2(arg_tys, decl.inputs) |arg_ty, input| {\n             assign(input.id, some(arg_ty));\n-            #debug[\"Argument %s is assigned to %s\",\n-                   *input.ident, fcx.locals.get(input.id).to_str()];\n+            debug!{\"Argument %s is assigned to %s\",\n+                   *input.ident, fcx.locals.get(input.id).to_str()};\n         }\n \n         // Add explicitly-declared locals.\n@@ -311,9 +311,9 @@ fn check_fn(ccx: @crate_ctxt,\n               _ { some(fcx.to_ty(local.node.ty)) }\n             };\n             assign(local.node.id, o_ty);\n-            #debug[\"Local variable %s is assigned to %s\",\n+            debug!{\"Local variable %s is assigned to %s\",\n                    pat_to_str(local.node.pat),\n-                   fcx.locals.get(local.node.id).to_str()];\n+                   fcx.locals.get(local.node.id).to_str()};\n             visit::visit_local(local, e, v);\n         };\n \n@@ -323,9 +323,9 @@ fn check_fn(ccx: @crate_ctxt,\n               ast::pat_ident(path, _)\n               if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n                 assign(p.id, none);\n-                #debug[\"Pattern binding %s is assigned to %s\",\n+                debug!{\"Pattern binding %s is assigned to %s\",\n                        *path.idents[0],\n-                       fcx.locals.get(p.id).to_str()];\n+                       fcx.locals.get(p.id).to_str()};\n               }\n               _ {}\n             }\n@@ -381,9 +381,9 @@ fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n         let (id, sp) = p;\n         alt field_names.find(id) {\n           some(orig_sp) {\n-            tcx.sess.span_err(sp, #fmt(\"Duplicate field \\\n+            tcx.sess.span_err(sp, fmt!{\"Duplicate field \\\n                                    name %s in record type declaration\",\n-                                   *id));\n+                                   *id});\n             tcx.sess.span_note(orig_sp, ~\"First declaration of \\\n                                           this field occurred here\");\n             break;\n@@ -407,8 +407,8 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_impl(tps, _, ty, ms) {\n         let rp = ccx.tcx.region_paramd_items.contains_key(it.id);\n-        #debug[\"item_impl %s with id %d rp %b\",\n-               *it.ident, it.id, rp];\n+        debug!{\"item_impl %s with id %d rp %b\",\n+               *it.ident, it.id, rp};\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n         for ms.each |m| { check_method(ccx, m, self_ty);}\n       }\n@@ -470,7 +470,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                 if (*tpt.bounds).is_not_empty() {\n                     ccx.tcx.sess.span_err(\n                         item.span,\n-                        #fmt[\"foreign items may not have type parameters\"]);\n+                        fmt!{\"foreign items may not have type parameters\"});\n                 }\n             }\n         }\n@@ -502,22 +502,22 @@ impl of region_scope for @fn_ctxt {\n               some(r) { result::ok(r) }\n               none if *id == ~\"blk\" { self.block_region() }\n               none {\n-                result::err(#fmt[\"named region `%s` not in scope here\", *id])\n+                result::err(fmt!{\"named region `%s` not in scope here\", *id})\n               }\n             }\n         }\n     }\n }\n \n impl methods for @fn_ctxt {\n-    fn tag() -> ~str { #fmt[\"%x\", ptr::addr_of(*self) as uint] }\n+    fn tag() -> ~str { fmt!{\"%x\", ptr::addr_of(*self) as uint} }\n     fn block_region() -> result<ty::region, ~str> {\n         result::ok(ty::re_scope(self.region_lb))\n     }\n     #[inline(always)]\n     fn write_ty(node_id: ast::node_id, ty: ty::t) {\n-        #debug[\"write_ty(%d, %s) in fcx %s\",\n-               node_id, ty_to_str(self.tcx(), ty), self.tag()];\n+        debug!{\"write_ty(%d, %s) in fcx %s\",\n+               node_id, ty_to_str(self.tcx(), ty), self.tag()};\n         self.node_types.insert(node_id, ty);\n     }\n     fn write_substs(node_id: ast::node_id, +substs: ty::substs) {\n@@ -546,8 +546,8 @@ impl methods for @fn_ctxt {\n         alt self.node_types.find(ex.id) {\n           some(t) { t }\n           none {\n-            self.tcx().sess.bug(#fmt[\"no type for expr %d (%s) in fcx %s\",\n-                                     ex.id, expr_to_str(ex), self.tag()]);\n+            self.tcx().sess.bug(fmt!{\"no type for expr %d (%s) in fcx %s\",\n+                                     ex.id, expr_to_str(ex), self.tag()});\n           }\n         }\n     }\n@@ -556,9 +556,9 @@ impl methods for @fn_ctxt {\n           some(t) { t }\n           none {\n             self.tcx().sess.bug(\n-                #fmt[\"no type for node %d: %s in fcx %s\",\n+                fmt!{\"no type for node %d: %s in fcx %s\",\n                      id, ast_map::node_id_to_str(self.tcx().items, id),\n-                     self.tag()]);\n+                     self.tag()});\n           }\n         }\n     }\n@@ -567,9 +567,9 @@ impl methods for @fn_ctxt {\n           some(ts) { ts }\n           none {\n             self.tcx().sess.bug(\n-                #fmt[\"no type substs for node %d: %s in fcx %s\",\n+                fmt!{\"no type substs for node %d: %s in fcx %s\",\n                      id, ast_map::node_id_to_str(self.tcx().items, id),\n-                     self.tag()]);\n+                     self.tag()});\n           }\n         }\n     }\n@@ -581,10 +581,10 @@ impl methods for @fn_ctxt {\n                                err: ty::type_err) {\n         self.ccx.tcx.sess.span_err(\n             sp,\n-            #fmt[\"mismatched types: expected `%s` but found `%s` (%s)\",\n+            fmt!{\"mismatched types: expected `%s` but found `%s` (%s)\",\n                  self.infcx.ty_to_str(e),\n                  self.infcx.ty_to_str(a),\n-                 ty::type_err_to_str(self.ccx.tcx, err)]);\n+                 ty::type_err_to_str(self.ccx.tcx, err)});\n     }\n \n     fn mk_subty(sub: ty::t, sup: ty::t) -> result<(), ty::type_err> {\n@@ -621,7 +621,7 @@ impl methods for @fn_ctxt {\n           _ {\n             self.ccx.tcx.sess.span_err(\n                 sp,\n-                #fmt[\"%s requires unsafe function or block\", op]);\n+                fmt!{\"%s requires unsafe function or block\", op});\n           }\n         }\n     }\n@@ -775,8 +775,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                            expected: option<ty::t>,\n                            unifier: fn()) -> bool {\n \n-    #debug(\">> typechecking expr %d (%s)\",\n-           expr.id, syntax::print::pprust::expr_to_str(expr));\n+    debug!{\">> typechecking expr %d (%s)\",\n+           expr.id, syntax::print::pprust::expr_to_str(expr)};\n \n     // A generic function to factor out common logic from call and\n     // overloaded operations\n@@ -789,8 +789,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Replace all region parameters in the arguments and return\n         // type with fresh region variables.\n \n-        #debug[\"check_call_inner: before universal quant., in_fty=%s\",\n-               fcx.infcx.ty_to_str(in_fty)];\n+        debug!{\"check_call_inner: before universal quant., in_fty=%s\",\n+               fcx.infcx.ty_to_str(in_fty)};\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n@@ -815,8 +815,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n \n         let fty = ty::mk_fn(fcx.tcx(), fn_ty);\n-        #debug[\"check_call_inner: after universal quant., fty=%s\",\n-               fcx.infcx.ty_to_str(fty)];\n+        debug!{\"check_call_inner: after universal quant., fty=%s\",\n+               fcx.infcx.ty_to_str(fty)};\n \n         let supplied_arg_count = vec::len(args);\n \n@@ -827,7 +827,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fn_ty.inputs.map(|a| a.ty)\n         } else {\n             fcx.ccx.tcx.sess.span_err(\n-                sp, #fmt[\"this function takes %u parameter%s but %u \\\n+                sp, fmt!{\"this function takes %u parameter%s but %u \\\n                           parameter%s supplied\", expected_arg_count,\n                          if expected_arg_count == 1u {\n                              ~\"\"\n@@ -839,7 +839,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              ~\" was\"\n                          } else {\n                              ~\"s were\"\n-                         }]);\n+                         }});\n             fcx.infcx.next_ty_vars(supplied_arg_count)\n         };\n \n@@ -999,8 +999,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 // separate case below.\n                 tcx.sess.span_bug(\n                     expr.span,\n-                    #fmt[\"comparison operator in expr_binop: %s\",\n-                         ast_util::binop_to_str(op)]);\n+                    fmt!{\"comparison operator in expr_binop: %s\",\n+                         ast_util::binop_to_str(op)});\n               }\n               _ { lhs_t }\n             };\n@@ -1061,8 +1061,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           some((ret_ty, _)) { ret_ty }\n           _ {\n             fcx.ccx.tcx.sess.span_err(\n-                ex.span, #fmt[\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, fcx.infcx.ty_to_str(rhs_t)]);\n+                ex.span, fmt!{\"cannot apply unary operator `%s` to type `%s`\",\n+                              op_str, fcx.infcx.ty_to_str(rhs_t)});\n             rhs_t\n           }\n         }\n@@ -1118,8 +1118,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                            decl, expected_tys);\n         let fty = ty::mk_fn(tcx, fn_ty);\n \n-        #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr), fcx.infcx.ty_to_str(fty));\n+        debug!{\"check_expr_fn_with_unifier %s fty=%s\",\n+               expr_to_str(expr), fcx.infcx.ty_to_str(fty)};\n \n         fcx.write_ty(expr.id, fty);\n \n@@ -1159,7 +1159,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n               // (1) verify that the class id actually has a field called\n               // field\n-              #debug(\"class named %s\", ty_to_str(tcx, base_t));\n+              debug!{\"class named %s\", ty_to_str(tcx, base_t)};\n               /*\n                 check whether this is a self-reference or not, which\n                 determines whether we look at all fields or only public\n@@ -1209,10 +1209,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               }\n               none {\n                 let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n-                let msg = #fmt[\"attempted access of field `%s` on type `%s`, \\\n+                let msg = fmt!{\"attempted access of field `%s` on type `%s`, \\\n                                 but no public field or method with that name \\\n                                 was found\",\n-                               *field, fcx.infcx.ty_to_str(t_err)];\n+                               *field, fcx.infcx.ty_to_str(t_err)};\n                 tcx.sess.span_err(expr.span, msg);\n                 // NB: Adding a bogus type to allow typechecking to continue\n                 fcx.write_ty(expr.id, fcx.infcx.next_ty_var());\n@@ -1334,8 +1334,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                   _ {\n                     tcx.sess.span_err(\n                         expr.span,\n-                        #fmt[\"type %s cannot be dereferenced\",\n-                             fcx.infcx.ty_to_str(oprnd_t)]);\n+                        fmt!{\"type %s cannot be dereferenced\",\n+                             fcx.infcx.ty_to_str(oprnd_t)});\n                   }\n                 }\n               }\n@@ -1472,9 +1472,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               result::ok(_) {}\n               result::err(err) {\n                 tcx.sess.span_fatal(\n-                    expr.span, #fmt(\"a `loop` function's last argument \\\n+                    expr.span, fmt!{\"a `loop` function's last argument \\\n                                      should return `bool`, not `%s`\",\n-                                    fcx.infcx.ty_to_str(fty.output)));\n+                                    fcx.infcx.ty_to_str(fty.output)});\n               }\n             }\n             (ty::mk_fn(tcx, {output: ty::mk_nil(tcx) with fty}), fty.proto)\n@@ -1545,8 +1545,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        #debug[\"t_1=%s\", fcx.infcx.ty_to_str(t_1)];\n-        #debug[\"t_e=%s\", fcx.infcx.ty_to_str(t_e)];\n+        debug!{\"t_1=%s\", fcx.infcx.ty_to_str(t_1)};\n+        debug!{\"t_e=%s\", fcx.infcx.ty_to_str(t_e)};\n \n         alt ty::get(t_1).struct {\n           // This will be looked up later on\n@@ -1743,15 +1743,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             alt class_field_map.find(*field.node.ident) {\n                 none => {\n                     tcx.sess.span_err(field.span,\n-                                      #fmt(\"structure has no field named \\\n+                                      fmt!{\"structure has no field named \\\n                                             field named `%s`\",\n-                                           *field.node.ident));\n+                                           *field.node.ident});\n                 }\n                 some((_, true)) => {\n                     tcx.sess.span_err(field.span,\n-                                      #fmt(\"field `%s` specified more than \\\n+                                      fmt!{\"field `%s` specified more than \\\n                                             once\",\n-                                           *field.node.ident));\n+                                           *field.node.ident});\n                 }\n                 some((field_id, false)) => {\n                     let expected_field_type =\n@@ -1779,13 +1779,13 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n \n             tcx.sess.span_err(expr.span,\n-                              #fmt(\"missing field%s: %s\",\n+                              fmt!{\"missing field%s: %s\",\n                                    if missing_fields.len() == 1 {\n                                        ~\"\"\n                                    } else {\n                                        ~\"s\"\n                                    },\n-                                   str::connect(missing_fields, ~\", \")));\n+                                   str::connect(missing_fields, ~\", \")});\n         }\n \n         // Write in the resulting type.\n@@ -1851,8 +1851,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n           none {\n             let t_err = fcx.infcx.resolve_type_vars_if_possible(p_ty);\n-            let msg = #fmt[\"no `alloc()` method found for type `%s`\",\n-                           fcx.infcx.ty_to_str(t_err)];\n+            let msg = fmt!{\"no `alloc()` method found for type `%s`\",\n+                           fcx.infcx.ty_to_str(t_err)};\n             tcx.sess.span_err(expr.span, msg);\n           }\n         }\n@@ -1868,17 +1868,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     }\n     if bot { fcx.write_bot(expr.id); }\n \n-    #debug(\"type of expr %s is %s, expected is %s\",\n+    debug!{\"type of expr %s is %s, expected is %s\",\n            syntax::print::pprust::expr_to_str(expr),\n            ty_to_str(tcx, fcx.expr_ty(expr)),\n            alt expected {\n                some(t) { ty_to_str(tcx, t) }\n                _ { ~\"empty\" }\n-           });\n+           }};\n \n     unifier();\n \n-    #debug(\"<< bot=%b\", bot);\n+    debug!{\"<< bot=%b\", bot};\n     ret bot;\n }\n \n@@ -2025,10 +2025,10 @@ fn check_instantiable(tcx: ty::ctxt,\n                       item_id: ast::node_id) {\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n-        tcx.sess.span_err(sp, #fmt[\"this type cannot be instantiated \\\n+        tcx.sess.span_err(sp, fmt!{\"this type cannot be instantiated \\\n                                     without an instance of itself; \\\n                                     consider using `option<%s>`\",\n-                                   ty_to_str(tcx, item_ty)]);\n+                                   ty_to_str(tcx, item_ty)});\n     }\n }\n \n@@ -2299,7 +2299,7 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n       ast::vstore_fixed(none) { ty::vstore_fixed(n) }\n       ast::vstore_fixed(some(u)) {\n         if n != u {\n-            let s = #fmt(\"fixed-size sequence mismatch: %u vs. %u\",u, n);\n+            let s = fmt!{\"fixed-size sequence mismatch: %u vs. %u\",u, n};\n             fcx.ccx.tcx.sess.span_err(e.span,s);\n         }\n         ty::vstore_fixed(u)\n@@ -2344,7 +2344,7 @@ fn check_bounds_are_used(ccx: @crate_ctxt,\n     for tps_used.eachi |i, b| {\n         if !b {\n             ccx.tcx.sess.span_err(\n-                span, #fmt[\"type parameter `%s` is unused\", *tps[i].ident]);\n+                span, fmt!{\"type parameter `%s` is unused\", *tps[i].ident});\n         }\n     }\n }\n@@ -2424,14 +2424,14 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {\n-        tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n+        tcx.sess.span_err(it.span, fmt!{\"intrinsic has wrong number \\\n                                          of type parameters: found %u, \\\n-                                         expected %u\", i_n_tps, n_tps));\n+                                         expected %u\", i_n_tps, n_tps});\n     } else {\n         require_same_types(\n             tcx, none, it.span, i_ty.ty, fty,\n-            || #fmt[\"intrinsic has wrong type: \\\n+            || fmt!{\"intrinsic has wrong type: \\\n                       expected `%s`\",\n-                     ty_to_str(ccx.tcx, fty)]);\n+                     ty_to_str(ccx.tcx, fty)});\n     }\n }"}, {"sha": "db35398a49c69c291a7f938433e7f688854a4cb1", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -88,12 +88,12 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         if arg_len > 0u {\n             // N-ary variant.\n             if arg_len != subpats_len {\n-                let s = #fmt[\"this pattern has %u field%s, but the \\\n+                let s = fmt!{\"this pattern has %u field%s, but the \\\n                               corresponding variant has %u field%s\",\n                              subpats_len,\n                              if subpats_len == 1u { ~\"\" } else { ~\"s\" },\n                              arg_len,\n-                             if arg_len == 1u { ~\"\" } else { ~\"s\" }];\n+                             if arg_len == 1u { ~\"\" } else { ~\"s\" }};\n                 tcx.sess.span_fatal(pat.span, s);\n             }\n \n@@ -104,18 +104,18 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             };\n         } else if subpats_len > 0u {\n             tcx.sess.span_fatal\n-                (pat.span, #fmt[\"this pattern has %u field%s, \\\n+                (pat.span, fmt!{\"this pattern has %u field%s, \\\n                                  but the corresponding variant has no fields\",\n                                 subpats_len,\n                                 if subpats_len == 1u { ~\"\" }\n-                                else { ~\"s\" }]);\n+                                else { ~\"s\" }});\n         }\n       }\n       _ {\n         tcx.sess.span_fatal\n             (pat.span,\n-             #fmt[\"mismatched types: expected enum but found `%s`\",\n-                  fcx.infcx.ty_to_str(expected)]);\n+             fmt!{\"mismatched types: expected enum but found `%s`\",\n+                  fcx.infcx.ty_to_str(expected)});\n       }\n     }\n }\n@@ -141,8 +141,8 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         let e_ty =\n             fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(end));\n-        #debug[\"pat_range beginning type: %?\", b_ty];\n-        #debug[\"pat_range ending type: %?\", e_ty];\n+        debug!{\"pat_range beginning type: %?\", b_ty};\n+        debug!{\"pat_range ending type: %?\", e_ty};\n         if !require_same_types(\n             tcx, some(fcx.infcx), pat.span, b_ty, e_ty,\n             || ~\"mismatched types in range\") {\n@@ -183,18 +183,18 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ {\n             tcx.sess.span_fatal\n                 (pat.span,\n-                #fmt[\"mismatched types: expected `%s` but found record\",\n-                     fcx.infcx.ty_to_str(expected)]);\n+                fmt!{\"mismatched types: expected `%s` but found record\",\n+                     fcx.infcx.ty_to_str(expected)});\n           }\n         };\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n             tcx.sess.span_fatal\n-                (pat.span, #fmt[\"mismatched types: expected a record \\\n+                (pat.span, fmt!{\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n-                                ex_f_count, f_count]);\n+                                ex_f_count, f_count});\n         }\n         fn matches(name: ast::ident, f: ty::field) -> bool {\n             ret str::eq(*name, *f.ident);\n@@ -206,9 +206,9 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               }\n               none {\n                 tcx.sess.span_fatal(pat.span,\n-                                    #fmt[\"mismatched types: did not \\\n+                                    fmt!{\"mismatched types: did not \\\n                                           expect a record with a field `%s`\",\n-                                         *f.ident]);\n+                                         *f.ident});\n               }\n             }\n         }\n@@ -220,16 +220,16 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           _ {\n             tcx.sess.span_fatal\n                 (pat.span,\n-                 #fmt[\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.infcx.ty_to_str(expected)]);\n+                 fmt!{\"mismatched types: expected `%s`, found tuple\",\n+                      fcx.infcx.ty_to_str(expected)});\n           }\n         };\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n             tcx.sess.span_fatal\n-                (pat.span, #fmt[\"mismatched types: expected a tuple \\\n+                (pat.span, fmt!{\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n-                      fields\", vec::len(ex_elts), e_count]);\n+                      fields\", vec::len(ex_elts), e_count});\n         }\n         let mut i = 0u;\n         for elts.each |elt| {"}, {"sha": "277891c4effbecd43e3e4d07a48d7b2b1b756cda", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -58,9 +58,9 @@ class lookup {\n \n     // Entrypoint:\n     fn method() -> option<method_map_entry> {\n-        #debug[\"method lookup(m_name=%s, self_ty=%s, %?)\",\n+        debug!{\"method lookup(m_name=%s, self_ty=%s, %?)\",\n                *self.m_name, self.fcx.infcx.ty_to_str(self.self_ty),\n-               ty::get(self.self_ty).struct];\n+               ty::get(self.self_ty).struct};\n \n         // Determine if there are any inherent methods we can call.\n         let optional_inherent_methods;\n@@ -71,15 +71,15 @@ class lookup {\n                 optional_inherent_methods = none;\n             }\n             some(base_type_def_id) {\n-                #debug(\"(checking method) found base type\");\n+                debug!{\"(checking method) found base type\"};\n                 optional_inherent_methods =\n                     self.fcx.ccx.coherence_info.inherent_methods.find\n                         (base_type_def_id);\n \n                 if optional_inherent_methods.is_none() {\n-                    #debug(\"(checking method) ... no inherent methods found\");\n+                    debug!{\"(checking method) ... no inherent methods found\"};\n                 } else {\n-                    #debug(\"(checking method) ... inherent methods found\");\n+                    debug!{\"(checking method) ... inherent methods found\"};\n                 }\n             }\n         }\n@@ -173,30 +173,30 @@ class lookup {\n         };\n         self.tcx().sess.span_note(\n             span,\n-            #fmt[\"candidate #%u is `%s`\",\n+            fmt!{\"candidate #%u is `%s`\",\n                  (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)]);\n+                 ty::item_path_str(self.tcx(), did)});\n     }\n \n     fn report_param_candidate(idx: uint, did: ast::def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            #fmt[\"candidate #%u derives from the bound `%s`\",\n+            fmt!{\"candidate #%u derives from the bound `%s`\",\n                  (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)]);\n+                 ty::item_path_str(self.tcx(), did)});\n     }\n \n     fn report_trait_candidate(idx: uint, did: ast::def_id) {\n         self.tcx().sess.span_note(\n             self.expr.span,\n-            #fmt[\"candidate #%u derives from the type of the receiver, \\\n+            fmt!{\"candidate #%u derives from the type of the receiver, \\\n                   which is the trait `%s`\",\n                  (idx+1u),\n-                 ty::item_path_str(self.tcx(), did)]);\n+                 ty::item_path_str(self.tcx(), did)});\n     }\n \n     fn add_candidates_from_param(n: uint, did: ast::def_id) {\n-        #debug[\"candidates_from_param\"];\n+        debug!{\"candidates_from_param\"};\n \n         let tcx = self.tcx();\n         let mut trait_bnd_idx = 0u; // count only trait bounds\n@@ -246,7 +246,7 @@ class lookup {\n \n     fn add_candidates_from_trait(did: ast::def_id, trait_substs: ty::substs) {\n \n-        #debug[\"method_from_trait\"];\n+        debug!{\"method_from_trait\"};\n \n         let ms = *ty::trait_methods(self.tcx(), did);\n         for ms.eachi |i, m| {\n@@ -281,7 +281,7 @@ class lookup {\n \n     fn add_candidates_from_class(did: ast::def_id, class_substs: ty::substs) {\n \n-        #debug[\"method_from_class\"];\n+        debug!{\"method_from_class\"};\n \n         let ms = *ty::trait_methods(self.tcx(), did);\n \n@@ -341,7 +341,7 @@ class lookup {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n         let mut added_any = false;\n \n-        #debug[\"method_from_scope\"];\n+        debug!{\"method_from_scope\"};\n \n         for list::each(impls_vecs) |impls| {\n             for vec::each(*impls) |im| {\n@@ -379,7 +379,7 @@ class lookup {\n             } else {\n                 self.fcx.can_mk_subty(self.self_ty, impl_ty)\n             };\n-            #debug[\"matches = %?\", matches];\n+            debug!{\"matches = %?\", matches};\n             alt matches {\n               result::err(_) { /* keep looking */ }\n               result::ok(_) {\n@@ -431,13 +431,13 @@ class lookup {\n                 // Continue.\n             }\n             some(inherent_methods) {\n-                #debug(\"(adding inherent and extension candidates) adding \\\n-                        inherent candidates\");\n+                debug!{\"(adding inherent and extension candidates) adding \\\n+                        inherent candidates\"};\n                 for inherent_methods.each |implementation| {\n-                    #debug(\"(adding inherent and extension candidates) \\\n+                    debug!{\"(adding inherent and extension candidates) \\\n                             adding candidates from impl: %s\",\n                            node_id_to_str(self.tcx().items,\n-                                          implementation.did.node));\n+                                          implementation.did.node)};\n                     self.add_candidates_from_impl(implementation,\n                                                   use_assignability);\n                 }\n@@ -451,9 +451,9 @@ class lookup {\n             }\n             some(trait_ids) {\n                 for (*trait_ids).each |trait_id| {\n-                    #debug(\"(adding inherent and extension candidates) \\\n+                    debug!{\"(adding inherent and extension candidates) \\\n                             trying trait: %s\",\n-                           self.def_id_to_str(trait_id));\n+                           self.def_id_to_str(trait_id)};\n \n                     let coherence_info = self.fcx.ccx.coherence_info;\n                     alt coherence_info.extension_methods.find(trait_id) {\n@@ -462,10 +462,10 @@ class lookup {\n                         }\n                         some(extension_methods) {\n                             for extension_methods.each |implementation| {\n-                                #debug(\"(adding inherent and extension \\\n+                                debug!{\"(adding inherent and extension \\\n                                          candidates) adding impl %s\",\n                                        self.def_id_to_str\n-                                        (implementation.did));\n+                                        (implementation.did)};\n                                 self.add_candidates_from_impl\n                                     (implementation, use_assignability);\n                             }\n@@ -487,10 +487,10 @@ class lookup {\n     fn write_mty_from_candidate(cand: candidate) -> method_map_entry {\n         let tcx = self.fcx.ccx.tcx;\n \n-        #debug[\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n+        debug!{\"write_mty_from_candidate(n_tps_m=%u, fty=%s, entry=%?)\",\n                cand.n_tps_m,\n                self.fcx.infcx.ty_to_str(cand.fty),\n-               cand.entry];\n+               cand.entry};\n \n         // Make the actual receiver type (cand.self_ty) assignable to the\n         // required receiver type (cand.rcvr_ty).  If this method is not\n@@ -501,9 +501,9 @@ class lookup {\n           result::err(_) {\n             self.tcx().sess.span_bug(\n                 self.expr.span,\n-                #fmt[\"%s was assignable to %s but now is not?\",\n+                fmt!{\"%s was assignable to %s but now is not?\",\n                      self.fcx.infcx.ty_to_str(cand.self_ty),\n-                     self.fcx.infcx.ty_to_str(cand.rcvr_ty)]);\n+                     self.fcx.infcx.ty_to_str(cand.rcvr_ty)});\n           }\n         }\n "}, {"sha": "06307c1c70cb8acce43d68ba17293bfda6590553", "filename": "src/rustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -107,7 +107,7 @@ fn visit_pat(p: @ast::pat, &&rcx: @rcx, v: rvt) {\n     alt p.node {\n       ast::pat_ident(path, _)\n       if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n-        #debug[\"visit_pat binding=%s\", *path.idents[0]];\n+        debug!{\"visit_pat binding=%s\", *path.idents[0]};\n         visit_node(p.id, p.span, rcx);\n       }\n       _ {}\n@@ -121,7 +121,7 @@ fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n }\n \n fn visit_expr(e: @ast::expr, &&rcx: @rcx, v: rvt) {\n-    #debug[\"visit_expr(e=%s)\", pprust::expr_to_str(e)];\n+    debug!{\"visit_expr(e=%s)\", pprust::expr_to_str(e)};\n \n     alt e.node {\n       ast::expr_path(*) {\n@@ -200,10 +200,10 @@ fn visit_node(id: ast::node_id, span: span, rcx: @rcx) -> bool {\n     let tcx = fcx.ccx.tcx;\n     let encl_region = ty::encl_region(tcx, id);\n \n-    #debug[\"visit_node(ty=%s, id=%d, encl_region=%s)\",\n+    debug!{\"visit_node(ty=%s, id=%d, encl_region=%s)\",\n            ppaux::ty_to_str(tcx, ty),\n            id,\n-           ppaux::region_to_str(tcx, encl_region)];\n+           ppaux::region_to_str(tcx, encl_region)};\n \n     // Otherwise, look at the type and see if it is a region pointer.\n     ret constrain_regions_in_type(rcx, encl_region, span, ty);\n@@ -228,9 +228,9 @@ fn constrain_regions_in_type(\n                         region: ty::region) {\n         let tcx = rcx.fcx.ccx.tcx;\n \n-        #debug[\"constrain_region(encl_region=%s, region=%s)\",\n+        debug!{\"constrain_region(encl_region=%s, region=%s)\",\n                ppaux::region_to_str(tcx, encl_region),\n-               ppaux::region_to_str(tcx, region)];\n+               ppaux::region_to_str(tcx, region)};\n \n         alt region {\n           ty::re_bound(_) {\n@@ -248,9 +248,9 @@ fn constrain_regions_in_type(\n             let region1 = rcx.fcx.infcx.resolve_region_if_possible(region);\n             tcx.sess.span_err(\n                 span,\n-                #fmt[\"reference is not valid outside \\\n+                fmt!{\"reference is not valid outside \\\n                       of its lifetime, %s\",\n-                     ppaux::region_to_str(tcx, region1)]);\n+                     ppaux::region_to_str(tcx, region1)});\n             rcx.errors_reported += 1u;\n           }\n           result::ok(()) {"}, {"sha": "efb50b1eb8fe7b6cb2199fbd90b3bbb1d45b4a0d", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,24 +14,24 @@ fn replace_bound_regions_in_fn_ty(\n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n     for self_ty.each |t| { vec::push(all_tys, t) }\n \n-    #debug[\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n+    debug!{\"replace_bound_regions_in_fn_ty(self_ty=%?, fn_ty=%s, all_tys=%?)\",\n            self_ty.map(|t| ty_to_str(tcx, t)),\n            ty_to_str(tcx, ty::mk_fn(tcx, fn_ty)),\n-           all_tys.map(|t| ty_to_str(tcx, t))];\n+           all_tys.map(|t| ty_to_str(tcx, t))};\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        #debug[\"br=%?\", br];\n+        debug!{\"br=%?\", br};\n         mapf(br)\n     };\n     let t_fn = ty::fold_sty_to_ty(tcx, ty::ty_fn(fn_ty), |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n \n-    #debug[\"result of replace_bound_regions_in_fn_ty: self_ty=%?, fn_ty=%s\",\n+    debug!{\"result of replace_bound_regions_in_fn_ty: self_ty=%?, fn_ty=%s\",\n            t_self.map(|t| ty_to_str(tcx, t)),\n-           ty_to_str(tcx, t_fn)];\n+           ty_to_str(tcx, t_fn)};\n \n     ret {isr: isr,\n          self_ty: t_self,\n@@ -122,9 +122,9 @@ fn replace_bound_regions_in_fn_ty(\n                   none if in_fn { r }\n                   none {\n                     tcx.sess.bug(\n-                        #fmt[\"Bound region not found in \\\n+                        fmt!{\"Bound region not found in \\\n                               in_scope_regions list: %s\",\n-                             region_to_str(tcx, r)]);\n+                             region_to_str(tcx, r)});\n                   }\n                 }\n               }\n@@ -145,7 +145,7 @@ fn replace_bound_regions_in_fn_ty(\n  * stack position and so the resulting region will be the enclosing block.\n  */\n fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n-    #debug[\"region_of(expr=%s)\", expr_to_str(expr)];\n+    debug!{\"region_of(expr=%s)\", expr_to_str(expr)};\n     ret alt expr.node {\n       ast::expr_path(path) {\n         def(fcx, expr, lookup_def(fcx, path.span, expr.id))}\n@@ -178,12 +178,12 @@ fn region_of(fcx: @fn_ctxt, expr: @ast::expr) -> ty::region {\n           ast::def_arg(local_id, _) |\n           ast::def_local(local_id, _) |\n           ast::def_binding(local_id) {\n-            #debug[\"region_of.def/arg/local/binding(id=%d)\", local_id];\n+            debug!{\"region_of.def/arg/local/binding(id=%d)\", local_id};\n             let local_scope = fcx.ccx.tcx.region_map.get(local_id);\n             ty::re_scope(local_scope)\n           }\n           ast::def_upvar(_, inner, _) {\n-            #debug[\"region_of.def/upvar\"];\n+            debug!{\"region_of.def/upvar\"};\n             def(fcx, expr, *inner)\n           }\n           ast::def_self(*) {"}, {"sha": "70fddb190fb45f4a0db350ece595d717cb87f442", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -56,8 +56,8 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                  allow_unsafe: bool)\n               -> vtable_origin {\n \n-    #debug[\"lookup_vtable(ty=%s, trait_ty=%s)\",\n-           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty)];\n+    debug!{\"lookup_vtable(ty=%s, trait_ty=%s)\",\n+           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(trait_ty)};\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n@@ -78,8 +78,8 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                 alt check ty::get(ity).struct {\n                   ty::ty_trait(idid, substs) {\n                     if trait_id == idid {\n-                        #debug(\"(checking vtable) @0 relating ty to trait ty\n-                                with did %?\", idid);\n+                        debug!{\"(checking vtable) @0 relating ty to trait ty\n+                                with did %?\", idid};\n                         relate_trait_tys(fcx, sp, trait_ty, ity);\n                         ret vtable_param(n, n_bound);\n                     }\n@@ -92,8 +92,8 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n       }\n \n       ty::ty_trait(did, substs) if trait_id == did {\n-        #debug(\"(checking vtable) @1 relating ty to trait ty with did %?\",\n-               did);\n+        debug!{\"(checking vtable) @1 relating ty to trait ty with did %?\",\n+               did};\n \n         relate_trait_tys(fcx, sp, trait_ty, ty);\n         if !allow_unsafe {\n@@ -153,10 +153,10 @@ fn lookup_vtable(fcx: @fn_ctxt, sp: span, ty: ty::t, trait_ty: ty::t,\n                         }\n \n                         // check that desired trait type unifies\n-                        #debug(\"(checking vtable) @2 relating trait ty %s to \\\n+                        debug!{\"(checking vtable) @2 relating trait ty %s to \\\n                                 of_ty %s\",\n                                fcx.infcx.ty_to_str(trait_ty),\n-                               fcx.infcx.ty_to_str(of_ty));\n+                               fcx.infcx.ty_to_str(of_ty)};\n                         let of_ty = ty::subst(tcx, substs, of_ty);\n                         relate_trait_tys(fcx, sp, trait_ty, of_ty);\n \n@@ -201,9 +201,9 @@ fn fixup_ty(fcx: @fn_ctxt, sp: span, ty: ty::t) -> ty::t {\n       result::err(e) {\n         tcx.sess.span_fatal(\n             sp,\n-            #fmt[\"cannot determine a type \\\n+            fmt!{\"cannot determine a type \\\n                   for this bounded type parameter: %s\",\n-                 fixup_err_to_str(e)])\n+                 fixup_err_to_str(e)})\n       }\n     }\n }\n@@ -215,8 +215,8 @@ fn connect_trait_tps(fcx: @fn_ctxt, sp: span, impl_tys: ~[ty::t],\n     // XXX: This should work for multiple traits.\n     let ity = ty::impl_traits(tcx, impl_did)[0];\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n-    #debug(\"(connect trait tps) trait type is %?, impl did is %?\",\n-           ty::get(trait_ty).struct, impl_did);\n+    debug!{\"(connect trait tps) trait type is %?, impl did is %?\",\n+           ty::get(trait_ty).struct, impl_did};\n     alt check ty::get(trait_ty).struct {\n       ty::ty_trait(_, substs) {\n         vec::iter2(substs.tps, trait_tys,"}, {"sha": "d9615c88583255c818fd14354f000a802e5681a0", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,9 +16,9 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n         if !fcx.ccx.tcx.sess.has_errors() {\n             fcx.ccx.tcx.sess.span_err(\n                 sp,\n-                #fmt[\"cannot determine a type \\\n+                fmt!{\"cannot determine a type \\\n                       for this expression: %s\",\n-                     infer::fixup_err_to_str(e)])\n+                     infer::fixup_err_to_str(e)})\n         }\n         ret none;\n       }\n@@ -35,8 +35,8 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n       }\n \n       some(t) {\n-        #debug[\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n-               id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t)];\n+        debug!{\"resolve_type_vars_for_node(id=%d, n_ty=%s, t=%s)\",\n+               id, ty_to_str(tcx, n_ty), ty_to_str(tcx, t)};\n         write_ty_to_tcx(tcx, id, t);\n         alt fcx.opt_node_ty_substs(id) {\n           some(substs) {\n@@ -120,11 +120,11 @@ fn visit_block(b: ast::blk, wbcx: wb_ctxt, v: wb_vt) {\n fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n     if !wbcx.success { ret; }\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n-    #debug[\"Type for pattern binding %s (id %d) resolved to %s\",\n+    debug!{\"Type for pattern binding %s (id %d) resolved to %s\",\n            pat_to_str(p), p.id,\n            wbcx.fcx.infcx.ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n-                                   p.id))];\n+                                   p.id))};\n     visit::visit_pat(p, wbcx, v);\n }\n fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n@@ -133,17 +133,17 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n     let var_ty = ty::mk_var(wbcx.fcx.tcx(), var_id);\n     alt resolve_type(wbcx.fcx.infcx, var_ty, resolve_all | force_all) {\n       result::ok(lty) {\n-        #debug[\"Type for local %s (id %d) resolved to %s\",\n+        debug!{\"Type for local %s (id %d) resolved to %s\",\n                pat_to_str(l.node.pat), l.node.id,\n-               wbcx.fcx.infcx.ty_to_str(lty)];\n+               wbcx.fcx.infcx.ty_to_str(lty)};\n         write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n       }\n       result::err(e) {\n         wbcx.fcx.ccx.tcx.sess.span_err(\n             l.span,\n-            #fmt[\"cannot determine a type \\\n+            fmt!{\"cannot determine a type \\\n                   for this local variable: %s\",\n-                 infer::fixup_err_to_str(e)]);\n+                 infer::fixup_err_to_str(e)});\n         wbcx.success = false;\n       }\n     }"}, {"sha": "e3fdd0424b7450d0e4e415fc95350eea0972d6a0", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -60,13 +60,13 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         ty_uniq(base_mutability_and_type) |\n         ty_ptr(base_mutability_and_type) |\n         ty_rptr(_, base_mutability_and_type) {\n-            #debug(\"(getting base type) recurring\");\n+            debug!{\"(getting base type) recurring\"};\n             get_base_type(inference_context, span,\n                           base_mutability_and_type.ty)\n         }\n \n         ty_enum(*) | ty_trait(*) | ty_class(*) {\n-            #debug(\"(getting base type) found base type\");\n+            debug!{\"(getting base type) found base type\"};\n             some(resolved_type)\n         }\n \n@@ -75,8 +75,8 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         ty_fn(*) | ty_tup(*) | ty_var(*) | ty_var_integral(*) |\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) {\n-            #debug(\"(getting base type) no base type; found %?\",\n-                   get(original_type).struct);\n+            debug!{\"(getting base type) no base type; found %?\",\n+                   get(original_type).struct};\n             none\n         }\n     }\n@@ -158,7 +158,7 @@ class CoherenceChecker {\n \n         visit_crate(*crate, (), mk_simple_visitor(@{\n             visit_item: |item| {\n-                #debug(\"(checking coherence) item '%s'\", *item.ident);\n+                debug!{\"(checking coherence) item '%s'\", *item.ident};\n \n                 alt item.node {\n                     item_impl(_, associated_traits, _, _) {\n@@ -199,9 +199,9 @@ class CoherenceChecker {\n         // base type.\n \n         if associated_traits.len() == 0 {\n-            #debug(\"(checking implementation) no associated traits for item \\\n+            debug!{\"(checking implementation) no associated traits for item \\\n                     '%s'\",\n-                   *item.ident);\n+                   *item.ident};\n \n             alt get_base_type_def_id(self.inference_context,\n                                      item.span,\n@@ -222,11 +222,11 @@ class CoherenceChecker {\n         for associated_traits.each |associated_trait| {\n             let def = self.crate_context.tcx.def_map.get\n                 (associated_trait.ref_id);\n-            #debug(\"(checking implementation) adding impl for trait \\\n+            debug!{\"(checking implementation) adding impl for trait \\\n                     '%s', item '%s'\",\n                    ast_map::node_id_to_str(self.crate_context.tcx.items,\n                                            associated_trait.ref_id),\n-                   *item.ident);\n+                   *item.ident};\n \n             let implementation = self.create_impl_from_item(item);\n             self.add_trait_method(def_id_of_def(def), implementation);\n@@ -368,10 +368,10 @@ class CoherenceChecker {\n                         let privileged_types =\n                             self.gather_privileged_types(module.items);\n                         for privileged_types.each |privileged_type| {\n-                            #debug(\"(checking privileged scopes) entering \\\n+                            debug!{\"(checking privileged scopes) entering \\\n                                     privileged scope of %d:%d\",\n                                    privileged_type.crate,\n-                                   privileged_type.node);\n+                                   privileged_type.node};\n \n                             self.privileged_types.insert(privileged_type, ());\n                         }\n@@ -584,11 +584,11 @@ class CoherenceChecker {\n                                          self_type.ty) {\n                     none {\n                         let session = self.crate_context.tcx.sess;\n-                        session.bug(#fmt(\"no base type for external impl \\\n+                        session.bug(fmt!{\"no base type for external impl \\\n                                           with no trait: %s (type %s)!\",\n                                          *implementation.ident,\n                                          ty_to_str(self.crate_context.tcx,\n-                                                   self_type.ty)));\n+                                                   self_type.ty)});\n                     }\n                     some(_) {\n                         // Nothing to do."}, {"sha": "83bc02a3755234a634df9e536d0e9c6f8c4746bf", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -92,8 +92,8 @@ impl of ast_conv for @crate_ctxt {\n                 ty_of_foreign_item(self, foreign_item)\n               }\n               x {\n-                self.tcx.sess.bug(#fmt[\"unexpected sort of item \\\n-                                        in get_item_ty(): %?\", x]);\n+                self.tcx.sess.bug(fmt!{\"unexpected sort of item \\\n+                                        in get_item_ty(): %?\", x});\n               }\n             }\n         }\n@@ -194,11 +194,11 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n     }\n \n     if vec::len(impl_m.fty.inputs) != vec::len(if_m.fty.inputs) {\n-        tcx.sess.span_err(sp,#fmt[\"method `%s` has %u parameters \\\n+        tcx.sess.span_err(sp,fmt!{\"method `%s` has %u parameters \\\n                                    but the trait has %u\",\n                                   *if_m.ident,\n                                   vec::len(impl_m.fty.inputs),\n-                                  vec::len(if_m.fty.inputs)]);\n+                                  vec::len(if_m.fty.inputs)});\n         ret;\n     }\n \n@@ -258,9 +258,9 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n           some({mty: m, id, span}) {\n             if m.purity != if_m.purity {\n                 ccx.tcx.sess.span_err(\n-                    span, #fmt[\"method `%s`'s purity does \\\n+                    span, fmt!{\"method `%s`'s purity does \\\n                                 not match the trait method's \\\n-                                purity\", *m.ident]);\n+                                purity\", *m.ident});\n             }\n             compare_impl_method(\n                 ccx.tcx, span, m, vec::len(tps),\n@@ -272,7 +272,7 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n \n             tcx.sess.span_err(\n                 a_trait_ty.path.span,\n-                #fmt[\"missing method `%s`\", *if_m.ident]);\n+                fmt!{\"missing method `%s`\", *if_m.ident});\n           }\n         } // alt\n     } // |if_m|\n@@ -316,7 +316,7 @@ fn convert_methods(ccx: @crate_ctxt,\n fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.contains_key(it.id);\n-    #debug[\"convert: item %s with id %d rp %b\", *it.ident, it.id, rp];\n+    debug!{\"convert: item %s with id %d rp %b\", *it.ident, it.id, rp};\n     alt it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) {}\n@@ -341,8 +341,8 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n       }\n       ast::item_trait(*) {\n         let tpt = ty_of_item(ccx, it);\n-        #debug[\"item_trait(it.id=%d, tpt.ty=%s)\",\n-               it.id, ty_to_str(tcx, tpt.ty)];\n+        debug!{\"item_trait(it.id=%d, tpt.ty=%s)\",\n+               it.id, ty_to_str(tcx, tpt.ty)};\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         ensure_trait_methods(ccx, it.id);\n       }\n@@ -501,8 +501,8 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         let tpt = {bounds: bounds,\n                    rp: false, // functions do not have a self\n                    ty: ty::mk_fn(ccx.tcx, tofd)};\n-        #debug[\"type of %s (id %d) is %s\",\n-               *it.ident, it.id, ty_to_str(tcx, tpt.ty)];\n+        debug!{\"type of %s (id %d) is %s\",\n+               *it.ident, it.id, ty_to_str(tcx, tpt.ty)};\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }"}, {"sha": "e3075ff005844ad74ccb8e8e5a295051f0672525", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -231,7 +231,7 @@ fn intersection(a: int_ty_set, b: int_ty_set) -> int_ty_set {\n \n fn single_type_contained_in(tcx: ty::ctxt, a: int_ty_set) ->\n     option<ty::t> {\n-    #debug[\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10u)];\n+    debug!{\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10u)};\n \n     if *a == INT_TY_SET_i8    { ret some(ty::mk_i8(tcx)); }\n     if *a == INT_TY_SET_u8    { ret some(ty::mk_u8(tcx)); }\n@@ -345,8 +345,8 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n       cyclic_ty(_) { ~\"cyclic type of infinite size\" }\n       unresolved_region(_) { ~\"unconstrained region\" }\n       region_var_bound_by_region_var(r1, r2) {\n-        #fmt[\"region var %? bound by another region var %?; this is \\\n-              a bug in rustc\", r1, r2]\n+        fmt!{\"region var %? bound by another region var %?; this is \\\n+              a bug in rustc\", r1, r2}\n       }\n     }\n }\n@@ -365,38 +365,38 @@ fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n                  borrowings: dvec()})}\n \n fn mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    debug!{\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n     indent(|| cx.commit(|| sub(cx).tys(a, b) ) ).to_ures()\n }\n \n fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    debug!{\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n     indent(|| cx.probe(|| sub(cx).tys(a, b) ) ).to_ures()\n }\n \n fn mk_subr(cx: infer_ctxt, a: ty::region, b: ty::region) -> ures {\n-    #debug[\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    debug!{\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n     indent(|| cx.commit(|| sub(cx).regions(a, b) ) ).to_ures()\n }\n \n fn mk_eqty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    #debug[\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)];\n+    debug!{\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx)};\n     indent(|| cx.commit(|| cx.eq_tys(a, b) ) ).to_ures()\n }\n \n fn mk_assignty(cx: infer_ctxt, anmnt: assignment,\n                a: ty::t, b: ty::t) -> ures {\n-    #debug[\"mk_assignty(%? / %s <: %s)\",\n-           anmnt, a.to_str(cx), b.to_str(cx)];\n+    debug!{\"mk_assignty(%? / %s <: %s)\",\n+           anmnt, a.to_str(cx), b.to_str(cx)};\n     indent(|| cx.commit(||\n         cx.assign_tys(anmnt, a, b)\n     ) ).to_ures()\n }\n \n fn can_mk_assignty(cx: infer_ctxt, anmnt: assignment,\n                 a: ty::t, b: ty::t) -> ures {\n-    #debug[\"can_mk_assignty(%? / %s <: %s)\",\n-           anmnt, a.to_str(cx), b.to_str(cx)];\n+    debug!{\"can_mk_assignty(%? / %s <: %s)\",\n+           anmnt, a.to_str(cx), b.to_str(cx)};\n \n     // FIXME(#2593)---this will not unroll any entries we make in the\n     // borrowings table.  But this is OK for the moment because this\n@@ -424,8 +424,8 @@ fn resolve_borrowings(cx: infer_ctxt) {\n     for cx.borrowings.each |item| {\n         alt resolve_region(cx, item.scope, resolve_all|force_all) {\n           ok(region) => {\n-            #debug[\"borrowing for expr %d resolved to region %?, mutbl %?\",\n-                   item.expr_id, region, item.mutbl];\n+            debug!{\"borrowing for expr %d resolved to region %?, mutbl %?\",\n+                   item.expr_id, region, item.mutbl};\n             cx.tcx.borrowings.insert(\n                 item.expr_id, {region: region, mutbl: item.mutbl});\n           }\n@@ -434,7 +434,7 @@ fn resolve_borrowings(cx: infer_ctxt) {\n             let str = fixup_err_to_str(e);\n             cx.tcx.sess.span_err(\n                 item.span,\n-                #fmt[\"could not resolve lifetime for borrow: %s\", str]);\n+                fmt!{\"could not resolve lifetime for borrow: %s\", str});\n           }\n         }\n     }\n@@ -509,9 +509,9 @@ impl<V:copy to_str> of to_str for bound<V> {\n \n impl<T:copy to_str> of to_str for bounds<T> {\n     fn to_str(cx: infer_ctxt) -> ~str {\n-        #fmt[\"{%s <: %s}\",\n+        fmt!{\"{%s <: %s}\",\n              self.lb.to_str(cx),\n-             self.ub.to_str(cx)]\n+             self.ub.to_str(cx)}\n     }\n }\n \n@@ -526,9 +526,9 @@ impl of to_str for int_ty_set {\n impl<V:copy vid, T:copy to_str> of to_str for var_value<V,T> {\n     fn to_str(cx: infer_ctxt) -> ~str {\n         alt self {\n-          redirect(vid) { #fmt(\"redirect(%s)\", vid.to_str()) }\n-          root(pt, rk) { #fmt(\"root(%s, %s)\", pt.to_str(cx),\n-                              uint::to_str(rk, 10u)) }\n+          redirect(vid) { fmt!{\"redirect(%s)\", vid.to_str()} }\n+          root(pt, rk) { fmt!{\"root(%s, %s)\", pt.to_str(cx),\n+                              uint::to_str(rk, 10u)} }\n         }\n     }\n }\n@@ -604,12 +604,12 @@ impl transaction_methods for infer_ctxt {\n         let rbl = self.rb.bindings.len();\n         let bl = self.borrowings.len();\n \n-        #debug[\"try(tvbl=%u, rbl=%u)\", tvbl, rbl];\n+        debug!{\"try(tvbl=%u, rbl=%u)\", tvbl, rbl};\n         let r <- f();\n         alt r {\n-          result::ok(_) { #debug[\"try--ok\"]; }\n+          result::ok(_) { debug!{\"try--ok\"}; }\n           result::err(_) {\n-            #debug[\"try--rollback\"];\n+            debug!{\"try--rollback\"};\n             rollback_to(self.tvb, tvbl);\n             rollback_to(self.rb, rbl);\n             while self.borrowings.len() != bl { self.borrowings.pop(); }\n@@ -709,8 +709,8 @@ impl unify_methods for infer_ctxt {\n         vec::push(vb.bindings, (vid, old_v));\n         vb.vals.insert(vid.to_uint(), new_v);\n \n-        #debug[\"Updating variable %s from %s to %s\",\n-               vid.to_str(), old_v.to_str(self), new_v.to_str(self)];\n+        debug!{\"Updating variable %s from %s to %s\",\n+               vid.to_str(), old_v.to_str(self), new_v.to_str(self)};\n     }\n \n     fn get<V:copy vid, T:copy>(\n@@ -720,7 +720,7 @@ impl unify_methods for infer_ctxt {\n         let vid_u = vid.to_uint();\n         alt vb.vals.find(vid_u) {\n           none {\n-            self.tcx.sess.bug(#fmt[\"failed lookup of vid `%u`\", vid_u]);\n+            self.tcx.sess.bug(fmt!{\"failed lookup of vid `%u`\", vid_u});\n           }\n           some(var_val) {\n             alt var_val {\n@@ -745,7 +745,7 @@ impl unify_methods for infer_ctxt {\n         a: bound<V>, b: bound<V>,\n         merge_op: fn(V,V) -> cres<V>) -> cres<bound<V>> {\n \n-        #debug[\"merge_bnd(%s,%s)\", a.to_str(self), b.to_str(self)];\n+        debug!{\"merge_bnd(%s,%s)\", a.to_str(self), b.to_str(self)};\n         let _r = indenter();\n \n         alt (a, b) {\n@@ -773,13 +773,13 @@ impl unify_methods for infer_ctxt {\n \n         let _r = indenter();\n         do self.merge_bnd(a.ub, b.ub, glb).chain |ub| {\n-            #debug[\"glb of ubs %s and %s is %s\",\n+            debug!{\"glb of ubs %s and %s is %s\",\n                    a.ub.to_str(self), b.ub.to_str(self),\n-                   ub.to_str(self)];\n+                   ub.to_str(self)};\n             do self.merge_bnd(a.lb, b.lb, lub).chain |lb| {\n-                #debug[\"lub of lbs %s and %s is %s\",\n+                debug!{\"lub of lbs %s and %s is %s\",\n                        a.lb.to_str(self), b.lb.to_str(self),\n-                       lb.to_str(self)];\n+                       lb.to_str(self)};\n                 ok({lb: lb, ub: ub})\n             }\n         }\n@@ -813,10 +813,10 @@ impl unify_methods for infer_ctxt {\n         //       A     \\ / A\n         //              B\n \n-        #debug[\"merge(%s,%s,%s)\",\n+        debug!{\"merge(%s,%s,%s)\",\n                v_id.to_str(),\n                a.to_str(self),\n-               b.to_str(self)];\n+               b.to_str(self)};\n \n         // First, relate the lower/upper bounds of A and B.\n         // Note that these relations *must* hold for us to\n@@ -830,9 +830,9 @@ impl unify_methods for infer_ctxt {\n         do self.merge_bnd(a.ub, b.ub, |x, y| x.glb(self, y) ).chain |ub| {\n         do self.merge_bnd(a.lb, b.lb, |x, y| x.lub(self, y) ).chain |lb| {\n             let bnds = {lb: lb, ub: ub};\n-            #debug[\"merge(%s): bnds=%s\",\n+            debug!{\"merge(%s): bnds=%s\",\n                    v_id.to_str(),\n-                   bnds.to_str(self)];\n+                   bnds.to_str(self)};\n \n             // the new bounds must themselves\n             // be relatable:\n@@ -855,9 +855,9 @@ impl unify_methods for infer_ctxt {\n         let a_bounds = nde_a.possible_types;\n         let b_bounds = nde_b.possible_types;\n \n-        #debug[\"vars(%s=%s <: %s=%s)\",\n+        debug!{\"vars(%s=%s <: %s=%s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n-               b_id.to_str(), b_bounds.to_str(self)];\n+               b_id.to_str(), b_bounds.to_str(self)};\n \n         if a_id == b_id { ret uok(); }\n \n@@ -883,20 +883,20 @@ impl unify_methods for infer_ctxt {\n         // Make the node with greater rank the parent of the node with\n         // smaller rank.\n         if nde_a.rank > nde_b.rank {\n-            #debug[\"vars(): a has smaller rank\"];\n+            debug!{\"vars(): a has smaller rank\"};\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n             self.set(vb, b_id, redirect(a_id));\n             self.set_var_to_merged_bounds(\n                 vb, a_id, a_bounds, b_bounds, nde_a.rank).then(|| uok() )\n         } else if nde_a.rank < nde_b.rank {\n-            #debug[\"vars(): b has smaller rank\"];\n+            debug!{\"vars(): b has smaller rank\"};\n             // b has greater rank, so a should redirect to b.\n             self.set(vb, a_id, redirect(b_id));\n             self.set_var_to_merged_bounds(\n                 vb, b_id, a_bounds, b_bounds, nde_b.rank).then(|| uok() )\n         } else {\n-            #debug[\"vars(): a and b have equal rank\"];\n+            debug!{\"vars(): a and b have equal rank\"};\n             assert nde_a.rank == nde_b.rank;\n             // If equal, just redirect one to the other and increment\n             // the other's rank.  We choose arbitrarily to redirect b\n@@ -932,18 +932,18 @@ impl unify_methods for infer_ctxt {\n \n         // Rank optimization\n         if nde_a.rank > nde_b.rank {\n-            #debug[\"vars_integral(): a has smaller rank\"];\n+            debug!{\"vars_integral(): a has smaller rank\"};\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n             self.set(vb, a_id, root(intersection, nde_a.rank));\n             self.set(vb, b_id, redirect(a_id));\n         } else if nde_a.rank < nde_b.rank {\n-            #debug[\"vars_integral(): b has smaller rank\"];\n+            debug!{\"vars_integral(): b has smaller rank\"};\n             // b has greater rank, so a should redirect to b.\n             self.set(vb, b_id, root(intersection, nde_b.rank));\n             self.set(vb, a_id, redirect(b_id));\n         } else {\n-            #debug[\"vars_integral(): a and b have equal rank\"];\n+            debug!{\"vars_integral(): a and b have equal rank\"};\n             assert nde_a.rank == nde_b.rank;\n             // If equal, just redirect one to the other and increment\n             // the other's rank.  We choose arbitrarily to redirect b\n@@ -963,9 +963,9 @@ impl unify_methods for infer_ctxt {\n         let a_id = nde_a.root;\n         let a_bounds = nde_a.possible_types;\n \n-        #debug[\"vart(%s=%s <: %s)\",\n+        debug!{\"vart(%s=%s <: %s)\",\n                a_id.to_str(), a_bounds.to_str(self),\n-               b.to_str(self)];\n+               b.to_str(self)};\n         let b_bounds = {lb: none, ub: some(b)};\n         self.set_var_to_merged_bounds(vb, a_id, a_bounds, b_bounds,\n                                       nde_a.rank)\n@@ -1000,9 +1000,9 @@ impl unify_methods for infer_ctxt {\n         let b_id = nde_b.root;\n         let b_bounds = nde_b.possible_types;\n \n-        #debug[\"tvar(%s <: %s=%s)\",\n+        debug!{\"tvar(%s <: %s=%s)\",\n                a.to_str(self),\n-               b_id.to_str(), b_bounds.to_str(self)];\n+               b_id.to_str(), b_bounds.to_str(self)};\n         self.set_var_to_merged_bounds(vb, b_id, a_bounds, b_bounds,\n                                       nde_b.rank)\n     }\n@@ -1030,7 +1030,7 @@ impl unify_methods for infer_ctxt {\n     fn bnds<T:copy to_str st>(\n         a: bound<T>, b: bound<T>) -> ures {\n \n-        #debug(\"bnds(%s <: %s)\", a.to_str(self), b.to_str(self));\n+        debug!{\"bnds(%s <: %s)\", a.to_str(self), b.to_str(self)};\n         do indent {\n             alt (a, b) {\n               (none, none) |\n@@ -1060,8 +1060,8 @@ impl unify_methods for infer_ctxt {\n     }\n \n     fn eq_regions(a: ty::region, b: ty::region) -> ures {\n-        #debug[\"eq_regions(%s, %s)\",\n-               a.to_str(self), b.to_str(self)];\n+        debug!{\"eq_regions(%s, %s)\",\n+               a.to_str(self), b.to_str(self)};\n         do indent {\n             do self.sub_regions(a, b).then {\n                 self.sub_regions(b, a)\n@@ -1141,9 +1141,9 @@ impl methods for resolve_state {\n     fn resolve_type_chk(typ: ty::t) -> fres<ty::t> {\n         self.err = none;\n \n-        #debug[\"Resolving %s (modes=%x)\",\n+        debug!{\"Resolving %s (modes=%x)\",\n                ty_to_str(self.infcx.tcx, typ),\n-               self.modes];\n+               self.modes};\n \n         // n.b. This is a hokey mess because the current fold doesn't\n         // allow us to pass back errors in any useful way.\n@@ -1153,9 +1153,9 @@ impl methods for resolve_state {\n         assert vec::is_empty(self.v_seen);\n         alt self.err {\n           none {\n-            #debug[\"Resolved to %s (modes=%x)\",\n+            debug!{\"Resolved to %s (modes=%x)\",\n                    ty_to_str(self.infcx.tcx, rty),\n-                   self.modes];\n+                   self.modes};\n             ret ok(rty);\n           }\n           some(e) { ret err(e); }\n@@ -1172,7 +1172,7 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_type(typ: ty::t) -> ty::t {\n-        #debug(\"resolve_type(%s)\", typ.to_str(self.infcx));\n+        debug!{\"resolve_type(%s)\", typ.to_str(self.infcx)};\n         indent(fn&() -> ty::t {\n             if !ty::type_needs_infer(typ) { ret typ; }\n \n@@ -1201,7 +1201,7 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_nested_tvar(typ: ty::t) -> ty::t {\n-        #debug(\"Resolve_if_deep(%s)\", typ.to_str(self.infcx));\n+        debug!{\"Resolve_if_deep(%s)\", typ.to_str(self.infcx)};\n         if !self.should(resolve_nested_tvar) {\n             typ\n         } else {\n@@ -1210,7 +1210,7 @@ impl methods for resolve_state {\n     }\n \n     fn resolve_region(orig: ty::region) -> ty::region {\n-        #debug(\"Resolve_region(%s)\", orig.to_str(self.infcx));\n+        debug!{\"Resolve_region(%s)\", orig.to_str(self.infcx)};\n         alt orig {\n           ty::re_var(rid) { self.resolve_region_var(rid) }\n           _ { orig }\n@@ -1372,8 +1372,8 @@ impl assignment for infer_ctxt {\n             }\n         }\n \n-        #debug[\"assign_tys(anmnt=%?, %s -> %s)\",\n-               anmnt, a.to_str(self), b.to_str(self)];\n+        debug!{\"assign_tys(anmnt=%?, %s -> %s)\",\n+               anmnt, a.to_str(self), b.to_str(self)};\n         let _r = indenter();\n \n         alt (ty::get(a).struct, ty::get(b).struct) {\n@@ -1419,9 +1419,9 @@ impl assignment for infer_ctxt {\n         a: ty::t, b: ty::t,\n         a_bnd: option<ty::t>, b_bnd: option<ty::t>) -> ures {\n \n-        #debug[\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n+        debug!{\"assign_tys_or_sub(anmnt=%?, %s -> %s, %s -> %s)\",\n                anmnt, a.to_str(self), b.to_str(self),\n-               a_bnd.to_str(self), b_bnd.to_str(self)];\n+               a_bnd.to_str(self), b_bnd.to_str(self)};\n         let _r = indenter();\n \n         fn is_borrowable(v: ty::vstore) -> bool {\n@@ -1475,22 +1475,22 @@ impl assignment for infer_ctxt {\n                       m: ast::mutability,\n                       r_b: ty::region) -> ures {\n \n-        #debug[\"crosspollinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n+        debug!{\"crosspollinate(anmnt=%?, a=%s, nr_b=%s, r_b=%s)\",\n                anmnt, a.to_str(self), nr_b.to_str(self),\n-               r_b.to_str(self)];\n+               r_b.to_str(self)};\n \n         do indent {\n             do self.sub_tys(a, nr_b).then {\n                 // Create a fresh region variable `r_a` with the given\n                 // borrow bounds:\n                 let r_a = self.next_region_var_with_scope_lb(anmnt.borrow_lb);\n \n-                #debug[\"anmnt=%?\", anmnt];\n+                debug!{\"anmnt=%?\", anmnt};\n                 do sub(self).contraregions(r_a, r_b).chain |_r| {\n                     // if successful, add an entry indicating that\n                     // borrowing occurred\n-                    #debug[\"borrowing expression #%?, scope=%?, m=%?\",\n-                           anmnt, r_a, m];\n+                    debug!{\"borrowing expression #%?, scope=%?, m=%?\",\n+                           anmnt, r_a, m};\n                     self.borrowings.push({expr_id: anmnt.expr_id,\n                                           span: anmnt.span,\n                                           scope: r_a,\n@@ -1596,10 +1596,10 @@ fn super_substs<C:combine>(\n             // consistently have a region parameter or not have a\n             // region parameter.\n             infcx.tcx.sess.bug(\n-                #fmt[\"substitution a had opt_region %s and \\\n+                fmt!{\"substitution a had opt_region %s and \\\n                       b had opt_region %s\",\n                      a.to_str(infcx),\n-                     b.to_str(infcx)]);\n+                     b.to_str(infcx)});\n           }\n         }\n     }\n@@ -1751,10 +1751,10 @@ fn super_tys<C:combine>(\n       (ty::ty_var(_), _) |\n       (_, ty::ty_var(_)) {\n         tcx.sess.bug(\n-            #fmt[\"%s: bot and var types should have been handled (%s,%s)\",\n+            fmt!{\"%s: bot and var types should have been handled (%s,%s)\",\n                  self.tag(),\n                  a.to_str(self.infcx()),\n-                 b.to_str(self.infcx())]);\n+                 b.to_str(self.infcx())});\n       }\n \n       // Have to handle these first\n@@ -1904,10 +1904,10 @@ impl of combine for sub {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        #debug[\"%s.regions(%s, %s)\",\n+        debug!{\"%s.regions(%s, %s)\",\n                self.tag(),\n                a.to_str(self.infcx()),\n-               b.to_str(self.infcx())];\n+               b.to_str(self.infcx())};\n         do indent {\n             alt (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) {\n@@ -1935,7 +1935,7 @@ impl of combine for sub {\n     }\n \n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n-        #debug(\"mts(%s <: %s)\", a.to_str(*self), b.to_str(*self));\n+        debug!{\"mts(%s <: %s)\", a.to_str(*self), b.to_str(*self)};\n \n         if a.mutbl != b.mutbl && b.mutbl != m_const {\n             ret err(ty::terr_mutability);\n@@ -1973,8 +1973,8 @@ impl of combine for sub {\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        #debug(\"%s.tys(%s, %s)\", self.tag(),\n-               a.to_str(*self), b.to_str(*self));\n+        debug!{\"%s.tys(%s, %s)\", self.tag(),\n+               a.to_str(*self), b.to_str(*self)};\n         if a == b { ret ok(a); }\n         do indent {\n             alt (ty::get(a).struct, ty::get(b).struct) {\n@@ -2015,9 +2015,9 @@ impl of combine for sub {\n                 // for it.  The only thing we're doing with `br` here is\n                 // using it in the debug message.\n                 let rvar = self.infcx().next_region_var_nb();\n-                #debug[\"Bound region %s maps to %s\",\n+                debug!{\"Bound region %s maps to %s\",\n                        bound_region_to_str(self.tcx, br),\n-                       region_to_str(self.tcx, rvar)];\n+                       region_to_str(self.tcx, rvar)};\n                 rvar\n             }\n         };\n@@ -2078,10 +2078,10 @@ impl of combine for lub {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx().tcx;\n \n-        #debug(\"%s.mts(%s, %s)\",\n+        debug!{\"%s.mts(%s, %s)\",\n                self.tag(),\n                mt_to_str(tcx, a),\n-               mt_to_str(tcx, b));\n+               mt_to_str(tcx, b)};\n \n         let m = if a.mutbl == b.mutbl {\n             a.mutbl\n@@ -2150,10 +2150,10 @@ impl of combine for lub {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        #debug[\"%s.regions(%?, %?)\",\n+        debug!{\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.to_str(self.infcx()),\n-               b.to_str(self.infcx())];\n+               b.to_str(self.infcx())};\n \n         do indent {\n             alt (a, b) {\n@@ -2259,10 +2259,10 @@ impl of combine for glb {\n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx().tcx;\n \n-        #debug(\"%s.mts(%s, %s)\",\n+        debug!{\"%s.mts(%s, %s)\",\n                self.tag(),\n                mt_to_str(tcx, a),\n-               mt_to_str(tcx, b));\n+               mt_to_str(tcx, b)};\n \n         alt (a.mutbl, b.mutbl) {\n           // If one side or both is mut, then the GLB must use\n@@ -2347,10 +2347,10 @@ impl of combine for glb {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        #debug[\"%s.regions(%?, %?)\",\n+        debug!{\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.to_str(self.infcx()),\n-               b.to_str(self.infcx())];\n+               b.to_str(self.infcx())};\n \n         do indent {\n             alt (a, b) {\n@@ -2486,9 +2486,9 @@ impl of lattice_ops for glb {\n fn lattice_tys<L:lattice_ops combine>(\n     self: L, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n-    #debug(\"%s.lattice_tys(%s, %s)\", self.tag(),\n+    debug!{\"%s.lattice_tys(%s, %s)\", self.tag(),\n            a.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n+           b.to_str(self.infcx())};\n     if a == b { ret ok(a); }\n     do indent {\n         alt (ty::get(a).struct, ty::get(b).struct) {\n@@ -2536,11 +2536,11 @@ fn lattice_rvars<L:lattice_ops combine>(\n \n       _ {\n         self.infcx().tcx.sess.bug(\n-            #fmt[\"%s: lattice_rvars invoked with a=%s and b=%s, \\\n+            fmt!{\"%s: lattice_rvars invoked with a=%s and b=%s, \\\n                   neither of which are region variables\",\n                  self.tag(),\n                  a.to_str(self.infcx()),\n-                 b.to_str(self.infcx())]);\n+                 b.to_str(self.infcx())});\n       }\n     }\n }\n@@ -2562,10 +2562,10 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     let a_bounds = nde_a.possible_types;\n     let b_bounds = nde_b.possible_types;\n \n-    #debug[\"%s.lattice_vars(%s=%s <: %s=%s)\",\n+    debug!{\"%s.lattice_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n            a_vid.to_str(), a_bounds.to_str(self.infcx()),\n-           b_vid.to_str(), b_bounds.to_str(self.infcx())];\n+           b_vid.to_str(), b_bounds.to_str(self.infcx())};\n \n     if a_vid == b_vid {\n         ret ok(a_t);\n@@ -2601,21 +2601,21 @@ fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    #debug[\"%s.lattice_vart(%s=%s <: %s)\",\n+    debug!{\"%s.lattice_vart(%s=%s <: %s)\",\n            self.tag(),\n            a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx())];\n+           b.to_str(self.infcx())};\n \n     alt self.bnd(a_bounds) {\n       some(a_bnd) {\n         // If a has an upper bound, return the LUB(a.ub, b)\n-        #debug[\"bnd=some(%s)\", a_bnd.to_str(self.infcx())];\n+        debug!{\"bnd=some(%s)\", a_bnd.to_str(self.infcx())};\n         ret c_ts(a_bnd, b);\n       }\n       none {\n         // If a does not have an upper bound, make b the upper bound of a\n         // and then return b.\n-        #debug[\"bnd=none\"];\n+        debug!{\"bnd=none\"};\n         let a_bounds = self.with_bnd(a_bounds, b);\n         do self.infcx().bnds(a_bounds.lb, a_bounds.ub).then {\n             self.infcx().set(vb, a_id, root(a_bounds,"}, {"sha": "b9f4d3d76aec98213792c5853ea45cf45dc05dff", "filename": "src/rustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fcommon.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -8,20 +8,20 @@ import syntax::print;\n fn indent<R>(op: fn() -> R) -> R {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`\n     // to make debug output more readable.\n-    #debug[\">>\"];\n+    debug!{\">>\"};\n     let r <- op();\n-    #debug[\"<< (Result = %?)\", r];\n+    debug!{\"<< (Result = %?)\", r};\n     ret r;\n }\n \n class _indenter {\n     let _i: ();\n     new(_i: ()) { self._i = (); }\n-    drop { #debug[\"<<\"]; }\n+    drop { debug!{\"<<\"}; }\n }\n \n fn indenter() -> _indenter {\n-    #debug[\">>\"];\n+    debug!{\">>\"};\n     _indenter(())\n }\n "}, {"sha": "bf97df5fd5f65e5bcb81c86924cb19a96383a319", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -22,15 +22,15 @@ import driver::session::session;\n fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n     alt br {\n       br_anon                        => { ~\"&\" }\n-      br_named(str)                  => { #fmt[\"&%s\", *str] }\n+      br_named(str)                  => { fmt!{\"&%s\", *str} }\n       br_self if cx.sess.ppregions() => { ~\"&<self>\" }\n       br_self                        => { ~\"&self\" }\n \n       // FIXME(#3011) -- even if this arm is removed, exhaustiveness checking\n       // does not fail\n       br_cap_avoid(id, br) => {\n         if cx.sess.ppregions() {\n-            #fmt[\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br)]\n+            fmt!{\"br_cap_avoid(%?, %s)\", id, bound_region_to_str(cx, *br)}\n         } else {\n             bound_region_to_str(cx, *br)\n         }\n@@ -41,58 +41,58 @@ fn bound_region_to_str(cx: ctxt, br: bound_region) -> ~str {\n fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n     alt cx.items.find(node_id) {\n       some(ast_map::node_block(blk)) {\n-        #fmt(\"<block at %s>\",\n-             codemap::span_to_str(blk.span, cx.sess.codemap))\n+        fmt!{\"<block at %s>\",\n+             codemap::span_to_str(blk.span, cx.sess.codemap)}\n       }\n       some(ast_map::node_expr(expr)) {\n         alt expr.node {\n           ast::expr_call(*) {\n-            #fmt(\"<call at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+            fmt!{\"<call at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n           }\n           ast::expr_alt(*) {\n-            #fmt(\"<alt at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+            fmt!{\"<alt at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n           }\n           ast::expr_assign_op(*) |\n           ast::expr_field(*) |\n           ast::expr_unary(*) |\n           ast::expr_binary(*) |\n           ast::expr_index(*) {\n-            #fmt(\"<method at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+            fmt!{\"<method at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n           }\n           _ {\n-            #fmt(\"<expression at %s>\",\n-                 codemap::span_to_str(expr.span, cx.sess.codemap))\n+            fmt!{\"<expression at %s>\",\n+                 codemap::span_to_str(expr.span, cx.sess.codemap)}\n           }\n         }\n       }\n       none {\n-        #fmt[\"<unknown-%d>\", node_id]\n+        fmt!{\"<unknown-%d>\", node_id}\n       }\n       _ { cx.sess.bug(\n-          #fmt[\"re_scope refers to %s\",\n-               ast_map::node_id_to_str(cx.items, node_id)]) }\n+          fmt!{\"re_scope refers to %s\",\n+               ast_map::node_id_to_str(cx.items, node_id)}) }\n     }\n }\n \n fn region_to_str(cx: ctxt, region: region) -> ~str {\n     alt region {\n-      re_scope(node_id) { #fmt[\"&%s\", re_scope_id_to_str(cx, node_id)] }\n+      re_scope(node_id) { fmt!{\"&%s\", re_scope_id_to_str(cx, node_id)} }\n       re_bound(br) { bound_region_to_str(cx, br) }\n       re_free(id, br) {\n         if cx.sess.ppregions() {\n             // For debugging, this version is sometimes helpful:\n-            #fmt[\"{%d} %s\", id, bound_region_to_str(cx, br)]\n+            fmt!{\"{%d} %s\", id, bound_region_to_str(cx, br)}\n         } else {\n             // But this version is what the user expects to see:\n             bound_region_to_str(cx, br)\n         }\n       }\n \n       // These two should not be seen by end-users (very often, anyhow):\n-      re_var(id)    { #fmt(\"&%s\", id.to_str()) }\n+      re_var(id)    { fmt!{\"&%s\", id.to_str()} }\n       re_static     { ~\"&static\" }\n     }\n }\n@@ -108,7 +108,7 @@ fn mt_to_str(cx: ctxt, m: mt) -> ~str {\n \n fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n     alt vs {\n-      ty::vstore_fixed(n) { #fmt[\"%u\", n] }\n+      ty::vstore_fixed(n) { fmt!{\"%u\", n} }\n       ty::vstore_uniq { ~\"~\" }\n       ty::vstore_box { ~\"@\" }\n       ty::vstore_slice(r) { region_to_str(cx, r) }\n@@ -118,9 +118,9 @@ fn vstore_to_str(cx: ctxt, vs: ty::vstore) -> ~str {\n fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     alt vs {\n       ty::vstore_fixed(_) {\n-        #fmt[\"%s/%s\", ty, vstore_to_str(cx, vs)]\n+        fmt!{\"%s/%s\", ty, vstore_to_str(cx, vs)}\n       }\n-      _ { #fmt[\"%s%s\", vstore_to_str(cx, vs), ty] }\n+      _ { fmt!{\"%s%s\", vstore_to_str(cx, vs), ty} }\n     }\n }\n \n@@ -243,7 +243,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         parameterized(cx, base, substs.self_r, substs.tps)\n       }\n       ty_evec(mt, vs) {\n-        vstore_ty_to_str(cx, #fmt[\"[%s]\", mt_to_str(cx, mt)], vs)\n+        vstore_ty_to_str(cx, fmt!{\"[%s]\", mt_to_str(cx, mt)}, vs)\n       }\n       ty_estr(vs) { vstore_ty_to_str(cx, ~\"str\", vs) }\n       ty_opaque_box { ~\"@?\" }\n@@ -261,15 +261,15 @@ fn parameterized(cx: ctxt,\n     let r_str = alt self_r {\n       none { ~\"\" }\n       some(r) {\n-        #fmt[\"/%s\", region_to_str(cx, r)]\n+        fmt!{\"/%s\", region_to_str(cx, r)}\n       }\n     };\n \n     if vec::len(tps) > 0u {\n         let strs = vec::map(tps, |t| ty_to_str(cx, t) );\n-        #fmt[\"%s%s<%s>\", base, r_str, str::connect(strs, ~\",\")]\n+        fmt!{\"%s%s<%s>\", base, r_str, str::connect(strs, ~\",\")}\n     } else {\n-        #fmt[\"%s%s\", base, r_str]\n+        fmt!{\"%s%s\", base, r_str}\n     }\n }\n "}, {"sha": "97f6ae2e81fd810f197583bd7256d7e67adce1ae", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -51,7 +51,7 @@ fn doc_meta(\n \n     if vec::is_not_empty(doc_metas) {\n         if vec::len(doc_metas) != 1u {\n-            #warn(\"ignoring %u doc attributes\", vec::len(doc_metas) - 1u);\n+            warn!{\"ignoring %u doc attributes\", vec::len(doc_metas) - 1u};\n         }\n         some(doc_metas[0])\n     } else {"}, {"sha": "c1af9d8ce166e0a501e8810b867a29c9a688881e", "filename": "src/rustdoc/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fconfig.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -62,7 +62,7 @@ fn usage() {\n     println(~\"Usage: rustdoc ~[options] <cratefile>\\n\");\n     println(~\"Options:\\n\");\n     for opts().each |opt| {\n-        println(#fmt(\"    %s\", opt.second()));\n+        println(fmt!{\"    %s\", opt.second()});\n     }\n     println(~\"\");\n }\n@@ -178,15 +178,15 @@ fn parse_output_format(output_format: ~str) -> result<output_format, ~str> {\n     alt output_format {\n       ~\"markdown\" { result::ok(markdown) }\n       ~\"html\" { result::ok(pandoc_html) }\n-      _ { result::err(#fmt(\"unknown output format '%s'\", output_format)) }\n+      _ { result::err(fmt!{\"unknown output format '%s'\", output_format}) }\n     }\n }\n \n fn parse_output_style(output_style: ~str) -> result<output_style, ~str> {\n     alt output_style {\n       ~\"doc-per-crate\" { result::ok(doc_per_crate) }\n       ~\"doc-per-mod\" { result::ok(doc_per_mod) }\n-      _ { result::err(#fmt(\"unknown output style '%s'\", output_style)) }\n+      _ { result::err(fmt!{\"unknown output style '%s'\", output_style}) }\n     }\n }\n \n@@ -213,7 +213,7 @@ fn maybe_find_pandoc(\n \n     let pandoc = do vec::find(possible_pandocs) |pandoc| {\n         let output = program_output(pandoc, ~[~\"--version\"]);\n-        #debug(\"testing pandoc cmd %s: %?\", pandoc, output);\n+        debug!{\"testing pandoc cmd %s: %?\", pandoc, output};\n         output.status == 0\n     };\n "}, {"sha": "beed9c27602b65a1f7cc8e52bcf68c4609c1ac42", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -123,7 +123,7 @@ fn should_request_new_writer_for_each_page() {\n }\n \n fn write_title(ctxt: ctxt, page: doc::page) {\n-    ctxt.w.write_line(#fmt(\"%% %s\", make_title(page)));\n+    ctxt.w.write_line(fmt!{\"%% %s\", make_title(page)});\n     ctxt.w.write_line(~\"\");\n }\n \n@@ -175,7 +175,7 @@ fn write_header(ctxt: ctxt, lvl: hlvl, doc: doc::itemtag) {\n \n fn write_header_(ctxt: ctxt, lvl: hlvl, title: ~str) {\n     let hashes = str::from_chars(vec::from_elem(lvl as uint, '#'));\n-    ctxt.w.write_line(#fmt(\"%s %s\", hashes, title));\n+    ctxt.w.write_line(fmt!{\"%s %s\", hashes, title});\n     ctxt.w.write_line(~\"\");\n }\n \n@@ -233,7 +233,7 @@ fn header_name(doc: doc::itemtag) -> ~str {\n             }\n             trait_part += trait_type;\n         }\n-        #fmt(\"%s%s for %s\", doc.name(), trait_part, self_ty)\n+        fmt!{\"%s%s for %s\", doc.name(), trait_part, self_ty}\n       }\n       _ {\n         doc.name()\n@@ -246,7 +246,7 @@ fn header_text(doc: doc::itemtag) -> ~str {\n }\n \n fn header_text_(kind: ~str, name: ~str) -> ~str {\n-    #fmt(\"%s `%s`\", kind, name)\n+    fmt!{\"%s `%s`\", kind, name}\n }\n \n fn write_crate(\n@@ -385,10 +385,10 @@ fn write_index(ctxt: ctxt, index: doc::index) {\n         let header = header_text_(entry.kind, entry.name);\n         let id = entry.link;\n         if option::is_some(entry.brief) {\n-            ctxt.w.write_line(#fmt(\"* [%s](%s) - %s\",\n-                                   header, id, option::get(entry.brief)));\n+            ctxt.w.write_line(fmt!{\"* [%s](%s) - %s\",\n+                                   header, id, option::get(entry.brief)});\n         } else {\n-            ctxt.w.write_line(#fmt(\"* [%s](%s)\", header, id));\n+            ctxt.w.write_line(fmt!{\"* [%s](%s)\", header, id});\n         }\n     }\n     ctxt.w.write_line(~\"\");\n@@ -492,7 +492,7 @@ fn write_sig(ctxt: ctxt, sig: option<~str>) {\n \n fn code_block_indent(s: ~str) -> ~str {\n     let lines = str::lines_any(s);\n-    let indented = vec::map(lines, |line| #fmt(\"    %s\", line) );\n+    let indented = vec::map(lines, |line| fmt!{\"    %s\", line} );\n     str::connect(indented, ~\"\\n\")\n }\n \n@@ -604,10 +604,10 @@ fn write_variant(ctxt: ctxt, doc: doc::variantdoc) {\n     let sig = option::get(doc.sig);\n     alt doc.desc {\n       some(desc) {\n-        ctxt.w.write_line(#fmt(\"* `%s` - %s\", sig, desc));\n+        ctxt.w.write_line(fmt!{\"* `%s` - %s\", sig, desc});\n       }\n       none {\n-        ctxt.w.write_line(#fmt(\"* `%s`\", sig));\n+        ctxt.w.write_line(fmt!{\"* `%s`\", sig});\n       }\n     }\n }\n@@ -761,7 +761,7 @@ mod test {\n     fn render(source: ~str) -> ~str {\n         let (srv, doc) = create_doc_srv(source);\n         let markdown = write_markdown_str_srv(srv, doc);\n-        #debug(\"markdown: %s\", markdown);\n+        debug!{\"markdown: %s\", markdown};\n         markdown\n     }\n \n@@ -774,23 +774,23 @@ mod test {\n             };\n \n             let doc = extract::from_srv(srv, ~\"\");\n-            #debug(\"doc (extract): %?\", doc);\n+            debug!{\"doc (extract): %?\", doc};\n             let doc = tystr_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (tystr): %?\", doc);\n+            debug!{\"doc (tystr): %?\", doc};\n             let doc = path_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (path): %?\", doc);\n+            debug!{\"doc (path): %?\", doc};\n             let doc = attr_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (attr): %?\", doc);\n+            debug!{\"doc (attr): %?\", doc};\n             let doc = desc_to_brief_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (desc_to_brief): %?\", doc);\n+            debug!{\"doc (desc_to_brief): %?\", doc};\n             let doc = unindent_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (unindent): %?\", doc);\n+            debug!{\"doc (unindent): %?\", doc};\n             let doc = sectionalize_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (trim): %?\", doc);\n+            debug!{\"doc (trim): %?\", doc};\n             let doc = trim_pass::mk_pass().f(srv, doc);\n-            #debug(\"doc (sectionalize): %?\", doc);\n+            debug!{\"doc (sectionalize): %?\", doc};\n             let doc = markdown_index_pass::mk_pass(config).f(srv, doc);\n-            #debug(\"doc (index): %?\", doc);\n+            debug!{\"doc (index): %?\", doc};\n             (srv, doc)\n         }\n     }"}, {"sha": "ffc8092846ccad3a83ccfb6f1d44d6a1d1e75476", "filename": "src/rustdoc/markdown_writer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_writer.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -90,8 +90,8 @@ fn pandoc_writer(\n     do generic_writer |markdown| {\n         import io::writer_util;\n \n-        #debug(\"pandoc cmd: %s\", pandoc_cmd);\n-        #debug(\"pandoc args: %s\", str::connect(pandoc_args, ~\" \"));\n+        debug!{\"pandoc cmd: %s\", pandoc_cmd};\n+        debug!{\"pandoc args: %s\", str::connect(pandoc_args, ~\" \")};\n \n         let pipe_in = os::pipe();\n         let pipe_out = os::pipe();\n@@ -123,10 +123,10 @@ fn pandoc_writer(\n         let stderr = comm::recv(stderr_po);\n \n         let status = run::waitpid(pid);\n-        #debug(\"pandoc result: %i\", status);\n+        debug!{\"pandoc result: %i\", status};\n         if status != 0 {\n-            #error(\"pandoc-out: %s\", stdout);\n-            #error(\"pandoc-err: %s\", stderr);\n+            error!{\"pandoc-out: %s\", stdout};\n+            error!{\"pandoc-err: %s\", stderr};\n             fail ~\"pandoc failed\";\n         }\n     }"}, {"sha": "13a5b03c5a675324d7a8183079883aa3102d149d", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -33,7 +33,7 @@ fn run_passes(\n \n     let mut passno = 0;\n     do vec::foldl(doc, passes) |doc, pass| {\n-        log(debug, #fmt(\"pass #%d\", passno));\n+        log(debug, fmt!{\"pass #%d\", passno});\n         passno += 1;\n         log(debug, doc);\n         do time(pass.name) {\n@@ -110,7 +110,7 @@ fn main(args: ~[~str]) {\n     let config = alt config::parse_config(args) {\n       result::ok(config) { config }\n       result::err(err) {\n-        io::println(#fmt(\"error: %s\", err));\n+        io::println(fmt!{\"error: %s\", err});\n         ret;\n       }\n     };\n@@ -122,7 +122,7 @@ fn time<T>(what: ~str, f: fn() -> T) -> T {\n     let start = std::time::precise_time_s();\n     let rv = f();\n     let end = std::time::precise_time_s();\n-    #info(\"time: %3.3f s    %s\", end - start, what);\n+    info!{\"time: %3.3f s    %s\", end - start, what};\n     ret rv;\n }\n "}, {"sha": "a6bbfae1df68c7e46f4b58f43b6f6ae8d0b26563", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -291,12 +291,12 @@ fn fold_type(\n                 ident: ident,\n                 node: ast::item_ty(ty, params), _\n               }, _) {\n-                some(#fmt(\n+                some(fmt!{\n                     \"type %s%s = %s\",\n                     *ident,\n                     pprust::typarams_to_str(params),\n                     pprust::ty_to_str(ty)\n-                ))\n+                })\n               }\n               _ { fail ~\"expected type\" }\n             }"}, {"sha": "43f57c41f88c641bfb95761d96ca36d9151e0321", "filename": "src/test/auxiliary/cci_class_4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_4.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@ class cat {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -22,12 +22,12 @@ class cat {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "95870b73c4d8f7e53845c070e27d9e104d1640ab", "filename": "src/test/auxiliary/cci_class_cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_cast.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@ class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ class cat : to_str {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "bb8dc68d7acec89f898a5aea83157802b14f24c0", "filename": "src/test/auxiliary/extern-crosscrate-source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fextern-crosscrate-source.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ extern mod rustrt {\n }\n \n fn fact(n: uint) -> uint {\n-    #debug(\"n = %?\", n);\n+    debug!{\"n = %?\", n};\n     rustrt::rust_dbg_call(cb, n)\n }\n "}, {"sha": "9b91918846c11bb760d3acdea0282feddcb3b5ff", "filename": "src/test/auxiliary/issue_2242_b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_b.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -5,5 +5,5 @@ use a;\n import a::to_str;\n \n impl of to_str for int {\n-    fn to_str() -> str { #fmt(\"%?\", self) }\n+    fn to_str() -> str { fmt!{\"%?\", self} }\n }"}, {"sha": "7dfcd9e33b003e90ae64759db6948e9e2fb2eb0a", "filename": "src/test/auxiliary/issue_2242_c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_2242_c.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,5 +6,5 @@ use a;\n import a::to_str;\n \n impl of to_str for bool {\n-    fn to_str() -> str { #fmt(\"%b\", self) }\n+    fn to_str() -> str { fmt!{\"%b\", self} }\n }"}, {"sha": "4542a23b854fe385e8e0ad8d5fe11851c3ed9645", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -30,10 +30,10 @@ fn port<T: send>() -> port<T> {\n class port_ptr<T:send> {\n    let po: *rust_port;\n    new(po: *rust_port) {\n-    #debug(\"in the port_ptr constructor\");\n+    debug!{\"in the port_ptr constructor\"};\n     self.po = po; }\n    drop unsafe {\n-    #debug(\"in the port_ptr destructor\");\n+    debug!{\"in the port_ptr destructor\"};\n        do task::unkillable {\n         let yield = 0u;\n         let yieldp = ptr::addr_of(yield);"}, {"sha": "0683624d5ffccd9d267abb642eacbf24d9a19b79", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -17,12 +17,12 @@ fn main(argv: ~[~str]) {\n \n     let tests = vec::view(argv, 1, argv.len());\n \n-    #bench[shift_push];\n-    #bench[read_line];\n-    #bench[str_set];\n-    #bench[vec_plus];\n-    #bench[vec_append];\n-    #bench[vec_push_all];\n+    bench!{shift_push};\n+    bench!{read_line};\n+    bench!{str_set};\n+    bench!{vec_plus};\n+    bench!{vec_append};\n+    bench!{vec_push_all};\n }\n \n fn maybe_run_test(argv: &[~str], name: ~str, test: fn()) {\n@@ -39,7 +39,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: fn()) {\n     test();\n     let stop = precise_time_s();\n \n-    io::println(#fmt(\"%s:\\t\\t%f ms\", name, (stop - start) * 1000f));\n+    io::println(fmt!{\"%s:\\t\\t%f ms\", name, (stop - start) * 1000f});\n }\n \n fn shift_push() {\n@@ -53,7 +53,7 @@ fn shift_push() {\n \n fn read_line() {\n     let path = path::connect(\n-        #env(\"CFG_SRC_DIR\"),\n+        env!{\"CFG_SRC_DIR\"},\n         ~\"src/test/bench/shootout-k-nucleotide.data\"\n     );\n "}, {"sha": "3a35e0c89ca472526eb0df6429fc5b8fcbb797d6", "filename": "src/test/bench/core-vec-append.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fcore-vec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-vec-append.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -48,18 +48,18 @@ fn main(args: ~[~str]) {\n     let rawf = raw as float;\n     let dvecf = dvec as float;\n     \n-    io::stdout().write_str(#fmt(\"Raw     : %? seconds\\n\", raw));\n-    io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/rawf));\n-    io::stdout().write_str(#fmt(\"\\n\"));\n-    io::stdout().write_str(#fmt(\"Dvec    : %? seconds\\n\", dvec));\n-    io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/dvecf));\n-    io::stdout().write_str(#fmt(\"\\n\"));\n+    io::stdout().write_str(fmt!{\"Raw     : %? seconds\\n\", raw});\n+    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/rawf});\n+    io::stdout().write_str(fmt!{\"\\n\"});\n+    io::stdout().write_str(fmt!{\"Dvec    : %? seconds\\n\", dvec});\n+    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/dvecf});\n+    io::stdout().write_str(fmt!{\"\\n\"});\n     \n     if dvec < raw {\n-        io::stdout().write_str(#fmt(\"Dvec is %f%% faster than raw\\n\",\n-                                    (rawf - dvecf) / rawf * 100.0));\n+        io::stdout().write_str(fmt!{\"Dvec is %f%% faster than raw\\n\",\n+                                    (rawf - dvecf) / rawf * 100.0});\n     } else {\n-        io::stdout().write_str(#fmt(\"Raw is %f%% faster than dvec\\n\",\n-                                    (dvecf - rawf) / dvecf * 100.0));\n+        io::stdout().write_str(fmt!{\"Raw is %f%% faster than dvec\\n\",\n+                                    (dvecf - rawf) / dvecf * 100.0});\n     }\n }"}, {"sha": "3e3f69372b45a95f30cad241daafba8f9c9dc07d", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -164,7 +164,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     let mut i = 0u;\n     while vec::any(colors, is_gray) {\n         // Do the BFS.\n-        log(info, #fmt(\"PBFS iteration %?\", i));\n+        log(info, fmt!{\"PBFS iteration %?\", i});\n         i += 1u;\n         colors = do colors.mapi() |i, c| {\n             let c : color = c;\n@@ -234,7 +234,7 @@ fn pbfs(&&graph: arc::arc<graph>, key: node_id) -> bfs_result {\n     let mut i = 0u;\n     while par::any(colors, is_gray) {\n         // Do the BFS.\n-        log(info, #fmt(\"PBFS iteration %?\", i));\n+        log(info, fmt!{\"PBFS iteration %?\", i});\n         i += 1u;\n         let old_len = colors.len();\n \n@@ -394,8 +394,8 @@ fn main(args: ~[~str]) {\n     let edges = make_edges(scale, 16u);\n     let stop = time::precise_time_s();\n \n-    io::stdout().write_line(#fmt(\"Generated %? edges in %? seconds.\",\n-                                 vec::len(edges), stop - start));\n+    io::stdout().write_line(fmt!{\"Generated %? edges in %? seconds.\",\n+                                 vec::len(edges), stop - start});\n \n     let start = time::precise_time_s();\n     let graph = make_graph(1u << scale, edges);\n@@ -404,9 +404,9 @@ fn main(args: ~[~str]) {\n     let mut total_edges = 0u;\n     vec::each(graph, |edges| { total_edges += edges.len(); true });\n \n-    io::stdout().write_line(#fmt(\"Generated graph with %? edges in %? seconds.\",\n+    io::stdout().write_line(fmt!{\"Generated graph with %? edges in %? seconds.\",\n                                  total_edges / 2u,\n-                                 stop - start));\n+                                 stop - start});\n \n     let mut total_seq = 0.0;\n     let mut total_par = 0.0;\n@@ -415,7 +415,7 @@ fn main(args: ~[~str]) {\n \n     do gen_search_keys(graph, num_keys).map() |root| {\n         io::stdout().write_line(~\"\");\n-        io::stdout().write_line(#fmt(\"Search key: %?\", root));\n+        io::stdout().write_line(fmt!{\"Search key: %?\", root});\n \n         if do_sequential {\n             let start = time::precise_time_s();\n@@ -425,17 +425,17 @@ fn main(args: ~[~str]) {\n             //total_seq += stop - start;\n \n             io::stdout().write_line(\n-                #fmt(\"Sequential BFS completed in %? seconds.\",\n-                     stop - start));\n+                fmt!{\"Sequential BFS completed in %? seconds.\",\n+                     stop - start});\n             \n             if do_validate {\n                 let start = time::precise_time_s();\n                 assert(validate(edges, root, bfs_tree));\n                 let stop = time::precise_time_s();\n                 \n                 io::stdout().write_line(\n-                    #fmt(\"Validation completed in %? seconds.\",\n-                         stop - start));\n+                    fmt!{\"Validation completed in %? seconds.\",\n+                         stop - start});\n             }\n             \n             let start = time::precise_time_s();\n@@ -445,17 +445,17 @@ fn main(args: ~[~str]) {\n             total_seq += stop - start;\n             \n             io::stdout().write_line(\n-                #fmt(\"Alternate Sequential BFS completed in %? seconds.\",\n-                     stop - start));\n+                fmt!{\"Alternate Sequential BFS completed in %? seconds.\",\n+                     stop - start});\n             \n             if do_validate {\n                 let start = time::precise_time_s();\n                 assert(validate(edges, root, bfs_tree));\n                 let stop = time::precise_time_s();\n                 \n                 io::stdout().write_line(\n-                    #fmt(\"Validation completed in %? seconds.\",\n-                         stop - start));\n+                    fmt!{\"Validation completed in %? seconds.\",\n+                         stop - start});\n             }\n         }\n         \n@@ -465,21 +465,21 @@ fn main(args: ~[~str]) {\n \n         total_par += stop - start;\n \n-        io::stdout().write_line(#fmt(\"Parallel BFS completed in %? seconds.\",\n-                                     stop - start));\n+        io::stdout().write_line(fmt!{\"Parallel BFS completed in %? seconds.\",\n+                                     stop - start});\n \n         if do_validate {\n             let start = time::precise_time_s();\n             assert(validate(edges, root, bfs_tree));\n             let stop = time::precise_time_s();\n             \n-            io::stdout().write_line(#fmt(\"Validation completed in %? seconds.\",\n-                                         stop - start));\n+            io::stdout().write_line(fmt!{\"Validation completed in %? seconds.\",\n+                                         stop - start});\n         }\n     };\n \n     io::stdout().write_line(~\"\");\n     io::stdout().write_line(\n-        #fmt(\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n-             total_seq, total_par, total_seq / total_par));\n+        fmt!{\"Total sequential: %? \\t Total Parallel: %? \\t Speedup: %?x\",\n+             total_seq, total_par, total_seq / total_par});\n }"}, {"sha": "fdf218a82df4c6c9c02eb1bb8b5ff755c538d69b", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -34,15 +34,15 @@ fn server(requests: port<request>, responses: pipes::chan<uint>) {\n         alt requests.try_recv() {\n           some(get_count) { responses.send(copy count); }\n           some(bytes(b)) {\n-            //#error(\"server: received %? bytes\", b);\n+            //error!{\"server: received %? bytes\", b};\n             count += b;\n           }\n           none { done = true; }\n           _ { }\n         }\n     }\n     responses.send(count);\n-    //#error(\"server exiting\");\n+    //error!{\"server exiting\"};\n }\n \n fn run(args: &[~str]) {\n@@ -62,27 +62,27 @@ fn run(args: &[~str]) {\n             vec::push(worker_results, r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n-                //#error(\"worker %?: sending %? bytes\", i, num_bytes);\n+                //error!{\"worker %?: sending %? bytes\", i, num_bytes};\n                 to_child.send(bytes(num_bytes));\n             }\n-            //#error(\"worker %? exiting\", i);\n+            //error!{\"worker %? exiting\", i};\n         };\n     }\n     do task::spawn {\n         server(from_parent, to_parent);\n     }\n \n     vec::iter(worker_results, |r| { future::get(r); } );\n-    //#error(\"sending stop message\");\n+    //error!{\"sending stop message\"};\n     to_child.send(stop);\n     move!{to_child};\n     let result = from_child.recv();\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n-    io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n+    io::stdout().write_str(fmt!{\"Count is %?\\n\", result});\n+    io::stdout().write_str(fmt!{\"Test took %? seconds\\n\", elapsed});\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n+    io::stdout().write_str(fmt!{\"Throughput=%f per sec\\n\", thruput});\n     assert result == num_bytes * size;\n }\n \n@@ -95,6 +95,6 @@ fn main(args: ~[~str]) {\n         copy args\n     };        \n \n-    #debug(\"%?\", args);\n+    debug!{\"%?\", args};\n     run(args);\n }"}, {"sha": "0428123a00cd1fceb1662cae9d97d0cbf1c4d49f", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -29,15 +29,15 @@ fn server(requests: port_set<request>, responses: pipes::chan<uint>) {\n         alt requests.try_recv() {\n           some(get_count) { responses.send(copy count); }\n           some(bytes(b)) {\n-            //#error(\"server: received %? bytes\", b);\n+            //error!{\"server: received %? bytes\", b};\n             count += b;\n           }\n           none { done = true; }\n           _ { }\n         }\n     }\n     responses.send(count);\n-    //#error(\"server exiting\");\n+    //error!{\"server exiting\"};\n }\n \n fn run(args: &[~str]) {\n@@ -58,27 +58,27 @@ fn run(args: &[~str]) {\n             vec::push(worker_results, r);\n         }).spawn {\n             for uint::range(0u, size / workers) |_i| {\n-                //#error(\"worker %?: sending %? bytes\", i, num_bytes);\n+                //error!{\"worker %?: sending %? bytes\", i, num_bytes};\n                 to_child.send(bytes(num_bytes));\n             }\n-            //#error(\"worker %? exiting\", i);\n+            //error!{\"worker %? exiting\", i};\n         };\n     }\n     do task::spawn {\n         server(from_parent, to_parent);\n     }\n \n     vec::iter(worker_results, |r| { future::get(r); } );\n-    //#error(\"sending stop message\");\n+    //error!{\"sending stop message\"};\n     to_child.send(stop);\n     move!{to_child};\n     let result = from_child.recv();\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n-    io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n+    io::stdout().write_str(fmt!{\"Count is %?\\n\", result});\n+    io::stdout().write_str(fmt!{\"Test took %? seconds\\n\", elapsed});\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n+    io::stdout().write_str(fmt!{\"Throughput=%f per sec\\n\", thruput});\n     assert result == num_bytes * size;\n }\n \n@@ -91,6 +91,6 @@ fn main(args: ~[~str]) {\n         copy args\n     };        \n \n-    #debug(\"%?\", args);\n+    debug!{\"%?\", args};\n     run(args);\n }"}, {"sha": "952157cfcafa2a17b0adfab03cb1e6b824ffdc22", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -36,7 +36,7 @@ fn thread_ring(i: uint,\n     let mut num_port <- some(num_port);\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n-        //#error(\"task %?, iter %?\", i, j);\n+        //error!{\"task %?, iter %?\", i, j};\n         let mut num_chan2 = none;\n         let mut num_port2 = none;\n         num_chan2 <-> num_chan;\n@@ -46,7 +46,7 @@ fn thread_ring(i: uint,\n         alt recv(port) {\n           ring::num(_n, p) {\n             //log(error, _n);\n-            num_port = some(#move(p));\n+            num_port = some(move!{p});\n           }\n         }\n     };\n@@ -73,7 +73,7 @@ fn main(args: ~[~str]) {\n     let mut futures = ~[];\n \n     for uint::range(1u, num_tasks) |i| {\n-        //#error(\"spawning %?\", i);\n+        //error!{\"spawning %?\", i};\n         let (new_chan, num_port) = ring::init();\n         let num_chan2 = ~mut none;\n         *num_chan2 <-> num_chan;\n@@ -103,8 +103,8 @@ fn main(args: ~[~str]) {\n     let elapsed = (stop - start);\n     let rate = (num_msgs as float) / elapsed;\n \n-    io::println(#fmt(\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed));\n-    io::println(#fmt(\"  %? messages / second\", rate));\n-    io::println(#fmt(\"  %? \u03bcs / message\", 1000000. / rate));\n+    io::println(fmt!{\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed});\n+    io::println(fmt!{\"  %? messages / second\", rate});\n+    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n }"}, {"sha": "6722423a08ea3d907fbb5bf0b4ab4be932b90191", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -68,8 +68,8 @@ fn main(args: ~[~str]) {\n     let elapsed = (stop - start);\n     let rate = (num_msgs as float) / elapsed;\n \n-    io::println(#fmt(\"Sent %? messages in %? seconds\",\n-                     num_msgs, elapsed));\n-    io::println(#fmt(\"  %? messages / second\", rate));\n-    io::println(#fmt(\"  %? \u03bcs / message\", 1000000. / rate));\n+    io::println(fmt!{\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed});\n+    io::println(fmt!{\"  %? messages / second\", rate});\n+    io::println(fmt!{\"  %? \u03bcs / message\", 1000000. / rate});\n }"}, {"sha": "606f33936c1e2cad854b2658aae363e6cea2023b", "filename": "src/test/bench/msgsend.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fmsgsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -52,10 +52,10 @@ fn run(args: ~[~str]) {\n     let result = comm::recv(from_child);\n     let end = std::time::precise_time_s();\n     let elapsed = end - start;\n-    io::stdout().write_str(#fmt(\"Count is %?\\n\", result));\n-    io::stdout().write_str(#fmt(\"Test took %? seconds\\n\", elapsed));\n+    io::stdout().write_str(fmt!{\"Count is %?\\n\", result});\n+    io::stdout().write_str(fmt!{\"Test took %? seconds\\n\", elapsed});\n     let thruput = ((size / workers * workers) as float) / (elapsed as float);\n-    io::stdout().write_str(#fmt(\"Throughput=%f per sec\\n\", thruput));\n+    io::stdout().write_str(fmt!{\"Throughput=%f per sec\\n\", thruput});\n }\n \n fn main(args: ~[~str]) {\n@@ -67,7 +67,7 @@ fn main(args: ~[~str]) {\n         args\n     };        \n \n-    #debug(\"%?\", args);\n+    debug!{\"%?\", args};\n     run(args);\n }\n "}, {"sha": "f9c7d39a259be41506f0b186847a5f4589ef755d", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -136,13 +136,13 @@ fn main() {\n     let bounded = do timeit { bounded(count) };\n     let unbounded = do timeit { unbounded(count) };\n \n-    io::println(#fmt(\"count: %?\\n\", count));\n-    io::println(#fmt(\"bounded:   %? s\\t(%? \u03bcs/message)\",\n-                     bounded, bounded * 1000000. / (count as float)));\n-    io::println(#fmt(\"unbounded: %? s\\t(%? \u03bcs/message)\",\n-                     unbounded, unbounded * 1000000. / (count as float)));\n+    io::println(fmt!{\"count: %?\\n\", count});\n+    io::println(fmt!{\"bounded:   %? s\\t(%? \u03bcs/message)\",\n+                     bounded, bounded * 1000000. / (count as float)});\n+    io::println(fmt!{\"unbounded: %? s\\t(%? \u03bcs/message)\",\n+                     unbounded, unbounded * 1000000. / (count as float)});\n \n-    io::println(#fmt(\"\\n\\\n+    io::println(fmt!{\"\\n\\\n                       bounded is %?%% faster\",\n-                     (unbounded - bounded) / bounded * 100.));\n+                     (unbounded - bounded) / bounded * 100.});\n }"}, {"sha": "f9b698a219578261652cded8c8553f1928412ed7", "filename": "src/test/bench/shootout-ackermann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-ackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-ackermann.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -21,5 +21,5 @@ fn main(args: ~[~str]) {\n         args\n     };\n     let n = int::from_str(args[1]).get();\n-    io::println(#fmt(\"Ack(3,%d): %d\\n\", n, ack(3, n)));\n+    io::println(fmt!{\"Ack(3,%d): %d\\n\", n, ack(3, n)});\n }"}, {"sha": "55e566296fc2d88f0f28b9737670f7cd6c86a51a", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -44,9 +44,9 @@ fn main(args: ~[~str]) {\n     let stretch_depth = max_depth + 1;\n     let stretch_tree = bottom_up_tree(&stretch_arena, 0, stretch_depth);\n \n-    io::println(#fmt(\"stretch tree of depth %d\\t check: %d\",\n+    io::println(fmt!{\"stretch tree of depth %d\\t check: %d\",\n                           stretch_depth,\n-                          item_check(stretch_tree)));\n+                          item_check(stretch_tree)});\n \n     let long_lived_arena = arena::arena();\n     let long_lived_tree = bottom_up_tree(&long_lived_arena, 0, max_depth);\n@@ -62,12 +62,12 @@ fn main(args: ~[~str]) {\n             chk += item_check(temp_tree);\n             i += 1;\n         }\n-        io::println(#fmt(\"%d\\t trees of depth %d\\t check: %d\",\n+        io::println(fmt!{\"%d\\t trees of depth %d\\t check: %d\",\n                          iterations * 2, depth,\n-                         chk));\n+                         chk});\n         depth += 2;\n     }\n-    io::println(#fmt(\"long lived trees of depth %d\\t check: %d\",\n+    io::println(fmt!{\"long lived trees of depth %d\\t check: %d\",\n                      max_depth,\n-                          item_check(long_lived_tree)));\n+                          item_check(long_lived_tree)});\n }"}, {"sha": "0400e8b127e746c1ce030845d59482e4f378f498", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -113,7 +113,7 @@ fn creature(\n             }\n             option::none {\n                 // log creatures met and evil clones of self\n-                let report = #fmt(\"%u\", creatures_met) + ~\" \" +\n+                let report = fmt!{\"%u\", creatures_met} + ~\" \" +\n                              show_number(evil_clones_met);\n                 comm::send(to_rendezvous_log, report);\n                 break;"}, {"sha": "4f48c8799b718bc8e3fde22af69af6f3148eef86", "filename": "src/test/bench/shootout-fannkuchredux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuchredux.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -43,7 +43,7 @@ fn fannkuch(n: int) -> int {\n         let mut go = true;\n         while go {\n             if r == n {\n-                io::println(#fmt(\"%d\", checksum));\n+                io::println(fmt!{\"%d\", checksum});\n                 ret flips;\n             }\n             let p0 = perm1[0];\n@@ -68,5 +68,5 @@ fn main(args: ~[~str]) {\n     };\n \n     let n = int::from_str(args[1]).get();\n-    io::println(#fmt(\"Pfannkuchen(%d) = %d\", n, fannkuch(n)));\n+    io::println(fmt!{\"Pfannkuchen(%d) = %d\", n, fannkuch(n)});\n }"}, {"sha": "2851b59956e108162a47e7e06e69394e4446fd09", "filename": "src/test/bench/shootout-fibo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-fibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fibo.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -17,5 +17,5 @@ fn main(args: ~[~str]) {\n         args\n     };\n     let n = int::from_str(args[1]).get();\n-    io::println(#fmt(\"%d\\n\", fib(n)));\n+    io::println(fmt!{\"%d\\n\", fib(n)});\n }"}, {"sha": "d8a82019f33773c9b283b4301c9acea94bee8efe", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -48,7 +48,7 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n \n    pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n       let (k,v) = kv;\n-      buffer += (#fmt[\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v]);\n+      buffer += (fmt!{\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v});\n       ret true;\n    });\n \n@@ -111,15 +111,15 @@ fn make_sequence_processor(sz: uint, from_parent: pipes::port<~[u8]>,\n    let buffer = alt sz { \n        1u { sort_and_fmt(freqs, total) }\n        2u { sort_and_fmt(freqs, total) }\n-       3u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\"] }\n-       4u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\"] }\n-       6u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\"] }\n-      12u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\"] }\n-      18u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\"] }\n+       3u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\"} }\n+       4u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\"} }\n+       6u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\"} }\n+      12u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\"} }\n+      18u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\"} }\n         _ { ~\"\" }\n    };\n \n-   //comm::send(to_parent, #fmt[\"yay{%u}\", sz]);\n+   //comm::send(to_parent, fmt!{\"yay{%u}\", sz});\n     to_parent.send(buffer);\n }\n \n@@ -129,7 +129,7 @@ fn main(args: ~[~str]) {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n        let path = path::connect(\n-           #env(\"CFG_SRC_DIR\"),\n+           env!{\"CFG_SRC_DIR\"},\n            ~\"src/test/bench/shootout-k-nucleotide.data\"\n            );\n        result::get(io::file_reader(path))"}, {"sha": "2eee8572a774bbb49d80bb644cfcbe7abba82cab", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -46,7 +46,7 @@ fn sort_and_fmt(mm: hashmap<~[u8], uint>, total: uint) -> ~str {\n \n    pairs_sorted.each(fn&(kv: (~[u8], float)) -> bool unsafe {\n       let (k,v) = kv;\n-      buffer += (#fmt[\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v]);\n+      buffer += (fmt!{\"%s %0.3f\\n\", str::to_upper(str::unsafe::from_bytes(k)), v});\n       ret true;\n    });\n \n@@ -109,15 +109,15 @@ fn make_sequence_processor(sz: uint, from_parent: comm::port<~[u8]>,\n    let buffer = alt sz { \n        1u { sort_and_fmt(freqs, total) }\n        2u { sort_and_fmt(freqs, total) }\n-       3u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\"] }\n-       4u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\"] }\n-       6u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\"] }\n-      12u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\"] }\n-      18u { #fmt[\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\"] }\n+       3u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\"} }\n+       4u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\"} }\n+       6u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\"} }\n+      12u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\"} }\n+      18u { fmt!{\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\"} }\n         _ { ~\"\" }\n    };\n \n-   //comm::send(to_parent, #fmt[\"yay{%u}\", sz]);\n+   //comm::send(to_parent, fmt!{\"yay{%u}\", sz});\n    comm::send(to_parent, buffer);\n }\n \n@@ -127,7 +127,7 @@ fn main(args: ~[~str]) {\n        // FIXME: Using this compile-time env variable is a crummy way to\n        // get to this massive data set, but #include_bin chokes on it (#2598)\n        let path = path::connect(\n-           #env(\"CFG_SRC_DIR\"),\n+           env!{\"CFG_SRC_DIR\"},\n            ~\"src/test/bench/shootout-k-nucleotide.data\"\n            );\n        result::get(io::file_reader(path))"}, {"sha": "c752dc4050d1dbb2a519a96c4c071d5c792de832", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -117,20 +117,20 @@ fn writer(path: ~str, writech: comm::chan<comm::chan<line>>, size: uint)\n         }\n     };\n     cout.write_line(~\"P4\");\n-    cout.write_line(#fmt(\"%u %u\", size, size));\n+    cout.write_line(fmt!{\"%u %u\", size, size});\n     let lines = std::map::uint_hash();\n     let mut done = 0_u;\n     let mut i = 0_u;\n     while i < size {\n         let aline = comm::recv(p);\n         if aline.i == done {\n-            #debug(\"W %u\", aline.i);\n+            debug!{\"W %u\", aline.i};\n             cout.write(aline.b);\n             done += 1_u;\n             let mut prev = done;\n             while prev <= i {\n                 if lines.contains_key(prev) {\n-                    #debug(\"WS %u\", prev);\n+                    debug!{\"WS %u\", prev};\n                     // FIXME (#2280): this temporary shouldn't be\n                     // necessary, but seems to be, for borrowing.\n                     let v : ~[u8] = lines.get(prev);\n@@ -145,7 +145,7 @@ fn writer(path: ~str, writech: comm::chan<comm::chan<line>>, size: uint)\n             };\n         }\n         else {\n-            #debug(\"S %u\", aline.i);\n+            debug!{\"S %u\", aline.i};\n             lines.insert(aline.i, aline.b);\n         };\n         i += 1_u;\n@@ -177,7 +177,7 @@ fn main(args: ~[~str]) {\n     for uint::range(0_u, size) |j| {\n         task::spawn(|| chanmb(j, size, ch) );\n         if j % yieldevery == 0_u {\n-            #debug(\"Y %u\", j);\n+            debug!{\"Y %u\", j};\n             task::yield();\n         };\n     };"}, {"sha": "c90ba53c58047f32dc4a9bd939cc77295be09801", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -23,10 +23,10 @@ fn main(args: ~[~str]) {\n     };\n     let n = int::from_str(args[1]).get();\n     let bodies: ~[Body::props] = NBodySystem::make();\n-    io::println(#fmt(\"%f\", NBodySystem::energy(bodies)));\n+    io::println(fmt!{\"%f\", NBodySystem::energy(bodies)});\n     let mut i = 0;\n     while i < n { NBodySystem::advance(bodies, 0.01); i += 1; }\n-    io::println(#fmt(\"%f\", NBodySystem::energy(bodies)));\n+    io::println(fmt!{\"%f\", NBodySystem::energy(bodies)});\n }\n \n mod NBodySystem {"}, {"sha": "be7a8c6c3c785bc02ded3d3fd046239203e69621", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -64,7 +64,7 @@ fn stress_task(&&id: int) {\n         let n = 15;\n         assert (fib(n) == fib(n));\n         i += 1;\n-        #error(\"%d: Completed %d iterations\", id, i);\n+        error!{\"%d: Completed %d iterations\", id, i};\n     }\n }\n \n@@ -109,8 +109,8 @@ fn main(args: ~[~str]) {\n \n                 let elapsed = stop - start;\n \n-                out.write_line(#fmt[\"%d\\t%d\\t%s\", n, fibn,\n-                                    u64::str(elapsed)]);\n+                out.write_line(fmt!{\"%d\\t%d\\t%s\", n, fibn,\n+                                    u64::str(elapsed)});\n             }\n         }\n     }"}, {"sha": "69f31b3907515da93cd7eb722666c8bd3dd73208", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -69,5 +69,5 @@ fn main(args: ~[~str]) {\n         i += 1u;\n     }\n \n-    io::println(#fmt(\"%0.9f\\n\", float::sqrt(vBv / vv)));\n+    io::println(fmt!{\"%0.9f\\n\", float::sqrt(vBv / vv)});\n }"}, {"sha": "890f36b833c031ce399e72a83867d6dea977cdd8", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -23,11 +23,11 @@ fn roundtrip(id: int, p: comm::port<int>, ch: comm::chan<int>) {\n     while (true) {\n         alt comm::recv(p) {\n           1 {\n-            io::println(#fmt(\"%d\\n\", id));\n+            io::println(fmt!{\"%d\\n\", id});\n             ret;\n           }\n           token {\n-            #debug(\"%d %d\", id, token);\n+            debug!{\"%d %d\", id, token};\n             comm::send(ch, token - 1);\n             if token <= n_threads {\n                 ret;"}, {"sha": "f5e4ab2e8fa0a1141a5914ad1559c733d52715e2", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -45,8 +45,8 @@ fn main(args: ~[~str]) {\n \n     let maxf = max as float;\n \n-    io::stdout().write_str(#fmt(\"insert(): %? seconds\\n\", checkf));\n-    io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/checkf));\n-    io::stdout().write_str(#fmt(\"get()   : %? seconds\\n\", appendf));\n-    io::stdout().write_str(#fmt(\"        : %f op/sec\\n\", maxf/appendf));\n+    io::stdout().write_str(fmt!{\"insert(): %? seconds\\n\", checkf});\n+    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/checkf});\n+    io::stdout().write_str(fmt!{\"get()   : %? seconds\\n\", appendf});\n+    io::stdout().write_str(fmt!{\"        : %f op/sec\\n\", maxf/appendf});\n }"}, {"sha": "e062e5c9dcb897219d59172a92c58267323e5eb9", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -118,9 +118,9 @@ fn solve_grid(g: grid_t) {\n \n fn write_grid(f: io::writer, g: grid_t) {\n     for u8::range(0u8, 9u8) |row| {\n-        f.write_str(#fmt(\"%u\", (*g)[row][0] as uint));\n+        f.write_str(fmt!{\"%u\", (*g)[row][0] as uint});\n         for u8::range(1u8, 9u8) |col| {\n-            f.write_str(#fmt(\" %u\", (*g)[row][col] as uint));\n+            f.write_str(fmt!{\" %u\", (*g)[row][col] as uint});\n         }\n         f.write_char('\\n');\n      }"}, {"sha": "e24b7bf5fa418e5a5c82e22370720f0213dc7ea1", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -17,11 +17,11 @@ fn main() {\n \n fn run(repeat: int, depth: int) {\n     for iter::repeat(repeat as uint) {\n-        #debug(\"starting %.4f\", precise_time_s());\n+        debug!{\"starting %.4f\", precise_time_s()};\n         do task::try {\n             recurse_or_fail(depth, none)\n         };\n-        #debug(\"stopping %.4f\", precise_time_s());\n+        debug!{\"stopping %.4f\", precise_time_s()};\n     }\n }\n \n@@ -48,7 +48,7 @@ class r {\n \n fn recurse_or_fail(depth: int, st: option<st>) {\n     if depth == 0 {\n-        #debug(\"unwinding %.4f\", precise_time_s());\n+        debug!{\"unwinding %.4f\", precise_time_s()};\n         fail;\n     } else {\n         let depth = depth - 1;"}, {"sha": "8dd6f957ffae2591098b828a01bcb48de82bd4be", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -68,5 +68,5 @@ fn main(args: ~[~str]) {\n     let sum = alt check comm::recv(port) {\n       done(sum) { sum }\n     };\n-    #error(\"How many tasks? %d tasks.\", sum);\n+    error!{\"How many tasks? %d tasks.\", sum};\n }"}, {"sha": "59e655186ce058003821d5bbfccb4d3d18ec805a", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -80,7 +80,7 @@ impl of word_reader for io::reader {\n fn file_word_reader(filename: ~str) -> word_reader {\n     alt io::file_reader(filename) {\n       result::ok(f) { f as word_reader }\n-      result::err(e) { fail #fmt(\"%?\", e) }\n+      result::err(e) { fail fmt!{\"%?\", e} }\n     }\n }\n \n@@ -99,7 +99,7 @@ fn reduce(&&word: ~str, get: map_reduce::getter<int>) {\n \n     loop { alt get() { some(_) { count += 1; } none { break; } } }\n     \n-    io::println(#fmt(\"%s\\t%?\", word, count));\n+    io::println(fmt!{\"%s\\t%?\", word, count});\n }\n \n class box<T> {\n@@ -225,11 +225,11 @@ mod map_reduce {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n-                    // #error(\"received %d\", v);\n+                    // error!{\"received %d\", v};\n                     ret some(v);\n                   }\n                   done {\n-                    // #error(\"all done\");\n+                    // error!{\"all done\"};\n                     is_done = true;\n                   }\n                   ref { ref_count += 1; }\n@@ -260,7 +260,7 @@ mod map_reduce {\n             let (_ready, message, ctrls) = pipes::select(ctrl);\n             alt option::unwrap(message) {\n               ctrl_proto::mapper_done {\n-                // #error(\"received mapper terminated.\");\n+                // error!{\"received mapper terminated.\"};\n                 num_mappers -= 1;\n                 ctrl = ctrls;\n               }\n@@ -301,7 +301,7 @@ fn main(argv: ~[~str]) {\n     if vec::len(argv) < 2u && !os::getenv(~\"RUST_BENCH\").is_some() {\n         let out = io::stdout();\n \n-        out.write_line(#fmt[\"Usage: %s <filename> ...\", argv[0]]);\n+        out.write_line(fmt!{\"Usage: %s <filename> ...\", argv[0]});\n \n         ret;\n     }"}, {"sha": "dd0628d4253a0a9ac22e703c4de3ea53c0a9a868", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -113,11 +113,11 @@ mod map_reduce {\n             while !state.is_done || state.ref_count > 0 {\n                 alt recv(p) {\n                   emit_val(v) {\n-                    // #error(\"received %d\", v);\n+                    // error!{\"received %d\", v};\n                     ret some(v);\n                   }\n                   done {\n-                    // #error(\"all done\");\n+                    // error!{\"all done\"};\n                     state.is_done = true;\n                   }\n                   ref { state.ref_count += 1; }\n@@ -146,7 +146,7 @@ mod map_reduce {\n         while num_mappers > 0 {\n             alt recv(ctrl) {\n               mapper_done {\n-                // #error(\"received mapper terminated.\");\n+                // error!{\"received mapper terminated.\"};\n                 num_mappers -= 1;\n               }\n               find_reducer(k, cc) {"}, {"sha": "f0e6e1040068e8e6764fcf1f7432b3abb0de8339", "filename": "src/test/compile-fail/assign-imm-local-twice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-imm-local-twice.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,9 +1,9 @@\n fn test() {\n     let v: int;\n     v = 1; //~ NOTE prior assignment occurs here\n-    #debug[\"v=%d\", v];\n+    debug!{\"v=%d\", v};\n     v = 2; //~ ERROR re-assignment of immutable variable\n-    #debug[\"v=%d\", v];\n+    debug!{\"v=%d\", v};\n }\n \n fn main() {"}, {"sha": "bd1a17c6b82a47590f9c11ddf4229a0ecae70870", "filename": "src/test/compile-fail/assign-to-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-to-method.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -11,5 +11,5 @@ class cat {\n \n fn main() {\n   let nyan : cat = cat(52u, 99);\n-  nyan.speak = fn@() { #debug[\"meow\"]; }; //~ ERROR attempted to take value of method\n+  nyan.speak = fn@() { debug!{\"meow\"}; }; //~ ERROR attempted to take value of method\n }"}, {"sha": "352189722cfdefa451013219b7bc2699b1af904a", "filename": "src/test/compile-fail/attr-before-ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fattr-before-ext.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     #[attr]\n-    #debug(\"hi\"); //~ ERROR expected item\n+    debug!{\"hi\"}; //~ ERROR expected item\n }\n\\ No newline at end of file"}, {"sha": "e578816c0e3b81224b88c26a41aeaf19815ae935", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,8 +7,8 @@ enum color { rgb(int, int, int), rgba(int, int, int, int), }\n fn main() {\n     let red: color = rgb(255, 0, 0);\n     alt red {\n-      rgb(r, g, b) { #debug(\"rgb\"); }\n-      hsl(h, s, l) { #debug(\"hsl\"); }\n+      rgb(r, g, b) { debug!{\"rgb\"}; }\n+      hsl(h, s, l) { debug!{\"hsl\"}; }\n     }\n }\n "}, {"sha": "6353a470f9a23235c5bd3b8129b85d84caacdbc9", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,14 +7,14 @@ fn box_imm() {\n     let _w = &mut v; //~ NOTE loan of mutable local variable granted here\n     do task::spawn |move v| {\n         //~^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n-        #debug[\"v=%d\", *v];\n+        debug!{\"v=%d\", *v};\n     }\n \n     let mut v = ~3;\n     let _w = &mut v; //~ NOTE loan of mutable local variable granted here\n     task::spawn(fn~(move v) {\n         //~^ ERROR moving out of mutable local variable prohibited due to outstanding loan\n-        #debug[\"v=%d\", *v];\n+        debug!{\"v=%d\", *v};\n     });\n }\n "}, {"sha": "72e215688fd2427ed2d60c3ab5f2a63b74c2db88", "filename": "src/test/compile-fail/class-cast-to-iface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-iface.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@ class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ class cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "4bad4bd2bc5ccaec2d6ec3a7033660df956cfce8", "filename": "src/test/compile-fail/class-missing-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-missing-self.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,7 +3,7 @@ class cat {\n     let mut meows : uint;\n     fn sleep() { loop{} }\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       meows += 1u; //~ ERROR unresolved name\n       sleep();     //~ ERROR unresolved name\n     }"}, {"sha": "fe7b7aec1049c148b5c028b69379b02762bf5b99", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -5,5 +5,5 @@\n \n fn f(caller: str) { log(debug, caller); }\n \n-fn main() { ret f(\"main\"); #debug(\"Paul is dead\"); }\n+fn main() { ret f(\"main\"); debug!{\"Paul is dead\"}; }\n "}, {"sha": "b8e724327b07e5d99a125d5ebdd32993d00ca0e6", "filename": "src/test/compile-fail/does-nothing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdoes-nothing.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern: unresolved name: this_does_nothing_what_the\n-fn main() { #debug(\"doing\"); this_does_nothing_what_the; #debug(\"boing\"); }\n+fn main() { debug!{\"doing\"}; this_does_nothing_what_the; debug!{\"boing\"}; }\n "}, {"sha": "ecef4685fd55047adb8165fe43ae9b161e63b10d", "filename": "src/test/compile-fail/export2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fexport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ mod foo {\n mod bar {\n     export y;\n \n-    fn x() { #debug(\"x\"); }\n+    fn x() { debug!{\"x\"}; }\n \n     fn y() { }\n }"}, {"sha": "4b43dc2183423ec468c18ae089070a13f1f3dec4", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,7 +1,7 @@\n-// error-pattern:expected item but found `#`\n+// error-pattern:expected item but found `fmt`\n \n // Don't know how to deal with a syntax extension appearing after an\n // item attribute. Probably could use a better error message.\n #[foo = \"bar\"]\n-#fmt(\"baz\")\n+fmt!{\"baz\"}\n fn main() { }\n\\ No newline at end of file"}, {"sha": "94df92825a215057f95e44da4678207defcb32d7", "filename": "src/test/compile-fail/ext-nonexistent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-nonexistent.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,2 +1,2 @@\n // error-pattern:macro undefined\n-fn main() { #iamnotanextensionthatexists[\"\"]; }\n+fn main() { iamnotanextensionthatexists!{\"\"}; }"}, {"sha": "2b28e009b95ff90b6f3bd7ef57aed7ab20a7eb9b", "filename": "src/test/compile-fail/extenv-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-no-args.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:#env takes between 1 and 1 arguments\n \n-fn main() { #env[]; }\n+fn main() { env!{}; }"}, {"sha": "009da5e38df7443cb3cfc96b353a4f8c3c5d847e", "filename": "src/test/compile-fail/extenv-not-string-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-not-string-literal.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:requires a string\n \n-fn main() { #env[10]; }\n+fn main() { env!{10}; }"}, {"sha": "02e6fb2940f3cc9ba7f1fb270cf85a33383d4ae2", "filename": "src/test/compile-fail/extenv-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextenv-too-many-args.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:#env takes between 1 and 1 arguments\n \n-fn main() { #env[\"one\", \"two\"]; }\n+fn main() { env!{\"one\", \"two\"}; }"}, {"sha": "09330d46aacf66bbc33ecfb9bc8ae6e4a47ca799", "filename": "src/test/compile-fail/extfmt-missing-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-missing-type.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:missing type\n \n-fn main() { #fmt[\"%+\"]; }\n+fn main() { fmt!{\"%+\"}; }"}, {"sha": "701e5f56827fdf22b799ec4265f5065d615d04ce", "filename": "src/test/compile-fail/extfmt-no-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-no-args.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:#fmt needs at least 1 arguments\n \n-fn main() { #fmt[]; }\n+fn main() { fmt!{}; }"}, {"sha": "ceae0f62a2406518f8df11f2682599c9826c9213", "filename": "src/test/compile-fail/extfmt-non-literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #fmt[\"a\" + \"b\"];\n+    let x = fmt!{\"a\" + \"b\"};\n }"}, {"sha": "d325b2dbf7c926c01c5e1526f4fb2aa8be4a8480", "filename": "src/test/compile-fail/extfmt-non-literal2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-non-literal2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,5 +4,5 @@ fn main() {\n     // #fmt's first argument must be a literal.  Hopefully this\n     // restriction can be eased eventually to just require a\n     // compile-time constant.\n-    let x = #fmt[20];\n+    let x = fmt!{20};\n }"}, {"sha": "2804a64c35b6f067a4ef410739960a0654a1f42f", "filename": "src/test/compile-fail/extfmt-not-enough-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-not-enough-args.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #fmt[\"%s%s%s\", \"test\", \"test\"]; }\n+fn main() { let s = fmt!{\"%s%s%s\", \"test\", \"test\"}; }"}, {"sha": "447d84aed808948f0153f7acbd2a6f42ae8f994b", "filename": "src/test/compile-fail/extfmt-too-many-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-too-many-args.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,4 +2,4 @@\n \n use std;\n \n-fn main() { let s = #fmt[\"%s\", \"test\", \"test\"]; }\n+fn main() { let s = fmt!{\"%s\", \"test\", \"test\"}; }"}, {"sha": "bfb6c99d351d84094a1a25b93b68a608133dff6d", "filename": "src/test/compile-fail/extfmt-unknown-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unknown-type.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unknown type\n \n-fn main() { #fmt[\"%w\"]; }\n+fn main() { fmt!{\"%w\"}; }"}, {"sha": "0f3781f0438f9e96a06e724513781387c4f1c15b", "filename": "src/test/compile-fail/extfmt-unsigned-plus.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-plus.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a sign on unsigned conversions\n-    #fmt[\"%+u\", 10u];\n+    fmt!{\"%+u\", 10u};\n }"}, {"sha": "d847ff43a6a835c26a34132c2920efdc28674c46", "filename": "src/test/compile-fail/extfmt-unsigned-space.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unsigned-space.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,5 +2,5 @@\n \n fn main() {\n     // Can't use a space on unsigned conversions\n-    #fmt[\"% u\", 10u];\n+    fmt!{\"% u\", 10u};\n }"}, {"sha": "cb12f54c789b9062cdc8772f120dcca77aab0fc4", "filename": "src/test/compile-fail/extfmt-unterminated-conv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextfmt-unterminated-conv.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,3 +1,3 @@\n // error-pattern:unterminated conversion\n \n-fn main() { #fmt[\"%\"]; }\n+fn main() { fmt!{\"%\"}; }"}, {"sha": "eb327ff3ea19f27a38c8ef49712257e6855d12ff", "filename": "src/test/compile-fail/for-loop-decl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-loop-decl.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,4 +16,4 @@ fn bitv_to_str(enclosing: fn_info, v: ~bitv::bitv) -> str {\n     ret s;\n }\n \n-fn main() { #debug(\"OK\"); }\n+fn main() { debug!{\"OK\"}; }"}, {"sha": "a1455ffa1f63f2f6332462e6b1560678ad09cdf5", "filename": "src/test/compile-fail/import-glob-0.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-0.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,10 +7,10 @@ mod module_of_many_things {\n     export f2;\n     export f4;\n \n-    fn f1() { #debug(\"f1\"); }\n-    fn f2() { #debug(\"f2\"); }\n-    fn f3() { #debug(\"f3\"); }\n-    fn f4() { #debug(\"f4\"); }\n+    fn f1() { debug!{\"f1\"}; }\n+    fn f2() { debug!{\"f2\"}; }\n+    fn f3() { debug!{\"f3\"}; }\n+    fn f4() { debug!{\"f4\"}; }\n }\n \n "}, {"sha": "e0f2d3a3c099e583b5d93c99a8b3cb1a2f31c069", "filename": "src/test/compile-fail/import-glob-circular.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport-glob-circular.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -5,7 +5,7 @@ mod circ1 {\n     export f1;\n     export f2;\n     export common;\n-    fn f1() { #debug(\"f1\"); }\n+    fn f1() { debug!{\"f1\"}; }\n     fn common() -> uint { ret 0u; }\n }\n \n@@ -14,7 +14,7 @@ mod circ2 {\n     export f1;\n     export f2;\n     export common;\n-    fn f2() { #debug(\"f2\"); }\n+    fn f2() { debug!{\"f2\"}; }\n     fn common() -> uint { ret 1u; }\n }\n "}, {"sha": "582096ab31fecc6a8a4cf9de29b75b71ae0a2c7e", "filename": "src/test/compile-fail/import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,6 +3,6 @@\n import zed::bar;\n import zed::baz;\n mod zed {\n-    fn bar() { #debug(\"bar\"); }\n+    fn bar() { debug!{\"bar\"}; }\n }\n fn main(args: ~[str]) { bar(); }"}, {"sha": "2543db0d059e8cb7337e5b7cc4cdc847123772ed", "filename": "src/test/compile-fail/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,6 +2,6 @@\n import baz::zed::bar;\n mod baz { }\n mod zed {\n-    fn bar() { #debug(\"bar3\"); }\n+    fn bar() { debug!{\"bar3\"}; }\n }\n fn main(args: ~[str]) { bar(); }"}, {"sha": "395e5e8b4127fdae9a7a72623424542c4c580ed9", "filename": "src/test/compile-fail/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport3.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: unresolved\n import main::bar;\n \n-fn main(args: ~[str]) { #debug(\"foo\"); }\n+fn main(args: ~[str]) { debug!{\"foo\"}; }"}, {"sha": "c3ca71c67aa80cc0c3a952a86e02a2ace1cb2eae", "filename": "src/test/compile-fail/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimport4.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,4 +3,4 @@\n mod a { import foo = b::foo; export foo; }\n mod b { import foo = a::foo; export foo; }\n \n-fn main(args: ~[str]) { #debug(\"loop\"); }\n+fn main(args: ~[str]) { debug!{\"loop\"}; }"}, {"sha": "191dda5b4c1a5b3731439a62cac4ae57de68402d", "filename": "src/test/compile-fail/issue-1448-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-1.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,5 +3,5 @@\n fn main() {\n     #macro[[#apply[f, [x, ...]], f(x, ...)]];\n     fn add(a: int, b: int) -> int { ret a + b; }\n-    assert (#apply[add, [y, 15]] == 16); //~ ERROR unresolved name: y\n+    assert (apply!{add, [y, 15]} == 16); //~ ERROR unresolved name: y\n }"}, {"sha": "3b16071da2a95245cd62e34f19fdc15b3d8ccbbf", "filename": "src/test/compile-fail/issue-1448-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1448-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,5 +1,5 @@\n // Regresion test for issue #1448 and #1386\n \n fn main() {\n-    #debug[\"%u\", 10i]; //~ ERROR mismatched types\n+    debug!{\"%u\", 10i}; //~ ERROR mismatched types\n }"}, {"sha": "edfc22f93e950b66522251edba6dd36285bbb5a9", "filename": "src/test/compile-fail/liveness-if-with-else.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-if-with-else.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,7 +3,7 @@ fn foo(x: int) { log(debug, x); }\n fn main() {\n     let x: int;\n     if 1 > 2 {\n-        #debug(\"whoops\");\n+        debug!{\"whoops\"};\n     } else {\n         x = 10;\n     }"}, {"sha": "dbfaecf1817f5be4a62529ad77b39313ed9f24b8", "filename": "src/test/compile-fail/liveness-while-break.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-while-break.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@ fn test(cond: bool) {\n         v = 3;\n         break;\n     }\n-    #debug[\"%d\", v]; //~ ERROR use of possibly uninitialized variable: `v`\n+    debug!{\"%d\", v}; //~ ERROR use of possibly uninitialized variable: `v`\n }\n \n fn main() {"}, {"sha": "71ae833a139654e3650a8b1535a00b35e682f0a3", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,5 +6,5 @@ fn main() {\n                 f\n             }]];\n \n-    assert (#mylambda[y * 1, y * 2](8) == 16);\n+    assert (mylambda!{y * 1, y * 2}(8) == 16);\n }"}, {"sha": "602f074813b39ea85adda9a9953f64eb851ddae8", "filename": "src/test/compile-fail/macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fmacro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,6 +3,6 @@\n fn main() {\n     #macro[[#trivial[], 1 * 2 * 4 * 2 * 1]];\n \n-    assert (#trivial[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16] ==\n+    assert (trivial!{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16} ==\n                 16);\n }"}, {"sha": "cbecec982a2bcd5cfae9ab9bbadff45bb883c9d0", "filename": "src/test/compile-fail/not-utf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-utf8.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,5 +1,5 @@\n // error-pattern: is not UTF-8\n \n fn foo() {\n-    #include(\"not-utf8.bin\")\n+    include!{\"not-utf8.bin\"}\n }"}, {"sha": "1add6f7f3fe972e91cd40a9d693b912e2eda4605", "filename": "src/test/compile-fail/pure-higher-order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpure-higher-order.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -40,7 +40,7 @@ pure fn range8(from: uint, to: uint) {\n     range(from, to, noop);\n }\n \n-fn print(i: uint) { #error[\"i=%u\", i]; }\n+fn print(i: uint) { error!{\"i=%u\", i}; }\n \n pure fn noop(_i: uint) {}\n "}, {"sha": "80b42622ffdf4083d11f5735d4107900dde07eba", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -37,7 +37,7 @@ fn mk_ctxt() -> fake_ext_ctxt {\n fn main() {\n     let ext_cx = mk_ctxt();\n \n-    let stmt = #ast(stmt){let x int = 20;}; //~ ERROR expected end-of-string\n+    let stmt = #ast[stmt]{let x int = 20;}; //~ ERROR expected end-of-string\n     check_pp(*stmt,  pprust::print_stmt, \"\");\n }\n "}, {"sha": "2aa84a273ec9a188858bb80158367d5ee2a4e303", "filename": "src/test/compile-fail/regions-addr-of-self.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-addr-of-self.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -19,5 +19,6 @@ class dog {\n fn main() {\n     let d = dog();\n     d.chase_cat();\n-    #debug[\"cats_chased: %u\", d.cats_chased];\n+    debug!{\"cats_chased: %u\", d.cats_chased};\n }\n+"}, {"sha": "297b183a1b4228fba99d0f3c077b5d18e72c1745", "filename": "src/test/compile-fail/regions-escape-via-iface-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-iface-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-iface-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-iface-or-not.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -20,5 +20,5 @@ fn return_it() -> int {\n \n fn main() {\n     let x = return_it();\n-    #debug[\"foo=%d\", x];\n+    debug!{\"foo=%d\", x};\n }"}, {"sha": "1b59839f092a6d54234ca6a2a745e243e462b368", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -13,5 +13,5 @@ fn return_it() -> &a/int {\n \n fn main() {\n     let x = return_it();\n-    #debug[\"foo=%d\", *x];\n+    debug!{\"foo=%d\", *x};\n }"}, {"sha": "557394de741334663d38ffca4b3abe35e5f1a635", "filename": "src/test/compile-fail/regions-ret-borrowed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,5 +16,5 @@ fn return_it() -> &int {\n \n fn main() {\n     let x = return_it();\n-    #debug[\"foo=%d\", *x];\n+    debug!{\"foo=%d\", *x};\n }"}, {"sha": "24ac09a2d417371ece7768b17a907778fd015c37", "filename": "src/test/compile-fail/unbalanced-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funbalanced-comment.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,5 +7,5 @@\n  */\n \n fn main() {\n-  #debug(\"hello, world.\");\n+  debug!{\"hello, world.\"};\n }"}, {"sha": "8a4297d95b2f54c4341c6060048590b68d36c93c", "filename": "src/test/pretty/block-arg-disambig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblock-arg-disambig.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,4 +2,4 @@\n // is probably not necessary anymore (#2882)\n \n fn blk1(b: fn()) -> fn@() { ret fn@() { }; }\n-fn test1() { (do blk1 { #debug[\"hi\"]; })(); }\n+fn test1() { (do blk1 { debug!{\"hi\"}; })(); }"}, {"sha": "a5890b39fda54292352f3dc3498c6cf239a924c3", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -10,8 +10,8 @@ fn main() {\n     // wrap around to a small number.\n \n     let idx = uint::max_value & !(uint::max_value >> 1u);\n-    #error(\"ov2 idx = 0x%x\", idx);\n+    error!{\"ov2 idx = 0x%x\", idx};\n \n     // This should fail.\n-    #error(\"ov2 0x%x\",  x[idx]);\n+    error!{\"ov2 0x%x\",  x[idx]};\n }\n\\ No newline at end of file"}, {"sha": "c87557804084c0669442268577f9429879e21d9b", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow-3.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,17 +12,17 @@ fn main() {\n     // This test is only meaningful on 32-bit hosts.\n \n     let idx = u64::max_value & !(u64::max_value >> 1u);\n-    #error(\"ov3 idx = 0x%8.8x%8.8x\",\n+    error!{\"ov3 idx = 0x%8.8x%8.8x\",\n            (idx >> 32) as uint,\n-           idx as uint);\n+           idx as uint};\n \n     // This should fail.\n-    #error(\"ov3 0x%x\",  x[idx]);\n+    error!{\"ov3 0x%x\",  x[idx]};\n }\n \n #[cfg(target_arch=\"x86_64\")]\n fn main() {\n     // This version just fails anyways, for symmetry on 64-bit hosts.\n     let x = ~[1u,2u,3u];\n-    #error(\"ov3 0x%x\",  x[200]);\n+    error!{\"ov3 0x%x\",  x[200]};\n }"}, {"sha": "fdaaf2fe445af041da1035ad9039698d538b1ac0", "filename": "src/test/run-fail/bug-2470-bounds-check-overflow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-2470-bounds-check-overflow.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,13 +12,13 @@ fn main() {\n     do vec::as_buf(x) |p, _len| {\n         let base = p as uint;                     // base = 0x1230 say\n         let idx = base / sys::size_of::<uint>();  // idx  = 0x0246 say\n-        #error(\"ov1 base = 0x%x\", base);\n-        #error(\"ov1 idx = 0x%x\", idx);\n-        #error(\"ov1 sizeof::<uint>() = 0x%x\", sys::size_of::<uint>());\n-        #error(\"ov1 idx * sizeof::<uint>() = 0x%x\",\n-               idx * sys::size_of::<uint>());\n+        error!{\"ov1 base = 0x%x\", base};\n+        error!{\"ov1 idx = 0x%x\", idx};\n+        error!{\"ov1 sizeof::<uint>() = 0x%x\", sys::size_of::<uint>()};\n+        error!{\"ov1 idx * sizeof::<uint>() = 0x%x\",\n+               idx * sys::size_of::<uint>()};\n \n         // This should fail.\n-        #error(\"ov1 0x%x\",  x[idx]);\n+        error!{\"ov1 0x%x\",  x[idx]};\n     }\n }\n\\ No newline at end of file"}, {"sha": "4b5a41c6eb2b28fcadf001329e3e31f5cac2c148", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     for iter::repeat(10u) {\n         do task::spawn {\n             let result = count(5u);\n-            #debug(\"result = %?\", result);\n+            debug!{\"result = %?\", result};\n             fail;\n         };\n     }"}, {"sha": "e45207c2ec693d549465693d168bbe1edcb42911", "filename": "src/test/run-fail/fmt-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-fail%2Ffmt-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffmt-fail.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,4 +1,4 @@\n // error-pattern:meh\n use std;\n \n-fn main() { let str_var: ~str = ~\"meh\"; fail #fmt[\"%s\", str_var]; }\n+fn main() { let str_var: ~str = ~\"meh\"; fail fmt!{\"%s\", str_var}; }"}, {"sha": "f4dbf24f005f329aa0fe59070030aaef8533150e", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -46,8 +46,8 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n fn main() {\n     let ext_cx = mk_ctxt();\n-    let s = #ast(expr){__s};\n-    let e = #ast(expr){__e};\n-    let f = #ast(expr){$(s).foo {|__e| $(e)}};\n+    let s = #ast[expr]{__s};\n+    let e = #ast[expr]{__e};\n+    let f = #ast[expr]{$(s).foo {|__e| $(e)}};\n     log(error, pprust::expr_to_str(f));\n }"}, {"sha": "173884d1d6677e04545341229a8539b1c02161a2", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -40,25 +40,25 @@ fn main() {\n     let expr4 = #ast{2 - $(#ast{3}) + 9};\n     check_pp(expr4,  pprust::print_expr, ~\"2 - 3 + 9\");\n \n-    let ty = #ast(ty){int};\n+    let ty = #ast[ty]{int};\n     check_pp(ty, pprust::print_type, ~\"int\");\n \n-    let ty2 = #ast(ty){option<$(ty)>};\n+    let ty2 = #ast[ty]{option<$(ty)>};\n     check_pp(ty2, pprust::print_type, ~\"option<int>\");\n \n-    let item = #ast(item){const x : int = 10;};\n+    let item = #ast[item]{const x : int = 10;};\n     check_pp(item, pprust::print_item, ~\"const x: int = 10;\");\n \n-    let item2: @ast::item = #ast(item){const x : int = $(abc);};\n+    let item2: @ast::item = #ast[item]{const x : int = $(abc);};\n     check_pp(item2, pprust::print_item, ~\"const x: int = 23;\");\n \n-    let stmt = #ast(stmt){let x = 20;};\n+    let stmt = #ast[stmt]{let x = 20;};\n     check_pp(*stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n-    let stmt2 = #ast(stmt){let x : $(ty) = $(abc);};\n+    let stmt2 = #ast[stmt]{let x : $(ty) = $(abc);};\n     check_pp(*stmt2, pprust::print_stmt, ~\"let x: int = 23;\");\n \n-    let pat = #ast(pat){some(_)};\n+    let pat = #ast[pat]{some(_)};\n     check_pp(pat, pprust::print_pat, ~\"some(_)\");\n \n     // issue #1785\n@@ -73,13 +73,13 @@ fn main() {\n     let test3 = #ast{$(x) + $(y)};\n     check_pp(test3, pprust::print_expr, ~\"1 + 2\");\n \n-    let crate = #ast(crate) { fn a() { } };\n+    let crate = #ast[crate] { fn a() { } };\n     check_pp(crate, pprust::print_crate_, ~\"fn a() { }\\n\");\n \n     // issue #1926\n-    let s = #ast(expr){__s};\n-    let e = #ast(expr){__e};\n-    let call = #ast(expr){$(s).foo(|__e| $(e) )};\n+    let s = #ast[expr]{__s};\n+    let e = #ast[expr]{__e};\n+    let call = #ast[expr]{$(s).foo(|__e| $(e) )};\n     check_pp(call, pprust::print_expr, ~\"__s.foo(|__e| __e)\")\n }\n \n@@ -91,7 +91,7 @@ fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: ~str) {\n     let str = mem_buffer_str(buf);\n     stdout().write_line(str);\n     if expect != ~\"\" {\n-        #error(\"expect: '%s', got: '%s'\", expect, str);\n+        error!{\"expect: '%s', got: '%s'\", expect, str};\n         assert str == expect;\n     }\n }"}, {"sha": "af2310926f1c6e8b3b559515d8ff56a098121dbb", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -17,7 +17,7 @@ fn f(c: comm::_chan<int>) {\n \n     loop {\n         // spin waiting for the parent to kill us.\n-        #debug(\"child waiting to die...\");\n+        debug!{\"child waiting to die...\"};\n \n         // while waiting to die, the messages we are\n         // sending to the channel are never received\n@@ -35,5 +35,5 @@ fn main() {\n     // synchronize on event from child.\n     i = p.recv();\n \n-    #debug(\"parent exiting, killing child\");\n+    debug!{\"parent exiting, killing child\"};\n }"}, {"sha": "d2fd007f1a8369061d30be05d56d9e0c4674eece", "filename": "src/test/run-pass/alignment-gep-tup-like-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-1.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -8,7 +8,7 @@ fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n \n fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n-    #debug[\"a=%? b=%?\", a, b];\n+    debug!{\"a=%? b=%?\", a, b};\n     assert a == 22u64;\n     assert b == 44u16;\n }\n\\ No newline at end of file"}, {"sha": "8d4315b8daa07809707cd8361bfa73e690dd3662", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -23,7 +23,7 @@ fn main() {\n     let z = f(~x, y);\n     make_cycle(z);\n     let (a, b) = z();\n-    #debug[\"a=%u b=%u\", *a as uint, b as uint];\n+    debug!{\"a=%u b=%u\", *a as uint, b as uint};\n     assert *a == x;\n     assert b == y;\n }\n\\ No newline at end of file"}, {"sha": "637c2c8dabf872fdbf0881415fe71fceaac032d7", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -13,4 +13,4 @@ fn foo<T>(y: option<T>) {\n     ret;\n }\n \n-fn main() { #debug(\"hello\"); foo::<int>(some::<int>(5)); }\n+fn main() { debug!{\"hello\"}; foo::<int>(some::<int>(5)); }"}, {"sha": "b8ce72992719b44045c92e1fe4408af4459d0c5a", "filename": "src/test/run-pass/alt-pattern-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-drop.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,7 +14,7 @@ fn foo(s: @int) {\n         log(debug, y); // ref up then down\n \n       }\n-      _ { #debug(\"?\"); fail; }\n+      _ { debug!{\"?\"}; fail; }\n     }\n     log(debug, sys::refcount(s));\n     assert (sys::refcount(s) == count + 1u);"}, {"sha": "e904818d688abaac24dc0d2fa0c6f6fe6530bfaf", "filename": "src/test/run-pass/alt-pattern-lit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-lit.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,8 +2,8 @@\n \n fn altlit(f: int) -> int {\n     alt check f {\n-      10 { #debug(\"case 10\"); ret 20; }\n-      11 { #debug(\"case 11\"); ret 22; }\n+      10 { debug!{\"case 10\"}; ret 20; }\n+      11 { debug!{\"case 11\"}; ret 22; }\n     }\n }\n "}, {"sha": "91340f94333c8d4e3191b44a608f4252952b45c1", "filename": "src/test/run-pass/alt-pattern-no-type-params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-pattern-no-type-params.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,7 +1,7 @@\n enum maybe<T> { nothing, just(T), }\n \n fn foo(x: maybe<int>) {\n-    alt x { nothing { #error(\"A\"); } just(a) { #error(\"B\"); } }\n+    alt x { nothing { error!{\"A\"}; } just(a) { error!{\"B\"}; } }\n }\n \n fn main() { }"}, {"sha": "98fdb9ee2b853fb9267e25e8bea8927c6791eafb", "filename": "src/test/run-pass/alt-tag.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -11,9 +11,9 @@ enum color {\n fn process(c: color) -> int {\n     let mut x: int;\n     alt c {\n-      rgb(r, _, _) { #debug(\"rgb\"); log(debug, r); x = r; }\n-      rgba(_, _, _, a) { #debug(\"rgba\"); log(debug, a); x = a; }\n-      hsl(_, s, _) { #debug(\"hsl\"); log(debug, s); x = s; }\n+      rgb(r, _, _) { debug!{\"rgb\"}; log(debug, r); x = r; }\n+      rgba(_, _, _, a) { debug!{\"rgba\"}; log(debug, a); x = a; }\n+      hsl(_, s, _) { debug!{\"hsl\"}; log(debug, s); x = s; }\n     }\n     ret x;\n }"}, {"sha": "0f47c9105297af2b083c1a6a9ea546f534af1bc8", "filename": "src/test/run-pass/alt-unique-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-unique-bind.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n     alt ~100 {\n       ~x {\n-        #debug(\"%?\", x);\n+        debug!{\"%?\", x};\n         assert x == 100;\n       }\n     }"}, {"sha": "46e743cde6c6d4fda62d24dff6f27590b252a3e0", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -19,7 +19,7 @@ fn test_ser_and_deser<A>(a1: A,\n     // check the pretty printer:\n     io_ser_fn(io::stdout(), a1);\n     let s = io::with_str_writer(|w| io_ser_fn(w, a1) );\n-    #debug[\"s == %?\", s];\n+    debug!{\"s == %?\", s};\n     assert s == expected;\n \n     // check the EBML serializer:"}, {"sha": "31d04b88d440720f6cd82383a6b9c011831b35aa", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -17,15 +17,15 @@ fn main() {\n     let mut n: int = 0;\n     n = recv(p);\n     n = recv(p);\n-    //    #debug(\"Finished.\");\n+    //    debug!{\"Finished.\"};\n }\n \n fn b(c: chan<int>) {\n-    //    #debug(\"task b0\");\n-    //    #debug(\"task b1\");\n-    //    #debug(\"task b2\");\n-    //    #debug(\"task b3\");\n-    //    #debug(\"task b4\");\n-    //    #debug(\"task b5\");\n+    //    debug!{\"task b0\"};\n+    //    debug!{\"task b1\"};\n+    //    debug!{\"task b2\"};\n+    //    debug!{\"task b3\"};\n+    //    debug!{\"task b4\"};\n+    //    debug!{\"task b5\"};\n     send(c, 10);\n }"}, {"sha": "ba81fb1ff9b703eddec15708f0788a08fec59d8d", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -8,7 +8,7 @@ import comm::chan;\n import comm::recv;\n import task;\n \n-fn a(c: chan<int>) { #debug(\"task a0\"); #debug(\"task a1\"); send(c, 10); }\n+fn a(c: chan<int>) { debug!{\"task a0\"}; debug!{\"task a1\"}; send(c, 10); }\n \n fn main() {\n     let p = port();\n@@ -18,14 +18,14 @@ fn main() {\n     let mut n: int = 0;\n     n = recv(p);\n     n = recv(p);\n-    #debug(\"Finished.\");\n+    debug!{\"Finished.\"};\n }\n \n fn b(c: chan<int>) {\n-    #debug(\"task b0\");\n-    #debug(\"task b1\");\n-    #debug(\"task b2\");\n-    #debug(\"task b2\");\n-    #debug(\"task b3\");\n+    debug!{\"task b0\"};\n+    debug!{\"task b1\"};\n+    debug!{\"task b2\"};\n+    debug!{\"task b2\"};\n+    debug!{\"task b3\"};\n     send(c, 10);\n }"}, {"sha": "786b34cb9842863ada4ace64581970b30d0b21ea", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,11 +9,11 @@ import task;\n \n fn a(c: chan<int>) {\n     if true {\n-        #debug(\"task a\");\n-        #debug(\"task a\");\n-        #debug(\"task a\");\n-        #debug(\"task a\");\n-        #debug(\"task a\");\n+        debug!{\"task a\"};\n+        debug!{\"task a\"};\n+        debug!{\"task a\"};\n+        debug!{\"task a\"};\n+        debug!{\"task a\"};\n     }\n     send(c, 10);\n }\n@@ -39,17 +39,17 @@ fn main() {\n     log(debug, x);\n     n = recv(p);\n     n = recv(p);\n-    #debug(\"children finished, root finishing\");\n+    debug!{\"children finished, root finishing\"};\n }\n \n fn b(c: chan<int>) {\n     if true {\n-        #debug(\"task b\");\n-        #debug(\"task b\");\n-        #debug(\"task b\");\n-        #debug(\"task b\");\n-        #debug(\"task b\");\n-        #debug(\"task b\");\n+        debug!{\"task b\"};\n+        debug!{\"task b\"};\n+        debug!{\"task b\"};\n+        debug!{\"task b\"};\n+        debug!{\"task b\"};\n+        debug!{\"task b\"};\n     }\n     send(c, 10);\n }"}, {"sha": "19bfaac0f0c03f9e7534c7fac2b142ea094eaba1", "filename": "src/test/run-pass/binops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbinops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbinops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbinops.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -136,9 +136,9 @@ fn test_class() {\n   let r = p(1, 2);\n   \n   unsafe {\n-  #error(\"q = %x, r = %x\",\n+  error!{\"q = %x, r = %x\",\n          (unsafe::reinterpret_cast::<*p, uint>(ptr::addr_of(q))),\n-         (unsafe::reinterpret_cast::<*p, uint>(ptr::addr_of(r))));\n+         (unsafe::reinterpret_cast::<*p, uint>(ptr::addr_of(r)))};\n   }\n   assert(q == r);\n   r.y = 17;"}, {"sha": "f3eed8cc26de8fcb674028be51666eb072b60c9b", "filename": "src/test/run-pass/borrowck-mut-uniq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-uniq.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -19,8 +19,8 @@ fn main() {\n     add_int(ints, 44);\n \n     for iter_ints(ints) |i| {\n-        #error[\"int = %d\", *i];\n+        error!{\"int = %d\", *i};\n     }\n \n-    #error[\"ints=%?\", ints];\n+    error!{\"ints=%?\", ints};\n }"}, {"sha": "0bbd2b2d90a96ca71acee7e7aed6bdab731315dc", "filename": "src/test/run-pass/borrowck-preserve-box-in-discr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-discr.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ fn main() {\n \n         x = @{f: ~4};\n \n-        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n       }"}, {"sha": "17831948b54fdf2739e9fa3a718d18b0ec9fc324", "filename": "src/test/run-pass/borrowck-preserve-box-in-field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-field.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         x = @{f: ~4};\n \n-        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n     }"}, {"sha": "cf738e02d2f98c4ac1d621626438714589dbf202", "filename": "src/test/run-pass/borrowck-preserve-box-in-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-pat.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ fn main() {\n \n         *x = @{f: ~4};\n \n-        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n       }"}, {"sha": "05f403425b3fa32bde8713ce3346e37dbb87eab9", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         *x = @{f: ~4};\n \n-        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n     }"}, {"sha": "886d9172cec7b7d751162bb001499e5cbe93f54e", "filename": "src/test/run-pass/borrowck-preserve-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x) == ptr::addr_of(*b_x);\n         x = @22;\n \n-        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n         assert *b_x == 3;\n         assert ptr::addr_of(*x) != ptr::addr_of(*b_x);\n     }"}, {"sha": "c5d815834b2d94b62eacce4aa228f862863f2e73", "filename": "src/test/run-pass/borrowck-preserve-cond-box.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-cond-box.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,13 +14,13 @@ fn testfn(cond: bool) {\n         exp = 4;\n     }\n \n-    #debug[\"*r = %d, exp = %d\", *r, exp];\n+    debug!{\"*r = %d, exp = %d\", *r, exp};\n     assert *r == exp;\n \n     x = @5;\n     y = @6;\n \n-    #debug[\"*r = %d, exp = %d\", *r, exp];\n+    debug!{\"*r = %d, exp = %d\", *r, exp};\n     assert *r == exp;\n }\n "}, {"sha": "30f33beea4822bbc157795eb94c10f6fff85f81a", "filename": "src/test/run-pass/borrowck-preserve-expl-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-expl-deref.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,7 +14,7 @@ fn main() {\n         assert ptr::addr_of(*x.f) == ptr::addr_of(*b_x);\n         x = @{f: ~4};\n \n-        #debug[\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint];\n+        debug!{\"ptr::addr_of(*b_x) = %x\", ptr::addr_of(*b_x) as uint};\n         assert *b_x == 3;\n         assert ptr::addr_of(*x.f) != ptr::addr_of(*b_x);\n     }"}, {"sha": "3366906ec947250efd30e282533a0be717870177", "filename": "src/test/run-pass/box-inside-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ fn is_odd(n: int) -> bool { ret true; }\n fn length_is_even(vs: @int) -> bool { ret true; }\n \n fn foo(acc: int, n: int) {\n-    if is_odd(n) && length_is_even(some_box(1)) { #error(\"bloop\"); }\n+    if is_odd(n) && length_is_even(some_box(1)) { error!{\"bloop\"}; }\n }\n \n fn main() { foo(67, 5); }"}, {"sha": "97a7a919712dad40c1518622d0c0c78505d64b2b", "filename": "src/test/run-pass/box-inside-if2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-inside-if2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ fn is_odd(n: int) -> bool { ret true; }\n fn length_is_even(vs: @int) -> bool { ret true; }\n \n fn foo(acc: int, n: int) {\n-    if is_odd(n) || length_is_even(some_box(1)) { #error(\"bloop\"); }\n+    if is_odd(n) || length_is_even(some_box(1)) { error!{\"bloop\"}; }\n }\n \n fn main() { foo(67, 5); }"}, {"sha": "48c7c046d3702b7d0e22efcd4e250d13b30e3eeb", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,6 +7,6 @@ fn unbox<T: copy>(b: box<T>) -> T { ret *b.c; }\n fn main() {\n     let foo: int = 17;\n     let bfoo: box<int> = {c: @foo};\n-    #debug(\"see what's in our box\");\n+    debug!{\"see what's in our box\"};\n     assert (unbox::<int>(bfoo) == foo);\n }"}, {"sha": "5a174f4c4aa231a03ed154ce58a03a7716700076", "filename": "src/test/run-pass/by-val-and-by-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,7 +3,7 @@\n \n fn it_takes_two(x: @int, -y: @int) -> int {\n     free(y);\n-    #debug[\"about to deref\"];\n+    debug!{\"about to deref\"};\n     *x\n }\n "}, {"sha": "7372450f496498b115338d27cb3981a13aaeff10", "filename": "src/test/run-pass/cast-region-to-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = 3;\n-    #debug[\"&x=%x\", &x as uint];\n+    debug!{\"&x=%x\", &x as uint};\n }\n\\ No newline at end of file"}, {"sha": "95de5dddf6df1b9bded7b57a65fa90651a10d70d", "filename": "src/test/run-pass/cci_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_borrow.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,6 +7,6 @@ import cci_borrow_lib::foo;\n fn main() {\n     let p = @22u;\n     let r = foo(p);\n-    #debug[\"r=%u\", r];\n+    debug!{\"r=%u\", r};\n     assert r == 22u;\n }"}, {"sha": "55bb9a8ad352d08d0af27ac8ad3650d55ddd1992", "filename": "src/test/run-pass/cci_impl_exe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_impl_exe.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,13 +7,13 @@ import cci_impl_lib::uint_helpers;\n \n fn main() {\n     //let bt0 = sys::frame_address();\n-    //#debug[\"%?\", bt0];\n+    //debug!{\"%?\", bt0};\n \n     do 3u.to(10u) |i| {\n-        io::print(#fmt[\"%u\\n\", i]);\n+        io::print(fmt!{\"%u\\n\", i});\n \n         //let bt1 = sys::frame_address();\n-        //#debug[\"%?\", bt1];\n+        //debug!{\"%?\", bt1};\n         //assert bt0 == bt1;\n     }\n }"}, {"sha": "0ba2a2190feb4d332e2e26b3a13f115392fc7704", "filename": "src/test/run-pass/cci_iter_exe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_iter_exe.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -5,9 +5,9 @@ use cci_iter_lib;\n \n fn main() {\n     //let bt0 = sys::rusti::frame_address(1u32);\n-    //#debug[\"%?\", bt0];\n+    //debug!{\"%?\", bt0};\n     do cci_iter_lib::iter(~[1, 2, 3]) |i| {\n-        io::print(#fmt[\"%d\", i]);\n+        io::print(fmt!{\"%d\", i});\n         //assert bt0 == sys::rusti::frame_address(2u32);\n     }\n }"}, {"sha": "51bc773b5c878ba62e1233f2b9e8d4e85c9db34d", "filename": "src/test/run-pass/cci_no_inline_exe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_no_inline_exe.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -11,12 +11,12 @@ fn main() {\n     // sys::frame_address() to determine if we are inlining is\n     // actually working.\n     //let bt0 = sys::frame_address();\n-    //#debug[\"%?\", bt0];\n+    //debug!{\"%?\", bt0};\n     do iter(~[1u, 2u, 3u]) |i| {\n-        io::print(#fmt[\"%u\\n\", i]);\n+        io::print(fmt!{\"%u\\n\", i});\n \n         //let bt1 = sys::frame_address();\n-        //#debug[\"%?\", bt1];\n+        //debug!{\"%?\", bt1};\n \n         //assert bt0 != bt1;\n     }"}, {"sha": "b41359b735f672736f9f581a434183ec7e1f707c", "filename": "src/test/run-pass/class-attributes-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-1.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@ class cat {\n     #[cat_maker]\n     new(name: ~str) { self.name = name; }\n     #[cat_dropper]\n-    drop { #error[\"%s landed on hir feet\", self.name]; }\n+    drop { error!{\"%s landed on hir feet\", self.name}; }\n     let name: ~str;\n }\n "}, {"sha": "d08ef04eca62a0f5c3a2ef53ac5e8164248da73f", "filename": "src/test/run-pass/class-attributes-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-attributes-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -9,7 +9,7 @@ class cat {\n   /**\n      Actually, cats don't always land on their feet when you drop them.\n   */\n-  drop { #error(\"%s landed on hir feet\", self.name); }\n+  drop { error!{\"%s landed on hir feet\", self.name}; }\n }\n \n fn main() {"}, {"sha": "24ffaa22cd406ffeaa79174f7feda49f3983825f", "filename": "src/test/run-pass/class-cast-to-iface-cross-crate-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,7 +6,7 @@ import cci_class_cast::kitty::*;\n \n fn print_out<T: to_str>(thing: T, expected: ~str) {\n   let actual = thing.to_str();\n-  #debug(\"%s\", actual);\n+  debug!{\"%s\", actual};\n   assert(actual == expected);\n }\n "}, {"sha": "765aba74cc2c1e134ef959b2707ea7bdbec564ed", "filename": "src/test/run-pass/class-cast-to-iface-cross-crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-cross-crate.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@ class cat : to_str {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ class cat : to_str {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }\n@@ -40,7 +40,7 @@ class cat : to_str {\n \n fn print_out<T: to_str>(thing: T, expected: str) {\n   let actual = thing.to_str();\n-  #debug(\"%s\", actual);\n+  debug!{\"%s\", actual};\n   assert(actual == expected);\n }\n "}, {"sha": "a55ef9f8bd7b11716da00aec05a721114af106c9", "filename": "src/test/run-pass/class-cast-to-iface-multiple-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface-multiple-types.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,15 +6,15 @@ class dog : noisy {\n   priv {\n     let barks : @mut uint;\n     fn bark() -> int {\n-      #debug(\"Woof %u %d\", *self.barks, *self.volume);\n+      debug!{\"Woof %u %d\", *self.barks, *self.volume};\n       *self.barks += 1u;\n       if *self.barks % 3u == 0u {\n           *self.volume += 1;\n       }\n       if *self.barks % 10u == 0u {\n           *self.volume -= 2;\n       }\n-      #debug(\"Grrr %u %d\", *self.barks, *self.volume);\n+      debug!{\"Grrr %u %d\", *self.barks, *self.volume};\n       *self.volume\n     }\n   }\n@@ -30,7 +30,7 @@ class cat : noisy {\n   priv {\n     let meows : @mut uint;\n     fn meow() -> uint {\n-      #debug(\"Meow\");\n+      debug!{\"Meow\"};\n       *self.meows += 1u;\n       if *self.meows % 5u == 0u {\n           *self.how_hungry += 1;"}, {"sha": "bba7540d22b0e09c16d69d2c71a844935b037467", "filename": "src/test/run-pass/class-cast-to-iface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-iface.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,7 +6,7 @@ class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -24,12 +24,12 @@ class cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "fe31eb7a3806667c9465c3cfe082be70033345a0", "filename": "src/test/run-pass/class-impl-parameterized-iface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-parameterized-iface.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -10,7 +10,7 @@ class cat : map<int, bool> {\n     let mut meows : int;\n     fn meow() {\n       self.meows += 1;\n-      #error(\"Meow %d\", self.meows);\n+      error!{\"Meow %d\", self.meows};\n       if self.meows % 5 == 0 {\n           self.how_hungry += 1;\n       }\n@@ -27,12 +27,12 @@ class cat : map<int, bool> {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "4126df0f5b7b71bb35464184b4c9255c681bbb9a", "filename": "src/test/run-pass/class-impl-very-parameterized-iface.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-iface.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -13,7 +13,7 @@ class cat<T: copy> : map<int, T> {\n     let mut meows : int;\n     fn meow() {\n       self.meows += 1;\n-      #error(\"Meow %d\", self.meows);\n+      error!{\"Meow %d\", self.meows};\n       if self.meows % 5 == 0 {\n           self.how_hungry += 1;\n       }\n@@ -30,12 +30,12 @@ class cat<T: copy> : map<int, T> {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "a66289a7ece2b316618bfc141cd2847853663fcc", "filename": "src/test/run-pass/class-implement-iface-cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-iface-cross-crate.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@ class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -25,12 +25,12 @@ class cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "eedc308a46002edfab816aca1063512a39b5f12a", "filename": "src/test/run-pass/class-implement-ifaces.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implement-ifaces.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,7 +6,7 @@ class cat : noisy {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -24,12 +24,12 @@ class cat : noisy {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "b8fd1dd2f27304766de78835868734d0f613563f", "filename": "src/test/run-pass/class-implements-multiple-ifaces.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-implements-multiple-ifaces.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -33,7 +33,7 @@ class cat : noisy, scratchy, bitey {\n     let bite_counts : hashmap<body_part, uint>;\n \n     fn meow() -> uint {\n-      #debug(\"Meow: %u\", *self.meows);\n+      debug!{\"Meow: %u\", *self.meows};\n       *self.meows += 1u;\n       if *self.meows % 5u == 0u {\n           *self.how_hungry += 1;\n@@ -72,32 +72,32 @@ class cat : noisy, scratchy, bitey {\n     rslt\n   }\n   fn bite() -> body_part {\n-    #error(\"In bite()\");\n+    error!{\"In bite()\"};\n     let all = ~[toe, nose, ear];\n     let mut min = finger;\n     do iter(all) |next| {\n-      #debug(\"min = %?\", min);\n+      debug!{\"min = %?\", min};\n         if self.bite_counts.get(next) < self.bite_counts.get(min) {\n             min = next;\n           }};\n     self.bite_counts.insert(min, self.bite_counts.get(min) + 1u);\n-    #debug(\"Bit %?\", min);\n+    debug!{\"Bit %?\", min};\n     min\n   }\n }\n \n fn annoy_neighbors<T: noisy>(critter: T) {\n   for uint::range(0u, 10u) |i| {\n       let what = critter.speak();\n-      #debug(\"%u %d\", i, what);\n+      debug!{\"%u %d\", i, what};\n   }\n }\n \n fn bite_everything<T: bitey>(critter: T) -> bool {\n   let mut left : ~[body_part] = ~[finger, toe, nose, ear];\n   while vec::len(left) > 0u {\n     let part = critter.bite();\n-    #debug(\"%? %?\", left, part);\n+    debug!{\"%? %?\", left, part};\n     if vec_includes(left, part) {\n         left = vec::filter(left, |p| p != part );\n     }"}, {"sha": "35c462e9dc2db12904b3531f377a94b6f0f0be7c", "filename": "src/test/run-pass/class-separate-impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-separate-impl.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,7 +6,7 @@ class cat {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -24,12 +24,12 @@ class cat {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }\n@@ -41,7 +41,7 @@ impl of to_str for cat {\n \n fn print_out<T: to_str>(thing: T, expected: ~str) {\n   let actual = thing.to_str();\n-  #debug(\"%s\", actual);\n+  debug!{\"%s\", actual};\n   assert(actual == expected);\n }\n "}, {"sha": "175d2c35c7732105c7bdc57b7b3f0b21e488a85d", "filename": "src/test/run-pass/classes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,7 +2,7 @@ class cat {\n   priv {\n     let mut meows : uint;\n     fn meow() {\n-      #error(\"Meow\");\n+      error!{\"Meow\"};\n       self.meows += 1u;\n       if self.meows % 5u == 0u {\n           self.how_hungry += 1;\n@@ -20,12 +20,12 @@ class cat {\n \n   fn eat() -> bool {\n     if self.how_hungry > 0 {\n-        #error(\"OM NOM NOM\");\n+        error!{\"OM NOM NOM\"};\n         self.how_hungry -= 2;\n         ret true;\n     }\n     else {\n-        #error(\"Not hungry!\");\n+        error!{\"Not hungry!\"};\n         ret false;\n     }\n   }"}, {"sha": "6e67451f6d9eb3ce57f1761bc903cd3f66a5a092", "filename": "src/test/run-pass/close-over-big-then-small-data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclose-over-big-then-small-data.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,7 +12,7 @@ fn f<A:copy owned>(a: A, b: u16) -> fn@() -> (A, u16) {\n \n fn main() {\n     let (a, b) = f(22_u64, 44u16)();\n-    #debug[\"a=%? b=%?\", a, b];\n+    debug!{\"a=%? b=%?\", a, b};\n     assert a == 22u64;\n     assert b == 44u16;\n }"}, {"sha": "d5be0affdb91830809a413e5dd38f987e3c8e094", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,13 +12,13 @@ fn main() {\n     let ch = comm::chan(p);\n     let t = task::spawn(|| child(ch) );\n     let y = recv(p);\n-    #error(\"received\");\n+    error!{\"received\"};\n     log(error, y);\n     assert (y == 10);\n }\n \n fn child(c: chan<int>) {\n-    #error(\"sending\");\n+    error!{\"sending\"};\n     send(c, 10);\n-    #error(\"value sent\");\n+    error!{\"value sent\"};\n }"}, {"sha": "104c312d673428662439d5f3f31fc0464e376b09", "filename": "src/test/run-pass/complex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -28,6 +28,6 @@ fn foo(x: int) -> int {\n fn main() {\n     let x: int = 2 + 2;\n     log(debug, x);\n-    #debug(\"hello, world\");\n+    debug!{\"hello, world\"};\n     log(debug, 10);\n }"}, {"sha": "0785005fac9418ab761f064cdf4c7a1cb5435641", "filename": "src/test/run-pass/dead-code-one-arm-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,4 +2,4 @@\n \n \n // -*- rust -*-\n-fn main() { if 1 == 1 { ret; } #debug(\"Paul is dead\"); }\n+fn main() { if 1 == 1 { ret; } debug!{\"Paul is dead\"}; }"}, {"sha": "a091e975177f282e87d18bc56153d4eb7c62f316", "filename": "src/test/run-pass/export-non-interference2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -6,7 +6,7 @@ mod foo {\n         fn y() { x(); }\n     }\n \n-    fn x() { #debug(\"x\"); }\n+    fn x() { debug!{\"x\"}; }\n }\n \n fn main() { foo::bar::y(); }"}, {"sha": "55b45d626e1f40697908f754eba92962159e1cce", "filename": "src/test/run-pass/export-non-interference3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference3.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -7,7 +7,7 @@ mod foo {\n mod bar {\n     export x;\n \n-    fn x() { #debug(\"x\"); }\n+    fn x() { debug!{\"x\"}; }\n }\n \n fn main() { foo::x(); }"}, {"sha": "146f371f290a232948705ae0d4f2a300aa04b892", "filename": "src/test/run-pass/extern-call-deep.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,12 +12,12 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    #debug(\"n = %?\", n);\n+    debug!{\"n = %?\", n};\n     rustrt::rust_dbg_call(cb, n)\n }\n \n fn main() {\n     let result = count(1000u);\n-    #debug(\"result = %?\", result);\n+    debug!{\"result = %?\", result};\n     assert result == 1000u;\n }\n\\ No newline at end of file"}, {"sha": "f9fbc1773bd112fc8edc9e2eff32f127b038733f", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,7 +12,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    #debug(\"n = %?\", n);\n+    debug!{\"n = %?\", n};\n     rustrt::rust_dbg_call(cb, n)\n }\n \n@@ -21,7 +21,7 @@ fn main() {\n     // has a large stack)\n     do task::spawn {\n         let result = count(1000u);\n-        #debug(\"result = %?\", result);\n+        debug!{\"result = %?\", result};\n         assert result == 1000u;\n     };\n }\n\\ No newline at end of file"}, {"sha": "4f7c7e233a78d738d066480e55cbd268fc2f84f7", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -16,7 +16,7 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn count(n: uint) -> uint {\n-    #debug(\"n = %?\", n);\n+    debug!{\"n = %?\", n};\n     rustrt::rust_dbg_call(cb, n)\n }\n \n@@ -25,7 +25,7 @@ fn main() {\n     // has a large stack)\n     do task::spawn {\n         let result = count(12u);\n-        #debug(\"result = %?\", result);\n+        debug!{\"result = %?\", result};\n         assert result == 2048u;\n     };\n }\n\\ No newline at end of file"}, {"sha": "7634d347cad716674ce2e53075c9e10a1f0dd147", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -12,12 +12,12 @@ extern fn cb(data: libc::uintptr_t) -> libc::uintptr_t {\n }\n \n fn fact(n: uint) -> uint {\n-    #debug(\"n = %?\", n);\n+    debug!{\"n = %?\", n};\n     rustrt::rust_dbg_call(cb, n)\n }\n \n fn main() {\n     let result = fact(10u);\n-    #debug(\"result = %?\", result);\n+    debug!{\"result = %?\", result};\n     assert result == 3628800u;\n }\n\\ No newline at end of file"}, {"sha": "290dc115a0b3254e2404c736f92160fc8311b773", "filename": "src/test/run-pass/extern-crosscrate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-crosscrate.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,12 +4,12 @@\n use externcallback(vers = \"0.1\");\n \n fn fact(n: uint) -> uint {\n-    #debug(\"n = %?\", n);\n+    debug!{\"n = %?\", n};\n     externcallback::rustrt::rust_dbg_call(externcallback::cb, n)\n }\n \n fn main() {\n     let result = fact(10u);\n-    #debug(\"result = %?\", result);\n+    debug!{\"result = %?\", result};\n     assert result == 3628800u;\n }"}, {"sha": "194970789c1d992d8bbb088e9743ad3f80265d75", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -20,7 +20,7 @@ fn main() {\n     for iter::repeat(10u) {\n         do task::spawn {\n             let result = count(5u);\n-            #debug(\"result = %?\", result);\n+            debug!{\"result = %?\", result};\n             assert result == 16u;\n         };\n     }"}, {"sha": "bf2329a94ff5d96c636632a734c3c8207dd6f1a0", "filename": "src/test/run-pass/fact.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Ffact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Ffact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffact.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,18 +3,18 @@\n \n // -*- rust -*-\n fn f(x: int) -> int {\n-    // #debug(\"in f:\");\n+    // debug!{\"in f:\"};\n \n     log(debug, x);\n     if x == 1 {\n-        // #debug(\"bottoming out\");\n+        // debug!{\"bottoming out\"};\n \n         ret 1;\n     } else {\n-        // #debug(\"recurring\");\n+        // debug!{\"recurring\"};\n \n         let y: int = x * f(x - 1);\n-        // #debug(\"returned\");\n+        // debug!{\"returned\"};\n \n         log(debug, y);\n         ret y;\n@@ -23,6 +23,6 @@ fn f(x: int) -> int {\n \n fn main() {\n     assert (f(5) == 120);\n-    // #debug(\"all done\");\n+    // debug!{\"all done\"};\n \n }"}, {"sha": "262ce59ae5826f6a3f1cfb11820260d3deef90db", "filename": "src/test/run-pass/float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffloat.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -5,6 +5,6 @@ fn main() {\n     log(debug, -pi * (pi + 2.0 / pi) - pi * 5.0);\n     if pi == 5.0 || pi < 10.0 || pi <= 2.0 || pi != 22.0 / 7.0 || pi >= 10.0\n            || pi > 1.0 {\n-        #debug(\"yes\");\n+        debug!{\"yes\"};\n     }\n }"}, {"sha": "6ab3deb74332d52b6866b63a013241841e67b527", "filename": "src/test/run-pass/fn-bare-item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Ffn-bare-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Ffn-bare-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-item.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,5 +1,5 @@\n fn f() {\n-    #debug(\"This is a bare function\");\n+    debug!{\"This is a bare function\"};\n }\n \n fn main() {"}, {"sha": "442e9eb4e19630324a3d5cd7f0575dd4b89bd6e0", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,13 +4,13 @@\n // -*- rust -*-\n fn main() {\n     let mut sum: int = 0;\n-    do first_ten |i| { #debug(\"main\"); log(debug, i); sum = sum + i; }\n-    #debug(\"sum\");\n+    do first_ten |i| { debug!{\"main\"}; log(debug, i); sum = sum + i; }\n+    debug!{\"sum\"};\n     log(debug, sum);\n     assert (sum == 45);\n }\n \n fn first_ten(it: fn(int)) {\n     let mut i: int = 0;\n-    while i < 10 { #debug(\"first_ten\"); it(i); i = i + 1; }\n+    while i < 10 { debug!{\"first_ten\"}; it(i); i = i + 1; }\n }"}, {"sha": "5857d1ae4215569ddaa286865c9dfc94480a3580", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@ enum foo<T> { arm(T), }\n \n fn altfoo<T>(f: foo<T>) {\n     let mut hit = false;\n-    alt f { arm::<T>(x) { #debug(\"in arm\"); hit = true; } }\n+    alt f { arm::<T>(x) { debug!{\"in arm\"}; hit = true; } }\n     assert (hit);\n }\n "}, {"sha": "80c942c69d1a1eaaf3867008b3e2c6ebda50d5b2", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -49,9 +49,9 @@ mod map_reduce {\n               some(_c) { c = _c }\n               none {\n                 let p = port();\n-                #error(\"sending find_reducer\");\n+                error!{\"sending find_reducer\"};\n                 send(ctrl, find_reducer(str::bytes(key), chan(p)));\n-                #error(\"receiving\");\n+                error!{\"receiving\"};\n                 c = recv(p);\n                 log(error, c);\n                 im.insert(key, c);"}, {"sha": "35ef6fbf695616f0e256b960346f7e148008d129", "filename": "src/test/run-pass/hello.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhello.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,4 +2,4 @@\n \n \n // -*- rust -*-\n-fn main() { #debug(\"hello, world.\"); }\n+fn main() { debug!{\"hello, world.\"}; }"}, {"sha": "ce1147dd176547baf07715ef077473801baf10c0", "filename": "src/test/run-pass/iface-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-cast.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -27,8 +27,8 @@ impl of to_str for int {\n impl of to_str for Tree {\n     fn to_str() -> ~str {\n         let l = self.left, r = self.right;\n-        #fmt[\"[%s, %s, %s]\", self.val.to_str(),\n-             l.to_str(), r.to_str()]\n+        fmt!{\"[%s, %s, %s]\", self.val.to_str(),\n+             l.to_str(), r.to_str()}\n     }\n }\n "}, {"sha": "0f830727768b65b0139b95f4e73f29310902c738", "filename": "src/test/run-pass/import-glob-0.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-0.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -5,10 +5,10 @@ mod module_of_many_things {\n     export f1;\n     export f2;\n     export f4;\n-    fn f1() { #debug(\"f1\"); }\n-    fn f2() { #debug(\"f2\"); }\n-    fn f3() { #debug(\"f3\"); }\n-    fn f4() { #debug(\"f4\"); }\n+    fn f1() { debug!{\"f1\"}; }\n+    fn f2() { debug!{\"f2\"}; }\n+    fn f3() { debug!{\"f3\"}; }\n+    fn f4() { debug!{\"f4\"}; }\n }\n \n mod dug {\n@@ -17,8 +17,8 @@ mod dug {\n             mod and {\n                 mod too {\n                     mod deep {\n-                        fn nameless_fear() { #debug(\"Boo!\"); }\n-                        fn also_redstone() { #debug(\"Whatever.\"); }\n+                        fn nameless_fear() { debug!{\"Boo!\"}; }\n+                        fn also_redstone() { debug!{\"Whatever.\"}; }\n                     }\n                 }\n             }"}, {"sha": "5ca7e028985927960fb2e4711f4800e49b5f7898", "filename": "src/test/run-pass/import-glob-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-glob-1.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -32,7 +32,7 @@ mod a2 {\n     mod b2 {\n         //   |\n         fn word_traveler() { //   |\n-            #debug(\"ahoy!\"); //  -/\n+            debug!{\"ahoy!\"}; //  -/\n         } //\n     } //\n }"}, {"sha": "8775f03f2e98e36642c81c3866c283275d70981d", "filename": "src/test/run-pass/import2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,7 +2,7 @@\n import zed::bar;\n \n mod zed {\n-    fn bar() { #debug(\"bar\"); }\n+    fn bar() { debug!{\"bar\"}; }\n }\n \n fn main() { bar(); }"}, {"sha": "95c68818412cd93502353440056fa69ec8a0a4d3", "filename": "src/test/run-pass/import3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport3.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@ import zed::bar;\n \n mod baz {\n     mod zed {\n-        fn bar() { #debug(\"bar2\"); }\n+        fn bar() { debug!{\"bar2\"}; }\n     }\n }\n "}, {"sha": "7df4ddbb71bd227f284ffccaa2a5af3327d6f063", "filename": "src/test/run-pass/import4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport4.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,7 +2,7 @@\n import zed::bar;\n \n mod zed {\n-    fn bar() { #debug(\"bar\"); }\n+    fn bar() { debug!{\"bar\"}; }\n }\n \n fn main(args: ~[~str]) { let zed = 42; bar(); }"}, {"sha": "bce048833c95ce93a461bb45361e6265c65e4540", "filename": "src/test/run-pass/import5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport5.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -3,7 +3,7 @@ mod foo {\n     import zed::bar;\n     export bar;\n     mod zed {\n-        fn bar() { #debug(\"foo\"); }\n+        fn bar() { debug!{\"foo\"}; }\n     }\n }\n "}, {"sha": "2449b5c7273dda423006b1eb5d0bc19165536416", "filename": "src/test/run-pass/import6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport6.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,7 +2,7 @@ import foo::zed;\n import bar::baz;\n mod foo {\n     mod zed {\n-        fn baz() { #debug(\"baz\"); }\n+        fn baz() { debug!{\"baz\"}; }\n     }\n }\n mod bar {"}, {"sha": "83923cce64d9f97ab206cd0e60cea242963e96b8", "filename": "src/test/run-pass/import7.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fimport7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport7.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,7 +2,7 @@ import foo::zed;\n import bar::baz;\n mod foo {\n     mod zed {\n-        fn baz() { #debug(\"baz\"); }\n+        fn baz() { debug!{\"baz\"}; }\n     }\n }\n mod bar {"}, {"sha": "27a123c0c4e9c5aaa619412615ef33ba06ad3a93", "filename": "src/test/run-pass/inner-module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Finner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Finner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finner-module.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n mod inner {\n     mod inner2 {\n-        fn hello() { #debug(\"hello, modular world\"); }\n+        fn hello() { debug!{\"hello, modular world\"}; }\n     }\n     fn hello() { inner2::hello(); }\n }"}, {"sha": "d2a9368d9d89e17799fe74c5264e0e8f6f6c1143", "filename": "src/test/run-pass/issue-1466.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-1466.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-1466.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1466.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -2,6 +2,6 @@\n // xfail-test\n \n fn main() {\n-    #error[\"%?\", os::getenv(~\"RUST_CC_ZEAL\")];\n+    error!{\"%?\", os::getenv(~\"RUST_CC_ZEAL\")};\n     let _x = @{a: @10, b: ~true};\n }"}, {"sha": "6309e967db26383852e2a4fa3c811f5e42663e55", "filename": "src/test/run-pass/issue-2101.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2101.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2101.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2101.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -14,7 +14,7 @@ fn main(args: ~[str]) {\n     let leak = init(&ar, args[0]);\n     alt *leak {\n         s(astr) {\n-            io::println(#fmt(\"%?\", astr));\n+            io::println(fmt!{\"%?\", astr});\n         }\n     };\n }"}, {"sha": "104ea37588bbc0187faae78763b53e3b0272f25c", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -44,5 +44,5 @@ fn main() {\n         a);\n     let sum = foldl(filt, 0u, |accum, &&n: uint| accum + n );\n \n-    io::println(#fmt(\"%u\", sum));\n+    io::println(fmt!{\"%u\", sum});\n }\n\\ No newline at end of file"}, {"sha": "d08a863529c79721e1cfe59edb8fdf1b59a4c11e", "filename": "src/test/run-pass/issue-2633.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2633.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -1,6 +1,6 @@\n class cat {\n     let mut meow: fn@();\n-    new() { self.meow = fn@() { #error(\"meow\"); };}\n+    new() { self.meow = fn@() { error!{\"meow\"}; };}\n }\n \n type kitty_info = {kitty: cat};"}, {"sha": "da7953a23706819338b5a748bcb4e72eb84d3b53", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -4,7 +4,7 @@ use std;\n import std::map::hashmap;\n \n fn add_interfaces(managed_ip: ~str, device: std::map::hashmap<~str, int>)  {\n-     #error[\"%s, %?\", managed_ip, device[~\"interfaces\"]];\n+     error!{\"%s, %?\", managed_ip, device[~\"interfaces\"]};\n }\n \n fn main() {}"}, {"sha": "811f5a52a14c674b6bdf4ac408603a8beafac21b", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cc5066ee61f20e7cc59141d5c7213a452a2778/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=a9cc5066ee61f20e7cc59141d5c7213a452a2778", "patch": "@@ -19,7 +19,7 @@ fn lookup(table: std::map::hashmap<~str, std::json::json>, key: ~str, default: ~\n         }\n         option::some(value)\n         {\n-            #error[\"%s was expected to be a string but is a %?\", key, value];\n+            error!{\"%s was expected to be a string but is a %?\", key, value};\n             default\n         }\n         option::none\n@@ -36,13 +36,13 @@ fn add_interface(store: int, managed_ip: ~str, data: std::json::json) -> (~str,\n         std::json::dict(interface)\n         {\n             let name = lookup(interface, ~\"ifDescr\", ~\"\");\n-            let label = #fmt[\"%s-%s\", managed_ip, name];\n+            let label = fmt!{\"%s-%s\", managed_ip, name};\n \n             (label, bool_value(false))\n         }\n         _\n         {\n-            #error[\"Expected dict for %s interfaces but found %?\", managed_ip, data];\n+            error!{\"Expected dict for %s interfaces but found %?\", managed_ip, data};\n             (~\"gnos:missing-interface\", bool_value(true))\n         }\n     }\n@@ -60,7 +60,7 @@ fn add_interfaces(store: int, managed_ip: ~str, device: std::map::hashmap<~str,\n         }\n         _\n         {\n-            #error[\"Expected list for %s interfaces but found %?\", managed_ip, device[~\"interfaces\"]];\n+            error!{\"Expected list for %s interfaces but found %?\", managed_ip, device[~\"interfaces\"]};\n             ~[]\n         }\n     }"}]}