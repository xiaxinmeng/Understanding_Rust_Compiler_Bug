{"sha": "f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZGRiMmEzMmMyZGU4NDAyMTE2MDdjOWI5ZTMyYTJhZWQ0ZmE3ZTg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T20:06:09Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-01-29T20:06:09Z"}, "message": "libstd: De-export libstd. rs=deexport", "tree": {"sha": "69ad79729bf8d503f7f6a9f9b720aa2627f608fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69ad79729bf8d503f7f6a9f9b720aa2627f608fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "html_url": "https://github.com/rust-lang/rust/commit/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0391c5b092f27c4d52b304c069f6cf6a033cb75", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0391c5b092f27c4d52b304c069f6cf6a033cb75", "html_url": "https://github.com/rust-lang/rust/commit/d0391c5b092f27c4d52b304c069f6cf6a033cb75"}], "stats": {"total": 482, "additions": 230, "deletions": 252}, "files": [{"sha": "a45e2b32941b1611ccaa96228f82344c622a712e", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -478,8 +478,6 @@ impl<T: Const Owned> &RWReadMode<T> {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use arc::*;\n@@ -493,7 +491,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    fn manually_share_arc() {\n+    pub fn manually_share_arc() {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = arc::ARC(v);\n \n@@ -518,7 +516,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_mutex_arc_condvar() {\n+    pub fn test_mutex_arc_condvar() {\n         let arc = ~MutexARC(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = pipes::oneshot();\n@@ -540,7 +538,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_arc_condvar_poison() {\n+    pub fn test_arc_condvar_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         let (p, c) = pipes::stream();\n@@ -561,7 +559,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_mutex_arc_poison() {\n+    pub fn test_mutex_arc_poison() {\n         let arc = ~MutexARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -574,7 +572,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_mutex_arc_unwrap_poison() {\n+    pub fn test_mutex_arc_unwrap_poison() {\n         let arc = MutexARC(1);\n         let arc2 = ~(&arc).clone();\n         let (p, c) = pipes::stream();\n@@ -589,7 +587,7 @@ mod tests {\n         assert one == 1;\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_rw_arc_poison_wr() {\n+    pub fn test_rw_arc_poison_wr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -602,7 +600,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_rw_arc_poison_ww() {\n+    pub fn test_rw_arc_poison_ww() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -615,7 +613,7 @@ mod tests {\n         }\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_rw_arc_poison_dw() {\n+    pub fn test_rw_arc_poison_dw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -630,7 +628,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rw_arc_no_poison_rr() {\n+    pub fn test_rw_arc_no_poison_rr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -643,7 +641,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rw_arc_no_poison_rw() {\n+    pub fn test_rw_arc_no_poison_rw() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -656,7 +654,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rw_arc_no_poison_dr() {\n+    pub fn test_rw_arc_no_poison_dr() {\n         let arc = ~RWARC(1);\n         let arc2 = ~arc.clone();\n         do task::try |move arc2| {\n@@ -672,7 +670,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_rw_arc() {\n+    pub fn test_rw_arc() {\n         let arc = ~RWARC(0);\n         let arc2 = ~arc.clone();\n         let (p,c) = pipes::stream();\n@@ -709,7 +707,7 @@ mod tests {\n         do arc.read |num| { assert *num == 10; }\n     }\n     #[test]\n-    fn test_rw_downgrade() {\n+    pub fn test_rw_downgrade() {\n         // (1) A downgrader gets in write mode and does cond.wait.\n         // (2) A writer gets in write mode, sets state to 42, and does signal.\n         // (3) Downgrader wakes, sets state to 31337."}, {"sha": "a9b57137709846d8da884d013cfc3374e9b3c5f1", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -152,12 +152,10 @@ impl ~str: FromBase64 {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use core::str;\n \n     #[test]\n-    fn test_to_base64() {\n+    pub fn test_to_base64() {\n         assert (~\"\").to_base64()       == ~\"\";\n         assert (~\"f\").to_base64()      == ~\"Zg==\";\n         assert (~\"fo\").to_base64()     == ~\"Zm8=\";\n@@ -168,7 +166,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_base64() {\n+    pub fn test_from_base64() {\n         assert (~\"\").from_base64() == str::to_bytes(~\"\");\n         assert (~\"Zg==\").from_base64() == str::to_bytes(~\"f\");\n         assert (~\"Zm8=\").from_base64() == str::to_bytes(~\"fo\");"}, {"sha": "ec7fc431ab70646eadade63cdd01c3ebfda68132", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -578,8 +578,6 @@ impl Bitv: ops::Index<uint,bool> {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use bitv::*;\n@@ -589,7 +587,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    fn test_to_str() {\n+    pub fn test_to_str() {\n         let zerolen = Bitv(0u, false);\n         assert zerolen.to_str() == ~\"\";\n \n@@ -598,7 +596,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_0_elements() {\n+    pub fn test_0_elements() {\n         let mut act;\n         let mut exp;\n         act = Bitv(0u, false);\n@@ -607,7 +605,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_1_element() {\n+    pub fn test_1_element() {\n         let mut act;\n         act = Bitv(1u, false);\n         assert act.eq_vec(~[0u]);\n@@ -616,15 +614,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_2_elements() {\n+    pub fn test_2_elements() {\n         let b = bitv::Bitv(2, false);\n         b.set(0, true);\n         b.set(1, false);\n         assert b.to_str() == ~\"10\";\n     }\n \n     #[test]\n-    fn test_10_elements() {\n+    pub fn test_10_elements() {\n         let mut act;\n         // all 0\n \n@@ -663,7 +661,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_31_elements() {\n+    pub fn test_31_elements() {\n         let mut act;\n         // all 0\n \n@@ -736,7 +734,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_32_elements() {\n+    pub fn test_32_elements() {\n         let mut act;\n         // all 0\n \n@@ -811,7 +809,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_33_elements() {\n+    pub fn test_33_elements() {\n         let mut act;\n         // all 0\n \n@@ -887,21 +885,21 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_equal_differing_sizes() {\n+    pub fn test_equal_differing_sizes() {\n         let v0 = Bitv(10u, false);\n         let v1 = Bitv(11u, false);\n         assert !v0.equal(&v1);\n     }\n \n     #[test]\n-    fn test_equal_greatly_differing_sizes() {\n+    pub fn test_equal_greatly_differing_sizes() {\n         let v0 = Bitv(10u, false);\n         let v1 = Bitv(110u, false);\n         assert !v0.equal(&v1);\n     }\n \n     #[test]\n-    fn test_equal_sneaky_small() {\n+    pub fn test_equal_sneaky_small() {\n         let a = bitv::Bitv(1, false);\n         a.set(0, true);\n \n@@ -912,7 +910,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_equal_sneaky_big() {\n+    pub fn test_equal_sneaky_big() {\n         let a = bitv::Bitv(100, false);\n         for uint::range(0, 100) |i| {\n             a.set(i, true);\n@@ -927,14 +925,14 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_bytes() {\n+    pub fn test_from_bytes() {\n         let bitv = from_bytes([0b10110110, 0b00000000, 0b11111111]);\n         let str = ~\"10110110\" + ~\"00000000\" + ~\"11111111\";\n         assert bitv.to_str() == str;\n     }\n \n     #[test]\n-    fn test_to_bytes() {\n+    pub fn test_to_bytes() {\n         let bv = Bitv(3, true);\n         bv.set(1, false);\n         assert bv.to_bytes() == ~[0b10100000];\n@@ -946,18 +944,18 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_bools() {\n+    pub fn test_from_bools() {\n         assert from_bools([true, false, true, true]).to_str() == ~\"1011\";\n     }\n \n     #[test]\n-    fn test_to_bools() {\n+    pub fn test_to_bools() {\n         let bools = ~[false, false, true, false, false, true, true, false];\n         assert from_bytes([0b00100110]).to_bools() == bools;\n     }\n \n     #[test]\n-    fn test_small_difference() {\n+    pub fn test_small_difference() {\n       let b1 = Bitv(3, false);\n       let b2 = Bitv(3, false);\n       b1.set(0, true);\n@@ -971,7 +969,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_big_difference() {\n+    pub fn test_big_difference() {\n       let b1 = Bitv(100, false);\n       let b2 = Bitv(100, false);\n       b1.set(0, true);"}, {"sha": "f4917934acb4002aa4234abda091f389eb36d68c", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -87,11 +87,10 @@ pub fn DuplexStream<T: Owned, U: Owned>()\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n     use comm::DuplexStream;\n \n     #[test]\n-    fn DuplexStream1() {\n+    pub fn DuplexStream1() {\n         let (left, right) = DuplexStream();\n \n         left.send(~\"abc\");"}, {"sha": "cf1b816f238e382daf83b6c6e1f31c459e329264", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -17,14 +17,13 @@ use core::sys;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n-    unsafe fn debug_tydesc(td: *sys::TypeDesc);\n-    unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n-    unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n-    unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n-    unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n-    unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n-    unsafe fn rust_dbg_breakpoint();\n+    pub unsafe fn debug_tydesc(td: *sys::TypeDesc);\n+    pub unsafe fn debug_opaque(td: *sys::TypeDesc, x: *());\n+    pub unsafe fn debug_box(td: *sys::TypeDesc, x: *());\n+    pub unsafe fn debug_tag(td: *sys::TypeDesc, x: *());\n+    pub unsafe fn debug_fn(td: *sys::TypeDesc, x: *());\n+    pub unsafe fn debug_ptrcast(td: *sys::TypeDesc, x: *()) -> *();\n+    pub unsafe fn rust_dbg_breakpoint();\n }\n \n pub fn debug_tydesc<T>() {"}, {"sha": "a51cc253755c224ad967bb1f45162e7c26fe403d", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -637,7 +637,6 @@ pub mod groups {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n     use core::prelude::*;\n \n     use opt = getopts;\n@@ -647,7 +646,7 @@ mod tests {\n     use core::result::{Err, Ok};\n     use core::result;\n \n-    fn check_fail_type(f: Fail_, ft: FailType) {\n+    pub fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {\n           ArgumentMissing(_) => assert ft == ArgumentMissing_,\n           UnrecognizedOption(_) => assert ft == UnrecognizedOption_,\n@@ -660,7 +659,7 @@ mod tests {\n \n     // Tests for reqopt\n     #[test]\n-    fn test_reqopt_long() {\n+    pub fn test_reqopt_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -674,7 +673,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_long_missing() {\n+    pub fn test_reqopt_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -685,7 +684,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_long_no_arg() {\n+    pub fn test_reqopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -696,7 +695,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_long_multi() {\n+    pub fn test_reqopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[reqopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -707,7 +706,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_short() {\n+    pub fn test_reqopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -721,7 +720,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_short_missing() {\n+    pub fn test_reqopt_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -732,7 +731,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_short_no_arg() {\n+    pub fn test_reqopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -743,7 +742,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_reqopt_short_multi() {\n+    pub fn test_reqopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[reqopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -756,7 +755,7 @@ mod tests {\n \n     // Tests for optopt\n     #[test]\n-    fn test_optopt_long() {\n+    pub fn test_optopt_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -770,7 +769,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_long_missing() {\n+    pub fn test_optopt_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -781,7 +780,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_long_no_arg() {\n+    pub fn test_optopt_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -792,7 +791,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_long_multi() {\n+    pub fn test_optopt_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optopt(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -803,7 +802,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_short() {\n+    pub fn test_optopt_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -817,7 +816,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_short_missing() {\n+    pub fn test_optopt_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -828,7 +827,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_short_no_arg() {\n+    pub fn test_optopt_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -839,7 +838,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optopt_short_multi() {\n+    pub fn test_optopt_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optopt(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -852,7 +851,7 @@ mod tests {\n \n     // Tests for optflag\n     #[test]\n-    fn test_optflag_long() {\n+    pub fn test_optflag_long() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -863,7 +862,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_long_missing() {\n+    pub fn test_optflag_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -874,7 +873,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_long_arg() {\n+    pub fn test_optflag_long_arg() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -888,7 +887,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_long_multi() {\n+    pub fn test_optflag_long_multi() {\n         let args = ~[~\"--test\", ~\"--test\"];\n         let opts = ~[optflag(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -899,7 +898,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_short() {\n+    pub fn test_optflag_short() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -910,7 +909,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_short_missing() {\n+    pub fn test_optflag_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -921,7 +920,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_short_arg() {\n+    pub fn test_optflag_short_arg() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -936,7 +935,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflag_short_multi() {\n+    pub fn test_optflag_short_multi() {\n         let args = ~[~\"-t\", ~\"-t\"];\n         let opts = ~[optflag(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -948,7 +947,7 @@ mod tests {\n \n     // Tests for optflagmulti\n     #[test]\n-    fn test_optflagmulti_short1() {\n+    pub fn test_optflagmulti_short1() {\n         let args = ~[~\"-v\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -961,7 +960,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflagmulti_short2a() {\n+    pub fn test_optflagmulti_short2a() {\n         let args = ~[~\"-v\", ~\"-v\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -974,7 +973,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflagmulti_short2b() {\n+    pub fn test_optflagmulti_short2b() {\n         let args = ~[~\"-vv\"];\n         let opts = ~[optflagmulti(~\"v\")];\n         let rs = getopts(args, opts);\n@@ -987,7 +986,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflagmulti_long1() {\n+    pub fn test_optflagmulti_long1() {\n         let args = ~[~\"--verbose\"];\n         let opts = ~[optflagmulti(~\"verbose\")];\n         let rs = getopts(args, opts);\n@@ -1000,7 +999,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optflagmulti_long2() {\n+    pub fn test_optflagmulti_long2() {\n         let args = ~[~\"--verbose\", ~\"--verbose\"];\n         let opts = ~[optflagmulti(~\"verbose\")];\n         let rs = getopts(args, opts);\n@@ -1014,7 +1013,7 @@ mod tests {\n \n     // Tests for optmulti\n     #[test]\n-    fn test_optmulti_long() {\n+    pub fn test_optmulti_long() {\n         let args = ~[~\"--test=20\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1028,7 +1027,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_long_missing() {\n+    pub fn test_optmulti_long_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1039,7 +1038,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_long_no_arg() {\n+    pub fn test_optmulti_long_no_arg() {\n         let args = ~[~\"--test\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1050,7 +1049,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_long_multi() {\n+    pub fn test_optmulti_long_multi() {\n         let args = ~[~\"--test=20\", ~\"--test=30\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1067,7 +1066,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_short() {\n+    pub fn test_optmulti_short() {\n         let args = ~[~\"-t\", ~\"20\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1081,7 +1080,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_short_missing() {\n+    pub fn test_optmulti_short_missing() {\n         let args = ~[~\"blah\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1092,7 +1091,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_short_no_arg() {\n+    pub fn test_optmulti_short_no_arg() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1103,7 +1102,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_optmulti_short_multi() {\n+    pub fn test_optmulti_short_multi() {\n         let args = ~[~\"-t\", ~\"20\", ~\"-t\", ~\"30\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1120,7 +1119,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unrecognized_option_long() {\n+    pub fn test_unrecognized_option_long() {\n         let args = ~[~\"--untest\"];\n         let opts = ~[optmulti(~\"t\")];\n         let rs = getopts(args, opts);\n@@ -1131,7 +1130,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_unrecognized_option_short() {\n+    pub fn test_unrecognized_option_short() {\n         let args = ~[~\"-t\"];\n         let opts = ~[optmulti(~\"test\")];\n         let rs = getopts(args, opts);\n@@ -1142,7 +1141,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_combined() {\n+    pub fn test_combined() {\n         let args =\n             ~[~\"prog\", ~\"free1\", ~\"-s\", ~\"20\", ~\"free2\",\n               ~\"--flag\", ~\"--long=30\", ~\"-f\", ~\"-m\", ~\"40\",\n@@ -1174,7 +1173,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_multi() {\n+    pub fn test_multi() {\n         let args = ~[~\"-e\", ~\"foo\", ~\"--encrypt\", ~\"foo\"];\n         let opts = ~[optopt(~\"e\"), optopt(~\"encrypt\")];\n         let matches = &match getopts(args, opts) {\n@@ -1195,7 +1194,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_nospace() {\n+    pub fn test_nospace() {\n         let args = ~[~\"-Lfoo\", ~\"-M.\"];\n         let opts = ~[optmulti(~\"L\"), optmulti(~\"M\")];\n         let matches = &match getopts(args, opts) {\n@@ -1210,7 +1209,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_reqopt() {\n+    pub fn test_groups_reqopt() {\n         let opt = groups::reqopt(~\"b\", ~\"banana\", ~\"some bananas\", ~\"VAL\");\n         assert opt == OptGroup { short_name: ~\"b\",\n                         long_name: ~\"banana\",\n@@ -1221,7 +1220,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_optopt() {\n+    pub fn test_groups_optopt() {\n         let opt = groups::optopt(~\"a\", ~\"apple\", ~\"some apples\", ~\"VAL\");\n         assert opt == OptGroup { short_name: ~\"a\",\n                         long_name: ~\"apple\",\n@@ -1232,7 +1231,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_optflag() {\n+    pub fn test_groups_optflag() {\n         let opt = groups::optflag(~\"k\", ~\"kiwi\", ~\"some kiwis\");\n         assert opt == OptGroup { short_name: ~\"k\",\n                         long_name: ~\"kiwi\",\n@@ -1243,7 +1242,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_optflagopt() {\n+    pub fn test_groups_optflagopt() {\n         let opt = groups::optflagopt(~\"p\", ~\"pineapple\",\n                                        ~\"some pineapples\", ~\"VAL\");\n         assert opt == OptGroup { short_name: ~\"p\",\n@@ -1255,7 +1254,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_optmulti() {\n+    pub fn test_groups_optmulti() {\n         let opt = groups::optmulti(~\"l\", ~\"lime\",\n                                      ~\"some limes\", ~\"VAL\");\n         assert opt == OptGroup { short_name: ~\"l\",\n@@ -1267,7 +1266,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_long_to_short() {\n+    pub fn test_groups_long_to_short() {\n         let short = ~[reqopt(~\"b\"), reqopt(~\"banana\")];\n         let verbose = groups::reqopt(~\"b\", ~\"banana\",\n                                        ~\"some bananas\", ~\"VAL\");\n@@ -1276,7 +1275,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_getopts() {\n+    pub fn test_groups_getopts() {\n         let short = ~[\n             reqopt(~\"b\"), reqopt(~\"banana\"),\n             optopt(~\"a\"), optopt(~\"apple\"),\n@@ -1302,7 +1301,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_groups_usage() {\n+    pub fn test_groups_usage() {\n         let optgroups = ~[\n             groups::reqopt(~\"b\", ~\"banana\", ~\"Desc\", ~\"VAL\"),\n             groups::optopt(~\"a\", ~\"012345678901234567890123456789\",\n@@ -1333,7 +1332,7 @@ Options:\n     }\n \n     #[test]\n-    fn test_groups_usage_description_wrapping() {\n+    pub fn test_groups_usage_description_wrapping() {\n         // indentation should be 24 spaces\n         // lines wrap after 78: or rather descriptions wrap after 54\n "}, {"sha": "6857138263154cc1c9d93be2192063831a2450de", "filename": "src/libstd/list.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -156,15 +156,13 @@ pub pure fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use list::*;\n     use list;\n \n     use core::option;\n \n     #[test]\n-    fn test_is_empty() {\n+    pub fn test_is_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n         let full1 = from_vec(~[1]);\n         let full2 = from_vec(~['r', 'u']);\n@@ -175,7 +173,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_vec() {\n+    pub fn test_from_vec() {\n         let l = from_vec(~[0, 1, 2]);\n \n         assert (head(l) == 0);\n@@ -188,13 +186,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_from_vec_empty() {\n+    pub fn test_from_vec_empty() {\n         let empty : @list::List<int> = from_vec(~[]);\n         assert (empty == @list::Nil::<int>);\n     }\n \n     #[test]\n-    fn test_foldl() {\n+    pub fn test_foldl() {\n         fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n         let l = from_vec(~[0, 1, 2, 3, 4]);\n         let empty = @list::Nil::<int>;\n@@ -203,7 +201,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_foldl2() {\n+    pub fn test_foldl2() {\n         fn sub(a: &int, b: &int) -> int {\n             *a - *b\n         }\n@@ -212,14 +210,14 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_find_success() {\n+    pub fn test_find_success() {\n         fn match_(i: &int) -> bool { return *i == 2; }\n         let l = from_vec(~[0, 1, 2]);\n         assert (list::find(l, match_) == option::Some(2));\n     }\n \n     #[test]\n-    fn test_find_fail() {\n+    pub fn test_find_fail() {\n         fn match_(_i: &int) -> bool { return false; }\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n@@ -228,7 +226,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_has() {\n+    pub fn test_has() {\n         let l = from_vec(~[5, 8, 6]);\n         let empty = @list::Nil::<int>;\n         assert (list::has(l, 5));\n@@ -238,15 +236,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_len() {\n+    pub fn test_len() {\n         let l = from_vec(~[0, 1, 2]);\n         let empty = @list::Nil::<int>;\n         assert (list::len(l) == 3u);\n         assert (list::len(empty) == 0u);\n     }\n \n     #[test]\n-    fn test_append() {\n+    pub fn test_append() {\n         assert from_vec(~[1,2,3,4])\n             == list::append(list::from_vec(~[1,2]), list::from_vec(~[3,4]));\n     }"}, {"sha": "89b19fccc1c4737e8b3e7eb0307c596a02e19188", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -731,8 +731,6 @@ impl Url: to_bytes::IterBytes {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use net_url::*;\n@@ -742,7 +740,7 @@ mod tests {\n     use core::str;\n \n     #[test]\n-    fn test_split_char_first() {\n+    pub fn test_split_char_first() {\n         let (u,v) = split_char_first(~\"hello, sweet world\", ',');\n         assert u == ~\"hello\";\n         assert v == ~\" sweet world\";\n@@ -753,7 +751,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_get_authority() {\n+    pub fn test_get_authority() {\n         let (u, h, p, r) = get_authority(\n             \"//user:pass@rust-lang.org/something\").unwrap();\n         assert u == Some(UserInfo::new(~\"user\", Some(~\"pass\")));\n@@ -808,7 +806,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_get_path() {\n+    pub fn test_get_path() {\n         let (p, r) = get_path(\"/something+%20orother\", true).unwrap();\n         assert p == ~\"/something+ orother\";\n         assert r == ~\"\";\n@@ -824,7 +822,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_url_parse() {\n+    pub fn test_url_parse() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n \n         let up = from_str(url);\n@@ -840,109 +838,109 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_url_parse_host_slash() {\n+    pub fn test_url_parse_host_slash() {\n         let urlstr = ~\"http://0.42.42.42/\";\n         let url = from_str(urlstr).unwrap();\n         assert url.host == ~\"0.42.42.42\";\n         assert url.path == ~\"/\";\n     }\n \n     #[test]\n-    fn test_url_with_underscores() {\n+    pub fn test_url_with_underscores() {\n         let urlstr = ~\"http://dotcom.com/file_name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert url.path == ~\"/file_name.html\";\n     }\n \n     #[test]\n-    fn test_url_with_dashes() {\n+    pub fn test_url_with_dashes() {\n         let urlstr = ~\"http://dotcom.com/file-name.html\";\n         let url = from_str(urlstr).unwrap();\n         assert url.path == ~\"/file-name.html\";\n     }\n \n     #[test]\n-    fn test_no_scheme() {\n+    pub fn test_no_scheme() {\n         assert get_scheme(\"noschemehere.html\").is_err();\n     }\n \n     #[test]\n-    fn test_invalid_scheme_errors() {\n+    pub fn test_invalid_scheme_errors() {\n         assert from_str(\"99://something\").is_err();\n         assert from_str(\"://something\").is_err();\n     }\n \n     #[test]\n-    fn test_full_url_parse_and_format() {\n+    pub fn test_full_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?s=v#something\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_userless_url_parse_and_format() {\n+    pub fn test_userless_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc?s=v#something\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_queryless_url_parse_and_format() {\n+    pub fn test_queryless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc#something\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_empty_query_url_parse_and_format() {\n+    pub fn test_empty_query_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?#something\";\n         let should_be = ~\"http://user:pass@rust-lang.org/doc#something\";\n         assert from_str(url).unwrap().to_str() == should_be;\n     }\n \n     #[test]\n-    fn test_fragmentless_url_parse_and_format() {\n+    pub fn test_fragmentless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org/doc?q=v\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_minimal_url_parse_and_format() {\n+    pub fn test_minimal_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org/doc\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_scheme_host_only_url_parse_and_format() {\n+    pub fn test_scheme_host_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_pathless_url_parse_and_format() {\n+    pub fn test_pathless_url_parse_and_format() {\n         let url = ~\"http://user:pass@rust-lang.org?q=v#something\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_scheme_host_fragment_only_url_parse_and_format() {\n+    pub fn test_scheme_host_fragment_only_url_parse_and_format() {\n         let url = ~\"http://rust-lang.org#something\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_url_component_encoding() {\n+    pub fn test_url_component_encoding() {\n         let url = ~\"http://rust-lang.org/doc%20uments?ba%25d%20=%23%26%2B\";\n         let u = from_str(url).unwrap();\n         assert u.path == ~\"/doc uments\";\n         assert u.query == ~[(~\"ba%d \", ~\"#&+\")];\n     }\n \n     #[test]\n-    fn test_url_without_authority() {\n+    pub fn test_url_without_authority() {\n         let url = ~\"mailto:test@email.com\";\n         assert from_str(url).unwrap().to_str() == url;\n     }\n \n     #[test]\n-    fn test_encode() {\n+    pub fn test_encode() {\n         assert encode(\"\") == ~\"\";\n         assert encode(\"http://example.com\") == ~\"http://example.com\";\n         assert encode(\"foo bar% baz\") == ~\"foo%20bar%25%20baz\";\n@@ -970,7 +968,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_encode_component() {\n+    pub fn test_encode_component() {\n         assert encode_component(\"\") == ~\"\";\n         assert encode_component(\"http://example.com\") ==\n             ~\"http%3A%2F%2Fexample.com\";\n@@ -998,7 +996,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_decode() {\n+    pub fn test_decode() {\n         assert decode(\"\") == ~\"\";\n         assert decode(\"abc/def 123\") == ~\"abc/def 123\";\n         assert decode(\"abc%2Fdef%20123\") == ~\"abc%2Fdef 123\";\n@@ -1026,7 +1024,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_decode_component() {\n+    pub fn test_decode_component() {\n         assert decode_component(\"\") == ~\"\";\n         assert decode_component(\"abc/def 123\") == ~\"abc/def 123\";\n         assert decode_component(\"abc%2Fdef%20123\") == ~\"abc/def 123\";\n@@ -1054,7 +1052,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_encode_form_urlencoded() {\n+    pub fn test_encode_form_urlencoded() {\n         let mut m = LinearMap::new();\n         assert encode_form_urlencoded(&m) == ~\"\";\n \n@@ -1072,7 +1070,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_decode_form_urlencoded() {\n+    pub fn test_decode_form_urlencoded() {\n         // FIXME #4449: Commented out because this causes an ICE, but only\n         // on FreeBSD\n         /*"}, {"sha": "5dd2a0563270bfaa877d2fad5f54b671cdddf77a", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -17,14 +17,13 @@ use core::str;\n use core::task;\n \n extern mod rustrt {\n-    #[legacy_exports];\n-    unsafe fn linenoise(prompt: *c_char) -> *c_char;\n-    unsafe fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n-    unsafe fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n-    unsafe fn linenoiseHistorySave(file: *c_char) -> c_int;\n-    unsafe fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n-    unsafe fn linenoiseSetCompletionCallback(callback: *u8);\n-    unsafe fn linenoiseAddCompletion(completions: *(), line: *c_char);\n+    pub unsafe fn linenoise(prompt: *c_char) -> *c_char;\n+    pub unsafe fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n+    pub unsafe fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n+    pub unsafe fn linenoiseHistorySave(file: *c_char) -> c_int;\n+    pub unsafe fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n+    pub unsafe fn linenoiseSetCompletionCallback(callback: *u8);\n+    pub unsafe fn linenoiseAddCompletion(completions: *(), line: *c_char);\n }\n \n /// Add a line to history"}, {"sha": "c2599864c90c14ce630bc733621ab66b449d46c7", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -274,15 +274,13 @@ pub fn sha1() -> Sha1 {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use sha1;\n \n     use core::str;\n     use core::vec;\n \n     #[test]\n-    fn test() {\n+    pub fn test() {\n         unsafe {\n             struct Test {\n                 input: ~str,\n@@ -397,7 +395,6 @@ mod tests {\n             }\n         }\n     }\n-\n }\n \n // Local Variables:"}, {"sha": "577fea7769a45f8c7fbdc7708300b887b2c4887e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -720,15 +720,13 @@ fn copy_vec<T: Copy>(dest: &[mut T], s1: uint,\n \n #[cfg(test)]\n mod test_qsort3 {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use sort::*;\n \n     use core::vec;\n \n-    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n@@ -740,7 +738,7 @@ mod test_qsort3 {\n     }\n \n     #[test]\n-    fn test() {\n+    pub fn test() {\n         {\n             let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n             let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n@@ -767,16 +765,14 @@ mod test_qsort3 {\n \n #[cfg(test)]\n mod test_qsort {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use sort::*;\n \n     use core::int;\n     use core::vec;\n \n-    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n@@ -789,7 +785,7 @@ mod test_qsort {\n     }\n \n     #[test]\n-    fn test() {\n+    pub fn test() {\n         {\n             let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n             let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n@@ -815,7 +811,7 @@ mod test_qsort {\n \n     // Regression test for #750\n     #[test]\n-    fn test_simple() {\n+    pub fn test_simple() {\n         let names = ~[mut 2, 1, 3];\n \n         let expected = ~[1, 2, 3];\n@@ -835,15 +831,13 @@ mod test_qsort {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use sort::*;\n \n     use core::vec;\n \n-    fn check_sort(v1: &[int], v2: &[int]) {\n+    pub fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;\n@@ -857,7 +851,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test() {\n+    pub fn test() {\n         {\n             let v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n             let v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n@@ -874,16 +868,15 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_merge_sort_mutable() {\n+    pub fn test_merge_sort_mutable() {\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let v1 = ~[mut 3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert v2 == ~[1, 2, 3];\n     }\n \n     #[test]\n-    fn test_merge_sort_stability()\n-    {\n+    pub fn test_merge_sort_stability() {\n         // tjc: funny that we have to use parens\n         pure fn ile(x: &(&static/str), y: &(&static/str)) -> bool\n         {"}, {"sha": "bd9386845aea9b1866d217b9ddd430612ba18e20", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 52, "deletions": 42, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -708,8 +708,6 @@ impl &RWlockReadMode {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use sync::*;\n@@ -726,19 +724,19 @@ mod tests {\n      * Semaphore tests\n      ************************************************************************/\n     #[test]\n-    fn test_sem_acquire_release() {\n+    pub fn test_sem_acquire_release() {\n         let s = ~semaphore(1);\n         s.acquire();\n         s.release();\n         s.acquire();\n     }\n     #[test]\n-    fn test_sem_basic() {\n+    pub fn test_sem_basic() {\n         let s = ~semaphore(1);\n         do s.access { }\n     }\n     #[test]\n-    fn test_sem_as_mutex() {\n+    pub fn test_sem_as_mutex() {\n         let s = ~semaphore(1);\n         let s2 = ~s.clone();\n         do task::spawn |move s2| {\n@@ -751,7 +749,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_sem_as_cvar() {\n+    pub fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n         let (p,c) = pipes::stream();\n         let s = ~semaphore(0);\n@@ -777,7 +775,7 @@ mod tests {\n         c.send(());\n     }\n     #[test]\n-    fn test_sem_multi_resource() {\n+    pub fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n         let s = ~semaphore(2);\n@@ -796,7 +794,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_sem_runtime_friendly_blocking() {\n+    pub fn test_sem_runtime_friendly_blocking() {\n         // Force the runtime to schedule two threads on the same sched_loop.\n         // When one blocks, it should schedule the other one.\n         do task::spawn_sched(task::ManualThreads(1)) {\n@@ -821,7 +819,7 @@ mod tests {\n      * Mutex tests\n      ************************************************************************/\n     #[test]\n-    fn test_mutex_lock() {\n+    pub fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n         let (p,c) = pipes::stream();\n@@ -852,7 +850,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_mutex_cond_wait() {\n+    pub fn test_mutex_cond_wait() {\n         let m = ~Mutex();\n \n         // Child wakes up parent\n@@ -884,7 +882,7 @@ mod tests {\n         let _ = port.recv(); // Wait until child wakes up\n     }\n     #[cfg(test)]\n-    fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n+    pub fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = ~Mutex();\n         let mut ports = ~[];\n \n@@ -911,15 +909,15 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n     }\n     #[test]\n-    fn test_mutex_cond_broadcast() {\n+    pub fn test_mutex_cond_broadcast() {\n         test_mutex_cond_broadcast_helper(12);\n     }\n     #[test]\n-    fn test_mutex_cond_broadcast_none() {\n+    pub fn test_mutex_cond_broadcast_none() {\n         test_mutex_cond_broadcast_helper(0);\n     }\n     #[test]\n-    fn test_mutex_cond_no_waiter() {\n+    pub fn test_mutex_cond_no_waiter() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         do task::try |move m| {\n@@ -930,7 +928,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_mutex_killed_simple() {\n+    pub fn test_mutex_killed_simple() {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n@@ -945,7 +943,7 @@ mod tests {\n         do m.lock { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_mutex_killed_cond() {\n+    pub fn test_mutex_killed_cond() {\n         // Getting killed during cond wait must not corrupt the mutex while\n         // unwinding (e.g. double unlock).\n         let m = ~Mutex();\n@@ -971,7 +969,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_mutex_killed_broadcast() {\n+    pub fn test_mutex_killed_broadcast() {\n         let m = ~Mutex();\n         let m2 = ~m.clone();\n         let (p,c) = pipes::stream();\n@@ -1024,7 +1022,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_mutex_cond_signal_on_0() {\n+    pub fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n         let m = ~Mutex();\n         do m.lock_cond |cond| {\n@@ -1038,7 +1036,7 @@ mod tests {\n         }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_mutex_different_conds() {\n+    pub fn test_mutex_different_conds() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(2);\n             let m2 = ~m.clone();\n@@ -1059,7 +1057,7 @@ mod tests {\n         assert result.is_err();\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_mutex_no_condvars() {\n+    pub fn test_mutex_no_condvars() {\n         let result = do task::try {\n             let m = ~mutex_with_condvars(0);\n             do m.lock_cond |cond| { cond.wait(); }\n@@ -1080,9 +1078,9 @@ mod tests {\n      * Reader/writer lock tests\n      ************************************************************************/\n     #[cfg(test)]\n-    enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n+    pub enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: fn()) {\n+    pub fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: fn()) {\n         match mode {\n             Read => x.read(blk),\n             Write => x.write(blk),\n@@ -1098,8 +1096,9 @@ mod tests {\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(x: ~RWlock, mode1: RWlockMode,\n-                             mode2: RWlockMode) {\n+    pub fn test_rwlock_exclusion(x: ~RWlock,\n+                                 mode1: RWlockMode,\n+                                 mode2: RWlockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n         let (p,c) = pipes::stream();\n@@ -1129,22 +1128,24 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_rwlock_readers_wont_modify_the_data() {\n+    pub fn test_rwlock_readers_wont_modify_the_data() {\n         test_rwlock_exclusion(~RWlock(), Read, Write);\n         test_rwlock_exclusion(~RWlock(), Write, Read);\n         test_rwlock_exclusion(~RWlock(), Read, Downgrade);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Read);\n     }\n     #[test]\n-    fn test_rwlock_writers_and_writers() {\n+    pub fn test_rwlock_writers_and_writers() {\n         test_rwlock_exclusion(~RWlock(), Write, Write);\n         test_rwlock_exclusion(~RWlock(), Write, Downgrade);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Write);\n         test_rwlock_exclusion(~RWlock(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(x: ~RWlock, mode1: RWlockMode,\n-                             mode2: RWlockMode, make_mode2_go_first: bool) {\n+    pub fn test_rwlock_handshake(x: ~RWlock,\n+                                 mode1: RWlockMode,\n+                                 mode2: RWlockMode,\n+                                 make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = ~x.clone();\n         let (p1,c1) = pipes::stream();\n@@ -1173,7 +1174,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    fn test_rwlock_readers_and_readers() {\n+    pub fn test_rwlock_readers_and_readers() {\n         test_rwlock_handshake(~RWlock(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n@@ -1182,7 +1183,7 @@ mod tests {\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n-    fn test_rwlock_downgrade_unlock() {\n+    pub fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~RWlock();\n         do lock_rwlock_in_mode(x, Downgrade) { }\n@@ -1192,12 +1193,12 @@ mod tests {\n         test_rwlock_exclusion(move y, Write, Write);\n     }\n     #[test]\n-    fn test_rwlock_read_recursive() {\n+    pub fn test_rwlock_read_recursive() {\n         let x = ~RWlock();\n         do x.read { do x.read { } }\n     }\n     #[test]\n-    fn test_rwlock_cond_wait() {\n+    pub fn test_rwlock_cond_wait() {\n         // As test_mutex_cond_wait above.\n         let x = ~RWlock();\n \n@@ -1232,8 +1233,9 @@ mod tests {\n         do x.read { } // Just for good measure\n     }\n     #[cfg(test)]\n-    fn test_rwlock_cond_broadcast_helper(num_waiters: uint, dg1: bool,\n-                                         dg2: bool) {\n+    pub fn test_rwlock_cond_broadcast_helper(num_waiters: uint,\n+                                             dg1: bool,\n+                                             dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n         fn lock_cond(x: &RWlock, downgrade: bool, blk: fn(c: &Condvar)) {\n             if downgrade {\n@@ -1270,7 +1272,7 @@ mod tests {\n         for ports.each |port| { let _ = port.recv(); }\n     }\n     #[test]\n-    fn test_rwlock_cond_broadcast() {\n+    pub fn test_rwlock_cond_broadcast() {\n         test_rwlock_cond_broadcast_helper(0, true, true);\n         test_rwlock_cond_broadcast_helper(0, true, false);\n         test_rwlock_cond_broadcast_helper(0, false, true);\n@@ -1281,7 +1283,7 @@ mod tests {\n         test_rwlock_cond_broadcast_helper(12, false, false);\n     }\n     #[cfg(test)] #[ignore(cfg(windows))]\n-    fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n+    pub fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let x = ~RWlock();\n         let x2 = ~x.clone();\n@@ -1296,15 +1298,23 @@ mod tests {\n         do lock_rwlock_in_mode(x, mode2) { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_reader_killed_writer() { rwlock_kill_helper(Read, Write); }\n+    pub fn test_rwlock_reader_killed_writer() {\n+        rwlock_kill_helper(Read, Write);\n+    }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_writer_killed_reader() { rwlock_kill_helper(Write,Read ); }\n+    pub fn test_rwlock_writer_killed_reader() {\n+        rwlock_kill_helper(Write,Read );\n+    }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(Read, Read ); }\n+    pub fn test_rwlock_reader_killed_reader() {\n+        rwlock_kill_helper(Read, Read );\n+    }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(Write,Write); }\n+    pub fn test_rwlock_writer_killed_writer() {\n+        rwlock_kill_helper(Write,Write);\n+    }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_kill_downgrader() {\n+    pub fn test_rwlock_kill_downgrader() {\n         rwlock_kill_helper(Downgrade, Read);\n         rwlock_kill_helper(Read, Downgrade);\n         rwlock_kill_helper(Downgrade, Write);\n@@ -1319,7 +1329,7 @@ mod tests {\n         rwlock_kill_helper(Downgrade, DowngradeRead);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn test_rwlock_downgrade_cant_swap() {\n+    pub fn test_rwlock_downgrade_cant_swap() {\n         // Tests that you can't downgrade with a different rwlock's token.\n         let x = ~RWlock();\n         let y = ~RWlock();"}, {"sha": "2db1a51e34aceba391768474962f05994a5ee73a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -38,8 +38,7 @@ use core::vec;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports];\n-    unsafe fn rust_sched_threads() -> size_t;\n+    pub unsafe fn rust_sched_threads() -> size_t;\n }\n \n // The name of a test. By convention this follows the rules for rust\n@@ -437,8 +436,6 @@ fn calc_result(test: &TestDesc, task_succeeded: bool) -> TestResult {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc};\n     use test::{TestOpts, run_test};\n \n@@ -448,7 +445,7 @@ mod tests {\n     use core::vec;\n \n     #[test]\n-    fn do_not_run_ignored_tests() {\n+    pub fn do_not_run_ignored_tests() {\n         fn f() { fail; }\n         let desc = TestDesc {\n             name: ~\"whatever\",\n@@ -464,7 +461,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn ignored_tests_result_in_ignored() {\n+    pub fn ignored_tests_result_in_ignored() {\n         fn f() { }\n         let desc = TestDesc {\n             name: ~\"whatever\",\n@@ -481,7 +478,7 @@ mod tests {\n \n     #[test]\n     #[ignore(cfg(windows))]\n-    fn test_should_fail() {\n+    pub fn test_should_fail() {\n         fn f() { fail; }\n         let desc = TestDesc {\n             name: ~\"whatever\",\n@@ -497,7 +494,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_should_fail_but_succeeds() {\n+    pub fn test_should_fail_but_succeeds() {\n         fn f() { }\n         let desc = TestDesc {\n             name: ~\"whatever\",\n@@ -513,7 +510,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn first_free_arg_should_be_a_filter() {\n+    pub fn first_free_arg_should_be_a_filter() {\n         let args = ~[~\"progname\", ~\"filter\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,\n@@ -523,7 +520,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn parse_ignored_flag() {\n+    pub fn parse_ignored_flag() {\n         let args = ~[~\"progname\", ~\"filter\", ~\"--ignored\"];\n         let opts = match parse_opts(args) {\n           either::Left(copy o) => o,\n@@ -533,7 +530,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn filter_for_ignored_option() {\n+    pub fn filter_for_ignored_option() {\n         // When we run ignored tests the test filter should filter out all the\n         // unignored tests and flip the ignore flag on the rest to false\n \n@@ -565,7 +562,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn sort_tests() {\n+    pub fn sort_tests() {\n         let opts = TestOpts {\n             filter: option::None,\n             run_ignored: false,"}, {"sha": "4217e9fb0589cc618478c527dbc9cea63a020974", "filename": "src/libstd/time.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -24,17 +24,16 @@ const NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n-    #[legacy_exports]\n-    unsafe fn get_time(sec: &mut i64, nsec: &mut i32);\n+    pub unsafe fn get_time(sec: &mut i64, nsec: &mut i32);\n \n-    unsafe fn precise_time_ns(ns: &mut u64);\n+    pub unsafe fn precise_time_ns(ns: &mut u64);\n \n-    unsafe fn rust_tzset();\n+    pub unsafe fn rust_tzset();\n     // FIXME: The i64 values can be passed by-val when #2064 is fixed.\n-    unsafe fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-    unsafe fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n-    unsafe fn rust_timegm(&&tm: Tm, sec: &mut i64);\n-    unsafe fn rust_mktime(&&tm: Tm, sec: &mut i64);\n+    pub unsafe fn rust_gmtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n+    pub unsafe fn rust_localtime(&&sec: i64, &&nsec: i32, &&result: Tm);\n+    pub unsafe fn rust_timegm(&&tm: Tm, sec: &mut i64);\n+    pub unsafe fn rust_mktime(&&tm: Tm, sec: &mut i64);\n }\n \n /// A record specifying a time value in seconds and nanoseconds.\n@@ -890,8 +889,6 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n-\n     use time::*;\n \n     use core::float;\n@@ -902,7 +899,7 @@ mod tests {\n     use core::uint;\n     use core::vec;\n \n-    fn test_get_time() {\n+    pub fn test_get_time() {\n         const some_recent_date: i64 = 1325376000i64; // 2012-01-01T00:00:00Z\n         const some_future_date: i64 = 1577836800i64; // 2020-01-01T00:00:00Z\n \n@@ -925,7 +922,7 @@ mod tests {\n         }\n     }\n \n-    fn test_precise_time() {\n+    pub fn test_precise_time() {\n         let s0 = precise_time_s();\n         let ns1 = precise_time_ns();\n \n@@ -942,7 +939,7 @@ mod tests {\n         assert ns2 >= ns1;\n     }\n \n-    fn test_at_utc() {\n+    pub fn test_at_utc() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -963,7 +960,7 @@ mod tests {\n         assert utc.tm_nsec == 54321_i32;\n     }\n \n-    fn test_at() {\n+    pub fn test_at() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -991,7 +988,7 @@ mod tests {\n         assert local.tm_nsec == 54321_i32;\n     }\n \n-    fn test_to_timespec() {\n+    pub fn test_to_timespec() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1002,7 +999,7 @@ mod tests {\n         assert utc.to_local().to_timespec() == time;\n     }\n \n-    fn test_conversions() {\n+    pub fn test_conversions() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1018,7 +1015,7 @@ mod tests {\n         assert utc.to_local().to_utc() == utc;\n     }\n \n-    fn test_strptime() {\n+    pub fn test_strptime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1172,7 +1169,7 @@ mod tests {\n         assert test(~\"%\", ~\"%%\");\n     }\n \n-    fn test_ctime() {\n+    pub fn test_ctime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1186,7 +1183,7 @@ mod tests {\n         assert local.ctime() == ~\"Fri Feb 13 15:31:30 2009\";\n     }\n \n-    fn test_strftime() {\n+    pub fn test_strftime() {\n         os::setenv(~\"TZ\", ~\"America/Los_Angeles\");\n         tzset();\n \n@@ -1259,7 +1256,7 @@ mod tests {\n         assert utc.rfc3339() == ~\"2009-02-13T23:31:30Z\";\n     }\n \n-    fn test_timespec_eq_ord() {\n+    pub fn test_timespec_eq_ord() {\n         use core::cmp::{eq, ge, gt, le, lt, ne};\n \n         let a = &Timespec::new(-2, 1);\n@@ -1293,7 +1290,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn run_tests() {\n+    pub fn run_tests() {\n         // The tests race on tzset. So instead of having many independent\n         // tests, we will just call the functions now.\n         test_get_time();"}, {"sha": "d62e2cbf05dbab9376cad4525c6fa3c4ef778d49", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=f1ddb2a32c2de840211607c9b9e32a2aed4fa7e8", "patch": "@@ -169,8 +169,6 @@ extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) {\n \n #[cfg(test)]\n mod test {\n-    #[legacy_exports];\n-\n     use core::prelude::*;\n \n     use timer::*;\n@@ -182,21 +180,21 @@ mod test {\n     use core::task;\n \n     #[test]\n-    fn test_gl_timer_simple_sleep_test() {\n+    pub fn test_gl_timer_simple_sleep_test() {\n         let hl_loop = &uv::global_loop::get();\n         sleep(hl_loop, 1u);\n     }\n \n     #[test]\n-    fn test_gl_timer_sleep_stress1() {\n+    pub fn test_gl_timer_sleep_stress1() {\n         let hl_loop = &uv::global_loop::get();\n         for iter::repeat(50u) {\n             sleep(hl_loop, 1u);\n         }\n     }\n \n     #[test]\n-    fn test_gl_timer_sleep_stress2() {\n+    pub fn test_gl_timer_sleep_stress2() {\n         let po = oldcomm::Port();\n         let ch = oldcomm::Chan(&po);\n         let hl_loop = &uv::global_loop::get();\n@@ -238,7 +236,7 @@ mod test {\n \n     #[test]\n     #[cfg(ignore)]\n-    fn test_gl_timer_recv_timeout_before_time_passes() {\n+    pub fn test_gl_timer_recv_timeout_before_time_passes() {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;\n@@ -268,7 +266,7 @@ mod test {\n     }\n \n     #[test]\n-    fn test_gl_timer_recv_timeout_after_time_passes() {\n+    pub fn test_gl_timer_recv_timeout_after_time_passes() {\n         let times = 100;\n         let mut successes = 0;\n         let mut failures = 0;"}]}