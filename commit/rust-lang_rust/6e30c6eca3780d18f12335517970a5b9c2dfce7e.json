{"sha": "6e30c6eca3780d18f12335517970a5b9c2dfce7e", "node_id": "C_kwDOAAsO6NoAKDZlMzBjNmVjYTM3ODBkMThmMTIzMzU1MTc5NzBhNWI5YzJkZmNlN2U", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-11-20T02:37:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-20T02:37:58Z"}, "message": "Merge pull request #315 from rust-lang/scatter-gather-ptr\n\nScatter/gather for pointers", "tree": {"sha": "27b8971b933d9ba00815ea6d4208bf6ea36a6461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27b8971b933d9ba00815ea6d4208bf6ea36a6461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e30c6eca3780d18f12335517970a5b9c2dfce7e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjeZMGCRBK7hj4Ov3rIwAAOHsIACZIUayQp2DDdvTxAdmJIyBc\nnPFrBP5PHjpZDX6CPZYLGyPa1Ea0Frjr9MxlCc3IHnXOXONt9iNctX6z+XxEEt2B\nINNSWu5vPa83eHSriRtwOPqaOqKp0xiwrB7bqzIEACV3IJzXlFiBfj8uLa3IgLyM\n7nDbuVPiBlx3kQTTGi4kd9lTpsGU2T2EiI9Iz/Nu54JSV5t7wa9+z61+yu2jdYsE\nCxmZ9lyl9RRLNgIApLKj1JSjg5Rztss27ldfxxcWlrk+bF+V5XWbTiZCCBMY7ujv\n1E33DRBl6WOSGL271BOVv2K3ZmdnadzjnE46bOlckol9YL8jLXSUJD20dE6l8uY=\n=4Z0J\n-----END PGP SIGNATURE-----\n", "payload": "tree 27b8971b933d9ba00815ea6d4208bf6ea36a6461\nparent 35c60ce6693500b2c86bf24de2526b3adcc7237d\nparent 7e614f0438324b60af24554699977757228d7acd\nauthor Caleb Zulawski <caleb.zulawski@gmail.com> 1668911878 -0500\ncommitter GitHub <noreply@github.com> 1668911878 -0500\n\nMerge pull request #315 from rust-lang/scatter-gather-ptr\n\nScatter/gather for pointers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e30c6eca3780d18f12335517970a5b9c2dfce7e", "html_url": "https://github.com/rust-lang/rust/commit/6e30c6eca3780d18f12335517970a5b9c2dfce7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e30c6eca3780d18f12335517970a5b9c2dfce7e/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35c60ce6693500b2c86bf24de2526b3adcc7237d", "url": "https://api.github.com/repos/rust-lang/rust/commits/35c60ce6693500b2c86bf24de2526b3adcc7237d", "html_url": "https://github.com/rust-lang/rust/commit/35c60ce6693500b2c86bf24de2526b3adcc7237d"}, {"sha": "7e614f0438324b60af24554699977757228d7acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e614f0438324b60af24554699977757228d7acd", "html_url": "https://github.com/rust-lang/rust/commit/7e614f0438324b60af24554699977757228d7acd"}], "stats": {"total": 122, "additions": 119, "deletions": 3}, "files": [{"sha": "d109087eaa6550dd4d50d2fc18f475e989ea1e25", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 119, "deletions": 3, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/6e30c6eca3780d18f12335517970a5b9c2dfce7e/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e30c6eca3780d18f12335517970a5b9c2dfce7e/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=6e30c6eca3780d18f12335517970a5b9c2dfce7e", "patch": "@@ -364,8 +364,71 @@ where\n         let base_ptr = Simd::<*const T, LANES>::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n-        // Safety: The ptrs have been bounds-masked to prevent memory-unsafe reads insha'allah\n-        unsafe { intrinsics::simd_gather(or, ptrs, enable.to_int()) }\n+        // Safety: The caller is responsible for determining the indices are okay to read\n+        unsafe { Self::gather_select_ptr(ptrs, enable, or) }\n+    }\n+\n+    /// Read pointers elementwise into a SIMD vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Each read must satisfy the same conditions as [`core::ptr::read`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdConstPtr};\n+    /// let values = [6, 2, 4, 9];\n+    /// let offsets = Simd::from_array([1, 0, 0, 3]);\n+    /// let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n+    /// let gathered = unsafe { Simd::gather_ptr(source) };\n+    /// assert_eq!(gathered, Simd::from_array([2, 6, 6, 9]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn gather_ptr(source: Simd<*const T, LANES>) -> Self\n+    where\n+        T: Default,\n+    {\n+        // TODO: add an intrinsic that doesn't use a passthru vector, and remove the T: Default bound\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { Self::gather_select_ptr(source, Mask::splat(true), Self::default()) }\n+    }\n+\n+    /// Conditionally read pointers elementwise into a SIMD vector.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If a lane is disabled, the lane is selected from the `or` vector and no read is performed.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Enabled lanes must satisfy the same conditions as [`core::ptr::read`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Mask, Simd, SimdConstPtr};\n+    /// let values = [6, 2, 4, 9];\n+    /// let enable = Mask::from_array([true, true, false, true]);\n+    /// let offsets = Simd::from_array([1, 0, 0, 3]);\n+    /// let source = Simd::splat(values.as_ptr()).wrapping_add(offsets);\n+    /// let gathered = unsafe { Simd::gather_select_ptr(source, enable, Simd::splat(0)) };\n+    /// assert_eq!(gathered, Simd::from_array([2, 6, 0, 9]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn gather_select_ptr(\n+        source: Simd<*const T, LANES>,\n+        enable: Mask<isize, LANES>,\n+        or: Self,\n+    ) -> Self {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { intrinsics::simd_gather(or, source, enable.to_int()) }\n     }\n \n     /// Writes the values in a SIMD vector to potentially discontiguous indices in `slice`.\n@@ -473,10 +536,63 @@ where\n             // Ferris forgive me, I have done pointer arithmetic here.\n             let ptrs = base_ptr.wrapping_add(idxs);\n             // The ptrs have been bounds-masked to prevent memory-unsafe writes insha'allah\n-            intrinsics::simd_scatter(self, ptrs, enable.to_int())\n+            self.scatter_select_ptr(ptrs, enable);\n             // Cleared \u2622\ufe0f *mut T Zone\n         }\n     }\n+\n+    /// Write pointers elementwise into a SIMD vector.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Each write must satisfy the same conditions as [`core::ptr::write`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Simd, SimdMutPtr};\n+    /// let mut values = [0; 4];\n+    /// let offset = Simd::from_array([3, 2, 1, 0]);\n+    /// let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n+    /// unsafe { Simd::from_array([6, 3, 5, 7]).scatter_ptr(ptrs); }\n+    /// assert_eq!(values, [7, 5, 3, 6]);\n+    /// ```\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn scatter_ptr(self, dest: Simd<*mut T, LANES>) {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { self.scatter_select_ptr(dest, Mask::splat(true)) }\n+    }\n+\n+    /// Conditionally write pointers elementwise into a SIMD vector.\n+    /// The mask `enable`s all `true` lanes and disables all `false` lanes.\n+    /// If a lane is disabled, the write to that lane is skipped.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Enabled lanes must satisfy the same conditions as [`core::ptr::write`].\n+    ///\n+    /// # Example\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"as_crate\")] use core_simd::simd;\n+    /// # #[cfg(not(feature = \"as_crate\"))] use core::simd;\n+    /// # use simd::{Mask, Simd, SimdMutPtr};\n+    /// let mut values = [0; 4];\n+    /// let offset = Simd::from_array([3, 2, 1, 0]);\n+    /// let ptrs = Simd::splat(values.as_mut_ptr()).wrapping_add(offset);\n+    /// let enable = Mask::from_array([true, true, false, false]);\n+    /// unsafe { Simd::from_array([6, 3, 5, 7]).scatter_select_ptr(ptrs, enable); }\n+    /// assert_eq!(values, [0, 0, 3, 6]);\n+    /// ```\n+    #[inline]\n+    #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n+    pub unsafe fn scatter_select_ptr(self, dest: Simd<*mut T, LANES>, enable: Mask<isize, LANES>) {\n+        // Safety: The caller is responsible for upholding all invariants\n+        unsafe { intrinsics::simd_scatter(self, dest, enable.to_int()) }\n+    }\n }\n \n impl<T, const LANES: usize> Copy for Simd<T, LANES>"}]}