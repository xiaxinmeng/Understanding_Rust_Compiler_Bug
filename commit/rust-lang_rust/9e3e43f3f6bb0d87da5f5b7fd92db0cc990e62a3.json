{"sha": "9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllM2U0M2YzZjZiYjBkODdkYTVmNWI3ZmQ5MmRiMGNjOTkwZTYyYTM=", "commit": {"author": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2015-11-10T00:29:56Z"}, "committer": {"name": "Kevin Butler", "email": "haqkrs@gmail.com", "date": "2016-01-14T22:47:50Z"}, "message": "libsyntax: make matches_codepattern unicode aware", "tree": {"sha": "ed14d7da67ea142349d5b5016aeb3ee201c2ea71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed14d7da67ea142349d5b5016aeb3ee201c2ea71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3", "html_url": "https://github.com/rust-lang/rust/commit/9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3/comments", "author": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ryman", "id": 994978, "node_id": "MDQ6VXNlcjk5NDk3OA==", "avatar_url": "https://avatars.githubusercontent.com/u/994978?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ryman", "html_url": "https://github.com/Ryman", "followers_url": "https://api.github.com/users/Ryman/followers", "following_url": "https://api.github.com/users/Ryman/following{/other_user}", "gists_url": "https://api.github.com/users/Ryman/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ryman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ryman/subscriptions", "organizations_url": "https://api.github.com/users/Ryman/orgs", "repos_url": "https://api.github.com/users/Ryman/repos", "events_url": "https://api.github.com/users/Ryman/events{/privacy}", "received_events_url": "https://api.github.com/users/Ryman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a2723010290077bca034cd988067c70d0a638db", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a2723010290077bca034cd988067c70d0a638db", "html_url": "https://github.com/rust-lang/rust/commit/8a2723010290077bca034cd988067c70d0a638db"}], "stats": {"total": 102, "additions": 57, "deletions": 45}, "files": [{"sha": "c19033f2347235dc4dafc97da8b97b34838ea957", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 57, "deletions": 45, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=9e3e43f3f6bb0d87da5f5b7fd92db0cc990e62a3", "patch": "@@ -14,7 +14,7 @@ use parse::new_parser_from_source_str;\n use parse::parser::Parser;\n use parse::token;\n use ptr::P;\n-use str::char_at;\n+use std::iter::Peekable;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_tts(source_str: String) -> Vec<ast::TokenTree> {\n@@ -87,57 +87,55 @@ pub fn strs_to_idents(ids: Vec<&str> ) -> Vec<ast::Ident> {\n \n /// Does the given string match the pattern? whitespace in the first string\n /// may be deleted or replaced with other whitespace to match the pattern.\n-/// this function is Unicode-ignorant; fortunately, the careful design of\n-/// UTF-8 mitigates this ignorance.  In particular, this function only collapses\n-/// sequences of \\n, \\r, ' ', and \\t, but it should otherwise tolerate Unicode\n-/// chars. Unsurprisingly, it doesn't do NKF-normalization(?).\n+/// This function is relatively Unicode-ignorant; fortunately, the careful design\n+/// of UTF-8 mitigates this ignorance. It doesn't do NKF-normalization(?).\n pub fn matches_codepattern(a : &str, b : &str) -> bool {\n-    let mut idx_a = 0;\n-    let mut idx_b = 0;\n+    let mut a_iter = a.chars().peekable();\n+    let mut b_iter = b.chars().peekable();\n+\n     loop {\n-        if idx_a == a.len() && idx_b == b.len() {\n-            return true;\n-        }\n-        else if idx_a == a.len() {return false;}\n-        else if idx_b == b.len() {\n-            // maybe the stuff left in a is all ws?\n-            if is_whitespace(char_at(a, idx_a)) {\n-                return scan_for_non_ws_or_end(a,idx_a) == a.len();\n-            } else {\n-                return false;\n+        let (a, b) = match (a_iter.peek(), b_iter.peek()) {\n+            (None, None) => return true,\n+            (None, _) => return false,\n+            (Some(a), None) => {\n+                if a.is_whitespace() {\n+                    break // trailing whitespace check is out of loop for borrowck\n+                } else {\n+                    return false\n+                }\n             }\n-        }\n-        // ws in both given and pattern:\n-        else if is_whitespace(char_at(a, idx_a))\n-           && is_whitespace(char_at(b, idx_b)) {\n-            idx_a = scan_for_non_ws_or_end(a,idx_a);\n-            idx_b = scan_for_non_ws_or_end(b,idx_b);\n-        }\n-        // ws in given only:\n-        else if is_whitespace(char_at(a, idx_a)) {\n-            idx_a = scan_for_non_ws_or_end(a,idx_a);\n-        }\n-        // *don't* silently eat ws in expected only.\n-        else if char_at(a, idx_a) == char_at(b, idx_b) {\n-            idx_a += 1;\n-            idx_b += 1;\n-        }\n-        else {\n-            return false;\n+            (Some(&a), Some(&b)) => (a, b)\n+        };\n+\n+        if a.is_whitespace() && b.is_whitespace() {\n+            // skip whitespace for a and b\n+            scan_for_non_ws_or_end(&mut a_iter);\n+            scan_for_non_ws_or_end(&mut b_iter);\n+        } else if a.is_whitespace() {\n+            // skip whitespace for a\n+            scan_for_non_ws_or_end(&mut a_iter);\n+        } else if a == b {\n+            a_iter.next();\n+            b_iter.next();\n+        } else {\n+            return false\n         }\n     }\n+\n+    // check if a has *only* trailing whitespace\n+    a_iter.all(|c| c.is_whitespace())\n }\n \n-/// Given a string and an index, return the first usize >= idx\n-/// that is a non-ws-char or is outside of the legal range of\n-/// the string.\n-fn scan_for_non_ws_or_end(a : &str, idx: usize) -> usize {\n-    let mut i = idx;\n-    let len = a.len();\n-    while (i < len) && (is_whitespace(char_at(a, i))) {\n-        i += 1;\n+/// Advances the given peekable `Iterator` until it reaches a non-whitespace character\n+fn scan_for_non_ws_or_end<I: Iterator<Item= char>>(iter: &mut Peekable<I>) {\n+    loop {\n+        match iter.peek() {\n+            Some(c) if c.is_whitespace() => {} // fall through; borrowck\n+            _ => return\n+        }\n+\n+        iter.next();\n     }\n-    i\n }\n \n pub fn is_whitespace(c: char) -> bool {\n@@ -148,7 +146,8 @@ pub fn is_whitespace(c: char) -> bool {\n mod tests {\n     use super::*;\n \n-    #[test] fn eqmodws() {\n+    #[test]\n+    fn eqmodws() {\n         assert_eq!(matches_codepattern(\"\",\"\"),true);\n         assert_eq!(matches_codepattern(\"\",\"a\"),false);\n         assert_eq!(matches_codepattern(\"a\",\"\"),false);\n@@ -159,5 +158,18 @@ mod tests {\n         assert_eq!(matches_codepattern(\"a   b\",\"a b\"),true);\n         assert_eq!(matches_codepattern(\"ab\",\"a b\"),false);\n         assert_eq!(matches_codepattern(\"a   b\",\"ab\"),true);\n+        assert_eq!(matches_codepattern(\" a   b\",\"ab\"),true);\n+    }\n+\n+    #[test]\n+    fn more_whitespace() {\n+        assert_eq!(matches_codepattern(\"\",\"\\x0C\"), false);\n+        assert_eq!(matches_codepattern(\"a b\",\"a\\u{2002}b\"),true);\n+        assert_eq!(matches_codepattern(\"a b \",\"a   \\u{0085}\\n\\t\\r  b\"),true);\n+        assert_eq!(matches_codepattern(\"a b\",\"a   \\u{0085}\\n\\t\\r  b \"),false);\n+        assert_eq!(matches_codepattern(\"a   b\",\"a\\u{2002}b\"),true);\n+        assert_eq!(matches_codepattern(\"ab\",\"a\\u{2003}b\"),false);\n+        assert_eq!(matches_codepattern(\"a  \\u{3000}b\",\"ab\"),true);\n+        assert_eq!(matches_codepattern(\"\\u{205F}a   b\",\"ab\"),true);\n     }\n }"}]}