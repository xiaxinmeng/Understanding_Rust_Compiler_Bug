{"sha": "01b7b7d5a0feeb88b5dba1e295925a7564473685", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxYjdiN2Q1YTBmZWViODhiNWRiYTFlMjk1OTI1YTc1NjQ0NzM2ODU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-27T09:07:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:02Z"}, "message": "core::rt: Use unsafe pointers instead of transmuted regions", "tree": {"sha": "32ec852e170f74a41fa85e8a0601434805824b8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32ec852e170f74a41fa85e8a0601434805824b8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01b7b7d5a0feeb88b5dba1e295925a7564473685", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01b7b7d5a0feeb88b5dba1e295925a7564473685", "html_url": "https://github.com/rust-lang/rust/commit/01b7b7d5a0feeb88b5dba1e295925a7564473685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01b7b7d5a0feeb88b5dba1e295925a7564473685/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab284d44d8d181b12783d82755ff83a014027e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab284d44d8d181b12783d82755ff83a014027e4a", "html_url": "https://github.com/rust-lang/rust/commit/ab284d44d8d181b12783d82755ff83a014027e4a"}], "stats": {"total": 166, "additions": 86, "deletions": 80}, "files": [{"sha": "9c1612884f044524d58f762a42ad852e8e15480c", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -111,9 +111,9 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n     let sp = align_down(sp);\n     let sp = mut_offset(sp, -4);\n \n-    unsafe { *sp = arg as uint; }\n+    unsafe { *sp = arg as uint };\n     let sp = mut_offset(sp, -1);\n-    unsafe { *sp = 0; } // The final return address\n+    unsafe { *sp = 0 }; // The final return address\n \n     regs.esp = sp as u32;\n     regs.eip = fptr as u32;\n@@ -195,7 +195,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: *c_void, arg: *c_void, sp:\n \n fn align_down(sp: *mut uint) -> *mut uint {\n     unsafe {\n-        let sp = transmute::<*mut uint, uint>(sp);\n+        let sp: uint = transmute(sp);\n         let sp = sp & !(16 - 1);\n         transmute::<uint, *mut uint>(sp)\n     }"}, {"sha": "0c7e0cf129d7f835c06d4c682eb0f57511728a9e", "filename": "src/libcore/rt/io/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fio%2Fnet%2Ftcp.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -35,7 +35,7 @@ impl TcpStream {\n             rtdebug!(\"borrowing io to connect\");\n             let io = unsafe_borrow_io();\n             rtdebug!(\"about to connect\");\n-            io.tcp_connect(addr)\n+            (*io).tcp_connect(addr)\n         };\n \n         match stream {\n@@ -91,7 +91,7 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: IpAddr) -> Option<TcpListener> {\n-        let listener = unsafe { unsafe_borrow_io().tcp_bind(addr) };\n+        let listener = unsafe { (*unsafe_borrow_io()).tcp_bind(addr) };\n         match listener {\n             Ok(l) => {\n                 Some(TcpListener {"}, {"sha": "ef159d9fe5dde594c6c27056ba3d456288c913f7", "filename": "src/libcore/rt/local_sched.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -78,23 +78,24 @@ pub fn borrow(f: &fn(&mut Scheduler)) {\n ///\n /// Because this leaves the Scheduler in thread-local storage it is possible\n /// For the Scheduler pointer to be aliased\n-pub unsafe fn unsafe_borrow() -> &mut Scheduler {\n+pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n     let key = tls_key();\n     let mut void_sched: *mut c_void = tls::get(key);\n     rtassert!(void_sched.is_not_null());\n     {\n-        let void_sched_ptr = &mut void_sched;\n-        let sched: &mut ~Scheduler = {\n-            cast::transmute::<&mut *mut c_void, &mut ~Scheduler>(void_sched_ptr)\n-        };\n-        let sched: &mut Scheduler = &mut **sched;\n+        let sched: *mut *mut c_void = &mut void_sched;\n+        let sched: *mut ~Scheduler = sched as *mut ~Scheduler;\n+        let sched: *mut Scheduler = &mut **sched;\n         return sched;\n     }\n }\n \n-pub unsafe fn unsafe_borrow_io() -> &mut IoFactoryObject {\n-    let sched = unsafe_borrow();\n-    return sched.event_loop.io().unwrap();\n+pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n+    unsafe {\n+        let sched = unsafe_borrow();\n+        let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n+        return io;\n+    }\n }\n \n fn tls_key() -> tls::Key {"}, {"sha": "94840d7b5d584ff23266490344a5eab7bd6d5794", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -169,16 +169,17 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n     }\n }\n \n-pub unsafe fn unsafe_borrow_local_services() -> &mut LocalServices {\n-    use cast::transmute_mut_region;\n-\n-    match local_sched::unsafe_borrow().current_task {\n-        Some(~ref mut task) => {\n-            transmute_mut_region(&mut task.local_services)\n-        }\n-        None => {\n-            // Don't fail. Infinite recursion\n-            abort!(\"no local services for schedulers yet\")\n+pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n+    unsafe {\n+        match (*local_sched::unsafe_borrow()).current_task {\n+            Some(~ref mut task) => {\n+                let s: *mut LocalServices = &mut task.local_services;\n+                return s;\n+            }\n+            None => {\n+                // Don't fail. Infinite recursion\n+                abort!(\"no local services for schedulers yet\")\n+            }\n         }\n     }\n }"}, {"sha": "b5fba51ca7f4d5baa6da1bcfcb0d4e10f0eb2b89", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -8,14 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*! Rust runtime services, including the task scheduler and I/O interface\n-\n-# XXX\n-\n-* Unsafe uses of borrowed pointers should just use unsafe pointers\n-\n-*/\n-\n+//! Rust runtime services, including the task scheduler and I/O interface\n \n #[doc(hidden)];\n "}, {"sha": "546272474edb671822214314d741bc37f246a1a0", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -106,6 +106,7 @@ pub impl Scheduler {\n                 }\n             }\n \n+            let scheduler = &mut *scheduler;\n             scheduler.event_loop.callback(run_scheduler_once);\n             scheduler.event_loop.run();\n         }\n@@ -179,18 +180,18 @@ pub impl Scheduler {\n         // Take pointers to both the task and scheduler's saved registers.\n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (sched_context, _, next_task_context) = sched.get_contexts();\n+            let (sched_context, _, next_task_context) = (*sched).get_contexts();\n             let next_task_context = next_task_context.unwrap();\n             // Context switch to the task, restoring it's registers\n             // and saving the scheduler's\n             Context::swap(sched_context, next_task_context);\n \n             let sched = local_sched::unsafe_borrow();\n             // The running task should have passed ownership elsewhere\n-            assert!(sched.current_task.is_none());\n+            assert!((*sched).current_task.is_none());\n \n             // Running tasks may have asked us to do some cleanup\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -208,21 +209,25 @@ pub impl Scheduler {\n \n         rtdebug!(\"blocking task\");\n \n-        let blocked_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n-        let f_opaque = ClosureConverter::from_fn(f_fake_region);\n-        this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        unsafe {\n+            let blocked_task = this.current_task.swap_unwrap();\n+            let f_fake_region = transmute::<&fn(~Task), &fn(~Task)>(f);\n+            let f_opaque = ClosureConverter::from_fn(f_fake_region);\n+            this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n+        }\n \n         local_sched::put(this);\n \n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        let (sched_context, last_task_context, _) = sched.get_contexts();\n-        let last_task_context = last_task_context.unwrap();\n-        Context::swap(last_task_context, sched_context);\n+        unsafe {\n+            let sched = local_sched::unsafe_borrow();\n+            let (sched_context, last_task_context, _) = (*sched).get_contexts();\n+            let last_task_context = last_task_context.unwrap();\n+            Context::swap(last_task_context, sched_context);\n \n-        // We could be executing in a different thread now\n-        let sched = unsafe { local_sched::unsafe_borrow() };\n-        sched.run_cleanup_job();\n+            // We could be executing in a different thread now\n+            let sched = local_sched::unsafe_borrow();\n+            (*sched).run_cleanup_job();\n+        }\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n@@ -244,14 +249,14 @@ pub impl Scheduler {\n \n         unsafe {\n             let sched = local_sched::unsafe_borrow();\n-            let (_, last_task_context, next_task_context) = sched.get_contexts();\n+            let (_, last_task_context, next_task_context) = (*sched).get_contexts();\n             let last_task_context = last_task_context.unwrap();\n             let next_task_context = next_task_context.unwrap();\n             Context::swap(last_task_context, next_task_context);\n \n             // We could be executing in a different thread now\n             let sched = local_sched::unsafe_borrow();\n-            sched.run_cleanup_job();\n+            (*sched).run_cleanup_job();\n         }\n     }\n \n@@ -356,10 +361,10 @@ pub impl Task {\n             // have asked us to do some cleanup.\n             unsafe {\n                 let sched = local_sched::unsafe_borrow();\n-                sched.run_cleanup_job();\n+                (*sched).run_cleanup_job();\n \n                 let sched = local_sched::unsafe_borrow();\n-                let task = sched.current_task.get_mut_ref();\n+                let task = (*sched).current_task.get_mut_ref();\n                 // FIXME #6141: shouldn't neet to put `start()` in another closure\n                 task.local_services.run(||start());\n             }"}, {"sha": "704294102ae988329b6dc0df1efea58b499e6c29", "filename": "src/libcore/rt/uv/uvio.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fuvio.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -327,10 +327,12 @@ impl RtioTcpStream for UvTcpStream {\n #[test]\n fn test_simple_io_no_connect() {\n     do run_in_newsched_task {\n-        let io = unsafe { local_sched::unsafe_borrow_io() };\n-        let addr = next_test_ip4();\n-        let maybe_chan = io.tcp_connect(addr);\n-        assert!(maybe_chan.is_err());\n+        unsafe {\n+            let io = local_sched::unsafe_borrow_io();\n+            let addr = next_test_ip4();\n+            let maybe_chan = (*io).tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n+        }\n     }\n }\n \n@@ -343,7 +345,7 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.tcp_bind(addr).unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n@@ -360,7 +362,7 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut stream = io.tcp_connect(addr).unwrap();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.close();\n             }\n@@ -375,7 +377,7 @@ fn test_read_and_block() {\n \n         do spawntask_immediately {\n             let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut listener = io.tcp_bind(addr).unwrap();\n+            let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n             let mut stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n@@ -412,13 +414,15 @@ fn test_read_and_block() {\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.tcp_connect(addr).unwrap();\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n-            stream.close();\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n+                stream.close();\n+            }\n         }\n \n     }\n@@ -433,7 +437,7 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = local_sched::unsafe_borrow_io();\n-                let mut listener = io.tcp_bind(addr).unwrap();\n+                let mut listener = (*io).tcp_bind(addr).unwrap();\n                 let mut stream = listener.accept().unwrap();\n                 let mut buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n@@ -447,20 +451,22 @@ fn test_read_read_read() {\n         }\n \n         do spawntask_immediately {\n-            let io = unsafe { local_sched::unsafe_borrow_io() };\n-            let mut stream = io.tcp_connect(addr).unwrap();\n-            let mut buf = [0, .. 2048];\n-            let mut total_bytes_read = 0;\n-            while total_bytes_read < MAX {\n-                let nread = stream.read(buf).unwrap();\n-                rtdebug!(\"read %u bytes\", nread as uint);\n-                total_bytes_read += nread;\n-                for uint::range(0, nread) |i| {\n-                    assert!(buf[i] == 1);\n+            unsafe {\n+                let io = local_sched::unsafe_borrow_io();\n+                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let mut buf = [0, .. 2048];\n+                let mut total_bytes_read = 0;\n+                while total_bytes_read < MAX {\n+                    let nread = stream.read(buf).unwrap();\n+                    rtdebug!(\"read %u bytes\", nread as uint);\n+                    total_bytes_read += nread;\n+                    for uint::range(0, nread) |i| {\n+                        assert!(buf[i] == 1);\n+                    }\n                 }\n+                rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n+                stream.close();\n             }\n-            rtdebug!(\"read %u bytes total\", total_bytes_read as uint);\n-            stream.close();\n         }\n     }\n }"}, {"sha": "a27b6fe615f33b6731f001dc1bd4ceb9e620b9aa", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -218,7 +218,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n             gc::cleanup_stack_for_failure();\n             unsafe {\n                 let local_services = unsafe_borrow_local_services();\n-                match local_services.unwinder {\n+                match (*local_services).unwinder {\n                     Some(ref mut unwinder) => unwinder.begin_unwind(),\n                     None => abort!(\"failure without unwinder. aborting process\")\n                 }"}, {"sha": "27f58057e2ff58f803b766b685e78030cc6bb968", "filename": "src/libcore/task/local_data_priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01b7b7d5a0feeb88b5dba1e295925a7564473685/src%2Flibcore%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Flocal_data_priv.rs?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -36,7 +36,7 @@ impl Handle {\n                 }\n                 _ => {\n                     let local_services = unsafe_borrow_local_services();\n-                    NewHandle(&mut local_services.storage)\n+                    NewHandle(&mut (*local_services).storage)\n                 }\n             }\n         }"}, {"sha": "97ac7c087a0caf6b0f611b80e14f7fe3cb18bb27", "filename": "src/libuv", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuv?ref=01b7b7d5a0feeb88b5dba1e295925a7564473685", "patch": "@@ -1 +1 @@\n-Subproject commit 218ab86721eefd7b7e97fa6d9f95a80a1fa8686c\n+Subproject commit 97ac7c087a0caf6b0f611b80e14f7fe3cb18bb27"}]}