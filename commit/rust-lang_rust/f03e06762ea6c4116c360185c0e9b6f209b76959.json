{"sha": "f03e06762ea6c4116c360185c0e9b6f209b76959", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwM2UwNjc2MmVhNmM0MTE2YzM2MDE4NWMwZTliNmYyMDliNzY5NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-14T04:32:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-14T04:32:14Z"}, "message": "Auto merge of #46582 - nikomatsakis:nll-master-to-rust-master-4, r=arielb1\n\nmake MIR type checker handle a number of other cases\n\nThe existing type checker was primarily used to verify types, but was skipping over a number of details. For example, it was not checking that the predicates on functions were satisfied and so forth. This meant that the NLL region checker was not getting a lot of the constraints it needed. This PR closes those gaps. It also includes a bit of refactoring for the way that we store region values, encapsulating the bit matrix over into its own module and improving the data structures in use.\n\nThis is mostly work by @spastorino being ported over from nll-master.\n\nr? @arielb1 or @pnkfelix", "tree": {"sha": "0b1cf5900a5f65f7b69c36b2bb484bf360bd6a58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b1cf5900a5f65f7b69c36b2bb484bf360bd6a58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f03e06762ea6c4116c360185c0e9b6f209b76959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f03e06762ea6c4116c360185c0e9b6f209b76959", "html_url": "https://github.com/rust-lang/rust/commit/f03e06762ea6c4116c360185c0e9b6f209b76959", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f03e06762ea6c4116c360185c0e9b6f209b76959/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0142781ad1639ca8c12809a677117dede0f5a9e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0142781ad1639ca8c12809a677117dede0f5a9e6", "html_url": "https://github.com/rust-lang/rust/commit/0142781ad1639ca8c12809a677117dede0f5a9e6"}, {"sha": "237dd4121157943ed54a2e3f75b5849fadd8c7b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/237dd4121157943ed54a2e3f75b5849fadd8c7b4", "html_url": "https://github.com/rust-lang/rust/commit/237dd4121157943ed54a2e3f75b5849fadd8c7b4"}], "stats": {"total": 1350, "additions": 1093, "deletions": 257}, "files": [{"sha": "9788ec2a5e4531cd4b0ac0d729d4662158347cf9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -1201,6 +1201,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// translate them into the form that the NLL solver\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n+        assert!(self.region_obligations.borrow().is_empty(),\n+                \"region_obligations not empty: {:#?}\",\n+                self.region_obligations.borrow());\n+\n         self.borrow_region_constraints().take_and_reset_data()\n     }\n "}, {"sha": "eda2e1f7b4ef4a43e92fb62d75310bf53a59a8e6", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -88,7 +88,12 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         body_id: ast::NodeId,\n         obligation: RegionObligation<'tcx>,\n     ) {\n-        debug!(\"register_region_obligation({:?}, {:?})\", body_id, obligation);\n+        debug!(\n+            \"register_region_obligation(body_id={:?}, obligation={:?})\",\n+            body_id,\n+            obligation\n+        );\n+\n         self.region_obligations\n             .borrow_mut()\n             .push((body_id, obligation));\n@@ -139,6 +144,8 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             \"cannot process registered region obligations in a snapshot\"\n         );\n \n+        debug!(\"process_registered_region_obligations()\");\n+\n         // pull out the region obligations with the given `body_id` (leaving the rest)\n         let mut my_region_obligations = Vec::with_capacity(self.region_obligations.borrow().len());\n         {\n@@ -157,6 +164,13 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             cause,\n         } in my_region_obligations\n         {\n+            debug!(\n+                \"process_registered_region_obligations: sup_type={:?} sub_region={:?} cause={:?}\",\n+                sup_type,\n+                sub_region,\n+                cause\n+            );\n+\n             let origin = SubregionOrigin::from_obligation_cause(\n                 &cause,\n                 || infer::RelateParamBound(cause.span, sup_type),"}, {"sha": "1d538e1c16750bee321855999b796336035c6b1e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -1708,7 +1708,9 @@ slice_interners!(\n );\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Create an unsafe fn ty based on a safe fn ty.\n+    /// Given a `fn` type, returns an equivalent `unsafe fn` type;\n+    /// that is, a `fn` type that is equivalent in every way for being\n+    /// unsafe.\n     pub fn safe_to_unsafe_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n         assert_eq!(sig.unsafety(), hir::Unsafety::Normal);\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig {\n@@ -1717,6 +1719,30 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }))\n     }\n \n+    /// Given a closure signature `sig`, returns an equivalent `fn`\n+    /// type with the same signature. Detuples and so forth -- so\n+    /// e.g. if we have a sig with `Fn<(u32, i32)>` then you would get\n+    /// a `fn(u32, i32)`.\n+    pub fn coerce_closure_fn_ty(self, sig: PolyFnSig<'tcx>) -> Ty<'tcx> {\n+        let converted_sig = sig.map_bound(|s| {\n+            let params_iter = match s.inputs()[0].sty {\n+                ty::TyTuple(params, _) => {\n+                    params.into_iter().cloned()\n+                }\n+                _ => bug!(),\n+            };\n+            self.mk_fn_sig(\n+                params_iter,\n+                s.output(),\n+                s.variadic,\n+                hir::Unsafety::Normal,\n+                abi::Abi::Rust,\n+            )\n+        });\n+\n+        self.mk_fn_ptr(converted_sig)\n+    }\n+\n     // Interns a type/name combination, stores the resulting box in cx.interners,\n     // and returns the box as cast to an unsafe ptr (see comments for Ty above).\n     pub fn mk_ty(self, st: TypeVariants<'tcx>) -> Ty<'tcx> {"}, {"sha": "69ecafa66aee7719f93050d4b38f2172968b721c", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -70,7 +70,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         with_msg: &mut FnMut(&str) -> io::Result<()>,\n     ) -> io::Result<()> {\n         for region in self.definitions.indices() {\n-            let value = self.region_value_str_from_matrix(&self.liveness_constraints, region);\n+            let value = self.liveness_constraints.region_value_str(region);\n             if value != \"{}\" {\n                 with_msg(&format!(\"{:?} live at {}\", region, value))?;\n             }"}, {"sha": "c926c7432bb00c58db1a097149575823504c9a52", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 38, "deletions": 111, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -19,15 +19,15 @@ use rustc::mir::{ClosureOutlivesRequirement, ClosureRegionRequirements, Location\n use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::bitvec::BitMatrix;\n-use rustc_data_structures::indexed_vec::Idx;\n-use std::collections::BTreeMap;\n use std::fmt;\n+use std::rc::Rc;\n use syntax_pos::Span;\n \n mod annotation;\n mod dump_mir;\n mod graphviz;\n+mod values;\n+use self::values::{RegionValueElements, RegionValues};\n \n pub struct RegionInferenceContext<'tcx> {\n     /// Contains the definition for every region variable.  Region\n@@ -36,27 +36,22 @@ pub struct RegionInferenceContext<'tcx> {\n     /// from as well as its final inferred value.\n     definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n+    /// Maps from points/universal-regions to a `RegionElementIndex`.\n+    elements: Rc<RegionValueElements>,\n+\n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    ///\n-    /// In this `BitMatrix` representation, the rows are the region\n-    /// variables and the columns are the free regions and MIR locations.\n-    liveness_constraints: BitMatrix,\n+    liveness_constraints: RegionValues,\n \n     /// The final inferred values of the inference variables; `None`\n     /// until `solve` is invoked.\n-    inferred_values: Option<BitMatrix>,\n+    inferred_values: Option<RegionValues>,\n \n     /// The constraints we have accumulated and used during solving.\n     constraints: Vec<Constraint>,\n \n-    /// A map from each MIR Location to its column index in\n-    /// `liveness_constraints`/`inferred_values`. (The first N columns are\n-    /// the free regions.)\n-    point_indices: BTreeMap<Location, usize>,\n-\n     /// Information about the universally quantified regions in scope\n     /// on this function and their (known) relations to one another.\n     universal_regions: UniversalRegions<'tcx>,\n@@ -112,19 +107,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let num_region_variables = var_origins.len();\n         let num_universal_regions = universal_regions.len();\n \n-        let mut num_points = 0;\n-        let mut point_indices = BTreeMap::new();\n-\n-        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n-            for statement_index in 0..block_data.statements.len() + 1 {\n-                let location = Location {\n-                    block,\n-                    statement_index,\n-                };\n-                point_indices.insert(location, num_universal_regions + num_points);\n-                num_points += 1;\n-            }\n-        }\n+        let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n         let definitions = var_origins\n@@ -134,13 +117,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let mut result = Self {\n             definitions,\n-            liveness_constraints: BitMatrix::new(\n-                num_region_variables,\n-                num_universal_regions + num_points,\n-            ),\n+            elements: elements.clone(),\n+            liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             constraints: Vec::new(),\n-            point_indices,\n             universal_regions,\n         };\n \n@@ -186,14 +166,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.definitions[variable].is_universal = true;\n \n             // Add all nodes in the CFG to liveness constraints\n-            for (_location, point_index) in &self.point_indices {\n-                self.liveness_constraints\n-                    .add(variable.index(), *point_index);\n+            for point_index in self.elements.all_point_indices() {\n+                self.liveness_constraints.add(variable, point_index);\n             }\n \n             // Add `end(X)` into the set for X.\n-            self.liveness_constraints\n-                .add(variable.index(), variable.index());\n+            self.liveness_constraints.add(variable, variable);\n         }\n     }\n \n@@ -217,32 +195,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let inferred_values = self.inferred_values\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n-        self.region_contains_point_in_matrix(inferred_values, r, p)\n-    }\n-\n-    /// True if given region `r` contains the point `p`, when\n-    /// evaluated in the set of region values `matrix`.\n-    fn region_contains_point_in_matrix(\n-        &self,\n-        matrix: &BitMatrix,\n-        r: RegionVid,\n-        p: Location,\n-    ) -> bool {\n-        let point_index = self.point_indices\n-            .get(&p)\n-            .expect(\"point index should be known\");\n-        matrix.contains(r.index(), *point_index)\n-    }\n-\n-    /// True if given region `r` contains the `end(s)`, when\n-    /// evaluated in the set of region values `matrix`.\n-    fn region_contains_region_in_matrix(\n-        &self,\n-        matrix: &BitMatrix,\n-        r: RegionVid,\n-        s: RegionVid,\n-    ) -> bool {\n-        matrix.contains(r.index(), s.index())\n+        inferred_values.contains(r, p)\n     }\n \n     /// Returns access to the value of `r` for debugging purposes.\n@@ -251,43 +204,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .as_ref()\n             .expect(\"region values not yet inferred\");\n \n-        self.region_value_str_from_matrix(inferred_values, r)\n-    }\n-\n-    fn region_value_str_from_matrix(&self,\n-                                    matrix: &BitMatrix,\n-                                    r: RegionVid) -> String {\n-        let mut result = String::new();\n-        result.push_str(\"{\");\n-        let mut sep = \"\";\n-\n-        for &point in self.point_indices.keys() {\n-            if self.region_contains_point_in_matrix(matrix, r, point) {\n-                result.push_str(&format!(\"{}{:?}\", sep, point));\n-                sep = \", \";\n-            }\n-        }\n-\n-        for fr in (0..self.universal_regions.len()).map(RegionVid::new) {\n-            if self.region_contains_region_in_matrix(matrix, r, fr) {\n-                result.push_str(&format!(\"{}{:?}\", sep, fr));\n-                sep = \", \";\n-            }\n-        }\n-\n-        result.push_str(\"}\");\n-\n-        result\n+        inferred_values.region_value_str(r)\n     }\n \n     /// Indicates that the region variable `v` is live at the point `point`.\n+    ///\n+    /// Returns `true` if this constraint is new and `false` is the\n+    /// constraint was already present.\n     pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n         debug!(\"add_live_point({:?}, {:?})\", v, point);\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        let point_index = self.point_indices\n-            .get(&point)\n-            .expect(\"point index should be known\");\n-        self.liveness_constraints.add(v.index(), *point_index)\n+        debug!(\"add_live_point: @{:?}\", point);\n+\n+        let element = self.elements.index(point);\n+        if self.liveness_constraints.add(v, element) {\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n@@ -386,16 +320,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n-        let longer_value = inferred_values.iter(longer_fr.index());\n \n         debug!(\"check_universal_region(fr={:?})\", longer_fr);\n \n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n-        let shorter_frs = longer_value\n-            .take_while(|&i| i < self.universal_regions.len())\n-            .map(RegionVid::new);\n-        for shorter_fr in shorter_frs {\n+        for shorter_fr in inferred_values.universal_regions_outlived_by(longer_fr) {\n             // If it is known that `fr: o`, carry on.\n             if self.universal_regions.outlives(longer_fr, shorter_fr) {\n                 continue;\n@@ -512,20 +442,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     fn copy(\n         &self,\n-        inferred_values: &mut BitMatrix,\n+        inferred_values: &mut RegionValues,\n         mir: &Mir<'tcx>,\n         from_region: RegionVid,\n         to_region: RegionVid,\n-        start_point: Location,\n+        constraint_point: Location,\n     ) -> bool {\n         let mut changed = false;\n \n         let mut stack = vec![];\n         let mut visited = FxHashSet();\n \n-        stack.push(start_point);\n+        stack.push(constraint_point);\n         while let Some(p) = stack.pop() {\n-            if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n+            let point_index = self.elements.index(p);\n+\n+            if !inferred_values.contains(from_region, point_index) {\n                 debug!(\"            not in from-region\");\n                 continue;\n             }\n@@ -535,8 +467,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 continue;\n             }\n \n-            let point_index = self.point_indices.get(&p).unwrap();\n-            changed |= inferred_values.add(to_region.index(), *point_index);\n+            let new = inferred_values.add(to_region, point_index);\n+            changed |= new;\n \n             let block_data = &mir[p.block];\n             let successor_points = if p.statement_index < block_data.statements.len() {\n@@ -564,13 +496,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n-                let universal_region_indices = inferred_values\n-                    .iter(from_region.index())\n-                    .take_while(|&i| i < self.universal_regions.len())\n-                    .collect::<Vec<_>>();\n-                for fr in &universal_region_indices {\n-                    changed |= inferred_values.add(to_region.index(), *fr);\n-                }\n+                changed |=\n+                    inferred_values.add_universal_regions_outlived_by(from_region, to_region);\n             } else {\n                 stack.extend(successor_points);\n             }"}, {"sha": "849ccd3259a2459f6247241f68f3532e179bebc5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,292 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::ty::RegionVid;\n+\n+/// Maps between the various kinds of elements of a region value to\n+/// the internal indices that w use.\n+pub(super) struct RegionValueElements {\n+    /// For each basic block, how many points are contained within?\n+    statements_before_block: IndexVec<BasicBlock, usize>,\n+    num_points: usize,\n+    num_universal_regions: usize,\n+}\n+\n+impl RegionValueElements {\n+    pub(super) fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n+        let mut num_points = 0;\n+        let statements_before_block =\n+            mir.basic_blocks()\n+               .iter()\n+               .map(|block_data| {\n+                   let v = num_points;\n+                   num_points += block_data.statements.len() + 1;\n+                   v\n+               })\n+               .collect();\n+\n+        debug!(\"RegionValueElements(num_universal_regions={:?})\", num_universal_regions);\n+        debug!(\"RegionValueElements: statements_before_block={:#?}\", statements_before_block);\n+        debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n+\n+        Self {\n+            statements_before_block,\n+            num_universal_regions,\n+            num_points,\n+        }\n+    }\n+\n+    /// Total number of element indices that exist.\n+    pub(super) fn num_elements(&self) -> usize {\n+        self.num_points + self.num_universal_regions\n+    }\n+\n+    /// Converts an element of a region value into a `RegionElementIndex`.\n+    pub(super) fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n+        elem.to_element_index(self)\n+    }\n+\n+    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n+    pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n+        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n+    }\n+\n+    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n+    pub(super) fn all_universal_region_indices(&self) -> impl Iterator<Item = RegionElementIndex> {\n+        (0..self.num_universal_regions).map(move |i| RegionElementIndex::new(i))\n+    }\n+\n+    /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n+    pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n+        debug!(\"to_element(i={:?})\", i);\n+\n+        if let Some(r) = self.to_universal_region(i) {\n+            RegionElement::UniversalRegion(r)\n+        } else {\n+            let point_index = i.index() - self.num_universal_regions;\n+\n+            // Find the basic block. We have a vector with the\n+            // starting index of the statement in each block. Imagine\n+            // we have statement #22, and we have a vector like:\n+            //\n+            // [0, 10, 20]\n+            //\n+            // In that case, this represents point_index 2 of\n+            // basic block BB2. We know this because BB0 accounts for\n+            // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+            // 20...\n+            //\n+            // To compute this, we could do a binary search, but\n+            // because I am lazy we instead iterate through to find\n+            // the last point where the \"first index\" (0, 10, or 20)\n+            // was less than the statement index (22). In our case, this will\n+            // be (BB2, 20).\n+            //\n+            // Nit: we could do a binary search here but I'm too lazy.\n+            let (block, &first_index) =\n+                self.statements_before_block\n+                    .iter_enumerated()\n+                    .filter(|(_, first_index)| **first_index <= point_index)\n+                    .last()\n+                    .unwrap();\n+\n+            RegionElement::Location(Location {\n+                block,\n+                statement_index: point_index - first_index,\n+            })\n+        }\n+    }\n+\n+    /// Converts a particular `RegionElementIndex` to a universal\n+    /// region, if that is what it represents. Returns `None`\n+    /// otherwise.\n+    pub(super) fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n+        if i.index() < self.num_universal_regions {\n+            Some(RegionVid::new(i.index()))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// A newtype for the integers that represent one of the possible\n+/// elements in a region. These are the rows in the `BitMatrix` that\n+/// is used to store the values of all regions. They have the following\n+/// convention:\n+///\n+/// - The first N indices represent free regions (where N = universal_regions.len()).\n+/// - The remainder represent the points in the CFG (see `point_indices` map).\n+///\n+/// You can convert a `RegionElementIndex` into a `RegionElement`\n+/// using the `to_region_elem` method.\n+newtype_index!(RegionElementIndex { DEBUG_FORMAT = \"RegionElementIndex({})\" });\n+\n+/// An individual element in a region value -- the value of a\n+/// particular region variable consists of a set of these elements.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub(super) enum RegionElement {\n+    /// A point in the control-flow graph.\n+    Location(Location),\n+\n+    /// An in-scope, universally quantified region (e.g., a liftime parameter).\n+    UniversalRegion(RegionVid),\n+}\n+\n+\n+pub(super) trait ToElementIndex {\n+    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n+}\n+\n+impl ToElementIndex for Location {\n+    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n+        let Location { block, statement_index } = self;\n+        let start_index = elements.statements_before_block[block];\n+        RegionElementIndex::new(elements.num_universal_regions + start_index + statement_index)\n+    }\n+}\n+\n+impl ToElementIndex for RegionVid {\n+    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n+        assert!(self.index() < elements.num_universal_regions);\n+        RegionElementIndex::new(self.index())\n+    }\n+}\n+\n+impl ToElementIndex for RegionElementIndex {\n+    fn to_element_index(self, _elements: &RegionValueElements) -> RegionElementIndex {\n+        self\n+    }\n+}\n+\n+/// Stores the values for a set of regions. These are stored in a\n+/// compact `BitMatrix` representation, with one row per region\n+/// variable. The columns consist of either universal regions or\n+/// points in the CFG.\n+#[derive(Clone)]\n+pub(super) struct RegionValues {\n+    elements: Rc<RegionValueElements>,\n+    matrix: BitMatrix,\n+}\n+\n+impl RegionValues {\n+    pub(super) fn new(elements: &Rc<RegionValueElements>, num_region_variables: usize) -> Self {\n+        assert!(\n+            elements.num_universal_regions <= num_region_variables,\n+            \"universal regions are a subset of the region variables\"\n+        );\n+\n+        Self {\n+            elements: elements.clone(),\n+            matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n+        }\n+    }\n+\n+    /// Adds the given element to the value for the given region. Returns true if\n+    /// the element is newly added (i.e., was not already present).\n+    pub(super) fn add<E: ToElementIndex>(&mut self, r: RegionVid, elem: E) -> bool {\n+        let i = self.elements.index(elem);\n+        if self.matrix.add(r.index(), i.index()) {\n+            debug!(\"add(r={:?}, i={:?})\", r, self.elements.to_element(i));\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    /// Adds all the universal regions outlived by `from_region` to\n+    /// `to_region`.\n+    pub(super) fn add_universal_regions_outlived_by(\n+        &mut self,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n+    ) -> bool {\n+        // FIXME. We could optimize this by improving\n+        // `BitMatrix::merge` so it does not always merge an entire\n+        // row.\n+        debug!(\"add_universal_regions_outlived_by(from_region={:?}, to_region={:?})\",\n+               from_region, to_region);\n+        let mut changed = false;\n+        for elem in self.elements.all_universal_region_indices() {\n+            if self.contains(from_region, elem) {\n+                changed |= self.add(to_region, elem);\n+            }\n+        }\n+        changed\n+    }\n+\n+    /// True if the region `r` contains the given element.\n+    pub(super) fn contains<E: ToElementIndex>(&self, r: RegionVid, elem: E) -> bool {\n+        let i = self.elements.index(elem);\n+        self.matrix.contains(r.index(), i.index())\n+    }\n+\n+    /// Iterate over the value of the region `r`, yielding up element\n+    /// indices. You may prefer `universal_regions_outlived_by` or\n+    /// `elements_contained_in`.\n+    pub(super) fn element_indices_contained_in<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n+        self.matrix\n+            .iter(r.index())\n+            .map(move |i| RegionElementIndex::new(i))\n+    }\n+\n+    /// Returns just the universal regions that are contained in a given region's value.\n+    pub(super) fn universal_regions_outlived_by<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        self.element_indices_contained_in(r)\n+            .map(move |i| self.elements.to_universal_region(i))\n+            .take_while(move |v| v.is_some()) // universal regions are a prefix\n+            .map(move |v| v.unwrap())\n+    }\n+\n+    /// Returns all the elements contained in a given region's value.\n+    pub(super) fn elements_contained_in<'a>(\n+        &'a self,\n+        r: RegionVid,\n+    ) -> impl Iterator<Item = RegionElement> + 'a {\n+        self.element_indices_contained_in(r)\n+            .map(move |r| self.elements.to_element(r))\n+    }\n+\n+    /// Returns a \"pretty\" string value of the region. Meant for debugging.\n+    pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n+        let mut result = String::new();\n+        result.push_str(\"{\");\n+\n+        for (index, element) in self.elements_contained_in(r).enumerate() {\n+            if index > 0 {\n+                result.push_str(\", \");\n+            }\n+\n+            match element {\n+                RegionElement::Location(l) => {\n+                    result.push_str(&format!(\"{:?}\", l));\n+                }\n+\n+                RegionElement::UniversalRegion(fr) => {\n+                    result.push_str(&format!(\"{:?}\", fr));\n+                }\n+            }\n+        }\n+\n+        result.push_str(\"}\");\n+\n+        result\n+    }\n+}"}, {"sha": "5336bd271f5903c6488eef0edf9f1e0aa4f9362a", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -456,6 +456,21 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Returns the \"defining type\" of the current MIR:\n+    ///\n+    /// - for functions, this is the `TyFnDef`;\n+    /// - for closures, this is the `TyClosure`;\n+    /// - for generators, this is the `TyGenerator`;\n+    /// - for constants, this is the type of value that gets produced.\n+    ///   - FIXME. Constants are handled somewhat inelegantly; this gets\n+    ///     patched in a later PR that has already landed on nll-master.\n+    ///\n+    /// The key feature of the \"defining type\" is that it contains the\n+    /// information needed to derive all the universal regions that\n+    /// are in scope as well as the types of the inputs/output from\n+    /// the MIR. In general, early-bound universal regions appear free\n+    /// in the defining type and late-bound regions appear bound in\n+    /// the signature.\n     fn defining_ty(&self) -> ty::Ty<'tcx> {\n         let tcx = self.infcx.tcx;\n         let closure_base_def_id = tcx.closure_base_def_id(self.mir_def_id);\n@@ -471,6 +486,10 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             .replace_free_regions_with_nll_infer_vars(FR, &defining_ty)\n     }\n \n+    /// Builds a hashmap that maps from the universal regions that are\n+    /// in scope (as a `ty::Region<'tcx>`) to their indices (as a\n+    /// `RegionVid`). The map returned by this function contains only\n+    /// the early-bound regions.\n     fn compute_indices(\n         &self,\n         fr_static: RegionVid,\n@@ -490,10 +509,31 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n                 // that correspond to early-bound regions declared on\n                 // the `closure_base_def_id`.\n                 assert!(substs.substs.len() >= identity_substs.len());\n+                assert_eq!(substs.substs.regions().count(), identity_substs.regions().count());\n                 substs.substs\n             }\n             ty::TyFnDef(_, substs) => substs,\n-            _ => bug!(),\n+\n+            // FIXME. When we encounter other sorts of constant\n+            // expressions, such as the `22` in `[foo; 22]`, we can\n+            // get the type `usize` here. For now, just return an\n+            // empty vector of substs in this case, since there are no\n+            // generics in scope in such expressions right now.\n+            //\n+            // Eventually I imagine we could get a wider range of\n+            // types.  What is the best way to handle this? Should we\n+            // be checking something other than the type of the def-id\n+            // to figure out what to do (e.g. the def-key?).\n+            ty::TyUint(..) => {\n+                assert!(identity_substs.is_empty());\n+                identity_substs\n+            }\n+\n+            _ => span_bug!(\n+                tcx.def_span(self.mir_def_id),\n+                \"unknown defining type: {:?}\",\n+                defining_ty\n+            ),\n         };\n \n         let global_mapping = iter::once((gcx.types.re_static, fr_static));\n@@ -551,7 +591,15 @@ impl<'cx, 'gcx, 'tcx> UniversalRegionsBuilder<'cx, 'gcx, 'tcx> {\n             ty::TyFnDef(def_id, _) => {\n                 let sig = tcx.fn_sig(def_id);\n                 let sig = indices.fold_to_region_vids(tcx, &sig);\n-                return sig.inputs_and_output();\n+                sig.inputs_and_output()\n+            }\n+\n+            // FIXME: as above, this happens on things like `[foo;\n+            // 22]`. For now, no inputs, one output, but it seems like\n+            // we need a more general way to handle this category of\n+            // MIR.\n+            ty::TyUint(..) => {\n+                ty::Binder::dummy(tcx.mk_type_list(iter::once(defining_ty)))\n             }\n \n             _ => span_bug!("}, {"sha": "fae911780a1e6ea22d98fdee8f433f624d6f0b13", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 254, "deletions": 40, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -17,7 +17,7 @@ use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, Ty, TyCtxt, TypeVariants};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use rustc::middle::const_val::ConstVal;\n use rustc::mir::*;\n use rustc::mir::tcx::PlaceTy;\n@@ -59,7 +59,10 @@ pub fn type_check<'a, 'gcx, 'tcx>(\n }\n \n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n-    tcx.sess.diagnostic().span_bug(span, msg);\n+    // We sometimes see MIR failures (notably predicate failures) due to\n+    // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n+    // to avoid reporting bugs in those cases.\n+    tcx.sess.diagnostic().delay_span_bug(span, msg);\n }\n \n macro_rules! span_mirbug {\n@@ -171,7 +174,50 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         );\n \n         let expected_ty = match constant.literal {\n-            Literal::Value { value } => value.ty,\n+            Literal::Value { value } => {\n+                // FIXME(#46702) -- We need some way to get the predicates\n+                // associated with the \"pre-evaluated\" form of the\n+                // constant. For example, consider that the constant\n+                // may have associated constant projections (`<Foo as\n+                // Trait<'a, 'b>>::SOME_CONST`) that impose\n+                // constraints on `'a` and `'b`. These constraints\n+                // would be lost if we just look at the normalized\n+                // value.\n+                if let ConstVal::Function(def_id, ..) = value.val {\n+                    let tcx = self.tcx();\n+                    let type_checker = &mut self.cx;\n+\n+                    // FIXME -- For now, use the substitutions from\n+                    // `value.ty` rather than `value.val`. The\n+                    // renumberer will rewrite them to independent\n+                    // sets of regions; in principle, we ought to\n+                    // derive the type of the `value.val` from \"first\n+                    // principles\" and equate with value.ty, but as we\n+                    // are transitioning to the miri-based system, we\n+                    // don't have a handy function for that, so for\n+                    // now we just ignore `value.val` regions.\n+                    let substs = match value.ty.sty {\n+                        ty::TyFnDef(ty_def_id, substs) => {\n+                            assert_eq!(def_id, ty_def_id);\n+                            substs\n+                        }\n+                        _ => span_bug!(\n+                            self.last_span,\n+                            \"unexpected type for constant function: {:?}\",\n+                            value.ty\n+                        ),\n+                    };\n+\n+                    let instantiated_predicates =\n+                        tcx.predicates_of(def_id).instantiate(tcx, substs);\n+                    let predicates =\n+                        type_checker.normalize(&instantiated_predicates.predicates, location);\n+                    type_checker.prove_predicates(&predicates, location);\n+                }\n+\n+                value.ty\n+            }\n+\n             Literal::Promoted { .. } => {\n                 // FIXME -- promoted MIR return types reference\n                 // various \"free regions\" (e.g., scopes and things)\n@@ -545,6 +591,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             span_mirbug!(self, \"\", \"errors selecting obligation: {:?}\", e);\n         }\n \n+        self.infcx\n+            .process_registered_region_obligations(&[], None, self.param_env, self.body_id);\n+\n         let data = self.infcx.take_and_reset_region_constraints();\n         if !data.is_empty() {\n             self.constraints\n@@ -1110,21 +1159,123 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn check_rvalue(&mut self, mir: &Mir<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        let tcx = self.tcx();\n+\n         match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n                 self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n             }\n+\n+            Rvalue::Repeat(operand, const_usize) => if const_usize.as_u64() > 1 {\n+                let operand_ty = operand.ty(mir, tcx);\n+\n+                let trait_ref = ty::TraitRef {\n+                    def_id: tcx.lang_items().copy_trait().unwrap(),\n+                    substs: tcx.mk_substs_trait(operand_ty, &[]),\n+                };\n+\n+                self.prove_trait_ref(trait_ref, location);\n+            },\n+\n+            Rvalue::NullaryOp(_, ty) => {\n+                let trait_ref = ty::TraitRef {\n+                    def_id: tcx.lang_items().sized_trait().unwrap(),\n+                    substs: tcx.mk_substs_trait(ty, &[]),\n+                };\n+\n+                self.prove_trait_ref(trait_ref, location);\n+            }\n+\n+            Rvalue::Cast(cast_kind, op, ty) => match cast_kind {\n+                CastKind::ReifyFnPointer => {\n+                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+\n+                    // The type that we see in the fcx is like\n+                    // `foo::<'a, 'b>`, where `foo` is the path to a\n+                    // function definition. When we extract the\n+                    // signature, it comes from the `fn_sig` query,\n+                    // and hence may contain unnormalized results.\n+                    let fn_sig = self.normalize(&fn_sig, location);\n+\n+                    let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n+\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"equating {:?} with {:?} yields {:?}\",\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            terr\n+                        );\n+                    }\n+                }\n+\n+                CastKind::ClosureFnPointer => {\n+                    let sig = match op.ty(mir, tcx).sty {\n+                        ty::TyClosure(def_id, substs) => {\n+                            substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n+                        }\n+                        _ => bug!(),\n+                    };\n+                    let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n+\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"equating {:?} with {:?} yields {:?}\",\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            terr\n+                        );\n+                    }\n+                }\n+\n+                CastKind::UnsafeFnPointer => {\n+                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+\n+                    // The type that we see in the fcx is like\n+                    // `foo::<'a, 'b>`, where `foo` is the path to a\n+                    // function definition. When we extract the\n+                    // signature, it comes from the `fn_sig` query,\n+                    // and hence may contain unnormalized results.\n+                    let fn_sig = self.normalize(&fn_sig, location);\n+\n+                    let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n+\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            rvalue,\n+                            \"equating {:?} with {:?} yields {:?}\",\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            terr\n+                        );\n+                    }\n+                }\n+\n+                CastKind::Unsize => {\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty]),\n+                    };\n+\n+                    self.prove_trait_ref(trait_ref, location);\n+                }\n+\n+                CastKind::Misc => {}\n+            },\n+\n             // FIXME: These other cases have to be implemented in future PRs\n             Rvalue::Use(..) |\n-            Rvalue::Repeat(..) |\n             Rvalue::Ref(..) |\n             Rvalue::Len(..) |\n-            Rvalue::Cast(..) |\n             Rvalue::BinaryOp(..) |\n             Rvalue::CheckedBinaryOp(..) |\n             Rvalue::UnaryOp(..) |\n-            Rvalue::Discriminant(..) |\n-            Rvalue::NullaryOp(..) => {}\n+            Rvalue::Discriminant(..) => {}\n         }\n     }\n \n@@ -1138,11 +1289,63 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n \n-        match aggregate_kind {\n+        self.prove_aggregate_predicates(aggregate_kind, location);\n+\n+        if *aggregate_kind == AggregateKind::Tuple {\n             // tuple rvalue field type is always the type of the op. Nothing to check here.\n-            AggregateKind::Tuple => return,\n+            return;\n+        }\n+\n+        for (i, operand) in operands.iter().enumerate() {\n+            let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n+                Ok(field_ty) => field_ty,\n+                Err(FieldAccessError::OutOfRange { field_count }) => {\n+                    span_mirbug!(\n+                        self,\n+                        rvalue,\n+                        \"accessed field #{} but variant only has {}\",\n+                        i,\n+                        field_count\n+                    );\n+                    continue;\n+                }\n+            };\n+            let operand_ty = operand.ty(mir, tcx);\n+            if let Err(terr) =\n+                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n+            {\n+                span_mirbug!(\n+                    self,\n+                    rvalue,\n+                    \"{:?} is not a subtype of {:?}: {:?}\",\n+                    operand_ty,\n+                    field_ty,\n+                    terr\n+                );\n+            }\n+        }\n+    }\n+\n+    fn prove_aggregate_predicates(\n+        &mut self,\n+        aggregate_kind: &AggregateKind<'tcx>,\n+        location: Location,\n+    ) {\n+        let tcx = self.tcx();\n+\n+        debug!(\n+            \"prove_aggregate_predicates(aggregate_kind={:?}, location={:?})\",\n+            aggregate_kind,\n+            location\n+        );\n+\n+        let instantiated_predicates = match aggregate_kind {\n+            AggregateKind::Adt(def, _, substs, _) => {\n+                tcx.predicates_of(def.did).instantiate(tcx, substs)\n+            }\n \n             // For closures, we have some **extra requirements** we\n+            //\n             // have to check. In particular, in their upvars and\n             // signatures, closures often reference various regions\n             // from the surrounding function -- we call those the\n@@ -1170,39 +1373,50 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         *substs,\n                     );\n                 }\n-            }\n \n-            _ => {}\n-        }\n+                tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n+            }\n \n-        for (i, operand) in operands.iter().enumerate() {\n-            let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n-                Ok(field_ty) => field_ty,\n-                Err(FieldAccessError::OutOfRange { field_count }) => {\n-                    span_mirbug!(\n-                        self,\n-                        rvalue,\n-                        \"accessed field #{} but variant only has {}\",\n-                        i,\n-                        field_count\n-                    );\n-                    continue;\n-                }\n-            };\n-            let operand_ty = operand.ty(mir, tcx);\n-            if let Err(terr) =\n-                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n-            {\n-                span_mirbug!(\n-                    self,\n-                    rvalue,\n-                    \"{:?} is not a subtype of {:?}: {:?}\",\n-                    operand_ty,\n-                    field_ty,\n-                    terr\n-                );\n+            AggregateKind::Generator(def_id, substs, _) => {\n+                tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n             }\n-        }\n+\n+            AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n+        };\n+\n+        let predicates = self.normalize(&instantiated_predicates.predicates, location);\n+        debug!(\"prove_aggregate_predicates: predicates={:?}\", predicates);\n+        self.prove_predicates(&predicates, location);\n+    }\n+\n+    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, location: Location) {\n+        self.prove_predicates(\n+            &[\n+                ty::Predicate::Trait(trait_ref.to_poly_trait_ref().to_poly_trait_predicate()),\n+            ],\n+            location,\n+        );\n+    }\n+\n+    fn prove_predicates(&mut self, predicates: &[ty::Predicate<'tcx>], location: Location) {\n+        debug!(\n+            \"prove_predicates(predicates={:?}, location={:?})\",\n+            predicates,\n+            location\n+        );\n+        self.fully_perform_op(location.at_self(), |this| {\n+            let cause = this.misc(this.last_span);\n+            let obligations = predicates\n+                .iter()\n+                .map(|&p| {\n+                    traits::Obligation::new(cause.clone(), this.param_env, p)\n+                })\n+                .collect();\n+            Ok(InferOk {\n+                value: (),\n+                obligations,\n+            })\n+        }).unwrap()\n     }\n \n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n@@ -1237,7 +1451,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     {\n         self.fully_perform_op(location.at_self(), |this| {\n             let mut selcx = traits::SelectionContext::new(this.infcx);\n-            let cause = traits::ObligationCause::misc(this.last_span, ast::CRATE_NODE_ID);\n+            let cause = this.misc(this.last_span);\n             let traits::Normalized { value, obligations } =\n                 traits::normalize(&mut selcx, this.param_env, cause, value);\n             Ok(InferOk { value, obligations })"}, {"sha": "edda557c98c3784f99bbe1ec57c62c6d6b3fe9e8", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -75,7 +75,6 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n use errors::DiagnosticBuilder;\n-use syntax::abi;\n use syntax::feature_gate;\n use syntax::ptr::P;\n use syntax_pos;\n@@ -639,9 +638,18 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                     self.normalize_associated_types_in_as_infer_ok(self.cause.span, &a_sig);\n \n                 let a_fn_pointer = self.tcx.mk_fn_ptr(a_sig);\n-                let InferOk { value, obligations: o2 } =\n-                    self.coerce_from_safe_fn(a_fn_pointer, a_sig, b,\n-                        simple(Adjust::ReifyFnPointer), simple(Adjust::ReifyFnPointer))?;\n+                let InferOk { value, obligations: o2 } = self.coerce_from_safe_fn(\n+                    a_fn_pointer,\n+                    a_sig,\n+                    b,\n+                    |unsafe_ty| {\n+                        vec![\n+                            Adjustment { kind: Adjust::ReifyFnPointer, target: a_fn_pointer },\n+                            Adjustment { kind: Adjust::UnsafeFnPointer, target: unsafe_ty },\n+                        ]\n+                    },\n+                    simple(Adjust::ReifyFnPointer)\n+                )?;\n \n                 obligations.extend(o2);\n                 Ok(InferOk { value, obligations })\n@@ -670,22 +678,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // to\n                 //     `fn(arg0,arg1,...) -> _`\n                 let sig = self.closure_sig(def_id_a, substs_a);\n-                let converted_sig = sig.map_bound(|s| {\n-                    let params_iter = match s.inputs()[0].sty {\n-                        ty::TyTuple(params, _) => {\n-                            params.into_iter().cloned()\n-                        }\n-                        _ => bug!(),\n-                    };\n-                    self.tcx.mk_fn_sig(\n-                        params_iter,\n-                        s.output(),\n-                        s.variadic,\n-                        hir::Unsafety::Normal,\n-                        abi::Abi::Rust\n-                    )\n-                });\n-                let pointer_ty = self.tcx.mk_fn_ptr(converted_sig);\n+                let pointer_ty = self.tcx.coerce_closure_fn_ty(sig);\n                 debug!(\"coerce_closure_to_fn(a={:?}, b={:?}, pty={:?})\",\n                        a, b, pointer_ty);\n                 self.unify_and(pointer_ty, b, simple(Adjust::ClosureFnPointer))"}, {"sha": "be0d4b1374185d98f6656a69e966c6cf183a285f", "filename": "src/test/compile-fail/mir_check_cast_closure.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_closure.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(dead_code)]\n+\n+fn bar<'a, 'b>() -> fn(&'a u32, &'b u32) -> &'a u32 {\n+    let g: fn(_, _) -> _ = |_x, y| y;\n+    g\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR free region `'b` does not outlive free region `'a`\n+}\n+\n+fn main() {}"}, {"sha": "091e0b71b2dc3ecbc6bf0d7781a3fe22ac17af90", "filename": "src/test/compile-fail/mir_check_cast_reify.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_reify.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(dead_code)]\n+\n+// Test that we relate the type of the fn type to the type of the fn\n+// ptr when doing a `ReifyFnPointer` cast.\n+//\n+// This test is a bit tortured, let me explain:\n+//\n+\n+// The `where 'a: 'a` clause here ensures that `'a` is early bound,\n+// which is needed below to ensure that this test hits the path we are\n+// concerned with.\n+fn foo<'a>(x: &'a u32) -> &'a u32\n+where\n+    'a: 'a,\n+{\n+    panic!()\n+}\n+\n+fn bar<'a>(x: &'a u32) -> &'static u32 {\n+    // Here, the type of `foo` is `typeof(foo::<'x>)` for some fresh variable `'x`.\n+    // During NLL region analysis, this will get renumbered to `typeof(foo::<'?0>)`\n+    // where `'?0` is a new region variable.\n+    //\n+    // (Note that if `'a` on `foo` were late-bound, the type would be\n+    // `typeof(foo)`, which would interact differently with because\n+    // the renumbering later.)\n+    //\n+    // This type is then coerced to a fn type `fn(&'?1 u32) -> &'?2\n+    // u32`. Here, the `'?1` and `'?2` will have been created during\n+    // the NLL region renumbering.\n+    //\n+    // The MIR type checker must therefore relate `'?0` to `'?1` and `'?2`\n+    // as part of checking the `ReifyFnPointer`.\n+    let f: fn(_) -> _ = foo;\n+    //~^ WARNING not reporting region error due to -Znll\n+    f(x)\n+    //~^ ERROR free region `'_#1r` does not outlive free region `'static`\n+}\n+\n+fn main() {}"}, {"sha": "701a7c6b056a6245961062f4e9e4e292bc6ede52", "filename": "src/test/compile-fail/mir_check_cast_unsafe_fn.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsafe_fn.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(dead_code)]\n+\n+fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n+    // Here the NLL checker must relate the types in `f` to the types\n+    // in `g`. These are related via the `UnsafeFnPointer` cast.\n+    let g: unsafe fn(_) -> _ = f;\n+    //~^ WARNING not reporting region error due to -Znll\n+    unsafe { g(input) }\n+    //~^ ERROR free region `'_#1r` does not outlive free region `'static`\n+}\n+\n+fn main() {}"}, {"sha": "bc867047ab5b3bf340ca1db95a4178e14ea1973f", "filename": "src/test/compile-fail/mir_check_cast_unsize.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmir_check_cast_unsize.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(dead_code)]\n+#![feature(dyn_trait)]\n+\n+use std::fmt::Debug;\n+\n+fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n+    //~^ ERROR free region `'_#1r` does not outlive free region `'static`\n+    x\n+    //~^ WARNING not reporting region error due to -Znll\n+}\n+\n+fn main() {}"}, {"sha": "a13360aeca7f505a475028705477d1b5b5e34a14", "filename": "src/test/compile-fail/nll/where_clauses_in_functions.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_functions.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(dead_code)]\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32)\n+where\n+    'a: 'b,\n+{\n+    (x, y)\n+}\n+\n+fn bar<'a, 'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n+    foo(x, y)\n+    //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+    //~| WARNING not reporting region error due to -Znll\n+}\n+\n+fn main() {}"}, {"sha": "93c774e89961856ace6a17d5548ef623e5089701", "filename": "src/test/compile-fail/nll/where_clauses_in_repeat_rvalue.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_repeat_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_repeat_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_repeat_rvalue.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Foo<T> {\n+    t: T,\n+}\n+\n+impl<T: 'static + Copy> Copy for Foo<T> {}\n+impl<T: 'static + Copy> Clone for Foo<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 22;\n+\n+    {\n+        let p = &x;\n+        //~^ ERROR `x` does not live long enough\n+        let w = Foo { t: p };\n+\n+        let v = [w; 22];\n+    }\n+\n+    x += 1;\n+    //~^ ERROR cannot assign to `x` because it is borrowed [E0506]\n+}"}, {"sha": "0c4fd5dead3f9dc2a5de8ffa23fbddc30c27f2dd", "filename": "src/test/compile-fail/nll/where_clauses_in_structs.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fwhere_clauses_in_structs.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z borrowck=mir -Z nll\n+\n+#![allow(dead_code)]\n+\n+use std::cell::Cell;\n+\n+struct Foo<'a: 'b, 'b> {\n+    x: Cell<&'a u32>,\n+    y: Cell<&'b u32>,\n+}\n+\n+fn bar<'a, 'b>(x: Cell<&'a u32>, y: Cell<&'b u32>) {\n+    Foo { x, y };\n+    //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+    //~| WARNING not reporting region error due to -Znll\n+}\n+\n+fn main() {}"}, {"sha": "678da45fce41fc23bc47ddb38242d2de11333bb6", "filename": "src/test/compile-fail/regions-static-bound.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-static-bound.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -24,11 +24,10 @@ fn static_id_wrong_way<'a>(t: &'a ()) -> &'static () where 'static: 'a {\n fn error(u: &(), v: &()) {\n     static_id(&u); //[ll]~ ERROR cannot infer an appropriate lifetime\n     //[nll]~^ WARNING not reporting region error due to -Znll\n+    //[nll]~| ERROR free region `'_#1r` does not outlive free region `'static`\n     static_id_indirect(&v); //[ll]~ ERROR cannot infer an appropriate lifetime\n     //[nll]~^ WARNING not reporting region error due to -Znll\n-\n-    // FIXME(#45827) -- MIR type checker shortcomings mean we don't\n-    // see these errors (yet) in nll mode.\n+    //[nll]~| ERROR free region `'_#2r` does not outlive free region `'static`\n }\n \n fn main() {}"}, {"sha": "f3a57c088409ac05fb8e35894620739b6d53ee83", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -33,10 +33,10 @@ fn main() {\n // | '_#3r    | Local    | ['_#3r]\n // |\n // | Inferred Region Values\n-// | '_#0r    | {bb0[0], bb0[1], '_#0r}\n-// | '_#1r    | {bb0[0], bb0[1], '_#1r}\n-// | '_#2r    | {bb0[0], bb0[1], '_#2r}\n-// | '_#3r    | {bb0[0], bb0[1], '_#3r}\n+// | '_#0r    | {'_#0r, bb0[0], bb0[1]}\n+// | '_#1r    | {'_#1r, bb0[0], bb0[1]}\n+// | '_#2r    | {'_#2r, bb0[0], bb0[1]}\n+// | '_#3r    | {'_#3r, bb0[0], bb0[1]}\n // |\n // ...\n // fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {"}, {"sha": "11918d3739d4bf8b4ca1e6b816708550660b3e91", "filename": "src/test/run-pass/mir-typeck-normalize-fn-sig.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Frun-pass%2Fmir-typeck-normalize-fn-sig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Frun-pass%2Fmir-typeck-normalize-fn-sig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir-typeck-normalize-fn-sig.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This code was creating an ICE in the MIR type checker. The reason\n+// is that we are reifying a reference to a function (`foo::<'x>`),\n+// which involves extracting its signature, but we were not\n+// normalizing the signature afterwards. As a result, we sometimes got\n+// errors around the `<u32 as Foo<'x>>::Value`, which can be\n+// normalized to `f64`.\n+\n+#![allow(dead_code)]\n+\n+trait Foo<'x> {\n+    type Value;\n+}\n+\n+impl<'x> Foo<'x> for u32 {\n+    type Value = f64;\n+}\n+\n+struct Providers<'x> {\n+    foo: for<'y> fn(x: &'x u32, y: &'y u32) -> <u32 as Foo<'x>>::Value,\n+}\n+\n+fn foo<'y, 'x: 'x>(x: &'x u32, y: &'y u32) -> <u32 as Foo<'x>>::Value {\n+    *x as f64\n+}\n+\n+fn main() {\n+    Providers { foo };\n+}"}, {"sha": "80a40581b8957c188640c9ef5d0d3f3eba2264d9", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -21,14 +21,8 @@\n //\n // Note: the use of `Cell` here is to introduce invariance. One less\n // variable.\n-//\n-// FIXME(#45827): The `supply` function *ought* to generate an error, but it\n-// currently does not. This is I believe a shortcoming of the MIR type\n-// checker: the closure inference is expressing the correct\n-// requirement, as you can see from the `#[rustc_regions]` output.\n \n // compile-flags:-Znll -Zborrowck=mir -Zverbose\n-// must-compile-successfully\n \n #![feature(rustc_attrs)]\n \n@@ -57,8 +51,10 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+        //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+\n         // Only works if 'x: 'y:\n-        demand_y(x, y, x.get())\n+        demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n     });\n }\n "}, {"sha": "717cf481a01d193d1d4343161e6ed5389d80d070", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -1,17 +1,19 @@\n warning: not reporting region error due to -Znll\n-  --> $DIR/propagate-approximated-ref.rs:61:9\n+  --> $DIR/propagate-approximated-ref.rs:57:9\n    |\n-61 |         demand_y(x, y, x.get())\n+57 |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n-  --> $DIR/propagate-approximated-ref.rs:59:47\n+  --> $DIR/propagate-approximated-ref.rs:53:47\n    |\n-59 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+53 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n-60 | |         // Only works if 'x: 'y:\n-61 | |         demand_y(x, y, x.get())\n-62 | |     });\n+54 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+55 | |\n+56 | |         // Only works if 'x: 'y:\n+57 | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+58 | |     });\n    | |_____^\n    |\n    = note: defining type: DefId(0/1:18 ~ propagate_approximated_ref[317d]::supply[0]::{{closure}}[0]) with closure substs [\n@@ -21,16 +23,25 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n+error: free region `'_#1r` does not outlive free region `'_#2r`\n+  --> $DIR/propagate-approximated-ref.rs:53:38\n+   |\n+53 |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |                                      ^^^^^^^\n+\n note: No external requirements\n-  --> $DIR/propagate-approximated-ref.rs:58:1\n+  --> $DIR/propagate-approximated-ref.rs:52:1\n    |\n-58 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-59 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-60 | |         // Only works if 'x: 'y:\n-61 | |         demand_y(x, y, x.get())\n-62 | |     });\n-63 | | }\n+52 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+53 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+54 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+55 | |\n+...  |\n+58 | |     });\n+59 | | }\n    | |_^\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_ref[317d]::supply[0]) with substs []\n \n+error: aborting due to previous error\n+"}, {"sha": "244929d71dba8ed9b81b20dd05c1f3bc25d7f1b2", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -39,12 +39,10 @@ fn case1() {\n fn case2() {\n     let a = 0;\n     let cell = Cell::new(&a);\n+    //~^ ERROR `a` does not live long enough\n \n     // As you can see in the stderr output, this closure propoagates a\n     // requirement that `'a: 'static'.\n-    //\n-    // FIXME(#45827) However, because of shortcomings in the MIR type\n-    // checker, this does not result in errors later on (yet).\n     foo(cell, |cell_a, cell_x| {\n         cell_x.set(cell_a.get()); // forces 'a: 'x, implies 'a = 'static -> borrow error\n     })"}, {"sha": "b93c69dc13f46ba691b79412cd196884879be704", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -42,12 +42,12 @@ note: No external requirements\n    = note: defining type: DefId(0/0:5 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case1[0]) with substs []\n \n note: External requirements\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:48:15\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:46:15\n    |\n-48 |       foo(cell, |cell_a, cell_x| {\n+46 |       foo(cell, |cell_a, cell_x| {\n    |  _______________^\n-49 | |         cell_x.set(cell_a.get()); // forces 'a: 'x, implies 'a = 'static -> borrow error\n-50 | |     })\n+47 | |         cell_x.set(cell_a.get()); // forces 'a: 'x, implies 'a = 'static -> borrow error\n+48 | |     })\n    | |_____^\n    |\n    = note: defining type: DefId(0/1:13 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case2[0]::{{closure}}[0]) with closure substs [\n@@ -63,13 +63,24 @@ note: No external requirements\n 39 | / fn case2() {\n 40 | |     let a = 0;\n 41 | |     let cell = Cell::new(&a);\n-42 | |\n+42 | |     //~^ ERROR `a` does not live long enough\n ...  |\n-50 | |     })\n-51 | | }\n+48 | |     })\n+49 | | }\n    | |_^\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_comparing_against_free[317d]::case2[0]) with substs []\n \n-error: aborting due to previous error\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:41:26\n+   |\n+41 |     let cell = Cell::new(&a);\n+   |                          ^^ does not live long enough\n+...\n+49 | }\n+   | - borrowed value only lives until here\n+   |\n+   = note: borrowed value must be valid for lifetime '_#1r...\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "54007f0191da1f5ba1127806d80353892bc32057", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -17,7 +17,6 @@\n // these errors are not (yet) reported.\n \n // compile-flags:-Znll -Zborrowck=mir -Zverbose\n-// must-compile-successfully\n \n #![feature(rustc_attrs)]\n \n@@ -44,8 +43,10 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+        //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+\n         // Only works if 'x: 'y:\n-        demand_y(x, y, x.get())\n+        demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n     });\n }\n "}, {"sha": "86b9fecb80e2ef989cfd0fa9935cf1030885f3b1", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -1,17 +1,19 @@\n warning: not reporting region error due to -Znll\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:48:9\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:49:9\n    |\n-48 |         demand_y(x, y, x.get())\n+49 |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:46:47\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n    |\n-46 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |  _______________________________________________^\n-47 | |         // Only works if 'x: 'y:\n-48 | |         demand_y(x, y, x.get())\n-49 | |     });\n+46 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+47 | |\n+48 | |         // Only works if 'x: 'y:\n+49 | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+50 | |     });\n    | |_____^\n    |\n    = note: defining type: DefId(0/1:18 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]::{{closure}}[0]) with closure substs [\n@@ -21,16 +23,31 @@ note: External requirements\n    = note: number of external vids: 2\n    = note: where '_#1r: '_#0r\n \n+error: free region `'_#1r` does not outlive free region `ReStatic`\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n+   |\n+45 |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |  _______________________________________________^\n+46 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+47 | |\n+48 | |         // Only works if 'x: 'y:\n+49 | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to -Znll\n+50 | |     });\n+   | |_____^\n+\n note: No external requirements\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:1\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1\n    |\n-45 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-46 | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-47 | |         // Only works if 'x: 'y:\n-48 | |         demand_y(x, y, x.get())\n-49 | |     });\n-50 | | }\n+44 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+45 | |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+46 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+47 | |\n+...  |\n+50 | |     });\n+51 | | }\n    | |_^\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]) with substs []\n \n+error: aborting due to previous error\n+"}, {"sha": "68d51e2b7d105f15833592f51e5055b056347f3a", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -18,7 +18,6 @@\n // these errors are not (yet) reported.\n \n // compile-flags:-Znll -Zborrowck=mir -Zverbose\n-// must-compile-successfully\n \n #![feature(rustc_attrs)]\n \n@@ -47,8 +46,10 @@ fn demand_y<'x, 'y>(_cell_x: &Cell<&'x u32>, _cell_y: &Cell<&'y u32>, _y: &'y u3\n #[rustc_regions]\n fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+        //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n         // Only works if 'x: 'y:\n         demand_y(x, y, x.get())\n+        //~^ WARNING not reporting region error due to -Znll\n     });\n }\n "}, {"sha": "adc6b1ac595e928205ce528bb8d462f183622c4d", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -5,13 +5,15 @@ warning: not reporting region error due to -Znll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n-  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:49:47\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n    |\n-49 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+48 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |  _______________________________________________^\n+49 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n 50 | |         // Only works if 'x: 'y:\n 51 | |         demand_y(x, y, x.get())\n-52 | |     });\n+52 | |         //~^ WARNING not reporting region error due to -Znll\n+53 | |     });\n    | |_____^\n    |\n    = note: defining type: DefId(0/1:18 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]::{{closure}}[0]) with closure substs [\n@@ -21,16 +23,31 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#0r\n \n-note: No external requirements\n-  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:1\n+error: free region `'_#1r` does not outlive free region `ReStatic`\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n    |\n-48 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-49 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+48 |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |  _______________________________________________^\n+49 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n 50 | |         // Only works if 'x: 'y:\n 51 | |         demand_y(x, y, x.get())\n-52 | |     });\n-53 | | }\n+52 | |         //~^ WARNING not reporting region error due to -Znll\n+53 | |     });\n+   | |_____^\n+\n+note: No external requirements\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1\n+   |\n+47 | / fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+48 | |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+49 | |         //~^ ERROR free region `'_#1r` does not outlive free region `ReStatic`\n+50 | |         // Only works if 'x: 'y:\n+...  |\n+53 | |     });\n+54 | | }\n    | |_^\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]) with substs []\n \n+error: aborting due to previous error\n+"}, {"sha": "b4a759d5e705d24078973eedb3e50115599c8bc3", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.rs?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -16,7 +16,6 @@\n // anonymous regions as well.\n \n // compile-flags:-Znll -Zborrowck=mir -Zverbose\n-// must-compile-successfully\n \n #![feature(rustc_attrs)]\n \n@@ -45,8 +44,10 @@ fn demand_y<'x, 'y>(_outlives1: Cell<&&'x u32>, _outlives2: Cell<&'y &u32>, _y:\n #[rustc_regions]\n fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+        //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+\n         // Only works if 'x: 'y:\n-        demand_y(outlives1, outlives2, x.get())\n+        demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n     });\n }\n "}, {"sha": "43464bfb2b9a7213dac8d1d994a0b38a57f2c28b", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f03e06762ea6c4116c360185c0e9b6f209b76959/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=f03e06762ea6c4116c360185c0e9b6f209b76959", "patch": "@@ -1,17 +1,19 @@\n warning: not reporting region error due to -Znll\n-  --> $DIR/propagate-approximated-val.rs:49:9\n+  --> $DIR/propagate-approximated-val.rs:50:9\n    |\n-49 |         demand_y(outlives1, outlives2, x.get())\n+50 |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n note: External requirements\n-  --> $DIR/propagate-approximated-val.rs:47:45\n+  --> $DIR/propagate-approximated-val.rs:46:45\n    |\n-47 |       establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+46 |       establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n    |  _____________________________________________^\n-48 | |         // Only works if 'x: 'y:\n-49 | |         demand_y(outlives1, outlives2, x.get())\n-50 | |     });\n+47 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+48 | |\n+49 | |         // Only works if 'x: 'y:\n+50 | |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to -Znll\n+51 | |     });\n    | |_____^\n    |\n    = note: defining type: DefId(0/1:18 ~ propagate_approximated_val[317d]::test[0]::{{closure}}[0]) with closure substs [\n@@ -21,16 +23,25 @@ note: External requirements\n    = note: number of external vids: 3\n    = note: where '_#1r: '_#2r\n \n+error: free region `'_#1r` does not outlive free region `'_#2r`\n+  --> $DIR/propagate-approximated-val.rs:46:37\n+   |\n+46 |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+   |                                     ^^^^^^\n+\n note: No external requirements\n-  --> $DIR/propagate-approximated-val.rs:46:1\n+  --> $DIR/propagate-approximated-val.rs:45:1\n    |\n-46 | / fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-47 | |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n-48 | |         // Only works if 'x: 'y:\n-49 | |         demand_y(outlives1, outlives2, x.get())\n-50 | |     });\n-51 | | }\n+45 | / fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+46 | |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+47 | |         //~^ ERROR free region `'_#1r` does not outlive free region `'_#2r`\n+48 | |\n+...  |\n+51 | |     });\n+52 | | }\n    | |_^\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_val[317d]::test[0]) with substs []\n \n+error: aborting due to previous error\n+"}]}