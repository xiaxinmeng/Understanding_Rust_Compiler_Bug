{"sha": "95ef1f54153095d7287ac1ca4209cdef4635ab0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZWYxZjU0MTUzMDk1ZDcyODdhYzFjYTQyMDljZGVmNDYzNWFiMGU=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:36:39Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-09-17T06:36:39Z"}, "message": "std: docstring fixes in io::file", "tree": {"sha": "366172d57f98ea3a3cc1f3eb1265c6e0e6ba979f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/366172d57f98ea3a3cc1f3eb1265c6e0e6ba979f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95ef1f54153095d7287ac1ca4209cdef4635ab0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95ef1f54153095d7287ac1ca4209cdef4635ab0e", "html_url": "https://github.com/rust-lang/rust/commit/95ef1f54153095d7287ac1ca4209cdef4635ab0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95ef1f54153095d7287ac1ca4209cdef4635ab0e/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56c87ffb30d0c876210497d20c3493fd39a75163", "url": "https://api.github.com/repos/rust-lang/rust/commits/56c87ffb30d0c876210497d20c3493fd39a75163", "html_url": "https://github.com/rust-lang/rust/commit/56c87ffb30d0c876210497d20c3493fd39a75163"}], "stats": {"total": 498, "additions": 259, "deletions": 239}, "files": [{"sha": "2a9b71db90bb059d961b1153d7e515205385c9dd", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 259, "deletions": 239, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/95ef1f54153095d7287ac1ca4209cdef4635ab0e/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ef1f54153095d7287ac1ca4209cdef4635ab0e/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=95ef1f54153095d7287ac1ca4209cdef4635ab0e", "patch": "@@ -8,21 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-use super::support::PathLike;\n-use super::{Reader, Writer, Seek};\n-use super::{SeekStyle,SeekSet, SeekCur, SeekEnd,\n-            Open, Read, Write, Create, ReadWrite};\n-use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n-use rt::io::{io_error, read_error, EndOfFile,\n-            FileMode, FileAccess, FileStat, IoError,\n-            PathAlreadyExists, PathDoesntExist,\n-            MismatchedFileTypeForOperation, ignore_io_error};\n-use rt::local::Local;\n-use option::{Some, None};\n-use path::Path;\n-use super::super::test::*;\n-\n /*! Synchronous File I/O\n \n This module provides a set of functions and traits for working\n@@ -44,52 +29,66 @@ possible, the `{FileInfo, DirectoryInfo}` preserve the same semantics as their\n free function counterparts.\n */\n \n-/*! Open a file for reading/writing, as indicated by `path`.\n-\n-# Example\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::support::PathLike;\n-    use std::rt::io::file::open;\n-    use std::rt::io::{FileMode, FileAccess};\n-\n-    let p = &Path(\"/some/file/path.txt\");\n-    \n-    do io_error::cond.trap(|_| {\n-        // hoo-boy...\n-    }).inside {\n-        let stream = match open(p, Create, ReadWrite) {\n-            Some(s) => s,\n-            None => fail!(\"whoops! I'm sure this raised, anyways..\");\n-        }\n-        // do some stuff with that stream\n-\n-        // the file stream will be closed at the end of this block\n-    }\n-    // ..\n-\n-`FileMode` and `FileAccess` provide information about the permissions\n-context in which a given stream is created. More information about them\n-can be found in `std::rt::io`'s docs.\n-\n-Note that, with this function, a `FileStream` is returned regardless of\n-the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n-`FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n-desire a more-correctly-constrained interface to files, use the\n-`{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n-\n-# Errors\n-\n-This function will raise an `io_error` condition under a number of different circumstances,\n-to include but not limited to:\n+use prelude::*;\n+use super::support::PathLike;\n+use super::{Reader, Writer, Seek};\n+use super::{SeekStyle,SeekSet, SeekCur, SeekEnd,\n+            Open, Read, Write, Create, ReadWrite};\n+use rt::rtio::{RtioFileStream, IoFactory, IoFactoryObject};\n+use rt::io::{io_error, read_error, EndOfFile,\n+            FileMode, FileAccess, FileStat, IoError,\n+            PathAlreadyExists, PathDoesntExist,\n+            MismatchedFileTypeForOperation, ignore_io_error};\n+use rt::local::Local;\n+use option::{Some, None};\n+use path::Path;\n+use super::super::test::*;\n \n-* Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n-  opening a non-existant file with `FileMode` or `Open`)\n-* Attempting to open a file with a `FileAccess` that the user lacks permissions\n-  for\n-* Filesystem-level errors (full disk, etc)\n-*/\n+/// Open a file for reading/writing, as indicated by `path`.\n+/// \n+/// # Example\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::open;\n+///     use std::rt::io::{FileMode, FileAccess};\n+/// \n+///     let p = &Path(\"/some/file/path.txt\");\n+///     \n+///     do io_error::cond.trap(|_| {\n+///         // hoo-boy...\n+///     }).inside {\n+///         let stream = match open(p, Create, ReadWrite) {\n+///             Some(s) => s,\n+///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+///         }\n+///         // do some stuff with that stream\n+/// \n+///         // the file stream will be closed at the end of this block\n+///     }\n+///     // ..\n+/// \n+/// `FileMode` and `FileAccess` provide information about the permissions\n+/// context in which a given stream is created. More information about them\n+/// can be found in `std::rt::io`'s docs.\n+/// \n+/// Note that, with this function, a `FileStream` is returned regardless of\n+/// the access-limitations indicated by `FileAccess` (e.g. calling `write` on a\n+/// `FileStream` opened as `ReadOnly` will raise an `io_error` condition at runtime). If you\n+/// desire a more-correctly-constrained interface to files, use the\n+/// `{open_stream, open_reader, open_writer}` methods that are a part of `FileInfo`\n+/// \n+/// # Errors\n+/// \n+/// This function will raise an `io_error` condition under a number of different circumstances,\n+/// to include but not limited to:\n+/// \n+/// * Opening a file that already exists with `FileMode` of `Create` or vice versa (e.g.\n+///   opening a non-existant file with `FileMode` or `Open`)\n+/// * Attempting to open a file with a `FileAccess` that the user lacks permissions\n+///   for\n+/// * Filesystem-level errors (full disk, etc)\n pub fn open<P: PathLike>(path: &P,\n                          mode: FileMode,\n                          access: FileAccess\n@@ -110,29 +109,28 @@ pub fn open<P: PathLike>(path: &P,\n     }\n }\n \n-/*! Unlink a file from the underlying filesystem.\n-\n-# Example\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::support::PathLike;\n-    use std::rt::io::file::unlink;\n-\n-    let p = &Path(\"/some/file/path.txt\");\n-    unlink(p);\n-    // if we made it here without failing, then the\n-    // unlink operation was successful\n-\n-Note that, just because an unlink call was successful, it is not\n-guaranteed that a file is immediately deleted (e.g. depending on\n-platform, other open file descriptors may prevent immediate removal)\n-\n-# Errors\n-\n-This function will raise an `io_error` condition if the user lacks permissions to\n-remove the file or if some other filesystem-level error occurs\n-*/\n+/// Unlink a file from the underlying filesystem.\n+/// \n+/// # Example\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::unlink;\n+/// \n+///     let p = &Path(\"/some/file/path.txt\");\n+///     unlink(p);\n+///     // if we made it here without failing, then the\n+///     // unlink operation was successful\n+/// \n+/// Note that, just because an unlink call was successful, it is not\n+/// guaranteed that a file is immediately deleted (e.g. depending on\n+/// platform, other open file descriptors may prevent immediate removal)\n+/// \n+/// # Errors\n+/// \n+/// This function will raise an `io_error` condition if the user lacks permissions to\n+/// remove the file or if some other filesystem-level error occurs\n pub fn unlink<P: PathLike>(path: &P) {\n     let unlink_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -146,24 +144,23 @@ pub fn unlink<P: PathLike>(path: &P) {\n     }\n }\n \n-/*! Create a new, empty directory at the provided path\n-\n-# Example\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::support::PathLike;\n-    use std::rt::io::file::mkdir;\n-\n-    let p = &Path(\"/some/dir\");\n-    mkdir(p);\n-    // If we got here, our directory exists! Horray!\n-\n-# Errors\n-\n-This call will raise an `io_error` condition if the user lacks permissions to make a\n-new directory at the provided path, or if the directory already exists\n-*/\n+/// Create a new, empty directory at the provided path\n+/// \n+/// # Example\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::mkdir;\n+/// \n+///     let p = &Path(\"/some/dir\");\n+///     mkdir(p);\n+///     // If we got here, our directory exists! Horray!\n+/// \n+/// # Errors\n+/// \n+/// This call will raise an `io_error` condition if the user lacks permissions to make a\n+/// new directory at the provided path, or if the directory already exists\n pub fn mkdir<P: PathLike>(path: &P) {\n     let mkdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -177,24 +174,23 @@ pub fn mkdir<P: PathLike>(path: &P) {\n     }\n }\n \n-/*! Remove an existing, empty directory\n-\n-# Example\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::support::PathLike;\n-    use std::rt::io::file::rmdir;\n-\n-    let p = &Path(\"/some/dir\");\n-    rmdir(p);\n-    // good riddance, you mean ol' directory\n-\n-# Errors\n-\n-This call will raise an `io_error` condition if the user lacks permissions to remove the\n-directory at the provided path, or if the directory isn't empty\n-*/\n+/// Remove an existing, empty directory\n+/// \n+/// # Example\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::rmdir;\n+/// \n+///     let p = &Path(\"/some/dir\");\n+///     rmdir(p);\n+///     // good riddance, you mean ol' directory\n+/// \n+/// # Errors\n+/// \n+/// This call will raise an `io_error` condition if the user lacks permissions to remove the\n+/// directory at the provided path, or if the directory isn't empty\n pub fn rmdir<P: PathLike>(path: &P) {\n     let rmdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -208,43 +204,42 @@ pub fn rmdir<P: PathLike>(path: &P) {\n     }\n }\n \n-/*! Get information on the file, directory, etc at the provided path\n-\n-Given a `rt::io::support::PathLike`, query the file system to get\n-information about a file, directory, etc.\n-\n-Returns a `Some(std::rt::io::PathInfo)` on success\n-\n-# Example\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::support::PathLike;\n-    use std::rt::io::file::stat;\n-\n-    let p = &Path(\"/some/file/path.txt\");\n-\n-    do io_error::cond.trap(|_| {\n-        // hoo-boy...\n-    }).inside {\n-        let info = match stat(p) {\n-            Some(s) => s,\n-            None => fail!(\"whoops! I'm sure this raised, anyways..\");\n-        }\n-        if stat.is_file {\n-            // just imagine the possibilities ...\n-        }\n-\n-        // the file stream will be closed at the end of this block\n-    }\n-    // ..\n-\n-# Errors\n-\n-This call will raise an `io_error` condition if the user lacks the requisite\n-permissions to perform a `stat` call on the given path or if there is no\n-entry in the filesystem at the provided path.\n-*/\n+/// Get information on the file, directory, etc at the provided path\n+/// \n+/// Given a `rt::io::support::PathLike`, query the file system to get\n+/// information about a file, directory, etc.\n+/// \n+/// Returns a `Some(std::rt::io::PathInfo)` on success\n+/// \n+/// # Example\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::stat;\n+/// \n+///     let p = &Path(\"/some/file/path.txt\");\n+/// \n+///     do io_error::cond.trap(|_| {\n+///         // hoo-boy...\n+///     }).inside {\n+///         let info = match stat(p) {\n+///             Some(s) => s,\n+///             None => fail!(\"whoops! I'm sure this raised, anyways..\");\n+///         }\n+///         if stat.is_file {\n+///             // just imagine the possibilities ...\n+///         }\n+/// \n+///         // the file stream will be closed at the end of this block\n+///     }\n+///     // ..\n+/// \n+/// # Errors\n+/// \n+/// This call will raise an `io_error` condition if the user lacks the requisite\n+/// permissions to perform a `stat` call on the given path or if there is no\n+/// entry in the filesystem at the provided path.\n pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n     let open_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -261,8 +256,31 @@ pub fn stat<P: PathLike>(path: &P) -> Option<FileStat> {\n     }\n }\n \n-/*! Retrieve a vector containing all entries within a provided directory\n-*/\n+/// Retrieve a vector containing all entries within a provided directory\n+///\n+/// # Example\n+///\n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::support::PathLike;\n+///     use std::rt::io::file::readdir;\n+///\n+///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///         if dir.is_dir() {\n+///             let contents = dir.readdir();\n+///             for entry in contents.iter() {\n+///                 if entry.is_dir() { visit_dirs(entry, cb); }\n+///                 else { cb(entry); }\n+///             }\n+///         }\n+///         else { fail!(\"nope\"); }\n+///     }\n+///\n+/// # Errors\n+///\n+/// Will raise an `io_error` condition if the provided `path` doesn't exist,\n+/// the process lacks permissions to view the contents or if the `path` points\n+/// at a non-directory file\n pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n     let readdir_result = unsafe {\n         let io: *mut IoFactoryObject = Local::unsafe_borrow();\n@@ -279,10 +297,9 @@ pub fn readdir<P: PathLike>(path: &P) -> Option<~[Path]> {\n     }\n }\n \n-/*! Constrained version of `FileStream` that only exposes read-specific operations.\n-\n-Can be retreived via `FileInfo.open_reader()`.\n-*/\n+/// Constrained version of `FileStream` that only exposes read-specific operations.\n+///\n+/// Can be retreived via `FileInfo.open_reader()`.\n pub struct FileReader { priv stream: FileStream }\n \n /// a `std::rt::io::Reader` trait impl for file I/O.\n@@ -307,10 +324,9 @@ impl Seek for FileReader {\n     }\n }\n \n-/*! Constrained version of `FileStream` that only exposes write-specific operations.\n-\n-Can be retreived via `FileInfo.open_writer()`.\n-*/\n+/// Constrained version of `FileStream` that only exposes write-specific operations.\n+/// \n+/// Can be retreived via `FileInfo.open_writer()`.\n pub struct FileWriter { priv stream: FileStream }\n \n /// a `std::rt::io::Writer` trait impl for file I/O.\n@@ -335,19 +351,18 @@ impl Seek for FileWriter {\n     }\n }\n \n-/*! Unconstrained file access type that exposes read and write operations\n-\n-Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n-\n-# Errors\n-\n-This type will raise an io_error condition if operations are attempted against\n-it for which its underlying file descriptor was not configured at creation\n-time, via the `FileAccess` parameter to `file::open()`.\n-\n-For this reason, it is best to use the access-constrained wrappers that are\n-exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n-*/\n+/// Unconstrained file access type that exposes read and write operations\n+/// \n+/// Can be retreived via `file::open()` and `FileInfo.open_stream()`.\n+/// \n+/// # Errors\n+/// \n+/// This type will raise an io_error condition if operations are attempted against\n+/// it for which its underlying file descriptor was not configured at creation\n+/// time, via the `FileAccess` parameter to `file::open()`.\n+/// \n+/// For this reason, it is best to use the access-constrained wrappers that are\n+/// exposed via `FileInfo.open_reader()` and `FileInfo.open_writer()`.\n pub struct FileStream {\n     fd: ~RtioFileStream,\n     last_nread: int,\n@@ -435,12 +450,11 @@ pub trait FileSystemInfo {\n     /// later creates\n     fn get_path<'a>(&'a self) -> &'a Path;\n \n-    /*! Get information on the file, directory, etc at the provided path\n-\n-    Consult the `file::stat` documentation for more info.\n-\n-    This call preserves identical runtime/error semantics\n-    */\n+    /// Get information on the file, directory, etc at the provided path\n+    ///\n+    /// Consult the `file::stat` documentation for more info.\n+    ///\n+    /// This call preserves identical runtime/error semantics with `file::stat`\n     fn stat(&self) -> Option<FileStat> {\n         stat(self.get_path())\n     }\n@@ -459,37 +473,40 @@ pub trait FileSystemInfo {\n \n }\n \n-/*! Represents a file, whose underlying path may or may not be valid\n-\n-# Example\n-\n-* Check if a file exists, reading from it if so\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::file::{FileInfo, FileReader};\n-\n-    let f = &Path(\"/some/file/path.txt\");\n-    if f.exists() {\n-        let reader = f.open_reader(Open);\n-        let mut mem = [0u8, 8*64000];\n-        reader.read(mem);\n-        // ...\n-    }\n-\n-* Is the given path a file?\n-\n-   let f = get_file_path_from_wherever();\n-   match f.is_file() {\n-       true => doing_something_with_a_file(f),\n-       _ => {}\n-   }\n-*/\n+/// Represents a file, whose underlying path may or may not be valid\n+/// \n+/// # Example\n+/// \n+/// * Check if a file exists, reading from it if so\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::file::{FileInfo, FileReader};\n+/// \n+///     let f = &Path(\"/some/file/path.txt\");\n+///     if f.exists() {\n+///         let reader = f.open_reader(Open);\n+///         let mut mem = [0u8, 8*64000];\n+///         reader.read(mem);\n+///         // ...\n+///     }\n+/// \n+/// * Is the given path a file?\n+/// \n+///    let f = get_file_path_from_wherever();\n+///    match f.is_file() {\n+///        true => doing_something_with_a_file(f),\n+///        _ => {}\n+///    }\n pub trait FileInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) points at a \"regular file\" on the FS. Will return\n     /// false for paths to non-existent locations or directories or\n     /// other non-regular files (named pipes, etc).\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n     fn is_file(&self) -> bool {\n         match ignore_io_error(|| self.stat()) {\n             Some(s) => s.is_file,\n@@ -549,39 +566,42 @@ impl FileSystemInfo for Path {\n /// `FileInfo` implementation for `Path`s\n impl FileInfo for Path { }\n \n-/*! Represents a directory, whose underlying path may or may not be valid\n-\n-# Example\n-\n-* Check if a directory exists, `mkdir`'ing it if not\n-\n-    use std;\n-    use std::path::Path;\n-    use std::rt::io::file::{DirectoryInfo};\n-\n-    let dir = &Path(\"/some/dir\");\n-    if !dir.exists() {\n-        dir.mkdir();\n-    }\n-\n-* Is the given path a directory? If so, iterate on its contents\n-\n-    fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n-        if dir.is_dir() {\n-            let contents = dir.readdir();\n-            for entry in contents.iter() {\n-                if entry.is_dir() { visit_dirs(entry, cb); }\n-                else { cb(entry); }\n-            }\n-        }\n-        else { fail!(\"nope\"); }\n-    }\n-*/\n+/// Represents a directory, whose underlying path may or may not be valid\n+/// \n+/// # Example\n+/// \n+/// * Check if a directory exists, `mkdir`'ing it if not\n+/// \n+///     use std;\n+///     use std::path::Path;\n+///     use std::rt::io::file::{DirectoryInfo};\n+/// \n+///     let dir = &Path(\"/some/dir\");\n+///     if !dir.exists() {\n+///         dir.mkdir();\n+///     }\n+/// \n+/// * Is the given path a directory? If so, iterate on its contents\n+/// \n+///     fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n+///         if dir.is_dir() {\n+///             let contents = dir.readdir();\n+///             for entry in contents.iter() {\n+///                 if entry.is_dir() { visit_dirs(entry, cb); }\n+///                 else { cb(entry); }\n+///             }\n+///         }\n+///         else { fail!(\"nope\"); }\n+///     }\n trait DirectoryInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) is pointing at a directory in the underlying FS.\n     /// Will return false for paths to non-existent locations or if the item is\n     /// not a directory (eg files, named pipes, links, etc)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Will not raise a condition\n     fn is_dir(&self) -> bool {\n         match ignore_io_error(|| self.stat()) {\n             Some(s) => s.is_dir,"}]}