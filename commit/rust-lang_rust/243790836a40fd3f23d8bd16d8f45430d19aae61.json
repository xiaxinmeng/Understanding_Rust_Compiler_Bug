{"sha": "243790836a40fd3f23d8bd16d8f45430d19aae61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0Mzc5MDgzNmE0MGZkM2YyM2Q4YmQxNmQ4ZjQ1NDMwZDE5YWFlNjE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-29T23:31:30Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-01T02:51:29Z"}, "message": "rt: Rename rust_task_thread to rust_sched_loop\n\nThis class no longer represents a thread; it just schedules tasks.", "tree": {"sha": "972cd3efcba28932a840aa9af3d244232a1e9711", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/972cd3efcba28932a840aa9af3d244232a1e9711"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/243790836a40fd3f23d8bd16d8f45430d19aae61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/243790836a40fd3f23d8bd16d8f45430d19aae61", "html_url": "https://github.com/rust-lang/rust/commit/243790836a40fd3f23d8bd16d8f45430d19aae61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/243790836a40fd3f23d8bd16d8f45430d19aae61/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bf8d19712e2310ab6a7da2e82b2287278a772e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf8d19712e2310ab6a7da2e82b2287278a772e4", "html_url": "https://github.com/rust-lang/rust/commit/6bf8d19712e2310ab6a7da2e82b2287278a772e4"}], "stats": {"total": 380, "additions": 190, "deletions": 190}, "files": [{"sha": "0716dea800fe34210885b9c9d5fe3e6601fa68f9", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -50,7 +50,7 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_builtin.cpp \\\n               rt/rust_run_program.cpp \\\n               rt/rust_env.cpp \\\n-              rt/rust_task_thread.cpp \\\n+              rt/rust_sched_loop.cpp \\\n               rt/rust_sched_launcher.cpp \\\n               rt/rust_scheduler.cpp \\\n               rt/rust_task.cpp \\"}, {"sha": "d1adf41118fdd199bd41372f17b1a21029270514", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -80,15 +80,14 @@ rust_start(uintptr_t main_fn, int argc, char **argv, void* crate_map) {\n     rust_sched_id sched_id = kernel->create_scheduler(env->num_sched_threads);\n     rust_scheduler *sched = kernel->get_scheduler_by_id(sched_id);\n     rust_task *root_task = sched->create_task(NULL, \"main\");\n-    rust_task_thread *thread = root_task->thread;\n     command_line_args *args\n         = new (kernel, \"main command line args\")\n         command_line_args(root_task, argc, argv);\n \n-    DLOG(thread, dom, \"startup: %d args in 0x%\" PRIxPTR,\n+    LOG(root_task, dom, \"startup: %d args in 0x%\" PRIxPTR,\n              args->argc, (uintptr_t)args->args);\n     for (int i = 0; i < args->argc; i++) {\n-        DLOG(thread, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n+        LOG(root_task, dom, \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n     }\n \n     root_task->start((spawn_fn)main_fn, NULL, args->args);"}, {"sha": "aa1f1ce1e6a84625666a26b2d28a719cbf9f73c6", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -1,7 +1,7 @@\n /* Native builtins. */\n \n #include \"rust_internal.h\"\n-#include \"rust_task_thread.h\"\n+#include \"rust_sched_loop.h\"\n #include \"rust_task.h\"\n #include \"rust_util.h\"\n #include \"rust_scheduler.h\"\n@@ -22,7 +22,7 @@ extern char **environ;\n \n extern \"C\" CDECL rust_str*\n last_os_error() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     LOG(task, task, \"last_os_error()\");\n \n@@ -65,7 +65,7 @@ last_os_error() {\n \n extern \"C\" CDECL rust_str *\n rust_getcwd() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, task, \"rust_getcwd()\");\n \n     char cbuf[BUF_BYTES];\n@@ -85,7 +85,7 @@ rust_getcwd() {\n #if defined(__WIN32__)\n extern \"C\" CDECL rust_vec *\n rust_env_pairs() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t envc = 0;\n     LPTCH ch = GetEnvironmentStringsA();\n     LPTCH c;\n@@ -111,7 +111,7 @@ rust_env_pairs() {\n #else\n extern \"C\" CDECL rust_vec *\n rust_env_pairs() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n #ifdef __APPLE__\n     char **environ = *_NSGetEnviron();\n #endif\n@@ -133,21 +133,21 @@ refcount(intptr_t *v) {\n \n extern \"C\" CDECL void\n unsupervise() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->unsupervise();\n }\n \n extern \"C\" CDECL void\n vec_reserve_shared(type_desc* ty, rust_vec** vp,\n                    size_t n_elts) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     reserve_vec_exact(task, vp, n_elts * ty->size);\n }\n \n extern \"C\" CDECL void\n str_reserve_shared(rust_vec** sp,\n                    size_t n_elts) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     reserve_vec_exact(task, sp, n_elts + 1);\n }\n \n@@ -157,7 +157,7 @@ str_reserve_shared(rust_vec** sp,\n  */\n extern \"C\" CDECL rust_vec*\n vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t fill = ty->size * count;\n     rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n                                                     \"vec_from_buf\");\n@@ -168,7 +168,7 @@ vec_from_buf_shared(type_desc *ty, void *ptr, size_t count) {\n \n extern \"C\" CDECL void\n rust_str_push(rust_vec** sp, uint8_t byte) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t fill = (*sp)->fill;\n     reserve_vec(task, sp, fill + 1);\n     (*sp)->data[fill-1] = byte;\n@@ -178,8 +178,8 @@ rust_str_push(rust_vec** sp, uint8_t byte) {\n \n extern \"C\" CDECL void *\n rand_new() {\n-    rust_task *task = rust_task_thread::get_task();\n-    rust_task_thread *thread = task->thread;\n+    rust_task *task = rust_sched_loop::get_task();\n+    rust_sched_loop *thread = task->sched_loop;\n     randctx *rctx = (randctx *) task->malloc(sizeof(randctx), \"randctx\");\n     if (!rctx) {\n         task->fail();\n@@ -196,7 +196,7 @@ rand_next(randctx *rctx) {\n \n extern \"C\" CDECL void\n rand_free(randctx *rctx) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->free(rctx);\n }\n \n@@ -242,22 +242,22 @@ debug_abi_2(floats f) {\n static void\n debug_tydesc_helper(type_desc *t)\n {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"  size %\" PRIdPTR \", align %\" PRIdPTR\n         \", first_param 0x%\" PRIxPTR,\n         t->size, t->align, t->first_param);\n }\n \n extern \"C\" CDECL void\n debug_tydesc(type_desc *t) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_tydesc\");\n     debug_tydesc_helper(t);\n }\n \n extern \"C\" CDECL void\n debug_opaque(type_desc *t, uint8_t *front) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_opaque\");\n     debug_tydesc_helper(t);\n     // FIXME may want to actually account for alignment.  `front` may not\n@@ -277,7 +277,7 @@ struct rust_box {\n \n extern \"C\" CDECL void\n debug_box(type_desc *t, rust_box *box) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_box(0x%\" PRIxPTR \")\", box);\n     debug_tydesc_helper(t);\n     LOG(task, stdlib, \"  refcount %\" PRIdPTR,\n@@ -294,7 +294,7 @@ struct rust_tag {\n \n extern \"C\" CDECL void\n debug_tag(type_desc *t, rust_tag *tag) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     LOG(task, stdlib, \"debug_tag\");\n     debug_tydesc_helper(t);\n@@ -312,7 +312,7 @@ struct rust_fn {\n \n extern \"C\" CDECL void\n debug_fn(type_desc *t, rust_fn *fn) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_fn\");\n     debug_tydesc_helper(t);\n     LOG(task, stdlib, \"  thunk at 0x%\" PRIxPTR, fn->thunk);\n@@ -326,7 +326,7 @@ extern \"C\" CDECL void *\n debug_ptrcast(type_desc *from_ty,\n               type_desc *to_ty,\n               void *ptr) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, stdlib, \"debug_ptrcast from\");\n     debug_tydesc_helper(from_ty);\n     LOG(task, stdlib, \"to\");\n@@ -336,13 +336,13 @@ debug_ptrcast(type_desc *from_ty,\n \n extern \"C\" CDECL void *\n debug_get_stk_seg() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->stk;\n }\n \n extern \"C\" CDECL rust_vec*\n rust_list_files(rust_str *path) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     array_list<rust_str*> strings;\n #if defined(__WIN32__)\n     WIN32_FIND_DATA FindFileData;\n@@ -443,21 +443,21 @@ precise_time_ns(uint64_t *ns) {\n \n extern \"C\" CDECL rust_sched_id\n rust_get_sched_id() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->sched->get_id();\n }\n \n extern \"C\" CDECL rust_sched_id\n rust_new_sched(uintptr_t threads) {\n-    rust_task *task = rust_task_thread::get_task();\n-    A(task->thread, threads > 0,\n+    rust_task *task = rust_sched_loop::get_task();\n+    A(task->sched_loop, threads > 0,\n       \"Can't create a scheduler with no threads, silly!\");\n     return task->kernel->create_scheduler(threads);\n }\n \n extern \"C\" CDECL rust_task_id\n get_task_id() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->id;\n }\n \n@@ -468,13 +468,13 @@ new_task_common(rust_scheduler *sched, rust_task *parent) {\n \n extern \"C\" CDECL rust_task*\n new_task() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return new_task_common(task->sched, task);\n }\n \n extern \"C\" CDECL rust_task*\n rust_new_task_in_sched(rust_sched_id id) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     rust_scheduler *sched = task->kernel->get_scheduler_by_id(id);\n     // FIXME: What if we didn't get the scheduler?\n     return new_task_common(sched, task);\n@@ -487,7 +487,7 @@ rust_task_config_notify(rust_task *target, rust_port_id *port) {\n \n extern \"C\" rust_task *\n rust_get_task() {\n-    return rust_task_thread::get_task();\n+    return rust_sched_loop::get_task();\n }\n \n extern \"C\" CDECL void\n@@ -497,13 +497,13 @@ start_task(rust_task *target, fn_env_pair *f) {\n \n extern \"C\" CDECL int\n sched_threads() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     return task->sched->number_of_threads();\n }\n \n extern \"C\" CDECL rust_port*\n new_port(size_t unit_sz) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, comm, \"new_port(task=0x%\" PRIxPTR \" (%s), unit_sz=%d)\",\n         (uintptr_t) task, task->name, unit_sz);\n     // port starts with refcount == 1\n@@ -512,7 +512,7 @@ new_port(size_t unit_sz) {\n \n extern \"C\" CDECL void\n rust_port_begin_detach(rust_port *port, uintptr_t *yield) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, comm, \"rust_port_detach(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     port->begin_detach(yield);\n }\n@@ -524,7 +524,7 @@ rust_port_end_detach(rust_port *port) {\n \n extern \"C\" CDECL void\n del_port(rust_port *port) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG(task, comm, \"del_port(0x%\" PRIxPTR \")\", (uintptr_t) port);\n     delete port;\n }\n@@ -542,7 +542,7 @@ get_port_id(rust_port *port) {\n extern \"C\" CDECL uintptr_t\n rust_port_id_send(type_desc *t, rust_port_id target_port_id, void *sptr) {\n     bool sent = false;\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     LOG(task, comm, \"rust_port_id*_send port: 0x%\" PRIxPTR,\n         (uintptr_t) target_port_id);\n@@ -573,14 +573,14 @@ port_recv(uintptr_t *dptr, rust_port *port, uintptr_t *yield) {\n extern \"C\" CDECL void\n rust_port_select(rust_port **dptr, rust_port **ports,\n                  size_t n_ports, uintptr_t *yield) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     rust_port_selector *selector = task->get_port_selector();\n     selector->select(task, dptr, ports, n_ports, yield);\n }\n \n extern \"C\" CDECL void\n rust_set_exit_status(intptr_t code) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->kernel->set_exit_status((int)code);\n }\n \n@@ -595,7 +595,7 @@ extern void log_console_off(rust_env *env);\n \n extern \"C\" CDECL void\n rust_log_console_off() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     log_console_off(task->kernel->env);\n }\n \n@@ -606,36 +606,36 @@ rust_dbg_lock_create() {\n \n extern \"C\" CDECL void\n rust_dbg_lock_destroy(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     delete lock;\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_lock(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->lock();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_unlock(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->unlock();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_wait(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->wait();\n }\n \n extern \"C\" CDECL void\n rust_dbg_lock_signal(lock_and_signal *lock) {\n-    rust_task *task = rust_task_thread::get_task();\n-    I(task->thread, lock);\n+    rust_task *task = rust_sched_loop::get_task();\n+    I(task->sched_loop, lock);\n     lock->signal();\n }\n "}, {"sha": "0b9102b8ff79a9616f7c2eacec8d46b042181f43", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -10,7 +10,7 @@\n #include \"sync/lock_and_signal.h\"\n #include \"sync/lock_free_queue.h\"\n \n-struct rust_task_thread;\n+struct rust_sched_loop;\n struct rust_task;\n class rust_log;\n class rust_port;\n@@ -110,7 +110,7 @@ struct rust_cond { };\n #include \"rust_srv.h\"\n #include \"rust_log.h\"\n #include \"rust_kernel.h\"\n-#include \"rust_task_thread.h\"\n+#include \"rust_sched_loop.h\"\n \n typedef void CDECL (glue_fn)(void *, void *,\n                              const type_desc **, void *);"}, {"sha": "ce40eaa3a475e6730794479b520df3b9f9fd8930", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -40,9 +40,9 @@ log_console_off(rust_env *env) {\n     }\n }\n \n-rust_log::rust_log(rust_srv *srv, rust_task_thread *thread) :\n+rust_log::rust_log(rust_srv *srv, rust_sched_loop *sched_loop) :\n     _srv(srv),\n-    _thread(thread) {\n+    _sched_loop(sched_loop) {\n }\n \n rust_log::~rust_log() {\n@@ -122,12 +122,12 @@ rust_log::trace_ln(rust_task *task, uint32_t level, char *message) {\n #endif\n \n     char prefix[BUF_BYTES] = \"\";\n-    if (_thread && _thread->name) {\n+    if (_sched_loop && _sched_loop-.name) {\n         append_string(prefix, \"%04\" PRIxPTR \":%.10s:\",\n-                      thread_id, _thread->name);\n+                      thread_id, _sched_loop->name);\n     } else {\n         append_string(prefix, \"%04\" PRIxPTR \":0x%08\" PRIxPTR \":\",\n-                      thread_id, (uintptr_t) _thread);\n+                      thread_id, (uintptr_t) _sched_loop);\n     }\n     if (task) {\n         if (task->name) {"}, {"sha": "77449a516d0fcff2083f1e72190e73e332b019ca", "filename": "src/rt/rust_log.h", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -8,18 +8,18 @@ const uint32_t log_info = 2;\n const uint32_t log_debug = 3;\n \n #define LOG(task, field, ...)                                   \\\n-    DLOG_LVL(log_debug, task, task->thread, field, __VA_ARGS__)\n+    DLOG_LVL(log_debug, task, task->sched_loop, field, __VA_ARGS__)\n #define LOG_ERR(task, field, ...)                               \\\n-    DLOG_LVL(log_err, task, task->thread, field, __VA_ARGS__)\n-#define DLOG(thread, field, ...)                                   \\\n-    DLOG_LVL(log_debug, NULL, thread, field, __VA_ARGS__)\n-#define DLOG_ERR(thread, field, ...)                               \\\n-    DLOG_LVL(log_err, NULL, thread, field, __VA_ARGS__)\n-#define LOGPTR(thread, msg, ptrval)                                \\\n-    DLOG_LVL(log_debug, NULL, thread, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n-#define DLOG_LVL(lvl, task, thread, field, ...)                    \\\n+    DLOG_LVL(log_err, task, task->sched_loop, field, __VA_ARGS__)\n+#define DLOG(sched_loop, field, ...)                                   \\\n+    DLOG_LVL(log_debug, NULL, sched_loop, field, __VA_ARGS__)\n+#define DLOG_ERR(sched_loop, field, ...)                               \\\n+    DLOG_LVL(log_err, NULL, sched_loop, field, __VA_ARGS__)\n+#define LOGPTR(sched_loop, msg, ptrval)                                \\\n+    DLOG_LVL(log_debug, NULL, sched_loop, mem, \"%s 0x%\" PRIxPTR, msg, ptrval)\n+#define DLOG_LVL(lvl, task, sched_loop, field, ...)                    \\\n     do {                                                        \\\n-        rust_task_thread* _d_ = thread;                            \\\n+        rust_sched_loop* _d_ = sched_loop;                      \\\n         if (log_rt_##field >= lvl && _d_->log_lvl >= lvl) {     \\\n             _d_->log(task, lvl, __VA_ARGS__);                   \\\n         }                                                       \\\n@@ -34,13 +34,13 @@ const uint32_t log_debug = 3;\n         }                                                     \\\n     } while (0)\n \n-struct rust_task_thread;\n+struct rust_sched_loop;\n struct rust_task;\n \n class rust_log {\n \n public:\n-    rust_log(rust_srv *srv, rust_task_thread *thread);\n+    rust_log(rust_srv *srv, rust_sched_loop *sched_loop);\n     virtual ~rust_log();\n \n     void trace_ln(rust_task *task, uint32_t level, char *message);\n@@ -49,7 +49,7 @@ class rust_log {\n \n private:\n     rust_srv *_srv;\n-    rust_task_thread *_thread;\n+    rust_sched_loop *_sched_loop;\n     bool _use_labels;\n     void trace_ln(rust_task *task, char *message);\n };"}, {"sha": "81913d90f3cfd0c11ab89b0cc750ba183e82d5f2", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -51,7 +51,7 @@ void rust_port::end_detach() {\n     // Just take the lock to make sure that the thread that signaled\n     // the detach_cond isn't still holding it\n     scoped_lock with(ref_lock);\n-    I(task->thread, ref_count == 0);\n+    I(task->sched_loop, ref_count == 0);\n }\n \n void rust_port::send(void *sptr) {"}, {"sha": "042201cace5c13756b0a3f7a7abc97f6cfb5571c", "filename": "src/rt/rust_port_selector.cpp", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_port_selector.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_port_selector.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port_selector.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -10,12 +10,12 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n                            rust_port **ports,\n                            size_t n_ports, uintptr_t *yield) {\n \n-    I(task->thread, this->ports == NULL);\n-    I(task->thread, this->n_ports == 0);\n-    I(task->thread, dptr != NULL);\n-    I(task->thread, ports != NULL);\n-    I(task->thread, n_ports != 0);\n-    I(task->thread, yield != NULL);\n+    I(task->sched_loop, this->ports == NULL);\n+    I(task->sched_loop, this->n_ports == 0);\n+    I(task->sched_loop, dptr != NULL);\n+    I(task->sched_loop, ports != NULL);\n+    I(task->sched_loop, n_ports != 0);\n+    I(task->sched_loop, yield != NULL);\n \n     *yield = false;\n     size_t locks_taken = 0;\n@@ -27,11 +27,11 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n     // message.\n \n     // Start looking for ports from a different index each time.\n-    size_t j = isaac_rand(&task->thread->rctx);\n+    size_t j = isaac_rand(&task->sched_loop->rctx);\n     for (size_t i = 0; i < n_ports; i++) {\n         size_t k = (i + j) % n_ports;\n         rust_port *port = ports[k];\n-        I(task->thread, port != NULL);\n+        I(task->sched_loop, port != NULL);\n \n         port->lock.lock();\n         locks_taken++;\n@@ -46,7 +46,7 @@ rust_port_selector::select(rust_task *task, rust_port **dptr,\n     if (!found_msg) {\n         this->ports = ports;\n         this->n_ports = n_ports;\n-        I(task->thread, task->rendezvous_ptr == NULL);\n+        I(task->sched_loop, task->rendezvous_ptr == NULL);\n         task->rendezvous_ptr = (uintptr_t*)dptr;\n         task->block(this, \"waiting for select rendezvous\");\n "}, {"sha": "08a5ff47f3f609a9fc903762742f8fa046de16f4", "filename": "src/rt/rust_sched_launcher.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_launcher.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_launcher.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -7,10 +7,10 @@ rust_sched_launcher::rust_sched_launcher(rust_scheduler *sched,\n                                          rust_srv *srv, int id)\n     : rust_thread(SCHED_STACK_SIZE),\n       kernel(sched->kernel),\n-      thread(sched, srv, id) {\n+      sched_loop(sched, srv, id) {\n }\n \n void\n rust_sched_launcher::run() {\n-    thread.start_main_loop();\n+    sched_loop.start_main_loop();\n }"}, {"sha": "38d46042bcf0d544387fa6e5e3076b09ec60e5c0", "filename": "src/rt/rust_sched_launcher.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_launcher.h", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_launcher.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_launcher.h?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -17,13 +17,13 @@ class rust_sched_launcher\n     rust_kernel *kernel;\n \n private:\n-    rust_task_thread thread;\n+    rust_sched_loop sched_loop;\n \n public:\n     rust_sched_launcher(rust_scheduler *sched, rust_srv *srv, int id);\n \n     virtual void run();\n-    rust_task_thread *get_loop() { return &thread; }\n+    rust_sched_loop *get_loop() { return &sched_loop; }\n };\n \n #endif // RUST_SCHED_LAUNCHER_H"}, {"sha": "efc1883ecae3e2f35525e1fcd7d1873a09746438", "filename": "src/rt/rust_sched_loop.cpp", "status": "renamed", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_loop.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_loop.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -8,16 +8,16 @@\n #include \"rust_scheduler.h\"\n \n #ifndef _WIN32\n-pthread_key_t rust_task_thread::task_key;\n+pthread_key_t rust_sched_loop::task_key;\n #else\n-DWORD rust_task_thread::task_key;\n+DWORD rust_sched_loop::task_key;\n #endif\n \n const size_t C_STACK_SIZE = 1024*1024;\n \n-bool rust_task_thread::tls_initialized = false;\n+bool rust_sched_loop::tls_initialized = false;\n \n-rust_task_thread::rust_task_thread(rust_scheduler *sched,\n+rust_sched_loop::rust_sched_loop(rust_scheduler *sched,\n                                    rust_srv *srv,\n                                    int id) :\n     _log(srv, this),\n@@ -42,7 +42,7 @@ rust_task_thread::rust_task_thread(rust_scheduler *sched,\n }\n \n void\n-rust_task_thread::activate(rust_task *task) {\n+rust_sched_loop::activate(rust_task *task) {\n     task->ctx.next = &c_context;\n     DLOG(this, task, \"descheduling...\");\n     lock.unlock();\n@@ -55,7 +55,7 @@ rust_task_thread::activate(rust_task *task) {\n }\n \n void\n-rust_task_thread::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n+rust_sched_loop::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n     char buf[BUF_BYTES];\n     va_list args;\n     va_start(args, fmt);\n@@ -65,14 +65,14 @@ rust_task_thread::log(rust_task* task, uint32_t level, char const *fmt, ...) {\n }\n \n void\n-rust_task_thread::fail() {\n+rust_sched_loop::fail() {\n     log(NULL, log_err, \"domain %s @0x%\" PRIxPTR \" root task failed\",\n         name, this);\n     kernel->fail();\n }\n \n void\n-rust_task_thread::kill_all_tasks() {\n+rust_sched_loop::kill_all_tasks() {\n     std::vector<rust_task*> all_tasks;\n \n     {\n@@ -98,15 +98,15 @@ rust_task_thread::kill_all_tasks() {\n }\n \n size_t\n-rust_task_thread::number_of_live_tasks() {\n+rust_sched_loop::number_of_live_tasks() {\n     return running_tasks.length() + blocked_tasks.length();\n }\n \n /**\n  * Delete any dead tasks.\n  */\n void\n-rust_task_thread::reap_dead_tasks() {\n+rust_sched_loop::reap_dead_tasks() {\n     if (dead_task == NULL) {\n         return;\n     }\n@@ -124,7 +124,7 @@ rust_task_thread::reap_dead_tasks() {\n }\n \n void\n-rust_task_thread::release_task(rust_task *task) {\n+rust_sched_loop::release_task(rust_task *task) {\n     // Nobody should have a ref to the task at this point\n     I(this, task->get_ref_count() == 0);\n     // Now delete the task, which will require using this thread's\n@@ -143,7 +143,7 @@ rust_task_thread::release_task(rust_task *task) {\n  * Returns NULL if no tasks can be scheduled.\n  */\n rust_task *\n-rust_task_thread::schedule_task() {\n+rust_sched_loop::schedule_task() {\n     I(this, this);\n     // FIXME: in the face of failing tasks, this is not always right.\n     // I(this, n_live_tasks() > 0);\n@@ -159,7 +159,7 @@ rust_task_thread::schedule_task() {\n }\n \n void\n-rust_task_thread::log_state() {\n+rust_sched_loop::log_state() {\n     if (log_rt_task < log_debug) return;\n \n     if (!running_tasks.is_empty()) {\n@@ -190,7 +190,7 @@ rust_task_thread::log_state() {\n  * drop to zero.\n  */\n void\n-rust_task_thread::start_main_loop() {\n+rust_sched_loop::start_main_loop() {\n     lock.lock();\n \n     DLOG(this, dom, \"started domain loop %d\", id);\n@@ -259,7 +259,7 @@ rust_task_thread::start_main_loop() {\n }\n \n rust_task *\n-rust_task_thread::create_task(rust_task *spawner, const char *name) {\n+rust_sched_loop::create_task(rust_task *spawner, const char *name) {\n     rust_task *task =\n         new (this->kernel, \"rust_task\")\n         rust_task (this, task_state_newborn,\n@@ -272,7 +272,7 @@ rust_task_thread::create_task(rust_task *spawner, const char *name) {\n }\n \n rust_task_list *\n-rust_task_thread::state_list(rust_task_state state) {\n+rust_sched_loop::state_list(rust_task_state state) {\n     switch (state) {\n     case task_state_running:\n         return &running_tasks;\n@@ -284,7 +284,7 @@ rust_task_thread::state_list(rust_task_state state) {\n }\n \n const char *\n-rust_task_thread::state_name(rust_task_state state) {\n+rust_sched_loop::state_name(rust_task_state state) {\n     switch (state) {\n     case task_state_newborn:\n         return \"newborn\";\n@@ -301,7 +301,7 @@ rust_task_thread::state_name(rust_task_state state) {\n }\n \n void \n-rust_task_thread::transition(rust_task *task,\n+rust_sched_loop::transition(rust_task *task,\n                              rust_task_state src, rust_task_state dst,\n                              rust_cond *cond, const char* cond_name) {\n     scoped_lock with(lock);\n@@ -329,36 +329,36 @@ rust_task_thread::transition(rust_task *task,\n \n #ifndef _WIN32\n void\n-rust_task_thread::init_tls() {\n+rust_sched_loop::init_tls() {\n     int result = pthread_key_create(&task_key, NULL);\n     assert(!result && \"Couldn't create the TLS key!\");\n     tls_initialized = true;\n }\n \n void\n-rust_task_thread::place_task_in_tls(rust_task *task) {\n+rust_sched_loop::place_task_in_tls(rust_task *task) {\n     int result = pthread_setspecific(task_key, task);\n     assert(!result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n #else\n void\n-rust_task_thread::init_tls() {\n+rust_sched_loop::init_tls() {\n     task_key = TlsAlloc();\n     assert(task_key != TLS_OUT_OF_INDEXES && \"Couldn't create the TLS key!\");\n     tls_initialized = true;\n }\n \n void\n-rust_task_thread::place_task_in_tls(rust_task *task) {\n+rust_sched_loop::place_task_in_tls(rust_task *task) {\n     BOOL result = TlsSetValue(task_key, task);\n     assert(result && \"Couldn't place the task in TLS!\");\n     task->record_stack_limit();\n }\n #endif\n \n void\n-rust_task_thread::exit() {\n+rust_sched_loop::exit() {\n     scoped_lock with(lock);\n     should_exit = true;\n     lock.signal();\n@@ -369,15 +369,15 @@ rust_task_thread::exit() {\n // stack), because once we're on the Rust stack we won't have enough\n // room to do the allocation\n void\n-rust_task_thread::prepare_c_stack(rust_task *task) {\n+rust_sched_loop::prepare_c_stack(rust_task *task) {\n     I(this, !extra_c_stack);\n     if (!cached_c_stack && !task->have_c_stack()) {\n         cached_c_stack = create_stack(kernel->region(), C_STACK_SIZE);\n     }\n }\n \n void\n-rust_task_thread::unprepare_c_stack() {\n+rust_sched_loop::unprepare_c_stack() {\n     if (extra_c_stack) {\n         destroy_stack(kernel->region(), extra_c_stack);\n         extra_c_stack = NULL;", "previous_filename": "src/rt/rust_task_thread.cpp"}, {"sha": "0b221e3c6f40eb8d1e2ff4964a98f1663e45feb7", "filename": "src/rt/rust_sched_loop.h", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_loop.h", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_sched_loop.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_sched_loop.h?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -1,5 +1,5 @@\n-#ifndef RUST_TASK_THREAD_H\n-#define RUST_TASK_THREAD_H\n+#ifndef RUST_SCHED_LOOP_H\n+#define RUST_SCHED_LOOP_H\n \n #include \"rust_internal.h\"\n #include \"rust_stack.h\"\n@@ -14,7 +14,7 @@ enum rust_task_state {\n \n typedef indexed_list<rust_task> rust_task_list;\n \n-struct rust_task_thread\n+struct rust_sched_loop\n {\n private:\n \n@@ -73,7 +73,7 @@ struct rust_task_thread\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_task_thread(rust_scheduler *sched, rust_srv *srv, int id);\n+    rust_sched_loop(rust_scheduler *sched, rust_srv *srv, int id);\n     void activate(rust_task *task);\n     void log(rust_task *task, uint32_t level, char const *fmt, ...);\n     rust_log & get_log();\n@@ -113,7 +113,7 @@ struct rust_task_thread\n };\n \n inline rust_log &\n-rust_task_thread::get_log() {\n+rust_sched_loop::get_log() {\n     return _log;\n }\n \n@@ -122,7 +122,7 @@ rust_task_thread::get_log() {\n #ifndef __WIN32__\n \n inline rust_task *\n-rust_task_thread::get_task() {\n+rust_sched_loop::get_task() {\n     if (!tls_initialized)\n         return NULL;\n     rust_task *task = reinterpret_cast<rust_task *>\n@@ -134,7 +134,7 @@ rust_task_thread::get_task() {\n #else\n \n inline rust_task *\n-rust_task_thread::get_task() {\n+rust_sched_loop::get_task() {\n     if (!tls_initialized)\n         return NULL;\n     rust_task *task = reinterpret_cast<rust_task *>(TlsGetValue(task_key));\n@@ -146,7 +146,7 @@ rust_task_thread::get_task() {\n \n // NB: Runs on the Rust stack\n inline stk_seg *\n-rust_task_thread::borrow_c_stack() {\n+rust_sched_loop::borrow_c_stack() {\n     I(this, cached_c_stack);\n     stk_seg *your_stack;\n     if (extra_c_stack) {\n@@ -161,7 +161,7 @@ rust_task_thread::borrow_c_stack() {\n \n // NB: Runs on the Rust stack\n inline void\n-rust_task_thread::return_c_stack(stk_seg *stack) {\n+rust_sched_loop::return_c_stack(stk_seg *stack) {\n     I(this, !extra_c_stack);\n     if (!cached_c_stack) {\n         cached_c_stack = stack;\n@@ -182,4 +182,4 @@ rust_task_thread::return_c_stack(stk_seg *stack) {\n // End:\n //\n \n-#endif /* RUST_TASK_THREAD_H */\n+#endif /* RUST_SCHED_LOOP_H */", "previous_filename": "src/rt/rust_task_thread.h"}, {"sha": "78434bae8bc54839d2c1a619bf44936d0bb610d6", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -550,7 +550,7 @@ extern \"C\" void\n shape_cmp_type(int8_t *result, const type_desc *tydesc,\n \t       const type_desc **subtydescs, uint8_t *data_0,\n \t       uint8_t *data_1, uint8_t cmp_type) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     shape::arena arena;\n \n     // FIXME: This may well be broken when comparing two closures or objects\n@@ -571,7 +571,7 @@ shape_cmp_type(int8_t *result, const type_desc *tydesc,\n \n extern \"C\" rust_str *\n shape_log_str(const type_desc *tydesc, uint8_t *data) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     shape::arena arena;\n     shape::type_param *params =\n@@ -589,7 +589,7 @@ shape_log_str(const type_desc *tydesc, uint8_t *data) {\n \n extern \"C\" void\n shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     shape::arena arena;\n     shape::type_param *params =\n@@ -601,6 +601,6 @@ shape_log_type(const type_desc *tydesc, uint8_t *data, uint32_t level) {\n \n     log.walk();\n \n-    task->thread->log(task, level, \"%s\", ss.str().c_str());\n+    task->sched_loop->log(task, level, \"%s\", ss.str().c_str());\n }\n "}, {"sha": "d276b5c904bfffd5f9f048a524f105f5657182a3", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 36, "deletions": 35, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -13,21 +13,21 @@\n #include \"rust_upcall.h\"\n \n // Tasks\n-rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n+rust_task::rust_task(rust_sched_loop *sched_loop, rust_task_state state,\n                      rust_task *spawner, const char *name,\n                      size_t init_stack_sz) :\n     ref_count(1),\n     id(0),\n     notify_enabled(false),\n     stk(NULL),\n     runtime_sp(0),\n-    sched(thread->sched),\n-    thread(thread),\n-    kernel(thread->kernel),\n+    sched(sched_loop->sched),\n+    sched_loop(sched_loop),\n+    kernel(sched_loop->kernel),\n     name(name),\n     list_index(-1),\n     rendezvous_ptr(0),\n-    local_region(&thread->srv->local_region),\n+    local_region(&sched_loop->srv->local_region),\n     boxed(&local_region),\n     unwinding(false),\n     propagate_failure(true),\n@@ -43,8 +43,9 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n     next_rust_sp(0),\n     supervisor(spawner)\n {\n-    LOGPTR(thread, \"new task\", (uintptr_t)this);\n-    DLOG(thread, task, \"sizeof(task) = %d (0x%x)\", sizeof *this, sizeof *this);\n+    LOGPTR(sched_loop, \"new task\", (uintptr_t)this);\n+    DLOG(sched_loop, task, \"sizeof(task) = %d (0x%x)\",\n+         sizeof *this, sizeof *this);\n \n     new_stack(init_stack_sz);\n     if (supervisor) {\n@@ -56,7 +57,7 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_state state,\n void\n rust_task::delete_this()\n {\n-    DLOG(thread, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n+    DLOG(sched_loop, task, \"~rust_task %s @0x%\" PRIxPTR \", refcnt=%d\",\n          name, (uintptr_t)this, ref_count);\n \n     // FIXME: We should do this when the task exits, not in the destructor\n@@ -69,10 +70,10 @@ rust_task::delete_this()\n \n     /* FIXME: tighten this up, there are some more\n        assertions that hold at task-lifecycle events. */\n-    I(thread, ref_count == 0); // ||\n+    I(sched_loop, ref_count == 0); // ||\n     //   (ref_count == 1 && this == sched->root_task));\n \n-    thread->release_task(this);\n+    sched_loop->release_task(this);\n }\n \n struct spawn_args {\n@@ -124,7 +125,7 @@ cleanup_task(cleanup_args *args) {\n #ifndef __WIN32__\n         task->conclude_failure();\n #else\n-        A(task->thread, false, \"Shouldn't happen\");\n+        A(task->sched_loop, false, \"Shouldn't happen\");\n #endif\n     }\n }\n@@ -140,7 +141,7 @@ void task_start_wrapper(spawn_args *a)\n         // must have void return type, we can safely pass 0.\n         a->f(0, a->envptr, a->argptr);\n     } catch (rust_task *ex) {\n-        A(task->thread, ex == task,\n+        A(task->sched_loop, ex == task,\n           \"Expected this task to be thrown for unwinding\");\n         threw_exception = true;\n \n@@ -154,7 +155,7 @@ void task_start_wrapper(spawn_args *a)\n     }\n \n     // We should have returned any C stack by now\n-    I(task->thread, task->c_stack == NULL);\n+    I(task->sched_loop, task->c_stack == NULL);\n \n     rust_opaque_box* env = a->envptr;\n     if(env) {\n@@ -180,7 +181,7 @@ rust_task::start(spawn_fn spawnee_fn,\n         \" with env 0x%\" PRIxPTR \" and arg 0x%\" PRIxPTR,\n         spawnee_fn, envptr, argptr);\n \n-    I(thread, stk->data != NULL);\n+    I(sched_loop, stk->data != NULL);\n \n     char *sp = (char *)stk->end;\n \n@@ -218,7 +219,7 @@ rust_task::must_fail_from_being_killed_unlocked() {\n void\n rust_task::yield(bool *killed) {\n     if (must_fail_from_being_killed()) {\n-        I(thread, !blocked());\n+        I(sched_loop, !blocked());\n         *killed = true;\n     }\n \n@@ -262,7 +263,7 @@ bool rust_task_is_unwinding(rust_task *rt) {\n void\n rust_task::fail() {\n     // See note in ::kill() regarding who should call this.\n-    DLOG(thread, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n+    DLOG(sched_loop, task, \"task %s @0x%\" PRIxPTR \" failing\", name, this);\n     backtrace();\n     unwinding = true;\n #ifndef __WIN32__\n@@ -271,7 +272,7 @@ rust_task::fail() {\n     die();\n     conclude_failure();\n     // FIXME: Need unwinding on windows. This will end up aborting\n-    thread->fail();\n+    sched_loop->fail();\n #endif\n }\n \n@@ -284,22 +285,22 @@ void\n rust_task::fail_parent() {\n     scoped_lock with(supervisor_lock);\n     if (supervisor) {\n-        DLOG(thread, task,\n+        DLOG(sched_loop, task,\n              \"task %s @0x%\" PRIxPTR\n              \" propagating failure to supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n         supervisor->kill();\n     }\n     if (NULL == supervisor && propagate_failure)\n-        thread->fail();\n+        sched_loop->fail();\n }\n \n void\n rust_task::unsupervise()\n {\n     scoped_lock with(supervisor_lock);\n     if (supervisor) {\n-        DLOG(thread, task,\n+        DLOG(sched_loop, task,\n              \"task %s @0x%\" PRIxPTR\n              \" disconnecting from supervisor %s @0x%\" PRIxPTR,\n              name, this, supervisor->name, supervisor);\n@@ -364,7 +365,7 @@ rust_task::free(void *p)\n void\n rust_task::transition(rust_task_state src, rust_task_state dst,\n                       rust_cond *cond, const char* cond_name) {\n-    thread->transition(this, src, dst, cond, cond_name);\n+    sched_loop->transition(this, src, dst, cond, cond_name);\n }\n \n void\n@@ -387,8 +388,8 @@ rust_task::block(rust_cond *on, const char* name) {\n \n     LOG(this, task, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n-    A(thread, cond == NULL, \"Cannot block an already blocked task.\");\n-    A(thread, on != NULL, \"Cannot block on a NULL object.\");\n+    A(sched_loop, cond == NULL, \"Cannot block an already blocked task.\");\n+    A(sched_loop, on != NULL, \"Cannot block on a NULL object.\");\n \n     transition(task_state_running, task_state_blocked, on, name);\n \n@@ -397,10 +398,10 @@ rust_task::block(rust_cond *on, const char* name) {\n \n void\n rust_task::wakeup(rust_cond *from) {\n-    A(thread, cond != NULL, \"Cannot wake up unblocked task.\");\n+    A(sched_loop, cond != NULL, \"Cannot wake up unblocked task.\");\n     LOG(this, task, \"Blocked on 0x%\" PRIxPTR \" woken up on 0x%\" PRIxPTR,\n                         (uintptr_t) cond, (uintptr_t) from);\n-    A(thread, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n+    A(sched_loop, cond == from, \"Cannot wake up blocked task on wrong condition.\");\n \n     transition(task_state_blocked, task_state_running, NULL, \"none\");\n }\n@@ -459,13 +460,13 @@ rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n     sz = std::max(sz, next);\n \n     LOG(this, mem, \"next stack size: %\" PRIdPTR, sz);\n-    I(thread, requested <= sz);\n+    I(sched_loop, requested <= sz);\n     return sz;\n }\n \n void\n rust_task::free_stack(stk_seg *stk) {\n-    LOGPTR(thread, \"freeing stk segment\", (uintptr_t)stk);\n+    LOGPTR(sched_loop, \"freeing stk segment\", (uintptr_t)stk);\n     total_stack_sz -= user_stack_size(stk);\n     destroy_stack(&local_region, stk);\n }\n@@ -483,7 +484,7 @@ rust_task::new_stack(size_t requested_sz) {\n     }\n \n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = thread->min_stack_size;\n+    size_t min_sz = sched_loop->min_stack_size;\n \n     // Try to reuse an existing stack segment\n     while (stk != NULL && stk->next != NULL) {\n@@ -512,21 +513,21 @@ rust_task::new_stack(size_t requested_sz) {\n     size_t rust_stk_sz = get_next_stack_size(min_sz,\n                                              current_sz, requested_sz);\n \n-    if (total_stack_sz + rust_stk_sz > thread->env->max_stack_size) {\n+    if (total_stack_sz + rust_stk_sz > sched_loop->env->max_stack_size) {\n         LOG_ERR(this, task, \"task %\" PRIxPTR \" ran out of stack\", this);\n         fail();\n     }\n \n     size_t sz = rust_stk_sz + RED_ZONE_SIZE;\n     stk_seg *new_stk = create_stack(&local_region, sz);\n-    LOGPTR(thread, \"new stk\", (uintptr_t)new_stk);\n+    LOGPTR(sched_loop, \"new stk\", (uintptr_t)new_stk);\n     new_stk->task = this;\n     new_stk->next = NULL;\n     new_stk->prev = stk;\n     if (stk) {\n         stk->next = new_stk;\n     }\n-    LOGPTR(thread, \"stk end\", new_stk->end);\n+    LOGPTR(sched_loop, \"stk end\", new_stk->end);\n \n     stk = new_stk;\n     total_stack_sz += user_stack_size(new_stk);\n@@ -536,7 +537,7 @@ void\n rust_task::cleanup_after_turn() {\n     // Delete any spare stack segments that were left\n     // behind by calls to prev_stack\n-    I(thread, stk);\n+    I(sched_loop, stk);\n     while (stk->next) {\n         stk_seg *new_next = stk->next->next;\n         free_stack(stk->next);\n@@ -566,7 +567,7 @@ reset_stack_limit_on_c_stack(reset_args *args) {\n     uintptr_t sp = args->sp;\n     while (!sp_in_stk_seg(sp, task->stk)) {\n         task->stk = task->stk->prev;\n-        A(task->thread, task->stk != NULL,\n+        A(task->sched_loop, task->stk != NULL,\n           \"Failed to find the current stack\");\n     }\n     task->record_stack_limit();\n@@ -595,10 +596,10 @@ rust_task::check_stack_canary() {\n \n void\n rust_task::delete_all_stacks() {\n-    I(thread, !on_rust_stack());\n+    I(sched_loop, !on_rust_stack());\n     // Delete all the stacks. There may be more than one if the task failed\n     // and no landing pads stopped to clean up.\n-    I(thread, stk->next == NULL);\n+    I(sched_loop, stk->next == NULL);\n     while (stk != NULL) {\n         stk_seg *prev = stk->prev;\n         free_stack(stk);"}, {"sha": "7c351364ec0b57e46380ea30c84bc7533a9666fd", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -112,7 +112,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     stk_seg *stk;\n     uintptr_t runtime_sp;      // Runtime sp while task running.\n     rust_scheduler *sched;\n-    rust_task_thread *thread;\n+    rust_sched_loop *sched_loop;\n \n     // Fields known only to the runtime.\n     rust_kernel *kernel;\n@@ -191,7 +191,7 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n public:\n \n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n-    rust_task(rust_task_thread *thread,\n+    rust_task(rust_sched_loop *sched_loop,\n               rust_task_state state,\n               rust_task *spawner,\n               const char *name,\n@@ -312,7 +312,7 @@ rust_task::call_on_c_stack(void *args, void *fn_ptr) {\n     bool borrowed_a_c_stack = false;\n     uintptr_t sp;\n     if (c_stack == NULL) {\n-        c_stack = thread->borrow_c_stack();\n+        c_stack = sched_loop->borrow_c_stack();\n         next_c_sp = align_down(c_stack->end);\n         sp = next_c_sp;\n         borrowed_a_c_stack = true;\n@@ -335,8 +335,8 @@ inline void\n rust_task::call_on_rust_stack(void *args, void *fn_ptr) {\n     // Too expensive to check\n     // I(thread, !on_rust_stack());\n-    A(thread, get_sp_limit() != 0, \"Stack must be configured\");\n-    I(thread, next_rust_sp);\n+    A(sched_loop, get_sp_limit() != 0, \"Stack must be configured\");\n+    I(sched_loop, next_rust_sp);\n \n     bool had_reentered_rust_stack = reentered_rust_stack;\n     reentered_rust_stack = true;\n@@ -358,8 +358,8 @@ inline void\n rust_task::return_c_stack() {\n     // Too expensive to check\n     // I(thread, on_rust_stack());\n-    I(thread, c_stack != NULL);\n-    thread->return_c_stack(c_stack);\n+    I(sched_loop, c_stack != NULL);\n+    sched_loop->return_c_stack(c_stack);\n     c_stack = NULL;\n     next_c_sp = 0;\n }\n@@ -368,7 +368,7 @@ rust_task::return_c_stack() {\n inline void *\n rust_task::next_stack(size_t stk_sz, void *args_addr, size_t args_sz) {\n     new_stack_fast(stk_sz + args_sz);\n-    A(thread, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n+    A(sched_loop, stk->end - (uintptr_t)stk->data >= stk_sz + args_sz,\n       \"Did not receive enough stack\");\n     uint8_t *new_sp = (uint8_t*)stk->end;\n     // Push the function arguments to the new stack\n@@ -407,7 +407,7 @@ new_stack_slow(new_stack_args *args);\n inline void\n rust_task::new_stack_fast(size_t requested_sz) {\n     // The minimum stack size, in bytes, of a Rust stack, excluding red zone\n-    size_t min_sz = thread->min_stack_size;\n+    size_t min_sz = sched_loop->min_stack_size;\n \n     // Try to reuse an existing stack segment\n     if (stk != NULL && stk->next != NULL) {\n@@ -438,8 +438,8 @@ record_sp_limit(void *limit);\n \n inline void\n rust_task::record_stack_limit() {\n-    I(thread, stk);\n-    A(thread,\n+    I(sched_loop, stk);\n+    A(sched_loop,\n       (uintptr_t)stk->end - RED_ZONE_SIZE\n       - (uintptr_t)stk->data >= LIMIT_OFFSET,\n       \"Stack size must be greater than LIMIT_OFFSET\");"}, {"sha": "f22579a3659f5961c4760228ef95dd6999f8c54f", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -8,7 +8,7 @@\n \n #include \"rust_cc.h\"\n #include \"rust_internal.h\"\n-#include \"rust_task_thread.h\"\n+#include \"rust_sched_loop.h\"\n #include \"rust_unwind.h\"\n #include \"rust_upcall.h\"\n #include \"rust_util.h\"\n@@ -47,7 +47,7 @@ static void check_stack_alignment() { }\n inline void\n call_upcall_on_c_stack(void *args, void *fn_ptr) {\n     check_stack_alignment();\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->call_on_c_stack(args, fn_ptr);\n }\n \n@@ -62,7 +62,7 @@ extern \"C\" void record_sp_limit(void *limit);\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     // FIXME (1226) - The shim functions generated by rustc contain the\n     // morestack prologue, so we need to let them know they have enough\n@@ -85,7 +85,7 @@ upcall_call_shim_on_c_stack(void *args, void *fn_ptr) {\n  */\n extern \"C\" CDECL void\n upcall_call_shim_on_rust_stack(void *args, void *fn_ptr) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     // FIXME: Because of the hack in the other function that disables the\n     // stack limit when entering the C stack, here we restore the stack limit\n@@ -116,7 +116,7 @@ struct s_fail_args {\n \n extern \"C\" CDECL void\n upcall_s_fail(s_fail_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n     LOG_ERR(task, upcall, \"upcall fail '%s', %s:%\" PRIdPTR, \n             args->expr, args->file, args->line);\n@@ -142,7 +142,7 @@ struct s_malloc_args {\n \n extern \"C\" CDECL void\n upcall_s_malloc(s_malloc_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem, \"upcall malloc(0x%\" PRIxPTR \")\", args->td);\n@@ -179,11 +179,11 @@ struct s_free_args {\n \n extern \"C\" CDECL void\n upcall_s_free(s_free_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    rust_task_thread *thread = task->thread;\n-    DLOG(thread, mem,\n+    rust_sched_loop *sched_loop = task->sched_loop;\n+    DLOG(sched_loop, mem,\n              \"upcall free(0x%\" PRIxPTR \", is_gc=%\" PRIdPTR \")\",\n              (uintptr_t)args->ptr);\n \n@@ -225,7 +225,7 @@ struct s_shared_malloc_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_malloc(s_shared_malloc_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n     LOG(task, mem, \"upcall shared_malloc(%\" PRIdPTR \")\", args->nbytes);\n@@ -253,11 +253,11 @@ struct s_shared_free_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_free(s_shared_free_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n \n-    rust_task_thread *thread = task->thread;\n-    DLOG(thread, mem,\n+    rust_sched_loop *sched_loop = task->sched_loop;\n+    DLOG(sched_loop, mem,\n              \"upcall shared_free(0x%\" PRIxPTR\")\",\n              (uintptr_t)args->ptr);\n     task->kernel->free(args->ptr);\n@@ -277,7 +277,7 @@ struct s_shared_realloc_args {\n \n extern \"C\" CDECL void\n upcall_s_shared_realloc(s_shared_realloc_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n     args->retval = task->kernel->realloc(args->ptr, args->size);\n }\n@@ -298,7 +298,7 @@ struct s_vec_grow_args {\n \n extern \"C\" CDECL void\n upcall_s_vec_grow(s_vec_grow_args *args) {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     LOG_UPCALL_ENTRY(task);\n     reserve_vec(task, args->vp, args->new_sz);\n     (*args->vp)->fill = args->new_sz;\n@@ -320,7 +320,7 @@ extern \"C\" CDECL void\n upcall_s_str_concat(s_str_concat_args *args) {\n     rust_vec *lhs = args->lhs;\n     rust_vec *rhs = args->rhs;\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     size_t fill = lhs->fill + rhs->fill - 1;\n     rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n                                                   \"str_concat\");\n@@ -377,7 +377,7 @@ upcall_rust_personality(int version,\n     s_rust_personality_args args = {(_Unwind_Reason_Code)0,\n                                     version, actions, exception_class,\n                                     ue_header, context};\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n \n     // The personality function is run on the stack of the\n     // last function that threw or landed, which is going\n@@ -462,7 +462,7 @@ upcall_del_stack() {\n // needs to acquire the value of the stack pointer\n extern \"C\" CDECL void\n upcall_reset_stack_limit() {\n-    rust_task *task = rust_task_thread::get_task();\n+    rust_task *task = rust_sched_loop::get_task();\n     task->reset_stack_limit();\n }\n "}, {"sha": "f54589bdf62c69ff6d9da6af3cdc16c8e436f693", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/243790836a40fd3f23d8bd16d8f45430d19aae61/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=243790836a40fd3f23d8bd16d8f45430d19aae61", "patch": "@@ -20,13 +20,13 @@ struct handle_data {\n // helpers\n static void*\n current_kernel_malloc(size_t size, const char* tag) {\n-  void* ptr = rust_task_thread::get_task()->kernel->malloc(size, tag);\n+  void* ptr = rust_sched_loop::get_task()->kernel->malloc(size, tag);\n   return ptr;\n }\n \n static void\n current_kernel_free(void* ptr) {\n-  rust_task_thread::get_task()->kernel->free(ptr);\n+  rust_sched_loop::get_task()->kernel->free(ptr);\n }\n \n static handle_data*"}]}