{"sha": "d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NmZjZTg4ZjVhZjFhOTc4ODhlZGY5MWRmMmNiNTFmZjViZmQ2MWM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-03T16:55:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-03T16:55:15Z"}, "message": "Merge #6700\n\n6700: More macro diagnostics improvements r=jonas-schievink a=jonas-schievink\n\nThis threads macro expansion errors through `eager.rs` and the `AsMacroCall` trait, improving macro diagnostics emitted during body lowering.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "1f0351e895fa8b24ae4fa5a1854fb6c4285efcd2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f0351e895fa8b24ae4fa5a1854fb6c4285efcd2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfyRhzCRBK7hj4Ov3rIwAAdHIIAIUQWpYhvrBgEVWs9I/DNv2n\nUeKK318HCW3sg0SPD1rKRNmkcb2L8LE8eo9ITdNsiNluAXaDzeJYS1qk9JnCWTzO\naYuXGZgkJNjRxjaBJdXZJqyrATqeTXAVu5bY786vIIFYW/asmiTUaRVwfO8XuAyo\nptWySkbgNAKxYfm9yiT4usetA3n0F5Gi8AYbYSSv6zdGx0X+iZBxCNvjegTxmI1T\njFXh5YAI5pXG3WBhKbzUVZy915qB5a9pzob+kwllJn/okIuksztAhscnHEQch4gB\n526ykdtP1Vy/qRnBX0oKgk3KUes7fg3P6BfNWVBksWWMrBAjlRgVp7DMG3/JWvs=\n=nr30\n-----END PGP SIGNATURE-----\n", "payload": "tree 1f0351e895fa8b24ae4fa5a1854fb6c4285efcd2\nparent 74de29b223c2e6f01d1ed0912d72787c202bb225\nparent bca1e5fcb825c6c4e09ec197513b5568fce3d985\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1607014515 +0000\ncommitter GitHub <noreply@github.com> 1607014515 +0000\n\nMerge #6700\n\n6700: More macro diagnostics improvements r=jonas-schievink a=jonas-schievink\n\nThis threads macro expansion errors through `eager.rs` and the `AsMacroCall` trait, improving macro diagnostics emitted during body lowering.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "html_url": "https://github.com/rust-lang/rust/commit/d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74de29b223c2e6f01d1ed0912d72787c202bb225", "url": "https://api.github.com/repos/rust-lang/rust/commits/74de29b223c2e6f01d1ed0912d72787c202bb225", "html_url": "https://github.com/rust-lang/rust/commit/74de29b223c2e6f01d1ed0912d72787c202bb225"}, {"sha": "bca1e5fcb825c6c4e09ec197513b5568fce3d985", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca1e5fcb825c6c4e09ec197513b5568fce3d985", "html_url": "https://github.com/rust-lang/rust/commit/bca1e5fcb825c6c4e09ec197513b5568fce3d985"}], "stats": {"total": 290, "additions": 223, "deletions": 67}, "files": [{"sha": "92bcc17053d82d2e8c0157e4e1f246025442b565", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "patch": "@@ -120,18 +120,24 @@ impl Expander {\n             self.resolve_path_as_macro(db, &path)\n         };\n \n-        let call_id = match macro_call.as_call_id(db, self.crate_def_map.krate, resolver) {\n+        let mut err = None;\n+        let call_id =\n+            macro_call.as_call_id_with_errors(db, self.crate_def_map.krate, resolver, &mut |e| {\n+                err.get_or_insert(e);\n+            });\n+        let call_id = match call_id {\n             Some(it) => it,\n             None => {\n-                // FIXME: this can mean other things too, but `as_call_id` doesn't provide enough\n-                // info.\n-                return ExpandResult::only_err(mbe::ExpandError::Other(\n-                    \"failed to parse or resolve macro invocation\".into(),\n-                ));\n+                if err.is_none() {\n+                    eprintln!(\"no error despite `as_call_id_with_errors` returning `None`\");\n+                }\n+                return ExpandResult { value: None, err };\n             }\n         };\n \n-        let err = db.macro_expand_error(call_id);\n+        if err.is_none() {\n+            err = db.macro_expand_error(call_id);\n+        }\n \n         let file_id = call_id.as_file();\n "}, {"sha": "7e78340ee4b3ecb2e0b893b6568baff5deb105a9", "filename": "crates/hir_def/src/body/tests.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Ftests.rs?ref=d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "patch": "@@ -78,21 +78,41 @@ fn f() {\n fn macro_diag_builtin() {\n     check_diagnostics(\n         r#\"\n+#[rustc_builtin_macro]\n+macro_rules! env {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! include {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! compile_error {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    () => {}\n+}\n+\n fn f() {\n     // Test a handful of built-in (eager) macros:\n \n     include!(invalid);\n-  //^^^^^^^^^^^^^^^^^ failed to parse or resolve macro invocation\n+  //^^^^^^^^^^^^^^^^^ could not convert tokens\n     include!(\"does not exist\");\n-  //^^^^^^^^^^^^^^^^^^^^^^^^^^ failed to parse or resolve macro invocation\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^ could not convert tokens\n \n     env!(invalid);\n-  //^^^^^^^^^^^^^ failed to parse or resolve macro invocation\n+  //^^^^^^^^^^^^^ could not convert tokens\n+\n+    env!(\"OUT_DIR\");\n+  //^^^^^^^^^^^^^^^ `OUT_DIR` not set, enable \"load out dirs from check\" to fix\n+\n+    compile_error!(\"compile_error works\");\n+  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `compile_error!` called: compile_error works\n \n     // Lazy:\n \n     format_args!();\n-  //^^^^^^^^^^^^^^ failed to parse or resolve macro invocation\n+  //^^^^^^^^^^^^^^ no rule matches input tokens\n }\n         \"#,\n     );"}, {"sha": "ce2be8e2b9bf41337eab83e5b1b410add07c2464", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "patch": "@@ -465,21 +465,37 @@ pub trait AsMacroCall {\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    ) -> Option<MacroCallId> {\n+        self.as_call_id_with_errors(db, krate, resolver, &mut |_| ())\n+    }\n+\n+    fn as_call_id_with_errors(\n+        &self,\n+        db: &dyn db::DefDatabase,\n+        krate: CrateId,\n+        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId>;\n }\n \n impl AsMacroCall for InFile<&ast::MacroCall> {\n-    fn as_call_id(\n+    fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId> {\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n         let h = Hygiene::new(db.upcast(), self.file_id);\n-        let path = path::ModPath::from_src(self.value.path()?, &h)?;\n+        let path = self.value.path().and_then(|path| path::ModPath::from_src(path, &h));\n+\n+        if path.is_none() {\n+            error_sink(mbe::ExpandError::Other(\"malformed macro invocation\".into()));\n+        }\n \n-        AstIdWithPath::new(ast_id.file_id, ast_id.value, path).as_call_id(db, krate, resolver)\n+        AstIdWithPath::new(ast_id.file_id, ast_id.value, path?)\n+            .as_call_id_with_errors(db, krate, resolver, error_sink)\n     }\n }\n \n@@ -497,22 +513,32 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n }\n \n impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n-    fn as_call_id(\n+    fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId> {\n-        let def: MacroDefId = resolver(self.path.clone())?;\n+        let def: MacroDefId = resolver(self.path.clone()).or_else(|| {\n+            error_sink(mbe::ExpandError::Other(\"could not resolve macro\".into()));\n+            None\n+        })?;\n \n         if let MacroDefKind::BuiltInEager(_) = def.kind {\n             let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db.upcast()));\n             let hygiene = Hygiene::new(db.upcast(), self.ast_id.file_id);\n \n             Some(\n-                expand_eager_macro(db.upcast(), krate, macro_call, def, &|path: ast::Path| {\n-                    resolver(path::ModPath::from_src(path, &hygiene)?)\n-                })?\n+                expand_eager_macro(\n+                    db.upcast(),\n+                    krate,\n+                    macro_call,\n+                    def,\n+                    &|path: ast::Path| resolver(path::ModPath::from_src(path, &hygiene)?),\n+                    error_sink,\n+                )\n+                .ok()?\n                 .into(),\n             )\n         } else {\n@@ -522,13 +548,18 @@ impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n }\n \n impl AsMacroCall for AstIdWithPath<ast::Item> {\n-    fn as_call_id(\n+    fn as_call_id_with_errors(\n         &self,\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+        error_sink: &mut dyn FnMut(mbe::ExpandError),\n     ) -> Option<MacroCallId> {\n-        let def = resolver(self.path.clone())?;\n+        let def: MacroDefId = resolver(self.path.clone()).or_else(|| {\n+            error_sink(mbe::ExpandError::Other(\"could not resolve macro\".into()));\n+            None\n+        })?;\n+\n         Some(\n             def.as_lazy_macro(\n                 db.upcast(),"}, {"sha": "16c3c4d69c17c16d7c8a71ea09e1cf7f14519d3a", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "patch": "@@ -86,7 +86,6 @@ pub fn find_builtin_macro(\n register_builtin! {\n     LAZY:\n     (column, Column) => column_expand,\n-    (compile_error, CompileError) => compile_error_expand,\n     (file, File) => file_expand,\n     (line, Line) => line_expand,\n     (assert, Assert) => assert_expand,\n@@ -97,6 +96,7 @@ register_builtin! {\n     (format_args_nl, FormatArgsNl) => format_args_expand,\n \n     EAGER:\n+    (compile_error, CompileError) => compile_error_expand,\n     (concat, Concat) => concat_expand,\n     (include, Include) => include_expand,\n     (include_bytes, IncludeBytes) => include_bytes_expand,\n@@ -213,25 +213,6 @@ fn file_expand(\n     ExpandResult::ok(expanded)\n }\n \n-fn compile_error_expand(\n-    _db: &dyn AstDatabase,\n-    _id: LazyMacroId,\n-    tt: &tt::Subtree,\n-) -> ExpandResult<tt::Subtree> {\n-    if tt.count() == 1 {\n-        if let tt::TokenTree::Leaf(tt::Leaf::Literal(it)) = &tt.token_trees[0] {\n-            let s = it.text.as_str();\n-            if s.contains('\"') {\n-                return ExpandResult::ok(quote! { loop { #it }});\n-            }\n-        };\n-    }\n-\n-    ExpandResult::only_err(mbe::ExpandError::BindingError(\n-        \"`compile_error!` argument be a string\".into(),\n-    ))\n-}\n-\n fn format_args_expand(\n     _db: &dyn AstDatabase,\n     _id: LazyMacroId,\n@@ -280,6 +261,30 @@ fn unquote_str(lit: &tt::Literal) -> Option<String> {\n     token.value().map(|it| it.into_owned())\n }\n \n+fn compile_error_expand(\n+    _db: &dyn AstDatabase,\n+    _id: EagerMacroId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<Option<(tt::Subtree, FragmentKind)>> {\n+    let err = match &*tt.token_trees {\n+        [tt::TokenTree::Leaf(tt::Leaf::Literal(it))] => {\n+            let text = it.text.as_str();\n+            if text.starts_with('\"') && text.ends_with('\"') {\n+                // FIXME: does not handle raw strings\n+                mbe::ExpandError::Other(format!(\n+                    \"`compile_error!` called: {}\",\n+                    &text[1..text.len() - 1]\n+                ))\n+            } else {\n+                mbe::ExpandError::BindingError(\"`compile_error!` argument must be a string\".into())\n+            }\n+        }\n+        _ => mbe::ExpandError::BindingError(\"`compile_error!` argument must be a string\".into()),\n+    };\n+\n+    ExpandResult { value: Some((quote! {}, FragmentKind::Items)), err: Some(err) }\n+}\n+\n fn concat_expand(\n     _db: &dyn AstDatabase,\n     _arg_id: EagerMacroId,\n@@ -417,17 +422,25 @@ fn env_expand(\n         Err(e) => return ExpandResult::only_err(e),\n     };\n \n-    // FIXME:\n-    // If the environment variable is not defined int rustc, then a compilation error will be emitted.\n-    // We might do the same if we fully support all other stuffs.\n-    // But for now on, we should return some dummy string for better type infer purpose.\n-    // However, we cannot use an empty string here, because for\n-    // `include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"))` will become\n-    // `include!(\"foo.rs\"), which might go to infinite loop\n-    let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| \"__RA_UNIMPLEMENTED__\".to_string());\n+    let mut err = None;\n+    let s = get_env_inner(db, arg_id, &key).unwrap_or_else(|| {\n+        // The only variable rust-analyzer ever sets is `OUT_DIR`, so only diagnose that to avoid\n+        // unnecessary diagnostics for eg. `CARGO_PKG_NAME`.\n+        if key == \"OUT_DIR\" {\n+            err = Some(mbe::ExpandError::Other(\n+                r#\"`OUT_DIR` not set, enable \"load out dirs from check\" to fix\"#.into(),\n+            ));\n+        }\n+\n+        // If the variable is unset, still return a dummy string to help type inference along.\n+        // We cannot use an empty string here, because for\n+        // `include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"))` will become\n+        // `include!(\"foo.rs\"), which might go to infinite loop\n+        \"__RA_UNIMPLEMENTED__\".to_string()\n+    });\n     let expanded = quote! { #s };\n \n-    ExpandResult::ok(Some((expanded, FragmentKind::Expr)))\n+    ExpandResult { value: Some((expanded, FragmentKind::Expr)), err }\n }\n \n fn option_env_expand(\n@@ -638,7 +651,8 @@ mod tests {\n             \"#,\n         );\n \n-        assert_eq!(expanded, r#\"loop{\"error!\"}\"#);\n+        // This expands to nothing (since it's in item position), but emits an error.\n+        assert_eq!(expanded, \"\");\n     }\n \n     #[test]"}, {"sha": "842a177db3fd1a4bb5fcb759dd8f28c626770882", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "patch": "@@ -207,6 +207,7 @@ fn macro_expand_with_arg(\n             } else {\n                 return ExpandResult {\n                     value: Some(db.lookup_intern_eager_expansion(id).subtree),\n+                    // FIXME: There could be errors here!\n                     err: None,\n                 };\n             }"}, {"sha": "0229a836ec5a3f59aeb94314b192096eb651e187", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 100, "deletions": 16, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46fce88f5af1a97888edf91df2cb51ff5bfd61c/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=d46fce88f5af1a97888edf91df2cb51ff5bfd61c", "patch": "@@ -26,19 +26,89 @@ use crate::{\n };\n \n use base_db::CrateId;\n+use mbe::ExpandResult;\n use parser::FragmentKind;\n use std::sync::Arc;\n use syntax::{algo::SyntaxRewriter, SyntaxNode};\n \n+pub struct ErrorEmitted {\n+    _private: (),\n+}\n+\n+trait ErrorSink {\n+    fn emit(&mut self, err: mbe::ExpandError);\n+\n+    fn option<T>(\n+        &mut self,\n+        opt: Option<T>,\n+        error: impl FnOnce() -> mbe::ExpandError,\n+    ) -> Result<T, ErrorEmitted> {\n+        match opt {\n+            Some(it) => Ok(it),\n+            None => {\n+                self.emit(error());\n+                Err(ErrorEmitted { _private: () })\n+            }\n+        }\n+    }\n+\n+    fn option_with<T>(\n+        &mut self,\n+        opt: impl FnOnce() -> Option<T>,\n+        error: impl FnOnce() -> mbe::ExpandError,\n+    ) -> Result<T, ErrorEmitted> {\n+        self.option(opt(), error)\n+    }\n+\n+    fn result<T>(&mut self, res: Result<T, mbe::ExpandError>) -> Result<T, ErrorEmitted> {\n+        match res {\n+            Ok(it) => Ok(it),\n+            Err(e) => {\n+                self.emit(e);\n+                Err(ErrorEmitted { _private: () })\n+            }\n+        }\n+    }\n+\n+    fn expand_result_option<T>(&mut self, res: ExpandResult<Option<T>>) -> Result<T, ErrorEmitted> {\n+        match (res.value, res.err) {\n+            (None, Some(err)) => {\n+                self.emit(err);\n+                Err(ErrorEmitted { _private: () })\n+            }\n+            (Some(value), opt_err) => {\n+                if let Some(err) = opt_err {\n+                    self.emit(err);\n+                }\n+                Ok(value)\n+            }\n+            (None, None) => unreachable!(\"`ExpandResult` without value or error\"),\n+        }\n+    }\n+}\n+\n+impl ErrorSink for &'_ mut dyn FnMut(mbe::ExpandError) {\n+    fn emit(&mut self, err: mbe::ExpandError) {\n+        self(err);\n+    }\n+}\n+\n+fn err(msg: impl Into<String>) -> mbe::ExpandError {\n+    mbe::ExpandError::Other(msg.into())\n+}\n+\n pub fn expand_eager_macro(\n     db: &dyn AstDatabase,\n     krate: CrateId,\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n-) -> Option<EagerMacroId> {\n-    let args = macro_call.value.token_tree()?;\n-    let parsed_args = mbe::ast_to_token_tree(&args)?.0;\n+    mut diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n+) -> Result<EagerMacroId, ErrorEmitted> {\n+    let parsed_args = diagnostic_sink.option_with(\n+        || Some(mbe::ast_to_token_tree(&macro_call.value.token_tree()?)?.0),\n+        || err(\"malformed macro invocation\"),\n+    )?;\n \n     // Note:\n     // When `lazy_expand` is called, its *parent* file must be already exists.\n@@ -55,17 +125,22 @@ pub fn expand_eager_macro(\n     });\n     let arg_file_id: MacroCallId = arg_id.into();\n \n-    let parsed_args = mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr).ok()?.0;\n+    let parsed_args =\n+        diagnostic_sink.result(mbe::token_tree_to_syntax_node(&parsed_args, FragmentKind::Expr))?.0;\n     let result = eager_macro_recur(\n         db,\n         InFile::new(arg_file_id.as_file(), parsed_args.syntax_node()),\n         krate,\n         resolver,\n+        diagnostic_sink,\n     )?;\n-    let subtree = to_subtree(&result)?;\n+    let subtree =\n+        diagnostic_sink.option(to_subtree(&result), || err(\"failed to parse macro result\"))?;\n \n     if let MacroDefKind::BuiltInEager(eager) = def.kind {\n-        let (subtree, fragment) = eager.expand(db, arg_id, &subtree).value?;\n+        let res = eager.expand(db, arg_id, &subtree);\n+\n+        let (subtree, fragment) = diagnostic_sink.expand_result_option(res)?;\n         let eager = EagerCallLoc {\n             def,\n             fragment,\n@@ -74,9 +149,9 @@ pub fn expand_eager_macro(\n             file_id: macro_call.file_id,\n         };\n \n-        Some(db.intern_eager_expansion(eager))\n+        Ok(db.intern_eager_expansion(eager))\n     } else {\n-        None\n+        panic!(\"called `expand_eager_macro` on non-eager macro def {:?}\", def);\n     }\n }\n \n@@ -91,29 +166,34 @@ fn lazy_expand(\n     def: &MacroDefId,\n     macro_call: InFile<ast::MacroCall>,\n     krate: CrateId,\n-) -> Option<InFile<SyntaxNode>> {\n+) -> ExpandResult<Option<InFile<SyntaxNode>>> {\n     let ast_id = db.ast_id_map(macro_call.file_id).ast_id(&macro_call.value);\n \n     let id: MacroCallId =\n         def.as_lazy_macro(db, krate, MacroCallKind::FnLike(macro_call.with_value(ast_id))).into();\n \n-    db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node))\n+    let err = db.macro_expand_error(id);\n+    let value = db.parse_or_expand(id.as_file()).map(|node| InFile::new(id.as_file(), node));\n+\n+    ExpandResult { value, err }\n }\n \n fn eager_macro_recur(\n     db: &dyn AstDatabase,\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n     macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n-) -> Option<SyntaxNode> {\n+    mut diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n+) -> Result<SyntaxNode, ErrorEmitted> {\n     let original = curr.value.clone();\n \n     let children = curr.value.descendants().filter_map(ast::MacroCall::cast);\n     let mut rewriter = SyntaxRewriter::default();\n \n     // Collect replacement\n     for child in children {\n-        let def: MacroDefId = macro_resolver(child.path()?)?;\n+        let def = diagnostic_sink\n+            .option_with(|| macro_resolver(child.path()?), || err(\"failed to resolve macro\"))?;\n         let insert = match def.kind {\n             MacroDefKind::BuiltInEager(_) => {\n                 let id: MacroCallId = expand_eager_macro(\n@@ -122,23 +202,27 @@ fn eager_macro_recur(\n                     curr.with_value(child.clone()),\n                     def,\n                     macro_resolver,\n+                    diagnostic_sink,\n                 )?\n                 .into();\n-                db.parse_or_expand(id.as_file())?\n+                db.parse_or_expand(id.as_file())\n+                    .expect(\"successful macro expansion should be parseable\")\n             }\n             MacroDefKind::Declarative\n             | MacroDefKind::BuiltIn(_)\n             | MacroDefKind::BuiltInDerive(_)\n             | MacroDefKind::ProcMacro(_) => {\n-                let expanded = lazy_expand(db, &def, curr.with_value(child.clone()), krate)?;\n+                let res = lazy_expand(db, &def, curr.with_value(child.clone()), krate);\n+                let val = diagnostic_sink.expand_result_option(res)?;\n+\n                 // replace macro inside\n-                eager_macro_recur(db, expanded, krate, macro_resolver)?\n+                eager_macro_recur(db, val, krate, macro_resolver, diagnostic_sink)?\n             }\n         };\n \n         rewriter.replace(child.syntax(), &insert);\n     }\n \n     let res = rewriter.rewrite(&original);\n-    Some(res)\n+    Ok(res)\n }"}]}