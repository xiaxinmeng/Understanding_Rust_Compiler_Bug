{"sha": "5a62acaf9e456280339f37ca2e43fcb277772a18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNjJhY2FmOWU0NTYyODAzMzlmMzdjYTJlNDNmY2IyNzc3NzJhMTg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-10T05:47:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-10T05:47:49Z"}, "message": "Rollup merge of #69677 - petrochenkov:spancode, r=eddyb\n\nrustc_metadata: Give decoder access to whole crate store\n\nPre-requisite for https://github.com/rust-lang/rust/pull/68941.\nr? @eddyb", "tree": {"sha": "22feee0e66c8b5355ec3e718477c632ed6a3fbd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22feee0e66c8b5355ec3e718477c632ed6a3fbd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a62acaf9e456280339f37ca2e43fcb277772a18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZyoFCRBK7hj4Ov3rIwAAdHIIACuyN6hj+HXZUKUEXqZTRC5D\n5QgDwijBppHT/2VVPrtRIS6wQSptdcKfywdgYGft011eylPVSdZOjD5p4Sfo8dee\nvZ8AaXkXVtht8atUVzc9jsZQV4s9K6+LXd8T2B/zJET5B5CZ9mNpd58vboZPdJX8\ny21TTiKDddy87KOHzS4Pz/3ok+zyzyReK8IiNgznJv6kUsNzXd6DfJNPrS8OlbEA\n239G/WHLjV/sLqyUuEulnVSThCculbg1zaxp19Eq2y34iB/cZIJoOiLCPkFaDDmw\nr+HRQ9BIZPrx0yyVGmv4jBDXvJxB/ewdNPj4XEbi1fDP66p7oNh29T3xa/kGALQ=\n=qqgi\n-----END PGP SIGNATURE-----\n", "payload": "tree 22feee0e66c8b5355ec3e718477c632ed6a3fbd5\nparent 61150353bf9cc415f4554a9b4851c14e4255329f\nparent 41374d748b3c8bc39a78adf703d7d5560a4a8ab7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583819269 +0100\ncommitter GitHub <noreply@github.com> 1583819269 +0100\n\nRollup merge of #69677 - petrochenkov:spancode, r=eddyb\n\nrustc_metadata: Give decoder access to whole crate store\n\nPre-requisite for https://github.com/rust-lang/rust/pull/68941.\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a62acaf9e456280339f37ca2e43fcb277772a18", "html_url": "https://github.com/rust-lang/rust/commit/5a62acaf9e456280339f37ca2e43fcb277772a18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a62acaf9e456280339f37ca2e43fcb277772a18/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61150353bf9cc415f4554a9b4851c14e4255329f", "url": "https://api.github.com/repos/rust-lang/rust/commits/61150353bf9cc415f4554a9b4851c14e4255329f", "html_url": "https://github.com/rust-lang/rust/commit/61150353bf9cc415f4554a9b4851c14e4255329f"}, {"sha": "41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "url": "https://api.github.com/repos/rust-lang/rust/commits/41374d748b3c8bc39a78adf703d7d5560a4a8ab7", "html_url": "https://github.com/rust-lang/rust/commit/41374d748b3c8bc39a78adf703d7d5560a4a8ab7"}], "stats": {"total": 233, "additions": 126, "deletions": 107}, "files": [{"sha": "18b4c9ad5044ca401575d0a7e9ab3f073cd42fc8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5a62acaf9e456280339f37ca2e43fcb277772a18/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a62acaf9e456280339f37ca2e43fcb277772a18/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=5a62acaf9e456280339f37ca2e43fcb277772a18", "patch": "@@ -76,6 +76,21 @@ impl<'a> LoadError<'a> {\n     }\n }\n \n+/// A reference to `CrateMetadata` that can also give access to whole crate store when necessary.\n+#[derive(Clone, Copy)]\n+crate struct CrateMetadataRef<'a> {\n+    pub cdata: &'a CrateMetadata,\n+    pub cstore: &'a CStore,\n+}\n+\n+impl std::ops::Deref for CrateMetadataRef<'_> {\n+    type Target = CrateMetadata;\n+\n+    fn deref(&self) -> &Self::Target {\n+        self.cdata\n+    }\n+}\n+\n fn dump_crates(cstore: &CStore) {\n     info!(\"resolved crates:\");\n     cstore.iter_crate_data(|cnum, data| {\n@@ -100,10 +115,11 @@ impl CStore {\n         CrateNum::new(self.metas.len() - 1)\n     }\n \n-    crate fn get_crate_data(&self, cnum: CrateNum) -> &CrateMetadata {\n-        self.metas[cnum]\n+    crate fn get_crate_data(&self, cnum: CrateNum) -> CrateMetadataRef<'_> {\n+        let cdata = self.metas[cnum]\n             .as_ref()\n-            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum))\n+            .unwrap_or_else(|| panic!(\"Failed to get crate data for {:?}\", cnum));\n+        CrateMetadataRef { cdata, cstore: self }\n     }\n \n     fn set_crate_data(&mut self, cnum: CrateNum, data: CrateMetadata) {\n@@ -217,7 +233,7 @@ impl<'a> CrateLoader<'a> {\n             // We're also sure to compare *paths*, not actual byte slices. The\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n-            let source = self.cstore.get_crate_data(cnum).source();\n+            let source = self.cstore.get_crate_data(cnum).cdata.source();\n             if let Some(entry) = self.sess.opts.externs.get(&name.as_str()) {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 if let Some(mut files) = entry.files() {"}, {"sha": "e60ae5b6c25ee311206613cd66109745dd8f96d1", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 105, "deletions": 102, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/5a62acaf9e456280339f37ca2e43fcb277772a18/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a62acaf9e456280339f37ca2e43fcb277772a18/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=5a62acaf9e456280339f37ca2e43fcb277772a18", "patch": "@@ -1,5 +1,6 @@\n // Decoding metadata from a single crate's metadata\n \n+use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n@@ -125,7 +126,7 @@ struct ImportedSourceFile {\n \n pub(super) struct DecodeContext<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n-    cdata: Option<&'a CrateMetadata>,\n+    cdata: Option<CrateMetadataRef<'a>>,\n     sess: Option<&'tcx Session>,\n     tcx: Option<TyCtxt<'tcx>>,\n \n@@ -141,7 +142,7 @@ pub(super) struct DecodeContext<'a, 'tcx> {\n /// Abstract over the various ways one can create metadata decoders.\n pub(super) trait Metadata<'a, 'tcx>: Copy {\n     fn raw_bytes(self) -> &'a [u8];\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n         None\n     }\n     fn sess(self) -> Option<&'tcx Session> {\n@@ -162,7 +163,7 @@ pub(super) trait Metadata<'a, 'tcx>: Copy {\n             lazy_state: LazyState::NoNode,\n             alloc_decoding_session: self\n                 .cdata()\n-                .map(|cdata| cdata.alloc_decoding_state.new_decoding_session()),\n+                .map(|cdata| cdata.cdata.alloc_decoding_state.new_decoding_session()),\n         }\n     }\n }\n@@ -185,33 +186,33 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a MetadataBlob, &'tcx Session) {\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadata {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for &'a CrateMetadataRef<'a> {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.blob.raw_bytes()\n     }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self)\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n+        Some(*self)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, &'tcx Session) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, &'tcx Session) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n+        Some(*self.0)\n     }\n     fn sess(self) -> Option<&'tcx Session> {\n         Some(&self.1)\n     }\n }\n \n-impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'tcx>) {\n+impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadataRef<'a>, TyCtxt<'tcx>) {\n     fn raw_bytes(self) -> &'a [u8] {\n         self.0.raw_bytes()\n     }\n-    fn cdata(self) -> Option<&'a CrateMetadata> {\n-        Some(self.0)\n+    fn cdata(self) -> Option<CrateMetadataRef<'a>> {\n+        Some(*self.0)\n     }\n     fn tcx(self) -> Option<TyCtxt<'tcx>> {\n         Some(self.1)\n@@ -242,7 +243,7 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n-    fn cdata(&self) -> &'a CrateMetadata {\n+    fn cdata(&self) -> CrateMetadataRef<'a> {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n \n@@ -558,50 +559,7 @@ impl CrateRoot<'_> {\n     }\n }\n \n-impl<'a, 'tcx> CrateMetadata {\n-    crate fn new(\n-        sess: &Session,\n-        blob: MetadataBlob,\n-        root: CrateRoot<'static>,\n-        raw_proc_macros: Option<&'static [ProcMacro]>,\n-        cnum: CrateNum,\n-        cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n-        source: CrateSource,\n-        private_dep: bool,\n-        host_hash: Option<Svh>,\n-    ) -> CrateMetadata {\n-        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n-            root.def_path_table.decode((&blob, sess))\n-        });\n-        let trait_impls = root\n-            .impls\n-            .decode((&blob, sess))\n-            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n-            .collect();\n-        let alloc_decoding_state =\n-            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n-        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n-        CrateMetadata {\n-            blob,\n-            root,\n-            def_path_table,\n-            trait_impls,\n-            raw_proc_macros,\n-            source_map_import_info: Once::new(),\n-            alloc_decoding_state,\n-            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n-            cnum,\n-            cnum_map,\n-            dependencies,\n-            dep_kind: Lock::new(dep_kind),\n-            source,\n-            private_dep,\n-            host_hash,\n-            extern_crate: Lock::new(None),\n-        }\n-    }\n-\n+impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn is_proc_macro(&self, id: DefIndex) -> bool {\n         self.root.proc_macro_data.and_then(|data| data.decode(self).find(|x| *x == id)).is_some()\n     }\n@@ -622,10 +580,6 @@ impl<'a, 'tcx> CrateMetadata {\n         })\n     }\n \n-    fn local_def_id(&self, index: DefIndex) -> DefId {\n-        DefId { krate: self.cnum, index }\n-    }\n-\n     fn raw_proc_macro(&self, id: DefIndex) -> &ProcMacro {\n         // DefIndex's in root.proc_macro_data have a one-to-one correspondence\n         // with items in 'raw_proc_macros'.\n@@ -1191,18 +1145,6 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    // Translate a DefId from the current compilation environment to a DefId\n-    // for an external crate.\n-    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n-        for (local, &global) in self.cnum_map.iter_enumerated() {\n-            if global == did.krate {\n-                return Some(DefId { krate: local, index: did.index });\n-            }\n-        }\n-\n-        None\n-    }\n-\n     fn get_inherent_implementations_for_type(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -1409,11 +1351,6 @@ impl<'a, 'tcx> CrateMetadata {\n         DefPath::make(self.cnum, id, |parent| self.def_key(parent))\n     }\n \n-    #[inline]\n-    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.def_path_table.def_path_hash(index)\n-    }\n-\n     /// Imports the source_map from an external crate into the source_map of the crate\n     /// currently being compiled (the \"local crate\").\n     ///\n@@ -1440,10 +1377,10 @@ impl<'a, 'tcx> CrateMetadata {\n     /// Proc macro crates don't currently export spans, so this function does not have\n     /// to work for them.\n     fn imported_source_files(\n-        &'a self,\n+        &self,\n         local_source_map: &source_map::SourceMap,\n-    ) -> &[ImportedSourceFile] {\n-        self.source_map_import_info.init_locking(|| {\n+    ) -> &'a [ImportedSourceFile] {\n+        self.cdata.source_map_import_info.init_locking(|| {\n             let external_source_map = self.root.source_map.decode(self);\n \n             external_source_map\n@@ -1516,29 +1453,50 @@ impl<'a, 'tcx> CrateMetadata {\n                 .collect()\n         })\n     }\n+}\n \n-    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n-    /// method is cached in the `dep_node_index` field.\n-    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n-        let mut dep_node_index = self.dep_node_index.load();\n-\n-        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n-            // We have not cached the DepNodeIndex for this upstream crate yet,\n-            // so use the dep-graph to find it out and cache it.\n-            // Note that multiple threads can enter this block concurrently.\n-            // That is fine because the DepNodeIndex remains constant\n-            // throughout the whole compilation session, and multiple stores\n-            // would always write the same value.\n-\n-            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n-            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n-\n-            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n-            assert!(dep_node_index != DepNodeIndex::INVALID);\n-            self.dep_node_index.store(dep_node_index);\n+impl CrateMetadata {\n+    crate fn new(\n+        sess: &Session,\n+        blob: MetadataBlob,\n+        root: CrateRoot<'static>,\n+        raw_proc_macros: Option<&'static [ProcMacro]>,\n+        cnum: CrateNum,\n+        cnum_map: CrateNumMap,\n+        dep_kind: DepKind,\n+        source: CrateSource,\n+        private_dep: bool,\n+        host_hash: Option<Svh>,\n+    ) -> CrateMetadata {\n+        let def_path_table = record_time(&sess.perf_stats.decode_def_path_tables_time, || {\n+            root.def_path_table.decode((&blob, sess))\n+        });\n+        let trait_impls = root\n+            .impls\n+            .decode((&blob, sess))\n+            .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+            .collect();\n+        let alloc_decoding_state =\n+            AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n+        let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+        CrateMetadata {\n+            blob,\n+            root,\n+            def_path_table,\n+            trait_impls,\n+            raw_proc_macros,\n+            source_map_import_info: Once::new(),\n+            alloc_decoding_state,\n+            dep_node_index: AtomicCell::new(DepNodeIndex::INVALID),\n+            cnum,\n+            cnum_map,\n+            dependencies,\n+            dep_kind: Lock::new(dep_kind),\n+            source,\n+            private_dep,\n+            host_hash,\n+            extern_crate: Lock::new(None),\n         }\n-\n-        dep_node_index\n     }\n \n     crate fn dependencies(&self) -> LockGuard<'_, Vec<CrateNum>> {\n@@ -1613,6 +1571,51 @@ impl<'a, 'tcx> CrateMetadata {\n     crate fn hash(&self) -> Svh {\n         self.root.hash\n     }\n+\n+    fn local_def_id(&self, index: DefIndex) -> DefId {\n+        DefId { krate: self.cnum, index }\n+    }\n+\n+    // Translate a DefId from the current compilation environment to a DefId\n+    // for an external crate.\n+    fn reverse_translate_def_id(&self, did: DefId) -> Option<DefId> {\n+        for (local, &global) in self.cnum_map.iter_enumerated() {\n+            if global == did.krate {\n+                return Some(DefId { krate: local, index: did.index });\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    #[inline]\n+    fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n+        self.def_path_table.def_path_hash(index)\n+    }\n+\n+    /// Get the `DepNodeIndex` corresponding this crate. The result of this\n+    /// method is cached in the `dep_node_index` field.\n+    fn get_crate_dep_node_index(&self, tcx: TyCtxt<'tcx>) -> DepNodeIndex {\n+        let mut dep_node_index = self.dep_node_index.load();\n+\n+        if unlikely!(dep_node_index == DepNodeIndex::INVALID) {\n+            // We have not cached the DepNodeIndex for this upstream crate yet,\n+            // so use the dep-graph to find it out and cache it.\n+            // Note that multiple threads can enter this block concurrently.\n+            // That is fine because the DepNodeIndex remains constant\n+            // throughout the whole compilation session, and multiple stores\n+            // would always write the same value.\n+\n+            let def_path_hash = self.def_path_hash(CRATE_DEF_INDEX);\n+            let dep_node = def_path_hash.to_dep_node(dep_graph::DepKind::CrateMetadata);\n+\n+            dep_node_index = tcx.dep_graph.dep_node_index_of(&dep_node);\n+            assert!(dep_node_index != DepNodeIndex::INVALID);\n+            self.dep_node_index.store(dep_node_index);\n+        }\n+\n+        dep_node_index\n+    }\n }\n \n // Cannot be implemented on 'ProcMacro', as libproc_macro"}, {"sha": "c890640d432a7ac2ae0c5232c10c34d193d09593", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a62acaf9e456280339f37ca2e43fcb277772a18/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a62acaf9e456280339f37ca2e43fcb277772a18/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=5a62acaf9e456280339f37ca2e43fcb277772a18", "patch": "@@ -517,7 +517,7 @@ impl CrateStore for CStore {\n     }\n \n     fn def_path_table(&self, cnum: CrateNum) -> &DefPathTable {\n-        &self.get_crate_data(cnum).def_path_table\n+        &self.get_crate_data(cnum).cdata.def_path_table\n     }\n \n     fn crates_untracked(&self) -> Vec<CrateNum> {"}]}