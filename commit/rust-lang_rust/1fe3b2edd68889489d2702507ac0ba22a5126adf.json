{"sha": "1fe3b2edd68889489d2702507ac0ba22a5126adf", "node_id": "C_kwDOAAsO6NoAKDFmZTNiMmVkZDY4ODg5NDg5ZDI3MDI1MDdhYzBiYTIyYTUxMjZhZGY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-22T09:08:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-22T09:08:22Z"}, "message": "Merge #11527\n\n11527: internal: Split unresolve proc-macro error out of mbe r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "46e9dd2c4391737f61743fc8edb363e716b0d546", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46e9dd2c4391737f61743fc8edb363e716b0d546"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fe3b2edd68889489d2702507ac0ba22a5126adf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiFKgGCRBK7hj4Ov3rIwAAlyoIAK4oXl6WPQEBi7LZrwu5aXlC\n8y7x419gkIIOKRndLcR0wgW2zHYYsrXINHO4n2pDa7mZrqn7Cr/wJEDJ+gp+z9iq\nN3ut/kQeeXmUH5oUA+jdwBAHKNhJ/jvUSBB9s7fwgn8jkV3oRcrnVVrw62zar33x\nTjT+NfrsoyBO1BVkZNHbE4fDNOdP40ukF3zzzskyGkDf/qw47BgMK56ouzHj+4+8\n4tYIBNMvFxoNi9KZb62LcswWeSpYJMpJdUgd8rcVOFvDckGfArT6Ne6eOxhfWDtS\n3ECcTEZ6jJ9djF73lQq4LZGXbxuerc65V9pWJRG31nmd0Fm9j2F9x1OUG8+vwE8=\n=ilq3\n-----END PGP SIGNATURE-----\n", "payload": "tree 46e9dd2c4391737f61743fc8edb363e716b0d546\nparent 071186f8e29792f7211a0249b454db9ef40f6605\nparent 1505b6a9b4965f1d0b352b2a390821aca2ed4743\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645520902 +0000\ncommitter GitHub <noreply@github.com> 1645520902 +0000\n\nMerge #11527\n\n11527: internal: Split unresolve proc-macro error out of mbe r=Veykril a=Veykril\n\n\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fe3b2edd68889489d2702507ac0ba22a5126adf", "html_url": "https://github.com/rust-lang/rust/commit/1fe3b2edd68889489d2702507ac0ba22a5126adf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fe3b2edd68889489d2702507ac0ba22a5126adf/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "071186f8e29792f7211a0249b454db9ef40f6605", "url": "https://api.github.com/repos/rust-lang/rust/commits/071186f8e29792f7211a0249b454db9ef40f6605", "html_url": "https://github.com/rust-lang/rust/commit/071186f8e29792f7211a0249b454db9ef40f6605"}, {"sha": "1505b6a9b4965f1d0b352b2a390821aca2ed4743", "url": "https://api.github.com/repos/rust-lang/rust/commits/1505b6a9b4965f1d0b352b2a390821aca2ed4743", "html_url": "https://github.com/rust-lang/rust/commit/1505b6a9b4965f1d0b352b2a390821aca2ed4743"}], "stats": {"total": 251, "additions": 147, "deletions": 104}, "files": [{"sha": "a2f64eda062f7c6ff31eb702b6e7ba6cc10ad753", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -97,9 +97,9 @@ impl Expander {\n     ) -> Result<ExpandResult<Option<(Mark, T)>>, UnresolvedMacro> {\n         if self.recursion_limit(db).check(self.recursion_limit + 1).is_err() {\n             cov_mark::hit!(your_stack_belongs_to_me);\n-            return Ok(ExpandResult::str_err(\n+            return Ok(ExpandResult::only_err(ExpandError::Other(\n                 \"reached recursion limit during macro expansion\".into(),\n-            ));\n+            )));\n         }\n \n         let macro_call = InFile::new(self.current_file_id, &macro_call);\n@@ -151,7 +151,7 @@ impl Expander {\n                 }\n \n                 return ExpandResult::only_err(err.unwrap_or_else(|| {\n-                    mbe::ExpandError::Other(\"failed to parse macro invocation\".into())\n+                    ExpandError::Other(\"failed to parse macro invocation\".into())\n                 }));\n             }\n         };"}, {"sha": "7e33e53599877ab7c62e97f39ba97ff3b2c8d937", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -63,8 +63,8 @@ use hir_expand::{\n     ast_id_map::FileAstId,\n     eager::{expand_eager_macro, ErrorEmitted, ErrorSink},\n     hygiene::Hygiene,\n-    AstId, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n-    UnresolvedMacro,\n+    AstId, ExpandError, ExpandTo, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId,\n+    MacroDefKind, UnresolvedMacro,\n };\n use item_tree::ExternBlock;\n use la_arena::Idx;\n@@ -662,7 +662,7 @@ pub trait AsMacroCall {\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        error_sink: &mut dyn FnMut(mbe::ExpandError),\n+        error_sink: &mut dyn FnMut(ExpandError),\n     ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro>;\n }\n \n@@ -672,7 +672,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n         db: &dyn db::DefDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        mut error_sink: &mut dyn FnMut(mbe::ExpandError),\n+        mut error_sink: &mut dyn FnMut(ExpandError),\n     ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n         let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n@@ -681,7 +681,7 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n             self.value.path().and_then(|path| path::ModPath::from_src(db.upcast(), path, &h));\n \n         let path = match error_sink\n-            .option(path, || mbe::ExpandError::Other(\"malformed macro invocation\".into()))\n+            .option(path, || ExpandError::Other(\"malformed macro invocation\".into()))\n         {\n             Ok(path) => path,\n             Err(error) => {\n@@ -719,7 +719,7 @@ fn macro_call_as_call_id(\n     db: &dyn db::DefDatabase,\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-    error_sink: &mut dyn FnMut(mbe::ExpandError),\n+    error_sink: &mut dyn FnMut(ExpandError),\n ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n     let def: MacroDefId =\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;"}, {"sha": "907ee02e332e8fbb79dd8679f1873428b0b5440b", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -1,9 +1,10 @@\n //! Builtin attributes.\n \n-use mbe::ExpandResult;\n use syntax::ast;\n \n-use crate::{db::AstDatabase, name, AstId, CrateId, MacroCallId, MacroDefId, MacroDefKind};\n+use crate::{\n+    db::AstDatabase, name, AstId, CrateId, ExpandResult, MacroCallId, MacroDefId, MacroDefKind,\n+};\n \n macro_rules! register_builtin {\n     ( $(($name:ident, $variant:ident) => $expand:ident),* ) => {"}, {"sha": "dd7d249efa353b0aa05a810009e33c32ece9818f", "filename": "crates/hir_expand/src/builtin_derive_macro.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive_macro.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -2,13 +2,16 @@\n \n use tracing::debug;\n \n-use mbe::ExpandResult;\n use syntax::{\n     ast::{self, AstNode, HasGenericParams, HasModuleItem, HasName},\n     match_ast,\n };\n+use tt::TokenId;\n \n-use crate::{db::AstDatabase, name, quote, AstId, CrateId, MacroCallId, MacroDefId, MacroDefKind};\n+use crate::{\n+    db::AstDatabase, name, quote, AstId, CrateId, ExpandError, ExpandResult, MacroCallId,\n+    MacroDefId, MacroDefKind,\n+};\n \n macro_rules! register_builtin {\n     ( $($trait:ident => $expand:ident),* ) => {\n@@ -71,15 +74,15 @@ struct BasicAdtInfo {\n     type_params: usize,\n }\n \n-fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n-    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MacroItems); // FragmentKind::Items doesn't parse attrs?\n+fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, ExpandError> {\n+    let (parsed, token_map) = mbe::token_tree_to_syntax_node(tt, mbe::TopEntryPoint::MacroItems);\n     let macro_items = ast::MacroItems::cast(parsed.syntax_node()).ok_or_else(|| {\n         debug!(\"derive node didn't parse\");\n-        mbe::ExpandError::UnexpectedToken\n+        ExpandError::Other(\"invalid item definition\".into())\n     })?;\n     let item = macro_items.items().next().ok_or_else(|| {\n         debug!(\"no module item parsed\");\n-        mbe::ExpandError::NoMatchingRule\n+        ExpandError::Other(\"no item found\".into())\n     })?;\n     let node = item.syntax();\n     let (name, params) = match_ast! {\n@@ -89,18 +92,17 @@ fn parse_adt(tt: &tt::Subtree) -> Result<BasicAdtInfo, mbe::ExpandError> {\n             ast::Union(it) => (it.name(), it.generic_param_list()),\n             _ => {\n                 debug!(\"unexpected node is {:?}\", node);\n-                return Err(mbe::ExpandError::ConversionError)\n+                return Err(ExpandError::Other(\"expected struct, enum or union\".into()))\n             },\n         }\n     };\n     let name = name.ok_or_else(|| {\n         debug!(\"parsed item has no name\");\n-        mbe::ExpandError::NoMatchingRule\n-    })?;\n-    let name_token_id = token_map.token_by_range(name.syntax().text_range()).ok_or_else(|| {\n-        debug!(\"name token not found\");\n-        mbe::ExpandError::ConversionError\n+        ExpandError::Other(\"missing name\".into())\n     })?;\n+    let name_token_id = token_map\n+        .token_by_range(name.syntax().text_range())\n+        .unwrap_or_else(|| TokenId::unspecified());\n     let name_token = tt::Ident { id: name_token_id, text: name.text().into() };\n     let type_params = params.map_or(0, |type_param_list| type_param_list.type_params().count());\n     Ok(BasicAdtInfo { name: name_token, type_params })"}, {"sha": "5876be81b458e8732140ad553ba15c7430718cb7", "filename": "crates/hir_expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -1,15 +1,16 @@\n //! Builtin macro\n-use crate::{\n-    db::AstDatabase, name, quote, AstId, CrateId, MacroCallId, MacroCallLoc, MacroDefId,\n-    MacroDefKind,\n-};\n \n use base_db::{AnchoredPath, Edition, FileId};\n use cfg::CfgExpr;\n use either::Either;\n-use mbe::{parse_exprs_with_sep, parse_to_token_tree, ExpandResult};\n+use mbe::{parse_exprs_with_sep, parse_to_token_tree};\n use syntax::ast::{self, AstToken};\n \n+use crate::{\n+    db::AstDatabase, name, quote, AstId, CrateId, ExpandError, ExpandResult, MacroCallId,\n+    MacroCallLoc, MacroDefId, MacroDefKind,\n+};\n+\n macro_rules! register_builtin {\n     ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n         #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -257,7 +258,7 @@ fn format_args_expand(\n     let mut args = parse_exprs_with_sep(tt, ',');\n \n     if args.is_empty() {\n-        return ExpandResult::only_err(mbe::ExpandError::NoMatchingRule);\n+        return ExpandResult::only_err(mbe::ExpandError::NoMatchingRule.into());\n     }\n     for arg in &mut args {\n         // Remove `key =`.\n@@ -368,12 +369,12 @@ fn compile_error_expand(\n             let text = it.text.as_str();\n             if text.starts_with('\"') && text.ends_with('\"') {\n                 // FIXME: does not handle raw strings\n-                mbe::ExpandError::Other(text[1..text.len() - 1].into())\n+                ExpandError::Other(text[1..text.len() - 1].into())\n             } else {\n-                mbe::ExpandError::BindingError(\"`compile_error!` argument must be a string\".into())\n+                ExpandError::Other(\"`compile_error!` argument must be a string\".into())\n             }\n         }\n-        _ => mbe::ExpandError::BindingError(\"`compile_error!` argument must be a string\".into()),\n+        _ => ExpandError::Other(\"`compile_error!` argument must be a string\".into()),\n     };\n \n     ExpandResult { value: ExpandedEager::new(quote! {}), err: Some(err) }\n@@ -414,7 +415,7 @@ fn concat_expand(\n             }\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n             _ => {\n-                err.get_or_insert(mbe::ExpandError::UnexpectedToken);\n+                err.get_or_insert(mbe::ExpandError::UnexpectedToken.into());\n             }\n         }\n     }\n@@ -435,7 +436,7 @@ fn concat_idents_expand(\n             }\n             tt::TokenTree::Leaf(tt::Leaf::Punct(punct)) if i % 2 == 1 && punct.char == ',' => (),\n             _ => {\n-                err.get_or_insert(mbe::ExpandError::UnexpectedToken);\n+                err.get_or_insert(mbe::ExpandError::UnexpectedToken.into());\n             }\n         }\n     }\n@@ -448,28 +449,28 @@ fn relative_file(\n     call_id: MacroCallId,\n     path_str: &str,\n     allow_recursion: bool,\n-) -> Result<FileId, mbe::ExpandError> {\n+) -> Result<FileId, ExpandError> {\n     let call_site = call_id.as_file().original_file(db);\n     let path = AnchoredPath { anchor: call_site, path: path_str };\n-    let res = db.resolve_path(path).ok_or_else(|| {\n-        mbe::ExpandError::Other(format!(\"failed to load file `{path_str}`\").into())\n-    })?;\n+    let res = db\n+        .resolve_path(path)\n+        .ok_or_else(|| ExpandError::Other(format!(\"failed to load file `{path_str}`\").into()))?;\n     // Prevent include itself\n     if res == call_site && !allow_recursion {\n-        Err(mbe::ExpandError::Other(format!(\"recursive inclusion of `{path_str}`\").into()))\n+        Err(ExpandError::Other(format!(\"recursive inclusion of `{path_str}`\").into()))\n     } else {\n         Ok(res)\n     }\n }\n \n-fn parse_string(tt: &tt::Subtree) -> Result<String, mbe::ExpandError> {\n+fn parse_string(tt: &tt::Subtree) -> Result<String, ExpandError> {\n     tt.token_trees\n         .get(0)\n         .and_then(|tt| match tt {\n             tt::TokenTree::Leaf(tt::Leaf::Literal(it)) => unquote_str(it),\n             _ => None,\n         })\n-        .ok_or(mbe::ExpandError::ConversionError)\n+        .ok_or(mbe::ExpandError::ConversionError.into())\n }\n \n fn include_expand(\n@@ -561,7 +562,7 @@ fn env_expand(\n         // The only variable rust-analyzer ever sets is `OUT_DIR`, so only diagnose that to avoid\n         // unnecessary diagnostics for eg. `CARGO_PKG_NAME`.\n         if key == \"OUT_DIR\" {\n-            err = Some(mbe::ExpandError::Other(\n+            err = Some(ExpandError::Other(\n                 r#\"`OUT_DIR` not set, enable \"run build scripts\" to fix\"#.into(),\n             ));\n         }"}, {"sha": "91c1631e8178b904f5a69d387801f6679bebc951", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -5,7 +5,7 @@ use std::sync::Arc;\n use base_db::{salsa, SourceDatabase};\n use either::Either;\n use limit::Limit;\n-use mbe::{syntax_node_to_token_tree, ExpandError, ExpandResult};\n+use mbe::syntax_node_to_token_tree;\n use rustc_hash::FxHashSet;\n use syntax::{\n     algo::diff,\n@@ -15,8 +15,9 @@ use syntax::{\n \n use crate::{\n     ast_id_map::AstIdMap, fixup, hygiene::HygieneFrame, BuiltinAttrExpander, BuiltinDeriveExpander,\n-    BuiltinFnLikeExpander, ExpandTo, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind,\n-    MacroCallLoc, MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n+    BuiltinFnLikeExpander, ExpandError, ExpandResult, ExpandTo, HirFileId, HirFileIdRepr,\n+    MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId, MacroDefKind, MacroFile,\n+    ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -47,10 +48,10 @@ impl TokenExpander {\n         db: &dyn AstDatabase,\n         id: MacroCallId,\n         tt: &tt::Subtree,\n-    ) -> mbe::ExpandResult<tt::Subtree> {\n+    ) -> ExpandResult<tt::Subtree> {\n         match self {\n-            TokenExpander::DeclarativeMacro { mac, .. } => mac.expand(tt),\n-            TokenExpander::Builtin(it) => it.expand(db, id, tt),\n+            TokenExpander::DeclarativeMacro { mac, .. } => mac.expand(tt).map_err(Into::into),\n+            TokenExpander::Builtin(it) => it.expand(db, id, tt).map_err(Into::into),\n             TokenExpander::BuiltinAttr(it) => it.expand(db, id, tt),\n             TokenExpander::BuiltinDerive(it) => it.expand(db, id, tt),\n             TokenExpander::ProcMacro(_) => {\n@@ -432,24 +433,35 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n \n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n-        None => return ExpandResult::str_err(\"Failed to lower macro args to token tree\".into()),\n+        None => {\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"Failed to lower macro args to token tree\".into(),\n+            ))\n+        }\n     };\n \n     let expander = match db.macro_def(loc.def) {\n         Ok(it) => it,\n         // FIXME: This is weird -- we effectively report macro *definition*\n         // errors lazily, when we try to expand the macro. Instead, they should\n         // be reported at the definition site (when we construct a def map).\n-        Err(err) => return ExpandResult::str_err(format!(\"invalid macro definition: {}\", err)),\n+        Err(err) => {\n+            return ExpandResult::only_err(ExpandError::Other(\n+                format!(\"invalid macro definition: {}\", err).into(),\n+            ))\n+        }\n     };\n     let ExpandResult { value: mut tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     if TOKEN_LIMIT.check(count).is_err() {\n-        return ExpandResult::str_err(format!(\n-            \"macro invocation exceeds token limit: produced {} tokens, limit is {}\",\n-            count,\n-            TOKEN_LIMIT.inner(),\n+        return ExpandResult::only_err(ExpandError::Other(\n+            format!(\n+                \"macro invocation exceeds token limit: produced {} tokens, limit is {}\",\n+                count,\n+                TOKEN_LIMIT.inner(),\n+            )\n+            .into(),\n         ));\n     }\n \n@@ -466,7 +478,9 @@ fn expand_proc_macro(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<tt::\n     let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n     let macro_arg = match db.macro_arg(id) {\n         Some(it) => it,\n-        None => return ExpandResult::str_err(\"No arguments for proc-macro\".to_string()),\n+        None => {\n+            return ExpandResult::only_err(ExpandError::Other(\"No arguments for proc-macro\".into()))\n+        }\n     };\n \n     let expander = match loc.def.kind {"}, {"sha": "1de0d5a77d62f36b0c86e16712df6fc900c96773", "filename": "crates/hir_expand/src/eager.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -21,16 +21,15 @@\n use std::sync::Arc;\n \n use base_db::CrateId;\n-use mbe::ExpandResult;\n use syntax::{ted, SyntaxNode};\n \n use crate::{\n     ast::{self, AstNode},\n     db::AstDatabase,\n     hygiene::Hygiene,\n     mod_path::ModPath,\n-    EagerCallInfo, ExpandTo, InFile, MacroCallId, MacroCallKind, MacroCallLoc, MacroDefId,\n-    MacroDefKind, UnresolvedMacro,\n+    EagerCallInfo, ExpandError, ExpandResult, ExpandTo, InFile, MacroCallId, MacroCallKind,\n+    MacroCallLoc, MacroDefId, MacroDefKind, UnresolvedMacro,\n };\n \n #[derive(Debug)]\n@@ -39,12 +38,12 @@ pub struct ErrorEmitted {\n }\n \n pub trait ErrorSink {\n-    fn emit(&mut self, err: mbe::ExpandError);\n+    fn emit(&mut self, err: ExpandError);\n \n     fn option<T>(\n         &mut self,\n         opt: Option<T>,\n-        error: impl FnOnce() -> mbe::ExpandError,\n+        error: impl FnOnce() -> ExpandError,\n     ) -> Result<T, ErrorEmitted> {\n         match opt {\n             Some(it) => Ok(it),\n@@ -58,12 +57,12 @@ pub trait ErrorSink {\n     fn option_with<T>(\n         &mut self,\n         opt: impl FnOnce() -> Option<T>,\n-        error: impl FnOnce() -> mbe::ExpandError,\n+        error: impl FnOnce() -> ExpandError,\n     ) -> Result<T, ErrorEmitted> {\n         self.option(opt(), error)\n     }\n \n-    fn result<T>(&mut self, res: Result<T, mbe::ExpandError>) -> Result<T, ErrorEmitted> {\n+    fn result<T>(&mut self, res: Result<T, ExpandError>) -> Result<T, ErrorEmitted> {\n         match res {\n             Ok(it) => Ok(it),\n             Err(e) => {\n@@ -90,8 +89,8 @@ pub trait ErrorSink {\n     }\n }\n \n-impl ErrorSink for &'_ mut dyn FnMut(mbe::ExpandError) {\n-    fn emit(&mut self, err: mbe::ExpandError) {\n+impl ErrorSink for &'_ mut dyn FnMut(ExpandError) {\n+    fn emit(&mut self, err: ExpandError) {\n         self(err);\n     }\n }\n@@ -102,7 +101,7 @@ pub fn expand_eager_macro(\n     macro_call: InFile<ast::MacroCall>,\n     def: MacroDefId,\n     resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n+    diagnostic_sink: &mut dyn FnMut(ExpandError),\n ) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n     let hygiene = Hygiene::new(db, macro_call.file_id);\n     let parsed_args = macro_call\n@@ -147,7 +146,7 @@ pub fn expand_eager_macro(\n     if let MacroDefKind::BuiltInEager(eager, _) = def.kind {\n         let res = eager.expand(db, arg_id, &subtree);\n         if let Some(err) = res.err {\n-            diagnostic_sink(err);\n+            diagnostic_sink(err.into());\n         }\n \n         let loc = MacroCallLoc {\n@@ -199,7 +198,7 @@ fn eager_macro_recur(\n     curr: InFile<SyntaxNode>,\n     krate: CrateId,\n     macro_resolver: &dyn Fn(ModPath) -> Option<MacroDefId>,\n-    mut diagnostic_sink: &mut dyn FnMut(mbe::ExpandError),\n+    mut diagnostic_sink: &mut dyn FnMut(ExpandError),\n ) -> Result<Result<SyntaxNode, ErrorEmitted>, UnresolvedMacro> {\n     let original = curr.value.clone_for_update();\n \n@@ -211,7 +210,7 @@ fn eager_macro_recur(\n         let def = match child.path().and_then(|path| ModPath::from_src(db, path, &hygiene)) {\n             Some(path) => macro_resolver(path.clone()).ok_or_else(|| UnresolvedMacro { path })?,\n             None => {\n-                diagnostic_sink(mbe::ExpandError::Other(\"malformed macro invocation\".into()));\n+                diagnostic_sink(ExpandError::Other(\"malformed macro invocation\".into()));\n                 continue;\n             }\n         };"}, {"sha": "27c3f097abb1bc9d0817f31a3c57eaa6962c638f", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -17,9 +17,9 @@ pub mod eager;\n pub mod mod_path;\n mod fixup;\n \n-pub use mbe::{ExpandError, ExpandResult, Origin};\n+pub use mbe::{Origin, ValueResult};\n \n-use std::{hash::Hash, iter, sync::Arc};\n+use std::{fmt, hash::Hash, iter, sync::Arc};\n \n use base_db::{impl_intern_key, salsa, CrateId, FileId, FileRange, ProcMacroKind};\n use either::Either;\n@@ -39,6 +39,31 @@ use crate::{\n     proc_macro::ProcMacroExpander,\n };\n \n+pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n+\n+#[derive(Debug, PartialEq, Eq, Clone)]\n+pub enum ExpandError {\n+    UnresolvedProcMacro,\n+    Mbe(mbe::ExpandError),\n+    Other(Box<str>),\n+}\n+\n+impl From<mbe::ExpandError> for ExpandError {\n+    fn from(mbe: mbe::ExpandError) -> Self {\n+        Self::Mbe(mbe)\n+    }\n+}\n+\n+impl fmt::Display for ExpandError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ExpandError::UnresolvedProcMacro => f.write_str(\"unresolved proc-macro\"),\n+            ExpandError::Mbe(it) => it.fmt(f),\n+            ExpandError::Other(it) => f.write_str(it),\n+        }\n+    }\n+}\n+\n /// Input to the analyzer is a set of files, where each file is identified by\n /// `FileId` and contains source code. However, another source of source code in\n /// Rust are macros: each macro can be thought of as producing a \"temporary"}, {"sha": "df6c38761c39ba2e8ef7e06d4169f56150114020", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -1,9 +1,8 @@\n //! Proc Macro Expander stub\n \n use base_db::{CrateId, ProcMacroExpansionError, ProcMacroId, ProcMacroKind};\n-use mbe::ExpandResult;\n \n-use crate::db::AstDatabase;\n+use crate::{db::AstDatabase, ExpandError, ExpandResult};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n pub struct ProcMacroExpander {\n@@ -37,7 +36,11 @@ impl ProcMacroExpander {\n                 let krate_graph = db.crate_graph();\n                 let proc_macro = match krate_graph[self.krate].proc_macro.get(id.0 as usize) {\n                     Some(proc_macro) => proc_macro,\n-                    None => return ExpandResult::str_err(\"No proc-macro found.\".to_string()),\n+                    None => {\n+                        return ExpandResult::only_err(ExpandError::Other(\n+                            \"No proc-macro found.\".into(),\n+                        ))\n+                    }\n                 };\n \n                 // Proc macros have access to the environment variables of the invoking crate.\n@@ -51,17 +54,17 @@ impl ProcMacroExpander {\n                         {\n                             ExpandResult {\n                                 value: tt.clone(),\n-                                err: Some(mbe::ExpandError::Other(text.into())),\n+                                err: Some(ExpandError::Other(text.into())),\n                             }\n                         }\n                         ProcMacroExpansionError::System(text)\n                         | ProcMacroExpansionError::Panic(text) => {\n-                            ExpandResult::only_err(mbe::ExpandError::Other(text.into()))\n+                            ExpandResult::only_err(ExpandError::Other(text.into()))\n                         }\n                     },\n                 }\n             }\n-            None => ExpandResult::only_err(mbe::ExpandError::UnresolvedProcMacro),\n+            None => ExpandResult::only_err(ExpandError::UnresolvedProcMacro),\n         }\n     }\n }"}, {"sha": "944d3ef87d81569704e47154c236430cec625862", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -599,7 +599,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n                 src = it;\n                 res.unmatched_tts += src.len();\n             }\n-            res.add_err(ExpandError::binding_error(\"leftover tokens\"));\n+            res.add_err(ExpandError::LeftoverTokens);\n \n             if let Some(error_reover_item) = error_recover_item {\n                 res.bindings = bindings_builder.build(&error_reover_item);\n@@ -658,7 +658,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n     let rhs = src\n         .expect_leaf()\n-        .map_err(|()| ExpandError::BindingError(format!(\"expected leaf: `{lhs}`\").into()))?;\n+        .map_err(|()| ExpandError::binding_error(format!(\"expected leaf: `{lhs}`\")))?;\n     match (lhs, rhs) {\n         (\n             tt::Leaf::Punct(tt::Punct { char: lhs, .. }),"}, {"sha": "b1b3f63fd3a5869f95d5a71afae1cd3a278edc10", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -17,7 +17,7 @@ impl Bindings {\n \n     fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n         macro_rules! binding_err {\n-            ($($arg:tt)*) => { ExpandError::BindingError(format!($($arg)*).into()) };\n+            ($($arg:tt)*) => { ExpandError::binding_error(format!($($arg)*)) };\n         }\n \n         let mut b: &Binding =\n@@ -178,7 +178,7 @@ fn expand_repeat(\n             );\n             return ExpandResult {\n                 value: Fragment::Tokens(Subtree::default().into()),\n-                err: Some(ExpandError::Other(\"Expand exceed limit\".into())),\n+                err: Some(ExpandError::LimitExceeded),\n             };\n         }\n "}, {"sha": "6402ceadaaae6d824e29bf2a95c344ae86fd3a4f", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -67,18 +67,17 @@ impl fmt::Display for ParseError {\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ExpandError {\n+    BindingError(Box<Box<str>>),\n+    LeftoverTokens,\n+    ConversionError,\n+    LimitExceeded,\n     NoMatchingRule,\n     UnexpectedToken,\n-    BindingError(Box<str>),\n-    ConversionError,\n-    // FIXME: no way mbe should know about proc macros.\n-    UnresolvedProcMacro,\n-    Other(Box<str>),\n }\n \n impl ExpandError {\n-    fn binding_error(e: &str) -> ExpandError {\n-        ExpandError::BindingError(e.into())\n+    fn binding_error(e: impl Into<Box<str>>) -> ExpandError {\n+        ExpandError::BindingError(Box::new(e.into()))\n     }\n }\n \n@@ -89,8 +88,8 @@ impl fmt::Display for ExpandError {\n             ExpandError::UnexpectedToken => f.write_str(\"unexpected token in input\"),\n             ExpandError::BindingError(e) => f.write_str(e),\n             ExpandError::ConversionError => f.write_str(\"could not convert tokens\"),\n-            ExpandError::UnresolvedProcMacro => f.write_str(\"unresolved proc macro\"),\n-            ExpandError::Other(e) => f.write_str(e),\n+            ExpandError::LimitExceeded => f.write_str(\"Expand exceed limit\"),\n+            ExpandError::LeftoverTokens => f.write_str(\"leftover tokens\"),\n         }\n     }\n }\n@@ -311,42 +310,41 @@ fn validate(pattern: &MetaTemplate) -> Result<(), ParseError> {\n     Ok(())\n }\n \n+pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n-pub struct ExpandResult<T> {\n+pub struct ValueResult<T, E> {\n     pub value: T,\n-    pub err: Option<ExpandError>,\n+    pub err: Option<E>,\n }\n \n-impl<T> ExpandResult<T> {\n+impl<T, E> ValueResult<T, E> {\n     pub fn ok(value: T) -> Self {\n         Self { value, err: None }\n     }\n \n-    pub fn only_err(err: ExpandError) -> Self\n+    pub fn only_err(err: E) -> Self\n     where\n         T: Default,\n     {\n         Self { value: Default::default(), err: Some(err) }\n     }\n \n-    pub fn str_err(err: String) -> Self\n-    where\n-        T: Default,\n-    {\n-        Self::only_err(ExpandError::Other(err.into()))\n+    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> ValueResult<U, E> {\n+        ValueResult { value: f(self.value), err: self.err }\n     }\n \n-    pub fn map<U>(self, f: impl FnOnce(T) -> U) -> ExpandResult<U> {\n-        ExpandResult { value: f(self.value), err: self.err }\n+    pub fn map_err<E2>(self, f: impl FnOnce(E) -> E2) -> ValueResult<T, E2> {\n+        ValueResult { value: self.value, err: self.err.map(f) }\n     }\n \n-    pub fn result(self) -> Result<T, ExpandError> {\n+    pub fn result(self) -> Result<T, E> {\n         self.err.map_or(Ok(self.value), Err)\n     }\n }\n \n-impl<T: Default> From<Result<T, ExpandError>> for ExpandResult<T> {\n-    fn from(result: Result<T, ExpandError>) -> Self {\n+impl<T: Default, E> From<Result<T, E>> for ValueResult<T, E> {\n+    fn from(result: Result<T, E>) -> Self {\n         result.map_or_else(Self::only_err, Self::ok)\n     }\n }"}, {"sha": "fc5590b71845163a92a74b122f4074217846e909", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fe3b2edd68889489d2702507ac0ba22a5126adf/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=1fe3b2edd68889489d2702507ac0ba22a5126adf", "patch": "@@ -106,7 +106,7 @@ impl<'a> TtIter<'a> {\n         }\n \n         let err = if error || !cursor.is_root() {\n-            Some(ExpandError::BindingError(format!(\"expected {entry_point:?}\").into()))\n+            Some(ExpandError::binding_error(format!(\"expected {entry_point:?}\")))\n         } else {\n             None\n         };"}]}