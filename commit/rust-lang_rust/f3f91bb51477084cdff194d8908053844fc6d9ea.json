{"sha": "f3f91bb51477084cdff194d8908053844fc6d9ea", "node_id": "C_kwDOAAsO6NoAKGYzZjkxYmI1MTQ3NzA4NGNkZmYxOTRkODkwODA1Mzg0NGZjNmQ5ZWE", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-09-12T04:18:08Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-09-25T17:07:17Z"}, "message": "Move functions on `DepKindStruct` from rustc_middle to rustc_query_system", "tree": {"sha": "c59213cd056b2b448911e69b79892a245189ed8f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c59213cd056b2b448911e69b79892a245189ed8f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3f91bb51477084cdff194d8908053844fc6d9ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f91bb51477084cdff194d8908053844fc6d9ea", "html_url": "https://github.com/rust-lang/rust/commit/f3f91bb51477084cdff194d8908053844fc6d9ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3f91bb51477084cdff194d8908053844fc6d9ea/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "url": "https://api.github.com/repos/rust-lang/rust/commits/93a0fb190e9a781a36f9ab2faf02f2e3dc303234", "html_url": "https://github.com/rust-lang/rust/commit/93a0fb190e9a781a36f9ab2faf02f2e3dc303234"}], "stats": {"total": 135, "additions": 64, "deletions": 71}, "files": [{"sha": "9b5b688d98a93d705e509aae4f7914ee9df62db7", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=f3f91bb51477084cdff194d8908053844fc6d9ea", "patch": "@@ -69,18 +69,6 @@ use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n \n-impl DepKind {\n-    #[inline(always)]\n-    pub fn fingerprint_style(self, tcx: TyCtxt<'_>) -> FingerprintStyle {\n-        // Only fetch the DepKindStruct once.\n-        let data = tcx.query_kind(self);\n-        if data.is_anon {\n-            return FingerprintStyle::Opaque;\n-        }\n-        data.fingerprint_style\n-    }\n-}\n-\n macro_rules! define_dep_nodes {\n     (\n      $($(#[$attr:meta])*\n@@ -186,7 +174,7 @@ impl DepNodeExt for DepNode {\n     /// method will assert that the given DepKind actually requires a\n     /// single DefId/DefPathHash parameter.\n     fn from_def_path_hash(tcx: TyCtxt<'_>, def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n-        debug_assert!(kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash);\n+        debug_assert!(tcx.fingerprint_style(kind) == FingerprintStyle::DefPathHash);\n         DepNode { kind, hash: def_path_hash.0.into() }\n     }\n \n@@ -201,7 +189,7 @@ impl DepNodeExt for DepNode {\n     /// refers to something from the previous compilation session that\n     /// has been removed.\n     fn extract_def_id<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n-        if self.kind.fingerprint_style(tcx) == FingerprintStyle::DefPathHash {\n+        if tcx.fingerprint_style(self.kind) == FingerprintStyle::DefPathHash {\n             Some(tcx.def_path_hash_to_def_id(DefPathHash(self.hash.into()), &mut || {\n                 panic!(\"Failed to extract DefId: {:?} {}\", self.kind, self.hash)\n             }))\n@@ -218,7 +206,7 @@ impl DepNodeExt for DepNode {\n     ) -> Result<DepNode, ()> {\n         let kind = dep_kind_from_label_string(label)?;\n \n-        match kind.fingerprint_style(tcx) {\n+        match tcx.fingerprint_style(kind) {\n             FingerprintStyle::Opaque => Err(()),\n             FingerprintStyle::Unit => Ok(DepNode::new_no_params(tcx, kind)),\n             FingerprintStyle::DefPathHash => {"}, {"sha": "6226fdd923aac89c4a8c94a909dd7e0dda135146", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 7, "deletions": 45, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=f3f91bb51477084cdff194d8908053844fc6d9ea", "patch": "@@ -27,6 +27,10 @@ impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;\n     const RED: Self = DepKind::Red;\n \n+    fn is_codegen_unit_query(self) -> bool {\n+        self == DepKind::codegen_unit\n+    }\n+\n     fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         write!(f, \"{:?}(\", node.kind)?;\n \n@@ -93,50 +97,8 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n         self.sess\n     }\n \n-    #[inline(always)]\n-    fn fingerprint_style(&self, kind: DepKind) -> rustc_query_system::dep_graph::FingerprintStyle {\n-        kind.fingerprint_style(*self)\n-    }\n-\n-    #[inline(always)]\n-    fn is_eval_always(&self, kind: DepKind) -> bool {\n-        self.query_kind(kind).is_eval_always\n-    }\n-\n-    fn try_force_from_dep_node(&self, dep_node: DepNode) -> bool {\n-        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n-\n-        // We must avoid ever having to call `force_from_dep_node()` for a\n-        // `DepNode::codegen_unit`:\n-        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-        // would always end up having to evaluate the first caller of the\n-        // `codegen_unit` query that *is* reconstructible. This might very well be\n-        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-        // to re-trigger calling the `codegen_unit` query with the right key. At\n-        // that point we would already have re-done all the work we are trying to\n-        // avoid doing in the first place.\n-        // The solution is simple: Just explicitly call the `codegen_unit` query for\n-        // each CGU, right after partitioning. This way `try_mark_green` will always\n-        // hit the cache instead of having to go through `force_from_dep_node`.\n-        // This assertion makes sure, we actually keep applying the solution above.\n-        debug_assert!(\n-            dep_node.kind != DepKind::codegen_unit,\n-            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-        );\n-\n-        let cb = self.query_kind(dep_node.kind);\n-        if let Some(f) = cb.force_from_dep_node {\n-            f(*self, dep_node);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn try_load_from_on_disk_cache(&self, dep_node: DepNode) {\n-        let cb = self.query_kind(dep_node.kind);\n-        if let Some(f) = cb.try_load_from_on_disk_cache {\n-            f(*self, dep_node)\n-        }\n+    #[inline]\n+    fn dep_kind_info(&self, dep_kind: DepKind) -> &DepKindStruct<'tcx> {\n+        &self.query_kinds[dep_kind as usize]\n     }\n }"}, {"sha": "e430c327efe7c08cb90456258ac877c5a6eb0b4d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f3f91bb51477084cdff194d8908053844fc6d9ea", "patch": "@@ -1,7 +1,7 @@\n //! Type context book-keeping.\n \n use crate::arena::Arena;\n-use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n+use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintLevelSource};\n@@ -1085,7 +1085,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: &'tcx dyn query::QueryEngine<'tcx>,\n     pub query_caches: query::QueryCaches<'tcx>,\n-    query_kinds: &'tcx [DepKindStruct<'tcx>],\n+    pub(crate) query_kinds: &'tcx [DepKindStruct<'tcx>],\n \n     // Internal caches for metadata decoding. No need to track deps on this.\n     pub ty_rcache: Lock<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n@@ -1292,10 +1292,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub(crate) fn query_kind(self, k: DepKind) -> &'tcx DepKindStruct<'tcx> {\n-        &self.query_kinds[k as usize]\n-    }\n-\n     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` to ensure it gets used.\n     #[track_caller]\n     pub fn ty_error(self) -> Ty<'tcx> {"}, {"sha": "a5c274791261d5544d6279e28eb6986ea0f9d946", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 52, "deletions": 5, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f91bb51477084cdff194d8908053844fc6d9ea/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=f3f91bb51477084cdff194d8908053844fc6d9ea", "patch": "@@ -34,16 +34,61 @@ pub trait DepContext: Copy {\n     /// Access the compiler session.\n     fn sess(&self) -> &Session;\n \n-    /// Return whether this kind always require evaluation.\n-    fn is_eval_always(&self, kind: Self::DepKind) -> bool;\n+    fn dep_kind_info(&self, dep_node: Self::DepKind) -> &DepKindStruct<Self>;\n+\n+    #[inline(always)]\n+    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle {\n+        let data = self.dep_kind_info(kind);\n+        if data.is_anon {\n+            return FingerprintStyle::Opaque;\n+        }\n+        data.fingerprint_style\n+    }\n \n-    fn fingerprint_style(&self, kind: Self::DepKind) -> FingerprintStyle;\n+    #[inline(always)]\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self, kind: Self::DepKind) -> bool {\n+        self.dep_kind_info(kind).is_eval_always\n+    }\n \n     /// Try to force a dep node to execute and see if it's green.\n-    fn try_force_from_dep_node(&self, dep_node: DepNode<Self::DepKind>) -> bool;\n+    fn try_force_from_dep_node(self, dep_node: DepNode<Self::DepKind>) -> bool {\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+\n+        // We must avoid ever having to call `force_from_dep_node()` for a\n+        // `DepNode::codegen_unit`:\n+        // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+        // would always end up having to evaluate the first caller of the\n+        // `codegen_unit` query that *is* reconstructible. This might very well be\n+        // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+        // to re-trigger calling the `codegen_unit` query with the right key. At\n+        // that point we would already have re-done all the work we are trying to\n+        // avoid doing in the first place.\n+        // The solution is simple: Just explicitly call the `codegen_unit` query for\n+        // each CGU, right after partitioning. This way `try_mark_green` will always\n+        // hit the cache instead of having to go through `force_from_dep_node`.\n+        // This assertion makes sure, we actually keep applying the solution above.\n+        debug_assert!(\n+            !dep_node.kind.is_codegen_unit_query(),\n+            \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+        );\n+\n+        let cb = self.dep_kind_info(dep_node.kind);\n+        if let Some(f) = cb.force_from_dep_node {\n+            f(self, dep_node);\n+            true\n+        } else {\n+            false\n+        }\n+    }\n \n     /// Load data from the on-disk cache.\n-    fn try_load_from_on_disk_cache(&self, dep_node: DepNode<Self::DepKind>);\n+    fn try_load_from_on_disk_cache(self, dep_node: DepNode<Self::DepKind>) {\n+        let cb = self.dep_kind_info(dep_node.kind);\n+        if let Some(f) = cb.try_load_from_on_disk_cache {\n+            f(self, dep_node)\n+        }\n+    }\n }\n \n pub trait HasDepContext: Copy {\n@@ -91,6 +136,8 @@ pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder>\n     /// DepKind to use to create the initial forever-red node.\n     const RED: Self;\n \n+    fn is_codegen_unit_query(self) -> bool;\n+\n     /// Implementation of `std::fmt::Debug` for `DepNode`.\n     fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n "}]}