{"sha": "65ed5a632f5a5fc99a015e7ad0537c401fb61023", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1ZWQ1YTYzMmY1YTVmYzk5YTAxNWU3YWQwNTM3YzQwMWZiNjEwMjM=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-01-16T20:04:47Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-04-05T11:33:45Z"}, "message": "Updated code for dogfood", "tree": {"sha": "f6bcb543278fd31d66edcde518f29e02bac07e08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6bcb543278fd31d66edcde518f29e02bac07e08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65ed5a632f5a5fc99a015e7ad0537c401fb61023", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65ed5a632f5a5fc99a015e7ad0537c401fb61023", "html_url": "https://github.com/rust-lang/rust/commit/65ed5a632f5a5fc99a015e7ad0537c401fb61023", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65ed5a632f5a5fc99a015e7ad0537c401fb61023/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1d26e544f10b814d9793294d0c05dd2ace5d0dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d26e544f10b814d9793294d0c05dd2ace5d0dc", "html_url": "https://github.com/rust-lang/rust/commit/b1d26e544f10b814d9793294d0c05dd2ace5d0dc"}], "stats": {"total": 202, "additions": 134, "deletions": 68}, "files": [{"sha": "4a701dc8898df2c2214510afa42f4980b73987e9", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 75, "deletions": 67, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/65ed5a632f5a5fc99a015e7ad0537c401fb61023/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ed5a632f5a5fc99a015e7ad0537c401fb61023/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=65ed5a632f5a5fc99a015e7ad0537c401fb61023", "patch": "@@ -1,8 +1,9 @@\n-use crate::utils::{both, count_eq, eq_expr_value, in_macro, search_same, SpanlessEq, SpanlessHash};\n use crate::utils::{\n-    first_line_of_span, get_enclosing_block, get_parent_expr, if_sequence, indent_of, parent_node_is_if_expr,\n-    reindent_multiline, snippet, snippet_opt, span_lint_and_note, span_lint_and_then, ContainsName,\n+    both, count_eq, eq_expr_value, first_line_of_span, get_enclosing_block, get_parent_expr, if_sequence, in_macro,\n+    indent_of, parent_node_is_if_expr, reindent_multiline, run_lints, search_same, snippet, snippet_opt,\n+    span_lint_and_note, span_lint_and_then, ContainsName, SpanlessEq, SpanlessHash,\n };\n+use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -188,57 +189,15 @@ fn lint_same_then_else<'tcx>(\n         return;\n     }\n \n-    let has_expr = blocks[0].expr.is_some();\n-\n     // Check if each block has shared code\n-    let mut start_eq = usize::MAX;\n-    let mut end_eq = usize::MAX;\n-    let mut expr_eq = true;\n-    for win in blocks.windows(2) {\n-        let l_stmts = win[0].stmts;\n-        let r_stmts = win[1].stmts;\n-\n-        let mut evaluator = SpanlessEq::new(cx);\n-        let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));\n-        let current_end_eq = count_eq(&mut l_stmts.iter().rev(), &mut r_stmts.iter().rev(), |l, r| {\n-            evaluator.eq_stmt(l, r)\n-        });\n-        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n-\n-        // IF_SAME_THEN_ELSE\n-        if block_expr_eq && l_stmts.len() == r_stmts.len() && l_stmts.len() == current_start_eq {\n-            span_lint_and_note(\n-                cx,\n-                IF_SAME_THEN_ELSE,\n-                win[0].span,\n-                \"this `if` has identical blocks\",\n-                Some(win[1].span),\n-                \"same as this\",\n-            );\n-\n-            return;\n-        }\n-\n-        start_eq = start_eq.min(current_start_eq);\n-        end_eq = end_eq.min(current_end_eq);\n-        expr_eq &= block_expr_eq;\n-    }\n+    let has_expr = blocks[0].expr.is_some();\n+    let (start_eq, mut end_eq, expr_eq) = scan_block_for_eq(cx, blocks);\n \n     // SHARED_CODE_IN_IF_BLOCKS prerequisites\n     if !has_unconditional_else || (start_eq == 0 && end_eq == 0 && (has_expr && !expr_eq)) {\n         return;\n     }\n \n-    if has_expr && !expr_eq {\n-        end_eq = 0;\n-    }\n-\n-    // Check if the regions are overlapping. Set `end_eq` to prevent the overlap\n-    let min_block_size = blocks.iter().map(|x| x.stmts.len()).min().unwrap();\n-    if (start_eq + end_eq) > min_block_size {\n-        end_eq = min_block_size - start_eq;\n-    }\n-\n     // Only the start is the same\n     if start_eq != 0 && end_eq == 0 && (!has_expr || !expr_eq) {\n         let block = blocks[0];\n@@ -302,14 +261,13 @@ fn lint_same_then_else<'tcx>(\n             end_eq -= moved_start;\n         }\n \n-        let end_linable = if let Some(expr) = block.expr {\n-            intravisit::walk_expr(&mut end_walker, expr);\n-            end_walker.uses.iter().any(|x| !block_defs.contains(x))\n-        } else if end_eq == 0 {\n-            false\n-        } else {\n-            true\n-        };\n+        let end_linable = block.expr.map_or_else(\n+            || end_eq != 0,\n+            |expr| {\n+                intravisit::walk_expr(&mut end_walker, expr);\n+                end_walker.uses.iter().any(|x| !block_defs.contains(x))\n+            },\n+        );\n \n         if end_linable {\n             end_walker.def_symbols.drain().for_each(|x| {\n@@ -329,13 +287,67 @@ fn lint_same_then_else<'tcx>(\n     }\n }\n \n+fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> (usize, usize, bool) {\n+    let mut start_eq = usize::MAX;\n+    let mut end_eq = usize::MAX;\n+    let mut expr_eq = true;\n+    for win in blocks.windows(2) {\n+        let l_stmts = win[0].stmts;\n+        let r_stmts = win[1].stmts;\n+\n+        let mut evaluator = SpanlessEq::new(cx);\n+        let current_start_eq = count_eq(&mut l_stmts.iter(), &mut r_stmts.iter(), |l, r| evaluator.eq_stmt(l, r));\n+        let current_end_eq = count_eq(&mut l_stmts.iter().rev(), &mut r_stmts.iter().rev(), |l, r| {\n+            evaluator.eq_stmt(l, r)\n+        });\n+        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n+\n+        // IF_SAME_THEN_ELSE\n+        if_chain! {\n+            if block_expr_eq;\n+            if l_stmts.len() == r_stmts.len();\n+            if l_stmts.len() == current_start_eq;\n+            if run_lints(cx, &[IF_SAME_THEN_ELSE], win[0].hir_id);\n+            if run_lints(cx, &[IF_SAME_THEN_ELSE], win[1].hir_id);\n+            then {\n+                span_lint_and_note(\n+                    cx,\n+                    IF_SAME_THEN_ELSE,\n+                    win[0].span,\n+                    \"this `if` has identical blocks\",\n+                    Some(win[1].span),\n+                    \"same as this\",\n+                );\n+\n+                return (0, 0, false);\n+            }\n+        }\n+\n+        start_eq = start_eq.min(current_start_eq);\n+        end_eq = end_eq.min(current_end_eq);\n+        expr_eq &= block_expr_eq;\n+    }\n+\n+    let has_expr = blocks[0].expr.is_some();\n+    if has_expr && !expr_eq {\n+        end_eq = 0;\n+    }\n+\n+    // Check if the regions are overlapping. Set `end_eq` to prevent the overlap\n+    let min_block_size = blocks.iter().map(|x| x.stmts.len()).min().unwrap();\n+    if (start_eq + end_eq) > min_block_size {\n+        end_eq = min_block_size - start_eq;\n+    }\n+\n+    (start_eq, end_eq, expr_eq)\n+}\n+\n fn check_for_warn_of_moved_symbol(\n     cx: &LateContext<'tcx>,\n     symbols: &FxHashSet<Symbol>,\n     if_expr: &'tcx Expr<'_>,\n ) -> bool {\n-    // Obs true as we include the current if block\n-    if let Some(block) = get_enclosing_block(cx, if_expr.hir_id) {\n+    get_enclosing_block(cx, if_expr.hir_id).map_or(false, |block| {\n         let ignore_span = block.span.shrink_to_lo().to(if_expr.span);\n \n         symbols\n@@ -360,9 +372,7 @@ fn check_for_warn_of_moved_symbol(\n \n                 walker.result\n             })\n-    } else {\n-        false\n-    }\n+    })\n }\n \n fn emit_shared_code_in_if_blocks_lint(\n@@ -410,12 +420,10 @@ fn emit_shared_code_in_if_blocks_lint(\n             block.stmts[block.stmts.len() - end_stmts].span\n         }\n         .source_callsite();\n-        let moved_end = if let Some(expr) = block.expr {\n-            expr.span\n-        } else {\n-            block.stmts[block.stmts.len() - 1].span\n-        }\n-        .source_callsite();\n+        let moved_end = block\n+            .expr\n+            .map_or_else(|| block.stmts[block.stmts.len() - 1].span, |expr| expr.span)\n+            .source_callsite();\n \n         let moved_span = moved_start.to(moved_end);\n         let moved_snipped = reindent_multiline(snippet(cx, moved_span, \"_\"), true, None);\n@@ -488,7 +496,7 @@ fn emit_shared_code_in_if_blocks_lint(\n     }\n }\n \n-/// This visitor collects HirIds and Symbols of defined symbols and HirIds of used values.\n+/// This visitor collects `HirId`s and Symbols of defined symbols and `HirId`s of used values.\n struct UsedValueFinderVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n "}, {"sha": "496939f2a5e8a48c8da373fa9666025020c783bb", "filename": "tests/ui/shared_code_in_if_blocks/shared_at_top.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65ed5a632f5a5fc99a015e7ad0537c401fb61023/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65ed5a632f5a5fc99a015e7ad0537c401fb61023/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.rs?ref=65ed5a632f5a5fc99a015e7ad0537c401fb61023", "patch": "@@ -80,4 +80,24 @@ fn simple_but_suggestion_is_invalid() {\n     }\n }\n \n+/// This function tests that the `IS_SAME_THAN_ELSE` only covers the lint if it's enabled.\n+fn check_if_same_than_else_mask() {\n+    let x = 2021;\n+\n+    #[allow(clippy::if_same_then_else)]\n+    if x == 2020 {\n+        println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+        println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+    } else {\n+        println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+        println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+    }\n+\n+    if x == 2019 {\n+        println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+    } else {\n+        println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+    }\n+}\n+\n fn main() {}"}, {"sha": "d217083c413a348add5b0805a2db76c60711c743", "filename": "tests/ui/shared_code_in_if_blocks/shared_at_top.stderr", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/65ed5a632f5a5fc99a015e7ad0537c401fb61023/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/65ed5a632f5a5fc99a015e7ad0537c401fb61023/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshared_code_in_if_blocks%2Fshared_at_top.stderr?ref=65ed5a632f5a5fc99a015e7ad0537c401fb61023", "patch": "@@ -79,5 +79,43 @@ LL |     println!(\"I'm also moveable\");\n LL |     if x == 11 {\n    |\n \n-error: aborting due to 5 previous errors\n+error: All if blocks contain the same code at the start\n+  --> $DIR/shared_at_top.rs:88:5\n+   |\n+LL | /     if x == 2020 {\n+LL | |         println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+LL | |         println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+   | |________________________________________________________________^\n+   |\n+help: Consider moving the start statements out like this\n+   |\n+LL |     println!(\"This should trigger the `SHARED_CODE_IN_IF_BLOCKS` lint.\");\n+LL |     println!(\"Because `IF_SAME_THEN_ELSE` is allowed here\");\n+LL |     if x == 2020 {\n+   |\n+\n+error: this `if` has identical blocks\n+  --> $DIR/shared_at_top.rs:96:18\n+   |\n+LL |       if x == 2019 {\n+   |  __________________^\n+LL | |         println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+LL | |     } else {\n+   | |_____^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/shared_at_top.rs:2:9\n+   |\n+LL | #![deny(clippy::if_same_then_else, clippy::shared_code_in_if_blocks)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: same as this\n+  --> $DIR/shared_at_top.rs:98:12\n+   |\n+LL |       } else {\n+   |  ____________^\n+LL | |         println!(\"This should trigger `IS_SAME_THAN_ELSE` as usual\");\n+LL | |     }\n+   | |_____^\n+\n+error: aborting due to 7 previous errors\n "}]}