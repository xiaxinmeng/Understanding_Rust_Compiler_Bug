{"sha": "f4c396036416eaa977876d8ff4afe7f58f93c09e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YzM5NjAzNjQxNmVhYTk3Nzg3NmQ4ZmY0YWZlN2Y1OGY5M2MwOWU=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-29T06:33:45Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:45Z"}, "message": "List useless patterns in a useful match arm", "tree": {"sha": "2030066c0f8e09c47008f86315e2e7a0163cbe61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2030066c0f8e09c47008f86315e2e7a0163cbe61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4c396036416eaa977876d8ff4afe7f58f93c09e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c396036416eaa977876d8ff4afe7f58f93c09e", "html_url": "https://github.com/rust-lang/rust/commit/f4c396036416eaa977876d8ff4afe7f58f93c09e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4c396036416eaa977876d8ff4afe7f58f93c09e/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a95c93fe4c1050b18b3c8be25baddd6972ed84", "html_url": "https://github.com/rust-lang/rust/commit/f4a95c93fe4c1050b18b3c8be25baddd6972ed84"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "57a416bec055417ccde987f51a42c62d6a168107", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 58, "deletions": 9, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f4c396036416eaa977876d8ff4afe7f58f93c09e/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c396036416eaa977876d8ff4afe7f58f93c09e/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=f4c396036416eaa977876d8ff4afe7f58f93c09e", "patch": "@@ -314,11 +314,28 @@ impl SubPatSet {\n         }\n \n         match (&mut *self, other) {\n-            (Seq { .. }, Seq { .. }) => {\n-                todo!()\n+            (Seq { subpats: s_set }, Seq { subpats: mut o_set }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as full.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Full);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop full entries.\n+                    !s_sub_set.is_full()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as full. Since\n+                // unioning with full returns full, we can drop those entries.\n             }\n-            (Alt { .. }, Alt { .. }) => {\n-                todo!()\n+            (Alt { subpats: s_set, .. }, Alt { subpats: mut o_set, .. }) => {\n+                s_set.retain(|i, s_sub_set| {\n+                    // Missing entries count as empty.\n+                    let o_sub_set = o_set.remove(&i).unwrap_or(Empty);\n+                    s_sub_set.union(o_sub_set);\n+                    // We drop empty entries.\n+                    !s_sub_set.is_empty()\n+                });\n+                // Everything left in `o_set` is missing from `s_set`, i.e. counts as empty. Since\n+                // unioning with empty changes nothing, we can take those entries as is.\n+                s_set.extend(o_set);\n             }\n             _ => panic!(\"bug\"),\n         }\n@@ -328,17 +345,48 @@ impl SubPatSet {\n         }\n     }\n \n-    /// Returns a list of the spans of the unreachable subpatterns. If `self` is empty (i.e. the\n+    /// Returns a list of the unreachable subpatterns. If `self` is empty (i.e. the\n     /// whole pattern is unreachable) we return `None`.\n-    fn list_unreachable_spans(&self) -> Option<Vec<()>> {\n+    fn list_unreachable_subpatterns(&self, cx: &MatchCheckCtx<'_>) -> Option<Vec<PatId>> {\n+        /// Panics if `set.is_empty()`.\n+        fn fill_subpats(\n+            set: &SubPatSet,\n+            unreachable_pats: &mut Vec<PatId>,\n+            cx: &MatchCheckCtx<'_>,\n+        ) {\n+            match set {\n+                SubPatSet::Empty => panic!(\"bug\"),\n+                SubPatSet::Full => {}\n+                SubPatSet::Seq { subpats } => {\n+                    for (_, sub_set) in subpats {\n+                        fill_subpats(sub_set, unreachable_pats, cx);\n+                    }\n+                }\n+                SubPatSet::Alt { subpats, pat, alt_count, .. } => {\n+                    let expanded = pat.expand_or_pat(cx);\n+                    for i in 0..*alt_count {\n+                        let sub_set = subpats.get(&i).unwrap_or(&SubPatSet::Empty);\n+                        if sub_set.is_empty() {\n+                            // Found a unreachable subpattern.\n+                            unreachable_pats.push(expanded[i]);\n+                        } else {\n+                            fill_subpats(sub_set, unreachable_pats, cx);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         if self.is_empty() {\n             return None;\n         }\n         if self.is_full() {\n             // No subpatterns are unreachable.\n             return Some(Vec::new());\n         }\n-        todo!()\n+        let mut unreachable_pats = Vec::new();\n+        fill_subpats(self, &mut unreachable_pats, cx);\n+        Some(unreachable_pats)\n     }\n \n     /// When `self` refers to a patstack that was obtained from specialization, after running\n@@ -691,10 +739,11 @@ pub(crate) enum Reachability {\n     /// The arm is reachable. This additionally carries a set of or-pattern branches that have been\n     /// found to be unreachable despite the overall arm being reachable. Used only in the presence\n     /// of or-patterns, otherwise it stays empty.\n-    Reachable(Vec<()>),\n+    Reachable(Vec<PatId>),\n     /// The arm is unreachable.\n     Unreachable,\n }\n+\n /// The output of checking a match for exhaustiveness and arm reachability.\n pub(crate) struct UsefulnessReport {\n     /// For each arm of the input, whether that arm is reachable after the arms above it.\n@@ -726,7 +775,7 @@ pub(crate) fn compute_match_usefulness(\n             let reachability = match usefulness {\n                 NoWitnesses(subpats) if subpats.is_empty() => Reachability::Unreachable,\n                 NoWitnesses(subpats) => {\n-                    Reachability::Reachable(subpats.list_unreachable_spans().unwrap())\n+                    Reachability::Reachable(subpats.list_unreachable_subpatterns(cx).unwrap())\n                 }\n                 WithWitnesses(..) => panic!(\"bug\"),\n             };"}]}