{"sha": "10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "node_id": "C_kwDOAAsO6NoAKDEwYjFjOWFhOGIyOGY1MGNmNzMzMjk2MGQxZmMxZTliMWQxMjBlYjc", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2021-12-14T19:18:18Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-14T19:57:18Z"}, "message": "rustdoc: avoid many `Symbol` to `String` conversions.\n\nParticularly when constructing file paths and fully qualified paths.\nThis avoids a lot of allocations, speeding things up on almost all\nexamples.", "tree": {"sha": "4dfb0c4e7ebdf28fcb2af9b0ed77fedf98572719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dfb0c4e7ebdf28fcb2af9b0ed77fedf98572719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "html_url": "https://github.com/rust-lang/rust/commit/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "url": "https://api.github.com/repos/rust-lang/rust/commits/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609", "html_url": "https://github.com/rust-lang/rust/commit/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609"}], "stats": {"total": 318, "additions": 198, "deletions": 120}, "files": [{"sha": "5134d916320ad7094cc8c4d0ee070a68433750e2", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -567,6 +567,7 @@ symbols! {\n         doc_spotlight,\n         doctest,\n         document_private_items,\n+        dotdot: \"..\",\n         dotdot_in_tuple_patterns,\n         dotdoteq_in_patterns,\n         dreg,"}, {"sha": "a2e612955b3498cecb506dc756b9d2735af0e0e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -9,7 +9,6 @@ use rustc_data_structures::thin_vec::ThinVec;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathData;\n use rustc_hir::Mutability;\n use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_middle::ty::{self, TyCtxt};\n@@ -164,12 +163,10 @@ crate fn load_attrs<'hir>(cx: &DocContext<'hir>, did: DefId) -> Attrs<'hir> {\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n crate fn record_extern_fqn(cx: &mut DocContext<'_>, did: DefId, kind: ItemType) {\n-    let crate_name = cx.tcx.crate_name(did.krate).to_string();\n+    let crate_name = cx.tcx.crate_name(did.krate);\n \n-    let relative = cx.tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-        // Filter out extern blocks\n-        (elem.data != DefPathData::ForeignMod).then(|| elem.data.to_string())\n-    });\n+    let relative =\n+        cx.tcx.def_path(did).data.into_iter().filter_map(|elem| elem.data.get_opt_name());\n     let fqn = if let ItemType::Macro = kind {\n         // Check to see if it is a macro 2.0 or built-in macro\n         if matches!("}, {"sha": "a8fef4a317802c7fd39ca71513d559977c69ed94", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -4,13 +4,14 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::symbol::sym;\n+use rustc_span::{sym, Symbol};\n \n use crate::clean::{self, types::ExternalLocation, ExternalCrate, ItemId, PrimitiveType};\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n use crate::formats::Impl;\n+use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::search_index::get_function_type_for_search;\n use crate::html::render::IndexItem;\n@@ -39,11 +40,11 @@ crate struct Cache {\n     /// URLs when a type is being linked to. External paths are not located in\n     /// this map because the `External` type itself has all the information\n     /// necessary.\n-    crate paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Similar to `paths`, but only holds external paths. This is only used for\n     /// generating explicit hyperlinks to other crates.\n-    crate external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+    crate external_paths: FxHashMap<DefId, (Vec<Symbol>, ItemType)>,\n \n     /// Maps local `DefId`s of exported types to fully qualified paths.\n     /// Unlike 'paths', this mapping ignores any renames that occur\n@@ -55,7 +56,7 @@ crate struct Cache {\n     /// to the path used if the corresponding type is inlined. By\n     /// doing this, we can detect duplicate impls on a trait page, and only display\n     /// the impl for the inlined type.\n-    crate exact_paths: FxHashMap<DefId, Vec<String>>,\n+    crate exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n \n     /// This map contains information about all known traits of this crate.\n     /// Implementations of a crate should inherit the documentation of the\n@@ -92,7 +93,7 @@ crate struct Cache {\n     crate masked_crates: FxHashSet<CrateNum>,\n \n     // Private fields only used when initially crawling a crate to build a cache\n-    stack: Vec<String>,\n+    stack: Vec<Symbol>,\n     parent_stack: Vec<DefId>,\n     parent_is_trait_impl: bool,\n     stripped_mod: bool,\n@@ -155,7 +156,7 @@ impl Cache {\n             let dst = &render_options.output;\n             let location = e.location(extern_url, extern_url_takes_precedence, dst, tcx);\n             cx.cache.extern_locations.insert(e.crate_num, location);\n-            cx.cache.external_paths.insert(e.def_id(), (vec![name.to_string()], ItemType::Module));\n+            cx.cache.external_paths.insert(e.def_id(), (vec![name], ItemType::Module));\n         }\n \n         // FIXME: avoid this clone (requires implementing Default manually)\n@@ -164,10 +165,9 @@ impl Cache {\n             let crate_name = tcx.crate_name(def_id.krate);\n             // Recall that we only allow primitive modules to be at the root-level of the crate.\n             // If that restriction is ever lifted, this will have to include the relative paths instead.\n-            cx.cache.external_paths.insert(\n-                def_id,\n-                (vec![crate_name.to_string(), prim.as_sym().to_string()], ItemType::Primitive),\n-            );\n+            cx.cache\n+                .external_paths\n+                .insert(def_id, (vec![crate_name, prim.as_sym()], ItemType::Primitive));\n         }\n \n         krate = CacheBuilder { tcx, cache: &mut cx.cache }.fold_crate(krate);\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         self.cache.search_index.push(IndexItem {\n                             ty: item.type_(),\n                             name: s.to_string(),\n-                            path: path.join(\"::\"),\n+                            path: join_with_double_colon(path),\n                             desc,\n                             parent,\n                             parent_idx: None,\n@@ -320,7 +320,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n         // Keep track of the fully qualified path for this item.\n         let pushed = match item.name {\n             Some(n) if !n.is_empty() => {\n-                self.cache.stack.push(n.to_string());\n+                self.cache.stack.push(n);\n                 true\n             }\n             _ => false,"}, {"sha": "a4cdef9358b479eaa63ba206603dd2fc133266d1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 82, "deletions": 39, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::CRATE_DEF_INDEX;\n+use rustc_span::{sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{\n@@ -502,11 +503,45 @@ crate enum HrefError {\n     NotInExternalCache,\n }\n \n+// This mostly works with sequences of symbols, but sometimes the first item\n+// comes from a string, and in that case we want to trim any trailing `/`.\n+// `syms` can be empty.\n+crate fn join_with_slash(first: Option<&str>, syms: &[Symbol]) -> String {\n+    // 64 bytes covers 99.9%+ of cases.\n+    let mut s = String::with_capacity(64);\n+    if let Some(first) = first {\n+        s.push_str(first.trim_end_matches('/'));\n+        if !syms.is_empty() {\n+            s.push('/');\n+        }\n+    }\n+    if !syms.is_empty() {\n+        s.push_str(&syms[0].as_str());\n+        for sym in &syms[1..] {\n+            s.push('/');\n+            s.push_str(&sym.as_str());\n+        }\n+    }\n+    s\n+}\n+\n+// Panics if `syms` is empty.\n+crate fn join_with_double_colon(syms: &[Symbol]) -> String {\n+    // 64 bytes covers 99.9%+ of cases.\n+    let mut s = String::with_capacity(64);\n+    s.push_str(&syms[0].as_str());\n+    for sym in &syms[1..] {\n+        s.push_str(\"::\");\n+        s.push_str(&sym.as_str());\n+    }\n+    s\n+}\n+\n crate fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n     root_path: Option<&str>,\n-) -> Result<(String, ItemType, Vec<String>), HrefError> {\n+) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     let tcx = cx.tcx();\n     let def_kind = tcx.def_kind(did);\n     let did = match def_kind {\n@@ -518,7 +553,7 @@ crate fn href_with_root_path(\n     };\n     let cache = cx.cache();\n     let relative_to = &cx.current;\n-    fn to_module_fqp(shortty: ItemType, fqp: &[String]) -> &[String] {\n+    fn to_module_fqp(shortty: ItemType, fqp: &[Symbol]) -> &[Symbol] {\n         if shortty == ItemType::Module { fqp } else { &fqp[..fqp.len() - 1] }\n     }\n \n@@ -533,9 +568,9 @@ crate fn href_with_root_path(\n     let mut is_remote = false;\n     let (fqp, shortty, mut url_parts) = match cache.paths.get(&did) {\n         Some(&(ref fqp, shortty)) => (fqp, shortty, {\n-            let module_fqp = to_module_fqp(shortty, fqp);\n+            let module_fqp = to_module_fqp(shortty, fqp.as_slice());\n             debug!(?fqp, ?shortty, ?module_fqp);\n-            href_relative_parts(module_fqp, relative_to)\n+            href_relative_parts(module_fqp, relative_to).collect()\n         }),\n         None => {\n             if let Some(&(ref fqp, shortty)) = cache.external_paths.get(&did) {\n@@ -548,10 +583,12 @@ crate fn href_with_root_path(\n                             is_remote = true;\n                             let s = s.trim_end_matches('/');\n                             let mut builder = UrlPartsBuilder::singleton(s);\n-                            builder.extend(module_fqp.iter().map(String::as_str));\n+                            builder.extend(module_fqp.iter().copied());\n                             builder\n                         }\n-                        ExternalLocation::Local => href_relative_parts(module_fqp, relative_to),\n+                        ExternalLocation::Local => {\n+                            href_relative_parts(module_fqp, relative_to).collect()\n+                        }\n                         ExternalLocation::Unknown => return Err(HrefError::DocumentationNotBuilt),\n                     },\n                 )\n@@ -567,45 +604,50 @@ crate fn href_with_root_path(\n         }\n     }\n     debug!(?url_parts);\n-    let last = &fqp.last().unwrap()[..];\n     match shortty {\n         ItemType::Module => {\n             url_parts.push(\"index.html\");\n         }\n         _ => {\n-            let filename = format!(\"{}.{}.html\", shortty.as_str(), last);\n-            url_parts.push(&filename);\n+            let prefix = shortty.as_str();\n+            let last = fqp.last().unwrap();\n+            url_parts.push_fmt(format_args!(\"{}.{}.html\", prefix, last));\n         }\n     }\n     Ok((url_parts.finish(), shortty, fqp.to_vec()))\n }\n \n-crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<String>), HrefError> {\n+crate fn href(did: DefId, cx: &Context<'_>) -> Result<(String, ItemType, Vec<Symbol>), HrefError> {\n     href_with_root_path(did, cx, None)\n }\n \n /// Both paths should only be modules.\n /// This is because modules get their own directories; that is, `std::vec` and `std::vec::Vec` will\n /// both need `../iter/trait.Iterator.html` to get at the iterator trait.\n-crate fn href_relative_parts(fqp: &[String], relative_to_fqp: &[String]) -> UrlPartsBuilder {\n+crate fn href_relative_parts<'fqp>(\n+    fqp: &'fqp [Symbol],\n+    relative_to_fqp: &[Symbol],\n+) -> Box<dyn Iterator<Item = Symbol> + 'fqp> {\n     for (i, (f, r)) in fqp.iter().zip(relative_to_fqp.iter()).enumerate() {\n         // e.g. linking to std::iter from std::vec (`dissimilar_part_count` will be 1)\n         if f != r {\n             let dissimilar_part_count = relative_to_fqp.len() - i;\n-            let fqp_module = fqp[i..fqp.len()].iter().map(String::as_str);\n-            return iter::repeat(\"..\").take(dissimilar_part_count).chain(fqp_module).collect();\n+            let fqp_module = &fqp[i..fqp.len()];\n+            return box iter::repeat(sym::dotdot)\n+                .take(dissimilar_part_count)\n+                .chain(fqp_module.iter().copied());\n         }\n     }\n     // e.g. linking to std::sync::atomic from std::sync\n     if relative_to_fqp.len() < fqp.len() {\n-        fqp[relative_to_fqp.len()..fqp.len()].iter().map(String::as_str).collect()\n+        box fqp[relative_to_fqp.len()..fqp.len()].iter().copied()\n     // e.g. linking to std::sync from std::sync::atomic\n     } else if fqp.len() < relative_to_fqp.len() {\n         let dissimilar_part_count = relative_to_fqp.len() - fqp.len();\n-        iter::repeat(\"..\").take(dissimilar_part_count).collect()\n+        box iter::repeat(sym::dotdot).take(dissimilar_part_count)\n     // linking to the same module\n     } else {\n-        UrlPartsBuilder::new()\n+        box iter::empty()\n     }\n }\n \n@@ -632,14 +674,14 @@ fn resolved_path<'cx>(\n             if let Ok((_, _, fqp)) = href(did, cx) {\n                 format!(\n                     \"{}::{}\",\n-                    fqp[..fqp.len() - 1].join(\"::\"),\n-                    anchor(did, fqp.last().unwrap(), cx)\n+                    join_with_double_colon(&fqp[..fqp.len() - 1]),\n+                    anchor(did, *fqp.last().unwrap(), cx)\n                 )\n             } else {\n                 last.name.to_string()\n             }\n         } else {\n-            anchor(did, last.name.as_str(), cx).to_string()\n+            anchor(did, last.name, cx).to_string()\n         };\n         write!(w, \"{}{}\", path, last.args.print(cx))?;\n     }\n@@ -668,30 +710,31 @@ fn primitive_link(\n                 needs_termination = true;\n             }\n             Some(&def_id) => {\n-                let cname_sym;\n                 let loc = match m.extern_locations[&def_id.krate] {\n                     ExternalLocation::Remote(ref s) => {\n-                        cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n-                        Some(vec![s.trim_end_matches('/'), cname_sym.as_str()])\n+                        let cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n+                        let builder: UrlPartsBuilder =\n+                            [s.as_str().trim_end_matches('/'), cname_sym.as_str()]\n+                                .into_iter()\n+                                .collect();\n+                        Some(builder)\n                     }\n                     ExternalLocation::Local => {\n-                        cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n-                        Some(if cx.current.first().map(|x| &x[..]) == Some(cname_sym.as_str()) {\n-                            iter::repeat(\"..\").take(cx.current.len() - 1).collect()\n+                        let cname_sym = ExternalCrate { crate_num: def_id.krate }.name(cx.tcx());\n+                        Some(if cx.current.first() == Some(&cname_sym) {\n+                            iter::repeat(sym::dotdot).take(cx.current.len() - 1).collect()\n                         } else {\n-                            let cname = iter::once(cname_sym.as_str());\n-                            iter::repeat(\"..\").take(cx.current.len()).chain(cname).collect()\n+                            iter::repeat(sym::dotdot)\n+                                .take(cx.current.len())\n+                                .chain(iter::once(cname_sym))\n+                                .collect()\n                         })\n                     }\n                     ExternalLocation::Unknown => None,\n                 };\n-                if let Some(loc) = loc {\n-                    write!(\n-                        f,\n-                        \"<a class=\\\"primitive\\\" href=\\\"{}/primitive.{}.html\\\">\",\n-                        loc.join(\"/\"),\n-                        prim.as_sym()\n-                    )?;\n+                if let Some(mut loc) = loc {\n+                    loc.push_fmt(format_args!(\"primitive.{}.html\", prim.as_sym()));\n+                    write!(f, \"<a class=\\\"primitive\\\" href=\\\"{}\\\">\", loc.finish())?;\n                     needs_termination = true;\n                 }\n             }\n@@ -730,7 +773,7 @@ fn tybounds<'a, 'tcx: 'a>(\n \n crate fn anchor<'a, 'cx: 'a>(\n     did: DefId,\n-    text: &'a str,\n+    text: Symbol,\n     cx: &'cx Context<'_>,\n ) -> impl fmt::Display + 'a {\n     let parts = href(did, cx);\n@@ -742,8 +785,8 @@ crate fn anchor<'a, 'cx: 'a>(\n                 short_ty,\n                 url,\n                 short_ty,\n-                fqp.join(\"::\"),\n-                text\n+                join_with_double_colon(&fqp),\n+                &*text.as_str()\n             )\n         } else {\n             write!(f, \"{}\", text)\n@@ -960,7 +1003,7 @@ fn fmt_type<'cx>(\n                         url = url,\n                         shortty = ItemType::AssocType,\n                         name = name,\n-                        path = path.join(\"::\")\n+                        path = join_with_double_colon(path),\n                     )?;\n                 }\n                 _ => write!(f, \"{}\", name)?,\n@@ -1270,7 +1313,7 @@ impl clean::Visibility {\n                     debug!(\"path={:?}\", path);\n                     // modified from `resolved_path()` to work with `DefPathData`\n                     let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                    let anchor = anchor(vis_did, last_name.as_str(), cx).to_string();\n+                    let anchor = anchor(vis_did, last_name, cx).to_string();\n \n                     let mut s = \"pub(in \".to_owned();\n                     for seg in &path.data[..path.data.len() - 1] {"}, {"sha": "865e14f694dccbcc752b7adfc19547e93a93b1d3", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::FileName;\n-use rustc_span::symbol::sym;\n+use rustc_span::{sym, Symbol};\n \n use super::print_item::{full_path, item_path, print_item};\n use super::search_index::build_index;\n@@ -29,7 +29,7 @@ use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::formats::FormatRenderer;\n use crate::html::escape::Escape;\n-use crate::html::format::Buffer;\n+use crate::html::format::{join_with_double_colon, Buffer};\n use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n use crate::html::{layout, sources};\n use crate::scrape_examples::AllCallLocations;\n@@ -45,7 +45,7 @@ use crate::try_err;\n crate struct Context<'tcx> {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n-    pub(crate) current: Vec<String>,\n+    pub(crate) current: Vec<Symbol>,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     crate dst: PathBuf,\n@@ -176,7 +176,7 @@ impl<'tcx> Context<'tcx> {\n                 title.push_str(\" in \");\n             }\n             // No need to include the namespace for primitive types and keywords\n-            title.push_str(&self.current.join(\"::\"));\n+            title.push_str(&join_with_double_colon(&self.current));\n         };\n         title.push_str(\" - Rust\");\n         let tyname = it.type_();\n@@ -225,18 +225,18 @@ impl<'tcx> Context<'tcx> {\n             if let Some(&(ref names, ty)) = self.cache().paths.get(&it.def_id.expect_def_id()) {\n                 let mut path = String::new();\n                 for name in &names[..names.len() - 1] {\n-                    path.push_str(name);\n+                    path.push_str(&name.as_str());\n                     path.push('/');\n                 }\n-                path.push_str(&item_path(ty, names.last().unwrap()));\n+                path.push_str(&item_path(ty, &names.last().unwrap().as_str()));\n                 match self.shared.redirections {\n                     Some(ref redirections) => {\n                         let mut current_path = String::new();\n                         for name in &self.current {\n-                            current_path.push_str(name);\n+                            current_path.push_str(&name.as_str());\n                             current_path.push('/');\n                         }\n-                        current_path.push_str(&item_path(ty, names.last().unwrap()));\n+                        current_path.push_str(&item_path(ty, &names.last().unwrap().as_str()));\n                         redirections.borrow_mut().insert(current_path, path);\n                     }\n                     None => return layout::redirect(&format!(\"{}{}\", self.root_path(), path)),\n@@ -634,8 +634,8 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             self.render_redirect_pages = item.is_stripped();\n         }\n         let scx = &self.shared;\n-        let item_name = item.name.as_ref().unwrap().to_string();\n-        self.dst.push(&item_name);\n+        let item_name = item.name.unwrap();\n+        self.dst.push(&*item_name.as_str());\n         self.current.push(item_name);\n \n         info!(\"Recursing into {}\", self.dst.display());"}, {"sha": "8ba9a6dccacf051d87ded706a29b33031af8f48c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -69,8 +69,9 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    href, print_abi_with_space, print_constness_with_space, print_default_space,\n-    print_generic_bounds, print_where_clause, Buffer, HrefError, PrintWithSpace,\n+    href, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n+    print_default_space, print_generic_bounds, print_where_clause, Buffer, HrefError,\n+    PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::markdown::{HeadingOffset, Markdown, MarkdownHtml, MarkdownSummaryLine};\n@@ -2515,7 +2516,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n         let fqp = cache.exact_paths.get(&did).cloned().or_else(get_extern);\n \n         if let Some(path) = fqp {\n-            out.push(path.join(\"::\"));\n+            out.push(join_with_double_colon(&path));\n         }\n     };\n "}, {"sha": "6f7ba8aff5d50750d6cc20bcc7d8774e5de88152", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -26,7 +26,8 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    print_abi_with_space, print_constness_with_space, print_where_clause, Buffer, PrintWithSpace,\n+    join_with_double_colon, join_with_slash, print_abi_with_space, print_constness_with_space,\n+    print_where_clause, Buffer, PrintWithSpace,\n };\n use crate::html::highlight;\n use crate::html::layout::Page;\n@@ -40,9 +41,9 @@ const ITEM_TABLE_ROW_OPEN: &str = \"<div class=\\\"item-row\\\">\";\n const ITEM_TABLE_ROW_CLOSE: &str = \"</div>\";\n \n // A component in a `use` path, like `string` in std::string::ToString\n-struct PathComponent<'a> {\n+struct PathComponent {\n     path: String,\n-    name: &'a str,\n+    name: Symbol,\n }\n \n #[derive(Template)]\n@@ -53,7 +54,7 @@ struct ItemVars<'a> {\n     typ: &'a str,\n     name: &'a str,\n     item_type: &'a str,\n-    path_components: Vec<PathComponent<'a>>,\n+    path_components: Vec<PathComponent>,\n     stability_since_raw: &'a str,\n     src_href: Option<&'a str>,\n }\n@@ -121,7 +122,7 @@ pub(super) fn print_item(cx: &Context<'_>, item: &clean::Item, buf: &mut Buffer,\n             .take(amt)\n             .map(|(i, component)| PathComponent {\n                 path: \"../\".repeat(cur.len() - i - 1),\n-                name: component,\n+                name: *component,\n             })\n             .collect()\n     };\n@@ -304,22 +305,18 @@ fn item_module(w: &mut Buffer, cx: &Context<'_>, item: &clean::Item, items: &[cl\n \n                 w.write_str(ITEM_TABLE_ROW_OPEN);\n                 match *src {\n-                    Some(ref src) => write!(\n+                    Some(src) => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {} as {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(myitem.def_id.expect_def_id(), src.as_str(), cx),\n+                        anchor(myitem.def_id.expect_def_id(), src, cx),\n                         myitem.name.as_ref().unwrap(),\n                     ),\n                     None => write!(\n                         w,\n                         \"<div class=\\\"item-left\\\"><code>{}extern crate {};\",\n                         myitem.visibility.print_with_space(myitem.def_id, cx),\n-                        anchor(\n-                            myitem.def_id.expect_def_id(),\n-                            myitem.name.as_ref().unwrap().as_str(),\n-                            cx\n-                        ),\n+                        anchor(myitem.def_id.expect_def_id(), *myitem.name.as_ref().unwrap(), cx),\n                     ),\n                 }\n                 w.write_str(\"</code></div>\");\n@@ -864,10 +861,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n          </script>\",\n         root_path = vec![\"..\"; cx.current.len()].join(\"/\"),\n         path = if it.def_id.is_local() {\n-            cx.current.join(\"/\")\n+            join_with_slash(None, &cx.current)\n         } else {\n             let (ref path, _) = cache.external_paths[&it.def_id.expect_def_id()];\n-            path[..path.len() - 1].join(\"/\")\n+            join_with_slash(None, &path[..path.len() - 1])\n         },\n         ty = it.type_(),\n         name = *it.name.as_ref().unwrap()\n@@ -1410,7 +1407,7 @@ crate fn compare_names(mut lhs: &str, mut rhs: &str) -> Ordering {\n }\n \n pub(super) fn full_path(cx: &Context<'_>, item: &clean::Item) -> String {\n-    let mut s = cx.current.join(\"::\");\n+    let mut s = join_with_double_colon(&cx.current);\n     s.push_str(\"::\");\n     s.push_str(item.name.unwrap().as_str());\n     s"}, {"sha": "87138b9571c2a0e36515203263dfe060e730a508", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -10,6 +10,7 @@ use crate::clean;\n use crate::clean::types::{FnRetTy, Function, GenericBound, Generics, Type, WherePredicate};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n+use crate::html::format::join_with_double_colon;\n use crate::html::markdown::short_markdown_summary;\n use crate::html::render::{IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n@@ -28,7 +29,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n             cache.search_index.push(IndexItem {\n                 ty: item.type_(),\n                 name: item.name.unwrap().to_string(),\n-                path: fqp[..fqp.len() - 1].join(\"::\"),\n+                path: join_with_double_colon(&fqp[..fqp.len() - 1]),\n                 desc,\n                 parent: Some(did),\n                 parent_idx: None,\n@@ -102,7 +103,7 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n     struct CrateData<'a> {\n         doc: String,\n         items: Vec<&'a IndexItem>,\n-        paths: Vec<(ItemType, String)>,\n+        paths: Vec<(ItemType, Symbol)>,\n         // The String is alias name and the vec is the list of the elements with this alias.\n         //\n         // To be noted: the `usize` elements are indexes to `items`.\n@@ -154,7 +155,10 @@ crate fn build_index<'tcx>(krate: &clean::Crate, cache: &mut Cache, tcx: TyCtxt<\n                 \"f\",\n                 &self.items.iter().map(|item| &item.search_type).collect::<Vec<_>>(),\n             )?;\n-            crate_data.serialize_field(\"p\", &self.paths)?;\n+            crate_data.serialize_field(\n+                \"p\",\n+                &self.paths.iter().map(|(it, s)| (it, s.to_string())).collect::<Vec<_>>(),\n+            )?;\n             if has_aliases {\n                 crate_data.serialize_field(\"a\", &self.aliases)?;\n             }"}, {"sha": "e6900332a04297ba205a60b2cecfc0ff8435742e", "filename": "src/librustdoc/html/render/write_shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fwrite_shared.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -562,7 +562,7 @@ pub(super) fn write_shared(\n \n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n-            mydst.push(part);\n+            mydst.push(part.to_string());\n         }\n         cx.shared.ensure_dir(&mydst)?;\n         mydst.push(&format!(\"{}.{}.js\", remote_item_type, remote_path[remote_path.len() - 1]));"}, {"sha": "437d3995e29fca356eb31f085d9f10437496507a", "filename": "src/librustdoc/html/tests.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftests.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -1,44 +1,50 @@\n use crate::html::format::href_relative_parts;\n+use rustc_span::{sym, Symbol};\n \n-fn assert_relative_path(expected: &str, relative_to_fqp: &[&str], fqp: &[&str]) {\n-    let relative_to_fqp: Vec<String> = relative_to_fqp.iter().copied().map(String::from).collect();\n-    let fqp: Vec<String> = fqp.iter().copied().map(String::from).collect();\n-    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp).finish());\n+fn assert_relative_path(expected: &[Symbol], relative_to_fqp: &[Symbol], fqp: &[Symbol]) {\n+    // No `create_default_session_globals_then` call is needed here because all\n+    // the symbols used are static, and no `Symbol::intern` calls occur.\n+    assert_eq!(expected, href_relative_parts(&fqp, &relative_to_fqp).collect::<Vec<_>>());\n }\n \n #[test]\n fn href_relative_parts_basic() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"std\", \"iter\"];\n-    assert_relative_path(\"../iter\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::std, sym::iter];\n+    assert_relative_path(&[sym::dotdot, sym::iter], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_parent_module() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"std\"];\n-    assert_relative_path(\"..\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::std];\n+    assert_relative_path(&[sym::dotdot], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_different_crate() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"core\", \"iter\"];\n-    assert_relative_path(\"../../core/iter\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::core, sym::iter];\n+    assert_relative_path(&[sym::dotdot, sym::dotdot, sym::core, sym::iter], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_same_module() {\n-    let relative_to_fqp = &[\"std\", \"vec\"];\n-    let fqp = &[\"std\", \"vec\"];\n-    assert_relative_path(\"\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std, sym::vec];\n+    let fqp = &[sym::std, sym::vec];\n+    assert_relative_path(&[], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_child_module() {\n-    let relative_to_fqp = &[\"std\"];\n-    let fqp = &[\"std\", \"vec\"];\n-    assert_relative_path(\"vec\", relative_to_fqp, fqp);\n+    let relative_to_fqp = &[sym::std];\n+    let fqp = &[sym::std, sym::vec];\n+    assert_relative_path(&[sym::vec], relative_to_fqp, fqp);\n }\n+\n #[test]\n fn href_relative_parts_root() {\n     let relative_to_fqp = &[];\n-    let fqp = &[\"std\"];\n-    assert_relative_path(\"std\", relative_to_fqp, fqp);\n+    let fqp = &[sym::std];\n+    assert_relative_path(&[sym::std], relative_to_fqp, fqp);\n }"}, {"sha": "5c1557078aa8080842f1c5975d666056ae328f49", "filename": "src/librustdoc/html/url_parts_builder.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Furl_parts_builder.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -1,3 +1,7 @@\n+use std::fmt::{self, Write};\n+\n+use rustc_span::Symbol;\n+\n /// A builder that allows efficiently and easily constructing the part of a URL\n /// after the domain: `nightly/core/str/struct.Bytes.html`.\n ///\n@@ -10,6 +14,7 @@ crate struct UrlPartsBuilder {\n \n impl UrlPartsBuilder {\n     /// Create an empty buffer.\n+    #[allow(dead_code)]\n     crate fn new() -> Self {\n         Self { buf: String::new() }\n     }\n@@ -62,6 +67,13 @@ impl UrlPartsBuilder {\n         self.buf.push_str(part);\n     }\n \n+    crate fn push_fmt(&mut self, args: fmt::Arguments<'_>) {\n+        if !self.buf.is_empty() {\n+            self.buf.push('/');\n+        }\n+        self.buf.write_fmt(args).unwrap()\n+    }\n+\n     /// Push a component onto the front of the buffer.\n     ///\n     /// # Examples\n@@ -115,5 +127,26 @@ impl<'a> Extend<&'a str> for UrlPartsBuilder {\n     }\n }\n \n+impl FromIterator<Symbol> for UrlPartsBuilder {\n+    fn from_iter<T: IntoIterator<Item = Symbol>>(iter: T) -> Self {\n+        // This code has to be duplicated from the `&str` impl because of\n+        // `Symbol::as_str`'s lifetimes.\n+        let iter = iter.into_iter();\n+        let mut builder = Self::with_capacity_bytes(AVG_PART_LENGTH * iter.size_hint().0);\n+        iter.for_each(|part| builder.push(part.as_str()));\n+        builder\n+    }\n+}\n+\n+impl Extend<Symbol> for UrlPartsBuilder {\n+    fn extend<T: IntoIterator<Item = Symbol>>(&mut self, iter: T) {\n+        // This code has to be duplicated from the `&str` impl because of\n+        // `Symbol::as_str`'s lifetimes.\n+        let iter = iter.into_iter();\n+        self.buf.reserve(AVG_PART_LENGTH * iter.size_hint().0);\n+        iter.for_each(|part| self.push(part.as_str()));\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "81fbfd9fdbd166da4619f6c7277671343076e531", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> JsonRenderer<'tcx> {\n                                 })\n                                 .0\n                                 .last()\n-                                .map(Clone::clone),\n+                                .map(|s| s.to_string()),\n                             visibility: types::Visibility::Public,\n                             inner: types::ItemEnum::Trait(trait_item.clone().into_tcx(self.tcx)),\n                             span: None,\n@@ -230,7 +230,7 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n                         from_item_id(k.into()),\n                         types::ItemSummary {\n                             crate_id: k.krate.as_u32(),\n-                            path,\n+                            path: path.iter().map(|s| s.to_string()).collect(),\n                             kind: kind.into_tcx(self.tcx),\n                         },\n                     )"}, {"sha": "90cb5d586c2114a18dd2cccfd33e5e35f6d15a9d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=10b1c9aa8b28f50cf7332960d1fc1e9b1d120eb7", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::DefPathData;\n use rustc_hir::Node;\n use rustc_hir::CRATE_HIR_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n@@ -43,12 +42,9 @@ impl Module<'_> {\n }\n \n // FIXME: Should this be replaced with tcx.def_path_str?\n-fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<String> {\n-    let crate_name = tcx.crate_name(did.krate).to_string();\n-    let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| {\n-        // Filter out extern blocks\n-        (elem.data != DefPathData::ForeignMod).then(|| elem.data.to_string())\n-    });\n+fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n+    let crate_name = tcx.crate_name(did.krate);\n+    let relative = tcx.def_path(did).data.into_iter().filter_map(|elem| elem.data.get_opt_name());\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n@@ -71,7 +67,7 @@ crate struct RustdocVisitor<'a, 'tcx> {\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n-    exact_paths: FxHashMap<DefId, Vec<String>>,\n+    exact_paths: FxHashMap<DefId, Vec<Symbol>>,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {"}]}