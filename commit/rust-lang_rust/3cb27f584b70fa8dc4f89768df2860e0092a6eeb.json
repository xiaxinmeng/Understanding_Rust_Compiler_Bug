{"sha": "3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "node_id": "C_kwDOAAsO6NoAKDNjYjI3ZjU4NGI3MGZhOGRjNGY4OTc2OGRmMjg2MGUwMDkyYTZlZWI", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-18T19:52:38Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-09-20T06:37:20Z"}, "message": "avoid thread-local var indirection for non-halting diagnostics", "tree": {"sha": "08dd8cc7b8f714cd1112b58a0be5a81defc078ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08dd8cc7b8f714cd1112b58a0be5a81defc078ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "html_url": "https://github.com/rust-lang/rust/commit/3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b9463c5b713350b37ebc26a01122ea16e002451", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b9463c5b713350b37ebc26a01122ea16e002451", "html_url": "https://github.com/rust-lang/rust/commit/4b9463c5b713350b37ebc26a01122ea16e002451"}], "stats": {"total": 333, "additions": 133, "deletions": 200}, "files": [{"sha": "7e13b44e3f1eb3b49d4c6f826e26a753ea457e86", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -544,7 +544,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                     validate,\n                 )?;\n                 if global.track_outdated_loads && recency == LoadRecency::Outdated {\n-                    register_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n+                    this.emit_diagnostic(NonHaltingDiagnostic::WeakMemoryOutdatedLoad);\n                 }\n \n                 return Ok(loaded);"}, {"sha": "0118f9f421e38b06d6b07e15e751340862086ee4", "filename": "src/diagnostics.rs", "status": "modified", "additions": 105, "deletions": 172, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -1,11 +1,10 @@\n-use std::cell::RefCell;\n use std::fmt;\n use std::num::NonZeroU64;\n \n use log::trace;\n \n-use rustc_middle::ty;\n-use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::{source_map::DUMMY_SP, SpanData, Symbol};\n use rustc_target::abi::{Align, Size};\n \n use crate::stacked_borrows::{diagnostics::TagHistory, AccessKind};\n@@ -89,15 +88,16 @@ enum DiagLevel {\n /// Attempts to prune a stacktrace to omit the Rust runtime, and returns a bool indicating if any\n /// frames were pruned. If the stacktrace does not have any local frames, we conclude that it must\n /// be pointing to a problem in the Rust runtime itself, and do not prune it at all.\n-fn prune_stacktrace<'mir, 'tcx>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+fn prune_stacktrace<'tcx>(\n     mut stacktrace: Vec<FrameInfo<'tcx>>,\n+    machine: &Evaluator<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) -> (Vec<FrameInfo<'tcx>>, bool) {\n-    match ecx.machine.backtrace_style {\n+    match machine.backtrace_style {\n         BacktraceStyle::Off => {\n             // Remove all frames marked with `caller_location` -- that attribute indicates we\n             // usually want to point at the caller, not them.\n-            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+            stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(tcx));\n             // Retain one frame so that we can print a span for the error itself\n             stacktrace.truncate(1);\n             (stacktrace, false)\n@@ -107,11 +107,11 @@ fn prune_stacktrace<'mir, 'tcx>(\n             // Only prune frames if there is at least one local frame. This check ensures that if\n             // we get a backtrace that never makes it to the user code because it has detected a\n             // bug in the Rust runtime, we don't prune away every frame.\n-            let has_local_frame = stacktrace.iter().any(|frame| ecx.machine.is_local(frame));\n+            let has_local_frame = stacktrace.iter().any(|frame| machine.is_local(frame));\n             if has_local_frame {\n                 // Remove all frames marked with `caller_location` -- that attribute indicates we\n                 // usually want to point at the caller, not them.\n-                stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(*ecx.tcx));\n+                stacktrace.retain(|frame| !frame.instance.def.requires_caller_location(tcx));\n \n                 // This is part of the logic that `std` uses to select the relevant part of a\n                 // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n@@ -121,7 +121,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n                     .into_iter()\n                     .take_while(|frame| {\n                         let def_id = frame.instance.def_id();\n-                        let path = ecx.tcx.tcx.def_path_str(def_id);\n+                        let path = tcx.def_path_str(def_id);\n                         !path.contains(\"__rust_begin_short_backtrace\")\n                     })\n                     .collect::<Vec<_>>();\n@@ -132,7 +132,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n                 // This len check ensures that we don't somehow remove every frame, as doing so breaks\n                 // the primary error message.\n                 while stacktrace.len() > 1\n-                    && stacktrace.last().map_or(false, |frame| !ecx.machine.is_local(frame))\n+                    && stacktrace.last().map_or(false, |frame| !machine.is_local(frame))\n                 {\n                     stacktrace.pop();\n                 }\n@@ -256,17 +256,18 @@ pub fn report_error<'tcx, 'mir>(\n     };\n \n     let stacktrace = ecx.generate_stacktrace();\n-    let (stacktrace, was_pruned) = prune_stacktrace(ecx, stacktrace);\n+    let (stacktrace, was_pruned) = prune_stacktrace(stacktrace, &ecx.machine, *ecx.tcx);\n     e.print_backtrace();\n     msg.insert(0, e.to_string());\n     report_msg(\n-        ecx,\n         DiagLevel::Error,\n         &if let Some(title) = title { format!(\"{}: {}\", title, msg[0]) } else { msg[0].clone() },\n         msg,\n         vec![],\n         helps,\n         &stacktrace,\n+        &ecx.machine,\n+        *ecx.tcx,\n     );\n \n     // Include a note like `std` does when we omit frames from a backtrace\n@@ -306,21 +307,21 @@ pub fn report_error<'tcx, 'mir>(\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'mir, 'tcx>(\n-    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+fn report_msg<'tcx>(\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,\n     notes: Vec<(Option<SpanData>, String)>,\n     helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n+    machine: &Evaluator<'_, 'tcx>,\n+    tcx: TyCtxt<'tcx>,\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n-    let sess = ecx.tcx.sess;\n     let mut err = match diag_level {\n-        DiagLevel::Error => sess.struct_span_err(span, title).forget_guarantee(),\n-        DiagLevel::Warning => sess.struct_span_warn(span, title),\n-        DiagLevel::Note => sess.diagnostic().span_note_diag(span, title),\n+        DiagLevel::Error => tcx.sess.struct_span_err(span, title).forget_guarantee(),\n+        DiagLevel::Warning => tcx.sess.struct_span_warn(span, title),\n+        DiagLevel::Note => tcx.sess.diagnostic().span_note_diag(span, title),\n     };\n \n     // Show main message.\n@@ -357,7 +358,7 @@ fn report_msg<'mir, 'tcx>(\n     }\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n-        let is_local = ecx.machine.is_local(frame_info);\n+        let is_local = machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n             err.span_note(frame_info.span, &frame_info.to_string());\n@@ -369,164 +370,95 @@ fn report_msg<'mir, 'tcx>(\n     err.emit();\n }\n \n-thread_local! {\n-    static DIAGNOSTICS: RefCell<Vec<NonHaltingDiagnostic>> = RefCell::new(Vec::new());\n-}\n+pub fn emit_diagnostic<'tcx>(e: NonHaltingDiagnostic, machine: &Evaluator<'_, 'tcx>, tcx: TyCtxt<'tcx>) {\n+    use NonHaltingDiagnostic::*;\n+\n+    let stacktrace = MiriEvalContext::generate_stacktrace_from_stack(machine.threads.active_thread_stack());\n+    let (stacktrace, _was_pruned) = prune_stacktrace(stacktrace, machine, tcx);\n+\n+    let (title, diag_level) = match e {\n+        RejectedIsolatedOp(_) =>\n+            (\"operation rejected by isolation\", DiagLevel::Warning),\n+        Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n+        CreatedPointerTag(..)\n+        | PoppedPointerTag(..)\n+        | CreatedCallId(..)\n+        | CreatedAlloc(..)\n+        | FreedAlloc(..)\n+        | ProgressReport { .. }\n+        | WeakMemoryOutdatedLoad =>\n+            (\"tracking was triggered\", DiagLevel::Note),\n+    };\n \n-/// Schedule a diagnostic for emitting. This function works even if you have no `InterpCx` available.\n-/// The diagnostic will be emitted after the current interpreter step is finished.\n-pub fn register_diagnostic(e: NonHaltingDiagnostic) {\n-    DIAGNOSTICS.with(|diagnostics| diagnostics.borrow_mut().push(e));\n-}\n+    let msg = match e {\n+        CreatedPointerTag(tag, None) =>\n+            format!(\"created tag {tag:?}\"),\n+        CreatedPointerTag(tag, Some((alloc_id, range))) =>\n+            format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n+        PoppedPointerTag(item, tag) =>\n+            match tag {\n+                None =>\n+                    format!(\n+                        \"popped tracked tag for item {item:?} due to deallocation\",\n+                    ),\n+                Some((tag, access)) => {\n+                    format!(\n+                        \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n+                    )\n+                }\n+            },\n+        CreatedCallId(id) =>\n+            format!(\"function call with id {id}\"),\n+        CreatedAlloc(AllocId(id), size, align, kind) =>\n+            format!(\n+                \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n+                size = size.bytes(),\n+                align = align.bytes(),\n+            ),\n+        FreedAlloc(AllocId(id)) =>\n+            format!(\"freed allocation with id {id}\"),\n+        RejectedIsolatedOp(ref op) =>\n+            format!(\"{op} was made to return an error due to isolation\"),\n+        ProgressReport { .. } =>\n+            format!(\"progress report: current operation being executed is here\"),\n+        Int2Ptr { .. } =>\n+            format!(\"integer-to-pointer cast\"),\n+        WeakMemoryOutdatedLoad =>\n+            format!(\"weak memory emulation: outdated value returned from load\"),\n+    };\n \n-/// Remember enough about the topmost frame so that we can restore the stack\n-/// after a step was taken.\n-pub struct TopFrameInfo<'tcx> {\n-    stack_size: usize,\n-    instance: Option<ty::Instance<'tcx>>,\n-    span: Span,\n+    let notes = match e {\n+        ProgressReport { block_count } => {\n+            // It is important that each progress report is slightly different, since\n+            // identical diagnostics are being deduplicated.\n+            vec![\n+                (None, format!(\"so far, {block_count} basic blocks have been executed\")),\n+            ]\n+        }\n+        _ => vec![],\n+    };\n+\n+    let helps = match e {\n+        Int2Ptr { details: true } =>\n+            vec![\n+                (None, format!(\"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\")),\n+                (None, format!(\"which means that Miri might miss pointer bugs in this program.\")),\n+                (None, format!(\"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\")),\n+                (None, format!(\"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\")),\n+                (None, format!(\"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\")),\n+                (None, format!(\"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\")),\n+            ],\n+        _ => vec![],\n+    };\n+\n+    report_msg(diag_level, title, vec![msg], notes, helps, &stacktrace, machine, tcx);\n }\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn preprocess_diagnostics(&self) -> TopFrameInfo<'tcx> {\n-        // Ensure we have no lingering diagnostics.\n-        DIAGNOSTICS.with(|diagnostics| assert!(diagnostics.borrow().is_empty()));\n-\n+    fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n         let this = self.eval_context_ref();\n-        if this.active_thread_stack().is_empty() {\n-            // Diagnostics can happen even with the empty stack (e.g. deallocation of thread-local statics).\n-            return TopFrameInfo { stack_size: 0, instance: None, span: DUMMY_SP };\n-        }\n-        let frame = this.frame();\n-\n-        TopFrameInfo {\n-            stack_size: this.active_thread_stack().len(),\n-            instance: Some(frame.instance),\n-            span: frame.current_span(),\n-        }\n-    }\n-\n-    /// Emit all diagnostics that were registed with `register_diagnostics`\n-    fn process_diagnostics(&self, info: TopFrameInfo<'tcx>) {\n-        let this = self.eval_context_ref();\n-        DIAGNOSTICS.with(|diagnostics| {\n-            let mut diagnostics = diagnostics.borrow_mut();\n-            if diagnostics.is_empty() {\n-                return;\n-            }\n-            // We need to fix up the stack trace, because the machine has already\n-            // stepped to the next statement.\n-            let mut stacktrace = this.generate_stacktrace();\n-            // Remove newly pushed frames.\n-            while stacktrace.len() > info.stack_size {\n-                stacktrace.remove(0);\n-            }\n-            // Add popped frame back.\n-            if stacktrace.len() < info.stack_size {\n-                assert!(\n-                    stacktrace.len() == info.stack_size - 1,\n-                    \"we should never pop more than one frame at once\"\n-                );\n-                let frame_info = FrameInfo {\n-                    instance: info.instance.unwrap(),\n-                    span: info.span,\n-                    lint_root: None,\n-                };\n-                stacktrace.insert(0, frame_info);\n-            } else if let Some(instance) = info.instance {\n-                // Adjust topmost frame.\n-                stacktrace[0].span = info.span;\n-                assert_eq!(\n-                    stacktrace[0].instance, instance,\n-                    \"we should not pop and push a frame in one step\"\n-                );\n-            }\n-\n-            let (stacktrace, _was_pruned) = prune_stacktrace(this, stacktrace);\n-\n-            // Show diagnostics.\n-            for e in diagnostics.drain(..) {\n-                use NonHaltingDiagnostic::*;\n-\n-                let (title, diag_level) = match e {\n-                    RejectedIsolatedOp(_) =>\n-                        (\"operation rejected by isolation\", DiagLevel::Warning),\n-                    Int2Ptr { .. } => (\"integer-to-pointer cast\", DiagLevel::Warning),\n-                    CreatedPointerTag(..)\n-                    | PoppedPointerTag(..)\n-                    | CreatedCallId(..)\n-                    | CreatedAlloc(..)\n-                    | FreedAlloc(..)\n-                    | ProgressReport { .. }\n-                    | WeakMemoryOutdatedLoad =>\n-                        (\"tracking was triggered\", DiagLevel::Note),\n-                };\n-\n-                let msg = match e {\n-                    CreatedPointerTag(tag, None) =>\n-                        format!(\"created tag {tag:?}\"),\n-                    CreatedPointerTag(tag, Some((alloc_id, range))) =>\n-                        format!(\"created tag {tag:?} at {alloc_id:?}{range:?}\"),\n-                    PoppedPointerTag(item, tag) =>\n-                        match tag {\n-                            None =>\n-                                format!(\n-                                    \"popped tracked tag for item {item:?} due to deallocation\",\n-                                ),\n-                            Some((tag, access)) => {\n-                                format!(\n-                                    \"popped tracked tag for item {item:?} due to {access:?} access for {tag:?}\",\n-                                )\n-                            }\n-                        },\n-                    CreatedCallId(id) =>\n-                        format!(\"function call with id {id}\"),\n-                    CreatedAlloc(AllocId(id), size, align, kind) =>\n-                        format!(\n-                            \"created {kind} allocation of {size} bytes (alignment {align} bytes) with id {id}\",\n-                            size = size.bytes(),\n-                            align = align.bytes(),\n-                        ),\n-                    FreedAlloc(AllocId(id)) =>\n-                        format!(\"freed allocation with id {id}\"),\n-                    RejectedIsolatedOp(ref op) =>\n-                        format!(\"{op} was made to return an error due to isolation\"),\n-                    ProgressReport { .. } =>\n-                        format!(\"progress report: current operation being executed is here\"),\n-                    Int2Ptr { .. } =>\n-                        format!(\"integer-to-pointer cast\"),\n-                    WeakMemoryOutdatedLoad =>\n-                        format!(\"weak memory emulation: outdated value returned from load\"),\n-                };\n-\n-                let notes = match e {\n-                    ProgressReport { block_count } => {\n-                        // It is important that each progress report is slightly different, since\n-                        // identical diagnostics are being deduplicated.\n-                        vec![\n-                            (None, format!(\"so far, {block_count} basic blocks have been executed\")),\n-                        ]\n-                    }\n-                    _ => vec![],\n-                };\n-\n-                let helps = match e {\n-                    Int2Ptr { details: true } =>\n-                        vec![\n-                            (None, format!(\"This program is using integer-to-pointer casts or (equivalently) `ptr::from_exposed_addr`,\")),\n-                            (None, format!(\"which means that Miri might miss pointer bugs in this program.\")),\n-                            (None, format!(\"See https://doc.rust-lang.org/nightly/std/ptr/fn.from_exposed_addr.html for more details on that operation.\")),\n-                            (None, format!(\"To ensure that Miri does not miss bugs in your program, use Strict Provenance APIs (https://doc.rust-lang.org/nightly/std/ptr/index.html#strict-provenance, https://crates.io/crates/sptr) instead.\")),\n-                            (None, format!(\"You can then pass the `-Zmiri-strict-provenance` flag to Miri, to ensure you are not relying on `from_exposed_addr` semantics.\")),\n-                            (None, format!(\"Alternatively, the `-Zmiri-permissive-provenance` flag disables this warning.\")),\n-                        ],\n-                    _ => vec![],\n-                };\n-\n-                report_msg(this, diag_level, title, vec![msg], notes, helps, &stacktrace);\n-            }\n-        });\n+        emit_diagnostic(e, &this.machine, *this.tcx);\n     }\n \n     /// We had a panic in Miri itself, try to print something useful.\n@@ -538,13 +470,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_ref();\n         let stacktrace = this.generate_stacktrace();\n         report_msg(\n-            this,\n             DiagLevel::Note,\n             \"the place in the program where the ICE was triggered\",\n             vec![],\n             vec![],\n             vec![],\n             &stacktrace,\n+            &this.machine,\n+            *this.tcx,\n         );\n     }\n }"}, {"sha": "7562d0e36f1691547c2f77c5188c8403089fc6f8", "filename": "src/eval.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -190,11 +190,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         Evaluator::new(config, layout_cx),\n     );\n \n-    // Capture the current interpreter stack state (which should be empty) so that we can emit\n-    // allocation-tracking and tag-tracking diagnostics for allocations which are part of the\n-    // early runtime setup.\n-    let info = ecx.preprocess_diagnostics();\n-\n     // Some parts of initialization require a full `InterpCx`.\n     Evaluator::late_init(&mut ecx, config)?;\n \n@@ -324,10 +319,6 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         }\n     }\n \n-    // Emit any diagnostics related to the setup process for the runtime, so that when the\n-    // interpreter loop starts there are no unprocessed diagnostics.\n-    ecx.process_diagnostics(info);\n-\n     Ok((ecx, ret_place))\n }\n \n@@ -356,7 +347,6 @@ pub fn eval_entry<'tcx>(\n     let res: thread::Result<InterpResult<'_, i64>> = panic::catch_unwind(AssertUnwindSafe(|| {\n         // Main loop.\n         loop {\n-            let info = ecx.preprocess_diagnostics();\n             match ecx.schedule()? {\n                 SchedulingAction::ExecuteStep => {\n                     assert!(ecx.step()?, \"a terminated thread was scheduled for execution\");\n@@ -374,7 +364,6 @@ pub fn eval_entry<'tcx>(\n                     break;\n                 }\n             }\n-            ecx.process_diagnostics(info);\n         }\n         let return_code = ecx.read_scalar(&ret_place.into())?.to_machine_isize(&ecx)?;\n         Ok(return_code)"}, {"sha": "84815ee7691016f015ffd35c52b6209f5536dda1", "filename": "src/helpers.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -508,7 +508,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 Ok(())\n             }\n             RejectOpWith::Warning => {\n-                register_diagnostic(NonHaltingDiagnostic::RejectedIsolatedOp(op_name.to_string()));\n+                this.emit_diagnostic(NonHaltingDiagnostic::RejectedIsolatedOp(op_name.to_string()));\n                 Ok(())\n             }\n             RejectOpWith::NoWarning => Ok(()), // no warning\n@@ -881,6 +881,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             None => tcx.item_name(def_id),\n         }\n     }\n+\n+    fn current_span(&self) -> CurrentSpan<'_, 'mir, 'tcx> {\n+        let this = self.eval_context_ref();\n+        CurrentSpan { current_frame_idx: None, machine: &this.machine, tcx: *this.tcx }\n+    }\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n@@ -901,6 +906,12 @@ pub struct CurrentSpan<'a, 'mir, 'tcx> {\n }\n \n impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n+    /// Not really about the `CurrentSpan`, but we just happen to have all the things needed to emit\n+    /// diagnostics like that.\n+    pub fn emit_diagnostic(&self, e: NonHaltingDiagnostic) {\n+        emit_diagnostic(e, self.machine, self.tcx);\n+    }\n+\n     /// Get the current span, skipping non-local frames.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n     pub fn get(&mut self) -> Span {"}, {"sha": "a7b967ece51a59bbae7049cb3939826fc5f1dfe2", "filename": "src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -142,7 +142,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     let first = past_warnings.is_empty();\n                     if past_warnings.insert(ecx.cur_span()) {\n                         // Newly inserted, so first time we see this span.\n-                        register_diagnostic(NonHaltingDiagnostic::Int2Ptr { details: first });\n+                        ecx.emit_diagnostic(NonHaltingDiagnostic::Int2Ptr { details: first });\n                     }\n                 });\n             }"}, {"sha": "900daa88d274556546cc9a2cc07fa59fa94cb2c9", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -94,7 +94,7 @@ pub use crate::concurrency::{\n     },\n };\n pub use crate::diagnostics::{\n-    register_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n+    emit_diagnostic, report_error, EvalContextExt as DiagnosticsEvalContextExt,\n     NonHaltingDiagnostic, TerminationInfo,\n };\n pub use crate::eval::{"}, {"sha": "19978e550c32bbccc13c61ea6d304ce14f310c58", "filename": "src/machine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -755,7 +755,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>> {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         if ecx.machine.tracked_alloc_ids.contains(&id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(\n+            ecx.emit_diagnostic(NonHaltingDiagnostic::CreatedAlloc(\n                 id,\n                 alloc.size(),\n                 alloc.align,\n@@ -813,7 +813,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n         let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n         let sb_tag = if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance)\n+            stacked_borrows.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.current_span())\n         } else {\n             // Value does not matter, SB is disabled\n             SbTag::default()\n@@ -937,7 +937,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if machine.tracked_alloc_ids.contains(&alloc_id) {\n-            register_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id));\n+            emit_diagnostic(NonHaltingDiagnostic::FreedAlloc(alloc_id), machine, tcx);\n         }\n         if let Some(data_race) = &mut alloc_extra.data_race {\n             data_race.deallocate(\n@@ -993,7 +993,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         let stacked_borrows = ecx.machine.stacked_borrows.as_ref();\n \n         let extra = FrameData {\n-            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame()),\n+            stacked_borrows: stacked_borrows.map(|sb| sb.borrow_mut().new_frame(&ecx.current_span())),\n             catch_unwind: None,\n             timing,\n         };\n@@ -1018,7 +1018,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         // Possibly report our progress.\n         if let Some(report_progress) = ecx.machine.report_progress {\n             if ecx.machine.basic_block_count % u64::from(report_progress) == 0 {\n-                register_diagnostic(NonHaltingDiagnostic::ProgressReport {\n+                ecx.emit_diagnostic(NonHaltingDiagnostic::ProgressReport {\n                     block_count: ecx.machine.basic_block_count,\n                 });\n             }"}, {"sha": "278058c9f5f16407b02beff591518ba0e0dfecf1", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -471,7 +471,7 @@ impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir\n                 Some((orig_tag, kind))\n             }\n         };\n-        register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n+        self.current_span.emit_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(*item, summary));\n     }\n }\n "}, {"sha": "b4edf27856819f0bc3959af5d1ac59dd2284b1de", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb27f584b70fa8dc4f89768df2860e0092a6eeb/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=3cb27f584b70fa8dc4f89768df2860e0092a6eeb", "patch": "@@ -178,11 +178,11 @@ impl GlobalStateInner {\n         id\n     }\n \n-    pub fn new_frame(&mut self) -> FrameExtra {\n+    pub fn new_frame(&mut self, current_span: &CurrentSpan<'_, '_, '_>) -> FrameExtra {\n         let call_id = self.next_call_id;\n         trace!(\"new_frame: Assigning call ID {}\", call_id);\n         if self.tracked_call_ids.contains(&call_id) {\n-            register_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n+            current_span.emit_diagnostic(NonHaltingDiagnostic::CreatedCallId(call_id));\n         }\n         self.next_call_id = NonZeroU64::new(call_id.get() + 1).unwrap();\n         FrameExtra { call_id, protected_tags: SmallVec::new() }\n@@ -199,11 +199,11 @@ impl GlobalStateInner {\n         }\n     }\n \n-    pub fn base_ptr_tag(&mut self, id: AllocId) -> SbTag {\n+    pub fn base_ptr_tag(&mut self, id: AllocId, current_span: &CurrentSpan<'_, '_, '_>) -> SbTag {\n         self.base_ptr_tags.get(&id).copied().unwrap_or_else(|| {\n             let tag = self.new_ptr();\n             if self.tracked_pointer_tags.contains(&tag) {\n-                register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None));\n+                current_span.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(tag.0, None));\n             }\n             trace!(\"New allocation {:?} has base tag {:?}\", id, tag);\n             self.base_ptr_tags.try_insert(id, tag).unwrap();\n@@ -572,9 +572,9 @@ impl Stacks {\n             // not through a pointer). That is, whenever we directly write to a local, this will pop\n             // everything else off the stack, invalidating all previous pointers,\n             // and in particular, *all* raw pointers.\n-            MemoryKind::Stack => (extra.base_ptr_tag(id), Permission::Unique),\n+            MemoryKind::Stack => (extra.base_ptr_tag(id, &current_span), Permission::Unique),\n             // Everything else is shared by default.\n-            _ => (extra.base_ptr_tag(id), Permission::SharedReadWrite),\n+            _ => (extra.base_ptr_tag(id, &current_span), Permission::SharedReadWrite),\n         };\n         Stacks::new(size, perm, base_tag, id, &mut current_span)\n     }\n@@ -674,7 +674,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextEx\n          -> InterpResult<'tcx> {\n             let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n             if global.tracked_pointer_tags.contains(&new_tag) {\n-                register_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n                     new_tag.0,\n                     loc.map(|(alloc_id, base_offset, _)| (alloc_id, alloc_range(base_offset, size))),\n                 ));"}]}