{"sha": "28a0b25f424090255966273994748a9f9901059f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4YTBiMjVmNDI0MDkwMjU1OTY2MjczOTk0NzQ4YTlmOTkwMTA1OWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-23T22:43:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-23T22:43:39Z"}, "message": "Auto merge of #23536 - pnkfelix:arith-oflo-shifts, r=nikomatsakis\n\noverflow-checking for rhs of shift operators\r\n\r\nSubtask of #22020 ([RFC 560](https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md))", "tree": {"sha": "a4616861f27428e13ff510b2622cde80cce3cccf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4616861f27428e13ff510b2622cde80cce3cccf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28a0b25f424090255966273994748a9f9901059f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28a0b25f424090255966273994748a9f9901059f", "html_url": "https://github.com/rust-lang/rust/commit/28a0b25f424090255966273994748a9f9901059f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28a0b25f424090255966273994748a9f9901059f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "809a554fca2d0ebc2ba50077016fe282a4064752", "url": "https://api.github.com/repos/rust-lang/rust/commits/809a554fca2d0ebc2ba50077016fe282a4064752", "html_url": "https://github.com/rust-lang/rust/commit/809a554fca2d0ebc2ba50077016fe282a4064752"}, {"sha": "bb9d210c99ab248e81598d70c39c3968ab9d09eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb9d210c99ab248e81598d70c39c3968ab9d09eb", "html_url": "https://github.com/rust-lang/rust/commit/bb9d210c99ab248e81598d70c39c3968ab9d09eb"}], "stats": {"total": 479, "additions": 449, "deletions": 30}, "files": [{"sha": "7b177bd4e395c47898fd359bc1c3c695dabaf6ed", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -756,7 +756,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n }\n \n pub fn cast_shift_expr_rhs(cx: Block,\n-                           op: ast::BinOp,\n+                           op: ast::BinOp_,\n                            lhs: ValueRef,\n                            rhs: ValueRef)\n                            -> ValueRef {\n@@ -765,24 +765,24 @@ pub fn cast_shift_expr_rhs(cx: Block,\n                    |a,b| ZExt(cx, a, b))\n }\n \n-pub fn cast_shift_const_rhs(op: ast::BinOp,\n+pub fn cast_shift_const_rhs(op: ast::BinOp_,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs,\n                    |a, b| unsafe { llvm::LLVMConstTrunc(a, b.to_ref()) },\n                    |a, b| unsafe { llvm::LLVMConstZExt(a, b.to_ref()) })\n }\n \n-pub fn cast_shift_rhs<F, G>(op: ast::BinOp,\n-                            lhs: ValueRef,\n-                            rhs: ValueRef,\n-                            trunc: F,\n-                            zext: G)\n-                            -> ValueRef where\n+fn cast_shift_rhs<F, G>(op: ast::BinOp_,\n+                        lhs: ValueRef,\n+                        rhs: ValueRef,\n+                        trunc: F,\n+                        zext: G)\n+                        -> ValueRef where\n     F: FnOnce(ValueRef, Type) -> ValueRef,\n     G: FnOnce(ValueRef, Type) -> ValueRef,\n {\n     // Shifts may have any size int on the rhs\n-    if ast_util::is_shift_binop(op.node) {\n+    if ast_util::is_shift_binop(op) {\n         let mut rhs_llty = val_ty(rhs);\n         let mut lhs_llty = val_ty(lhs);\n         if rhs_llty.kind() == Vector { rhs_llty = rhs_llty.element_type() }"}, {"sha": "c95b29f4e7afca2fad2ee6aeb9ca91551d46ec90", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -376,7 +376,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let signed = ty::type_is_signed(intype);\n \n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n-            let te2 = base::cast_shift_const_rhs(b, te1, te2);\n+            let te2 = base::cast_shift_const_rhs(b.node, te1, te2);\n \n             match b.node {\n               ast::BiAdd   => {"}, {"sha": "565fe4a4d8f45375471e1b8d4f6d16cef2a15859", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 156, "deletions": 19, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -1770,7 +1770,6 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     };\n     let is_float = ty::type_is_fp(intype);\n     let is_signed = ty::type_is_signed(intype);\n-    let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n     let info = expr_info(binop_expr);\n \n     let binop_debug_loc = binop_expr.debug_loc();\n@@ -1843,13 +1842,17 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n       ast::BiBitOr => Or(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiBitAnd => And(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiBitXor => Xor(bcx, lhs, rhs, binop_debug_loc),\n-      ast::BiShl => Shl(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiShl => {\n+          let (newbcx, res) = with_overflow_check(\n+              bcx, OverflowOp::Shl, info, lhs_t, lhs, rhs, binop_debug_loc);\n+          bcx = newbcx;\n+          res\n+      }\n       ast::BiShr => {\n-        if is_signed {\n-            AShr(bcx, lhs, rhs, binop_debug_loc)\n-        } else {\n-            LShr(bcx, lhs, rhs, binop_debug_loc)\n-        }\n+          let (newbcx, res) = with_overflow_check(\n+              bcx, OverflowOp::Shr, info, lhs_t, lhs, rhs, binop_debug_loc);\n+          bcx = newbcx;\n+          res\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if is_simd {\n@@ -2389,9 +2392,38 @@ enum OverflowOp {\n     Add,\n     Sub,\n     Mul,\n+    Shl,\n+    Shr,\n }\n \n impl OverflowOp {\n+    fn codegen_strategy(&self) -> OverflowCodegen {\n+        use self::OverflowCodegen::{ViaIntrinsic, ViaInputCheck};\n+        match *self {\n+            OverflowOp::Add => ViaIntrinsic(OverflowOpViaIntrinsic::Add),\n+            OverflowOp::Sub => ViaIntrinsic(OverflowOpViaIntrinsic::Sub),\n+            OverflowOp::Mul => ViaIntrinsic(OverflowOpViaIntrinsic::Mul),\n+\n+            OverflowOp::Shl => ViaInputCheck(OverflowOpViaInputCheck::Shl),\n+            OverflowOp::Shr => ViaInputCheck(OverflowOpViaInputCheck::Shr),\n+        }\n+    }\n+}\n+\n+enum OverflowCodegen {\n+    ViaIntrinsic(OverflowOpViaIntrinsic),\n+    ViaInputCheck(OverflowOpViaInputCheck),\n+}\n+\n+enum OverflowOpViaInputCheck { Shl, Shr, }\n+\n+enum OverflowOpViaIntrinsic { Add, Sub, Mul, }\n+\n+impl OverflowOpViaIntrinsic {\n+    fn to_intrinsic<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>, lhs_ty: Ty) -> ValueRef {\n+        let name = self.to_intrinsic_name(bcx.tcx(), lhs_ty);\n+        bcx.ccx().get_intrinsic(&name)\n+    }\n     fn to_intrinsic_name(&self, tcx: &ty::ctxt, ty: Ty) -> &'static str {\n         use syntax::ast::IntTy::*;\n         use syntax::ast::UintTy::*;\n@@ -2413,7 +2445,7 @@ impl OverflowOp {\n         };\n \n         match *self {\n-            OverflowOp::Add => match new_sty {\n+            OverflowOpViaIntrinsic::Add => match new_sty {\n                 ty_int(TyI8) => \"llvm.sadd.with.overflow.i8\",\n                 ty_int(TyI16) => \"llvm.sadd.with.overflow.i16\",\n                 ty_int(TyI32) => \"llvm.sadd.with.overflow.i32\",\n@@ -2426,7 +2458,7 @@ impl OverflowOp {\n \n                 _ => unreachable!(),\n             },\n-            OverflowOp::Sub => match new_sty {\n+            OverflowOpViaIntrinsic::Sub => match new_sty {\n                 ty_int(TyI8) => \"llvm.ssub.with.overflow.i8\",\n                 ty_int(TyI16) => \"llvm.ssub.with.overflow.i16\",\n                 ty_int(TyI32) => \"llvm.ssub.with.overflow.i32\",\n@@ -2439,7 +2471,7 @@ impl OverflowOp {\n \n                 _ => unreachable!(),\n             },\n-            OverflowOp::Mul => match new_sty {\n+            OverflowOpViaIntrinsic::Mul => match new_sty {\n                 ty_int(TyI8) => \"llvm.smul.with.overflow.i8\",\n                 ty_int(TyI16) => \"llvm.smul.with.overflow.i16\",\n                 ty_int(TyI32) => \"llvm.smul.with.overflow.i32\",\n@@ -2454,16 +2486,14 @@ impl OverflowOp {\n             },\n         }\n     }\n-}\n \n-\n-fn with_overflow_check<'a, 'b>(bcx: Block<'a, 'b>, oop: OverflowOp, info: NodeIdAndSpan,\n-                               lhs_t: Ty, lhs: ValueRef, rhs: ValueRef, binop_debug_loc: DebugLoc)\n-                               -> (Block<'a, 'b>, ValueRef) {\n-    if bcx.unreachable.get() { return (bcx, _Undef(lhs)); }\n-    if bcx.ccx().check_overflow() {\n-        let name = oop.to_intrinsic_name(bcx.tcx(), lhs_t);\n-        let llfn = bcx.ccx().get_intrinsic(&name);\n+    fn build_intrinsic_call<'blk, 'tcx>(&self, bcx: Block<'blk, 'tcx>,\n+                                        info: NodeIdAndSpan,\n+                                        lhs_t: Ty<'tcx>, lhs: ValueRef,\n+                                        rhs: ValueRef,\n+                                        binop_debug_loc: DebugLoc)\n+                                        -> (Block<'blk, 'tcx>, ValueRef) {\n+        let llfn = self.to_intrinsic(bcx, lhs_t);\n \n         let val = Call(bcx, llfn, &[lhs, rhs], None, binop_debug_loc);\n         let result = ExtractValue(bcx, val, 0); // iN operation result\n@@ -2482,11 +2512,118 @@ fn with_overflow_check<'a, 'b>(bcx: Block<'a, 'b>, oop: OverflowOp, info: NodeId\n                     InternedString::new(\"arithmetic operation overflowed\")));\n \n         (bcx, result)\n+    }\n+}\n+\n+impl OverflowOpViaInputCheck {\n+    fn build_with_input_check<'blk, 'tcx>(&self,\n+                                          bcx: Block<'blk, 'tcx>,\n+                                          info: NodeIdAndSpan,\n+                                          lhs_t: Ty<'tcx>,\n+                                          lhs: ValueRef,\n+                                          rhs: ValueRef,\n+                                          binop_debug_loc: DebugLoc)\n+                                          -> (Block<'blk, 'tcx>, ValueRef)\n+    {\n+        let lhs_llty = val_ty(lhs);\n+        let rhs_llty = val_ty(rhs);\n+\n+        // Panic if any bits are set outside of bits that we always\n+        // mask in.\n+        //\n+        // Note that the mask's value is derived from the LHS type\n+        // (since that is where the 32/64 distinction is relevant) but\n+        // the mask's type must match the RHS type (since they will\n+        // both be fed into a and-binop)\n+        let invert_mask = !shift_mask_val(lhs_llty);\n+        let invert_mask = C_integral(rhs_llty, invert_mask, true);\n+\n+        let outer_bits = And(bcx, rhs, invert_mask, binop_debug_loc);\n+        let cond = ICmp(bcx, llvm::IntNE, outer_bits,\n+                        C_integral(rhs_llty, 0, false), binop_debug_loc);\n+        let result = match *self {\n+            OverflowOpViaInputCheck::Shl =>\n+                build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n+            OverflowOpViaInputCheck::Shr =>\n+                build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc),\n+        };\n+        let bcx =\n+            base::with_cond(bcx, cond, |bcx|\n+                controlflow::trans_fail(bcx, info,\n+                    InternedString::new(\"shift operation overflowed\")));\n+\n+        (bcx, result)\n+    }\n+}\n+\n+fn shift_mask_val(llty: Type) -> u64 {\n+    // i8/u8 can shift by at most 7, i16/u16 by at most 15, etc.\n+    llty.int_width() - 1\n+}\n+\n+// To avoid UB from LLVM, these two functions mask RHS with an\n+// appropriate mask unconditionally (i.e. the fallback behavior for\n+// all shifts). For 32- and 64-bit types, this matches the semantics\n+// of Java. (See related discussion on #1877 and #10183.)\n+\n+fn build_unchecked_lshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, ast::BinOp_::BiShl, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    Shl(bcx, lhs, rhs, binop_debug_loc)\n+}\n+\n+fn build_unchecked_rshift<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      lhs_t: Ty<'tcx>,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      binop_debug_loc: DebugLoc) -> ValueRef {\n+    let rhs = base::cast_shift_expr_rhs(bcx, ast::BinOp_::BiShr, lhs, rhs);\n+    // #1877, #10183: Ensure that input is always valid\n+    let rhs = shift_mask_rhs(bcx, rhs, binop_debug_loc);\n+    let is_signed = ty::type_is_signed(lhs_t);\n+    if is_signed {\n+        AShr(bcx, lhs, rhs, binop_debug_loc)\n+    } else {\n+        LShr(bcx, lhs, rhs, binop_debug_loc)\n+    }\n+}\n+\n+fn shift_mask_rhs<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                              rhs: ValueRef,\n+                              debug_loc: DebugLoc) -> ValueRef {\n+    let rhs_llty = val_ty(rhs);\n+    let mask = shift_mask_val(rhs_llty);\n+    And(bcx, rhs, C_integral(rhs_llty, mask, false), debug_loc)\n+}\n+\n+fn with_overflow_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, oop: OverflowOp, info: NodeIdAndSpan,\n+                                   lhs_t: Ty<'tcx>, lhs: ValueRef,\n+                                   rhs: ValueRef,\n+                                   binop_debug_loc: DebugLoc)\n+                                   -> (Block<'blk, 'tcx>, ValueRef) {\n+    if bcx.unreachable.get() { return (bcx, _Undef(lhs)); }\n+    if bcx.ccx().check_overflow() {\n+\n+        match oop.codegen_strategy() {\n+            OverflowCodegen::ViaIntrinsic(oop) =>\n+                oop.build_intrinsic_call(bcx, info, lhs_t, lhs, rhs, binop_debug_loc),\n+            OverflowCodegen::ViaInputCheck(oop) =>\n+                oop.build_with_input_check(bcx, info, lhs_t, lhs, rhs, binop_debug_loc),\n+        }\n     } else {\n         let res = match oop {\n             OverflowOp::Add => Add(bcx, lhs, rhs, binop_debug_loc),\n             OverflowOp::Sub => Sub(bcx, lhs, rhs, binop_debug_loc),\n             OverflowOp::Mul => Mul(bcx, lhs, rhs, binop_debug_loc),\n+\n+            OverflowOp::Shl =>\n+                build_unchecked_lshift(bcx, lhs, rhs, binop_debug_loc),\n+            OverflowOp::Shr =>\n+                build_unchecked_rshift(bcx, lhs_t, lhs, rhs, binop_debug_loc),\n         };\n         (bcx, res)\n     }"}, {"sha": "54159153382084a239a90c033b7d33100b639a1d", "filename": "src/test/run-fail/overflowing-lsh-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-1.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = 1_i32 << id(32);\n+}"}, {"sha": "fd3e801457c2359912fe3ce1680796b25d137520", "filename": "src/test/run-fail/overflowing-lsh-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-2.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = 1 << id(-1);\n+}"}, {"sha": "58914bab3fb15e248dee3dbf4e21d0035ce63b42", "filename": "src/test/run-fail/overflowing-lsh-3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-3.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = 1_u64 << id(64);\n+}"}, {"sha": "ed25876cec47906c061767cdff910e5cdc24bbf8", "filename": "src/test/run-fail/overflowing-lsh-4.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-lsh-4.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// This function is checking that our automatic truncation does not\n+// sidestep the overflow checking.\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    // this signals overflow when checking is on\n+    let x = 1_i8 << id(17);\n+\n+    // ... but when checking is off, the fallback will truncate the\n+    // input to its lower three bits (= 1). Note that this is *not*\n+    // the behavior of the x86 processor for 8- and 16-bit types,\n+    // but it is necessary to avoid undefined behavior from LLVM.\n+    //\n+    // We check that here, by ensuring the result has only been\n+    // shifted by one place; if overflow checking is turned off, then\n+    // this assertion will pass (and the compiletest driver will\n+    // report that the test did not produce the error expected above).\n+    assert_eq!(x, 2_i8);\n+}"}, {"sha": "c36a16f18f86e963ee0a7e57d2a9b2397b61e069", "filename": "src/test/run-fail/overflowing-rsh-1.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-1.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = -1_i32 >> id(32);\n+}"}, {"sha": "f619ebe9fb4a60ca9241d15f3133f2a420b9b739", "filename": "src/test/run-fail/overflowing-rsh-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-2.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = -1_i32 >> id(-1);\n+}"}, {"sha": "c261e195fd71ebe3b39d72f35418aa05446639fc", "filename": "src/test/run-fail/overflowing-rsh-3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-3.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let _x = -1_i64 >> id(64);\n+}"}, {"sha": "6e79a13d4e133ba93deb5ca86a3c8e449b60fa7c", "filename": "src/test/run-fail/overflowing-rsh-4.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Foverflowing-rsh-4.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// error-pattern:thread '<main>' panicked at 'shift operation overflowed'\n+// compile-flags: -C debug-assertions\n+\n+// This function is checking that our (type-based) automatic\n+// truncation does not sidestep the overflow checking.\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    // this signals overflow when checking is on\n+    let x = 2_i8 >> id(17);\n+\n+    // ... but when checking is off, the fallback will truncate the\n+    // input to its lower three bits (= 1). Note that this is *not*\n+    // the behavior of the x86 processor for 8- and 16-bit types,\n+    // but it is necessary to avoid undefined behavior from LLVM.\n+    //\n+    // We check that here, by ensuring the result is not zero; if\n+    // overflow checking is turned off, then this assertion will pass\n+    // (and the compiletest driver will report that the test did not\n+    // produce the error expected above).\n+    assert_eq!(x, 1_i8);\n+}"}, {"sha": "c2b42ac1c8163a5b4667a07ec8898b23bbcd479c", "filename": "src/test/run-pass/over-constrained-vregs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fover-constrained-vregs.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -11,7 +11,7 @@\n // Regression test for issue #152.\n pub fn main() {\n     let mut b: uint = 1_usize;\n-    while b <= 32_usize {\n+    while b < std::mem::size_of::<usize>() {\n         0_usize << b;\n         b <<= 1_usize;\n         println!(\"{}\", b);"}, {"sha": "4ff058f336661253f4a2f07380ec3cdd1a815d36", "filename": "src/test/run-pass/shift-near-oflo.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-pass%2Fshift-near-oflo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28a0b25f424090255966273994748a9f9901059f/src%2Ftest%2Frun-pass%2Fshift-near-oflo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshift-near-oflo.rs?ref=28a0b25f424090255966273994748a9f9901059f", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C debug-assertions\n+\n+// Check that we do *not* overflow on a number of edge cases.\n+// (compare with test/run-fail/overflowing-{lsh,rsh}*.rs)\n+\n+// (Work around constant-evaluation)\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    test_left_shift();\n+    test_right_shift();\n+}\n+\n+fn test_left_shift() {\n+    // negative rhs can panic, but values in [0,N-1] are okay for iN\n+\n+    macro_rules! tests {\n+        ($iN:ty, $uN:ty, $max_rhs:expr, $expect_i:expr, $expect_u:expr) => { {\n+            let x = (1 as $iN) << id(0);\n+            assert_eq!(x, 1);\n+            let x = (1 as $uN) << id(0);\n+            assert_eq!(x, 1);\n+            let x = (1 as $iN) << id($max_rhs);\n+            assert_eq!(x, $expect_i);\n+            let x = (1 as $uN) << id($max_rhs);\n+            assert_eq!(x, $expect_u);\n+            // high-order bits on LHS are silently discarded without panic.\n+            let x = (3 as $iN) << id($max_rhs);\n+            assert_eq!(x, $expect_i);\n+            let x = (3 as $uN) << id($max_rhs);\n+            assert_eq!(x, $expect_u);\n+        } }\n+    }\n+\n+    let x = 1_i8 << id(0);\n+    assert_eq!(x, 1);\n+    let x = 1_u8 << id(0);\n+    assert_eq!(x, 1);\n+    let x = 1_i8 << id(7);\n+    assert_eq!(x, std::i8::MIN);\n+    let x = 1_u8 << id(7);\n+    assert_eq!(x, 0x80);\n+    // high-order bits on LHS are silently discarded without panic.\n+    let x = 3_i8 << id(7);\n+    assert_eq!(x, std::i8::MIN);\n+    let x = 3_u8 << id(7);\n+    assert_eq!(x, 0x80);\n+\n+    // above is (approximately) expanded from:\n+    tests!(i8, u8, 7, std::i8::MIN, 0x80_u8);\n+\n+    tests!(i16, u16, 15, std::i16::MIN, 0x8000_u16);\n+    tests!(i32, u32, 31, std::i32::MIN, 0x8000_0000_u32);\n+    tests!(i64, u64, 63, std::i64::MIN, 0x8000_0000_0000_0000_u64);\n+}\n+\n+fn test_right_shift() {\n+    // negative rhs can panic, but values in [0,N-1] are okay for iN\n+\n+    macro_rules! tests {\n+        ($iN:ty, $uN:ty, $max_rhs:expr,\n+         $signbit_i:expr, $highbit_i:expr, $highbit_u:expr) =>\n+        { {\n+            let x = (1 as $iN) >> id(0);\n+            assert_eq!(x, 1);\n+            let x = (1 as $uN) >> id(0);\n+            assert_eq!(x, 1);\n+            let x = ($highbit_i) >> id($max_rhs-1);\n+            assert_eq!(x, 1);\n+            let x = ($highbit_u) >> id($max_rhs);\n+            assert_eq!(x, 1);\n+            // sign-bit is carried by arithmetic right shift\n+            let x = ($signbit_i) >> id($max_rhs);\n+            assert_eq!(x, -1);\n+            // low-order bits on LHS are silently discarded without panic.\n+            let x = ($highbit_i + 1) >> id($max_rhs-1);\n+            assert_eq!(x, 1);\n+            let x = ($highbit_u + 1) >> id($max_rhs);\n+            assert_eq!(x, 1);\n+            let x = ($signbit_i + 1) >> id($max_rhs);\n+            assert_eq!(x, -1);\n+        } }\n+    }\n+\n+    tests!(i8, u8, 7, std::i8::MIN, 0x40_i8, 0x80_u8);\n+    tests!(i16, u16, 15, std::i16::MIN, 0x4000_u16, 0x8000_u16);\n+    tests!(i32, u32, 31, std::i32::MIN, 0x4000_0000_u32, 0x8000_0000_u32);\n+    tests!(i64, u64, 63, std::i64::MIN,\n+           0x4000_0000_0000_0000_u64, 0x8000_0000_0000_0000_u64);\n+}"}]}