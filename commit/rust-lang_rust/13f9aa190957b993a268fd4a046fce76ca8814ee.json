{"sha": "13f9aa190957b993a268fd4a046fce76ca8814ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZjlhYTE5MDk1N2I5OTNhMjY4ZmQ0YTA0NmZjZTc2Y2E4ODE0ZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-26T09:09:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-26T09:09:43Z"}, "message": "Auto merge of #74664 - pnadon:Miri-rename-undef-uninit, r=RalfJung\n\nMiri rename undef uninit\n\nRenamed parts of code within the `librustc_middle/mir/interpret/` directory.\n\nRelated issue [#71193](https://github.com/rust-lang/rust/issues/71193)", "tree": {"sha": "e3afb4f7850e5aba24cdfe044303d17a97c04daf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3afb4f7850e5aba24cdfe044303d17a97c04daf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13f9aa190957b993a268fd4a046fce76ca8814ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13f9aa190957b993a268fd4a046fce76ca8814ee", "html_url": "https://github.com/rust-lang/rust/commit/13f9aa190957b993a268fd4a046fce76ca8814ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13f9aa190957b993a268fd4a046fce76ca8814ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "461707c5a119cc33c5d7df585ddb6cbec4a081bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/461707c5a119cc33c5d7df585ddb6cbec4a081bf", "html_url": "https://github.com/rust-lang/rust/commit/461707c5a119cc33c5d7df585ddb6cbec4a081bf"}, {"sha": "ef9c4f5cef53c547b6f0af7c3049abb319368419", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9c4f5cef53c547b6f0af7c3049abb319368419", "html_url": "https://github.com/rust-lang/rust/commit/ef9c4f5cef53c547b6f0af7c3049abb319368419"}], "stats": {"total": 188, "additions": 94, "deletions": 94}, "files": [{"sha": "e8270b4fa0adba7b5802ef2bb95ff0b49b419b27", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -883,7 +883,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 let ptr = Pointer::new(AllocId(0), offset);\n                                 alloc\n                                     .read_scalar(&bx, ptr, size)\n-                                    .and_then(|s| s.not_undef())\n+                                    .and_then(|s| s.check_init())\n                                     .unwrap_or_else(|e| {\n                                         bx.tcx().sess.span_err(\n                                             span,"}, {"sha": "dd4fc7adff11785a5edc1246c41da16ddf14179b", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -105,7 +105,7 @@ impl<Tag> Allocation<Tag> {\n         Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n     }\n \n-    pub fn undef(size: Size, align: Align) -> Self {\n+    pub fn uninit(size: Size, align: Align) -> Self {\n         Allocation {\n             bytes: vec![0; size.bytes_usize()],\n             relocations: Relocations::new(),\n@@ -153,7 +153,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         self.size.bytes_usize()\n     }\n \n-    /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n     /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n     /// edges) at all. It further ignores `AllocationExtra` callbacks.\n     /// This must not be used for reads affecting the interpreter execution.\n@@ -192,7 +192,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         offset.bytes_usize()..end\n     }\n \n-    /// The last argument controls whether we error out when there are undefined\n+    /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n@@ -206,12 +206,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        check_defined_and_ptr: bool,\n+        check_init_and_ptr: bool,\n     ) -> InterpResult<'tcx, &[u8]> {\n         let range = self.check_bounds(ptr.offset, size);\n \n-        if check_defined_and_ptr {\n-            self.check_defined(ptr, size)?;\n+        if check_init_and_ptr {\n+            self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n             // We still don't want relocations on the *edges*.\n@@ -239,7 +239,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n-    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// It is the caller's responsibility to handle uninitialized and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -267,7 +267,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ) -> InterpResult<'tcx, &mut [u8]> {\n         let range = self.check_bounds(ptr.offset, size);\n \n-        self.mark_definedness(ptr, size, true);\n+        self.mark_init(ptr, size, true);\n         self.clear_relocations(cx, ptr, size)?;\n \n         AllocationExtra::memory_written(self, ptr, size)?;\n@@ -303,7 +303,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n-    /// given range contains neither relocations nor undef bytes.\n+    /// given range contains neither relocations nor uninitialized bytes.\n     pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -313,9 +313,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ) -> InterpResult<'tcx> {\n         // Check bounds and relocations on the edges.\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n-        // Check undef and ptr.\n+        // Check uninit and ptr.\n         if !allow_ptr_and_undef {\n-            self.check_defined(ptr, size)?;\n+            self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         }\n         Ok(())\n@@ -364,7 +364,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n-        if self.is_defined(ptr, size).is_err() {\n+        if self.is_init(ptr, size).is_err() {\n             // This inflates uninitialized bytes to the entire scalar, even if only a few\n             // bytes are uninitialized.\n             return Ok(ScalarMaybeUninit::Uninit);\n@@ -416,7 +416,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let val = match val {\n             ScalarMaybeUninit::Scalar(scalar) => scalar,\n             ScalarMaybeUninit::Uninit => {\n-                self.mark_definedness(ptr, type_size, false);\n+                self.mark_init(ptr, type_size, false);\n                 return Ok(());\n             }\n         };\n@@ -512,7 +512,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         let start = ptr.offset;\n         let end = start + size; // `Size` addition\n \n-        // Mark parts of the outermost relocations as undefined if they partially fall outside the\n+        // Mark parts of the outermost relocations as uninitialized if they partially fall outside the\n         // given range.\n         if first < start {\n             self.init_mask.set_range(first, start, false);\n@@ -542,20 +542,20 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Undefined bytes.\n+/// Uninitialized bytes.\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Checks whether the given range  is entirely defined.\n+    /// Checks whether the given range  is entirely initialized.\n     ///\n-    /// Returns `Ok(())` if it's defined. Otherwise returns the range of byte\n-    /// indexes of the first contiguous undefined access.\n-    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns the range of byte\n+    /// indexes of the first contiguous uninitialized access.\n+    fn is_init(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n         self.init_mask.is_range_initialized(ptr.offset, ptr.offset + size) // `Size` addition\n     }\n \n-    /// Checks that a range of bytes is defined. If not, returns the `InvalidUndefBytes`\n-    /// error which will report the first range of bytes which is undefined.\n-    fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        self.is_defined(ptr, size).or_else(|idx_range| {\n+    /// Checks that a range of bytes is initialized. If not, returns the `InvalidUninitBytes`\n+    /// error which will report the first range of bytes which is uninitialized.\n+    fn check_init(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n+        self.is_init(ptr, size).or_else(|idx_range| {\n             throw_ub!(InvalidUninitBytes(Some(Box::new(UninitBytesAccess {\n                 access_ptr: ptr.erase_tag(),\n                 access_size: size,\n@@ -565,44 +565,44 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         })\n     }\n \n-    pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n+    pub fn mark_init(&mut self, ptr: Pointer<Tag>, size: Size, is_init: bool) {\n         if size.bytes() == 0 {\n             return;\n         }\n-        self.init_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n+        self.init_mask.set_range(ptr.offset, ptr.offset + size, is_init);\n     }\n }\n \n-/// Run-length encoding of the undef mask.\n+/// Run-length encoding of the uninit mask.\n /// Used to copy parts of a mask multiple times to another allocation.\n-pub struct AllocationDefinedness {\n-    /// The definedness of the first range.\n+pub struct InitMaskCompressed {\n+    /// Whether the first range is initialized.\n     initial: bool,\n     /// The lengths of ranges that are run-length encoded.\n-    /// The definedness of the ranges alternate starting with `initial`.\n+    /// The initialization state of the ranges alternate starting with `initial`.\n     ranges: smallvec::SmallVec<[u64; 1]>,\n }\n \n-impl AllocationDefinedness {\n-    pub fn all_bytes_undef(&self) -> bool {\n-        // The `ranges` are run-length encoded and of alternating definedness.\n-        // So if `ranges.len() > 1` then the second block is a range of defined.\n+impl InitMaskCompressed {\n+    pub fn no_bytes_init(&self) -> bool {\n+        // The `ranges` are run-length encoded and of alternating initialization state.\n+        // So if `ranges.len() > 1` then the second block is an initialized range.\n         !self.initial && self.ranges.len() == 1\n     }\n }\n \n-/// Transferring the definedness mask to other allocations.\n+/// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n-    /// Creates a run-length encoding of the undef mask.\n-    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> AllocationDefinedness {\n+    /// Creates a run-length encoding of the initialization mask.\n+    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n-        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n         // we'd be doing all of this `repeat` times.\n-        // Therefore we precompute a compressed version of the undef mask of the source value and\n+        // Therefore we precompute a compressed version of the initialization mask of the source value and\n         // then write it back `repeat` times without computing any more information from the source.\n \n-        // A precomputed cache for ranges of defined/undefined bits\n+        // A precomputed cache for ranges of initialized / uninitialized bits\n         // 0000010010001110 will become\n         // `[5, 1, 2, 1, 3, 3, 1]`,\n         // where each element toggles the state.\n@@ -613,7 +613,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         let mut cur = initial;\n \n         for i in 1..size.bytes() {\n-            // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n+            // FIXME: optimize to bitshift the current uninitialized block's bits and read the top bit.\n             if self.init_mask.get(src.offset + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n@@ -625,13 +625,13 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n \n         ranges.push(cur_len);\n \n-        AllocationDefinedness { ranges, initial }\n+        InitMaskCompressed { ranges, initial }\n     }\n \n-    /// Applies multiple instances of the run-length encoding to the undef mask.\n-    pub fn mark_compressed_undef_range(\n+    /// Applies multiple instances of the run-length encoding to the initialization mask.\n+    pub fn mark_compressed_init_range(\n         &mut self,\n-        defined: &AllocationDefinedness,\n+        defined: &InitMaskCompressed,\n         dest: Pointer<Tag>,\n         size: Size,\n         repeat: u64,\n@@ -740,7 +740,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Undefined byte tracking\n+// Uninitialized byte tracking\n ////////////////////////////////////////////////////////////////////////////////\n \n type Block = u64;\n@@ -778,11 +778,11 @@ impl InitMask {\n \n         match idx {\n             Some(idx) => {\n-                let undef_end = (idx.bytes()..end.bytes())\n+                let uninit_end = (idx.bytes()..end.bytes())\n                     .map(Size::from_bytes)\n                     .find(|&i| self.get(i))\n                     .unwrap_or(end);\n-                Err(idx..undef_end)\n+                Err(idx..uninit_end)\n             }\n             None => Ok(()),\n         }"}, {"sha": "9de2d17457ab16e1d9172dc87a95ca4a0936eeaa", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -606,7 +606,7 @@ impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n     }\n \n     #[inline]\n-    pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n+    pub fn check_init(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUninit::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUninit::Uninit => throw_ub!(InvalidUninitBytes(None)),\n@@ -615,72 +615,72 @@ impl<'tcx, Tag> ScalarMaybeUninit<Tag> {\n \n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n-        self.not_undef()?.to_bool()\n+        self.check_init()?.to_bool()\n     }\n \n     #[inline(always)]\n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n-        self.not_undef()?.to_char()\n+        self.check_init()?.to_char()\n     }\n \n     #[inline(always)]\n     pub fn to_f32(self) -> InterpResult<'tcx, Single> {\n-        self.not_undef()?.to_f32()\n+        self.check_init()?.to_f32()\n     }\n \n     #[inline(always)]\n     pub fn to_f64(self) -> InterpResult<'tcx, Double> {\n-        self.not_undef()?.to_f64()\n+        self.check_init()?.to_f64()\n     }\n \n     #[inline(always)]\n     pub fn to_u8(self) -> InterpResult<'tcx, u8> {\n-        self.not_undef()?.to_u8()\n+        self.check_init()?.to_u8()\n     }\n \n     #[inline(always)]\n     pub fn to_u16(self) -> InterpResult<'tcx, u16> {\n-        self.not_undef()?.to_u16()\n+        self.check_init()?.to_u16()\n     }\n \n     #[inline(always)]\n     pub fn to_u32(self) -> InterpResult<'tcx, u32> {\n-        self.not_undef()?.to_u32()\n+        self.check_init()?.to_u32()\n     }\n \n     #[inline(always)]\n     pub fn to_u64(self) -> InterpResult<'tcx, u64> {\n-        self.not_undef()?.to_u64()\n+        self.check_init()?.to_u64()\n     }\n \n     #[inline(always)]\n     pub fn to_machine_usize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, u64> {\n-        self.not_undef()?.to_machine_usize(cx)\n+        self.check_init()?.to_machine_usize(cx)\n     }\n \n     #[inline(always)]\n     pub fn to_i8(self) -> InterpResult<'tcx, i8> {\n-        self.not_undef()?.to_i8()\n+        self.check_init()?.to_i8()\n     }\n \n     #[inline(always)]\n     pub fn to_i16(self) -> InterpResult<'tcx, i16> {\n-        self.not_undef()?.to_i16()\n+        self.check_init()?.to_i16()\n     }\n \n     #[inline(always)]\n     pub fn to_i32(self) -> InterpResult<'tcx, i32> {\n-        self.not_undef()?.to_i32()\n+        self.check_init()?.to_i32()\n     }\n \n     #[inline(always)]\n     pub fn to_i64(self) -> InterpResult<'tcx, i64> {\n-        self.not_undef()?.to_i64()\n+        self.check_init()?.to_i64()\n     }\n \n     #[inline(always)]\n     pub fn to_machine_isize(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, i64> {\n-        self.not_undef()?.to_machine_isize(cx)\n+        self.check_init()?.to_machine_isize(cx)\n     }\n }\n "}, {"sha": "42fba8982d23c3d0c91f1bd9771bf13904120699", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -154,7 +154,7 @@ pub(super) fn op_to_const<'tcx>(\n                 ScalarMaybeUninit::Uninit => to_const_value(op.assert_mem_place(ecx)),\n             },\n             Immediate::ScalarPair(a, b) => {\n-                let (data, start) = match a.not_undef().unwrap() {\n+                let (data, start) = match a.check_init().unwrap() {\n                     Scalar::Ptr(ptr) => {\n                         (ecx.tcx.global_alloc(ptr.alloc_id).unwrap_memory(), ptr.offset.bytes())\n                     }"}, {"sha": "39ed3b607934b2a0f10f701845a95cea5d35f831", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -150,7 +150,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             | sym::bitreverse => {\n                 let ty = substs.type_at(0);\n                 let layout_of = self.layout_of(ty)?;\n-                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let val = self.read_scalar(args[0])?.check_init()?;\n                 let bits = self.force_bits(val, layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     Abi::Scalar(ref scalar) => scalar.value,\n@@ -281,9 +281,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // rotate_left: (X << (S % BW)) | (X >> ((BW - S) % BW))\n                 // rotate_right: (X << ((BW - S) % BW)) | (X >> (S % BW))\n                 let layout = self.layout_of(substs.type_at(0))?;\n-                let val = self.read_scalar(args[0])?.not_undef()?;\n+                let val = self.read_scalar(args[0])?.check_init()?;\n                 let val_bits = self.force_bits(val, layout.size)?;\n-                let raw_shift = self.read_scalar(args[1])?.not_undef()?;\n+                let raw_shift = self.read_scalar(args[1])?.check_init()?;\n                 let raw_shift_bits = self.force_bits(raw_shift, layout.size)?;\n                 let width_bits = u128::from(layout.size.bits());\n                 let shift_bits = raw_shift_bits % width_bits;\n@@ -298,15 +298,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(result, dest)?;\n             }\n             sym::offset => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.check_init()?;\n                 let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n \n                 let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n                 self.write_scalar(offset_ptr, dest)?;\n             }\n             sym::arith_offset => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let ptr = self.read_scalar(args[0])?.check_init()?;\n                 let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n                 let pointee_ty = substs.type_at(0);\n "}, {"sha": "39d2df968341c4208ba56715759fa428117b6670", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -171,7 +171,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n-        let alloc = Allocation::undef(size, align);\n+        let alloc = Allocation::uninit(size, align);\n         self.allocate_with(alloc, kind)\n     }\n \n@@ -907,18 +907,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let dest_bytes = dest_bytes.as_mut_ptr();\n \n-        // Prepare a copy of the undef mask.\n+        // Prepare a copy of the initialization mask.\n         let compressed = self.get_raw(src.alloc_id)?.compress_undef_range(src, size);\n \n-        if compressed.all_bytes_undef() {\n-            // Fast path: If all bytes are `undef` then there is nothing to copy. The target range\n-            // is marked as undef but we otherwise omit changing the byte representation which may\n-            // be arbitrary for undef bytes.\n+        if compressed.no_bytes_init() {\n+            // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n+            // is marked as unititialized but we otherwise omit changing the byte representation which may\n+            // be arbitrary for uninitialized bytes.\n             // This also avoids writing to the target bytes so that the backing allocation is never\n-            // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n+            // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n             let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_definedness(dest, size * length, false); // `Size` multiplication\n+            dest_alloc.mark_init(dest, size * length, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -958,7 +958,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // now fill in all the data\n-        self.get_raw_mut(dest.alloc_id)?.mark_compressed_undef_range(\n+        self.get_raw_mut(dest.alloc_id)?.mark_compressed_init_range(\n             &compressed,\n             dest,\n             size,"}, {"sha": "9f86f2bc588fc86b07fda021af3b9f3b7e48f5ae", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -63,7 +63,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_or_undef(self) -> ScalarMaybeUninit<Tag> {\n+    pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a wide pointer where a scalar was expected\"),\n@@ -72,14 +72,14 @@ impl<'tcx, Tag> Immediate<Tag> {\n \n     #[inline]\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.to_scalar_or_undef().not_undef()\n+        self.to_scalar_or_uninit().check_init()\n     }\n \n     #[inline]\n     pub fn to_scalar_pair(self) -> InterpResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n         match self {\n             Immediate::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n-            Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?)),\n+            Immediate::ScalarPair(a, b) => Ok((a.check_init()?, b.check_init()?)),\n         }\n     }\n }\n@@ -333,7 +333,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n-        Ok(self.read_immediate(op)?.to_scalar_or_undef())\n+        Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n     }\n \n     // Turn the wide MPlace into a string (must already be dereferenced!)"}, {"sha": "80a5e56059d0906b0a6cee559bb7ad644a61c460", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -292,9 +292,9 @@ where\n             val.layout.ty.builtin_deref(true).expect(\"`ref_to_mplace` called on non-ptr type\").ty;\n         let layout = self.layout_of(pointee_type)?;\n         let (ptr, meta) = match *val {\n-            Immediate::Scalar(ptr) => (ptr.not_undef()?, MemPlaceMeta::None),\n+            Immediate::Scalar(ptr) => (ptr.check_init()?, MemPlaceMeta::None),\n             Immediate::ScalarPair(ptr, meta) => {\n-                (ptr.not_undef()?, MemPlaceMeta::Meta(meta.not_undef()?))\n+                (ptr.check_init()?, MemPlaceMeta::Meta(meta.check_init()?))\n             }\n         };\n \n@@ -541,7 +541,7 @@ where\n                 let n = self.access_local(self.frame(), local, Some(layout))?;\n                 let n = self.read_scalar(n)?;\n                 let n = u64::try_from(\n-                    self.force_bits(n.not_undef()?, self.tcx.data_layout.pointer_size)?,\n+                    self.force_bits(n.check_init()?, self.tcx.data_layout.pointer_size)?,\n                 )\n                 .unwrap();\n                 self.mplace_index(base, n)?"}, {"sha": "9a036a0f299e47bd7c6621b91b58f3c1496bd289", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -58,7 +58,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, abi) = match func.layout.ty.kind {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.read_scalar(func)?.not_undef()?;\n+                        let fn_ptr = self.read_scalar(func)?.check_init()?;\n                         let fn_val = self.memory.get_fn(fn_ptr)?;\n                         (fn_val, caller_abi)\n                     }"}, {"sha": "589da04d6a387468b50049143057e67821b7ce4f", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -118,7 +118,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .memory\n             .get_raw(vtable_slot.alloc_id)?\n             .read_ptr_sized(self, vtable_slot)?\n-            .not_undef()?;\n+            .check_init()?;\n         Ok(self.memory.get_fn(fn_ptr)?)\n     }\n \n@@ -137,7 +137,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )?\n             .expect(\"cannot be a ZST\");\n         let drop_fn =\n-            self.memory.get_raw(vtable.alloc_id)?.read_ptr_sized(self, vtable)?.not_undef()?;\n+            self.memory.get_raw(vtable.alloc_id)?.read_ptr_sized(self, vtable)?.check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n         let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n@@ -165,10 +165,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_ptr_access(vtable, 3 * pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n         let alloc = self.memory.get_raw(vtable.alloc_id)?;\n-        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.not_undef()?;\n+        let size = alloc.read_ptr_sized(self, vtable.offset(pointer_size, self)?)?.check_init()?;\n         let size = u64::try_from(self.force_bits(size, pointer_size)?).unwrap();\n         let align =\n-            alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.not_undef()?;\n+            alloc.read_ptr_sized(self, vtable.offset(pointer_size * 2, self)?)?.check_init()?;\n         let align = u64::try_from(self.force_bits(align, pointer_size)?).unwrap();\n \n         if size >= self.tcx.data_layout.obj_size_bound() {"}, {"sha": "f1c5a67ed33f163ae497fa022d80492f78891f9d", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -500,7 +500,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // types below!\n                 if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n-                    let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n+                    let is_bits = value.check_init().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n                         throw_validation_failure!(self.path,\n                             { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n@@ -537,7 +537,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             ty::FnPtr(_sig) => {\n                 let value = self.ecx.read_scalar(value)?;\n                 let _fn = try_validation!(\n-                    value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n+                    value.check_init().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n                     self.path,\n                     err_ub!(DanglingIntPointer(..)) |\n                     err_ub!(InvalidFunctionPointer(..)) |\n@@ -596,7 +596,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         }\n         // At least one value is excluded. Get the bits.\n         let value = try_validation!(\n-            value.not_undef(),\n+            value.check_init(),\n             self.path,\n             err_ub!(InvalidUninitBytes(None)) => { \"{}\", value }\n                 expected { \"something {}\", wrapping_range_format(valid_range, max_hi) },"}, {"sha": "3202f7d1b1b88a036598e159d7c37c7a5c88c40c", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f9aa190957b993a268fd4a046fce76ca8814ee/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=13f9aa190957b993a268fd4a046fce76ca8814ee", "patch": "@@ -2614,7 +2614,7 @@ fn specialize_one_pattern<'p, 'tcx>(\n             let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n                 let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n                 let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                let scalar = scalar.not_undef().ok()?;\n+                let scalar = scalar.check_init().ok()?;\n                 let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n                 let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n                 Some(pattern)"}]}