{"sha": "708a81809498780760d6992ee86dd0aa47d32bde", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwOGE4MTgwOTQ5ODc4MDc2MGQ2OTkyZWU4NmRkMGFhNDdkMzJiZGU=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2017-09-16T07:16:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-09-16T07:16:55Z"}, "message": "Merge pull request #2057 from topecongiro/issue-1818\n\nEnhance CHARS_*_CMP lint", "tree": {"sha": "026e30e05a3a088373361434ba3cc62613cda28a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/026e30e05a3a088373361434ba3cc62613cda28a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/708a81809498780760d6992ee86dd0aa47d32bde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/708a81809498780760d6992ee86dd0aa47d32bde", "html_url": "https://github.com/rust-lang/rust/commit/708a81809498780760d6992ee86dd0aa47d32bde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/708a81809498780760d6992ee86dd0aa47d32bde/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "013b1f5923c848b7ab99168b4df9d69fb36ee5bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/013b1f5923c848b7ab99168b4df9d69fb36ee5bc", "html_url": "https://github.com/rust-lang/rust/commit/013b1f5923c848b7ab99168b4df9d69fb36ee5bc"}, {"sha": "d5d300c0349c350db13009a4889dbcee3e1a509b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5d300c0349c350db13009a4889dbcee3e1a509b", "html_url": "https://github.com/rust-lang/rust/commit/d5d300c0349c350db13009a4889dbcee3e1a509b"}], "stats": {"total": 261, "additions": 248, "deletions": 13}, "files": [{"sha": "b36e1851d0de4acdc5bc0497f6af06d56cbe4c75", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 119, "deletions": 12, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/708a81809498780760d6992ee86dd0aa47d32bde/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/708a81809498780760d6992ee86dd0aa47d32bde/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=708a81809498780760d6992ee86dd0aa47d32bde", "patch": "@@ -7,6 +7,7 @@ use rustc::ty::subst::Substs;\n use rustc_const_eval::ConstContext;\n use std::borrow::Cow;\n use std::fmt;\n+use syntax::ast;\n use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, is_self, is_self_ty,\n             iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method,\n@@ -544,6 +545,24 @@ declare_lint! {\n     \"using `.cloned().collect()` on slice to create a `Vec`\"\n }\n \n+/// **What it does:** Checks for usage of `.chars().last()` or\n+/// `.chars().next_back()` on a `str` to check if it ends with a given char.\n+///\n+/// **Why is this bad?** Readability, this can be written more concisely as\n+/// `_.ends_with(_)`.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust\n+/// name.chars().last() == Some('_') || name.chars().next_back() == Some('-')\n+/// ```\n+declare_lint! {\n+    pub CHARS_LAST_CMP,\n+    Warn,\n+    \"using `.chars().last()` or `.chars().next_back()` to check if a string ends with a char\"\n+}\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n@@ -557,6 +576,7 @@ impl LintPass for Pass {\n             OPTION_MAP_UNWRAP_OR_ELSE,\n             OR_FUN_CALL,\n             CHARS_NEXT_CMP,\n+            CHARS_LAST_CMP,\n             CLONE_ON_COPY,\n             CLONE_ON_REF_PTR,\n             CLONE_DOUBLE_REF,\n@@ -648,9 +668,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                 }\n             },\n             hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n-                if !lint_chars_next(cx, expr, lhs, rhs, op.node == hir::BiEq) {\n-                    lint_chars_next(cx, expr, rhs, lhs, op.node == hir::BiEq);\n-                }\n+                let mut info = BinaryExprInfo {\n+                    expr: expr,\n+                    chain: lhs,\n+                    other: rhs,\n+                    eq: op.node == hir::BiEq,\n+                };\n+                lint_binary_expr_with_method_call(cx, &mut info);\n             },\n             _ => (),\n         }\n@@ -1285,11 +1309,39 @@ fn lint_search_is_some<'a, 'tcx>(\n     }\n }\n \n-/// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, chain: &'tcx hir::Expr, other: &'tcx hir::Expr, eq: bool) -> bool {\n+/// Used for `lint_binary_expr_with_method_call`.\n+#[derive(Copy, Clone)]\n+struct BinaryExprInfo<'a> {\n+    expr: &'a hir::Expr,\n+    chain: &'a hir::Expr,\n+    other: &'a hir::Expr,\n+    eq: bool,\n+}\n+\n+/// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n+fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, info: &mut BinaryExprInfo) {\n+    macro_rules! lint_with_both_lhs_and_rhs {\n+        ($func:ident, $cx:expr, $info:ident) => {\n+            if !$func($cx, $info) {\n+                ::std::mem::swap(&mut $info.chain, &mut $info.other);\n+                if $func($cx, $info) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp, cx, info);\n+    lint_with_both_lhs_and_rhs!(lint_chars_last_cmp, cx, info);\n+    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp_with_unwrap, cx, info);\n+    lint_with_both_lhs_and_rhs!(lint_chars_last_cmp_with_unwrap, cx, info);\n+}\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n+fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n     if_let_chain! {[\n-        let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n-        let hir::ExprCall(ref fun, ref arg_char) = other.node,\n+        let Some(args) = method_chain_args(info.chain, chain_methods),\n+        let hir::ExprCall(ref fun, ref arg_char) = info.other.node,\n         arg_char.len() == 1,\n         let hir::ExprPath(ref qpath) = fun.node,\n         let Some(segment) = single_segment_path(qpath),\n@@ -1302,13 +1354,14 @@ fn lint_chars_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n         }\n \n         span_lint_and_sugg(cx,\n-                           CHARS_NEXT_CMP,\n-                           expr.span,\n-                           \"you should use the `starts_with` method\",\n+                           lint,\n+                           info.expr.span,\n+                           &format!(\"you should use the `{}` method\", suggest),\n                            \"like this\",\n-                           format!(\"{}{}.starts_with({})\",\n-                                   if eq { \"\" } else { \"!\" },\n+                           format!(\"{}{}.{}({})\",\n+                                   if info.eq { \"\" } else { \"!\" },\n                                    snippet(cx, args[0][0].span, \"_\"),\n+                                   suggest,\n                                    snippet(cx, arg_char[0].span, \"_\")));\n \n         return true;\n@@ -1317,6 +1370,60 @@ fn lint_chars_next<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr,\n     false\n }\n \n+/// Checks for the `CHARS_NEXT_CMP` lint.\n+fn lint_chars_next_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n+}\n+\n+/// Checks for the `CHARS_LAST_CMP` lint.\n+fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_NEXT_CMP, \"ends_with\") {\n+        true\n+    } else {\n+        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_NEXT_CMP, \"ends_with\")\n+    }\n+}\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n+fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n+    if_let_chain! {[\n+        let Some(args) = method_chain_args(info.chain, chain_methods),\n+        let hir::ExprLit(ref lit) = info.other.node,\n+        let ast::LitKind::Char(c) = lit.node,\n+    ], {\n+        span_lint_and_sugg(\n+            cx,\n+            lint,\n+            info.expr.span,\n+            &format!(\"you should use the `{}` method\", suggest),\n+            \"like this\",\n+            format!(\"{}{}.{}('{}')\",\n+                    if info.eq { \"\" } else { \"!\" },\n+                    snippet(cx, args[0][0].span, \"_\"),\n+                    suggest,\n+                    c)\n+        );\n+\n+        return true;\n+    }}\n+\n+    false\n+}\n+\n+/// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n+fn lint_chars_next_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n+}\n+\n+/// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n+fn lint_chars_last_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo) -> bool {\n+    if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n+        true\n+    } else {\n+        lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next_back\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\")\n+    }\n+}\n+\n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n fn lint_single_char_pattern<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, arg: &'tcx hir::Expr) {\n     let parent_item = cx.tcx.hir.get_parent(arg.id);"}, {"sha": "48132cc662cc5905a58632513dc8588c4dcd0af3", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/708a81809498780760d6992ee86dd0aa47d32bde/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/708a81809498780760d6992ee86dd0aa47d32bde/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=708a81809498780760d6992ee86dd0aa47d32bde", "patch": "@@ -547,3 +547,33 @@ fn iter_clone_collect() {\n     let v3 : HashSet<isize> = v.iter().cloned().collect();\n     let v4 : VecDeque<isize> = v.iter().cloned().collect();\n }\n+\n+fn chars_cmp_with_unwrap() {\n+    let s = String::from(\"foo\");\n+    if s.chars().next().unwrap() == 'f' { // s.starts_with('f')\n+        // Nothing here\n+    }\n+    if s.chars().next_back().unwrap() == 'o' { // s.ends_with('o')\n+        // Nothing here\n+    }\n+    if s.chars().last().unwrap() == 'o' { // s.ends_with('o')\n+        // Nothing here\n+    }\n+    if s.chars().next().unwrap() != 'f' { // !s.starts_with('f')\n+        // Nothing here\n+    }\n+    if s.chars().next_back().unwrap() != 'o' { // !s.ends_with('o')\n+        // Nothing here\n+    }\n+    if s.chars().last().unwrap() != 'o' { // !s.ends_with('o')\n+        // Nothing here\n+    }\n+}\n+\n+#[allow(unnecessary_operation)]\n+fn ends_with() {\n+    \"\".chars().last() == Some(' ');\n+    Some(' ') != \"\".chars().last();\n+    \"\".chars().next_back() == Some(' ');\n+    Some(' ') != \"\".chars().next_back();\n+}"}, {"sha": "7f3d505a3cd22d6fe64d60b432d858face2804c8", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/708a81809498780760d6992ee86dd0aa47d32bde/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/708a81809498780760d6992ee86dd0aa47d32bde/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=708a81809498780760d6992ee86dd0aa47d32bde", "patch": "@@ -738,5 +738,103 @@ error: called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec\n     |\n     = note: `-D iter-cloned-collect` implied by `-D warnings`\n \n-error: aborting due to 107 previous errors\n+error: you should use the `starts_with` method\n+   --> $DIR/methods.rs:553:8\n+    |\n+553 |     if s.chars().next().unwrap() == 'f' { // s.starts_with('f')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `s.starts_with('f')`\n+\n+error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n+   --> $DIR/methods.rs:553:8\n+    |\n+553 |     if s.chars().next().unwrap() == 'f' { // s.starts_with('f')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:556:8\n+    |\n+556 |     if s.chars().next_back().unwrap() == 'o' { // s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `s.ends_with('o')`\n+    |\n+    = note: `-D chars-last-cmp` implied by `-D warnings`\n+\n+error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n+   --> $DIR/methods.rs:556:8\n+    |\n+556 |     if s.chars().next_back().unwrap() == 'o' { // s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:559:8\n+    |\n+559 |     if s.chars().last().unwrap() == 'o' { // s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `s.ends_with('o')`\n+\n+error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n+   --> $DIR/methods.rs:559:8\n+    |\n+559 |     if s.chars().last().unwrap() == 'o' { // s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: you should use the `starts_with` method\n+   --> $DIR/methods.rs:562:8\n+    |\n+562 |     if s.chars().next().unwrap() != 'f' { // !s.starts_with('f')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.starts_with('f')`\n+\n+error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n+   --> $DIR/methods.rs:562:8\n+    |\n+562 |     if s.chars().next().unwrap() != 'f' { // !s.starts_with('f')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:565:8\n+    |\n+565 |     if s.chars().next_back().unwrap() != 'o' { // !s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.ends_with('o')`\n+\n+error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n+   --> $DIR/methods.rs:565:8\n+    |\n+565 |     if s.chars().next_back().unwrap() != 'o' { // !s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:568:8\n+    |\n+568 |     if s.chars().last().unwrap() != 'o' { // !s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!s.ends_with('o')`\n+\n+error: used unwrap() on an Option value. If you don't want to handle the None case gracefully, consider using expect() to provide a better panic message\n+   --> $DIR/methods.rs:568:8\n+    |\n+568 |     if s.chars().last().unwrap() != 'o' { // !s.ends_with('o')\n+    |        ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:575:5\n+    |\n+575 |     \"\".chars().last() == Some(' ');\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `\"\".ends_with(' ')`\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:576:5\n+    |\n+576 |     Some(' ') != \"\".chars().last();\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".ends_with(' ')`\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:577:5\n+    |\n+577 |     \"\".chars().next_back() == Some(' ');\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `\"\".ends_with(' ')`\n+\n+error: you should use the `ends_with` method\n+   --> $DIR/methods.rs:578:5\n+    |\n+578 |     Some(' ') != \"\".chars().next_back();\n+    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: like this: `!\"\".ends_with(' ')`\n+\n+error: aborting due to 123 previous errors\n "}]}