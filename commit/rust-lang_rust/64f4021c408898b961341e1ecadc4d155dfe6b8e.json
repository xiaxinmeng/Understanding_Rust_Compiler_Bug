{"sha": "64f4021c408898b961341e1ecadc4d155dfe6b8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0ZjQwMjFjNDA4ODk4Yjk2MTM0MWUxZWNhZGM0ZDE1NWRmZTZiOGU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T15:50:28Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-10T16:26:58Z"}, "message": "copy-editing: if\n\nI decided to break if-let out, as it's too complex for this part, but moving\nif that late seems silly too.", "tree": {"sha": "2299a88e24baa742ef0f4b047d039e3e8f01b839", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2299a88e24baa742ef0f4b047d039e3e8f01b839"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f4021c408898b961341e1ecadc4d155dfe6b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f4021c408898b961341e1ecadc4d155dfe6b8e", "html_url": "https://github.com/rust-lang/rust/commit/64f4021c408898b961341e1ecadc4d155dfe6b8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f4021c408898b961341e1ecadc4d155dfe6b8e/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b4bb9fb0cb4bfe004ea0eff4ab1a4a9349ec93", "url": "https://api.github.com/repos/rust-lang/rust/commits/04b4bb9fb0cb4bfe004ea0eff4ab1a4a9349ec93", "html_url": "https://github.com/rust-lang/rust/commit/04b4bb9fb0cb4bfe004ea0eff4ab1a4a9349ec93"}], "stats": {"total": 110, "additions": 15, "deletions": 95}, "files": [{"sha": "29210fa6c163daabc9fa67e09912833ff7203569", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64f4021c408898b961341e1ecadc4d155dfe6b8e/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/64f4021c408898b961341e1ecadc4d155dfe6b8e/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=64f4021c408898b961341e1ecadc4d155dfe6b8e", "patch": "@@ -41,6 +41,7 @@\n     * [Traits](traits.md)\n     * [Operators and Overloading](operators-and-overloading.md)\n     * [Generics](generics.md)\n+    * [if let](if-let.md)\n     * [Trait Objects](trait-objects.md)\n     * [Closures](closures.md)\n     * [Universal Function Call Syntax](ufcs.md)"}, {"sha": "9e010b020c1810faa30811880c72672a681eb906", "filename": "src/doc/trpl/if-let.md", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64f4021c408898b961341e1ecadc4d155dfe6b8e/src%2Fdoc%2Ftrpl%2Fif-let.md", "raw_url": "https://github.com/rust-lang/rust/raw/64f4021c408898b961341e1ecadc4d155dfe6b8e/src%2Fdoc%2Ftrpl%2Fif-let.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif-let.md?ref=64f4021c408898b961341e1ecadc4d155dfe6b8e", "patch": "@@ -0,0 +1,3 @@\n+% if let\n+\n+COMING SOON"}, {"sha": "a532dabf8d12d894a7b9f13e7d6081d7b2f2040e", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 11, "deletions": 95, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/64f4021c408898b961341e1ecadc4d155dfe6b8e/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/64f4021c408898b961341e1ecadc4d155dfe6b8e/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=64f4021c408898b961341e1ecadc4d155dfe6b8e", "patch": "@@ -1,10 +1,10 @@\n % if\n \n-Rust's take on `if` is not particularly complex, but it's much more like the\n-`if` you'll find in a dynamically typed language than in a more traditional\n-systems language. So let's talk about it, to make sure you grasp the nuances.\n+Rust\u2019s take on `if` is not particularly complex, but it\u2019s much more like the\n+`if` you\u2019ll find in a dynamically typed language than in a more traditional\n+systems language. So let\u2019s talk about it, to make sure you grasp the nuances.\n \n-`if` is a specific form of a more general concept, the *branch*. The name comes\n+`if` is a specific form of a more general concept, the \u2018branch\u2019. The name comes\n from a branch in a tree: a decision point, where depending on a choice,\n multiple paths can be taken.\n \n@@ -20,11 +20,11 @@ if x == 5 {\n \n If we changed the value of `x` to something else, this line would not print.\n More specifically, if the expression after the `if` evaluates to `true`, then\n-the block is executed. If it's `false`, then it is not.\n+the block is executed. If it\u2019s `false`, then it is not.\n \n If you want something to happen in the `false` case, use an `else`:\n \n-```{rust}\n+```rust\n let x = 5;\n \n if x == 5 {\n@@ -50,8 +50,7 @@ if x == 5 {\n \n This is all pretty standard. However, you can also do this:\n \n-\n-```{rust}\n+```rust\n let x = 5;\n \n let y = if x == 5 {\n@@ -63,95 +62,12 @@ let y = if x == 5 {\n \n Which we can (and probably should) write like this:\n \n-```{rust}\n+```rust\n let x = 5;\n \n let y = if x == 5 { 10 } else { 15 }; // y: i32\n ```\n \n-This reveals two interesting things about Rust: it is an expression-based\n-language, and semicolons are different from semicolons in other 'curly brace\n-and semicolon'-based languages. These two things are related.\n-\n-## Expressions vs. Statements\n-\n-Rust is primarily an expression based language. There are only two kinds of\n-statements, and everything else is an expression.\n-\n-So what's the difference? Expressions return a value, and statements do not.\n-In many languages, `if` is a statement, and therefore, `let x = if ...` would\n-make no sense. But in Rust, `if` is an expression, which means that it returns\n-a value. We can then use this value to initialize the binding.\n-\n-Speaking of which, bindings are a kind of the first of Rust's two statements.\n-The proper name is a *declaration statement*. So far, `let` is the only kind\n-of declaration statement we've seen. Let's talk about that some more.\n-\n-In some languages, variable bindings can be written as expressions, not just\n-statements. Like Ruby:\n-\n-```{ruby}\n-x = y = 5\n-```\n-\n-In Rust, however, using `let` to introduce a binding is _not_ an expression. The\n-following will produce a compile-time error:\n-\n-```{ignore}\n-let x = (let y = 5); // expected identifier, found keyword `let`\n-```\n-\n-The compiler is telling us here that it was expecting to see the beginning of\n-an expression, and a `let` can only begin a statement, not an expression.\n-\n-Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n-expression, although its value is not particularly useful. Unlike C, where an\n-assignment evaluates to the assigned value (e.g. `5` in the previous example),\n-in Rust the value of an assignment is the unit type `()` (which we'll cover later).\n-\n-The second kind of statement in Rust is the *expression statement*. Its\n-purpose is to turn any expression into a statement. In practical terms, Rust's\n-grammar expects statements to follow other statements. This means that you use\n-semicolons to separate expressions from each other. This means that Rust\n-looks a lot like most other languages that require you to use semicolons\n-at the end of every line, and you will see semicolons at the end of almost\n-every line of Rust code you see.\n-\n-What is this exception that makes us say \"almost\"? You saw it already, in this\n-code:\n-\n-```{rust}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10 } else { 15 };\n-```\n-\n-Note that I've added the type annotation to `y`, to specify explicitly that I\n-want `y` to be an integer.\n-\n-This is not the same as this, which won't compile:\n-\n-```{ignore}\n-let x = 5;\n-\n-let y: i32 = if x == 5 { 10; } else { 15; };\n-```\n-\n-Note the semicolons after the 10 and 15. Rust will give us the following error:\n-\n-```text\n-error: mismatched types: expected `i32`, found `()` (expected i32, found ())\n-```\n-\n-We expected an integer, but we got `()`. `()` is pronounced *unit*, and is a\n-special type in Rust's type system. In Rust, `()` is _not_ a valid value for a\n-variable of type `i32`. It's only a valid value for variables of the type `()`,\n-which aren't very useful. Remember how we said statements don't return a value?\n-Well, that's the purpose of unit in this case. The semicolon turns any\n-expression into a statement by throwing away its value and returning unit\n-instead.\n-\n-There's one more time in which you won't see a semicolon at the end of a line\n-of Rust code. For that, we'll need our next concept: functions.\n-\n-TODO: `if let`\n+This works because `if` is an expression. The value of the expression is the\n+value of the last expression in whichever branch was chosen. An `if` without an\n+`else` always results in `()` as the value."}]}