{"sha": "bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkMGUzY2NkMGJmODFiNTdmMTE1YjM0NGRjZjQyNGEzZWQ2MjZjYWI=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T19:08:01Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-17T19:25:03Z"}, "message": "Store SliceKinds directly when subtracting", "tree": {"sha": "ee191bde89d778b9a9e543e133301384b0065d9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee191bde89d778b9a9e543e133301384b0065d9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "html_url": "https://github.com/rust-lang/rust/commit/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "daa117eab715f38d08facfb826b04116bc9fe0b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/daa117eab715f38d08facfb826b04116bc9fe0b7", "html_url": "https://github.com/rust-lang/rust/commit/daa117eab715f38d08facfb826b04116bc9fe0b7"}], "stats": {"total": 111, "additions": 58, "deletions": 53}, "files": [{"sha": "182c9e22e4188c9e4458b2da431e8133886791c7", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 58, "deletions": 53, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd0e3ccd0bf81b57f115b344dcf424a3ed626cab/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=bd0e3ccd0bf81b57f115b344dcf424a3ed626cab", "patch": "@@ -594,51 +594,17 @@ enum SliceKind {\n     VarLen(u64, u64),\n }\n \n-/// A constructor for array and slice patterns.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-struct Slice {\n-    /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n-    array_len: Option<u64>,\n-    /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n-    kind: SliceKind,\n-}\n-\n-impl Slice {\n-    /// Returns what patterns this constructor covers: either fixed-length patterns or\n-    /// variable-length patterns.\n-    fn pattern_kind(self) -> SliceKind {\n-        match self {\n-            Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n-                if prefix + suffix == len =>\n-            {\n-                FixedLen(len)\n-            }\n-            _ => self.kind,\n-        }\n-    }\n-\n-    /// Returns what values this constructor covers: either values of only one given length, or\n-    /// values of length above a given length.\n-    /// This is different from `pattern_kind()` because in some cases the pattern only takes into\n-    /// account a subset of the entries of the array, but still only captures values of a given\n-    /// length.\n-    fn value_kind(self) -> SliceKind {\n-        match self {\n-            Slice { array_len: Some(len), kind: VarLen(_, _) } => FixedLen(len),\n-            _ => self.kind,\n-        }\n-    }\n-\n+impl SliceKind {\n     fn arity(self) -> u64 {\n-        match self.pattern_kind() {\n+        match self {\n             FixedLen(length) => length,\n             VarLen(prefix, suffix) => prefix + suffix,\n         }\n     }\n \n     /// Whether this pattern includes patterns of length `other_len`.\n     fn covers_length(self, other_len: u64) -> bool {\n-        match self.value_kind() {\n+        match self {\n             FixedLen(len) => len == other_len,\n             VarLen(prefix, suffix) => prefix + suffix <= other_len,\n         }\n@@ -649,7 +615,7 @@ impl Slice {\n     fn subtract(self, other: Self) -> SmallVec<[Self; 1]> {\n         // Remember, `VarLen(i, j)` covers the union of `FixedLen` from `i + j` to infinity.\n         // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-        match self.value_kind() {\n+        match self {\n             FixedLen(pos_len) => {\n                 if other.covers_length(pos_len) {\n                     smallvec![]\n@@ -659,7 +625,7 @@ impl Slice {\n             }\n             VarLen(pos_prefix, pos_suffix) => {\n                 let pos_len = pos_prefix + pos_suffix;\n-                match other.value_kind() {\n+                match other {\n                     FixedLen(neg_len) => {\n                         if neg_len < pos_len {\n                             smallvec![self]\n@@ -668,7 +634,6 @@ impl Slice {\n                                 .map(FixedLen)\n                                 // We know that `neg_len + 1 >= pos_len >= pos_suffix`.\n                                 .chain(Some(VarLen(neg_len + 1 - pos_suffix, pos_suffix)))\n-                                .map(|kind| Slice { array_len: None, kind })\n                                 .collect()\n                         }\n                     }\n@@ -677,10 +642,7 @@ impl Slice {\n                         if neg_len <= pos_len {\n                             smallvec![]\n                         } else {\n-                            (pos_len..neg_len)\n-                                .map(FixedLen)\n-                                .map(|kind| Slice { array_len: None, kind })\n-                                .collect()\n+                            (pos_len..neg_len).map(FixedLen).collect()\n                         }\n                     }\n                 }\n@@ -689,6 +651,46 @@ impl Slice {\n     }\n }\n \n+/// A constructor for array and slice patterns.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+struct Slice {\n+    /// `None` if the matched value is a slice, `Some(n)` if it is an array of size `n`.\n+    array_len: Option<u64>,\n+    /// The kind of pattern it is: fixed-length `[x, y]` or variable length `[x, .., y]`.\n+    kind: SliceKind,\n+}\n+\n+impl Slice {\n+    /// Returns what patterns this constructor covers: either fixed-length patterns or\n+    /// variable-length patterns.\n+    fn pattern_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(prefix, suffix) }\n+                if prefix + suffix == len =>\n+            {\n+                FixedLen(len)\n+            }\n+            _ => self.kind,\n+        }\n+    }\n+\n+    /// Returns what values this constructor covers: either values of only one given length, or\n+    /// values of length above a given length.\n+    /// This is different from `pattern_kind()` because in some cases the pattern only takes into\n+    /// account a subset of the entries of the array, but still only captures values of a given\n+    /// length.\n+    fn value_kind(self) -> SliceKind {\n+        match self {\n+            Slice { array_len: Some(len), kind: VarLen(_, _) } => FixedLen(len),\n+            _ => self.kind,\n+        }\n+    }\n+\n+    fn arity(self) -> u64 {\n+        self.pattern_kind().arity()\n+    }\n+}\n+\n #[derive(Clone, Debug, PartialEq)]\n enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n@@ -743,26 +745,25 @@ impl<'tcx> Constructor<'tcx> {\n             &Slice(slice) => match slice.value_kind() {\n                 FixedLen(self_len) => {\n                     let overlaps = |c: &Constructor<'_>| match *c {\n-                        Slice(other_slice) => other_slice.covers_length(self_len),\n+                        Slice(other_slice) => other_slice.value_kind().covers_length(self_len),\n                         _ => false,\n                     };\n                     if other_ctors.iter().any(overlaps) { vec![] } else { vec![Slice(slice)] }\n                 }\n                 VarLen(..) => {\n-                    let mut remaining_slices = vec![slice];\n+                    let mut remaining_slices = vec![slice.value_kind()];\n \n                     // For each used slice, subtract from the current set of slices.\n-                    // Naming: we remove the \"neg\" constructors from the \"pos\" ones.\n-                    for neg_ctor in other_ctors {\n-                        let neg_slice = match neg_ctor {\n-                            Slice(slice) => *slice,\n-                            // FIXME(#65413): If `neg_ctor` is not a slice, we assume it doesn't\n+                    for other_ctor in other_ctors {\n+                        let other_slice = match other_ctor {\n+                            Slice(slice) => slice.value_kind(),\n+                            // FIXME(#65413): If `other_ctor` is not a slice, we assume it doesn't\n                             // cover any value here.\n                             _ => continue,\n                         };\n                         remaining_slices = remaining_slices\n                             .into_iter()\n-                            .flat_map(|pos_slice| pos_slice.subtract(neg_slice))\n+                            .flat_map(|remaining_slice| remaining_slice.subtract(other_slice))\n                             .collect();\n \n                         // If the constructors that have been considered so far already cover\n@@ -772,7 +773,11 @@ impl<'tcx> Constructor<'tcx> {\n                         }\n                     }\n \n-                    remaining_slices.into_iter().map(Slice).collect()\n+                    remaining_slices\n+                        .into_iter()\n+                        .map(|kind| Slice { array_len: slice.array_len, kind })\n+                        .map(Slice)\n+                        .collect()\n                 }\n             },\n             IntRange(self_range) => {"}]}