{"sha": "c039810b16c15c0d94eb57022130db4d0142918f", "node_id": "C_kwDOAAsO6NoAKGMwMzk4MTBiMTZjMTVjMGQ5NGViNTcwMjIxMzBkYjRkMDE0MjkxOGY", "commit": {"author": {"name": "Jonas Bushart", "email": "jonas@bushart.org", "date": "2022-03-31T18:15:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-31T18:15:01Z"}, "message": "Fix: Select correct insert position for disabled group import\n\nThe logic for importing with and without `group_imports` differed\nsignificantly when no previous group existed. This lead to the problem\nof using the wrong position when importing inside a module (#11585) or\nwhen inner attributes are involved.\nThe existing code for grouped imports is better and takes these things\ninto account.\n\nThis PR changes the flow to use the pre-existing code for adding a new\nimport group even for the non-grouped import settings.\nSome coverage markers are updated and the `group` is removed, since they\nare now invoked in both cases (grouping and no grouping).\n\nTests are updated and two tests (empty module and inner attribute) are\nadded.\n\nFixes #11585", "tree": {"sha": "33e143c8786c184964473098c4216aafec987a36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33e143c8786c184964473098c4216aafec987a36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c039810b16c15c0d94eb57022130db4d0142918f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c039810b16c15c0d94eb57022130db4d0142918f", "html_url": "https://github.com/rust-lang/rust/commit/c039810b16c15c0d94eb57022130db4d0142918f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c039810b16c15c0d94eb57022130db4d0142918f/comments", "author": {"login": "jonasbb", "id": 273459, "node_id": "MDQ6VXNlcjI3MzQ1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/273459?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonasbb", "html_url": "https://github.com/jonasbb", "followers_url": "https://api.github.com/users/jonasbb/followers", "following_url": "https://api.github.com/users/jonasbb/following{/other_user}", "gists_url": "https://api.github.com/users/jonasbb/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonasbb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonasbb/subscriptions", "organizations_url": "https://api.github.com/users/jonasbb/orgs", "repos_url": "https://api.github.com/users/jonasbb/repos", "events_url": "https://api.github.com/users/jonasbb/events{/privacy}", "received_events_url": "https://api.github.com/users/jonasbb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1d684e95130cca21fc78f1642b02811ad09db15", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d684e95130cca21fc78f1642b02811ad09db15", "html_url": "https://github.com/rust-lang/rust/commit/a1d684e95130cca21fc78f1642b02811ad09db15"}], "stats": {"total": 160, "additions": 98, "deletions": 62}, "files": [{"sha": "a19969ecc4ac8660efc63bc0277572fa5851e3f8", "filename": "crates/ide_db/src/imports/insert_use.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/c039810b16c15c0d94eb57022130db4d0142918f/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c039810b16c15c0d94eb57022130db4d0142918f/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use.rs?ref=c039810b16c15c0d94eb57022130db4d0142918f", "patch": "@@ -337,67 +337,65 @@ fn insert_use_(\n             Some((path, has_tl, node))\n         });\n \n-    if !group_imports {\n+    if group_imports {\n+        // Iterator that discards anything thats not in the required grouping\n+        // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n+        let group_iter = path_node_iter\n+            .clone()\n+            .skip_while(|(path, ..)| ImportGroup::new(path) != group)\n+            .take_while(|(path, ..)| ImportGroup::new(path) == group);\n+\n+        // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n+        let mut last = None;\n+        // find the element that would come directly after our new import\n+        let post_insert: Option<(_, _, SyntaxNode)> = group_iter\n+            .inspect(|(.., node)| last = Some(node.clone()))\n+            .find(|&(ref path, has_tl, _)| {\n+                use_tree_path_cmp(insert_path, false, path, has_tl) != Ordering::Greater\n+            });\n+\n+        if let Some((.., node)) = post_insert {\n+            cov_mark::hit!(insert_group);\n+            // insert our import before that element\n+            return ted::insert(ted::Position::before(node), use_item.syntax());\n+        }\n+        if let Some(node) = last {\n+            cov_mark::hit!(insert_group_last);\n+            // there is no element after our new import, so append it to the end of the group\n+            return ted::insert(ted::Position::after(node), use_item.syntax());\n+        }\n+\n+        // the group we were looking for actually doesn't exist, so insert\n+\n+        let mut last = None;\n+        // find the group that comes after where we want to insert\n+        let post_group = path_node_iter\n+            .inspect(|(.., node)| last = Some(node.clone()))\n+            .find(|(p, ..)| ImportGroup::new(p) > group);\n+        if let Some((.., node)) = post_group {\n+            cov_mark::hit!(insert_group_new_group);\n+            ted::insert(ted::Position::before(&node), use_item.syntax());\n+            if let Some(node) = algo::non_trivia_sibling(node.into(), Direction::Prev) {\n+                ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+            }\n+            return;\n+        }\n+        // there is no such group, so append after the last one\n+        if let Some(node) = last {\n+            cov_mark::hit!(insert_group_no_group);\n+            ted::insert(ted::Position::after(&node), use_item.syntax());\n+            ted::insert(ted::Position::after(node), make::tokens::single_newline());\n+            return;\n+        }\n+    } else {\n+        // There exists a group, so append to the end of it\n         if let Some((_, _, node)) = path_node_iter.last() {\n             cov_mark::hit!(insert_no_grouping_last);\n             ted::insert(ted::Position::after(node), use_item.syntax());\n-        } else {\n-            cov_mark::hit!(insert_no_grouping_last2);\n-            ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n-            ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n+            return;\n         }\n-        return;\n-    }\n-\n-    // Iterator that discards anything thats not in the required grouping\n-    // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n-    let group_iter = path_node_iter\n-        .clone()\n-        .skip_while(|(path, ..)| ImportGroup::new(path) != group)\n-        .take_while(|(path, ..)| ImportGroup::new(path) == group);\n-\n-    // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n-    let mut last = None;\n-    // find the element that would come directly after our new import\n-    let post_insert: Option<(_, _, SyntaxNode)> = group_iter\n-        .inspect(|(.., node)| last = Some(node.clone()))\n-        .find(|&(ref path, has_tl, _)| {\n-            use_tree_path_cmp(insert_path, false, path, has_tl) != Ordering::Greater\n-        });\n-\n-    if let Some((.., node)) = post_insert {\n-        cov_mark::hit!(insert_group);\n-        // insert our import before that element\n-        return ted::insert(ted::Position::before(node), use_item.syntax());\n-    }\n-    if let Some(node) = last {\n-        cov_mark::hit!(insert_group_last);\n-        // there is no element after our new import, so append it to the end of the group\n-        return ted::insert(ted::Position::after(node), use_item.syntax());\n     }\n \n-    // the group we were looking for actually doesn't exist, so insert\n-\n-    let mut last = None;\n-    // find the group that comes after where we want to insert\n-    let post_group = path_node_iter\n-        .inspect(|(.., node)| last = Some(node.clone()))\n-        .find(|(p, ..)| ImportGroup::new(p) > group);\n-    if let Some((.., node)) = post_group {\n-        cov_mark::hit!(insert_group_new_group);\n-        ted::insert(ted::Position::before(&node), use_item.syntax());\n-        if let Some(node) = algo::non_trivia_sibling(node.into(), Direction::Prev) {\n-            ted::insert(ted::Position::after(node), make::tokens::single_newline());\n-        }\n-        return;\n-    }\n-    // there is no such group, so append after the last one\n-    if let Some(node) = last {\n-        cov_mark::hit!(insert_group_no_group);\n-        ted::insert(ted::Position::after(&node), use_item.syntax());\n-        ted::insert(ted::Position::after(node), make::tokens::single_newline());\n-        return;\n-    }\n     // there are no imports in this file at all\n     if let Some(last_inner_element) = scope_syntax\n         .children_with_tokens()\n@@ -407,14 +405,14 @@ fn insert_use_(\n         })\n         .last()\n     {\n-        cov_mark::hit!(insert_group_empty_inner_attr);\n+        cov_mark::hit!(insert_empty_inner_attr);\n         ted::insert(ted::Position::after(&last_inner_element), use_item.syntax());\n         ted::insert(ted::Position::after(last_inner_element), make::tokens::single_newline());\n         return;\n     }\n     let l_curly = match scope {\n         ImportScope::File(_) => {\n-            cov_mark::hit!(insert_group_empty_file);\n+            cov_mark::hit!(insert_empty_file);\n             ted::insert(ted::Position::first_child_of(scope_syntax), make::tokens::blank_line());\n             ted::insert(ted::Position::first_child_of(scope_syntax), use_item.syntax());\n             return;\n@@ -426,7 +424,7 @@ fn insert_use_(\n     };\n     match l_curly {\n         Some(b) => {\n-            cov_mark::hit!(insert_group_empty_module);\n+            cov_mark::hit!(insert_empty_module);\n             ted::insert(ted::Position::after(&b), make::tokens::single_newline());\n             ted::insert(ted::Position::after(&b), use_item.syntax());\n         }"}, {"sha": "39d2b22ff03d86439224746285a3e16ce5537549", "filename": "crates/ide_db/src/imports/insert_use/tests.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c039810b16c15c0d94eb57022130db4d0142918f/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c039810b16c15c0d94eb57022130db4d0142918f/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports%2Finsert_use%2Ftests.rs?ref=c039810b16c15c0d94eb57022130db4d0142918f", "patch": "@@ -86,7 +86,7 @@ use external_crate2::bar::A;\",\n \n #[test]\n fn insert_not_group_empty() {\n-    cov_mark::check!(insert_no_grouping_last2);\n+    cov_mark::check!(insert_empty_file);\n     check_with_config(\n         \"use external_crate2::bar::A\",\n         r\"\",\n@@ -103,6 +103,44 @@ fn insert_not_group_empty() {\n     );\n }\n \n+#[test]\n+fn insert_not_group_empty_module() {\n+    cov_mark::check!(insert_empty_module);\n+    check_with_config(\n+        \"foo::bar\",\n+        r\"mod x {$0}\",\n+        r\"mod x {\n+    use foo::bar;\n+}\",\n+        &InsertUseConfig {\n+            granularity: ImportGranularity::Item,\n+            enforce_granularity: true,\n+            prefix_kind: PrefixKind::Plain,\n+            group: false,\n+            skip_glob_imports: true,\n+        },\n+    );\n+}\n+\n+#[test]\n+fn insert_no_group_after_inner_attr() {\n+    cov_mark::check!(insert_empty_inner_attr);\n+    check_with_config(\n+        \"foo::bar\",\n+        r\"#![allow(unused_imports)]\",\n+        r\"#![allow(unused_imports)]\n+\n+use foo::bar;\",\n+        &InsertUseConfig {\n+            granularity: ImportGranularity::Item,\n+            enforce_granularity: true,\n+            prefix_kind: PrefixKind::Plain,\n+            group: false,\n+            skip_glob_imports: true,\n+        },\n+    )\n+}\n+\n #[test]\n fn insert_existing() {\n     check_crate(\"std::fs\", \"use std::fs;\", \"use std::fs;\")\n@@ -321,7 +359,7 @@ fn main() {}\",\n \n #[test]\n fn insert_empty_file() {\n-    cov_mark::check!(insert_group_empty_file);\n+    cov_mark::check!(insert_empty_file);\n     // empty files will get two trailing newlines\n     // this is due to the test case insert_no_imports above\n     check_crate(\n@@ -335,7 +373,7 @@ fn insert_empty_file() {\n \n #[test]\n fn insert_empty_module() {\n-    cov_mark::check!(insert_group_empty_module);\n+    cov_mark::check!(insert_empty_module);\n     check(\n         \"foo::bar\",\n         r\"\n@@ -352,7 +390,7 @@ mod x {\n \n #[test]\n fn insert_after_inner_attr() {\n-    cov_mark::check!(insert_group_empty_inner_attr);\n+    cov_mark::check!(insert_empty_inner_attr);\n     check_crate(\n         \"foo::bar\",\n         r\"#![allow(unused_imports)]\","}]}