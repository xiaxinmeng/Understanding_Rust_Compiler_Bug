{"sha": "c747626cedaaf91d357ffd48d1459b507afb0538", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NDc2MjZjZWRhYWY5MWQzNTdmZmQ0OGQxNDU5YjUwN2FmYjA1Mzg=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-18T00:41:50Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T18:36:27Z"}, "message": "Reindent function call continuations, and other style fixes", "tree": {"sha": "dfb26776144841cbccc9f89c7dc5e3a423d221e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfb26776144841cbccc9f89c7dc5e3a423d221e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c747626cedaaf91d357ffd48d1459b507afb0538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c747626cedaaf91d357ffd48d1459b507afb0538", "html_url": "https://github.com/rust-lang/rust/commit/c747626cedaaf91d357ffd48d1459b507afb0538", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c747626cedaaf91d357ffd48d1459b507afb0538/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba1c0c42320d2187115ad324579e81b0172acb57", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba1c0c42320d2187115ad324579e81b0172acb57", "html_url": "https://github.com/rust-lang/rust/commit/ba1c0c42320d2187115ad324579e81b0172acb57"}], "stats": {"total": 207, "additions": 104, "deletions": 103}, "files": [{"sha": "e8e057c926c7cd4b7dc74f0cb5fa61c4b72c0ad7", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=c747626cedaaf91d357ffd48d1459b507afb0538", "patch": "@@ -175,7 +175,7 @@ Available lint options:\n         for lint in lints.move_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7s}  {}\",\n-                padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n+                     padded(name.as_slice()), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };"}, {"sha": "604edf280f14ca63bf29efbaf450463669e38a10", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 80, "deletions": 78, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=c747626cedaaf91d357ffd48d1459b507afb0538", "patch": "@@ -54,7 +54,7 @@ use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n \n declare_lint!(WHILE_TRUE, Warn,\n-    \"suggest using `loop { }` instead of `while true { }`\")\n+              \"suggest using `loop { }` instead of `while true { }`\")\n \n pub struct WhileTrue;\n \n@@ -86,7 +86,7 @@ impl LintPass for WhileTrue {\n }\n \n declare_lint!(UNNECESSARY_TYPECAST, Allow,\n-    \"detects unnecessary type casts, that can be removed\")\n+              \"detects unnecessary type casts, that can be removed\")\n \n pub struct UnusedCasts;\n \n@@ -99,7 +99,7 @@ impl LintPass for UnusedCasts {\n         match e.node {\n             ast::ExprCast(expr, ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n-                if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n+                if ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n                     cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n                 }\n             }\n@@ -109,13 +109,13 @@ impl LintPass for UnusedCasts {\n }\n \n declare_lint!(UNSIGNED_NEGATE, Warn,\n-    \"using an unary minus operator on unsigned type\")\n+              \"using an unary minus operator on unsigned type\")\n \n declare_lint!(TYPE_LIMITS, Warn,\n-    \"comparisons made useless by limits of the types involved\")\n+              \"comparisons made useless by limits of the types involved\")\n \n declare_lint!(TYPE_OVERFLOW, Warn,\n-    \"literal out of range for its type\")\n+              \"literal out of range for its type\")\n \n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n@@ -315,7 +315,7 @@ impl LintPass for TypeLimits {\n }\n \n declare_lint!(CTYPES, Warn,\n-    \"proper use of libc types in foreign modules\")\n+              \"proper use of libc types in foreign modules\")\n \n pub struct CTypes;\n \n@@ -331,19 +331,19 @@ impl LintPass for CTypes {\n                     match cx.tcx.def_map.borrow().get_copy(&id) {\n                         def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n                             cx.span_lint(CTYPES, ty.span,\n-                                \"found rust type `int` in foreign module, while \\\n-                                 libc::c_int or libc::c_long should be used\");\n+                                         \"found rust type `int` in foreign module, while \\\n+                                          libc::c_int or libc::c_long should be used\");\n                         }\n                         def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n                             cx.span_lint(CTYPES, ty.span,\n-                                \"found rust type `uint` in foreign module, while \\\n-                                 libc::c_uint or libc::c_ulong should be used\");\n+                                         \"found rust type `uint` in foreign module, while \\\n+                                          libc::c_uint or libc::c_ulong should be used\");\n                         }\n                         def::DefTy(def_id) => {\n                             if !adt::is_ffi_safe(cx.tcx, def_id) {\n                                 cx.span_lint(CTYPES, ty.span,\n-                                    \"found enum type without foreign-function-safe \\\n-                                     representation annotation in foreign module\");\n+                                             \"found enum type without foreign-function-safe \\\n+                                              representation annotation in foreign module\");\n                                 // hmm... this message could be more helpful\n                             }\n                         }\n@@ -377,13 +377,13 @@ impl LintPass for CTypes {\n }\n \n declare_lint!(MANAGED_HEAP_MEMORY, Allow,\n-    \"use of managed (@ type) heap memory\")\n+              \"use of managed (@ type) heap memory\")\n \n declare_lint!(OWNED_HEAP_MEMORY, Allow,\n-    \"use of owned (Box type) heap memory\")\n+              \"use of owned (Box type) heap memory\")\n \n declare_lint!(HEAP_MEMORY, Allow,\n-    \"use of any (Box type or @ type) heap memory\")\n+              \"use of any (Box type or @ type) heap memory\")\n \n pub struct HeapMemory;\n \n@@ -438,9 +438,9 @@ impl LintPass for HeapMemory {\n             ast::ItemFn(..) |\n             ast::ItemTy(..) |\n             ast::ItemEnum(..) |\n-            ast::ItemStruct(..)\n-                => self.check_heap_type(cx, it.span,\n-                    ty::node_id_to_type(cx.tcx, it.id)),\n+            ast::ItemStruct(..) =>\n+                self.check_heap_type(cx, it.span,\n+                                     ty::node_id_to_type(cx.tcx, it.id)),\n             _ => ()\n         }\n \n@@ -449,7 +449,7 @@ impl LintPass for HeapMemory {\n             ast::ItemStruct(struct_def, _) => {\n                 for struct_field in struct_def.fields.iter() {\n                     self.check_heap_type(cx, struct_field.span,\n-                    ty::node_id_to_type(cx.tcx, struct_field.node.id));\n+                                         ty::node_id_to_type(cx.tcx, struct_field.node.id));\n                 }\n             }\n             _ => ()\n@@ -463,7 +463,7 @@ impl LintPass for HeapMemory {\n }\n \n declare_lint!(RAW_POINTER_DERIVING, Warn,\n-    \"uses of #[deriving] with raw pointers are rarely correct\")\n+              \"uses of #[deriving] with raw pointers are rarely correct\")\n \n struct RawPtrDerivingVisitor<'a> {\n     cx: &'a Context<'a>\n@@ -531,7 +531,7 @@ impl LintPass for RawPointerDeriving {\n }\n \n declare_lint!(UNUSED_ATTRIBUTE, Warn,\n-    \"detects attributes that were not used by the compiler\")\n+              \"detects attributes that were not used by the compiler\")\n \n pub struct UnusedAttribute;\n \n@@ -600,8 +600,8 @@ impl LintPass for UnusedAttribute {\n             cx.span_lint(UNUSED_ATTRIBUTE, attr.span, \"unused attribute\");\n             if CRATE_ATTRS.contains(&attr.name().get()) {\n                 let msg = match attr.node.style {\n-                   ast::AttrOuter => \"crate-level attribute should be an inner \\\n-                                      attribute: add an exclamation mark: #![foo]\",\n+                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n+                                       attribute: add an exclamation mark: #![foo]\",\n                     ast::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n@@ -612,7 +612,7 @@ impl LintPass for UnusedAttribute {\n }\n \n declare_lint!(PATH_STATEMENT, Warn,\n-    \"path statements with no effect\")\n+              \"path statements with no effect\")\n \n pub struct PathStatement;\n \n@@ -636,10 +636,10 @@ impl LintPass for PathStatement {\n }\n \n declare_lint!(UNUSED_MUST_USE, Warn,\n-    \"unused result of a type flagged as #[must_use]\")\n+              \"unused result of a type flagged as #[must_use]\")\n \n declare_lint!(UNUSED_RESULT, Allow,\n-    \"unused result of an expression in a statement\")\n+              \"unused result of an expression in a statement\")\n \n pub struct UnusedResult;\n \n@@ -699,7 +699,7 @@ impl LintPass for UnusedResult {\n }\n \n declare_lint!(DEPRECATED_OWNED_VECTOR, Allow,\n-    \"use of a `~[T]` vector\")\n+              \"use of a `~[T]` vector\")\n \n pub struct DeprecatedOwnedVector;\n \n@@ -714,7 +714,7 @@ impl LintPass for DeprecatedOwnedVector {\n             ty::ty_uniq(t) => match ty::get(t).sty {\n                 ty::ty_vec(_, None) => {\n                     cx.span_lint(DEPRECATED_OWNED_VECTOR, e.span,\n-                        \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n+                                 \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n                 }\n                 _ => {}\n             },\n@@ -724,7 +724,7 @@ impl LintPass for DeprecatedOwnedVector {\n }\n \n declare_lint!(NON_CAMEL_CASE_TYPES, Warn,\n-    \"types, variants and traits should have camel case names\")\n+              \"types, variants and traits should have camel case names\")\n \n pub struct NonCamelCaseTypes;\n \n@@ -757,7 +757,7 @@ impl LintPass for NonCamelCaseTypes {\n             if !is_camel_case(ident) {\n                 cx.span_lint(NON_CAMEL_CASE_TYPES, span,\n                     format!(\"{} `{}` should have a camel case name such as `{}`\",\n-                        sort, s, to_camel_case(s.get())).as_slice());\n+                            sort, s, to_camel_case(s.get())).as_slice());\n             }\n         }\n \n@@ -809,7 +809,7 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n }\n \n declare_lint!(NON_SNAKE_CASE_FUNCTIONS, Warn,\n-    \"methods and functions should have snake case names\")\n+              \"methods and functions should have snake case names\")\n \n pub struct NonSnakeCaseFunctions;\n \n@@ -853,7 +853,7 @@ impl NonSnakeCaseFunctions {\n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE_FUNCTIONS, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                    sort, s, to_snake_case(s.get())).as_slice());\n+                        sort, s, to_snake_case(s.get())).as_slice());\n         }\n     }\n }\n@@ -886,7 +886,7 @@ impl LintPass for NonSnakeCaseFunctions {\n }\n \n declare_lint!(NON_UPPERCASE_STATICS, Allow,\n-    \"static constants should have uppercase identifiers\")\n+              \"static constants should have uppercase identifiers\")\n \n pub struct NonUppercaseStatics;\n \n@@ -906,8 +906,8 @@ impl LintPass for NonUppercaseStatics {\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPERCASE_STATICS, it.span,\n                         format!(\"static constant `{}` should have an uppercase name \\\n-                            such as `{}`\", s.get(),\n-                            s.get().chars().map(|c| c.to_uppercase())\n+                                 such as `{}`\",\n+                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n                                 .collect::<String>().as_slice()).as_slice());\n                 }\n             }\n@@ -917,7 +917,7 @@ impl LintPass for NonUppercaseStatics {\n }\n \n declare_lint!(NON_UPPERCASE_PATTERN_STATICS, Warn,\n-    \"static constants in match patterns should be all caps\")\n+              \"static constants in match patterns should be all caps\")\n \n pub struct NonUppercasePatternStatics;\n \n@@ -936,9 +936,9 @@ impl LintPass for NonUppercasePatternStatics {\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n-                            name such as `{}`\", s.get(),\n-                            s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>().as_slice()).as_slice());\n+                                 name such as `{}`\",\n+                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n+                                    .collect::<String>().as_slice()).as_slice());\n                 }\n             }\n             _ => {}\n@@ -947,7 +947,7 @@ impl LintPass for NonUppercasePatternStatics {\n }\n \n declare_lint!(UPPERCASE_VARIABLES, Warn,\n-    \"variable and structure field names should start with a lowercase character\")\n+              \"variable and structure field names should start with a lowercase character\")\n \n pub struct UppercaseVariables;\n \n@@ -967,7 +967,8 @@ impl LintPass for UppercaseVariables {\n                         let s = token::get_ident(ident);\n                         if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n                             cx.span_lint(UPPERCASE_VARIABLES, path.span,\n-                                \"variable names should start with a lowercase character\");\n+                                         \"variable names should start with \\\n+                                          a lowercase character\");\n                         }\n                     }\n                     _ => {}\n@@ -985,7 +986,8 @@ impl LintPass for UppercaseVariables {\n                     let s = token::get_ident(ident);\n                     if s.get().char_at(0).is_uppercase() {\n                         cx.span_lint(UPPERCASE_VARIABLES, sf.span,\n-                            \"structure field names should start with a lowercase character\");\n+                                     \"structure field names should start with \\\n+                                      a lowercase character\");\n                     }\n                 }\n                 _ => {}\n@@ -995,7 +997,7 @@ impl LintPass for UppercaseVariables {\n }\n \n declare_lint!(UNNECESSARY_PARENS, Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\")\n+              \"`if`, `match`, `while` and `return` do not need parentheses\")\n \n pub struct UnnecessaryParens;\n \n@@ -1045,7 +1047,7 @@ impl LintPass for UnnecessaryParens {\n }\n \n declare_lint!(UNUSED_UNSAFE, Warn,\n-    \"unnecessary use of an `unsafe` block\")\n+              \"unnecessary use of an `unsafe` block\")\n \n pub struct UnusedUnsafe;\n \n@@ -1069,7 +1071,7 @@ impl LintPass for UnusedUnsafe {\n }\n \n declare_lint!(UNSAFE_BLOCK, Allow,\n-    \"usage of an `unsafe` block\")\n+              \"usage of an `unsafe` block\")\n \n pub struct UnsafeBlock;\n \n@@ -1090,7 +1092,7 @@ impl LintPass for UnsafeBlock {\n }\n \n declare_lint!(UNUSED_MUT, Warn,\n-    \"detect mut variables which don't need to be mutable\")\n+              \"detect mut variables which don't need to be mutable\")\n \n pub struct UnusedMut;\n \n@@ -1105,8 +1107,8 @@ impl UnusedMut {\n                     ast::BindByValue(ast::MutMutable) => {\n                         if path.segments.len() != 1 {\n                             cx.sess().span_bug(p.span,\n-                                                 \"mutable binding that doesn't consist \\\n-                                                  of exactly one segment\");\n+                                               \"mutable binding that doesn't consist \\\n+                                                of exactly one segment\");\n                         }\n                         let ident = path.segments.get(0).identifier;\n                         if !token::get_ident(ident).get().starts_with(\"_\") {\n@@ -1124,7 +1126,7 @@ impl UnusedMut {\n         for (_, v) in mutables.iter() {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n                 cx.span_lint(UNUSED_MUT, cx.tcx.map.span(*v.get(0)),\n-                    \"variable does not need to be mutable\");\n+                             \"variable does not need to be mutable\");\n             }\n         }\n     }\n@@ -1175,7 +1177,7 @@ enum Allocation {\n }\n \n declare_lint!(UNNECESSARY_ALLOCATION, Warn,\n-    \"detects unnecessary allocations that can be eliminated\")\n+              \"detects unnecessary allocations that can be eliminated\")\n \n pub struct UnnecessaryAllocation;\n \n@@ -1210,17 +1212,17 @@ impl LintPass for UnnecessaryAllocation {\n                         match (allocation, autoref) {\n                             (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n-                                    \"unnecessary allocation, the sigil can be removed\");\n+                                             \"unnecessary allocation, the sigil can be removed\");\n                             }\n                             (BoxAllocation,\n                              Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n-                                    \"unnecessary allocation, use & instead\");\n+                                             \"unnecessary allocation, use & instead\");\n                             }\n                             (BoxAllocation,\n                              Some(ty::AutoPtr(_, ast::MutMutable))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n-                                    \"unnecessary allocation, use &mut instead\");\n+                                             \"unnecessary allocation, use &mut instead\");\n                             }\n                             _ => ()\n                         }\n@@ -1234,7 +1236,7 @@ impl LintPass for UnnecessaryAllocation {\n }\n \n declare_lint!(MISSING_DOC, Allow,\n-    \"detects missing documentation for public members\")\n+              \"detects missing documentation for public members\")\n \n pub struct MissingDoc {\n     /// Stack of IDs of struct definitions.\n@@ -1323,7 +1325,7 @@ impl LintPass for MissingDoc {\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n         self.check_missing_doc_attrs(cx, None, krate.attrs.as_slice(),\n-            krate.span, \"crate\");\n+                                     krate.span, \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -1336,7 +1338,7 @@ impl LintPass for MissingDoc {\n             _ => return\n         };\n         self.check_missing_doc_attrs(cx, Some(it.id), it.attrs.as_slice(),\n-            it.span, desc);\n+                                     it.span, desc);\n     }\n \n     fn check_fn(&mut self, cx: &Context,\n@@ -1350,15 +1352,15 @@ impl LintPass for MissingDoc {\n                 // Otherwise, doc according to privacy. This will also check\n                 // doc for default methods defined on traits.\n                 self.check_missing_doc_attrs(cx, Some(m.id), m.attrs.as_slice(),\n-                    m.span, \"a method\");\n+                                             m.span, \"a method\");\n             }\n             _ => {}\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n         self.check_missing_doc_attrs(cx, Some(tm.id), tm.attrs.as_slice(),\n-            tm.span, \"a type method\");\n+                                     tm.span, \"a type method\");\n     }\n \n     fn check_struct_field(&mut self, cx: &Context, sf: &ast::StructField) {\n@@ -1367,26 +1369,27 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_doc_attrs(cx, Some(cur_struct_def),\n-                    sf.node.attrs.as_slice(), sf.span, \"a struct field\")\n+                                             sf.node.attrs.as_slice(), sf.span,\n+                                             \"a struct field\")\n             }\n             _ => {}\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n         self.check_missing_doc_attrs(cx, Some(v.node.id), v.node.attrs.as_slice(),\n-            v.span, \"a variant\");\n+                                     v.span, \"a variant\");\n     }\n }\n \n declare_lint!(DEPRECATED, Warn,\n-    \"detects use of #[deprecated] items\")\n+              \"detects use of #[deprecated] items\")\n \n declare_lint!(EXPERIMENTAL, Warn,\n-    \"detects use of #[experimental] items\")\n+              \"detects use of #[experimental] items\")\n \n declare_lint!(UNSTABLE, Allow,\n-    \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n+              \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n \n /// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n /// `#[unstable]` attributes, or no stability attribute.\n@@ -1415,8 +1418,7 @@ impl LintPass for Stability {\n                                 // of the method inside trait definition.\n                                 // Otherwise, use the current def_id (which refers\n                                 // to the method inside impl).\n-                                ty::trait_method_of_method(\n-                                    cx.tcx, def_id).unwrap_or(def_id)\n+                                ty::trait_method_of_method(cx.tcx, def_id).unwrap_or(def_id)\n                             }\n                             typeck::MethodParam(typeck::MethodParam {\n                                 trait_id: trait_id,\n@@ -1487,40 +1489,40 @@ impl LintPass for Stability {\n }\n \n declare_lint!(pub UNUSED_IMPORTS, Warn,\n-    \"imports that are never used\")\n+              \"imports that are never used\")\n \n declare_lint!(pub UNNECESSARY_QUALIFICATION, Allow,\n-    \"detects unnecessarily qualified names\")\n+              \"detects unnecessarily qualified names\")\n \n declare_lint!(pub UNRECOGNIZED_LINT, Warn,\n-    \"unrecognized lint attribute\")\n+              \"unrecognized lint attribute\")\n \n declare_lint!(pub UNUSED_VARIABLE, Warn,\n-    \"detect variables which are not used in any way\")\n+              \"detect variables which are not used in any way\")\n \n declare_lint!(pub DEAD_ASSIGNMENT, Warn,\n-    \"detect assignments that will never be read\")\n+              \"detect assignments that will never be read\")\n \n declare_lint!(pub DEAD_CODE, Warn,\n-    \"detect piece of code that will never be used\")\n+              \"detect piece of code that will never be used\")\n \n declare_lint!(pub VISIBLE_PRIVATE_TYPES, Warn,\n-    \"detect use of private types in exported type signatures\")\n+              \"detect use of private types in exported type signatures\")\n \n declare_lint!(pub UNREACHABLE_CODE, Warn,\n-    \"detects unreachable code\")\n+              \"detects unreachable code\")\n \n declare_lint!(pub WARNINGS, Warn,\n-    \"mass-change the level for lints which produce warnings\")\n+              \"mass-change the level for lints which produce warnings\")\n \n declare_lint!(pub UNKNOWN_FEATURES, Deny,\n-    \"unknown features found in crate-level #[feature] directives\")\n+              \"unknown features found in crate-level #[feature] directives\")\n \n declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n-    \"unknown crate type found in #[crate_type] directive\")\n+              \"unknown crate type found in #[crate_type] directive\")\n \n declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n-    \"detects enums with widely varying variant sizes\")\n+              \"detects enums with widely varying variant sizes\")\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler."}, {"sha": "628171bf168c1f039b5bc9c31fdcfaff3d3caa7f", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=c747626cedaaf91d357ffd48d1459b507afb0538", "patch": "@@ -137,17 +137,17 @@ impl LintStore {\n         ))\n \n         add_builtin!(sess, HardwiredLints,\n-            WhileTrue, UnusedCasts, CTypes, HeapMemory,\n-            UnusedAttribute, PathStatement, UnusedResult,\n-            DeprecatedOwnedVector, NonCamelCaseTypes,\n-            NonSnakeCaseFunctions, NonUppercaseStatics,\n-            NonUppercasePatternStatics, UppercaseVariables,\n-            UnnecessaryParens, UnusedUnsafe, UnsafeBlock,\n-            UnusedMut, UnnecessaryAllocation, Stability,\n+                     WhileTrue, UnusedCasts, CTypes, HeapMemory,\n+                     UnusedAttribute, PathStatement, UnusedResult,\n+                     DeprecatedOwnedVector, NonCamelCaseTypes,\n+                     NonSnakeCaseFunctions, NonUppercaseStatics,\n+                     NonUppercasePatternStatics, UppercaseVariables,\n+                     UnnecessaryParens, UnusedUnsafe, UnsafeBlock,\n+                     UnusedMut, UnnecessaryAllocation, Stability,\n         )\n \n         add_builtin_with_new!(sess,\n-            TypeLimits, RawPointerDeriving, MissingDoc,\n+                              TypeLimits, RawPointerDeriving, MissingDoc,\n         )\n \n         // We have one lint pass defined in this module.\n@@ -159,7 +159,7 @@ impl LintStore {\n             match self.by_name.find_equiv(&lint_name.as_slice()) {\n                 Some(&lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => sess.err(format!(\"unknown {} flag: {}\",\n-                    level.as_str(), lint_name).as_slice()),\n+                                         level.as_str(), lint_name).as_slice()),\n             }\n         }\n     }\n@@ -249,14 +249,14 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     let msg = match source {\n         Default => {\n             format!(\"{}, #[{}({})] on by default\", msg,\n-                level.as_str(), name)\n+                    level.as_str(), name)\n         },\n         CommandLine => {\n             format!(\"{} [-{} {}]\", msg,\n-                match level {\n-                    Warn => 'W', Deny => 'D', Forbid => 'F',\n-                    Allow => fail!()\n-                }, name.replace(\"_\", \"-\"))\n+                    match level {\n+                        Warn => 'W', Deny => 'D', Forbid => 'F',\n+                        Allow => fail!()\n+                    }, name.replace(\"_\", \"-\"))\n         },\n         Node(src) => {\n             note = Some(src);\n@@ -286,7 +286,7 @@ impl<'a> Context<'a> {\n            exported_items: &'a ExportedItems) -> Context<'a> {\n         // We want to own the lint store, so move it out of the session.\n         let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n-            LintStore::new());\n+                                      LintStore::new());\n \n         Context {\n             tcx: tcx,\n@@ -363,8 +363,8 @@ impl<'a> Context<'a> {\n             if now == Forbid && level != Forbid {\n                 let lint_name = lint_id.as_str();\n                 self.tcx.sess.span_err(span,\n-                    format!(\"{}({}) overruled by outer forbid({})\",\n-                        level.as_str(), lint_name, lint_name).as_slice());\n+                                       format!(\"{}({}) overruled by outer forbid({})\",\n+                                               level.as_str(), lint_name, lint_name).as_slice());\n             } else if now != level {\n                 let src = self.lints.get_level_source(lint_id).val1();\n                 self.level_stack.push((lint_id, (now, src)));\n@@ -651,9 +651,8 @@ pub fn check_crate(tcx: &ty::ctxt,\n     for (id, v) in tcx.sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n-                format!(\"unprocessed lint {} at {}: {}\",\n-                    lint.as_str(), tcx.map.node_to_str(*id), *msg)\n-                .as_slice())\n+                              format!(\"unprocessed lint {} at {}: {}\",\n+                                      lint.as_str(), tcx.map.node_to_str(*id), *msg).as_slice())\n         }\n     }\n "}, {"sha": "210de1946c9e6f9ec8deef4faf185821439b460c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c747626cedaaf91d357ffd48d1459b507afb0538/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c747626cedaaf91d357ffd48d1459b507afb0538", "patch": "@@ -1591,10 +1591,10 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n         lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCE,\n-            lvlsrc, Some(sp),\n-            format!(\"enum variant is more than three times larger \\\n-                     ({} bytes) than the next largest (ignoring padding)\",\n-                    largest).as_slice());\n+                            lvlsrc, Some(sp),\n+                            format!(\"enum variant is more than three times larger \\\n+                                     ({} bytes) than the next largest (ignoring padding)\",\n+                                    largest).as_slice());\n \n         ccx.sess().span_note(enum_def.variants.get(largest_index).span,\n                              \"this variant is the largest\");"}]}