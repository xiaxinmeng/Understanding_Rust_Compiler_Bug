{"sha": "3e2d60624162845238fa3b2fbb874eee51daa983", "node_id": "C_kwDOAAsO6NoAKDNlMmQ2MDYyNDE2Mjg0NTIzOGZhM2IyZmJiODc0ZWVlNTFkYWE5ODM", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-09-22T13:11:40Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-10-03T18:49:26Z"}, "message": "Automatically convert paths to verbatim\n\nThis allows using longer paths for filesystem operations without the user needing to `canonicalize` or manually prefix paths.\n\nIf the path is already verbatim than this has no effect.", "tree": {"sha": "fa7033169d03b79804dca1fc6df47d4ea09e52c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa7033169d03b79804dca1fc6df47d4ea09e52c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e2d60624162845238fa3b2fbb874eee51daa983", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmFZ+zcACgkQcTRy8vRW\nJ97KBw/+PwbljmtMWvNeHtuyOzTNzJxldlA2tQ4nXZWumV43r7COv/IXbXNz81vN\n5RdaOlJtbeHwD/muYzvStapptCwUUPFxhmUNZFveUdVn0kjxbZx3bgZ13QJD4VL+\noGets54dTsDyoKxovjal2rMJ24AIO6wARwMwlStVQ0vkZlpFNA60fvxLNEirEV2Q\nin6OOkI/c1394k1VumSuW+Tm8jhpafx1gPlRyY9UDfXeQOyJnGDKON2ZSpqH4ir5\nccLUcruIaPrJ8z5CaRw1ejNPZNeCbjkJq/NF9aunL6EPYTYsNuc/r8yhMwM4+9GB\n4w5PYdJl95p1nfcDtEN+0VHtcR6eF6c9q9D+G9LZ+npSJ/4k2bryHg+bj4eLErYL\nKgSSJQrCF+1gRrrFd0pxSppt/w5zkj16eek+fqTl6KMKaL6agOI22KQINaNVzzrN\nkc9rQK1xBAEODMzcsv2efOGHaBfno7cr22NNBIyftqkXd8zrSTuvwn6cVMxM3sgT\n9oN1sfaVnLzXs8TSEXER0QCAjBgsuEU7oLm2SuF/FY9pQn2GlqpBhpuxre2FwB+Y\nPyDhNAWMVs4iVdrnp9qJmx6xMH+qGlP7MHprsryIL7SnRXmumFmhVJL0Jdid462q\nwUscay/IQe5YqrFXh0HWnHHeo9GF1Z7+TdxWQLzFD7bPgoPN9x0=\n=Joaw\n-----END PGP SIGNATURE-----", "payload": "tree fa7033169d03b79804dca1fc6df47d4ea09e52c6\nparent cfff31bc833070a00578bd6178160aeed56f28ba\nauthor Chris Denton <christophersdenton@gmail.com> 1632316300 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1633286966 +0100\n\nAutomatically convert paths to verbatim\n\nThis allows using longer paths for filesystem operations without the user needing to `canonicalize` or manually prefix paths.\n\nIf the path is already verbatim than this has no effect.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e2d60624162845238fa3b2fbb874eee51daa983", "html_url": "https://github.com/rust-lang/rust/commit/3e2d60624162845238fa3b2fbb874eee51daa983", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e2d60624162845238fa3b2fbb874eee51daa983/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfff31bc833070a00578bd6178160aeed56f28ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfff31bc833070a00578bd6178160aeed56f28ba", "html_url": "https://github.com/rust-lang/rust/commit/cfff31bc833070a00578bd6178160aeed56f28ba"}], "stats": {"total": 176, "additions": 163, "deletions": 13}, "files": [{"sha": "f70c0a883f82a2f311d07963bce56d0fdc6b21f7", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=3e2d60624162845238fa3b2fbb874eee51daa983", "patch": "@@ -990,6 +990,12 @@ extern \"system\" {\n         cchCount2: c_int,\n         bIgnoreCase: BOOL,\n     ) -> c_int;\n+    pub fn GetFullPathNameW(\n+        lpFileName: LPCWSTR,\n+        nBufferLength: DWORD,\n+        lpBuffer: LPWSTR,\n+        lpFilePart: *mut LPWSTR,\n+    ) -> DWORD;\n }\n \n #[link(name = \"ws2_32\")]"}, {"sha": "064a3559739a5c26023f544e80042c4e0df957b4", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=3e2d60624162845238fa3b2fbb874eee51daa983", "patch": "@@ -14,6 +14,7 @@ use crate::sys::time::SystemTime;\n use crate::sys::{c, cvt};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n+use super::path::maybe_verbatim;\n use super::to_u16s;\n \n pub struct File {\n@@ -281,7 +282,7 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = to_u16s(path)?;\n+        let path = maybe_verbatim(path)?;\n         let handle = unsafe {\n             c::CreateFileW(\n                 path.as_ptr(),\n@@ -706,7 +707,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = to_u16s(p)?;\n+        let p = maybe_verbatim(p)?;\n         cvt(unsafe { c::CreateDirectoryW(p.as_ptr(), ptr::null_mut()) })?;\n         Ok(())\n     }\n@@ -715,7 +716,7 @@ impl DirBuilder {\n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = p.to_path_buf();\n     let star = p.join(\"*\");\n-    let path = to_u16s(&star)?;\n+    let path = maybe_verbatim(&star)?;\n \n     unsafe {\n         let mut wfd = mem::zeroed();\n@@ -733,20 +734,20 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p_u16s = to_u16s(p)?;\n+    let p_u16s = maybe_verbatim(p)?;\n     cvt(unsafe { c::DeleteFileW(p_u16s.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = to_u16s(old)?;\n-    let new = to_u16s(new)?;\n+    let old = maybe_verbatim(old)?;\n+    let new = maybe_verbatim(new)?;\n     cvt(unsafe { c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING) })?;\n     Ok(())\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = to_u16s(p)?;\n+    let p = maybe_verbatim(p)?;\n     cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) })?;\n     Ok(())\n }\n@@ -794,7 +795,7 @@ pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n \n pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()> {\n     let original = to_u16s(original)?;\n-    let link = to_u16s(link)?;\n+    let link = maybe_verbatim(link)?;\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     // Formerly, symlink creation required the SeCreateSymbolicLink privilege. For the Windows 10\n     // Creators Update, Microsoft loosened this to allow unprivileged symlink creation if the\n@@ -823,8 +824,8 @@ pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()>\n \n #[cfg(not(target_vendor = \"uwp\"))]\n pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n-    let original = to_u16s(original)?;\n-    let link = to_u16s(link)?;\n+    let original = maybe_verbatim(original)?;\n+    let link = maybe_verbatim(link)?;\n     cvt(unsafe { c::CreateHardLinkW(link.as_ptr(), original.as_ptr(), ptr::null_mut()) })?;\n     Ok(())\n }\n@@ -857,7 +858,7 @@ pub fn lstat(path: &Path) -> io::Result<FileAttr> {\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = to_u16s(p)?;\n+    let p = maybe_verbatim(p)?;\n     unsafe {\n         cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs))?;\n         Ok(())\n@@ -900,8 +901,8 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         }\n         c::PROGRESS_CONTINUE\n     }\n-    let pfrom = to_u16s(from)?;\n-    let pto = to_u16s(to)?;\n+    let pfrom = maybe_verbatim(from)?;\n+    let pto = maybe_verbatim(to)?;\n     let mut size = 0i64;\n     cvt(unsafe {\n         c::CopyFileExW("}, {"sha": "eea7f3247c068a90bad0ddea843daf49c32f199a", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=3e2d60624162845238fa3b2fbb874eee51daa983", "patch": "@@ -1,6 +1,10 @@\n+use super::{c, fill_utf16_buf, to_u16s};\n use crate::ffi::OsStr;\n+use crate::io;\n use crate::mem;\n+use crate::path::Path;\n use crate::path::Prefix;\n+use crate::ptr;\n \n #[cfg(test)]\n mod tests;\n@@ -141,3 +145,96 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n         None => (path, OsStr::new(\"\")),\n     }\n }\n+\n+/// Returns a UTF-16 encoded path capable of bypassing the legacy `MAX_PATH` limits.\n+///\n+/// This path may or may not have a verbatim prefix.\n+pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n+    const LEGACY_MAX_PATH: usize = 260;\n+    // UTF-16 encoded code points, used in parsing and building UTF-16 paths.\n+    // All of these are in the ASCII range so they can be cast directly to `u16`.\n+    const SEP: u16 = b'\\\\' as _;\n+    const ALT_SEP: u16 = b'/' as _;\n+    const QUERY: u16 = b'?' as _;\n+    const COLON: u16 = b':' as _;\n+    const DOT: u16 = b'.' as _;\n+    const U: u16 = b'U' as _;\n+    const N: u16 = b'N' as _;\n+    const C: u16 = b'C' as _;\n+\n+    // \\\\?\\\n+    const VERBATIM_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP];\n+    // \\??\\\n+    const NT_PREFIX: &[u16] = &[SEP, QUERY, QUERY, SEP];\n+    // \\\\?\\UNC\\\n+    const UNC_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP, U, N, C, SEP];\n+\n+    let mut path = to_u16s(path)?;\n+    if path.starts_with(VERBATIM_PREFIX) || path.starts_with(NT_PREFIX) {\n+        // Early return for paths that are already verbatim.\n+        return Ok(path);\n+    } else if path.len() < LEGACY_MAX_PATH {\n+        // Early return if an absolute path is less < 260 UTF-16 code units.\n+        // This is an optimization to avoid calling `GetFullPathNameW` unnecessarily.\n+        match path.as_slice() {\n+            // Starts with `D:`, `D:\\`, `D:/`, etc.\n+            // Does not match if the path starts with a `\\` or `/`.\n+            [drive, COLON, 0] | [drive, COLON, SEP | ALT_SEP, ..]\n+                if *drive != SEP && *drive != ALT_SEP =>\n+            {\n+                return Ok(path);\n+            }\n+            // Starts with `\\\\`, `//`, etc\n+            [SEP | ALT_SEP, SEP | ALT_SEP, ..] => return Ok(path),\n+            _ => {}\n+        }\n+    }\n+\n+    // Firstly, get the absolute path using `GetFullPathNameW`.\n+    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew\n+    let lpfilename = path.as_ptr();\n+    fill_utf16_buf(\n+        // SAFETY: `fill_utf16_buf` ensures the `buffer` and `size` are valid.\n+        // `lpfilename` is a pointer to a null terminated string that is not\n+        // invalidated until after `GetFullPathNameW` returns successfully.\n+        |buffer, size| unsafe {\n+            // While the docs for `GetFullPathNameW` have the standard note\n+            // about needing a `\\\\?\\` path for a long lpfilename, this does not\n+            // appear to be true in practice.\n+            // See:\n+            // https://stackoverflow.com/questions/38036943/getfullpathnamew-and-long-windows-file-paths\n+            // https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html\n+            c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut())\n+        },\n+        |mut absolute| {\n+            path.clear();\n+\n+            // Secondly, add the verbatim prefix. This is easier here because we know the\n+            // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n+            let prefix = match absolute {\n+                // C:\\ => \\\\?\\C:\\\n+                [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n+                // \\\\.\\ => \\\\?\\\n+                [SEP, SEP, DOT, SEP, ..] => {\n+                    absolute = &absolute[4..];\n+                    VERBATIM_PREFIX\n+                }\n+                // Leave \\\\?\\ and \\??\\ as-is.\n+                [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n+                // \\\\ => \\\\?\\UNC\\\n+                [SEP, SEP, ..] => {\n+                    absolute = &absolute[2..];\n+                    UNC_PREFIX\n+                }\n+                // Anything else we leave alone.\n+                _ => &[],\n+            };\n+\n+            path.reserve_exact(prefix.len() + absolute.len() + 1);\n+            path.extend_from_slice(prefix);\n+            path.extend_from_slice(absolute);\n+            path.push(0);\n+        },\n+    )?;\n+    Ok(path)\n+}"}, {"sha": "131d27a99fee15d08b22dacf09c3256cd1e2caf6", "filename": "library/std/src/sys/windows/path/tests.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e2d60624162845238fa3b2fbb874eee51daa983/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs?ref=3e2d60624162845238fa3b2fbb874eee51daa983", "patch": "@@ -42,3 +42,49 @@ fn test_parse_next_component() {\n         (OsStr::new(r\"server\"), OsStr::new(r\"\\\\\\\\\\\\\\\\\\\\\\\\\\share\"))\n     );\n }\n+\n+#[test]\n+fn verbatim() {\n+    use crate::path::Path;\n+    fn check(path: &str, expected: &str) {\n+        let verbatim = maybe_verbatim(Path::new(path)).unwrap();\n+        let verbatim = String::from_utf16_lossy(verbatim.strip_suffix(&[0]).unwrap());\n+        assert_eq!(&verbatim, expected, \"{}\", path);\n+    }\n+\n+    // Ensure long paths are correctly prefixed.\n+    check(\n+        r\"C:\\Program Files\\Rust\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\C:\\Program Files\\Rust\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    check(\n+        r\"\\\\server\\share\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\UNC\\server\\share\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    check(\n+        r\"\\\\.\\PIPE\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\PIPE\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    // `\\\\?\\` prefixed paths are left unchanged...\n+    check(\n+        r\"\\\\?\\verbatim.\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\verbatim.\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    // But `//?/` is not a verbatim prefix so it will be normalized.\n+    check(\n+        r\"//?/E:/verbatim.\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\E:\\verbatim\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+\n+    // For performance, short absolute paths are left unchanged.\n+    check(r\"C:\\Program Files\\Rust\", r\"C:\\Program Files\\Rust\");\n+    check(r\"\\\\server\\share\", r\"\\\\server\\share\");\n+    check(r\"\\\\.\\COM1\", r\"\\\\.\\COM1\");\n+\n+    // Make sure opening a drive will work.\n+    check(\"Z:\", \"Z:\");\n+\n+    // An empty path or a path that contains null are not valid paths.\n+    assert!(maybe_verbatim(Path::new(\"\")).is_err());\n+    assert!(maybe_verbatim(Path::new(\"\\0\")).is_err());\n+}"}]}