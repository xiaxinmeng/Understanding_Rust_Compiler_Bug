{"sha": "7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNmY0NTgxOTQ2ZjlhZThlMmMyM2NkN2UwOWViNGYwM2Q2YzNjYjE=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2016-02-03T17:23:33Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2016-02-03T17:23:33Z"}, "message": "Adress comments", "tree": {"sha": "84f92ea71bd466e128528d52e61fbc3a352b97a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84f92ea71bd466e128528d52e61fbc3a352b97a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "html_url": "https://github.com/rust-lang/rust/commit/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdb1df749e848c2d0e0a87fa6140aa7c74220b80", "html_url": "https://github.com/rust-lang/rust/commit/cdb1df749e848c2d0e0a87fa6140aa7c74220b80"}], "stats": {"total": 92, "additions": 63, "deletions": 29}, "files": [{"sha": "23672d0cc13dfb14cc862135c06adfee2b5cb654", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "patch": "@@ -1475,7 +1475,9 @@ mod tests {\n     use str;\n \n     #[cfg(windows)]\n-    use os::windows::fs::{symlink_dir, symlink_file, symlink_junction};\n+    use os::windows::fs::{symlink_dir, symlink_file};\n+    #[cfg(windows)]\n+    use sys::fs::symlink_junction;\n     #[cfg(unix)]\n     use os::unix::fs::symlink as symlink_dir;\n     #[cfg(unix)]\n@@ -1533,6 +1535,7 @@ mod tests {\n     // `SeCreateSymbolicLinkPrivilege`). Instead of disabling these test on Windows, use this\n     // function to test whether we have permission, and return otherwise. This way, we still don't\n     // run these tests most of the time, but at least we do if the user has the right permissions.\n+    #[cfg(windows)]\n     pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n         let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n \n@@ -1546,6 +1549,9 @@ mod tests {\n                 }\n         }\n     }\n+    #[cfg(not(windows))]\n+    #[allow(unused_variables)]\n+    pub fn got_symlink_permission(tmpdir: &TempDir) -> bool { true }\n \n     #[test]\n     fn file_test_io_smoke_test() {\n@@ -2401,4 +2407,30 @@ mod tests {\n         let res = fs::read_dir(\"/path/that/does/not/exist\");\n         assert_eq!(res.err().unwrap().kind(), ErrorKind::NotFound);\n     }\n+\n+    #[test]\n+    fn create_dir_all_with_junctions() {\n+        let tmpdir = tmpdir();\n+        let target = tmpdir.join(\"target\");\n+\n+        let junction = tmpdir.join(\"junction\");\n+        let b = junction.join(\"a/b\");\n+\n+        let link = tmpdir.join(\"link\");\n+        let d = link.join(\"c/d\");\n+\n+        fs::create_dir(&target).unwrap();\n+\n+        check!(symlink_junction(&target, &junction));\n+        check!(fs::create_dir_all(&b));\n+        // the junction itself is not a directory, but `is_dir()` on a Path follows links\n+        assert!(junction.is_dir());\n+        assert!(b.exists());\n+\n+        if !got_symlink_permission(&tmpdir) { return };\n+        check!(symlink_dir(&target, &link));\n+        check!(fs::create_dir_all(&d));\n+        assert!(link.is_dir());\n+        assert!(d.exists());\n+    }\n }"}, {"sha": "a2e6f467b17c079131f795371a8467521d75c047", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "patch": "@@ -512,12 +512,11 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     for child in try!(readdir(path)) {\n-        let child = try!(child).path();\n-        let stat = try!(lstat(&*child));\n-        if stat.file_type().is_dir() {\n-            try!(remove_dir_all(&*child));\n+        let child = try!(child);\n+        if try!(child.file_type()).is_dir() {\n+            try!(remove_dir_all(&child.path()));\n         } else {\n-            try!(unlink(&*child));\n+            try!(unlink(&child.path()));\n         }\n     }\n     rmdir(path)"}, {"sha": "7ace48fe561101be374681973ab9db7f77bd2936", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=7f6f4581946f9ae8e2c23cd7e09eb4f03d6c3cb1", "patch": "@@ -35,7 +35,7 @@ pub struct FileAttr {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum FileType {\n-    Dir, File, Symlink, ReparsePoint, MountPoint,\n+    Dir, File, SymlinkFile, SymlinkDir, ReparsePoint, MountPoint,\n }\n \n pub struct ReadDir {\n@@ -444,23 +444,30 @@ impl FilePermissions {\n \n impl FileType {\n     fn new(attrs: c::DWORD, reparse_tag: c::DWORD) -> FileType {\n-        if attrs & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-            match reparse_tag {\n-                c::IO_REPARSE_TAG_SYMLINK => FileType::Symlink,\n-                c::IO_REPARSE_TAG_MOUNT_POINT => FileType::MountPoint,\n-                _ => FileType::ReparsePoint,\n-            }\n-        } else if attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n-            FileType::Dir\n-        } else {\n-            FileType::File\n+        match (attrs & c::FILE_ATTRIBUTE_DIRECTORY != 0,\n+               attrs & c::FILE_ATTRIBUTE_REPARSE_POINT != 0,\n+               reparse_tag) {\n+            (false, false, _) => FileType::File,\n+            (true, false, _) => FileType::Dir,\n+            (false, true, c::IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkFile,\n+            (true, true, c::IO_REPARSE_TAG_SYMLINK) => FileType::SymlinkDir,\n+            (true, true, c::IO_REPARSE_TAG_MOUNT_POINT) => FileType::MountPoint,\n+            (_, true, _) => FileType::ReparsePoint,\n+            // Note: if a _file_ has a reparse tag of the type IO_REPARSE_TAG_MOUNT_POINT it is\n+            // invalid, as junctions always have to be dirs. We set the filetype to ReparsePoint\n+            // to indicate it is something symlink-like, but not something you can follow.\n         }\n     }\n \n     pub fn is_dir(&self) -> bool { *self == FileType::Dir }\n     pub fn is_file(&self) -> bool { *self == FileType::File }\n     pub fn is_symlink(&self) -> bool {\n-        *self == FileType::Symlink || *self == FileType::MountPoint\n+        *self == FileType::SymlinkFile ||\n+        *self == FileType::SymlinkDir ||\n+        *self == FileType::MountPoint\n+    }\n+    pub fn is_symlink_dir(&self) -> bool {\n+        *self == FileType::SymlinkDir || *self == FileType::MountPoint\n     }\n }\n \n@@ -519,18 +526,14 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n \n pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n     for child in try!(readdir(path)) {\n-        let child = try!(child).path();\n-        let stat = try!(lstat(&*child));\n-        if stat.data.dwFileAttributes & c::FILE_ATTRIBUTE_DIRECTORY != 0 {\n-            if stat.data.dwFileAttributes & c::FILE_ATTRIBUTE_REPARSE_POINT != 0 {\n-                // remove junctions and directory symlinks with rmdir\n-                try!(rmdir(&*child));\n-            } else {\n-                try!(remove_dir_all(&*child));\n-            }\n+        let child = try!(child);\n+        let child_type = try!(child.file_type());\n+        if child_type.is_dir() {\n+            try!(remove_dir_all(&child.path()));\n+        } else if child_type.is_symlink_dir() {\n+            try!(rmdir(&child.path()));\n         } else {\n-            // remove files and file symlinks\n-            try!(unlink(&*child));\n+            try!(unlink(&child.path()));\n         }\n     }\n     rmdir(path)"}]}