{"sha": "5f52aecb1e7a53bf46280d057654746c34e89859", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNTJhZWNiMWU3YTUzYmY0NjI4MGQwNTc2NTQ3NDZjMzRlODk4NTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T02:24:43Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-04-15T02:24:43Z"}, "message": "core::rt: Schedulers only need a single cleanup_job at a time\n\nEach context switch has up to one cleanup job and it is always\nexecuted immediately after the context switch.", "tree": {"sha": "706a326b6f06c67c93db63e66ffeb9080694d22d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/706a326b6f06c67c93db63e66ffeb9080694d22d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f52aecb1e7a53bf46280d057654746c34e89859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f52aecb1e7a53bf46280d057654746c34e89859", "html_url": "https://github.com/rust-lang/rust/commit/5f52aecb1e7a53bf46280d057654746c34e89859", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f52aecb1e7a53bf46280d057654746c34e89859/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b084bad250e58c4003a1df40584f6385f44aac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b084bad250e58c4003a1df40584f6385f44aac1", "html_url": "https://github.com/rust-lang/rust/commit/6b084bad250e58c4003a1df40584f6385f44aac1"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "11934d676e660c879a7245811b02c496e32c0d3e", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5f52aecb1e7a53bf46280d057654746c34e89859/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f52aecb1e7a53bf46280d057654746c34e89859/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=5f52aecb1e7a53bf46280d057654746c34e89859", "patch": "@@ -38,12 +38,9 @@ pub struct Scheduler {\n     priv saved_context: Context,\n     /// The currently executing task\n     priv current_task: Option<~Task>,\n-    /// A queue of jobs to perform immediately upon return from task\n-    /// context to scheduler context.\n-    /// XXX: This probably should be a single cleanup action and it\n-    /// should run after a context switch, not on return from the\n-    /// scheduler\n-    priv cleanup_jobs: ~[CleanupJob]\n+    /// An action performed after a context switch on behalf of the\n+    /// code running before the context switch\n+    priv cleanup_job: Option<CleanupJob>\n }\n \n // XXX: Some hacks to put a &fn in Scheduler without borrowck\n@@ -84,7 +81,7 @@ pub impl Scheduler {\n             stack_pool: StackPool::new(),\n             saved_context: Context::empty(),\n             current_task: None,\n-            cleanup_jobs: ~[]\n+            cleanup_job: None\n         }\n     }\n \n@@ -165,7 +162,7 @@ pub impl Scheduler {\n         assert!(self.current_task.is_none());\n \n         // Running tasks may have asked us to do some cleanup\n-        self.run_cleanup_jobs();\n+        self.run_cleanup_job();\n     }\n \n \n@@ -212,7 +209,7 @@ pub impl Scheduler {\n             Context::swap(last_task_context, sched_context);\n         }\n \n-        self.run_cleanup_jobs();\n+        self.run_cleanup_job();\n     }\n \n     /// Switch directly to another task, without going through the scheduler.\n@@ -233,29 +230,33 @@ pub impl Scheduler {\n             Context::swap(last_task_context, next_task_context);\n         }\n \n-        self.run_cleanup_jobs();\n+        self.run_cleanup_job();\n     }\n \n     // * Other stuff\n \n     fn in_task_context(&self) -> bool { self.current_task.is_some() }\n \n     fn enqueue_cleanup_job(&mut self, job: CleanupJob) {\n-        self.cleanup_jobs.unshift(job);\n+        assert!(self.cleanup_job.is_none());\n+        self.cleanup_job = Some(job);\n     }\n \n-    fn run_cleanup_jobs(&mut self) {\n+    fn run_cleanup_job(&mut self) {\n         rtdebug!(\"running cleanup jobs\");\n \n-        while !self.cleanup_jobs.is_empty() {\n-            match self.cleanup_jobs.pop() {\n-                RescheduleTask(task) => {\n-                    // NB: Pushing to the *front* of the queue\n-                    self.task_queue.push_front(task);\n-                }\n-                RecycleTask(task) => task.recycle(&mut self.stack_pool),\n-                GiveTask(task, f) => (f.to_fn())(self, task)\n+        if self.cleanup_job.is_none() {\n+            return;\n+        }\n+\n+        let cleanup_job = self.cleanup_job.swap_unwrap();\n+        match cleanup_job {\n+            RescheduleTask(task) => {\n+                // NB: Pushing to the *front* of the queue\n+                self.task_queue.push_front(task);\n             }\n+            RecycleTask(task) => task.recycle(&mut self.stack_pool),\n+            GiveTask(task, f) => (f.to_fn())(self, task)\n         }\n     }\n \n@@ -271,16 +272,15 @@ pub impl Scheduler {\n     fn get_contexts(&mut self) -> (&'self mut Context,\n                                    Option<&'self mut Context>,\n                                    Option<&'self mut Context>) {\n-        let last_task = if !self.cleanup_jobs.is_empty() {\n-            let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n-            let last_task: &'self Task = match last_job {\n-                &RescheduleTask(~ref task) => task,\n-                &RecycleTask(~ref task) => task,\n-                &GiveTask(~ref task, _) => task,\n-            };\n-            Some(last_task)\n-        } else {\n-            None\n+        let last_task = match self.cleanup_job {\n+            Some(RescheduleTask(~ref task)) |\n+            Some(RecycleTask(~ref task)) |\n+            Some(GiveTask(~ref task, _)) => {\n+                Some(task)\n+            }\n+            None => {\n+                None\n+            }\n         };\n         // XXX: Pattern matching mutable pointers above doesn't work\n         // because borrowck thinks the three patterns are conflicting\n@@ -329,7 +329,7 @@ pub impl Task {\n             // have asked us to do some cleanup.\n             let mut sched = ThreadLocalScheduler::new();\n             let sched = sched.get_scheduler();\n-            sched.run_cleanup_jobs();\n+            sched.run_cleanup_job();\n \n             start();\n "}]}