{"sha": "99d02fe583f4747f67debc1973a3eb3ca62e2005", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5ZDAyZmU1ODNmNDc0N2Y2N2RlYmMxOTczYTNlYjNjYTYyZTIwMDU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-10T17:14:31Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-09-15T21:00:05Z"}, "message": "start query-based modules", "tree": {"sha": "61af7d14bb5eafec446ee5b1bc9d07d13ef70006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61af7d14bb5eafec446ee5b1bc9d07d13ef70006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99d02fe583f4747f67debc1973a3eb3ca62e2005", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99d02fe583f4747f67debc1973a3eb3ca62e2005", "html_url": "https://github.com/rust-lang/rust/commit/99d02fe583f4747f67debc1973a3eb3ca62e2005", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99d02fe583f4747f67debc1973a3eb3ca62e2005/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ee4c287f9c95738f0482bf635ccc3801fc2fea2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ee4c287f9c95738f0482bf635ccc3801fc2fea2", "html_url": "https://github.com/rust-lang/rust/commit/6ee4c287f9c95738f0482bf635ccc3801fc2fea2"}], "stats": {"total": 402, "additions": 361, "deletions": 41}, "files": [{"sha": "4c92951b148f75c6e48eac5f1bebfcc1e2be2f0e", "filename": "crates/libanalysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2FCargo.toml?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -11,6 +11,7 @@ parking_lot = \"0.6.3\"\n once_cell = \"0.1.5\"\n rayon = \"1.0.2\"\n fst = \"0.3.1\"\n+im = \"12.0.0\"\n libsyntax2 = { path = \"../libsyntax2\" }\n libeditor = { path = \"../libeditor\" }\n "}, {"sha": "335c79e76da5f2010afc99a60d415e705179bbf8", "filename": "crates/libanalysis/src/db.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fdb.rs?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -0,0 +1,121 @@\n+use std::{\n+    hash::Hash,\n+    sync::Arc,\n+};\n+use libsyntax2::{File};\n+use im;\n+use {\n+    FileId,\n+    imp::{FileResolverImp},\n+};\n+\n+#[derive(Clone)]\n+pub(crate) struct Db {\n+    file_resolver: FileResolverImp,\n+    files: im::HashMap<FileId, Arc<String>>,\n+}\n+\n+impl Db {\n+    pub(crate) fn new() -> Db {\n+        Db {\n+            file_resolver: FileResolverImp::default(),\n+            files: im::HashMap::new(),\n+        }\n+    }\n+    pub(crate) fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n+        match text {\n+            None => {\n+                self.files.remove(&file_id);\n+            }\n+            Some(text) => {\n+                self.files.insert(file_id, Arc::new(text));\n+            }\n+        }\n+    }\n+    pub(crate) fn set_file_resolver(&mut self, file_resolver: FileResolverImp) {\n+        self.file_resolver = file_resolver\n+    }\n+    pub(crate) fn query_ctx(&self) -> QueryCtx {\n+        QueryCtx { db: self.clone() }\n+    }\n+}\n+\n+pub(crate) struct QueryCtx {\n+    db: Db\n+}\n+\n+impl QueryCtx {\n+    pub(crate) fn get<Q: Get>(&self, params: &Q::Params) -> Q::Output {\n+        Q::get(self, params)\n+    }\n+}\n+\n+pub(crate) trait Query {\n+    const ID: u32;\n+    type Params: Hash;\n+    type Output;\n+}\n+\n+pub(crate) trait Get: Query {\n+    fn get(ctx: &QueryCtx, params: &Self::Params) -> Self::Output;\n+}\n+\n+impl<T: Eval> Get for T {\n+    fn get(ctx: &QueryCtx, params: &Self::Params) -> Self::Output {\n+        Self::eval(ctx, params)\n+    }\n+}\n+\n+pub(crate) trait Eval: Query {\n+    fn eval(ctx: &QueryCtx, params: &Self::Params) -> Self::Output;\n+}\n+\n+pub(crate) struct DbFiles {\n+    db: Db,\n+}\n+\n+impl DbFiles {\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item=FileId> + 'a {\n+        self.db.files.keys().cloned()\n+    }\n+    pub(crate) fn file_resolver(&self) -> FileResolverImp {\n+        self.db.file_resolver.clone()\n+    }\n+}\n+\n+pub(crate) enum Files {}\n+impl Query for Files {\n+    const ID: u32 = 1;\n+    type Params = ();\n+    type Output = DbFiles;\n+}\n+impl Get for Files {\n+    fn get(ctx: &QueryCtx, _params: &()) -> DbFiles {\n+        DbFiles { db: ctx.db.clone() }\n+    }\n+}\n+\n+enum FileText {}\n+impl Query for FileText {\n+    const ID: u32 = 10;\n+    type Params = FileId;\n+    type Output = Arc<String>;\n+}\n+impl Get for FileText {\n+    fn get(ctx: &QueryCtx, file_id: &FileId) -> Arc<String> {\n+        ctx.db.files[file_id].clone()\n+    }\n+}\n+\n+pub(crate) enum FileSyntax {}\n+impl Query for FileSyntax {\n+    const ID: u32 = 20;\n+    type Params = FileId;\n+    type Output = File;\n+}\n+impl Eval for FileSyntax {\n+    fn eval(ctx: &QueryCtx, file_id: &FileId) -> File {\n+        let text = ctx.get::<FileText>(file_id);\n+        File::parse(&text)\n+    }\n+}"}, {"sha": "68cf31e08f570380c3729a2c779bee79499f4e9a", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -9,12 +9,15 @@ extern crate rayon;\n extern crate relative_path;\n #[macro_use]\n extern crate crossbeam_channel;\n+extern crate im;\n \n mod symbol_index;\n mod module_map;\n+mod module_map_db;\n mod imp;\n mod job;\n mod roots;\n+mod db;\n \n use std::{\n     sync::Arc,"}, {"sha": "79b88cac2ff2fb94a790d61b07f35fd6db060b36", "filename": "crates/libanalysis/src/module_map.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map.rs?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -244,31 +244,38 @@ impl Link {\n             self.points_to = Vec::new();\n             return;\n         }\n+        let (points_to, problem) = resolve_submodule(self.owner.0, &self.name(), file_resolver);\n+        self.problem = problem;\n+        self.points_to = points_to.into_iter().map(ModuleId).collect();\n+    }\n+}\n \n-        let mod_name = file_resolver.file_stem(self.owner.0);\n-        let is_dir_owner =\n-            mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+pub(crate) fn resolve_submodule(file_id: FileId, name: &SmolStr, file_resolver: &FileResolverImp) -> (Vec<FileId>, Option<Problem>) {\n+    let mod_name = file_resolver.file_stem(file_id);\n+    let is_dir_owner =\n+        mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n \n-        let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", self.name()));\n-        let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", self.name()));\n-        if is_dir_owner {\n-            self.points_to = [&file_mod, &dir_mod].iter()\n-                .filter_map(|path| file_resolver.resolve(self.owner.0, path))\n-                .map(ModuleId)\n-                .collect();\n-            self.problem = if self.points_to.is_empty() {\n-                Some(Problem::UnresolvedModule {\n-                    candidate: file_mod,\n-                })\n-            } else {\n-                None\n-            }\n-        } else {\n-            self.points_to = Vec::new();\n-            self.problem = Some(Problem::NotDirOwner {\n-                move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n+    let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n+    let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n+    let points_to: Vec<FileId>;\n+    let problem: Option<Problem>;\n+    if is_dir_owner {\n+        points_to = [&file_mod, &dir_mod].iter()\n+            .filter_map(|path| file_resolver.resolve(file_id, path))\n+            .collect();\n+        problem = if points_to.is_empty() {\n+            Some(Problem::UnresolvedModule {\n                 candidate: file_mod,\n-            });\n+            })\n+        } else {\n+            None\n         }\n+    } else {\n+        points_to = Vec::new();\n+        problem = Some(Problem::NotDirOwner {\n+            move_to: RelativePathBuf::from(format!(\"../{}/mod.rs\", mod_name)),\n+            candidate: file_mod,\n+        });\n     }\n+    (points_to, problem)\n }"}, {"sha": "1ef87ab3f2f84825d8fd73efe62e8c85308e9366", "filename": "crates/libanalysis/src/module_map_db.rs", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fmodule_map_db.rs?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -0,0 +1,189 @@\n+use std::sync::Arc;\n+use {\n+    FileId,\n+    db::{Query, Eval, QueryCtx, FileSyntax, Files},\n+    module_map::resolve_submodule,\n+};\n+\n+enum ModuleDescr {}\n+impl Query for ModuleDescr {\n+    const ID: u32 = 30;\n+    type Params = FileId;\n+    type Output = Arc<descr::ModuleDescr>;\n+}\n+\n+enum ResolveSubmodule {}\n+impl Query for ResolveSubmodule {\n+    const ID: u32 = 31;\n+    type Params = (FileId, descr::Submodule);\n+    type Output = Arc<Vec<FileId>>;\n+}\n+\n+enum ParentModule {}\n+impl Query for ParentModule {\n+    const ID: u32 = 40;\n+    type Params = FileId;\n+    type Output = Arc<Vec<FileId>>;\n+}\n+\n+impl Eval for ModuleDescr {\n+    fn eval(ctx: &QueryCtx, file_id: &FileId) -> Arc<descr::ModuleDescr> {\n+        let file = ctx.get::<FileSyntax>(file_id);\n+        Arc::new(descr::ModuleDescr::new(file.ast()))\n+    }\n+}\n+\n+impl Eval for ResolveSubmodule {\n+    fn eval(ctx: &QueryCtx, &(file_id, ref submodule): &(FileId, descr::Submodule)) -> Arc<Vec<FileId>> {\n+        let files = ctx.get::<Files>(&());\n+        let res = resolve_submodule(file_id, &submodule.name, &files.file_resolver()).0;\n+        Arc::new(res)\n+    }\n+}\n+\n+impl Eval for ParentModule {\n+    fn eval(ctx: &QueryCtx, file_id: &FileId) -> Arc<Vec<FileId>> {\n+        let files = ctx.get::<Files>(&());\n+        let res = files.iter()\n+            .map(|parent_id| (parent_id, ctx.get::<ModuleDescr>(&parent_id)))\n+            .filter(|(parent_id, descr)| {\n+                descr.submodules.iter()\n+                    .any(|subm| {\n+                        ctx.get::<ResolveSubmodule>(&(*parent_id, subm.clone()))\n+                            .iter()\n+                            .any(|it| it == file_id)\n+                    })\n+            })\n+            .map(|(id, _)| id)\n+            .collect();\n+        Arc::new(res)\n+    }\n+}\n+\n+mod descr {\n+    use libsyntax2::{\n+        SmolStr,\n+        ast::{self, NameOwner},\n+    };\n+\n+    pub struct ModuleDescr {\n+        pub submodules: Vec<Submodule>\n+    }\n+\n+    impl ModuleDescr {\n+        pub fn new(root: ast::Root) -> ModuleDescr {\n+            let submodules = root\n+                .modules()\n+                .filter_map(|module| {\n+                    let name = module.name()?.text();\n+                    if !module.has_semi() {\n+                        return None;\n+                    }\n+                    Some(Submodule { name })\n+                }).collect();\n+\n+            ModuleDescr { submodules } }\n+    }\n+\n+    #[derive(Clone, Hash)]\n+    pub struct Submodule {\n+        pub name: SmolStr,\n+    }\n+\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use im;\n+    use relative_path::{RelativePath, RelativePathBuf};\n+    use {\n+        db::Db,\n+        imp::FileResolverImp,\n+        FileId, FileResolver,\n+    };\n+\n+    #[derive(Debug)]\n+    struct FileMap(im::HashMap<FileId, RelativePathBuf>);\n+\n+    impl FileResolver for FileMap {\n+        fn file_stem(&self, file_id: FileId) -> String {\n+            self.0[&file_id].file_stem().unwrap().to_string()\n+        }\n+        fn resolve(&self, file_id: FileId, rel: &RelativePath) -> Option<FileId> {\n+            let path = self.0[&file_id].join(rel).normalize();\n+            self.0.iter()\n+                .filter_map(|&(id, ref p)| Some(id).filter(|_| p == &path))\n+                .next()\n+        }\n+    }\n+\n+    struct Fixture {\n+        next_file_id: u32,\n+        fm: im::HashMap<FileId, RelativePathBuf>,\n+        db: Db,\n+    }\n+\n+    impl Fixture {\n+        fn new() -> Fixture {\n+            Fixture {\n+                next_file_id: 1,\n+                fm: im::HashMap::new(),\n+                db: Db::new(),\n+            }\n+        }\n+        fn add_file(&mut self, path: &str, text: &str) -> FileId {\n+            assert!(path.starts_with(\"/\"));\n+            let file_id = FileId(self.next_file_id);\n+            self.next_file_id += 1;\n+            self.fm.insert(file_id, RelativePathBuf::from(&path[1..]));\n+            self.db.change_file(file_id, Some(text.to_string()));\n+            self.db.set_file_resolver(FileResolverImp::new(\n+                Arc::new(FileMap(self.fm.clone()))\n+            ));\n+\n+            file_id\n+        }\n+        fn remove_file(&mut self, file_id: FileId) {\n+            self.fm.remove(&file_id);\n+            self.db.change_file(file_id, None);\n+            self.db.set_file_resolver(FileResolverImp::new(\n+                Arc::new(FileMap(self.fm.clone()))\n+            ))\n+        }\n+        fn change_file(&mut self, file_id: FileId, new_text: &str) {\n+            self.db.change_file(file_id, Some(new_text.to_string()));\n+        }\n+        fn check_parent_modules(&self, file_id: FileId, expected: &[FileId]) {\n+            let ctx = self.db.query_ctx();\n+            let actual = ctx.get::<ParentModule>(&file_id);\n+            assert_eq!(actual.as_slice(), expected);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_parent_module() {\n+        let mut f = Fixture::new();\n+        let foo = f.add_file(\"/foo.rs\", \"\");\n+        f.check_parent_modules(foo, &[]);\n+\n+        let lib = f.add_file(\"/lib.rs\", \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib]);\n+\n+        f.change_file(lib, \"\");\n+        f.check_parent_modules(foo, &[]);\n+\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib]);\n+\n+        f.change_file(lib, \"mod bar;\");\n+        f.check_parent_modules(foo, &[]);\n+\n+        f.change_file(lib, \"mod foo;\");\n+        f.check_parent_modules(foo, &[lib]);\n+\n+        f.remove_file(lib);\n+        f.check_parent_modules(foo, &[]);\n+    }\n+\n+}"}, {"sha": "547f85958ea7be406c86e820d5623d1753a0124c", "filename": "crates/libanalysis/tests/tests.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Flibanalysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Ftests%2Ftests.rs?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -14,24 +14,6 @@ use test_utils::assert_eq_dbg;\n #[derive(Debug)]\n struct FileMap(Vec<(FileId, RelativePathBuf)>);\n \n-fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost {\n-    let mut host = AnalysisHost::new();\n-    let mut file_map = Vec::new();\n-    for (id, &(path, contents)) in files.iter().enumerate() {\n-        let file_id = FileId((id + 1) as u32);\n-        assert!(path.starts_with('/'));\n-        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        host.change_file(file_id, Some(contents.to_string()));\n-        file_map.push((file_id, path));\n-    }\n-    host.set_file_resolver(Arc::new(FileMap(file_map)));\n-    host\n-}\n-\n-fn analysis(files: &'static [(&'static str, &'static str)]) -> Analysis {\n-    analysis_host(files).analysis()\n-}\n-\n impl FileMap {\n     fn iter<'a>(&'a self) -> impl Iterator<Item=(FileId, &'a RelativePath)> + 'a {\n         self.0.iter().map(|(id, path)| (*id, path.as_relative_path()))\n@@ -56,6 +38,23 @@ impl FileResolver for FileMap {\n     }\n }\n \n+fn analysis_host(files: &'static [(&'static str, &'static str)]) -> AnalysisHost {\n+    let mut host = AnalysisHost::new();\n+    let mut file_map = Vec::new();\n+    for (id, &(path, contents)) in files.iter().enumerate() {\n+        let file_id = FileId((id + 1) as u32);\n+        assert!(path.starts_with('/'));\n+        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+        host.change_file(file_id, Some(contents.to_string()));\n+        file_map.push((file_id, path));\n+    }\n+    host.set_file_resolver(Arc::new(FileMap(file_map)));\n+    host\n+}\n+\n+fn analysis(files: &'static [(&'static str, &'static str)]) -> Analysis {\n+    analysis_host(files).analysis()\n+}\n \n #[test]\n fn test_resolve_module() {"}, {"sha": "fc20730b88800d278194ca8be9424049ae361f03", "filename": "crates/server/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Fserver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/99d02fe583f4747f67debc1973a3eb3ca62e2005/crates%2Fserver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2FCargo.toml?ref=99d02fe583f4747f67debc1973a3eb3ca62e2005", "patch": "@@ -17,7 +17,7 @@ log = \"0.4.3\"\n url_serde = \"0.2.0\"\n languageserver-types = \"0.49.0\"\n walkdir = \"2.2.0\"\n-im = { version = \"11.0.1\", features = [\"arc\"] }\n+im = \"12.0.0\"\n cargo_metadata = \"0.6.0\"\n text_unit = { version = \"0.1.2\", features = [\"serde\"] }\n smol_str = { version = \"0.1.5\", features = [\"serde\"] }"}]}