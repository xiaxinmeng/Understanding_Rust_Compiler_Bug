{"sha": "89571a1bbc25a03ac0195460c7ec463d3f089def", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NTcxYTFiYmMyNWEwM2FjMDE5NTQ2MGM3ZWM0NjNkM2YwODlkZWY=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-03-10T03:21:37Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-03-26T00:13:04Z"}, "message": "Tweak chained operators diagnostic\n\nUse more selective spans\nImprove suggestion output\nBe more selective when displaying suggestions\nSilence some knock-down type errors", "tree": {"sha": "bbb9a94a979d337794929fd66d07f769d63ae480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbb9a94a979d337794929fd66d07f769d63ae480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89571a1bbc25a03ac0195460c7ec463d3f089def", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89571a1bbc25a03ac0195460c7ec463d3f089def", "html_url": "https://github.com/rust-lang/rust/commit/89571a1bbc25a03ac0195460c7ec463d3f089def", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89571a1bbc25a03ac0195460c7ec463d3f089def/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8", "html_url": "https://github.com/rust-lang/rust/commit/3c1d9adb3cb3aad4233075fa296fc3c70b42cdb8"}], "stats": {"total": 357, "additions": 197, "deletions": 160}, "files": [{"sha": "4771031984d1e4a041d4cfcb1d9e941fda378bff", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 98, "deletions": 46, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=89571a1bbc25a03ac0195460c7ec463d3f089def", "patch": "@@ -459,9 +459,18 @@ impl<'a> Parser<'a> {\n         err: &mut DiagnosticBuilder<'_>,\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n-    ) {\n+    ) -> bool /* recover */ {\n         if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n-            match (op.node, &outer_op.node) {\n+            if let ExprKind::Field(_, ident) = l1.kind {\n+                if ident.as_str().parse::<i32>().is_err() && !matches!(r1.kind, ExprKind::Lit(_)) {\n+                    // The parser has encountered `foo.bar<baz`, the likelihood of the turbofish\n+                    // suggestion being the only one to apply is high.\n+                    return false;\n+                }\n+            }\n+            return match (op.node, &outer_op.node) {\n+                // `x == y == z`\n+                (BinOpKind::Eq, AssocOp::Equal) |\n                 // `x < y < z` and friends.\n                 (BinOpKind::Lt, AssocOp::Less) | (BinOpKind::Lt, AssocOp::LessEqual) |\n                 (BinOpKind::Le, AssocOp::LessEqual) | (BinOpKind::Le, AssocOp::Less) |\n@@ -472,35 +481,65 @@ impl<'a> Parser<'a> {\n                         self.span_to_snippet(e.span)\n                             .unwrap_or_else(|_| pprust::expr_to_string(&e))\n                     };\n-                    err.span_suggestion(\n-                        inner_op.span.to(outer_op.span),\n-                        \"split the comparison into two...\",\n-                        format!(\n-                            \"{} {} {} && {} {}\",\n-                            expr_to_str(&l1),\n-                            op.node.to_string(),\n-                            expr_to_str(&r1),\n-                            expr_to_str(&r1),\n-                            outer_op.node.to_ast_binop().unwrap().to_string(),\n-                        ),\n+                    err.span_suggestion_verbose(\n+                            inner_op.span.shrink_to_hi(),\n+                        \"split the comparison into two\",\n+                        format!(\" && {}\", expr_to_str(&r1)),\n                         Applicability::MaybeIncorrect,\n                     );\n-                    err.span_suggestion(\n-                        inner_op.span.to(outer_op.span),\n-                        \"...or parenthesize one of the comparisons\",\n-                        format!(\n-                            \"({} {} {}) {}\",\n-                            expr_to_str(&l1),\n-                            op.node.to_string(),\n-                            expr_to_str(&r1),\n-                            outer_op.node.to_ast_binop().unwrap().to_string(),\n-                        ),\n+                    false // Keep the current parse behavior, where the AST is `(x < y) < z`.\n+                }\n+                // `x == y < z`\n+                (BinOpKind::Eq, AssocOp::Less) | (BinOpKind::Eq, AssocOp::LessEqual) |\n+                (BinOpKind::Eq, AssocOp::Greater) | (BinOpKind::Eq, AssocOp::GreaterEqual) => {\n+                    // Consume `/`z`/outer-op-rhs.\n+                    let snapshot = self.clone();\n+                    match self.parse_expr() {\n+                        Ok(r2) => {\n+                            err.multipart_suggestion(\n+                                \"parenthesize the comparison\",\n+                                vec![\n+                                    (r1.span.shrink_to_lo(), \"(\".to_string()),\n+                                    (r2.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            true\n+                        }\n+                        Err(mut expr_err) => {\n+                            expr_err.cancel();\n+                            mem::replace(self, snapshot);\n+                            false\n+                        }\n+                    }\n+                }\n+                // `x > y == z`\n+                (BinOpKind::Lt, AssocOp::Equal) | (BinOpKind::Le, AssocOp::Equal) |\n+                (BinOpKind::Gt, AssocOp::Equal) | (BinOpKind::Ge, AssocOp::Equal) => {\n+                    let snapshot = self.clone();\n+                    err.multipart_suggestion(\n+                        \"parenthesize the comparison\",\n+                        vec![\n+                            (l1.span.shrink_to_lo(), \"(\".to_string()),\n+                            (r1.span.shrink_to_hi(), \")\".to_string()),\n+                        ],\n                         Applicability::MaybeIncorrect,\n                     );\n+                    match self.parse_expr() {\n+                        Ok(_) => {\n+                            true\n+                        }\n+                        Err(mut expr_err) => {\n+                            expr_err.cancel();\n+                            mem::replace(self, snapshot);\n+                            false\n+                        }\n+                    }\n                 }\n-                _ => {}\n-            }\n+                _ => false,\n+            };\n         }\n+        false\n     }\n \n     /// Produces an error if comparison operators are chained (RFC #558).\n@@ -534,31 +573,26 @@ impl<'a> Parser<'a> {\n             |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err, AttrVec::new())));\n \n         match inner_op.kind {\n-            ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n-                // Respan to include both operators.\n-                let op_span = op.span.to(self.prev_token.span);\n-                let mut err =\n-                    self.struct_span_err(op_span, \"comparison operators cannot be chained\");\n-\n-                // If it looks like a genuine attempt to chain operators (as opposed to a\n-                // misformatted turbofish, for instance), suggest a correct form.\n-                self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n+            ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n+                let mut err = self.struct_span_err(\n+                    vec![op.span, self.prev_token.span],\n+                    \"comparison operators cannot be chained\",\n+                );\n \n                 let suggest = |err: &mut DiagnosticBuilder<'_>| {\n                     err.span_suggestion_verbose(\n-                        op_span.shrink_to_lo(),\n+                        op.span.shrink_to_lo(),\n                         TURBOFISH,\n                         \"::\".to_string(),\n                         Applicability::MaybeIncorrect,\n                     );\n                 };\n \n-                if op.node == BinOpKind::Lt &&\n-                    outer_op.node == AssocOp::Less ||  // Include `<` to provide this recommendation\n-                    outer_op.node == AssocOp::Greater\n-                // even in a case like the following:\n+                if op.node == BinOpKind::Lt && outer_op.node == AssocOp::Less\n+                    || outer_op.node == AssocOp::Greater\n                 {\n-                    //     Foo<Bar<Baz<Qux, ()>>>\n+                    // Include `<` to provide this recommendation\n+                    // even in a case like `Foo<Bar<Baz<Qux, ()>>>`\n                     if outer_op.node == AssocOp::Less {\n                         let snapshot = self.clone();\n                         self.bump();\n@@ -617,15 +651,33 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                     } else {\n-                        // All we know is that this is `foo < bar >` and *nothing* else. Try to\n-                        // be helpful, but don't attempt to recover.\n-                        err.help(TURBOFISH);\n-                        err.help(\"or use `(...)` if you meant to specify fn arguments\");\n-                        // These cases cause too many knock-down errors, bail out (#61329).\n-                        Err(err)\n+                        if !matches!(l1.kind, ExprKind::Lit(_))\n+                            && !matches!(r1.kind, ExprKind::Lit(_))\n+                        {\n+                            // All we know is that this is `foo < bar >` and *nothing* else. Try to\n+                            // be helpful, but don't attempt to recover.\n+                            err.help(TURBOFISH);\n+                            err.help(\"or use `(...)` if you meant to specify fn arguments\");\n+                        }\n+\n+                        // If it looks like a genuine attempt to chain operators (as opposed to a\n+                        // misformatted turbofish, for instance), suggest a correct form.\n+                        if self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op)\n+                        {\n+                            err.emit();\n+                            mk_err_expr(self, inner_op.span.to(self.prev_token.span))\n+                        } else {\n+                            // These cases cause too many knock-down errors, bail out (#61329).\n+                            Err(err)\n+                        }\n                     };\n                 }\n+                let recover =\n+                    self.attempt_chained_comparison_suggestion(&mut err, inner_op, outer_op);\n                 err.emit();\n+                if recover {\n+                    return mk_err_expr(self, inner_op.span.to(self.prev_token.span));\n+                }\n             }\n             _ => {}\n         }"}, {"sha": "10972697f9fcdc7af0373f94d1493e80b785329e", "filename": "src/test/ui/did_you_mean/issue-40396.stderr", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40396.stderr?ref=89571a1bbc25a03ac0195460c7ec463d3f089def", "patch": "@@ -2,16 +2,8 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:2:20\n    |\n LL |     (0..13).collect<Vec<i32>>();\n-   |                    ^^^^^\n+   |                    ^   ^\n    |\n-help: split the comparison into two...\n-   |\n-LL |     (0..13).collect < Vec && Vec <i32>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     ((0..13).collect < Vec) <i32>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>>();\n@@ -21,7 +13,7 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:4:8\n    |\n LL |     Vec<i32>::new();\n-   |        ^^^^^\n+   |        ^   ^\n    |\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n@@ -32,16 +24,8 @@ error: comparison operators cannot be chained\n   --> $DIR/issue-40396.rs:6:20\n    |\n LL |     (0..13).collect<Vec<i32>();\n-   |                    ^^^^^\n-   |\n-help: split the comparison into two...\n-   |\n-LL |     (0..13).collect < Vec && Vec <i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |                    ^   ^\n    |\n-LL |     ((0..13).collect < Vec) <i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     (0..13).collect::<Vec<i32>();"}, {"sha": "bbd46082c9f901bcc6c22f8de14f1759029bb188", "filename": "src/test/ui/parser/chained-comparison-suggestion.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.rs?ref=89571a1bbc25a03ac0195460c7ec463d3f089def", "patch": "@@ -37,4 +37,17 @@ fn comp8() {\n     //~^ ERROR mismatched types\n }\n \n+fn comp9() {\n+    1 == 2 < 3; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp10() {\n+    1 > 2 == false; //~ ERROR comparison operators cannot be chained\n+}\n+\n+fn comp11() {\n+    1 == 2 == 3; //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "067920d12f486c6595229d8eef6c896ba9a055b6", "filename": "src/test/ui/parser/chained-comparison-suggestion.stderr", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fchained-comparison-suggestion.stderr?ref=89571a1bbc25a03ac0195460c7ec463d3f089def", "patch": "@@ -2,127 +2,122 @@ error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:4:7\n    |\n LL |     1 < 2 <= 3;\n-   |       ^^^^^^\n+   |       ^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 < 2 && 2 <= 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 < 2) <= 3;\n-   |     ^^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:9:7\n    |\n LL |     1 < 2 < 3;\n-   |       ^^^^^\n+   |       ^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 < 2 && 2 < 3;\n-   |     ^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 < 2) < 3;\n-   |     ^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:13:7\n    |\n LL |     1 <= 2 < 3;\n-   |       ^^^^^^\n+   |       ^^   ^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 <= 2 && 2 < 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 <= 2) < 3;\n-   |     ^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:18:7\n    |\n LL |     1 <= 2 <= 3;\n-   |       ^^^^^^^\n+   |       ^^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 <= 2 && 2 <= 3;\n-   |     ^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 <= 2) <= 3;\n-   |     ^^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:23:7\n    |\n LL |     1 > 2 >= 3;\n-   |       ^^^^^^\n+   |       ^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 > 2 && 2 >= 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 > 2) >= 3;\n-   |     ^^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:28:7\n    |\n LL |     1 > 2 > 3;\n-   |       ^^^^^\n+   |       ^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 > 2 && 2 > 3;\n-   |     ^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 > 2) > 3;\n-   |     ^^^^^^^^^\n+   |           ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:32:7\n    |\n LL |     1 >= 2 > 3;\n-   |       ^^^^^^\n+   |       ^^   ^\n    |\n-   = help: use `::<...>` instead of `<...>` to specify type arguments\n-   = help: or use `(...)` if you meant to specify fn arguments\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 >= 2 && 2 > 3;\n-   |     ^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n-   |\n-LL |     (1 >= 2) > 3;\n-   |     ^^^^^^^^^^\n+   |            ^^^^\n \n error: comparison operators cannot be chained\n   --> $DIR/chained-comparison-suggestion.rs:36:7\n    |\n LL |     1 >= 2 >= 3;\n-   |       ^^^^^^^\n+   |       ^^   ^^\n    |\n-help: split the comparison into two...\n+help: split the comparison into two\n    |\n LL |     1 >= 2 && 2 >= 3;\n-   |     ^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |            ^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:41:7\n+   |\n+LL |     1 == 2 < 3;\n+   |       ^^   ^\n    |\n-LL |     (1 >= 2) >= 3;\n-   |     ^^^^^^^^^^^\n+help: parenthesize the comparison\n+   |\n+LL |     1 == (2 < 3);\n+   |          ^     ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:45:7\n+   |\n+LL |     1 > 2 == false;\n+   |       ^   ^^\n+   |\n+help: parenthesize the comparison\n+   |\n+LL |     (1 > 2) == false;\n+   |     ^     ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/chained-comparison-suggestion.rs:49:7\n+   |\n+LL |     1 == 2 == 3;\n+   |       ^^   ^^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     1 == 2 && 2 == 3;\n+   |            ^^^^\n \n error[E0308]: mismatched types\n   --> $DIR/chained-comparison-suggestion.rs:4:14\n@@ -154,6 +149,12 @@ error[E0308]: mismatched types\n LL |     1 >= 2 >= 3;\n    |               ^ expected `bool`, found integer\n \n-error: aborting due to 13 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/chained-comparison-suggestion.rs:49:15\n+   |\n+LL |     1 == 2 == 3;\n+   |               ^ expected `bool`, found integer\n+\n+error: aborting due to 17 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "4e97904ed6d5f9f178aa6954b3673368724c1239", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.rs?ref=89571a1bbc25a03ac0195460c7ec463d3f089def", "patch": "@@ -4,20 +4,18 @@ struct X;\n fn main() {\n     false == false == false;\n     //~^ ERROR comparison operators cannot be chained\n+    //~| HELP split the comparison into two\n \n     false == 0 < 2;\n     //~^ ERROR comparison operators cannot be chained\n-    //~| ERROR mismatched types\n-    //~| ERROR mismatched types\n+    //~| HELP parenthesize the comparison\n \n     f<X>();\n     //~^ ERROR comparison operators cannot be chained\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n     //~^ ERROR comparison operators cannot be chained\n-    //~| HELP split the comparison into two...\n-    //~| ...or parenthesize one of the comparisons\n     //~| HELP use `::<...>` instead of `<...>` to specify type arguments\n \n     use std::convert::identity;"}, {"sha": "7001aa8e8a1d8c279707db8c396f5637ddb2fb71", "filename": "src/test/ui/parser/require-parens-for-chained-comparison.stderr", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/89571a1bbc25a03ac0195460c7ec463d3f089def/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frequire-parens-for-chained-comparison.stderr?ref=89571a1bbc25a03ac0195460c7ec463d3f089def", "patch": "@@ -2,19 +2,29 @@ error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:5:11\n    |\n LL |     false == false == false;\n-   |           ^^^^^^^^^^^\n+   |           ^^       ^^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     false == false && false == false;\n+   |                    ^^^^^^^^\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:11\n+  --> $DIR/require-parens-for-chained-comparison.rs:9:11\n    |\n LL |     false == 0 < 2;\n-   |           ^^^^^^\n+   |           ^^   ^\n+   |\n+help: parenthesize the comparison\n+   |\n+LL |     false == (0 < 2);\n+   |              ^     ^\n \n error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:13:6\n    |\n LL |     f<X>();\n-   |      ^^^\n+   |      ^ ^\n    |\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n@@ -25,42 +35,21 @@ error: comparison operators cannot be chained\n   --> $DIR/require-parens-for-chained-comparison.rs:17:6\n    |\n LL |     f<Result<Option<X>, Option<Option<X>>>(1, 2);\n-   |      ^^^^^^^^\n-   |\n-help: split the comparison into two...\n-   |\n-LL |     f < Result && Result <Option<X>, Option<Option<X>>>(1, 2);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n-help: ...or parenthesize one of the comparisons\n+   |      ^      ^\n    |\n-LL |     (f < Result) <Option<X>, Option<Option<X>>>(1, 2);\n-   |     ^^^^^^^^^^^^^^\n help: use `::<...>` instead of `<...>` to specify type arguments\n    |\n LL |     f::<Result<Option<X>, Option<Option<X>>>(1, 2);\n    |      ^^\n \n error: comparison operators cannot be chained\n-  --> $DIR/require-parens-for-chained-comparison.rs:24:21\n+  --> $DIR/require-parens-for-chained-comparison.rs:22:21\n    |\n LL |     let _ = identity<u8>;\n-   |                     ^^^^\n+   |                     ^  ^\n    |\n    = help: use `::<...>` instead of `<...>` to specify type arguments\n    = help: or use `(...)` if you meant to specify fn arguments\n \n-error[E0308]: mismatched types\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:14\n-   |\n-LL |     false == 0 < 2;\n-   |              ^ expected `bool`, found integer\n-\n-error[E0308]: mismatched types\n-  --> $DIR/require-parens-for-chained-comparison.rs:8:18\n-   |\n-LL |     false == 0 < 2;\n-   |                  ^ expected `bool`, found integer\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0308`."}]}