{"sha": "d19d7e27552b8da17932384b8db53927a1f4e00e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOWQ3ZTI3NTUyYjhkYTE3OTMyMzg0YjhkYjUzOTI3YTFmNGUwMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T07:46:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T07:46:04Z"}, "message": "Auto merge of #75257 - ssomers:btree_74762_again, r=Mark-Simulacrum\n\nBTreeMap: better way to postpone root access in DrainFilter\n\nA slightly more elegant (in my opinion) adaptation of #74762. Benchmarks seem irrationally pleased to:\n```\nbenchcmp old new --threshold 5\n name                                           old ns/iter  new ns/iter  diff ns/iter   diff %  speedup\n btree::map::clone_fat_100_and_remove_all       215,182      185,052           -30,130  -14.00%   x 1.16\n btree::map::clone_fat_100_and_remove_half      139,667      127,945           -11,722   -8.39%   x 1.09\n btree::map::clone_fat_val_100_and_remove_all   96,755       81,279            -15,476  -16.00%   x 1.19\n btree::map::clone_fat_val_100_and_remove_half  64,678       56,911             -7,767  -12.01%   x 1.14\n btree::map::find_rand_100                      18           17                     -1   -5.56%   x 1.06\n btree::map::first_and_last_0                   33           35                      2    6.06%   x 0.94\n btree::map::first_and_last_100                 40           54                     14   35.00%   x 0.74\n btree::map::insert_rand_100                    45           42                     -3   -6.67%   x 1.07\n btree::map::insert_rand_10_000                 45           41                     -4   -8.89%   x 1.10\n btree::map::iter_0                             2,010        1,759                -251  -12.49%   x 1.14\n btree::map::iter_100                           3,514        2,764                -750  -21.34%   x 1.27\n btree::map::iter_10k                           4,018        3,768                -250   -6.22%   x 1.07\n btree::map::range_unbounded_unbounded          37,269       28,929             -8,340  -22.38%   x 1.29\n btree::map::range_unbounded_vs_iter            31,518       28,814             -2,704   -8.58%   x 1.09\n```\n\nr? @Mark-Simulacrum", "tree": {"sha": "90220e2e6146458fea2d64eb6589efc5dae39015", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90220e2e6146458fea2d64eb6589efc5dae39015"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d19d7e27552b8da17932384b8db53927a1f4e00e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d19d7e27552b8da17932384b8db53927a1f4e00e", "html_url": "https://github.com/rust-lang/rust/commit/d19d7e27552b8da17932384b8db53927a1f4e00e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d19d7e27552b8da17932384b8db53927a1f4e00e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e61621c3078f25365d58cb508cda745007e64d85", "url": "https://api.github.com/repos/rust-lang/rust/commits/e61621c3078f25365d58cb508cda745007e64d85", "html_url": "https://github.com/rust-lang/rust/commit/e61621c3078f25365d58cb508cda745007e64d85"}, {"sha": "85a78793412c7cf6bdde982f7de2fc3de204817c", "url": "https://api.github.com/repos/rust-lang/rust/commits/85a78793412c7cf6bdde982f7de2fc3de204817c", "html_url": "https://github.com/rust-lang/rust/commit/85a78793412c7cf6bdde982f7de2fc3de204817c"}], "stats": {"total": 57, "additions": 25, "deletions": 32}, "files": [{"sha": "a19ba34375734e270b6194730f435470408a84ef", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/d19d7e27552b8da17932384b8db53927a1f4e00e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19d7e27552b8da17932384b8db53927a1f4e00e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=d19d7e27552b8da17932384b8db53927a1f4e00e", "patch": "@@ -1697,10 +1697,9 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                let (kv, pos) = kv.remove_kv_tracking(|_| self.emptied_internal_root = true);\n                 self.cur_leaf_edge = Some(pos);\n-                self.emptied_internal_root |= emptied_internal_root;\n-                return Some(old_kv);\n+                return Some(kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2645,35 +2644,28 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n-        let root = pos.into_node().into_root_mut();\n-        if emptied_internal_root {\n-            root.pop_internal_level();\n-        }\n+        let (old_kv, _) =\n+            self.handle.remove_kv_tracking(|root| root.into_root_mut().pop_internal_level());\n         old_kv\n     }\n }\n \n-struct RemoveResult<'a, K, V> {\n-    // Key and value removed.\n-    old_kv: (K, V),\n-    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n-    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    // Whether the remove left behind and empty internal root node, that should be removed\n-    // using `pop_internal_level`.\n-    emptied_internal_root: bool,\n-}\n-\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the tree, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair. It's possible this leaves\n     /// an empty internal root node, which the caller should subsequently pop from\n     /// the map holding the tree. The caller should also decrement the map's length.\n-    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n-        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n+    fn remove_kv_tracking<F>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>)\n+    where\n+        F: FnOnce(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    {\n+        let (old_kv, mut pos, was_internal) = match self.force() {\n             Leaf(leaf) => {\n-                let (hole, old_key, old_val) = leaf.remove();\n-                (hole, old_key, old_val, false)\n+                let (old_kv, pos) = leaf.remove();\n+                (old_kv, pos, false)\n             }\n             Internal(mut internal) => {\n                 // Replace the location freed in the internal node with the next KV,\n@@ -2688,17 +2680,16 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n                 let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n-                let (hole, key, val) = to_remove.remove();\n+                let (kv, pos) = to_remove.remove();\n \n-                let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n-                let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n+                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n \n-                (hole, old_key, old_val, true)\n+                ((old_key, old_val), pos, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2719,8 +2710,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // This empty parent must be the root, and should be popped off the tree.\n-                        emptied_internal_root = true;\n+                        // The parent that was just emptied must be the root,\n+                        // because nodes on a lower level would not have been\n+                        // left underfull. It has to be popped off the tree soon.\n+                        handle_emptied_internal_root(parent);\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2747,7 +2740,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n+        (old_kv, pos)\n     }\n }\n "}, {"sha": "4e52c16d20d20d81fc2cbd424124fb98eb71d226", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d19d7e27552b8da17932384b8db53927a1f4e00e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d19d7e27552b8da17932384b8db53927a1f4e00e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=d19d7e27552b8da17932384b8db53927a1f4e00e", "patch": "@@ -1083,12 +1083,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n     pub fn remove(\n         mut self,\n-    ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n             (*self.node.as_leaf_mut()).len -= 1;\n-            (self.left_edge(), k, v)\n+            ((k, v), self.left_edge())\n         }\n     }\n }"}]}