{"sha": "09e12fa553efc933cb69d112f8f5c461c2b91492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZTEyZmE1NTNlZmM5MzNjYjY5ZDExMmY4ZjVjNDYxYzJiOTE0OTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-16T22:30:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-28T11:43:39Z"}, "message": "Test that reborrowing contents of an `&'a mut &'b mut` pointer can only\nbe done for at most lifetime `'a`\n\nFixes #8624", "tree": {"sha": "ba5e168aff89bde56ff8e2c430f1d85dc55911e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba5e168aff89bde56ff8e2c430f1d85dc55911e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09e12fa553efc933cb69d112f8f5c461c2b91492", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09e12fa553efc933cb69d112f8f5c461c2b91492", "html_url": "https://github.com/rust-lang/rust/commit/09e12fa553efc933cb69d112f8f5c461c2b91492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09e12fa553efc933cb69d112f8f5c461c2b91492/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac", "html_url": "https://github.com/rust-lang/rust/commit/bc4164d4c0cd232aa0c4a91b97a3e29920a311ac"}], "stats": {"total": 383, "additions": 278, "deletions": 105}, "files": [{"sha": "7cc1395a9e5d6906edbfaacf72bed647e24656ff", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 142, "deletions": 76, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -233,7 +233,7 @@ the lifetime of the value being borrowed. This pass is also\n responsible for inserting root annotations to keep managed values\n alive and for dynamically freezing `@mut` boxes.\n \n-3. `RESTRICTIONS(LV, ACTIONS) = RS`: This pass checks and computes the\n+3. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n@@ -451,17 +451,17 @@ the scope `LT`.\n \n The final rules govern the computation of *restrictions*, meaning that\n we compute the set of actions that will be illegal for the life of the\n-loan. The predicate is written `RESTRICTIONS(LV, ACTIONS) =\n+loan. The predicate is written `RESTRICTIONS(LV, LT, ACTIONS) =\n RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n occuring on `LV`, the restrictions `RESTRICTION*` must be respected\n for the lifetime of the loan\".\n \n Note that there is an initial set of restrictions: these restrictions\n are computed based on the kind of borrow:\n \n-    &mut LV =>   RESTRICTIONS(LV, MUTATE|CLAIM|FREEZE)\n-    &LV =>       RESTRICTIONS(LV, MUTATE|CLAIM)\n-    &const LV => RESTRICTIONS(LV, [])\n+    &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n+    &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n+    &const LV => RESTRICTIONS(LV, LT, [])\n \n The reasoning here is that a mutable borrow must be the only writer,\n therefore it prevents other writes (`MUTATE`), mutable borrows\n@@ -474,7 +474,7 @@ moved out from under it, so no actions are forbidden.\n \n The simplest case is a borrow of a local variable `X`:\n \n-    RESTRICTIONS(X, ACTIONS) = (X, ACTIONS)            // R-Variable\n+    RESTRICTIONS(X, LT, ACTIONS) = (X, ACTIONS)            // R-Variable\n \n In such cases we just record the actions that are not permitted.\n \n@@ -483,8 +483,8 @@ In such cases we just record the actions that are not permitted.\n Restricting a field is the same as restricting the owner of that\n field:\n \n-    RESTRICTIONS(LV.f, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n-      RESTRICTIONS(LV, ACTIONS) = RS\n+    RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n+      RESTRICTIONS(LV, LT, ACTIONS) = RS\n \n The reasoning here is as follows. If the field must not be mutated,\n then you must not mutate the owner of the field either, since that\n@@ -504,9 +504,9 @@ must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n \n-    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n+    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n       TYPE(LV) = ~Ty\n-      RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n+      RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n \n ### Restrictions for loans of immutable managed/borrowed pointees\n \n@@ -519,7 +519,7 @@ restricting that path. Therefore, the rule for `&Ty` and `@Ty`\n pointers always returns an empty set of restrictions, and it only\n permits restricting `MUTATE` and `CLAIM` actions:\n \n-    RESTRICTIONS(*LV, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+    RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n       TYPE(LV) = &Ty or @Ty\n       ACTIONS subset of [MUTATE, CLAIM]\n \n@@ -546,7 +546,7 @@ Because moves from a `&const` or `@const` lvalue are never legal, it\n is not necessary to add any restrictions at all to the final\n result.\n \n-    RESTRICTIONS(*LV, []) = []                         // R-Deref-Freeze-Borrowed\n+    RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n \n ### Restrictions for loans of mutable borrowed pointees\n@@ -581,91 +581,157 @@ an `&mut` pointee from being mutated, claimed, or frozen, as occurs\n whenever the `&mut` pointee `*LV` is reborrowed as mutable or\n immutable:\n \n-    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n-      TYPE(LV) = &mut Ty\n-      RESTRICTIONS(LV, MUTATE|CLAIM|ALIAS) = RS\n-\n-The main interesting part of the rule is the final line, which\n-requires that the `&mut` *pointer* `LV` be restricted from being\n-mutated, claimed, or aliased. The goal of these restrictions is to\n-ensure that, not considering the pointer that will result from this\n-borrow, `LV` remains the *sole pointer with mutable access* to `*LV`.\n-\n-Restrictions against mutations and claims are necessary because if the\n-pointer in `LV` were to be somehow copied or moved to a different\n-location, then the restriction issued for `*LV` would not apply to the\n-new location. Note that because `&mut` values are non-copyable, a\n-simple attempt to move the base pointer will fail due to the\n-(implicit) restriction against moves:\n-\n-    // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n-    fn foo(t0: &mut int) {\n-        let p: &int = &*t0; // Freezes `*t0`\n-        let t1 = t0;        //~ ERROR cannot move out of `t0`\n-        *t1 = 22;\n-    }\n-\n-However, the additional restrictions against mutation mean that even a\n-clever attempt to use a swap to circumvent the type system will\n-encounter an error:\n-\n-    // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n-    fn foo<'a>(mut t0: &'a mut int,\n-               mut t1: &'a mut int) {\n-        let p: &int = &*t0;     // Freezes `*t0`\n-        swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n-        *t1 = 22;\n-    }\n-\n-The restriction against *aliasing* (and, in turn, freezing) is\n-necessary because, if an alias were of `LV` were to be produced, then\n-`LV` would no longer be the sole path to access the `&mut`\n-pointee. Since we are only issuing restrictions against `*LV`, these\n-other aliases would be unrestricted, and the result would be\n-unsound. For example:\n+    RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed-1\n+      TYPE(LV) = &LT' mut Ty\n+      LT <= LT'                                            // (1)\n+      RESTRICTIONS(LV, LT, MUTATE|CLAIM|ALIAS) = RS        // (2)\n+\n+There are two interesting parts to this rule:\n+\n+1. The lifetime of the loan (`LT`) cannot exceed the lifetime of the\n+   `&mut` pointer (`LT'`). The reason for this is that the `&mut`\n+   pointer is guaranteed to be the only legal way to mutate its\n+   pointee -- but only for the lifetime `LT'`.  After that lifetime,\n+   the loan on the pointee expires and hence the data may be modified\n+   by its owner again. This implies that we are only able to guarantee that\n+   the pointee will not be modified or aliased for a maximum of `LT'`.\n+\n+   Here is a concrete example of a bug this rule prevents:\n+\n+       // Test region-reborrow-from-shorter-mut-ref.rs:\n+       fn copy_pointer<'a,'b,T>(x: &'a mut &'b mut T) -> &'b mut T {\n+           &mut **p // ERROR due to clause (1)\n+       }\n+       fn main() {\n+           let mut x = 1;\n+           let mut y = &mut x; // <-'b-----------------------------+\n+           //      +-'a--------------------+                       |\n+           //      v                       v                       |\n+           let z = copy_borrowed_ptr(&mut y); // y is lent         |\n+           *y += 1; // Here y==z, so both should not be usable...  |\n+           *z += 1; // ...and yet they would be, but for clause 1. |\n+       } <---------------------------------------------------------+\n+\n+2. The final line recursively requires that the `&mut` *pointer* `LV`\n+   be restricted from being mutated, claimed, or aliased (not just the\n+   pointee). The goal of these restrictions is to ensure that, not\n+   considering the pointer that will result from this borrow, `LV`\n+   remains the *sole pointer with mutable access* to `*LV`.\n+\n+   Restrictions against claims are necessary because if the pointer in\n+   `LV` were to be somehow copied or moved to a different location,\n+   then the restriction issued for `*LV` would not apply to the new\n+   location. Note that because `&mut` values are non-copyable, a\n+   simple attempt to move the base pointer will fail due to the\n+   (implicit) restriction against moves:\n+\n+       // src/test/compile-fail/borrowck-move-mut-base-ptr.rs\n+       fn foo(t0: &mut int) {\n+           let p: &int = &*t0; // Freezes `*t0`\n+           let t1 = t0;        //~ ERROR cannot move out of `t0`\n+           *t1 = 22;\n+       }\n+\n+   However, the additional restrictions against claims mean that even\n+   a clever attempt to use a swap to circumvent the type system will\n+   encounter an error:\n+\n+       // src/test/compile-fail/borrowck-swap-mut-base-ptr.rs\n+       fn foo<'a>(mut t0: &'a mut int,\n+                  mut t1: &'a mut int) {\n+           let p: &int = &*t0;     // Freezes `*t0`\n+           swap(&mut t0, &mut t1); //~ ERROR cannot borrow `t0`\n+           *t1 = 22;\n+       }\n+\n+   The restriction against *aliasing* (and, in turn, freezing) is\n+   necessary because, if an alias were of `LV` were to be produced,\n+   then `LV` would no longer be the sole path to access the `&mut`\n+   pointee. Since we are only issuing restrictions against `*LV`,\n+   these other aliases would be unrestricted, and the result would be\n+   unsound. For example:\n \n     // src/test/compile-fail/borrowck-alias-mut-base-ptr.rs\n     fn foo(t0: &mut int) {\n         let p: &int = &*t0; // Freezes `*t0`\n         let q: &const &mut int = &const t0; //~ ERROR cannot borrow `t0`\n-        **q = 22; // (*)\n-    }\n-\n-Note that the current rules also report an error at the assignment in\n-`(*)`, because we only permit `&mut` poiners to be assigned if they\n-are located in a non-aliasable location. However, I do not believe\n-this restriction is strictly necessary. It was added, I believe, to\n-discourage `&mut` from being placed in aliasable locations in the\n-first place. One (desirable) side-effect of restricting aliasing on\n-`LV` is that borrowing an `&mut` pointee found inside an aliasable\n-pointee yields an error:\n-\n-    // src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc:\n-    fn foo(t0: & &mut int) {\n-        let t1 = t0;\n-        let p: &int = &**t0; //~ ERROR cannot borrow an `&mut` in a `&` pointer\n-        **t1 = 22; // (*)\n+        **q = 22;\n     }\n \n-Here at the line `(*)` you will also see the error I referred to\n-above, which I do not believe is strictly necessary.\n+The current rules could use some correction:\n+\n+1. Issue #10520. Now that the swap operator has been removed, I do not\n+   believe the restriction against mutating `LV` is needed, and in\n+   fact it prevents some useful patterns. For example, the following\n+   function will fail to compile:\n+\n+       fn mut_shift_ref<'a,T>(x: &mut &'a mut [T]) -> &'a mut T {\n+           // `mut_split` will restrict mutation against *x:\n+           let (head, tail) = (*x).mut_split(1);\n+\n+           // Hence mutating `*x` yields an error here:\n+           *x = tail;\n+           &mut head[0]\n+       }\n+\n+   Note that this function -- which adjusts the slice `*x` in place so\n+   that it no longer contains the head element and then returns a\n+   pointer to that element separately -- is perfectly valid. It is\n+   currently implemented using unsafe code. I believe that now that\n+   the swap operator is removed from the language, we could liberalize\n+   the rules and make this function be accepted normally. The idea\n+   would be to have the assignment to `*x` kill the loans of `*x` and\n+   its subpaths -- after all, those subpaths are no longer accessible\n+   through `*x`, since it has been overwritten with a new value. Thus\n+   those subpaths are only accessible through prior existing borrows\n+   of `*x`, if any. The danger of the *swap* operator was that it\n+   allowed `*x` to be mutated without making the subpaths of `*x`\n+   inaccessible: worse, they became accessible through a new path (I\n+   suppose that we could support swap, too, if needed, by moving the\n+   loans over to the new path).\n+\n+   Note: the `swap()` function doesn't pose the same danger as the\n+   swap operator because it requires taking `&mut` refs to invoke it.\n+\n+2. Issue #9629. The current rules correctly prohibit `&mut` pointees\n+   from being assigned unless they are in a unique location. However,\n+   we *also* prohibit `&mut` pointees from being frozen. This prevents\n+   compositional patterns, like this one:\n+\n+       struct BorrowedMap<'a> {\n+           map: &'a mut HashMap\n+       }\n+\n+   If we have a pointer `x:&BorrowedMap`, we can't freeze `x.map`,\n+   and hence can't call `find` etc on it. But that's silly, since\n+   fact that the `&mut` exists in frozen data implies that it\n+   will not be mutable by anyone. For example, this program nets an\n+   error:\n+\n+       fn main() {\n+           let a = &mut 2;\n+           let b = &a;\n+           *a += 1; // ERROR: cannot assign to `*a` because it is borrowed\n+       }\n+\n+   (Naturally `&mut` reborrows from an `&&mut` pointee should be illegal.)\n \n The second rule for `&mut` handles the case where we are not adding\n any restrictions (beyond the default of \"no move\"):\n \n-    RESTRICTIONS(*LV, []) = []                    // R-Deref-Mut-Borrowed-2\n+    RESTRICTIONS(*LV, LT, []) = []                    // R-Deref-Mut-Borrowed-2\n       TYPE(LV) = &mut Ty\n \n Moving from an `&mut` pointee is never legal, so no special\n-restrictions are needed.\n+restrictions are needed. This rule is used for `&const` borrows.\n \n ### Restrictions for loans of mutable managed pointees\n \n With `@mut` pointees, we don't make any static guarantees.  But as a\n convenience, we still register a restriction against `*LV`, because\n that way if we *can* find a simple static error, we will:\n \n-    RESTRICTIONS(*LV, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n+    RESTRICTIONS(*LV, LT, ACTIONS) = [*LV, ACTIONS]   // R-Deref-Managed-Borrowed\n       TYPE(LV) = @mut Ty\n \n # Moves and initialization"}, {"sha": "8cfb47bd04dc98dd2c4a252448b9a92627282322", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This module implements the check that the lifetime of a borrow\n-//! does not exceed the lifetime of the value being borrowed.\n-\n+/*!\n+ * This module implements the check that the lifetime of a borrow\n+ * does not exceed the lifetime of the value being borrowed.\n+ */\n \n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n@@ -20,13 +21,15 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{note_and_explain_region};\n \n+type R = Result<(),()>;\n+\n pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                           item_scope_id: ast::NodeId,\n                           root_scope_id: ast::NodeId,\n                           span: Span,\n                           cmt: mc::cmt,\n                           loan_region: ty::Region,\n-                          loan_mutbl: LoanMutability) {\n+                          loan_mutbl: LoanMutability) -> R {\n     debug!(\"guarantee_lifetime(cmt={}, loan_region={})\",\n            cmt.repr(bccx.tcx), loan_region.repr(bccx.tcx));\n     let ctxt = GuaranteeLifetimeContext {bccx: bccx,\n@@ -36,7 +39,7 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n                                          loan_mutbl: loan_mutbl,\n                                          cmt_original: cmt,\n                                          root_scope_id: root_scope_id};\n-    ctxt.check(cmt, None);\n+    ctxt.check(cmt, None)\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -63,7 +66,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         self.bccx.tcx\n     }\n \n-    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) {\n+    fn check(&self, cmt: mc::cmt, discr_scope: Option<ast::NodeId>) -> R {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n \n         match cmt.cat {\n@@ -83,6 +86,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n             }\n \n             mc::cat_static_item => {\n+                Ok(())\n             }\n \n             mc::cat_deref(base, derefs, mc::gc_ptr(ptr_mutbl)) => {\n@@ -99,10 +103,11 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 if !omit_root {\n                     // L-Deref-Managed-Imm-Compiler-Root\n                     // L-Deref-Managed-Mut-Compiler-Root\n-                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope);\n+                    self.check_root(cmt, base, derefs, ptr_mutbl, discr_scope)\n                 } else {\n                     debug!(\"omitting root, base={}, base_scope={:?}\",\n                            base.repr(self.tcx()), base_scope);\n+                    Ok(())\n                 }\n             }\n \n@@ -120,7 +125,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                 // for one arm.  Therefore, we insert a cat_discr(),\n                 // basically a special kind of category that says \"if this\n                 // value must be dynamically rooted, root it for the scope\n-                // `match_id`.\n+                // `match_id`\".\n                 //\n                 // As an example, consider this scenario:\n                 //\n@@ -188,7 +193,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n                   cmt_base: mc::cmt,\n                   derefs: uint,\n                   ptr_mutbl: ast::Mutability,\n-                  discr_scope: Option<ast::NodeId>) {\n+                  discr_scope: Option<ast::NodeId>) -> R {\n         debug!(\"check_root(cmt_deref={}, cmt_base={}, derefs={:?}, ptr_mutbl={:?}, \\\n                 discr_scope={:?})\",\n                cmt_deref.repr(self.tcx()),\n@@ -201,9 +206,8 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         // that we can root the value, dynamically.\n         let root_region = ty::ReScope(self.root_scope_id);\n         if !self.bccx.is_subregion_of(self.loan_region, root_region) {\n-            self.report_error(\n-                err_out_of_root_scope(root_region, self.loan_region));\n-            return;\n+            return Err(self.report_error(\n+                err_out_of_root_scope(root_region, self.loan_region)));\n         }\n \n         // Extract the scope id that indicates how long the rooting is required\n@@ -278,13 +282,16 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         self.bccx.root_map.insert(rm_key, root_info);\n \n         debug!(\"root_key: {:?} root_info: {:?}\", rm_key, root_info);\n+        Ok(())\n     }\n \n-    fn check_scope(&self, max_scope: ty::Region) {\n+    fn check_scope(&self, max_scope: ty::Region) -> R {\n         //! Reports an error if `loan_region` is larger than `valid_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n-            self.report_error(err_out_of_scope(max_scope, self.loan_region));\n+            Err(self.report_error(err_out_of_scope(max_scope, self.loan_region)))\n+        } else {\n+            Ok(())\n         }\n     }\n "}, {"sha": "918d807e8c2ab5a479f3f9d9cfce1ec0a0dddc4c", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -449,17 +449,22 @@ impl<'self> GatherLoanCtxt<'self> {\n \n         // Check that the lifetime of the borrow does not exceed\n         // the lifetime of the data being borrowed.\n-        lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n-                                     borrow_span, cmt, loan_region, req_mutbl);\n+        if lifetime::guarantee_lifetime(self.bccx, self.item_ub, root_ub,\n+                                        borrow_span, cmt, loan_region,\n+                                        req_mutbl).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n \n         // Check that we don't allow mutable borrows of non-mutable data.\n-        check_mutability(self.bccx, borrow_span, cmt, req_mutbl);\n+        if check_mutability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n \n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n             self.bccx, borrow_span,\n-            cmt, self.restriction_set(req_mutbl));\n+            cmt, loan_region, self.restriction_set(req_mutbl));\n \n         // Create the loan record (if needed).\n         let loan = match restr {\n@@ -556,25 +561,29 @@ impl<'self> GatherLoanCtxt<'self> {\n         fn check_mutability(bccx: &BorrowckCtxt,\n                             borrow_span: Span,\n                             cmt: mc::cmt,\n-                            req_mutbl: LoanMutability) {\n+                            req_mutbl: LoanMutability) -> Result<(),()> {\n             //! Implements the M-* rules in doc.rs.\n \n             match req_mutbl {\n                 ConstMutability => {\n                     // Data of any mutability can be lent as const.\n+                    Ok(())\n                 }\n \n                 ImmutableMutability => {\n                     // both imm and mut data can be lent as imm;\n                     // for mutable data, this is a freeze\n+                    Ok(())\n                 }\n \n                 MutableMutability => {\n                     // Only mutable data can be lent as mutable.\n                     if !cmt.mutbl.is_mutable() {\n-                        bccx.report(BckError {span: borrow_span,\n-                                              cmt: cmt,\n-                                              code: err_mutbl(req_mutbl)});\n+                        Err(bccx.report(BckError {span: borrow_span,\n+                                                  cmt: cmt,\n+                                                  code: err_mutbl(req_mutbl)}))\n+                    } else {\n+                        Ok(())\n                     }\n                 }\n             }"}, {"sha": "d4fe23e57b47dfa831384efb6d638b136e6dfafa", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Computes the restrictions that result from a borrow.\n-\n+/*!\n+ * Computes the restrictions that result from a borrow.\n+ */\n \n use std::vec;\n use middle::borrowck::*;\n@@ -26,11 +27,13 @@ pub enum RestrictionResult {\n pub fn compute_restrictions(bccx: &BorrowckCtxt,\n                             span: Span,\n                             cmt: mc::cmt,\n+                            loan_region: ty::Region,\n                             restr: RestrictionSet) -> RestrictionResult {\n     let ctxt = RestrictionsContext {\n         bccx: bccx,\n         span: span,\n-        cmt_original: cmt\n+        cmt_original: cmt,\n+        loan_region: loan_region,\n     };\n \n     ctxt.restrict(cmt, restr)\n@@ -42,7 +45,8 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n struct RestrictionsContext<'self> {\n     bccx: &'self BorrowckCtxt,\n     span: Span,\n-    cmt_original: mc::cmt\n+    cmt_original: mc::cmt,\n+    loan_region: ty::Region,\n }\n \n impl<'self> RestrictionsContext<'self> {\n@@ -169,12 +173,22 @@ impl<'self> RestrictionsContext<'self> {\n                 }\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, _)) => {\n+            mc::cat_deref(cmt_base, _, pk @ mc::region_ptr(MutMutable, lt)) => {\n                 // Because an `&mut` pointer does not inherit its\n                 // mutability, we can only prevent mutation or prevent\n                 // freezing if it is not aliased. Therefore, in such\n                 // cases we restrict aliasing on `cmt_base`.\n                 if restrictions != RESTR_EMPTY {\n+                    if !self.bccx.is_subregion_of(self.loan_region, lt) {\n+                        self.bccx.report(\n+                            BckError {\n+                                span: self.span,\n+                                cmt: cmt_base,\n+                                code: err_mut_pointer_too_short(\n+                                    self.loan_region, lt, restrictions)});\n+                        return Safe;\n+                    }\n+\n                     // R-Deref-Mut-Borrowed-1\n                     let result = self.restrict(\n                         cmt_base,"}, {"sha": "82569cca1d40fff181cdce63199ff4fc882b27e3", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -443,7 +443,8 @@ pub enum bckerr_code {\n     err_mutbl(LoanMutability),\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n-    err_freeze_aliasable_const\n+    err_freeze_aliasable_const,\n+    err_mut_pointer_too_short(ty::Region, ty::Region, RestrictionSet), // loan, ptr\n }\n \n // Combination of an error code and the categorization of the expression\n@@ -669,6 +670,22 @@ impl BorrowckCtxt {\n                 // supposed to be going away.\n                 format!(\"unsafe borrow of aliasable, const value\")\n             }\n+            err_mut_pointer_too_short(_, _, r) => {\n+                let descr = match opt_loan_path(err.cmt) {\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    None => ~\"`&mut` pointer\"\n+                };\n+\n+                let tag = if r.intersects(RESTR_ALIAS) {\n+                    \"its contents are unique\"\n+                } else {\n+                    \"its contents are not otherwise mutable\"\n+                };\n+\n+                format!(\"lifetime of {} is too short to guarantee {} \\\n+                        so they can be safely reborrowed\",\n+                        descr, tag)\n+            }\n         }\n     }\n \n@@ -742,7 +759,24 @@ impl BorrowckCtxt {\n                     \"...but borrowed value is only valid for \",\n                     super_scope,\n                     \"\");\n-          }\n+            }\n+\n+            err_mut_pointer_too_short(loan_scope, ptr_scope, _) => {\n+                let descr = match opt_loan_path(err.cmt) {\n+                    Some(lp) => format!(\"`{}`\", self.loan_path_to_str(lp)),\n+                    None => ~\"`&mut` pointer\"\n+                };\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"{} would have to be valid for \", descr),\n+                    loan_scope,\n+                    \"...\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    format!(\"...but {} is only valid for \", descr),\n+                    ptr_scope,\n+                    \"\");\n+            }\n         }\n     }\n "}, {"sha": "d3e0740a0fefe6bc4eecd5058256403a9f7e2ed1", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref-mut-ref.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref-mut-ref.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #8624. Test for reborrowing with 3 levels, not just two.\n+\n+fn copy_borrowed_ptr<'a, 'b, 'c>(p: &'a mut &'b mut &'c mut int) -> &'b mut int {\n+    &mut ***p //~ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn main() {\n+}"}, {"sha": "385bc11d1a983d233c5303b70d904fe04ce8e6d0", "filename": "src/test/compile-fail/regions-reborrow-from-shorter-mut-ref.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e12fa553efc933cb69d112f8f5c461c2b91492/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-reborrow-from-shorter-mut-ref.rs?ref=09e12fa553efc933cb69d112f8f5c461c2b91492", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue #8624. Tests that reborrowing the contents of an `&'b mut`\n+// pointer which is backed by another `&'a mut` can only be done\n+// for `'a` (which must be a sublifetime of `'b`).\n+\n+fn copy_borrowed_ptr<'a, 'b>(p: &'a mut &'b mut int) -> &'b mut int {\n+    &mut **p //~ ERROR lifetime of `p` is too short\n+}\n+\n+fn main() {\n+    let mut x = 1;\n+    let mut y = &mut x;\n+    let z = copy_borrowed_ptr(&mut y);\n+    *y += 1;\n+    *z += 1;\n+}"}]}