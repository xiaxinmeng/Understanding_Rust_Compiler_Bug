{"sha": "2c252ff1fb282ebf39593ee3436b480e7fda0183", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMjUyZmYxZmIyODJlYmYzOTU5M2VlMzQzNmI0ODBlN2ZkYTAxODM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2017-03-08T18:53:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-08T18:53:52Z"}, "message": "Rollup merge of #40237 - arthurprs:hm-adapt2, r=alexcrichton\n\nReduce size overhead of adaptative hashmap\n\nExposes a boolean flag in RawTable and use it instead of a bool field in HashMap.\n\nTaking a bit from capacity or length would make overflow handling tricky.\n\nFixes: #40042", "tree": {"sha": "4de533ecc611bc417a0e71d4aeae2f80e6147526", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4de533ecc611bc417a0e71d4aeae2f80e6147526"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c252ff1fb282ebf39593ee3436b480e7fda0183", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c252ff1fb282ebf39593ee3436b480e7fda0183", "html_url": "https://github.com/rust-lang/rust/commit/2c252ff1fb282ebf39593ee3436b480e7fda0183", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c252ff1fb282ebf39593ee3436b480e7fda0183/comments", "author": null, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68a5a167408d8d3af67c114e34bbdee8ce7e76a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/68a5a167408d8d3af67c114e34bbdee8ce7e76a3", "html_url": "https://github.com/rust-lang/rust/commit/68a5a167408d8d3af67c114e34bbdee8ce7e76a3"}, {"sha": "3273003912272b3e9e44c535ba785bae980348bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3273003912272b3e9e44c535ba785bae980348bb", "html_url": "https://github.com/rust-lang/rust/commit/3273003912272b3e9e44c535ba785bae980348bb"}], "stats": {"total": 98, "additions": 74, "deletions": 24}, "files": [{"sha": "f9b0ec479d70115768328111f24537acbb979453", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c252ff1fb282ebf39593ee3436b480e7fda0183/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c252ff1fb282ebf39593ee3436b480e7fda0183/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=2c252ff1fb282ebf39593ee3436b480e7fda0183", "patch": "@@ -396,8 +396,6 @@ pub struct HashMap<K, V, S = RandomState> {\n     table: RawTable<K, V>,\n \n     resize_policy: DefaultResizePolicy,\n-\n-    long_probes: bool,\n }\n \n /// Search for a pre-hashed key.\n@@ -655,7 +653,6 @@ impl<K, V, S> HashMap<K, V, S>\n             hash_builder: hash_builder,\n             resize_policy: DefaultResizePolicy::new(),\n             table: RawTable::new(0),\n-            long_probes: false,\n         }\n     }\n \n@@ -688,7 +685,6 @@ impl<K, V, S> HashMap<K, V, S>\n             hash_builder: hash_builder,\n             resize_policy: resize_policy,\n             table: RawTable::new(raw_cap),\n-            long_probes: false,\n         }\n     }\n \n@@ -746,7 +742,7 @@ impl<K, V, S> HashMap<K, V, S>\n             let min_cap = self.len().checked_add(additional).expect(\"reserve overflow\");\n             let raw_cap = self.resize_policy.raw_capacity(min_cap);\n             self.resize(raw_cap);\n-        } else if self.long_probes && remaining <= self.len() {\n+        } else if self.table.tag() && remaining <= self.len() {\n             // Probe sequence is too long and table is half full,\n             // resize early to reduce probing length.\n             let new_capacity = self.table.capacity() * 2;\n@@ -763,7 +759,6 @@ impl<K, V, S> HashMap<K, V, S>\n         assert!(self.table.size() <= new_raw_cap);\n         assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n \n-        self.long_probes = false;\n         let mut old_table = replace(&mut self.table, RawTable::new(new_raw_cap));\n         let old_size = old_table.size();\n \n@@ -844,8 +839,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// If the key already exists, the hashtable will be returned untouched\n     /// and a reference to the existing element will be returned.\n     fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n-        let entry = search_hashed(&mut self.table, hash, |key| *key == k)\n-            .into_entry(k, &mut self.long_probes);\n+        let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n         match entry {\n             Some(Occupied(mut elem)) => Some(elem.insert(v)),\n             Some(Vacant(elem)) => {\n@@ -1002,7 +996,7 @@ impl<K, V, S> HashMap<K, V, S>\n         self.reserve(1);\n         let hash = self.make_hash(&key);\n         search_hashed(&mut self.table, hash, |q| q.eq(&key))\n-            .into_entry(key, &mut self.long_probes).expect(\"unreachable\")\n+            .into_entry(key).expect(\"unreachable\")\n     }\n \n     /// Returns the number of elements in the map.\n@@ -1456,7 +1450,7 @@ impl<K, V, M> InternalEntry<K, V, M> {\n \n impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n     #[inline]\n-    fn into_entry(self, key: K, long_probes: &'a mut bool) -> Option<Entry<'a, K, V>> {\n+    fn into_entry(self, key: K) -> Option<Entry<'a, K, V>> {\n         match self {\n             InternalEntry::Occupied { elem } => {\n                 Some(Occupied(OccupiedEntry {\n@@ -1469,7 +1463,6 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n                     hash: hash,\n                     key: key,\n                     elem: elem,\n-                    long_probes: long_probes,\n                 }))\n             }\n             InternalEntry::TableIsEmpty => None,\n@@ -1542,7 +1535,6 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n-    long_probes: &'a mut bool,\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n@@ -2117,15 +2109,15 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n-            NeqElem(bucket, disp) => {\n+            NeqElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n-                    *self.long_probes = true;\n+                    bucket.table_mut().set_tag(true);\n                 }\n                 robin_hood(bucket, disp, self.hash, self.key, value)\n             },\n-            NoElem(bucket, disp) => {\n+            NoElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n-                    *self.long_probes = true;\n+                    bucket.table_mut().set_tag(true);\n                 }\n                 bucket.put(self.hash, self.key, value).into_mut_refs().1\n             },"}, {"sha": "0e225b2964f63752246b7a30d6fc26096b425e98", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 66, "deletions": 8, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2c252ff1fb282ebf39593ee3436b480e7fda0183/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c252ff1fb282ebf39593ee3436b480e7fda0183/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=2c252ff1fb282ebf39593ee3436b480e7fda0183", "patch": "@@ -34,6 +34,42 @@ type HashUint = usize;\n \n const EMPTY_BUCKET: HashUint = 0;\n \n+/// Special `Unique<HashUint>` that uses the lower bit of the pointer\n+/// to expose a boolean tag.\n+/// Note: when the pointer is initialized to EMPTY `.ptr()` will return\n+/// null and the tag functions shouldn't be used.\n+struct TaggedHashUintPtr(Unique<HashUint>);\n+\n+impl TaggedHashUintPtr {\n+    #[inline]\n+    unsafe fn new(ptr: *mut HashUint) -> Self {\n+        debug_assert!(ptr as usize & 1 == 0 || ptr as usize == EMPTY as usize);\n+        TaggedHashUintPtr(Unique::new(ptr))\n+    }\n+\n+    #[inline]\n+    fn set_tag(&mut self, value: bool) {\n+        let usize_ptr = &*self.0 as *const *mut HashUint as *mut usize;\n+        unsafe {\n+            if value {\n+                *usize_ptr |= 1;\n+            } else {\n+                *usize_ptr &= !1;\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn tag(&self) -> bool {\n+        (*self.0 as usize) & 1 == 1\n+    }\n+\n+    #[inline]\n+    fn ptr(&self) -> *mut HashUint {\n+        (*self.0 as usize & !1) as *mut HashUint\n+    }\n+}\n+\n /// The raw hashtable, providing safe-ish access to the unzipped and highly\n /// optimized arrays of hashes, and key-value pairs.\n ///\n@@ -72,10 +108,14 @@ const EMPTY_BUCKET: HashUint = 0;\n /// around just the \"table\" part of the hashtable. It enforces some\n /// invariants at the type level and employs some performance trickery,\n /// but in general is just a tricked out `Vec<Option<(u64, K, V)>>`.\n+///\n+/// The hashtable also exposes a special boolean tag. The tag defaults to false\n+/// when the RawTable is created and is accessible with the `tag` and `set_tag`\n+/// functions.\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size: usize,\n-    hashes: Unique<HashUint>,\n+    hashes: TaggedHashUintPtr,\n \n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n@@ -208,6 +248,10 @@ impl<K, V, M> FullBucket<K, V, M> {\n     pub fn table(&self) -> &M {\n         &self.table\n     }\n+    /// Borrow a mutable reference to the table.\n+    pub fn table_mut(&mut self) -> &mut M {\n+        &mut self.table\n+    }\n     /// Move out the reference to the table.\n     pub fn into_table(self) -> M {\n         self.table\n@@ -227,6 +271,10 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n     pub fn table(&self) -> &M {\n         &self.table\n     }\n+    /// Borrow a mutable reference to the table.\n+    pub fn table_mut(&mut self) -> &mut M {\n+        &mut self.table\n+    }\n }\n \n impl<K, V, M> Bucket<K, V, M> {\n@@ -687,7 +735,7 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: Unique::new(EMPTY as *mut HashUint),\n+                hashes: TaggedHashUintPtr::new(EMPTY as *mut HashUint),\n                 marker: marker::PhantomData,\n             };\n         }\n@@ -728,7 +776,7 @@ impl<K, V> RawTable<K, V> {\n         RawTable {\n             capacity: capacity,\n             size: 0,\n-            hashes: Unique::new(hashes),\n+            hashes: TaggedHashUintPtr::new(hashes),\n             marker: marker::PhantomData,\n         }\n     }\n@@ -737,13 +785,13 @@ impl<K, V> RawTable<K, V> {\n         let hashes_size = self.capacity * size_of::<HashUint>();\n         let pairs_size = self.capacity * size_of::<(K, V)>();\n \n-        let buffer = *self.hashes as *mut u8;\n+        let buffer = self.hashes.ptr() as *mut u8;\n         let (pairs_offset, _, oflo) =\n             calculate_offsets(hashes_size, pairs_size, align_of::<(K, V)>());\n         debug_assert!(!oflo, \"capacity overflow\");\n         unsafe {\n             RawBucket {\n-                hash: *self.hashes,\n+                hash: self.hashes.ptr(),\n                 pair: buffer.offset(pairs_offset as isize) as *const _,\n                 _marker: marker::PhantomData,\n             }\n@@ -755,7 +803,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            ptr::write_bytes(*ret.hashes, 0, capacity);\n+            ptr::write_bytes(ret.hashes.ptr(), 0, capacity);\n             ret\n         }\n     }\n@@ -774,7 +822,7 @@ impl<K, V> RawTable<K, V> {\n     fn raw_buckets(&self) -> RawBuckets<K, V> {\n         RawBuckets {\n             raw: self.first_bucket_raw(),\n-            hashes_end: unsafe { self.hashes.offset(self.capacity as isize) },\n+            hashes_end: unsafe { self.hashes.ptr().offset(self.capacity as isize) },\n             marker: marker::PhantomData,\n         }\n     }\n@@ -832,6 +880,16 @@ impl<K, V> RawTable<K, V> {\n             marker: marker::PhantomData,\n         }\n     }\n+\n+    /// Set the table tag\n+    pub fn set_tag(&mut self, value: bool) {\n+        self.hashes.set_tag(value)\n+    }\n+\n+    /// Get the table tag\n+    pub fn tag(&self) -> bool {\n+        self.hashes.tag()\n+    }\n }\n \n /// A raw iterator. The basis for some other iterators in this module. Although\n@@ -1156,7 +1214,7 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            deallocate(*self.hashes as *mut u8, size, align);\n+            deallocate(self.hashes.ptr() as *mut u8, size, align);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}]}