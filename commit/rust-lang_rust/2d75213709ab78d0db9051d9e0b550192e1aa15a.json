{"sha": "2d75213709ab78d0db9051d9e0b550192e1aa15a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNzUyMTM3MDlhYjc4ZDBkYjkwNTFkOWUwYjU1MDE5MmUxYWExNWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-14T08:53:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-14T08:53:07Z"}, "message": "Auto merge of #45155 - Nashenas88:nll-infer, r=nikomatsakis\n\nNLL infer\n\nr? @nikomatsakis", "tree": {"sha": "ec2b82898624af51b76a16738cf7a28a561e2bcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec2b82898624af51b76a16738cf7a28a561e2bcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d75213709ab78d0db9051d9e0b550192e1aa15a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d75213709ab78d0db9051d9e0b550192e1aa15a", "html_url": "https://github.com/rust-lang/rust/commit/2d75213709ab78d0db9051d9e0b550192e1aa15a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d75213709ab78d0db9051d9e0b550192e1aa15a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3037965b5bb762b6ed0dc860aefe01b664943ce8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3037965b5bb762b6ed0dc860aefe01b664943ce8", "html_url": "https://github.com/rust-lang/rust/commit/3037965b5bb762b6ed0dc860aefe01b664943ce8"}, {"sha": "9603e240d4e90c73507bf09957199de6f25bbc71", "url": "https://api.github.com/repos/rust-lang/rust/commits/9603e240d4e90c73507bf09957199de6f25bbc71", "html_url": "https://github.com/rust-lang/rust/commit/9603e240d4e90c73507bf09957199de6f25bbc71"}], "stats": {"total": 254, "additions": 245, "deletions": 9}, "files": [{"sha": "e6e00f295ca11958646338efd680a45d83f29806", "filename": "src/librustc_mir/transform/nll/infer.rs", "status": "added", "additions": 222, "deletions": 0, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/2d75213709ab78d0db9051d9e0b550192e1aa15a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d75213709ab78d0db9051d9e0b550192e1aa15a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Finfer.rs?ref=2d75213709ab78d0db9051d9e0b550192e1aa15a", "patch": "@@ -0,0 +1,222 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::{Region, RegionIndex};\n+use std::mem;\n+use rustc::infer::InferCtxt;\n+use rustc::mir::{Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::fx::FxHashSet;\n+\n+pub struct InferenceContext {\n+    definitions: IndexVec<RegionIndex, VarDefinition>,\n+    constraints: IndexVec<ConstraintIndex, Constraint>,\n+    errors: IndexVec<InferenceErrorIndex, InferenceError>,\n+}\n+\n+pub struct InferenceError {\n+    pub constraint_point: Location,\n+    pub name: (), // FIXME(nashenas88) RegionName\n+}\n+\n+newtype_index!(InferenceErrorIndex);\n+\n+struct VarDefinition {\n+    name: (), // FIXME(nashenas88) RegionName\n+    value: Region,\n+    capped: bool,\n+}\n+\n+impl VarDefinition {\n+    pub fn new(value: Region) -> Self {\n+        Self {\n+            name: (),\n+            value,\n+            capped: false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct Constraint {\n+    sub: RegionIndex,\n+    sup: RegionIndex,\n+    point: Location,\n+}\n+\n+newtype_index!(ConstraintIndex);\n+\n+impl InferenceContext {\n+    pub fn new(values: IndexVec<RegionIndex, Region>) -> Self {\n+        Self {\n+            definitions: values.into_iter().map(VarDefinition::new).collect(),\n+            constraints: IndexVec::new(),\n+            errors: IndexVec::new(),\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn cap_var(&mut self, v: RegionIndex) {\n+        self.definitions[v].capped = true;\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn add_live_point(&mut self, v: RegionIndex, point: Location) {\n+        debug!(\"add_live_point({:?}, {:?})\", v, point);\n+        let definition = &mut self.definitions[v];\n+        if definition.value.add_point(point) {\n+            if definition.capped {\n+                self.errors.push(InferenceError {\n+                    constraint_point: point,\n+                    name: definition.name,\n+                });\n+            }\n+        }\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn add_outlives(&mut self, sup: RegionIndex, sub: RegionIndex, point: Location) {\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n+        self.constraints.push(Constraint { sup, sub, point });\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn region(&self, v: RegionIndex) -> &Region {\n+        &self.definitions[v].value\n+    }\n+\n+    pub fn solve<'a, 'gcx, 'tcx>(\n+        &mut self,\n+        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+        mir: &'a Mir<'tcx>,\n+    ) -> IndexVec<InferenceErrorIndex, InferenceError>\n+    where\n+        'gcx: 'tcx + 'a,\n+        'tcx: 'a,\n+    {\n+        let mut changed = true;\n+        let mut dfs = Dfs::new(infcx, mir);\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                let sub = &self.definitions[constraint.sub].value.clone();\n+                let sup_def = &mut self.definitions[constraint.sup];\n+                debug!(\"constraint: {:?}\", constraint);\n+                debug!(\"    sub (before): {:?}\", sub);\n+                debug!(\"    sup (before): {:?}\", sup_def.value);\n+\n+                if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n+                    changed = true;\n+                    if sup_def.capped {\n+                        // This is kind of a hack, but when we add a\n+                        // constraint, the \"point\" is always the point\n+                        // AFTER the action that induced the\n+                        // constraint. So report the error on the\n+                        // action BEFORE that.\n+                        assert!(constraint.point.statement_index > 0);\n+                        let p = Location {\n+                            block: constraint.point.block,\n+                            statement_index: constraint.point.statement_index - 1,\n+                        };\n+\n+                        self.errors.push(InferenceError {\n+                            constraint_point: p,\n+                            name: sup_def.name,\n+                        });\n+                    }\n+                }\n+\n+                debug!(\"    sup (after) : {:?}\", sup_def.value);\n+                debug!(\"    changed     : {:?}\", changed);\n+            }\n+            debug!(\"\\n\");\n+        }\n+\n+        mem::replace(&mut self.errors, IndexVec::new())\n+    }\n+}\n+\n+struct Dfs<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> {\n+    #[allow(dead_code)]\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    mir: &'a Mir<'tcx>,\n+}\n+\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> Dfs<'a, 'gcx, 'tcx> {\n+    fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>, mir: &'a Mir<'tcx>) -> Self {\n+        Self { infcx, mir }\n+    }\n+\n+    fn copy(\n+        &mut self,\n+        from_region: &Region,\n+        to_region: &mut Region,\n+        start_point: Location,\n+    ) -> bool {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(start_point);\n+        while let Some(p) = stack.pop() {\n+            debug!(\"        dfs: p={:?}\", p);\n+\n+            if !from_region.may_contain(p) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            changed |= to_region.add_point(p);\n+\n+            let block_data = &self.mir[p.block];\n+            let successor_points = if p.statement_index < block_data.statements.len() {\n+                vec![Location {\n+                    statement_index: p.statement_index + 1,\n+                    ..p\n+                }]\n+            } else {\n+                block_data.terminator()\n+                    .successors()\n+                    .iter()\n+                    .map(|&basic_block| Location {\n+                        statement_index: 0,\n+                        block: basic_block,\n+                    })\n+                    .collect::<Vec<_>>()\n+            };\n+\n+            if successor_points.is_empty() {\n+                // FIXME handle free regions\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                // for region_decl in self.infcx.tcx.tables.borrow().free_region_map() {\n+                //     // FIXME(nashenas88) figure out skolemized_end points\n+                //     let block = self.env.graph.skolemized_end(region_decl.name);\n+                //     let skolemized_end_point = Location {\n+                //         block,\n+                //         statement_index: 0,\n+                //     };\n+                //     changed |= to_region.add_point(skolemized_end_point);\n+                // }\n+            } else {\n+                stack.extend(successor_points);\n+            }\n+        }\n+\n+        changed\n+    }\n+}"}, {"sha": "805e9c976e4f0ed6774b1ebfb1e14620b7977bab", "filename": "src/librustc_mir/transform/nll/mod.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2d75213709ab78d0db9051d9e0b550192e1aa15a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d75213709ab78d0db9051d9e0b550192e1aa15a/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fmod.rs?ref=2d75213709ab78d0db9051d9e0b550192e1aa15a", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use self::infer::InferenceContext;\n use rustc::ty::TypeFoldable;\n use rustc::ty::subst::{Kind, Substs};\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts, RegionVid, RegionKind};\n use rustc::mir::{Mir, Location, Rvalue, BasicBlock, Statement, StatementKind};\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n-use rustc::infer::{self, InferCtxt};\n+use rustc::infer::{self as rustc_infer, InferCtxt};\n use rustc::util::nodemap::FxHashSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use syntax_pos::DUMMY_SP;\n@@ -24,30 +25,33 @@ use std::fmt;\n use util as mir_util;\n use self::mir_util::PassWhere;\n \n+mod infer;\n+\n #[allow(dead_code)]\n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     lookup_map: HashMap<RegionVid, Lookup>,\n     regions: IndexVec<RegionIndex, Region>,\n-    infcx: InferCtxt<'a, 'gcx, 'tcx>,\n+    #[allow(dead_code)]\n+    infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>) -> Self {\n         NLLVisitor {\n             infcx,\n             lookup_map: HashMap::new(),\n             regions: IndexVec::new(),\n         }\n     }\n \n-    pub fn into_results(self) -> HashMap<RegionVid, Lookup> {\n-        self.lookup_map\n+    pub fn into_results(self) -> (HashMap<RegionVid, Lookup>, IndexVec<RegionIndex, Region>) {\n+        (self.lookup_map, self.regions)\n     }\n \n     fn renumber_regions<T>(&mut self, value: &T) -> T where T: TypeFoldable<'tcx> {\n         self.infcx.tcx.fold_regions(value, &mut false, |_region, _depth| {\n             self.regions.push(Region::default());\n-            self.infcx.next_region_var(infer::MiscVariable(DUMMY_SP))\n+            self.infcx.next_region_var(rustc_infer::MiscVariable(DUMMY_SP))\n         })\n     }\n \n@@ -147,7 +151,7 @@ impl MirPass for NLL {\n         tcx.infer_ctxt().enter(|infcx| {\n             // Clone mir so we can mutate it without disturbing the rest of the compiler\n             let mut renumbered_mir = mir.clone();\n-            let mut visitor = NLLVisitor::new(infcx);\n+            let mut visitor = NLLVisitor::new(&infcx);\n             visitor.visit_mir(&mut renumbered_mir);\n             mir_util::dump_mir(tcx, None, \"nll\", &0, source, mir, |pass_where, out| {\n                 if let PassWhere::BeforeCFG = pass_where {\n@@ -157,13 +161,15 @@ impl MirPass for NLL {\n                 }\n                 Ok(())\n             });\n-            let _results = visitor.into_results();\n+            let (_lookup_map, regions) = visitor.into_results();\n+            let mut inference_context = InferenceContext::new(regions);\n+            inference_context.solve(&infcx, &renumbered_mir);\n         })\n     }\n }\n \n #[derive(Clone, Default, PartialEq, Eq)]\n-struct Region {\n+pub struct Region {\n     points: FxHashSet<Location>,\n }\n \n@@ -173,6 +179,14 @@ impl fmt::Debug for Region {\n     }\n }\n \n+impl Region {\n+    pub fn add_point(&mut self, point: Location) -> bool {\n+        self.points.insert(point)\n+    }\n \n+    pub fn may_contain(&self, point: Location) -> bool {\n+        self.points.contains(&point)\n+    }\n+}\n \n newtype_index!(RegionIndex);"}]}