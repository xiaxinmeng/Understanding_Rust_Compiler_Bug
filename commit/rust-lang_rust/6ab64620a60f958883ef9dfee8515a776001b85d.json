{"sha": "6ab64620a60f958883ef9dfee8515a776001b85d", "node_id": "C_kwDOAAsO6NoAKDZhYjY0NjIwYTYwZjk1ODg4M2VmOWRmZWU4NTE1YTc3NjAwMWI4NWQ", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-18T12:55:50Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-18T12:55:50Z"}, "message": "refactor atomic intrinsic handling to actually parse the intrinsic name", "tree": {"sha": "daed04c7143631026e9034e624157df41aac83c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daed04c7143631026e9034e624157df41aac83c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ab64620a60f958883ef9dfee8515a776001b85d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ab64620a60f958883ef9dfee8515a776001b85d", "html_url": "https://github.com/rust-lang/rust/commit/6ab64620a60f958883ef9dfee8515a776001b85d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ab64620a60f958883ef9dfee8515a776001b85d/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad3010c449572d86bb668ed1dc53bac5df041374", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3010c449572d86bb668ed1dc53bac5df041374", "html_url": "https://github.com/rust-lang/rust/commit/ad3010c449572d86bb668ed1dc53bac5df041374"}], "stats": {"total": 332, "additions": 100, "deletions": 232}, "files": [{"sha": "78e13a498ce1b34eb2f961768e350b75beb4d0f1", "filename": "src/shims/intrinsics/atomic.rs", "status": "modified", "additions": 100, "deletions": 232, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/6ab64620a60f958883ef9dfee8515a776001b85d/src%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ab64620a60f958883ef9dfee8515a776001b85d/src%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fatomic.rs?ref=6ab64620a60f958883ef9dfee8515a776001b85d", "patch": "@@ -1,10 +1,12 @@\n-use rustc_middle::{mir, mir::BinOp};\n+use rustc_middle::{mir, mir::BinOp, ty};\n use rustc_target::abi::Align;\n \n use crate::*;\n use helpers::check_arg_count;\n \n pub enum AtomicOp {\n+    /// The `bool` indicates whether the result of the operation should be negated\n+    /// (must be a boolean-typed operation).\n     MirOp(mir::BinOp, bool),\n     Max,\n     Min,\n@@ -20,236 +22,99 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest: &PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        match intrinsic_name {\n-            \"load_seqcst\" => this.atomic_load(args, dest, AtomicReadOrd::SeqCst)?,\n-            \"load_relaxed\" => this.atomic_load(args, dest, AtomicReadOrd::Relaxed)?,\n-            \"load_acquire\" => this.atomic_load(args, dest, AtomicReadOrd::Acquire)?,\n-\n-            \"store_seqcst\" => this.atomic_store(args, AtomicWriteOrd::SeqCst)?,\n-            \"store_relaxed\" => this.atomic_store(args, AtomicWriteOrd::Relaxed)?,\n-            \"store_release\" => this.atomic_store(args, AtomicWriteOrd::Release)?,\n-\n-            \"fence_acquire\" => this.atomic_fence(args, AtomicFenceOrd::Acquire)?,\n-            \"fence_release\" => this.atomic_fence(args, AtomicFenceOrd::Release)?,\n-            \"fence_acqrel\" => this.atomic_fence(args, AtomicFenceOrd::AcqRel)?,\n-            \"fence_seqcst\" => this.atomic_fence(args, AtomicFenceOrd::SeqCst)?,\n-\n-            \"singlethreadfence_acquire\" => this.compiler_fence(args, AtomicFenceOrd::Acquire)?,\n-            \"singlethreadfence_release\" => this.compiler_fence(args, AtomicFenceOrd::Release)?,\n-            \"singlethreadfence_acqrel\" => this.compiler_fence(args, AtomicFenceOrd::AcqRel)?,\n-            \"singlethreadfence_seqcst\" => this.compiler_fence(args, AtomicFenceOrd::SeqCst)?,\n-\n-            \"xchg_seqcst\" => this.atomic_exchange(args, dest, AtomicRwOrd::SeqCst)?,\n-            \"xchg_acquire\" => this.atomic_exchange(args, dest, AtomicRwOrd::Acquire)?,\n-            \"xchg_release\" => this.atomic_exchange(args, dest, AtomicRwOrd::Release)?,\n-            \"xchg_acqrel\" => this.atomic_exchange(args, dest, AtomicRwOrd::AcqRel)?,\n-            \"xchg_relaxed\" => this.atomic_exchange(args, dest, AtomicRwOrd::Relaxed)?,\n-\n-            #[rustfmt::skip]\n-            \"cxchg_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchg_seqcst_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchg_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchg_acqrel_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchg_acqrel_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchg_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchg_acquire_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchg_acquire_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchg_acquire_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchg_release_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Release, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchg_release_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchg_release_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchg_relaxed_seqcst\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchg_relaxed_acquire\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchg_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n-\n-            #[rustfmt::skip]\n-            \"cxchgweak_seqcst_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_seqcst_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_seqcst_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::SeqCst, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_acqrel_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_acqrel_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_acqrel_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::AcqRel, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_acquire_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_acquire_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_acquire_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Acquire, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_release_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Release, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_release_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_release_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Release, AtomicReadOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_relaxed_seqcst\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_relaxed_acquire\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"cxchgweak_relaxed_relaxed\" =>\n-                this.atomic_compare_exchange_weak(args, dest, AtomicRwOrd::Relaxed, AtomicReadOrd::Relaxed)?,\n-\n-            #[rustfmt::skip]\n-            \"or_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"or_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"or_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"or_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"or_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"xor_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"xor_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"xor_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"xor_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"xor_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"and_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"and_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"and_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"and_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"and_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"nand_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"nand_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"nand_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"nand_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"nand_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"xadd_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"xadd_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"xadd_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"xadd_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"xadd_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), AtomicRwOrd::Relaxed)?,\n-            #[rustfmt::skip]\n-            \"xsub_seqcst\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::SeqCst)?,\n-            #[rustfmt::skip]\n-            \"xsub_acquire\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Acquire)?,\n-            #[rustfmt::skip]\n-            \"xsub_release\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Release)?,\n-            #[rustfmt::skip]\n-            \"xsub_acqrel\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::AcqRel)?,\n-            #[rustfmt::skip]\n-            \"xsub_relaxed\" =>\n-                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), AtomicRwOrd::Relaxed)?,\n-\n-            \"min_seqcst\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n-            \"min_acquire\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n-            \"min_release\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n-            \"min_acqrel\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n-            \"min_relaxed\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n-            \"max_seqcst\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n-            \"max_acquire\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n-            \"max_release\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n-            \"max_acqrel\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n-            \"max_relaxed\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n-            \"umin_seqcst\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::SeqCst)?,\n-            \"umin_acquire\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Acquire)?,\n-            \"umin_release\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Release)?,\n-            \"umin_acqrel\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::AcqRel)?,\n-            \"umin_relaxed\" => this.atomic_op(args, dest, AtomicOp::Min, AtomicRwOrd::Relaxed)?,\n-            \"umax_seqcst\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::SeqCst)?,\n-            \"umax_acquire\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Acquire)?,\n-            \"umax_release\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Release)?,\n-            \"umax_acqrel\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::AcqRel)?,\n-            \"umax_relaxed\" => this.atomic_op(args, dest, AtomicOp::Max, AtomicRwOrd::Relaxed)?,\n-\n-            name => throw_unsup_format!(\"unimplemented intrinsic: `atomic_{name}`\"),\n+\n+        let intrinsic_structure: Vec<_> = intrinsic_name.split('_').collect();\n+\n+        fn read_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicReadOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicReadOrd::SeqCst,\n+                \"acquire\" => AtomicReadOrd::Acquire,\n+                \"relaxed\" => AtomicReadOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported read ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn write_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicWriteOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicWriteOrd::SeqCst,\n+                \"release\" => AtomicWriteOrd::Release,\n+                \"relaxed\" => AtomicWriteOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported write ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn rw_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicRwOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicRwOrd::SeqCst,\n+                \"acqrel\" => AtomicRwOrd::AcqRel,\n+                \"acquire\" => AtomicRwOrd::Acquire,\n+                \"release\" => AtomicRwOrd::Release,\n+                \"relaxed\" => AtomicRwOrd::Relaxed,\n+                _ => throw_unsup_format!(\"unsupported read-write ordering `{ord}`\"),\n+            })\n+        }\n+\n+        fn fence_ord<'tcx>(ord: &str) -> InterpResult<'tcx, AtomicFenceOrd> {\n+            Ok(match ord {\n+                \"seqcst\" => AtomicFenceOrd::SeqCst,\n+                \"acqrel\" => AtomicFenceOrd::AcqRel,\n+                \"acquire\" => AtomicFenceOrd::Acquire,\n+                \"release\" => AtomicFenceOrd::Release,\n+                _ => throw_unsup_format!(\"unsupported fence ordering `{ord}`\"),\n+            })\n+        }\n+\n+        match &*intrinsic_structure {\n+            [\"load\", ord] => this.atomic_load(args, dest, read_ord(ord)?)?,\n+            [\"store\", ord] => this.atomic_store(args, write_ord(ord)?)?,\n+\n+            [\"fence\", ord] => this.atomic_fence(args, fence_ord(ord)?)?,\n+            [\"singlethreadfence\", ord] => this.compiler_fence(args, fence_ord(ord)?)?,\n+\n+            [\"xchg\", ord] => this.atomic_exchange(args, dest, rw_ord(ord)?)?,\n+            [\"cxchg\", ord1, ord2] =>\n+                this.atomic_compare_exchange(args, dest, rw_ord(ord1)?, read_ord(ord2)?)?,\n+            [\"cxchgweak\", ord1, ord2] =>\n+                this.atomic_compare_exchange_weak(args, dest, rw_ord(ord1)?, read_ord(ord2)?)?,\n+\n+            [\"or\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitOr, false), rw_ord(ord)?)?,\n+            [\"xor\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitXor, false), rw_ord(ord)?)?,\n+            [\"and\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, false), rw_ord(ord)?)?,\n+            [\"nand\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::BitAnd, true), rw_ord(ord)?)?,\n+            [\"xadd\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Add, false), rw_ord(ord)?)?,\n+            [\"xsub\", ord] =>\n+                this.atomic_op(args, dest, AtomicOp::MirOp(BinOp::Sub, false), rw_ord(ord)?)?,\n+            [\"min\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Int(_)));\n+                this.atomic_op(args, dest, AtomicOp::Min, rw_ord(ord)?)?;\n+            }\n+            [\"umin\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Uint(_)));\n+                this.atomic_op(args, dest, AtomicOp::Min, rw_ord(ord)?)?;\n+            }\n+            [\"max\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Int(_)));\n+                this.atomic_op(args, dest, AtomicOp::Max, rw_ord(ord)?)?;\n+            }\n+            [\"umax\", ord] => {\n+                // Later we will use the type to indicate signed vs unsigned,\n+                // so make sure it matches the intrinsic name.\n+                assert!(matches!(args[1].layout.ty.kind(), ty::Uint(_)));\n+                this.atomic_op(args, dest, AtomicOp::Max, rw_ord(ord)?)?;\n+            }\n+\n+            _ => throw_unsup_format!(\"unimplemented intrinsic: `atomic_{intrinsic_name}`\"),\n         }\n         Ok(())\n     }\n@@ -343,14 +208,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let [place, rhs] = check_arg_count(args)?;\n         let place = this.deref_operand(place)?;\n+        let rhs = this.read_immediate(rhs)?;\n \n         if !place.layout.ty.is_integral() && !place.layout.ty.is_unsafe_ptr() {\n             span_bug!(\n                 this.cur_span(),\n                 \"atomic arithmetic operations only work on integer and raw pointer types\",\n             );\n         }\n-        let rhs = this.read_immediate(rhs)?;\n+        if rhs.layout.ty != place.layout.ty {\n+            span_bug!(this.cur_span(), \"atomic arithmetic operation type mismatch\");\n+        }\n \n         // Check alignment requirements. Atomics must always be aligned to their size,\n         // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must"}]}