{"sha": "816147c4b508117fad4ca4d3cb6d77a3c4a683a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjE0N2M0YjUwODExN2ZhZDRjYTRkM2NiNmQ3N2EzYzRhNjgzYTk=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-25T13:55:46Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-05-25T13:55:46Z"}, "message": "Simplify  token_tree_to_xxx", "tree": {"sha": "7b1f2ca7972982b8dc05e34998a30305f0a04831", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b1f2ca7972982b8dc05e34998a30305f0a04831"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/816147c4b508117fad4ca4d3cb6d77a3c4a683a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/816147c4b508117fad4ca4d3cb6d77a3c4a683a9", "html_url": "https://github.com/rust-lang/rust/commit/816147c4b508117fad4ca4d3cb6d77a3c4a683a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/816147c4b508117fad4ca4d3cb6d77a3c4a683a9/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcb1eef3232c3fc673bf5f98595708e108c3950c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcb1eef3232c3fc673bf5f98595708e108c3950c", "html_url": "https://github.com/rust-lang/rust/commit/fcb1eef3232c3fc673bf5f98595708e108c3950c"}], "stats": {"total": 67, "additions": 20, "deletions": 47}, "files": [{"sha": "6265fe462d383bbb8e22fcc0cc32c4a1827026db", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 20, "deletions": 47, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/816147c4b508117fad4ca4d3cb6d77a3c4a683a9/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/816147c4b508117fad4ca4d3cb6d77a3c4a683a9/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=816147c4b508117fad4ca4d3cb6d77a3c4a683a9", "patch": "@@ -45,92 +45,65 @@ pub fn syntax_node_to_token_tree(node: &SyntaxNode) -> Option<(tt::Subtree, Toke\n //\n //\n \n-/// Parses the token tree (result of macro expansion) to an expression\n-pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, ExpandError> {\n+fn token_tree_to_syntax_node<F>(tt: &tt::Subtree, f: F) -> Result<TreeArc<SyntaxNode>, ExpandError>\n+where\n+    F: Fn(&mut ra_parser::TokenSource, &mut ra_parser::TreeSink),\n+{\n     let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n     let mut token_source = SubtreeTokenSource::new(&buffer);\n     let querier = token_source.querier();\n     let mut tree_sink = TtTreeSink::new(querier.as_ref());\n-    ra_parser::parse_expr(&mut token_source, &mut tree_sink);\n+    f(&mut token_source, &mut tree_sink);\n+    if tree_sink.roots.len() != 1 {\n+        return Err(ExpandError::ConversionError);\n+    }\n+\n     if tree_sink.roots.len() != 1 {\n         return Err(ExpandError::ConversionError);\n     }\n \n-    let syntax = tree_sink.inner.finish();\n+    Ok(tree_sink.inner.finish())\n+}\n+\n+/// Parses the token tree (result of macro expansion) to an expression\n+pub fn token_tree_to_expr(tt: &tt::Subtree) -> Result<TreeArc<ast::Expr>, ExpandError> {\n+    let syntax = token_tree_to_syntax_node(tt, ra_parser::parse_expr)?;\n     ast::Expr::cast(&syntax)\n         .map(|m| m.to_owned())\n         .ok_or_else(|| crate::ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) to a Pattern\n pub fn token_tree_to_pat(tt: &tt::Subtree) -> Result<TreeArc<ast::Pat>, ExpandError> {\n-    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n-    let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let querier = token_source.querier();\n-    let mut tree_sink = TtTreeSink::new(querier.as_ref());\n-    ra_parser::parse_pat(&mut token_source, &mut tree_sink);\n-    if tree_sink.roots.len() != 1 {\n-        return Err(ExpandError::ConversionError);\n-    }\n-\n-    let syntax = tree_sink.inner.finish();\n+    let syntax = token_tree_to_syntax_node(tt, ra_parser::parse_pat)?;\n     ast::Pat::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) to a Type\n pub fn token_tree_to_ty(tt: &tt::Subtree) -> Result<TreeArc<ast::TypeRef>, ExpandError> {\n-    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n-    let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let querier = token_source.querier();\n-    let mut tree_sink = TtTreeSink::new(querier.as_ref());\n-    ra_parser::parse_ty(&mut token_source, &mut tree_sink);\n-    if tree_sink.roots.len() != 1 {\n-        return Err(ExpandError::ConversionError);\n-    }\n-    let syntax = tree_sink.inner.finish();\n+    let syntax = token_tree_to_syntax_node(tt, ra_parser::parse_ty)?;\n     ast::TypeRef::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) as a sequence of stmts\n pub fn token_tree_to_macro_stmts(\n     tt: &tt::Subtree,\n ) -> Result<TreeArc<ast::MacroStmts>, ExpandError> {\n-    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n-    let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let querier = token_source.querier();\n-    let mut tree_sink = TtTreeSink::new(querier.as_ref());\n-    ra_parser::parse_macro_stmts(&mut token_source, &mut tree_sink);\n-    if tree_sink.roots.len() != 1 {\n-        return Err(ExpandError::ConversionError);\n-    }\n-    let syntax = tree_sink.inner.finish();\n+    let syntax = token_tree_to_syntax_node(tt, ra_parser::parse_macro_stmts)?;\n     ast::MacroStmts::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) as a sequence of items\n pub fn token_tree_to_macro_items(\n     tt: &tt::Subtree,\n ) -> Result<TreeArc<ast::MacroItems>, ExpandError> {\n-    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n-    let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let querier = token_source.querier();\n-    let mut tree_sink = TtTreeSink::new(querier.as_ref());\n-    ra_parser::parse_macro_items(&mut token_source, &mut tree_sink);\n-    if tree_sink.roots.len() != 1 {\n-        return Err(ExpandError::ConversionError);\n-    }\n-    let syntax = tree_sink.inner.finish();\n+    let syntax = token_tree_to_syntax_node(tt, ra_parser::parse_macro_items)?;\n     ast::MacroItems::cast(&syntax).map(|m| m.to_owned()).ok_or_else(|| ExpandError::ConversionError)\n }\n \n /// Parses the token tree (result of macro expansion) as a sequence of items\n pub fn token_tree_to_ast_item_list(tt: &tt::Subtree) -> TreeArc<ast::SourceFile> {\n-    let buffer = tt::buffer::TokenBuffer::new(&[tt.clone().into()]);\n-    let mut token_source = SubtreeTokenSource::new(&buffer);\n-    let querier = token_source.querier();\n-    let mut tree_sink = TtTreeSink::new(querier.as_ref());\n-    ra_parser::parse(&mut token_source, &mut tree_sink);\n-    let syntax = tree_sink.inner.finish();\n+    let syntax = token_tree_to_syntax_node(tt, ra_parser::parse).unwrap();\n     ast::SourceFile::cast(&syntax).unwrap().to_owned()\n }\n "}]}