{"sha": "e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2MzMyNDliMzFkNmVjZmI0NmE0ZDdkODViNWJlNGE5ZGQ5NmIxYzA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T00:33:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-12T03:58:44Z"}, "message": "Test fixes and rebase conflicts", "tree": {"sha": "c504544264ea1c79c8735bafee0709378e3974bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c504544264ea1c79c8735bafee0709378e3974bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "html_url": "https://github.com/rust-lang/rust/commit/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a6b9219d180503254b55cfd14cdaf072fb35ac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6b9219d180503254b55cfd14cdaf072fb35ac4", "html_url": "https://github.com/rust-lang/rust/commit/0a6b9219d180503254b55cfd14cdaf072fb35ac4"}], "stats": {"total": 75, "additions": 31, "deletions": 44}, "files": [{"sha": "3487a92d8491cfa25c3274ba8a35d1716a328de1", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "patch": "@@ -242,13 +242,13 @@ use clone::Clone;\n use iter::Iterator;\n use kinds::Send;\n use kinds::marker;\n+use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Ok, Err, Result};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use sync::arc::UnsafeArc;\n-use util;\n \n pub use comm::select::{Select, Handle};\n \n@@ -427,7 +427,7 @@ impl<T: Send> Chan<T> {\n \n         unsafe {\n             let mut tmp = Chan::my_new(Stream(new_inner));\n-            util::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n+            mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n         }\n         return ret;\n     }\n@@ -460,7 +460,7 @@ impl<T: Send> Clone for Chan<T> {\n             (*packet.get()).inherit_blocker(sleeper);\n \n             let mut tmp = Chan::my_new(Shared(packet.clone()));\n-            util::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n+            mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n         }\n         Chan::my_new(Shared(packet))\n     }\n@@ -556,8 +556,8 @@ impl<T: Send> Port<T> {\n                 }\n             };\n             unsafe {\n-                util::swap(&mut cast::transmute_mut(self).inner,\n-                           &mut new_port.inner);\n+                mem::swap(&mut cast::transmute_mut(self).inner,\n+                          &mut new_port.inner);\n             }\n         }\n     }\n@@ -602,8 +602,8 @@ impl<T: Send> Port<T> {\n                 }\n             };\n             unsafe {\n-                util::swap(&mut cast::transmute_mut(self).inner,\n-                           &mut new_port.inner);\n+                mem::swap(&mut cast::transmute_mut(self).inner,\n+                          &mut new_port.inner);\n             }\n         }\n     }\n@@ -636,8 +636,8 @@ impl<T: Send> select::Packet for Port<T> {\n                 }\n             };\n             unsafe {\n-                util::swap(&mut cast::transmute_mut(self).inner,\n-                           &mut new_port.inner);\n+                mem::swap(&mut cast::transmute_mut(self).inner,\n+                          &mut new_port.inner);\n             }\n         }\n     }\n@@ -665,8 +665,8 @@ impl<T: Send> select::Packet for Port<T> {\n             };\n             task = t;\n             unsafe {\n-                util::swap(&mut cast::transmute_mut(self).inner,\n-                           &mut new_port.inner);\n+                mem::swap(&mut cast::transmute_mut(self).inner,\n+                          &mut new_port.inner);\n             }\n         }\n     }\n@@ -686,8 +686,8 @@ impl<T: Send> select::Packet for Port<T> {\n             let mut new_port = match result { Ok(b) => return b, Err(p) => p };\n             was_upgrade = true;\n             unsafe {\n-                util::swap(&mut cast::transmute_mut(self).inner,\n-                           &mut new_port.inner);\n+                mem::swap(&mut cast::transmute_mut(self).inner,\n+                          &mut new_port.inner);\n             }\n         }\n     }"}, {"sha": "9deccfeb8756697399c5401c4b6ad9acc75b4935", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "patch": "@@ -34,13 +34,13 @@\n \n use comm::Port;\n use kinds::Send;\n+use mem;\n use ops::Drop;\n use option::{Some, None, Option};\n use result::{Result, Ok, Err};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n use sync::atomics;\n-use util;\n \n // Various states you can find a port in.\n static EMPTY: uint = 0;\n@@ -100,10 +100,7 @@ impl<T: Send> Packet<T> {\n         self.data = Some(t);\n         self.upgrade = SendUsed;\n \n-        // This atomic swap uses a \"Release\" memory ordering to ensure that all\n-        // our previous memory writes are visible to the other thread (notably\n-        // the write of data/upgrade)\n-        match self.state.swap(DATA, atomics::Release) {\n+        match self.state.swap(DATA, atomics::SeqCst) {\n             // Sent the data, no one was waiting\n             EMPTY => true,\n \n@@ -141,14 +138,11 @@ impl<T: Send> Packet<T> {\n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n         // Attempt to not block the task (it's a little expensive). If it looks\n         // like we're not empty, then immediately go through to `try_recv`.\n-        //\n-        // These atomics use an Acquire memory ordering in order to have all the\n-        // previous writes of the releasing thread visible to us.\n-        if self.state.load(atomics::Acquire) == EMPTY {\n+        if self.state.load(atomics::SeqCst) == EMPTY {\n             let t: ~Task = Local::take();\n             t.deschedule(1, |task| {\n                 let n = unsafe { task.cast_to_uint() };\n-                match self.state.compare_and_swap(EMPTY, n, atomics::Acquire) {\n+                match self.state.compare_and_swap(EMPTY, n, atomics::SeqCst) {\n                     // Nothing on the channel, we legitimately block\n                     EMPTY => Ok(()),\n \n@@ -168,8 +162,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn try_recv(&mut self) -> Result<T, Failure<T>> {\n-        // see above for why Acquire is used.\n-        match self.state.load(atomics::Acquire) {\n+        match self.state.load(atomics::SeqCst) {\n             EMPTY => Err(Empty),\n \n             // We saw some data on the channel, but the channel can be used\n@@ -179,7 +172,7 @@ impl<T: Send> Packet<T> {\n             // the state changes under our feet we'd rather just see that state\n             // change.\n             DATA => {\n-                self.state.compare_and_swap(DATA, EMPTY, atomics::Acquire);\n+                self.state.compare_and_swap(DATA, EMPTY, atomics::SeqCst);\n                 match self.data.take() {\n                     Some(data) => Ok(data),\n                     None => unreachable!(),\n@@ -194,7 +187,7 @@ impl<T: Send> Packet<T> {\n                 match self.data.take() {\n                     Some(data) => Ok(data),\n                     None => {\n-                        match util::replace(&mut self.upgrade, SendUsed) {\n+                        match mem::replace(&mut self.upgrade, SendUsed) {\n                             SendUsed | NothingSent => Err(Disconnected),\n                             GoUp(upgrade) => Err(Upgraded(upgrade))\n                         }\n@@ -216,9 +209,7 @@ impl<T: Send> Packet<T> {\n         };\n         self.upgrade = GoUp(up);\n \n-        // Use a Release memory ordering in order to make sure that our write to\n-        // `upgrade` is visible to the other thread.\n-        match self.state.swap(DISCONNECTED, atomics::Release) {\n+        match self.state.swap(DISCONNECTED, atomics::SeqCst) {\n             // If the channel is empty or has data on it, then we're good to go.\n             // Senders will check the data before the upgrade (in case we\n             // plastered over the DATA state).\n@@ -246,9 +237,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     pub fn drop_port(&mut self) {\n-        // Use an Acquire memory ordering in order to see the data that the\n-        // senders are sending.\n-        match self.state.swap(DISCONNECTED, atomics::Acquire) {\n+        match self.state.swap(DISCONNECTED, atomics::SeqCst) {\n             // An empty channel has nothing to do, and a remotely disconnected\n             // channel also has nothing to do b/c we're about to run the drop\n             // glue\n@@ -271,13 +260,12 @@ impl<T: Send> Packet<T> {\n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n     pub fn can_recv(&mut self) -> Result<bool, Port<T>> {\n-        // Use Acquire so we can see all previous memory writes\n-        match self.state.load(atomics::Acquire) {\n+        match self.state.load(atomics::SeqCst) {\n             EMPTY => Ok(false), // Welp, we tried\n             DATA => Ok(true),   // we have some un-acquired data\n             DISCONNECTED if self.data.is_some() => Ok(true), // we have data\n             DISCONNECTED => {\n-                match util::replace(&mut self.upgrade, SendUsed) {\n+                match mem::replace(&mut self.upgrade, SendUsed) {\n                     // The other end sent us an upgrade, so we need to\n                     // propagate upwards whether the upgrade can receive\n                     // data\n@@ -304,7 +292,7 @@ impl<T: Send> Packet<T> {\n                 SelCanceled(unsafe { BlockedTask::cast_from_uint(n) })\n             }\n             DISCONNECTED => {\n-                match util::replace(&mut self.upgrade, SendUsed) {\n+                match mem::replace(&mut self.upgrade, SendUsed) {\n                     // The other end sent us an upgrade, so we need to\n                     // propagate upwards whether the upgrade can receive\n                     // data\n@@ -331,8 +319,7 @@ impl<T: Send> Packet<T> {\n     //\n     // The return value indicates whether there's data on this port.\n     pub fn abort_selection(&mut self) -> Result<bool, Port<T>> {\n-        // use Acquire to make sure we see all previous memory writes\n-        let state = match self.state.load(atomics::Acquire) {\n+        let state = match self.state.load(atomics::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection\n             s @ EMPTY |\n@@ -357,7 +344,7 @@ impl<T: Send> Packet<T> {\n             // aborted.\n             DISCONNECTED => {\n                 assert!(self.data.is_none());\n-                match util::replace(&mut self.upgrade, SendUsed) {\n+                match mem::replace(&mut self.upgrade, SendUsed) {\n                     GoUp(port) => Err(port),\n                     _ => Ok(true),\n                 }"}, {"sha": "53129f3df9b6ffa2d8caa58666db4672dbc7e338", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "patch": "@@ -698,7 +698,7 @@ mod test {\n     iotest!(fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n-        let (p, c) = SharedChan::new();\n+        let (p, c) = Chan::new();\n         let c2 = c.clone();\n \n         spawn(proc() {"}, {"sha": "f779d80976f6b4b522981b1ae7b04915a70ca15c", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "patch": "@@ -301,7 +301,7 @@ mod test {\n         let addr2 = next_test_ip4();\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n-        let (p, c) = SharedChan::new();\n+        let (p, c) = Chan::new();\n         let c2 = c.clone();\n \n         spawn(proc() {\n@@ -335,7 +335,7 @@ mod test {\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n \n-        let (p, c) = SharedChan::new();\n+        let (p, c) = Chan::new();\n         let (serv_port, serv_chan) = Chan::new();\n \n         spawn(proc() {"}, {"sha": "6ce4a6fdc875815ecfeaf5870c2190075f5d868f", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=e633249b31d6ecfb46a4d7d85b5be4a9dd96b1c0", "patch": "@@ -270,7 +270,7 @@ mod tests {\n     fn unix_clone_two_read() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n-        let (p, c) = SharedChan::new();\n+        let (p, c) = Chan::new();\n         let c2 = c.clone();\n \n         spawn(proc() {"}]}