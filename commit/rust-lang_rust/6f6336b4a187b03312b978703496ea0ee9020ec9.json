{"sha": "6f6336b4a187b03312b978703496ea0ee9020ec9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNjMzNmI0YTE4N2IwMzMxMmI5Nzg3MDM0OTZlYTBlZTkwMjBlYzk=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-24T14:03:20Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-27T08:05:56Z"}, "message": "Split sys_common::Mutex in StaticMutex and MovableMutex.\n\nThe (unsafe) Mutex from sys_common had a rather complicated interface.\nYou were supposed to call init() manually, unless you could guarantee it\nwas neither moved nor used reentrantly.\n\nCalling `destroy()` was also optional, although it was unclear if 1)\nresources might be leaked or not, and 2) if destroy() should only be\ncalled when `init()` was called.\n\nThis allowed for a number of interesting (confusing?) different ways to\nuse this Mutex, all captured in a single type.\n\nIn practice, this type was only ever used in two ways:\n\n1. As a static variable. In this case, neither init() nor destroy() are\n   called. The variable is never moved, and it is never used\n   reentrantly. It is only ever locked using the LockGuard, never with\n   raw_lock.\n\n2. As a Boxed variable. In this case, both init() and destroy() are\n   called, it will be moved and possibly used reentrantly.\n\nNo other combinations are used anywhere in `std`.\n\nThis change simplifies things by splitting this Mutex type into\ntwo types matching the two use cases: StaticMutex and MovableMutex.\n\nThe interface of both new types is now both safer and simpler. The first\none does not call nor expose init/destroy, and the second one calls\nthose automatically in its new() and Drop functions. Also, the locking\nfunctions of MovableMutex are no longer unsafe.", "tree": {"sha": "977253e1012f07a7a7a60c24e14102be3b363469", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/977253e1012f07a7a7a60c24e14102be3b363469"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f6336b4a187b03312b978703496ea0ee9020ec9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f6336b4a187b03312b978703496ea0ee9020ec9", "html_url": "https://github.com/rust-lang/rust/commit/6f6336b4a187b03312b978703496ea0ee9020ec9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f6336b4a187b03312b978703496ea0ee9020ec9/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "html_url": "https://github.com/rust-lang/rust/commit/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c"}], "stats": {"total": 221, "additions": 100, "deletions": 121}, "files": [{"sha": "1376d8ebe8f4a6478f358f1be05dedc890767740", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -553,8 +553,8 @@ impl Condvar {\n         unsafe { self.inner.notify_all() }\n     }\n \n-    fn verify(&self, mutex: &sys_mutex::Mutex) {\n-        let addr = mutex as *const _ as usize;\n+    fn verify(&self, mutex: &sys_mutex::MovableMutex) {\n+        let addr = mutex.raw() as *const _ as usize;\n         match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar."}, {"sha": "e8f5a6f42948601dd831c3304e07a1cbae326453", "filename": "library/std/src/sync/mutex.rs", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmutex.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -166,12 +166,7 @@ use crate::sys_common::poison::{self, LockResult, TryLockError, TryLockResult};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"mutex_type\")]\n pub struct Mutex<T: ?Sized> {\n-    // Note that this mutex is in a *box*, not inlined into the struct itself.\n-    // Once a native mutex has been used once, its address can never change (it\n-    // can't be moved). This mutex type can be safely moved at any time, so to\n-    // ensure that the native mutex is used correctly we box the inner mutex to\n-    // give it a constant address.\n-    inner: Box<sys::Mutex>,\n+    inner: sys::MovableMutex,\n     poison: poison::Flag,\n     data: UnsafeCell<T>,\n }\n@@ -218,15 +213,11 @@ impl<T> Mutex<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n-        let mut m = Mutex {\n-            inner: box sys::Mutex::new(),\n+        Mutex {\n+            inner: sys::MovableMutex::new(),\n             poison: poison::Flag::new(),\n             data: UnsafeCell::new(t),\n-        };\n-        unsafe {\n-            m.inner.init();\n         }\n-        m\n     }\n }\n \n@@ -378,7 +369,6 @@ impl<T: ?Sized> Mutex<T> {\n                 (ptr::read(inner), ptr::read(poison), ptr::read(data))\n             };\n             mem::forget(self);\n-            inner.destroy(); // Keep in sync with the `Drop` impl.\n             drop(inner);\n \n             poison::map_result(poison.borrow(), |_| data.into_inner())\n@@ -411,18 +401,6 @@ impl<T: ?Sized> Mutex<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<#[may_dangle] T: ?Sized> Drop for Mutex<T> {\n-    fn drop(&mut self) {\n-        // This is actually safe b/c we know that there is no further usage of\n-        // this mutex (it's up to the user to arrange for a mutex to get\n-        // dropped, that's not our job)\n-        //\n-        // IMPORTANT: This code must be kept in sync with `Mutex::into_inner`.\n-        unsafe { self.inner.destroy() }\n-    }\n-}\n-\n #[stable(feature = \"mutex_from\", since = \"1.24.0\")]\n impl<T> From<T> for Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n@@ -509,7 +487,7 @@ impl<T: ?Sized + fmt::Display> fmt::Display for MutexGuard<'_, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::MovableMutex {\n     &guard.lock.inner\n }\n "}, {"sha": "7727293927282b34e8b1afb750ec36faffbd93d1", "filename": "library/std/src/sys/hermit/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fargs.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -57,11 +57,11 @@ mod imp {\n     use crate::ptr;\n     use crate::sys_common::os_str_bytes::*;\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "f7c3f163718183510d78d904fc4bc3773f3aaf8e", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -80,13 +80,13 @@ mod imp {\n     use crate::ptr;\n     use crate::sync::atomic::{AtomicIsize, AtomicPtr, Ordering};\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static ARGC: AtomicIsize = AtomicIsize::new(0);\n     static ARGV: AtomicPtr<*const u8> = AtomicPtr::new(ptr::null_mut());\n     // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n     // acquire this mutex reentrantly!\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     unsafe fn really_init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "c9f9ed01e120e259b6cf408bf7e91bd5addc1521", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -21,7 +21,7 @@ use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n-use crate::sys_common::mutex::{Mutex, MutexGuard};\n+use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};\n@@ -470,10 +470,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> MutexGuard<'static> {\n-    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-    // acquire this mutex reentrantly!\n-    static ENV_LOCK: Mutex = Mutex::new();\n+pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()\n }\n "}, {"sha": "30cf7a707c7af9e08d53ec1e6719d98f837ab357", "filename": "library/std/src/sys/vxworks/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -57,11 +57,11 @@ mod imp {\n     use crate::marker::PhantomData;\n     use crate::ptr;\n \n-    use crate::sys_common::mutex::Mutex;\n+    use crate::sys_common::mutex::StaticMutex;\n \n     static mut ARGC: isize = 0;\n     static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: Mutex = Mutex::new();\n+    static LOCK: StaticMutex = StaticMutex::new();\n \n     pub unsafe fn init(argc: isize, argv: *const *const u8) {\n         let _guard = LOCK.lock();"}, {"sha": "08394a8d29de1c3e024646951c0c51d5443b1341", "filename": "library/std/src/sys/vxworks/os.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -10,7 +10,7 @@ use crate::path::{self, Path, PathBuf};\n use crate::slice;\n use crate::str;\n use crate::sys::cvt;\n-use crate::sys_common::mutex::{Mutex, MutexGuard};\n+use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n use libc::{self, c_char /*,c_void */, c_int};\n /*use sys::fd; this one is probably important */\n use crate::vec;\n@@ -212,10 +212,9 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> MutexGuard<'static> {\n-    // We never call `ENV_LOCK.init()`, so it is UB to attempt to\n-    // acquire this mutex reentrantly!\n-    static ENV_LOCK: Mutex = Mutex::new();\n+pub unsafe fn env_lock() -> StaticMutexGuard<'static> {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n     ENV_LOCK.lock()\n }\n "}, {"sha": "90d5d3a78987fe6b289745fbc3490ab77af36a00", "filename": "library/std/src/sys_common/at_exit_imp.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -4,17 +4,16 @@\n \n use crate::mem;\n use crate::ptr;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n type Queue = Vec<Box<dyn FnOnce()>>;\n \n // NB these are specifically not types from `std::sync` as they currently rely\n // on poisoning and this module needs to operate at a lower level than requiring\n // the thread infrastructure to be in place (useful on the borders of\n // initialization/destruction).\n-// We never call `LOCK.init()`, so it is UB to attempt to\n-// acquire this mutex reentrantly!\n-static LOCK: Mutex = Mutex::new();\n+// It is UB to attempt to acquire this mutex reentrantly!\n+static LOCK: StaticMutex = StaticMutex::new();\n static mut QUEUE: *mut Queue = ptr::null_mut();\n \n const DONE: *mut Queue = 1_usize as *mut _;"}, {"sha": "a48d301f8127bbc18731de82b6eafddf2e91fd9d", "filename": "library/std/src/sys_common/condvar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -1,5 +1,5 @@\n use crate::sys::condvar as imp;\n-use crate::sys_common::mutex::{self, Mutex};\n+use crate::sys_common::mutex::MovableMutex;\n use crate::time::Duration;\n \n /// An OS-based condition variable.\n@@ -46,8 +46,8 @@ impl Condvar {\n     /// Behavior is also undefined if more than one mutex is used concurrently\n     /// on this condition variable.\n     #[inline]\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.0.wait(mutex::raw(mutex))\n+    pub unsafe fn wait(&self, mutex: &MovableMutex) {\n+        self.0.wait(mutex.raw())\n     }\n \n     /// Waits for a signal on the specified mutex with a timeout duration\n@@ -57,8 +57,8 @@ impl Condvar {\n     /// Behavior is also undefined if more than one mutex is used concurrently\n     /// on this condition variable.\n     #[inline]\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        self.0.wait_timeout(mutex::raw(mutex), dur)\n+    pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n+        self.0.wait_timeout(mutex.raw(), dur)\n     }\n \n     /// Deallocates all resources associated with this condition variable."}, {"sha": "93ec7d89bc5c7e26152f34d5c316f26217354f83", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 66, "deletions": 61, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -1,101 +1,106 @@\n use crate::sys::mutex as imp;\n \n-/// An OS-based mutual exclusion lock.\n+/// An OS-based mutual exclusion lock, meant for use in static variables.\n+///\n+/// This mutex has a const constructor ([`StaticMutex::new`]), does not\n+/// implement `Drop` to cleanup resources, and causes UB when moved or used\n+/// reentrantly.\n+///\n+/// This mutex does not implement poisoning.\n ///\n-/// This is the thinnest cross-platform wrapper around OS mutexes. All usage of\n-/// this mutex is unsafe and it is recommended to instead use the safe wrapper\n-/// at the top level of the crate instead of this type.\n-pub struct Mutex(imp::Mutex);\n+/// This is a wrapper around `imp::Mutex` that does *not* call `init()` and\n+/// `destroy()`.\n+pub struct StaticMutex(imp::Mutex);\n \n-unsafe impl Sync for Mutex {}\n+unsafe impl Sync for StaticMutex {}\n \n-impl Mutex {\n+impl StaticMutex {\n     /// Creates a new mutex for use.\n     ///\n     /// Behavior is undefined if the mutex is moved after it is\n     /// first used with any of the functions below.\n-    /// Also, until `init` is called, behavior is undefined if this\n-    /// mutex is ever used reentrantly, i.e., `raw_lock` or `try_lock`\n-    /// are called by the thread currently holding the lock.\n+    /// Also, the behavior is undefined if this mutex is ever used reentrantly,\n+    /// i.e., `lock` is called by the thread currently holding the lock.\n     #[rustc_const_stable(feature = \"const_sys_mutex_new\", since = \"1.0.0\")]\n-    pub const fn new() -> Mutex {\n-        Mutex(imp::Mutex::new())\n+    pub const fn new() -> Self {\n+        Self(imp::Mutex::new())\n     }\n \n-    /// Prepare the mutex for use.\n+    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n+    /// will be unlocked.\n     ///\n-    /// This should be called once the mutex is at a stable memory address.\n-    /// If called, this must be the very first thing that happens to the mutex.\n-    /// Calling it in parallel with or after any operation (including another\n-    /// `init()`) is undefined behavior.\n+    /// It is undefined behaviour to call this function while locked, or if the\n+    /// mutex has been moved since the last time this was called.\n     #[inline]\n-    pub unsafe fn init(&mut self) {\n-        self.0.init()\n+    pub unsafe fn lock(&self) -> StaticMutexGuard<'_> {\n+        self.0.lock();\n+        StaticMutexGuard(&self.0)\n     }\n+}\n \n-    /// Locks the mutex blocking the current thread until it is available.\n-    ///\n-    /// Behavior is undefined if the mutex has been moved between this and any\n-    /// previous function call.\n+#[must_use]\n+pub struct StaticMutexGuard<'a>(&'a imp::Mutex);\n+\n+impl Drop for StaticMutexGuard<'_> {\n     #[inline]\n-    pub unsafe fn raw_lock(&self) {\n-        self.0.lock()\n+    fn drop(&mut self) {\n+        unsafe {\n+            self.0.unlock();\n+        }\n     }\n+}\n \n-    /// Calls raw_lock() and then returns an RAII guard to guarantee the mutex\n-    /// will be unlocked.\n+/// An OS-based mutual exclusion lock.\n+///\n+/// This mutex does *not* have a const constructor, cleans up its resources in\n+/// its `Drop` implementation, may safely be moved (when not borrowed), and\n+/// does not cause UB when used reentrantly.\n+///\n+/// This mutex does not implement poisoning.\n+///\n+/// This is a wrapper around `Box<imp::Mutex>`, to allow the object to be moved\n+/// without moving the raw mutex.\n+pub struct MovableMutex(Box<imp::Mutex>);\n+\n+unsafe impl Sync for MovableMutex {}\n+\n+impl MovableMutex {\n+    /// Creates a new mutex.\n+    pub fn new() -> Self {\n+        let mut mutex = box imp::Mutex::new();\n+        unsafe { mutex.init() };\n+        Self(mutex)\n+    }\n+\n+    pub(crate) fn raw(&self) -> &imp::Mutex {\n+        &self.0\n+    }\n+\n+    /// Locks the mutex blocking the current thread until it is available.\n     #[inline]\n-    pub unsafe fn lock(&self) -> MutexGuard<'_> {\n-        self.raw_lock();\n-        MutexGuard(&self.0)\n+    pub fn raw_lock(&self) {\n+        unsafe { self.0.lock() }\n     }\n \n     /// Attempts to lock the mutex without blocking, returning whether it was\n     /// successfully acquired or not.\n-    ///\n-    /// Behavior is undefined if the mutex has been moved between this and any\n-    /// previous function call.\n     #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        self.0.try_lock()\n+    pub fn try_lock(&self) -> bool {\n+        unsafe { self.0.try_lock() }\n     }\n \n     /// Unlocks the mutex.\n     ///\n     /// Behavior is undefined if the current thread does not actually hold the\n     /// mutex.\n-    ///\n-    /// Consider switching from the pair of raw_lock() and raw_unlock() to\n-    /// lock() whenever possible.\n     #[inline]\n     pub unsafe fn raw_unlock(&self) {\n         self.0.unlock()\n     }\n-\n-    /// Deallocates all resources associated with this mutex.\n-    ///\n-    /// Behavior is undefined if there are current or will be future users of\n-    /// this mutex.\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.0.destroy()\n-    }\n }\n \n-// not meant to be exported to the outside world, just the containing module\n-pub fn raw(mutex: &Mutex) -> &imp::Mutex {\n-    &mutex.0\n-}\n-\n-#[must_use]\n-/// A simple RAII utility for the above Mutex without the poisoning semantics.\n-pub struct MutexGuard<'a>(&'a imp::Mutex);\n-\n-impl Drop for MutexGuard<'_> {\n-    #[inline]\n+impl Drop for MovableMutex {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.0.unlock();\n-        }\n+        unsafe { self.0.destroy() };\n     }\n }"}, {"sha": "dbcb7b36265f5941c929b6eb2be8df3c823dacc1", "filename": "library/std/src/sys_common/thread_local_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_local_key.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -53,7 +53,7 @@ mod tests;\n \n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n use crate::sys::thread_local_key as imp;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n \n /// A type for TLS keys that are statically allocated.\n ///\n@@ -157,7 +157,7 @@ impl StaticKey {\n         if imp::requires_synchronized_create() {\n             // We never call `INIT_LOCK.init()`, so it is UB to attempt to\n             // acquire this mutex reentrantly!\n-            static INIT_LOCK: Mutex = Mutex::new();\n+            static INIT_LOCK: StaticMutex = StaticMutex::new();\n             let _guard = INIT_LOCK.lock();\n             let mut key = self.key.load(Ordering::SeqCst);\n             if key == 0 {"}, {"sha": "85a79642f5d91f0b5d5437e92d53ec5ded59bf1c", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -1034,9 +1034,8 @@ pub struct ThreadId(NonZeroU64);\n impl ThreadId {\n     // Generate a new unique thread ID.\n     fn new() -> ThreadId {\n-        // We never call `GUARD.init()`, so it is UB to attempt to\n-        // acquire this mutex reentrantly!\n-        static GUARD: mutex::Mutex = mutex::Mutex::new();\n+        // It is UB to attempt to acquire this mutex reentrantly!\n+        static GUARD: mutex::StaticMutex = mutex::StaticMutex::new();\n         static mut COUNTER: u64 = 1;\n \n         unsafe {"}, {"sha": "e7df38411478d804809c08099af839d170552006", "filename": "library/std/src/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f6336b4a187b03312b978703496ea0ee9020ec9/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=6f6336b4a187b03312b978703496ea0ee9020ec9", "patch": "@@ -20,7 +20,7 @@ use crate::error::Error;\n use crate::fmt;\n use crate::ops::{Add, AddAssign, Sub, SubAssign};\n use crate::sys::time;\n-use crate::sys_common::mutex::Mutex;\n+use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::FromInner;\n \n #[stable(feature = \"time\", since = \"1.3.0\")]\n@@ -243,7 +243,7 @@ impl Instant {\n             return Instant(os_now);\n         }\n \n-        static LOCK: Mutex = Mutex::new();\n+        static LOCK: StaticMutex = StaticMutex::new();\n         static mut LAST_NOW: time::Instant = time::Instant::zero();\n         unsafe {\n             let _lock = LOCK.lock();"}]}