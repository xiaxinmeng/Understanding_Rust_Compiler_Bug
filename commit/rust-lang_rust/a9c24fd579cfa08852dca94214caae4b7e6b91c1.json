{"sha": "a9c24fd579cfa08852dca94214caae4b7e6b91c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YzI0ZmQ1NzljZmEwODg1MmRjYTk0MjE0Y2FhZTRiN2U2YjkxYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-06T08:09:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-06T08:09:59Z"}, "message": "Auto merge of #43488 - Florob:repeat-opt, r=arielb1\n\nOptimize initialization of arrays using repeat expressions\n\nThis PR was inspired by [this thread](https://www.reddit.com/r/rust/comments/6o8ok9/understanding_rust_performances_a_newbie_question/) on Reddit.\nIt tries to bring array initialization in the same ballpark as `Vec::from_elem()` for unoptimized builds.\nFor optimized builds this should relieve LLVM of having to figure out the construct we generate is in fact a `memset()`.\n\nTo that end this emits `llvm.memset()` when:\n* the array is of integer type and all elements are zero (`Vec::from_elem()` also explicitly optimizes for this case)\n* the array elements are byte sized\n\nIf the array is zero-sized initialization is omitted entirely.", "tree": {"sha": "32126d8fc5afedad4033af072b1df6d5f0e3ae3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32126d8fc5afedad4033af072b1df6d5f0e3ae3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9c24fd579cfa08852dca94214caae4b7e6b91c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9c24fd579cfa08852dca94214caae4b7e6b91c1", "html_url": "https://github.com/rust-lang/rust/commit/a9c24fd579cfa08852dca94214caae4b7e6b91c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9c24fd579cfa08852dca94214caae4b7e6b91c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dd1df35f87beca7b1768b3e8fc3569dd8f9009e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1df35f87beca7b1768b3e8fc3569dd8f9009e5", "html_url": "https://github.com/rust-lang/rust/commit/dd1df35f87beca7b1768b3e8fc3569dd8f9009e5"}, {"sha": "11d6312abd614fca3970902f137225e0437d0a09", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d6312abd614fca3970902f137225e0437d0a09", "html_url": "https://github.com/rust-lang/rust/commit/11d6312abd614fca3970902f137225e0437d0a09"}], "stats": {"total": 112, "additions": 108, "deletions": 4}, "files": [{"sha": "0cc499577bb7caaa5c98ac97ecb029866e214654", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=a9c24fd579cfa08852dca94214caae4b7e6b91c1", "patch": "@@ -366,7 +366,7 @@ pub fn const_to_uint(v: ValueRef) -> u64 {\n     }\n }\n \n-fn is_const_integral(v: ValueRef) -> bool {\n+pub fn is_const_integral(v: ValueRef) -> bool {\n     unsafe {\n         !llvm::LLVMIsAConstantInt(v).is_null()\n     }"}, {"sha": "a23e1a0684bf4c27770058325dde9b9f132a0e77", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=a9c24fd579cfa08852dca94214caae4b7e6b91c1", "patch": "@@ -20,7 +20,7 @@ use base;\n use builder::Builder;\n use callee;\n use common::{self, val_ty, C_bool, C_null, C_uint};\n-use common::{C_integral};\n+use common::{C_integral, C_i32};\n use adt;\n use machine;\n use monomorphize;\n@@ -93,12 +93,42 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n+                let dest_ty = dest.ty.to_ty(bcx.tcx());\n+\n+                // No need to inizialize memory of a zero-sized slice\n+                if common::type_is_zero_size(bcx.ccx, dest_ty) {\n+                    return bcx;\n+                }\n+\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n+                let align = dest.alignment.to_align();\n+\n+                if let OperandValue::Immediate(v) = tr_elem.val {\n+                    // Use llvm.memset.p0i8.* to initialize all zero arrays\n+                    if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n+                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                        let align = C_i32(bcx.ccx, align as i32);\n+                        let ty = type_of::type_of(bcx.ccx, dest_ty);\n+                        let size = machine::llsize_of(bcx.ccx, ty);\n+                        let fill = C_integral(Type::i8(bcx.ccx), 0, false);\n+                        base::call_memset(&bcx, base, fill, size, align, false);\n+                        return bcx;\n+                    }\n+\n+                    // Use llvm.memset.p0i8.* to initialize byte arrays\n+                    if common::val_ty(v) == Type::i8(bcx.ccx) {\n+                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                        let align = C_i32(bcx.ccx, align as i32);\n+                        base::call_memset(&bcx, base, v, size, align, false);\n+                        return bcx;\n+                    }\n+                }\n+\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot, loop_bb| {\n-                    self.store_operand(bcx, llslot, dest.alignment.to_align(), tr_elem);\n+                    self.store_operand(bcx, llslot, align, tr_elem);\n                     bcx.br(loop_bb);\n                 })\n             }"}, {"sha": "de4d217c73534308e2c449089786c927b45338db", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=a9c24fd579cfa08852dca94214caae4b7e6b91c1", "patch": "@@ -30,8 +30,8 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     };\n \n     let body_bcx = bcx.build_sibling_block(\"slice_loop_body\");\n-    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n     let header_bcx = bcx.build_sibling_block(\"slice_loop_header\");\n+    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n \n     let start = if zst {\n         C_uint(bcx.ccx, 0usize)"}, {"sha": "569d937c812cbe67f8056f32d1b64a7961be1d5b", "filename": "src/test/codegen/slice-init.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Ftest%2Fcodegen%2Fslice-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9c24fd579cfa08852dca94214caae4b7e6b91c1/src%2Ftest%2Fcodegen%2Fslice-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-init.rs?ref=a9c24fd579cfa08852dca94214caae4b7e6b91c1", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @zero_sized_elem\n+#[no_mangle]\n+pub fn zero_sized_elem() {\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: call void @llvm.memset.p0i8\n+    let x = [(); 4];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @zero_len_array\n+#[no_mangle]\n+pub fn zero_len_array() {\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: call void @llvm.memset.p0i8\n+    let x = [4; 0];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @byte_array\n+#[no_mangle]\n+pub fn byte_array() {\n+    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 7, i[[WIDTH]] 4\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    let x = [7u8; 4];\n+    drop(&x);\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Copy, Clone)]\n+enum Init {\n+    Loop,\n+    Memset,\n+}\n+\n+// CHECK-LABEL: @byte_enum_array\n+#[no_mangle]\n+pub fn byte_enum_array() {\n+    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 {{.*}}, i[[WIDTH]] 4\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    let x = [Init::Memset; 4];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @zeroed_integer_array\n+#[no_mangle]\n+pub fn zeroed_integer_array() {\n+    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 0, i[[WIDTH]] 16\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    let x = [0u32; 4];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @nonzero_integer_array\n+#[no_mangle]\n+pub fn nonzero_integer_array() {\n+    // CHECK: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: call void @llvm.memset.p0i8\n+    let x = [0x1a_2b_3c_4d_u32; 4];\n+    drop(&x);\n+}"}]}