{"sha": "24bb4d1e758423dd10b517628401c1b2c2437715", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YmI0ZDFlNzU4NDIzZGQxMGI1MTc2Mjg0MDFjMWIyYzI0Mzc3MTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-11T18:17:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-11T18:17:14Z"}, "message": "Auto merge of #45333 - alkis:master, r=bluss\n\nImprove SliceExt::binary_search performance\n\nImprove the performance of binary_search by reducing the number of unpredictable conditional branches in the loop. In addition improve the benchmarks to test performance in l1, l2 and l3 caches on sorted arrays with or without dups.\n\nBefore:\n\n```\ntest slice::binary_search_l1                               ... bench:          48 ns/iter (+/- 1)\ntest slice::binary_search_l2                               ... bench:          63 ns/iter (+/- 0)\ntest slice::binary_search_l3                               ... bench:         152 ns/iter (+/- 12)\ntest slice::binary_search_l1_with_dups                     ... bench:          36 ns/iter (+/- 0)\ntest slice::binary_search_l2_with_dups                     ... bench:          64 ns/iter (+/- 1)\ntest slice::binary_search_l3_with_dups                     ... bench:         153 ns/iter (+/- 6)\n```\n\nAfter:\n\n```\ntest slice::binary_search_l1                               ... bench:          15 ns/iter (+/- 0)\ntest slice::binary_search_l2                               ... bench:          23 ns/iter (+/- 0)\ntest slice::binary_search_l3                               ... bench:         100 ns/iter (+/- 17)\ntest slice::binary_search_l1_with_dups                     ... bench:          15 ns/iter (+/- 0)\ntest slice::binary_search_l2_with_dups                     ... bench:          23 ns/iter (+/- 0)\ntest slice::binary_search_l3_with_dups                     ... bench:          98 ns/iter (+/- 14)\n```", "tree": {"sha": "c57359618031055afe26f3d2578210e0f8a76bdc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c57359618031055afe26f3d2578210e0f8a76bdc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24bb4d1e758423dd10b517628401c1b2c2437715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24bb4d1e758423dd10b517628401c1b2c2437715", "html_url": "https://github.com/rust-lang/rust/commit/24bb4d1e758423dd10b517628401c1b2c2437715", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24bb4d1e758423dd10b517628401c1b2c2437715/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b22679366a6faab9f3790697f8be0a1dce38c285", "url": "https://api.github.com/repos/rust-lang/rust/commits/b22679366a6faab9f3790697f8be0a1dce38c285", "html_url": "https://github.com/rust-lang/rust/commit/b22679366a6faab9f3790697f8be0a1dce38c285"}, {"sha": "2ca111b6b91c578c8a2b8e610471e582b6cf2c6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca111b6b91c578c8a2b8e610471e582b6cf2c6b", "html_url": "https://github.com/rust-lang/rust/commit/2ca111b6b91c578c8a2b8e610471e582b6cf2c6b"}], "stats": {"total": 166, "additions": 136, "deletions": 30}, "files": [{"sha": "201064e823b1e6ecee851126f444c408fed73063", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=24bb4d1e758423dd10b517628401c1b2c2437715", "patch": "@@ -20,6 +20,6 @@ extern crate test;\n mod any;\n mod hash;\n mod iter;\n-mod mem;\n mod num;\n mod ops;\n+mod slice;"}, {"sha": "b2fc74544f1df22abc7c84a4842be1c202a4aac1", "filename": "src/libcore/benches/slice.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fslice.rs?ref=24bb4d1e758423dd10b517628401c1b2c2437715", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use test::black_box;\n+use test::Bencher;\n+\n+enum Cache {\n+    L1,\n+    L2,\n+    L3,\n+}\n+\n+fn binary_search<F>(b: &mut Bencher, cache: Cache, mapper: F)\n+    where F: Fn(usize) -> usize\n+{\n+    let size = match cache {\n+        Cache::L1 => 1000, // 8kb\n+        Cache::L2 => 10_000, // 80kb\n+        Cache::L3 => 1_000_000, // 8Mb\n+    };\n+    let v = (0..size).map(&mapper).collect::<Vec<_>>();\n+    let mut r = 0usize;\n+    b.iter(move || {\n+        // LCG constants from https://en.wikipedia.org/wiki/Numerical_Recipes.\n+        r = r.wrapping_mul(1664525).wrapping_add(1013904223);\n+        // Lookup the whole range to get 50% hits and 50% misses.\n+        let i = mapper(r % size);\n+        black_box(v.binary_search(&i).is_ok());\n+    })\n+}\n+\n+#[bench]\n+fn binary_search_l1(b: &mut Bencher) {\n+    binary_search(b, Cache::L1, |i| i * 2);\n+}\n+\n+#[bench]\n+fn binary_search_l2(b: &mut Bencher) {\n+    binary_search(b, Cache::L2, |i| i * 2);\n+}\n+\n+#[bench]\n+fn binary_search_l3(b: &mut Bencher) {\n+    binary_search(b, Cache::L3, |i| i * 2);\n+}\n+\n+#[bench]\n+fn binary_search_l1_with_dups(b: &mut Bencher) {\n+    binary_search(b, Cache::L1, |i| i / 16 * 16);\n+}\n+\n+#[bench]\n+fn binary_search_l2_with_dups(b: &mut Bencher) {\n+    binary_search(b, Cache::L2, |i| i / 16 * 16);\n+}\n+\n+#[bench]\n+fn binary_search_l3_with_dups(b: &mut Bencher) {\n+    binary_search(b, Cache::L3, |i| i / 16 * 16);\n+}"}, {"sha": "74182f303c945c31909805100602a4ffb13f4887", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=24bb4d1e758423dd10b517628401c1b2c2437715", "patch": "@@ -391,23 +391,25 @@ impl<T> SliceExt for [T] {\n     fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a T) -> Ordering\n     {\n-        let mut base = 0usize;\n-        let mut s = self;\n-\n-        loop {\n-            let (head, tail) = s.split_at(s.len() >> 1);\n-            if tail.is_empty() {\n-                return Err(base)\n-            }\n-            match f(&tail[0]) {\n-                Less => {\n-                    base += head.len() + 1;\n-                    s = &tail[1..];\n-                }\n-                Greater => s = head,\n-                Equal => return Ok(base + head.len()),\n-            }\n+        let s = self;\n+        let mut size = s.len();\n+        if size == 0 {\n+            return Err(0);\n         }\n+        let mut base = 0usize;\n+        while size > 1 {\n+            let half = size / 2;\n+            let mid = base + half;\n+            // mid is always in [0, size).\n+            // mid >= 0: by definition\n+            // mid < size: mid = size / 2 + size / 4 + size / 8 ...\n+            let cmp = f(unsafe { s.get_unchecked(mid) });\n+            base = if cmp == Greater { base } else { mid };\n+            size -= half;\n+        }\n+        // base is always in [0, size) because base <= mid.\n+        let cmp = f(unsafe { s.get_unchecked(base) });\n+        if cmp == Equal { Ok(base) } else { Err(base + (cmp == Less) as usize) }\n     }\n \n     #[inline]"}, {"sha": "7835080db1d45ad2754fb36bac9b0d3f93d2cc36", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24bb4d1e758423dd10b517628401c1b2c2437715/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=24bb4d1e758423dd10b517628401c1b2c2437715", "patch": "@@ -15,22 +15,59 @@ use rand::{Rng, XorShiftRng};\n \n #[test]\n fn test_binary_search() {\n+    let b: [i32; 0] = [];\n+    assert_eq!(b.binary_search(&5), Err(0));\n+\n+    let b = [4];\n+    assert_eq!(b.binary_search(&3), Err(0));\n+    assert_eq!(b.binary_search(&4), Ok(0));\n+    assert_eq!(b.binary_search(&5), Err(1));\n+\n     let b = [1, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n-    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n-    let b = [1, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n-    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n-    let b = [1, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(4));\n-    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(4));\n+    assert_eq!(b.binary_search(&5), Err(3));\n+    assert_eq!(b.binary_search(&6), Ok(3));\n+    assert_eq!(b.binary_search(&7), Err(4));\n+    assert_eq!(b.binary_search(&8), Ok(4));\n+\n+    let b = [1, 2, 4, 5, 6, 8];\n+    assert_eq!(b.binary_search(&9), Err(6));\n+\n     let b = [1, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(5));\n+    assert_eq!(b.binary_search(&6), Ok(3));\n+    assert_eq!(b.binary_search(&5), Err(3));\n+    assert_eq!(b.binary_search(&8), Ok(5));\n+\n     let b = [1, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(5));\n-    assert!(b.binary_search_by(|v| v.cmp(&0)) == Err(0));\n-    let b = [1, 2, 4, 5, 6, 8];\n-    assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n+    assert_eq!(b.binary_search(&7), Err(5));\n+    assert_eq!(b.binary_search(&0), Err(0));\n+\n+    let b = [1, 3, 3, 3, 7];\n+    assert_eq!(b.binary_search(&0), Err(0));\n+    assert_eq!(b.binary_search(&1), Ok(0));\n+    assert_eq!(b.binary_search(&2), Err(1));\n+    assert!(match b.binary_search(&3) { Ok(1...3) => true, _ => false });\n+    assert!(match b.binary_search(&3) { Ok(1...3) => true, _ => false });\n+    assert_eq!(b.binary_search(&4), Err(4));\n+    assert_eq!(b.binary_search(&5), Err(4));\n+    assert_eq!(b.binary_search(&6), Err(4));\n+    assert_eq!(b.binary_search(&7), Ok(4));\n+    assert_eq!(b.binary_search(&8), Err(5));\n+}\n+\n+#[test]\n+// Test implementation specific behavior when finding equivalent elements.\n+// It is ok to break this test but when you do a crater run is highly advisable.\n+fn test_binary_search_implementation_details() {\n+    let b = [1, 1, 2, 2, 3, 3, 3];\n+    assert_eq!(b.binary_search(&1), Ok(1));\n+    assert_eq!(b.binary_search(&2), Ok(3));\n+    assert_eq!(b.binary_search(&3), Ok(6));\n+    let b = [1, 1, 1, 1, 1, 3, 3, 3, 3];\n+    assert_eq!(b.binary_search(&1), Ok(4));\n+    assert_eq!(b.binary_search(&3), Ok(8));\n+    let b = [1, 1, 1, 1, 3, 3, 3, 3, 3];\n+    assert_eq!(b.binary_search(&1), Ok(3));\n+    assert_eq!(b.binary_search(&3), Ok(8));\n }\n \n #[test]"}]}