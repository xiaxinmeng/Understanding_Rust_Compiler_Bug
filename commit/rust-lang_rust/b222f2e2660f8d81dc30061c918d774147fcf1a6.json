{"sha": "b222f2e2660f8d81dc30061c918d774147fcf1a6", "node_id": "C_kwDOAAsO6NoAKGIyMjJmMmUyNjYwZjhkODFkYzMwMDYxYzkxOGQ3NzQxNDdmY2YxYTY", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-25T18:53:03Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2023-01-25T20:18:35Z"}, "message": "Move `note_and_explain_type_err` from `rustc_middle` to `rustc_infer`\n\nThis way we can properly deal with the types.", "tree": {"sha": "82d9adf98c4c1941dcefebe2f31909e7801fcca6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82d9adf98c4c1941dcefebe2f31909e7801fcca6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b222f2e2660f8d81dc30061c918d774147fcf1a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b222f2e2660f8d81dc30061c918d774147fcf1a6", "html_url": "https://github.com/rust-lang/rust/commit/b222f2e2660f8d81dc30061c918d774147fcf1a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b222f2e2660f8d81dc30061c918d774147fcf1a6/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "027c8507b4265dcf285b0b503e2a49214b929f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/027c8507b4265dcf285b0b503e2a49214b929f7b", "html_url": "https://github.com/rust-lang/rust/commit/027c8507b4265dcf285b0b503e2a49214b929f7b"}], "stats": {"total": 1291, "additions": 657, "deletions": 634}, "files": [{"sha": "faba723acda8d018f38d34c89506fd54cef9bd0e", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b222f2e2660f8d81dc30061c918d774147fcf1a6", "patch": "@@ -79,6 +79,7 @@ use std::path::PathBuf;\n use std::{cmp, fmt, iter};\n \n mod note;\n+mod note_and_explain;\n mod suggest;\n \n pub(crate) mod need_type_info;\n@@ -1846,7 +1847,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n \n         self.check_and_note_conflicting_crates(diag, terr);\n-        self.tcx.note_and_explain_type_err(diag, terr, cause, span, cause.body_id.to_def_id());\n+\n+        self.note_and_explain_type_err(diag, terr, cause, span, cause.body_id.to_def_id());\n+\n \n         if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values\n             && let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind()"}, {"sha": "6e781a041e0134d61157a632faf464c4ed136a63", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "added", "additions": 647, "deletions": 0, "changes": 647, "blob_url": "https://github.com/rust-lang/rust/blob/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=b222f2e2660f8d81dc30061c918d774147fcf1a6", "patch": "@@ -0,0 +1,647 @@\n+use super::TypeErrCtxt;\n+use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n+use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n+use rustc_hir::{self as hir, def::DefKind};\n+use rustc_middle::traits::ObligationCauseCode;\n+use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::print::Printer;\n+use rustc_middle::{\n+    traits::ObligationCause,\n+    ty::{self, error::TypeError, print::FmtPrinter, suggest_constraining_type_param, Ty},\n+};\n+use rustc_span::{def_id::DefId, sym, BytePos, Span, Symbol};\n+\n+impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n+    pub fn note_and_explain_type_err(\n+        &self,\n+        diag: &mut Diagnostic,\n+        err: TypeError<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        sp: Span,\n+        body_owner_def_id: DefId,\n+    ) {\n+        use ty::error::TypeError::*;\n+        debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n+\n+        let tcx = self.tcx;\n+\n+        match err {\n+            ArgumentSorts(values, _) | Sorts(values) => {\n+                match (values.expected.kind(), values.found.kind()) {\n+                    (ty::Closure(..), ty::Closure(..)) => {\n+                        diag.note(\"no two closures, even if identical, have the same type\");\n+                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n+                    }\n+                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n+                        // Issue #63167\n+                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    }\n+                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n+                        if let Ok(\n+                            // Issue #53280\n+                            snippet,\n+                        ) = tcx.sess.source_map().span_to_snippet(sp) =>\n+                    {\n+                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n+                            diag.span_suggestion(\n+                                sp,\n+                                \"use a float literal\",\n+                                format!(\"{}.0\", snippet),\n+                                MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                    (ty::Param(expected), ty::Param(found)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let e_span = tcx.def_span(generics.type_param(expected, tcx).def_id);\n+                        if !sp.contains(e_span) {\n+                            diag.span_label(e_span, \"expected type parameter\");\n+                        }\n+                        let f_span = tcx.def_span(generics.type_param(found, tcx).def_id);\n+                        if !sp.contains(f_span) {\n+                            diag.span_label(f_span, \"found type parameter\");\n+                        }\n+                        diag.note(\n+                            \"a type parameter was expected, but a different one was found; \\\n+                             you might be missing a type parameter or trait bound\",\n+                        );\n+                        diag.note(\n+                            \"for more information, visit \\\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n+                        );\n+                    }\n+                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                        diag.note(\"an associated type was expected, but a different one was found\");\n+                    }\n+                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n+                        if tcx.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n+                    {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        let hir = tcx.hir();\n+                        let mut note = true;\n+                        if let Some(generics) = generics\n+                            .type_param(p, tcx)\n+                            .def_id\n+                            .as_local()\n+                            .map(|id| hir.local_def_id_to_hir_id(id))\n+                            .and_then(|id| tcx.hir().find_parent(id))\n+                            .as_ref()\n+                            .and_then(|node| node.generics())\n+                        {\n+                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n+                            // FIXME: extract this logic for use in other diagnostics.\n+                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(tcx);\n+                            let path =\n+                                tcx.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n+                            let item_name = tcx.item_name(proj.def_id);\n+                            let item_args = self.format_generic_args(assoc_substs);\n+\n+                            let path = if path.ends_with('>') {\n+                                format!(\n+                                    \"{}, {}{} = {}>\",\n+                                    &path[..path.len() - 1],\n+                                    item_name,\n+                                    item_args,\n+                                    p\n+                                )\n+                            } else {\n+                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n+                            };\n+                            note = !suggest_constraining_type_param(\n+                                tcx,\n+                                generics,\n+                                diag,\n+                                &format!(\"{}\", proj.self_ty()),\n+                                &path,\n+                                None,\n+                            );\n+                        }\n+                        if note {\n+                            diag.note(\"you might be missing a type parameter or trait bound\");\n+                        }\n+                    }\n+                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n+                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        diag.help(\"type parameters must be constrained to match other types\");\n+                        if tcx.sess.teach(&diag.get_code().unwrap()) {\n+                            diag.help(\n+                                \"given a type parameter `T` and a method `foo`:\n+```\n+trait Trait<T> { fn foo(&tcx) -> T; }\n+```\n+the only ways to implement method `foo` are:\n+- constrain `T` with an explicit type:\n+```\n+impl Trait<String> for X {\n+    fn foo(&tcx) -> String { String::new() }\n+}\n+```\n+- add a trait bound to `T` and call a method on that trait that returns `Self`:\n+```\n+impl<T: std::default::Default> Trait<T> for X {\n+    fn foo(&tcx) -> T { <T as std::default::Default>::default() }\n+}\n+```\n+- change `foo` to return an argument of type `T`:\n+```\n+impl<T> Trait<T> for X {\n+    fn foo(&tcx, x: T) -> T { x }\n+}\n+```\",\n+                            );\n+                        }\n+                        diag.note(\n+                            \"for more information, visit \\\n+                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                             #traits-as-parameters\",\n+                        );\n+                    }\n+                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                        diag.help(&format!(\n+                            \"every closure has a distinct type and so could not always match the \\\n+                             caller-chosen type of parameter `{}`\",\n+                            p\n+                        ));\n+                    }\n+                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n+                        let generics = tcx.generics_of(body_owner_def_id);\n+                        let p_span = tcx.def_span(generics.type_param(p, tcx).def_id);\n+                        if !sp.contains(p_span) {\n+                            diag.span_label(p_span, \"this type parameter\");\n+                        }\n+                    }\n+                    (ty::Alias(ty::Projection, proj_ty), _) if tcx.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                        self.expected_projection(\n+                            diag,\n+                            proj_ty,\n+                            values,\n+                            body_owner_def_id,\n+                            cause.code(),\n+                        );\n+                    }\n+                    (_, ty::Alias(ty::Projection, proj_ty)) if tcx.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n+                        let msg = format!(\n+                            \"consider constraining the associated type `{}` to `{}`\",\n+                            values.found, values.expected,\n+                        );\n+                        if !(self.suggest_constraining_opaque_associated_type(\n+                            diag,\n+                            &msg,\n+                            proj_ty,\n+                            values.expected,\n+                        ) || self.suggest_constraint(\n+                            diag,\n+                            &msg,\n+                            body_owner_def_id,\n+                            proj_ty,\n+                            values.expected,\n+                        )) {\n+                            diag.help(&msg);\n+                            diag.note(\n+                                \"for more information, visit \\\n+                                https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n+                            );\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                debug!(\n+                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n+                    values.expected,\n+                    values.expected.kind(),\n+                    values.found,\n+                    values.found.kind(),\n+                );\n+            }\n+            CyclicTy(ty) => {\n+                // Watch out for various cases of cyclic types and try to explain.\n+                if ty.is_closure() || ty.is_generator() {\n+                    diag.note(\n+                        \"closures cannot capture themselves or take themselves as argument;\\n\\\n+                         this error may be the result of a recent compiler bug-fix,\\n\\\n+                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n+                         for more information\",\n+                    );\n+                }\n+            }\n+            TargetFeatureCast(def_id) => {\n+                let target_spans = tcx.get_attrs(def_id, sym::target_feature).map(|attr| attr.span);\n+                diag.note(\n+                    \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n+                );\n+                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn suggest_constraint(\n+        &self,\n+        diag: &mut Diagnostic,\n+        msg: &str,\n+        body_owner_def_id: DefId,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(tcx);\n+        if let Some(item) = tcx.hir().get_if_local(body_owner_def_id) {\n+            if let Some(hir_generics) = item.generics() {\n+                // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n+                // This will also work for `impl Trait`.\n+                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n+                    let generics = tcx.generics_of(body_owner_def_id);\n+                    generics.type_param(param_ty, tcx).def_id\n+                } else {\n+                    return false;\n+                };\n+                let Some(def_id) = def_id.as_local() else {\n+                    return false;\n+                };\n+\n+                // First look in the `where` clause, as this might be\n+                // `fn foo<T>(x: T) where T: Trait`.\n+                for pred in hir_generics.bounds_for_param(def_id) {\n+                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n+                        diag,\n+                        &trait_ref,\n+                        pred.bounds,\n+                        &assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n+                        false,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n+\n+    /// An associated type was expected and a different type was found.\n+    ///\n+    /// We perform a few different checks to see what we can suggest:\n+    ///\n+    ///  - In the current item, look for associated functions that return the expected type and\n+    ///    suggest calling them. (Not a structured suggestion.)\n+    ///  - If any of the item's generic bounds can be constrained, we suggest constraining the\n+    ///    associated type to the found type.\n+    ///  - If the associated type has a default type and was expected inside of a `trait`, we\n+    ///    mention that this is disallowed.\n+    ///  - If all other things fail, and the error is not because of a mismatch between the `trait`\n+    ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n+    ///    fn that returns the type.\n+    fn expected_projection(\n+        &self,\n+        diag: &mut Diagnostic,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        values: ExpectedFound<Ty<'tcx>>,\n+        body_owner_def_id: DefId,\n+        cause_code: &ObligationCauseCode<'_>,\n+    ) {\n+        let tcx = self.tcx;\n+\n+        let msg = format!(\n+            \"consider constraining the associated type `{}` to `{}`\",\n+            values.expected, values.found\n+        );\n+        let body_owner = tcx.hir().get_if_local(body_owner_def_id);\n+        let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n+\n+        // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n+        let callable_scope = matches!(\n+            body_owner,\n+            Some(\n+                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n+                    | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n+                    | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n+            )\n+        );\n+        let impl_comparison =\n+            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        if !callable_scope || impl_comparison {\n+            // We do not want to suggest calling functions when the reason of the\n+            // type error is a comparison of an `impl` with its `trait` or when the\n+            // scope is outside of a `Body`.\n+        } else {\n+            // If we find a suitable associated function that returns the expected type, we don't\n+            // want the more general suggestion later in this method about \"consider constraining\n+            // the associated type or calling a method that returns the associated type\".\n+            let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n+                diag,\n+                assoc.container_id(tcx),\n+                current_method_ident,\n+                proj_ty.def_id,\n+                values.expected,\n+            );\n+            // Possibly suggest constraining the associated type to conform to the\n+            // found type.\n+            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n+                || point_at_assoc_fn\n+            {\n+                return;\n+            }\n+        }\n+\n+        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n+\n+        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n+            return;\n+        }\n+\n+        if !impl_comparison {\n+            // Generic suggestion when we can't be more specific.\n+            if callable_scope {\n+                diag.help(&format!(\n+                    \"{} or calling a method that returns `{}`\",\n+                    msg, values.expected\n+                ));\n+            } else {\n+                diag.help(&msg);\n+            }\n+            diag.note(\n+                \"for more information, visit \\\n+                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n+            );\n+        }\n+        if tcx.sess.teach(&diag.get_code().unwrap()) {\n+            diag.help(\n+                \"given an associated type `T` and a method `foo`:\n+```\n+trait Trait {\n+type T;\n+fn foo(&tcx) -> Self::T;\n+}\n+```\n+the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n+```\n+impl Trait for X {\n+type T = String;\n+fn foo(&tcx) -> Self::T { String::new() }\n+}\n+```\",\n+            );\n+        }\n+    }\n+\n+    /// When the expected `impl Trait` is not defined in the current item, it will come from\n+    /// a return type. This can occur when dealing with `TryStream` (#71035).\n+    fn suggest_constraining_opaque_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        msg: &str,\n+        proj_ty: &ty::AliasTy<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let assoc = tcx.associated_item(proj_ty.def_id);\n+        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n+            let opaque_local_def_id = def_id.as_local();\n+            let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n+                match &tcx.hir().expect_item(opaque_local_def_id).kind {\n+                    hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n+                    _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n+                }\n+            } else {\n+                return false;\n+            };\n+\n+            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(tcx);\n+\n+            self.constrain_generic_bound_associated_type_structured_suggestion(\n+                diag,\n+                &trait_ref,\n+                opaque_hir_ty.bounds,\n+                assoc,\n+                assoc_substs,\n+                ty,\n+                msg,\n+                true,\n+            )\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_methods_that_satisfy_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        assoc_container_id: DefId,\n+        current_method_ident: Option<Symbol>,\n+        proj_ty_item_def_id: DefId,\n+        expected: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let items = tcx.associated_items(assoc_container_id);\n+        // Find all the methods in the trait that could be called to construct the\n+        // expected associated type.\n+        // FIXME: consider suggesting the use of associated `const`s.\n+        let methods: Vec<(Span, String)> = items\n+            .in_definition_order()\n+            .filter(|item| {\n+                ty::AssocKind::Fn == item.kind && Some(item.name) != current_method_ident\n+            })\n+            .filter_map(|item| {\n+                let method = tcx.fn_sig(item.def_id);\n+                match *method.output().skip_binder().kind() {\n+                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n+                        if item_def_id == proj_ty_item_def_id =>\n+                    {\n+                        Some((\n+                            tcx.def_span(item.def_id),\n+                            format!(\"consider calling `{}`\", tcx.def_path_str(item.def_id)),\n+                        ))\n+                    }\n+                    _ => None,\n+                }\n+            })\n+            .collect();\n+        if !methods.is_empty() {\n+            // Use a single `help:` to show all the methods in the trait that can\n+            // be used to construct the expected associated type.\n+            let mut span: MultiSpan =\n+                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n+            let msg = format!(\n+                \"{some} method{s} {are} available that return{r} `{ty}`\",\n+                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n+                s = pluralize!(methods.len()),\n+                are = pluralize!(\"is\", methods.len()),\n+                r = if methods.len() == 1 { \"s\" } else { \"\" },\n+                ty = expected\n+            );\n+            for (sp, label) in methods.into_iter() {\n+                span.push_span_label(sp, label);\n+            }\n+            diag.span_help(span, &msg);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    fn point_at_associated_type(\n+        &self,\n+        diag: &mut Diagnostic,\n+        body_owner_def_id: DefId,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        let Some(hir_id) = body_owner_def_id.as_local() else {\n+            return false;\n+        };\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(hir_id);\n+        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n+        // `expected` and point at it.\n+        let parent_id = tcx.hir().get_parent_item(hir_id);\n+        let item = tcx.hir().find_by_def_id(parent_id.def_id);\n+        debug!(\"expected_projection parent item {:?}\", item);\n+        match item {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n+                // FIXME: account for `#![feature(specialization)]`\n+                for item in &items[..] {\n+                    match item.kind {\n+                        hir::AssocItemKind::Type => {\n+                            // FIXME: account for returning some type in a trait fn impl that has\n+                            // an assoc type as a return type (#72076).\n+                            if let hir::Defaultness::Default { has_value: true } =\n+                                tcx.impl_defaultness(item.id.owner_id)\n+                            {\n+                                if tcx.type_of(item.id.owner_id) == found {\n+                                    diag.span_label(\n+                                        item.span,\n+                                        \"associated type defaults can't be assumed inside the \\\n+                                            trait defining them\",\n+                                    );\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+            Some(hir::Node::Item(hir::Item {\n+                kind: hir::ItemKind::Impl(hir::Impl { items, .. }),\n+                ..\n+            })) => {\n+                for item in &items[..] {\n+                    if let hir::AssocItemKind::Type = item.kind {\n+                        if tcx.type_of(item.id.owner_id) == found {\n+                            diag.span_label(item.span, \"expected this associated type\");\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+\n+    /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n+    /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n+    ///\n+    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n+    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n+    /// trait bound as the one we're looking for. This can help in cases where the associated\n+    /// type is defined on a supertrait of the one present in the bounds.\n+    fn constrain_generic_bound_associated_type_structured_suggestion(\n+        &self,\n+        diag: &mut Diagnostic,\n+        trait_ref: &ty::TraitRef<'tcx>,\n+        bounds: hir::GenericBounds<'_>,\n+        assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n+        ty: Ty<'tcx>,\n+        msg: &str,\n+        is_bound_surely_present: bool,\n+    ) -> bool {\n+        // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n+\n+        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n+            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n+            _ => None,\n+        });\n+\n+        let matching_trait_bounds = trait_bounds\n+            .clone()\n+            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n+            .collect::<Vec<_>>();\n+\n+        let span = match &matching_trait_bounds[..] {\n+            &[ptr] => ptr.span,\n+            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n+                &[ptr] => ptr.span,\n+                _ => return false,\n+            },\n+            _ => return false,\n+        };\n+\n+        self.constrain_associated_type_structured_suggestion(\n+            diag,\n+            span,\n+            assoc,\n+            assoc_substs,\n+            ty,\n+            msg,\n+        )\n+    }\n+\n+    /// Given a span corresponding to a bound, provide a structured suggestion to set an\n+    /// associated type to a given type `ty`.\n+    fn constrain_associated_type_structured_suggestion(\n+        &self,\n+        diag: &mut Diagnostic,\n+        span: Span,\n+        assoc: &ty::AssocItem,\n+        assoc_substs: &[ty::GenericArg<'tcx>],\n+        ty: Ty<'tcx>,\n+        msg: &str,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+\n+        if let Ok(has_params) =\n+            tcx.sess.source_map().span_to_snippet(span).map(|snippet| snippet.ends_with('>'))\n+        {\n+            let (span, sugg) = if has_params {\n+                let pos = span.hi() - BytePos(1);\n+                let span = Span::new(pos, pos, span.ctxt(), span.parent());\n+                (span, format!(\", {} = {}\", assoc.ident(tcx), ty))\n+            } else {\n+                let item_args = self.format_generic_args(assoc_substs);\n+                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(tcx), item_args, ty))\n+            };\n+            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n+            return true;\n+        }\n+        false\n+    }\n+\n+    pub fn format_generic_args(&self, args: &[ty::GenericArg<'tcx>]) -> String {\n+        FmtPrinter::new(self.tcx, hir::def::Namespace::TypeNS)\n+            .path_generic_args(Ok, args)\n+            .expect(\"could not write to `String`.\")\n+            .into_buffer()\n+    }\n+}"}, {"sha": "47091ca1d69a719ce275a439356088f890294d10", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=b222f2e2660f8d81dc30061c918d774147fcf1a6", "patch": "@@ -130,7 +130,7 @@ impl std::fmt::Display for AssocKind {\n /// done only on items with the same name.\n #[derive(Debug, Clone, PartialEq, HashStable)]\n pub struct AssocItems<'tcx> {\n-    pub(super) items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n+    items: SortedIndexMultiMap<u32, Symbol, &'tcx ty::AssocItem>,\n }\n \n impl<'tcx> AssocItems<'tcx> {"}, {"sha": "c8a700c4e280d6eccd2d19ba8face8a430a6d31f", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 5, "deletions": 632, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b222f2e2660f8d81dc30061c918d774147fcf1a6/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=b222f2e2660f8d81dc30061c918d774147fcf1a6", "patch": "@@ -1,24 +1,18 @@\n-use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty::diagnostics::suggest_constraining_type_param;\n-use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, Printer};\n+use crate::ty::print::{with_forced_trimmed_paths, FmtPrinter, PrettyPrinter};\n use crate::ty::{self, BoundRegionKind, Region, Ty, TyCtxt};\n-use rustc_errors::Applicability::{MachineApplicable, MaybeIncorrect};\n-use rustc_errors::{pluralize, Diagnostic, MultiSpan};\n+use rustc_errors::pluralize;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::symbol::Symbol;\n use rustc_target::spec::abi;\n-\n use std::borrow::Cow;\n use std::collections::hash_map::DefaultHasher;\n use std::fmt;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+use std::hash::Hasher;\n use std::path::PathBuf;\n \n-use super::print::PrettyPrinter;\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq, TypeFoldable, TypeVisitable, Lift)]\n pub struct ExpectedFound<T> {\n     pub expected: T,\n@@ -391,620 +385,6 @@ impl<'tcx> Ty<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(\n-        self,\n-        diag: &mut Diagnostic,\n-        err: TypeError<'tcx>,\n-        cause: &ObligationCause<'tcx>,\n-        sp: Span,\n-        body_owner_def_id: DefId,\n-    ) {\n-        use self::TypeError::*;\n-        debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n-        match err {\n-            ArgumentSorts(values, _) | Sorts(values) => {\n-                match (values.expected.kind(), values.found.kind()) {\n-                    (ty::Closure(..), ty::Closure(..)) => {\n-                        diag.note(\"no two closures, even if identical, have the same type\");\n-                        diag.help(\"consider boxing your closure and/or using it as a trait object\");\n-                    }\n-                    (ty::Alias(ty::Opaque, ..), ty::Alias(ty::Opaque, ..)) => {\n-                        // Issue #63167\n-                        diag.note(\"distinct uses of `impl Trait` result in different opaque types\");\n-                    }\n-                    (ty::Float(_), ty::Infer(ty::IntVar(_)))\n-                        if let Ok(\n-                            // Issue #53280\n-                            snippet,\n-                        ) = self.sess.source_map().span_to_snippet(sp) =>\n-                    {\n-                        if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n-                            diag.span_suggestion(\n-                                sp,\n-                                \"use a float literal\",\n-                                format!(\"{}.0\", snippet),\n-                                MachineApplicable,\n-                            );\n-                        }\n-                    }\n-                    (ty::Param(expected), ty::Param(found)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let e_span = self.def_span(generics.type_param(expected, self).def_id);\n-                        if !sp.contains(e_span) {\n-                            diag.span_label(e_span, \"expected type parameter\");\n-                        }\n-                        let f_span = self.def_span(generics.type_param(found, self).def_id);\n-                        if !sp.contains(f_span) {\n-                            diag.span_label(f_span, \"found type parameter\");\n-                        }\n-                        diag.note(\n-                            \"a type parameter was expected, but a different one was found; \\\n-                             you might be missing a type parameter or trait bound\",\n-                        );\n-                        diag.note(\n-                            \"for more information, visit \\\n-                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                             #traits-as-parameters\",\n-                        );\n-                    }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n-                        diag.note(\"an associated type was expected, but a different one was found\");\n-                    }\n-                    (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n-                        if self.def_kind(proj.def_id) != DefKind::ImplTraitPlaceholder =>\n-                    {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        let hir = self.hir();\n-                        let mut note = true;\n-                        if let Some(generics) = generics\n-                            .type_param(p, self)\n-                            .def_id\n-                            .as_local()\n-                            .map(|id| hir.local_def_id_to_hir_id(id))\n-                            .and_then(|id| self.hir().find_parent(id))\n-                            .as_ref()\n-                            .and_then(|node| node.generics())\n-                        {\n-                            // Synthesize the associated type restriction `Add<Output = Expected>`.\n-                            // FIXME: extract this logic for use in other diagnostics.\n-                            let (trait_ref, assoc_substs) = proj.trait_ref_and_own_substs(self);\n-                            let path =\n-                                self.def_path_str_with_substs(trait_ref.def_id, trait_ref.substs);\n-                            let item_name = self.item_name(proj.def_id);\n-                            let item_args = self.format_generic_args(assoc_substs);\n-\n-                            let path = if path.ends_with('>') {\n-                                format!(\n-                                    \"{}, {}{} = {}>\",\n-                                    &path[..path.len() - 1],\n-                                    item_name,\n-                                    item_args,\n-                                    p\n-                                )\n-                            } else {\n-                                format!(\"{}<{}{} = {}>\", path, item_name, item_args, p)\n-                            };\n-                            note = !suggest_constraining_type_param(\n-                                self,\n-                                generics,\n-                                diag,\n-                                &format!(\"{}\", proj.self_ty()),\n-                                &path,\n-                                None,\n-                            );\n-                        }\n-                        if note {\n-                            diag.note(\"you might be missing a type parameter or trait bound\");\n-                        }\n-                    }\n-                    (ty::Param(p), ty::Dynamic(..) | ty::Alias(ty::Opaque, ..))\n-                    | (ty::Dynamic(..) | ty::Alias(ty::Opaque, ..), ty::Param(p)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        diag.help(\"type parameters must be constrained to match other types\");\n-                        if self.sess.teach(&diag.get_code().unwrap()) {\n-                            diag.help(\n-                                \"given a type parameter `T` and a method `foo`:\n-```\n-trait Trait<T> { fn foo(&self) -> T; }\n-```\n-the only ways to implement method `foo` are:\n-- constrain `T` with an explicit type:\n-```\n-impl Trait<String> for X {\n-    fn foo(&self) -> String { String::new() }\n-}\n-```\n-- add a trait bound to `T` and call a method on that trait that returns `Self`:\n-```\n-impl<T: std::default::Default> Trait<T> for X {\n-    fn foo(&self) -> T { <T as std::default::Default>::default() }\n-}\n-```\n-- change `foo` to return an argument of type `T`:\n-```\n-impl<T> Trait<T> for X {\n-    fn foo(&self, x: T) -> T { x }\n-}\n-```\",\n-                            );\n-                        }\n-                        diag.note(\n-                            \"for more information, visit \\\n-                             https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-                             #traits-as-parameters\",\n-                        );\n-                    }\n-                    (ty::Param(p), ty::Closure(..) | ty::Generator(..)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                        diag.help(&format!(\n-                            \"every closure has a distinct type and so could not always match the \\\n-                             caller-chosen type of parameter `{}`\",\n-                            p\n-                        ));\n-                    }\n-                    (ty::Param(p), _) | (_, ty::Param(p)) => {\n-                        let generics = self.generics_of(body_owner_def_id);\n-                        let p_span = self.def_span(generics.type_param(p, self).def_id);\n-                        if !sp.contains(p_span) {\n-                            diag.span_label(p_span, \"this type parameter\");\n-                        }\n-                    }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n-                        self.expected_projection(\n-                            diag,\n-                            proj_ty,\n-                            values,\n-                            body_owner_def_id,\n-                            cause.code(),\n-                        );\n-                    }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if self.def_kind(proj_ty.def_id) != DefKind::ImplTraitPlaceholder => {\n-                        let msg = format!(\n-                            \"consider constraining the associated type `{}` to `{}`\",\n-                            values.found, values.expected,\n-                        );\n-                        if !(self.suggest_constraining_opaque_associated_type(\n-                            diag,\n-                            &msg,\n-                            proj_ty,\n-                            values.expected,\n-                        ) || self.suggest_constraint(\n-                            diag,\n-                            &msg,\n-                            body_owner_def_id,\n-                            proj_ty,\n-                            values.expected,\n-                        )) {\n-                            diag.help(&msg);\n-                            diag.note(\n-                                \"for more information, visit \\\n-                                https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n-                            );\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-                debug!(\n-                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n-                    values.expected,\n-                    values.expected.kind(),\n-                    values.found,\n-                    values.found.kind(),\n-                );\n-            }\n-            CyclicTy(ty) => {\n-                // Watch out for various cases of cyclic types and try to explain.\n-                if ty.is_closure() || ty.is_generator() {\n-                    diag.note(\n-                        \"closures cannot capture themselves or take themselves as argument;\\n\\\n-                         this error may be the result of a recent compiler bug-fix,\\n\\\n-                         see issue #46062 <https://github.com/rust-lang/rust/issues/46062>\\n\\\n-                         for more information\",\n-                    );\n-                }\n-            }\n-            TargetFeatureCast(def_id) => {\n-                let target_spans =\n-                    self.get_attrs(def_id, sym::target_feature).map(|attr| attr.span);\n-                diag.note(\n-                    \"functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\"\n-                );\n-                diag.span_labels(target_spans, \"`#[target_feature]` added here\");\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn suggest_constraint(\n-        self,\n-        diag: &mut Diagnostic,\n-        msg: &str,\n-        body_owner_def_id: DefId,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n-        if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n-            if let Some(hir_generics) = item.generics() {\n-                // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n-                // This will also work for `impl Trait`.\n-                let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n-                    let generics = self.generics_of(body_owner_def_id);\n-                    generics.type_param(param_ty, self).def_id\n-                } else {\n-                    return false;\n-                };\n-                let Some(def_id) = def_id.as_local() else {\n-                    return false;\n-                };\n-\n-                // First look in the `where` clause, as this might be\n-                // `fn foo<T>(x: T) where T: Trait`.\n-                for pred in hir_generics.bounds_for_param(def_id) {\n-                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                        diag,\n-                        &trait_ref,\n-                        pred.bounds,\n-                        &assoc,\n-                        assoc_substs,\n-                        ty,\n-                        msg,\n-                        false,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-            }\n-        }\n-        false\n-    }\n-\n-    /// An associated type was expected and a different type was found.\n-    ///\n-    /// We perform a few different checks to see what we can suggest:\n-    ///\n-    ///  - In the current item, look for associated functions that return the expected type and\n-    ///    suggest calling them. (Not a structured suggestion.)\n-    ///  - If any of the item's generic bounds can be constrained, we suggest constraining the\n-    ///    associated type to the found type.\n-    ///  - If the associated type has a default type and was expected inside of a `trait`, we\n-    ///    mention that this is disallowed.\n-    ///  - If all other things fail, and the error is not because of a mismatch between the `trait`\n-    ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n-    ///    fn that returns the type.\n-    fn expected_projection(\n-        self,\n-        diag: &mut Diagnostic,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        values: ExpectedFound<Ty<'tcx>>,\n-        body_owner_def_id: DefId,\n-        cause_code: &ObligationCauseCode<'_>,\n-    ) {\n-        let msg = format!(\n-            \"consider constraining the associated type `{}` to `{}`\",\n-            values.expected, values.found\n-        );\n-        let body_owner = self.hir().get_if_local(body_owner_def_id);\n-        let current_method_ident = body_owner.and_then(|n| n.ident()).map(|i| i.name);\n-\n-        // We don't want to suggest calling an assoc fn in a scope where that isn't feasible.\n-        let callable_scope = matches!(\n-            body_owner,\n-            Some(\n-                hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                    | hir::Node::TraitItem(hir::TraitItem { kind: hir::TraitItemKind::Fn(..), .. })\n-                    | hir::Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }),\n-            )\n-        );\n-        let impl_comparison =\n-            matches!(cause_code, ObligationCauseCode::CompareImplItemObligation { .. });\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        if !callable_scope || impl_comparison {\n-            // We do not want to suggest calling functions when the reason of the\n-            // type error is a comparison of an `impl` with its `trait` or when the\n-            // scope is outside of a `Body`.\n-        } else {\n-            // If we find a suitable associated function that returns the expected type, we don't\n-            // want the more general suggestion later in this method about \"consider constraining\n-            // the associated type or calling a method that returns the associated type\".\n-            let point_at_assoc_fn = self.point_at_methods_that_satisfy_associated_type(\n-                diag,\n-                assoc.container_id(self),\n-                current_method_ident,\n-                proj_ty.def_id,\n-                values.expected,\n-            );\n-            // Possibly suggest constraining the associated type to conform to the\n-            // found type.\n-            if self.suggest_constraint(diag, &msg, body_owner_def_id, proj_ty, values.found)\n-                || point_at_assoc_fn\n-            {\n-                return;\n-            }\n-        }\n-\n-        self.suggest_constraining_opaque_associated_type(diag, &msg, proj_ty, values.found);\n-\n-        if self.point_at_associated_type(diag, body_owner_def_id, values.found) {\n-            return;\n-        }\n-\n-        if !impl_comparison {\n-            // Generic suggestion when we can't be more specific.\n-            if callable_scope {\n-                diag.help(&format!(\n-                    \"{} or calling a method that returns `{}`\",\n-                    msg, values.expected\n-                ));\n-            } else {\n-                diag.help(&msg);\n-            }\n-            diag.note(\n-                \"for more information, visit \\\n-                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\",\n-            );\n-        }\n-        if self.sess.teach(&diag.get_code().unwrap()) {\n-            diag.help(\n-                \"given an associated type `T` and a method `foo`:\n-```\n-trait Trait {\n-type T;\n-fn foo(&self) -> Self::T;\n-}\n-```\n-the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n-```\n-impl Trait for X {\n-type T = String;\n-fn foo(&self) -> Self::T { String::new() }\n-}\n-```\",\n-            );\n-        }\n-    }\n-\n-    /// When the expected `impl Trait` is not defined in the current item, it will come from\n-    /// a return type. This can occur when dealing with `TryStream` (#71035).\n-    fn suggest_constraining_opaque_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        msg: &str,\n-        proj_ty: &ty::AliasTy<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n-        let assoc = self.associated_item(proj_ty.def_id);\n-        if let ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }) = *proj_ty.self_ty().kind() {\n-            let opaque_local_def_id = def_id.as_local();\n-            let opaque_hir_ty = if let Some(opaque_local_def_id) = opaque_local_def_id {\n-                match &self.hir().expect_item(opaque_local_def_id).kind {\n-                    hir::ItemKind::OpaqueTy(opaque_hir_ty) => opaque_hir_ty,\n-                    _ => bug!(\"The HirId comes from a `ty::Opaque`\"),\n-                }\n-            } else {\n-                return false;\n-            };\n-\n-            let (trait_ref, assoc_substs) = proj_ty.trait_ref_and_own_substs(self);\n-\n-            self.constrain_generic_bound_associated_type_structured_suggestion(\n-                diag,\n-                &trait_ref,\n-                opaque_hir_ty.bounds,\n-                assoc,\n-                assoc_substs,\n-                ty,\n-                msg,\n-                true,\n-            )\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn point_at_methods_that_satisfy_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        assoc_container_id: DefId,\n-        current_method_ident: Option<Symbol>,\n-        proj_ty_item_def_id: DefId,\n-        expected: Ty<'tcx>,\n-    ) -> bool {\n-        let items = self.associated_items(assoc_container_id);\n-        // Find all the methods in the trait that could be called to construct the\n-        // expected associated type.\n-        // FIXME: consider suggesting the use of associated `const`s.\n-        let methods: Vec<(Span, String)> = items\n-            .items\n-            .iter()\n-            .filter(|(name, item)| {\n-                ty::AssocKind::Fn == item.kind && Some(**name) != current_method_ident\n-            })\n-            .filter_map(|(_, item)| {\n-                let method = self.fn_sig(item.def_id);\n-                match *method.output().skip_binder().kind() {\n-                    ty::Alias(ty::Projection, ty::AliasTy { def_id: item_def_id, .. })\n-                        if item_def_id == proj_ty_item_def_id =>\n-                    {\n-                        Some((\n-                            self.def_span(item.def_id),\n-                            format!(\"consider calling `{}`\", self.def_path_str(item.def_id)),\n-                        ))\n-                    }\n-                    _ => None,\n-                }\n-            })\n-            .collect();\n-        if !methods.is_empty() {\n-            // Use a single `help:` to show all the methods in the trait that can\n-            // be used to construct the expected associated type.\n-            let mut span: MultiSpan =\n-                methods.iter().map(|(sp, _)| *sp).collect::<Vec<Span>>().into();\n-            let msg = format!(\n-                \"{some} method{s} {are} available that return{r} `{ty}`\",\n-                some = if methods.len() == 1 { \"a\" } else { \"some\" },\n-                s = pluralize!(methods.len()),\n-                are = pluralize!(\"is\", methods.len()),\n-                r = if methods.len() == 1 { \"s\" } else { \"\" },\n-                ty = expected\n-            );\n-            for (sp, label) in methods.into_iter() {\n-                span.push_span_label(sp, label);\n-            }\n-            diag.span_help(span, &msg);\n-            return true;\n-        }\n-        false\n-    }\n-\n-    fn point_at_associated_type(\n-        self,\n-        diag: &mut Diagnostic,\n-        body_owner_def_id: DefId,\n-        found: Ty<'tcx>,\n-    ) -> bool {\n-        let Some(hir_id) = body_owner_def_id.as_local() else {\n-            return false;\n-        };\n-        let hir_id = self.hir().local_def_id_to_hir_id(hir_id);\n-        // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n-        // `expected` and point at it.\n-        let parent_id = self.hir().get_parent_item(hir_id);\n-        let item = self.hir().find_by_def_id(parent_id.def_id);\n-        debug!(\"expected_projection parent item {:?}\", item);\n-        match item {\n-            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Trait(.., items), .. })) => {\n-                // FIXME: account for `#![feature(specialization)]`\n-                for item in &items[..] {\n-                    match item.kind {\n-                        hir::AssocItemKind::Type => {\n-                            // FIXME: account for returning some type in a trait fn impl that has\n-                            // an assoc type as a return type (#72076).\n-                            if let hir::Defaultness::Default { has_value: true } =\n-                                self.impl_defaultness(item.id.owner_id)\n-                            {\n-                                if self.type_of(item.id.owner_id) == found {\n-                                    diag.span_label(\n-                                        item.span,\n-                                        \"associated type defaults can't be assumed inside the \\\n-                                            trait defining them\",\n-                                    );\n-                                    return true;\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-            Some(hir::Node::Item(hir::Item {\n-                kind: hir::ItemKind::Impl(hir::Impl { items, .. }),\n-                ..\n-            })) => {\n-                for item in &items[..] {\n-                    if let hir::AssocItemKind::Type = item.kind {\n-                        if self.type_of(item.id.owner_id) == found {\n-                            diag.span_label(item.span, \"expected this associated type\");\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-        false\n-    }\n-\n-    /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n-    /// requirement, provide a structured suggestion to constrain it to a given type `ty`.\n-    ///\n-    /// `is_bound_surely_present` indicates whether we know the bound we're looking for is\n-    /// inside `bounds`. If that's the case then we can consider `bounds` containing only one\n-    /// trait bound as the one we're looking for. This can help in cases where the associated\n-    /// type is defined on a supertrait of the one present in the bounds.\n-    fn constrain_generic_bound_associated_type_structured_suggestion(\n-        self,\n-        diag: &mut Diagnostic,\n-        trait_ref: &ty::TraitRef<'tcx>,\n-        bounds: hir::GenericBounds<'_>,\n-        assoc: &ty::AssocItem,\n-        assoc_substs: &[ty::GenericArg<'tcx>],\n-        ty: Ty<'tcx>,\n-        msg: &str,\n-        is_bound_surely_present: bool,\n-    ) -> bool {\n-        // FIXME: we would want to call `resolve_vars_if_possible` on `ty` before suggesting.\n-\n-        let trait_bounds = bounds.iter().filter_map(|bound| match bound {\n-            hir::GenericBound::Trait(ptr, hir::TraitBoundModifier::None) => Some(ptr),\n-            _ => None,\n-        });\n-\n-        let matching_trait_bounds = trait_bounds\n-            .clone()\n-            .filter(|ptr| ptr.trait_ref.trait_def_id() == Some(trait_ref.def_id))\n-            .collect::<Vec<_>>();\n-\n-        let span = match &matching_trait_bounds[..] {\n-            &[ptr] => ptr.span,\n-            &[] if is_bound_surely_present => match &trait_bounds.collect::<Vec<_>>()[..] {\n-                &[ptr] => ptr.span,\n-                _ => return false,\n-            },\n-            _ => return false,\n-        };\n-\n-        self.constrain_associated_type_structured_suggestion(\n-            diag,\n-            span,\n-            assoc,\n-            assoc_substs,\n-            ty,\n-            msg,\n-        )\n-    }\n-\n-    /// Given a span corresponding to a bound, provide a structured suggestion to set an\n-    /// associated type to a given type `ty`.\n-    fn constrain_associated_type_structured_suggestion(\n-        self,\n-        diag: &mut Diagnostic,\n-        span: Span,\n-        assoc: &ty::AssocItem,\n-        assoc_substs: &[ty::GenericArg<'tcx>],\n-        ty: Ty<'tcx>,\n-        msg: &str,\n-    ) -> bool {\n-        if let Ok(has_params) =\n-            self.sess.source_map().span_to_snippet(span).map(|snippet| snippet.ends_with('>'))\n-        {\n-            let (span, sugg) = if has_params {\n-                let pos = span.hi() - BytePos(1);\n-                let span = Span::new(pos, pos, span.ctxt(), span.parent());\n-                (span, format!(\", {} = {}\", assoc.ident(self), ty))\n-            } else {\n-                let item_args = self.format_generic_args(assoc_substs);\n-                (span.shrink_to_hi(), format!(\"<{}{} = {}>\", assoc.ident(self), item_args, ty))\n-            };\n-            diag.span_suggestion_verbose(span, msg, sugg, MaybeIncorrect);\n-            return true;\n-        }\n-        false\n-    }\n-\n     pub fn short_ty_string(self, ty: Ty<'tcx>) -> (String, Option<PathBuf>) {\n         let width = self.sess.diagnostic_width();\n         let length_limit = width.saturating_sub(30);\n@@ -1047,11 +427,4 @@ fn foo(&self) -> Self::T { String::new() }\n             Err(_) => (regular, None),\n         }\n     }\n-\n-    fn format_generic_args(self, args: &[ty::GenericArg<'tcx>]) -> String {\n-        FmtPrinter::new(self, hir::def::Namespace::TypeNS)\n-            .path_generic_args(Ok, args)\n-            .expect(\"could not write to `String`.\")\n-            .into_buffer()\n-    }\n }"}]}