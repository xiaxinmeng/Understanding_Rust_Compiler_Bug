{"sha": "f2aabb713820c3f4077fec4d0488d48ba493f965", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYWFiYjcxMzgyMGMzZjQwNzdmZWM0ZDA0ODhkNDhiYTQ5M2Y5NjU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-20T13:36:34Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-09-20T15:28:03Z"}, "message": "Rollup merge of #54346 - eddyb:constant-horror, r=nikomatsakis\n\nrustc: future-proof error reporting for polymorphic constants in types.\n\nCurrently, we have 3 categories of positions where a constant can be used (`const` and associated `const` can be considered \"aliases\" for an expression):\n* runtime - if the function is polymorphic, we could even just warn and emit a panic\n* `static` - always monomorphic, so we can error at definition site\n* type-system - **must** *enforce* evaluation success where it was written\n\nThat last one is the tricky one, because we can't easily turn *the presence* a type with an erroring const into a runtime panic, and we'd have to do post-monomorphization errors (which we'd rather avoid).\n\n<hr/>\n\nThe solution we came up with, as part of the plans for const generics, is to require successful evaluation wherever a constant shows up in a type (currently in array lengths, and values for const parameters in the future), *through* the WF system, which means that in certain situations (e.g. function signatures) we can assume evaluation *will* succeed, and require it of users (e.g. callers) instead (we've been doing this for lifetime bounds, for a long time now, and it's pretty ergonomic).\n\nSo once we do sth about #43408, this example *should* work, by propagating the responsability, to callers of `foo::<X>`, of proving `std::mem::size_of::<X>()` succeeds (and those callers can do the same).\n```rust\npub fn foo<T>(_: [u8; std::mem::size_of::<T>()]) {}\n```\nBut this one *shouldn't*, as there is nothing in the signature/bounds to indicate it:\n```rust\npub fn bar<T>() {\n    let _: [u8; std::mem::size_of::<T>()];\n}\n```\n\n<hr/>\n\nI've come across some bit of code in the compiler that ignores const-evaluation errors *even when* they come from a constant in a type, and I've added an ICE *only when* there are no other reported errors (e.g. it's fine to ignore evaluation errors if the constant doesn't even type-check).\n\nr? @nikomatsakis cc @oli-obk @RalfJung @Centril", "tree": {"sha": "ccb174c1f997af5046002edcd817d26f58376865", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccb174c1f997af5046002edcd817d26f58376865"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2aabb713820c3f4077fec4d0488d48ba493f965", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlujvIMACgkQ/vbIBR0O\nATwdEBAAlXCCwAVtEMfd0L5kLnsbSMsIg7PirWUdHoxdh38hpZsZssh3S+Tsg9O1\ntbAXBOyfhT+kyGt/DPA/L+tsfkBrYn1s1MhWBtLB6v8iH7Gl3oIZTU3ASJg9ROZs\nZzeqDQ4GVto5wYrSGlwanJB/gxacX5hNL25w8xHhv5i8GZ0FLUjdld85qCIKtO6w\nLtb099Mys+gRT4wcnTlS0DcJ97pcam/UBYz/dTSxMXcmE4IlYpi2Opxqux/TfU4x\n8tWNY21QM3O5FluG4ydDmEsr54dXFdb4Sj0b4Vi52ZcSxB/A37tZo2/FcfTSOfHa\nLb+Bdd09lxxHqX9F01Eeq6z0TsS28C0iTXwBoagsuIWwvP44QipJ0Zv4HzDqiNz+\n3sGevsvEXvkfGAiJgT1MkCCsttVg5/gLbaaJyutqAHmR7jGQwx+oXTAH6pDnp12f\nt/S4aSODTrhOdBFVcak1mYa/bZMFMn8+TQ9yytVyOnjZ5W6DOVpLuYH4Mnjk/lK7\ntA2Cx4EwrSVePs87TkX/k0Eg0/T41kE5JVX/ubrMkgDUKY3cT9i0rhXqkwBm5BKp\nLV7oi2GmVQZe9AMhM8zVwv+SWs89uVSLn64wh2S9NF2KZQZSkTjt8+a4RovD5CWV\nPJ3haMkzZ02nzdw5mPw0kEmmz6vkZz4ZxuD/yThTLNo0Ru8LV4c=\n=lkA3\n-----END PGP SIGNATURE-----", "payload": "tree ccb174c1f997af5046002edcd817d26f58376865\nparent f5b8c7fa1606cbd8bf25f448eed8c7998e30145d\nparent 046482e95e1b01a7f2ef01ffb7592db5045ad508\nauthor kennytm <kennytm@gmail.com> 1537450594 +0800\ncommitter kennytm <kennytm@gmail.com> 1537457283 +0800\n\nRollup merge of #54346 - eddyb:constant-horror, r=nikomatsakis\n\nrustc: future-proof error reporting for polymorphic constants in types.\n\nCurrently, we have 3 categories of positions where a constant can be used (`const` and associated `const` can be considered \"aliases\" for an expression):\n* runtime - if the function is polymorphic, we could even just warn and emit a panic\n* `static` - always monomorphic, so we can error at definition site\n* type-system - **must** *enforce* evaluation success where it was written\n\nThat last one is the tricky one, because we can't easily turn *the presence* a type with an erroring const into a runtime panic, and we'd have to do post-monomorphization errors (which we'd rather avoid).\n\n<hr/>\n\nThe solution we came up with, as part of the plans for const generics, is to require successful evaluation wherever a constant shows up in a type (currently in array lengths, and values for const parameters in the future), *through* the WF system, which means that in certain situations (e.g. function signatures) we can assume evaluation *will* succeed, and require it of users (e.g. callers) instead (we've been doing this for lifetime bounds, for a long time now, and it's pretty ergonomic).\n\nSo once we do sth about #43408, this example *should* work, by propagating the responsability, to callers of `foo::<X>`, of proving `std::mem::size_of::<X>()` succeeds (and those callers can do the same).\n```rust\npub fn foo<T>(_: [u8; std::mem::size_of::<T>()]) {}\n```\nBut this one *shouldn't*, as there is nothing in the signature/bounds to indicate it:\n```rust\npub fn bar<T>() {\n    let _: [u8; std::mem::size_of::<T>()];\n}\n```\n\n<hr/>\n\nI've come across some bit of code in the compiler that ignores const-evaluation errors *even when* they come from a constant in a type, and I've added an ICE *only when* there are no other reported errors (e.g. it's fine to ignore evaluation errors if the constant doesn't even type-check).\n\nr? @nikomatsakis cc @oli-obk @RalfJung @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2aabb713820c3f4077fec4d0488d48ba493f965", "html_url": "https://github.com/rust-lang/rust/commit/f2aabb713820c3f4077fec4d0488d48ba493f965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2aabb713820c3f4077fec4d0488d48ba493f965/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5b8c7fa1606cbd8bf25f448eed8c7998e30145d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b8c7fa1606cbd8bf25f448eed8c7998e30145d", "html_url": "https://github.com/rust-lang/rust/commit/f5b8c7fa1606cbd8bf25f448eed8c7998e30145d"}, {"sha": "046482e95e1b01a7f2ef01ffb7592db5045ad508", "url": "https://api.github.com/repos/rust-lang/rust/commits/046482e95e1b01a7f2ef01ffb7592db5045ad508", "html_url": "https://github.com/rust-lang/rust/commit/046482e95e1b01a7f2ef01ffb7592db5045ad508"}], "stats": {"total": 6, "additions": 5, "deletions": 1}, "files": [{"sha": "6fb5acde72c49735d7280e8e9f39c8782c9a16f7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2aabb713820c3f4077fec4d0488d48ba493f965/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2aabb713820c3f4077fec4d0488d48ba493f965/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f2aabb713820c3f4077fec4d0488d48ba493f965", "patch": "@@ -839,7 +839,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"could not evaluate constant expression\",\n                 ) {\n                     Some(err) => err,\n-                    None => return,\n+                    None => {\n+                        self.tcx.sess.delay_span_bug(span,\n+                            &format!(\"constant in type had an ignored error: {:?}\", err));\n+                        return;\n+                    }\n                 }\n             }\n "}]}