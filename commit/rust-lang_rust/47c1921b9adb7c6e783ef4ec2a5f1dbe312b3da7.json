{"sha": "47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YzE5MjFiOWFkYjdjNmU3ODNlZjRlYzJhNWYxZGJlMzEyYjNkYTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-03T18:14:36Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:27:49Z"}, "message": "move some parts of liveness to happen during type checking\n\nThis allows us to re-use the `normalize` method on `TypeCheck`, which\nis important since normalization may create fresh region\nvariables. This is not an ideal solution, though, since the current\nrepresentation of \"liveness constraints\" (a vector of (region, point)\npairs) is rather inefficient. Could do somewhat better by converting\nto indices, but it'd still be less good than the older code. Unclear\nhow important this is.", "tree": {"sha": "a376d0d7b9a106c239a5e467a3e0be06c7477a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a376d0d7b9a106c239a5e467a3e0be06c7477a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "html_url": "https://github.com/rust-lang/rust/commit/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a940b321534a1024078cce92fc69030bfd6c60d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a940b321534a1024078cce92fc69030bfd6c60d", "html_url": "https://github.com/rust-lang/rust/commit/4a940b321534a1024078cce92fc69030bfd6c60d"}], "stats": {"total": 550, "additions": 351, "deletions": 199}, "files": [{"sha": "673e85e6b61cd23c7ce27d77b6a205c45f40ecf0", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 171, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -12,41 +12,25 @@ use rustc::hir;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n use rustc::mir::visit::Visitor;\n use rustc::mir::Place::Projection;\n-use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n+use rustc::mir::{PlaceProjection, ProjectionElem};\n use rustc::mir::visit::TyContext;\n use rustc::infer::InferCtxt;\n-use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, ClosureSubsts, Ty};\n+use rustc::ty::{self, ClosureSubsts};\n use rustc::ty::subst::Substs;\n use rustc::ty::fold::TypeFoldable;\n-use rustc::util::common::ErrorReported;\n-use rustc_data_structures::fx::FxHashSet;\n-use syntax::codemap::DUMMY_SP;\n-use dataflow::{FlowAtLocation, FlowsAtLocation};\n-use dataflow::MaybeInitializedLvals;\n-use dataflow::move_paths::{HasMoveData, MoveData};\n \n-use super::LivenessResults;\n use super::ToRegionVid;\n use super::region_infer::RegionInferenceContext;\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &mut RegionInferenceContext<'tcx>,\n     mir: &Mir<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    liveness: &LivenessResults,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n-    move_data: &MoveData<'tcx>,\n ) {\n     let mut cg = ConstraintGeneration {\n         infcx,\n         regioncx,\n         mir,\n-        liveness,\n-        param_env,\n-        flow_inits,\n-        move_data,\n     };\n \n     for (bb, data) in mir.basic_blocks().iter_enumerated() {\n@@ -59,16 +43,10 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n     regioncx: &'cg mut RegionInferenceContext<'tcx>,\n     mir: &'cg Mir<'tcx>,\n-    liveness: &'cg LivenessResults,\n-    param_env: ty::ParamEnv<'tcx>,\n-    flow_inits: &'cg mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n-    move_data: &'cg MoveData<'tcx>,\n }\n \n-\n impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n     fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.add_liveness_constraints(bb);\n         self.super_basic_block_data(bb, data);\n     }\n \n@@ -130,84 +108,6 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n }\n \n impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n-    /// Liveness constraints:\n-    ///\n-    /// > If a variable V is live at point P, then all regions R in the type of V\n-    /// > must include the point P.\n-    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n-        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n-\n-        self.liveness\n-            .regular\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n-                for live_local in live_locals.iter() {\n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.add_regular_live_constraint(live_local_ty, location);\n-                }\n-            });\n-\n-        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n-        self.liveness\n-            .drop\n-            .simulate_block(self.mir, bb, |location, live_locals| {\n-                all_live_locals.push((location, live_locals.iter().collect()));\n-            });\n-        debug!(\n-            \"add_liveness_constraints: all_live_locals={:#?}\",\n-            all_live_locals\n-        );\n-\n-        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n-        self.flow_inits.reset_to_entry_of(bb);\n-        while let Some((location, live_locals)) = all_live_locals.pop() {\n-            for live_local in live_locals {\n-                debug!(\n-                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n-                    location,\n-                    live_local\n-                );\n-\n-                self.flow_inits.each_state_bit(|mpi_init| {\n-                    debug!(\n-                        \"add_liveness_constraints: location={:?} initialized={:?}\",\n-                        location,\n-                        &self.flow_inits\n-                            .operator()\n-                            .move_data()\n-                            .move_paths[mpi_init]\n-                    );\n-                });\n-\n-                let mpi = self.move_data.rev_lookup.find_local(live_local);\n-                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n-                    debug!(\n-                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n-                        self.move_data.move_paths[mpi],\n-                        self.move_data.move_paths[initialized_child]\n-                    );\n-\n-                    let live_local_ty = self.mir.local_decls[live_local].ty;\n-                    self.add_drop_live_constraint(live_local_ty, location);\n-                }\n-            }\n-\n-            if location.statement_index == terminator_index {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_terminator_effect(location);\n-            } else {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_statement_effect(location);\n-            }\n-            self.flow_inits.apply_local_effect(location);\n-        }\n-    }\n-\n     /// Some variable with type `live_ty` is \"regular live\" at\n     /// `location` -- i.e., it may be used later. This means that all\n     /// regions appearing in the type `live_ty` must be live at\n@@ -230,75 +130,6 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             });\n     }\n \n-    /// Some variable with type `live_ty` is \"drop live\" at `location`\n-    /// -- i.e., it may be dropped later. This means that *some* of\n-    /// the regions in its type must be live at `location`. The\n-    /// precise set will depend on the dropck constraints, and in\n-    /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n-        debug!(\n-            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n-            dropped_ty,\n-            location\n-        );\n-\n-        let tcx = self.infcx.tcx;\n-        let mut types = vec![(dropped_ty, 0)];\n-        let mut known = FxHashSet();\n-        while let Some((ty, depth)) = types.pop() {\n-            let span = DUMMY_SP; // FIXME\n-            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n-                Ok(result) => result,\n-                Err(ErrorReported) => {\n-                    continue;\n-                }\n-            };\n-\n-            let ty::DtorckConstraint {\n-                outlives,\n-                dtorck_types,\n-            } = result;\n-\n-            // All things in the `outlives` array may be touched by\n-            // the destructor and must be live at this point.\n-            for outlive in outlives {\n-                self.add_regular_live_constraint(outlive, location);\n-            }\n-\n-            // However, there may also be some types that\n-            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n-            // associated types and parameters). We need to normalize\n-            // associated types here and possibly recursively process.\n-            for ty in dtorck_types {\n-                let cause = ObligationCause::dummy();\n-                // We know that our original `dropped_ty` is well-formed,\n-                // so region obligations resulting from this normalization\n-                // should always hold.\n-                //\n-                // Therefore we ignore them instead of trying to match\n-                // them up with a location.\n-                let fulfillcx = traits::FulfillmentContext::new_ignoring_regions();\n-                match traits::fully_normalize_with_fulfillcx(\n-                    self.infcx, fulfillcx, cause, self.param_env, &ty\n-                ) {\n-                    Ok(ty) => match ty.sty {\n-                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                            self.add_regular_live_constraint(ty, location);\n-                        }\n-\n-                        _ => if known.insert(ty) {\n-                            types.push((ty, depth + 1));\n-                        },\n-                    },\n-\n-                    Err(errors) => {\n-                        self.infcx.report_fulfillment_errors(&errors, None);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn add_reborrow_constraint(\n         &mut self,\n         location: Location,"}, {"sha": "3329448e2b7acbf0f9eebe9257a3a25a6169ef1f", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -77,27 +77,26 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n ) {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n-    let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n+    let liveness = &LivenessResults::compute(mir);\n+    let constraint_sets = &type_check::type_check(\n+        infcx,\n+        mir_node_id,\n+        param_env,\n+        mir,\n+        &liveness,\n+        flow_inits,\n+        move_data,\n+    );\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n     let mut regioncx = RegionInferenceContext::new(var_origins, universal_regions, mir);\n     subtype_constraint_generation::generate(&mut regioncx, mir, constraint_sets);\n \n-    // Compute what is live where.\n-    let liveness = &LivenessResults::compute(mir);\n \n     // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(\n-        infcx,\n-        &mut regioncx,\n-        &mir,\n-        param_env,\n-        liveness,\n-        flow_inits,\n-        move_data,\n-    );\n+    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir);\n \n     // Solve the region constraints.\n     let closure_region_requirements = regioncx.solve(infcx, &mir, def_id);"}, {"sha": "f36392c9fcfdb7974be25ceadac52b758a6d1ced", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -425,11 +425,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// therefore add `end('a)` into the region for `'b` -- but we\n     /// have no evidence that `'b` outlives `'a`, so we want to report\n     /// an error.\n-    fn check_type_tests(\n-        &self,\n-        infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir: &Mir<'tcx>,\n-    ) {\n+    fn check_type_tests(&self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n@@ -473,13 +469,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 .iter()\n                 .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n \n-            RegionTest::Any(tests) => tests\n-                .iter()\n-                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+            RegionTest::Any(tests) => tests.iter().any(|test| {\n+                self.eval_region_test(mir, point, lower_bound, test)\n+            }),\n \n-            RegionTest::All(tests) => tests\n-                .iter()\n-                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+            RegionTest::All(tests) => tests.iter().all(|test| {\n+                self.eval_region_test(mir, point, lower_bound, test)\n+            }),\n         }\n     }\n "}, {"sha": "e41bf7cda8e6c32ea0d91bcf9bca89742ff21e89", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -0,0 +1,220 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use dataflow::{FlowAtLocation, FlowsAtLocation};\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::{HasMoveData, MoveData};\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc::mir::Local;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::util::common::ErrorReported;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::codemap::DUMMY_SP;\n+use util::liveness::LivenessResults;\n+\n+use super::TypeChecker;\n+\n+/// Combines liveness analysis with initialization analysis to\n+/// determine which variables are live at which points, both due to\n+/// ordinary uses and drops. Returns a set of (ty, location) pairs\n+/// that indicate which types must be live at which point in the CFG.\n+/// This vector is consumed by `constraint_generation`.\n+///\n+/// NB. This computation requires normalization; therefore, it must be\n+/// performed before\n+pub(super) fn generate<'gcx, 'tcx>(\n+    cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    liveness: &LivenessResults,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) {\n+    let tcx = cx.tcx();\n+    let mut generator = TypeLivenessGenerator {\n+        cx,\n+        tcx,\n+        mir,\n+        liveness,\n+        flow_inits,\n+        move_data,\n+    };\n+\n+    for bb in mir.basic_blocks().indices() {\n+        generator.add_liveness_constraints(bb);\n+    }\n+}\n+\n+struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n+where\n+    'typeck: 'gen,\n+    'flow: 'gen,\n+    'tcx: 'typeck + 'flow,\n+    'gcx: 'tcx,\n+{\n+    cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n+    tcx: TyCtxt<'typeck, 'gcx, 'tcx>,\n+    mir: &'gen Mir<'tcx>,\n+    liveness: &'gen LivenessResults,\n+    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedLvals<'flow, 'gcx, 'tcx>>,\n+    move_data: &'gen MoveData<'tcx>,\n+}\n+\n+impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n+    /// Liveness constraints:\n+    ///\n+    /// > If a variable V is live at point P, then all regions R in the type of V\n+    /// > must include the point P.\n+    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n+        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n+\n+        self.liveness\n+            .regular\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                for live_local in live_locals.iter() {\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.push_type_live_constraint(live_local_ty, location);\n+                }\n+            });\n+\n+        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+        self.liveness\n+            .drop\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                all_live_locals.push((location, live_locals.iter().collect()));\n+            });\n+        debug!(\n+            \"add_liveness_constraints: all_live_locals={:#?}\",\n+            all_live_locals\n+        );\n+\n+        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n+        self.flow_inits.reset_to_entry_of(bb);\n+        while let Some((location, live_locals)) = all_live_locals.pop() {\n+            for live_local in live_locals {\n+                debug!(\n+                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n+                    location,\n+                    live_local\n+                );\n+\n+                self.flow_inits.each_state_bit(|mpi_init| {\n+                    debug!(\n+                        \"add_liveness_constraints: location={:?} initialized={:?}\",\n+                        location,\n+                        &self.flow_inits.operator().move_data().move_paths[mpi_init]\n+                    );\n+                });\n+\n+                let mpi = self.move_data.rev_lookup.find_local(live_local);\n+                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n+                    debug!(\n+                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n+                        self.move_data.move_paths[mpi],\n+                        self.move_data.move_paths[initialized_child]\n+                    );\n+\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.add_drop_live_constraint(live_local_ty, location);\n+                }\n+            }\n+\n+            if location.statement_index == terminator_index {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_terminator_effect(location);\n+            } else {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_statement_effect(location);\n+            }\n+            self.flow_inits.apply_local_effect(location);\n+        }\n+    }\n+\n+    /// Some variable with type `live_ty` is \"regular live\" at\n+    /// `location` -- i.e., it may be used later. This means that all\n+    /// regions appearing in the type `live_ty` must be live at\n+    /// `location`.\n+    fn push_type_live_constraint<T>(&mut self, value: T, location: Location)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n+            value,\n+            location\n+        );\n+\n+        self.tcx.for_each_free_region(&value, |live_region| {\n+            self.cx\n+                .constraints\n+                .liveness_set\n+                .push((live_region, location));\n+        });\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+        debug!(\n+            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            dropped_ty,\n+            location\n+        );\n+\n+        let tcx = self.cx.infcx.tcx;\n+        let mut types = vec![(dropped_ty, 0)];\n+        let mut known = FxHashSet();\n+        while let Some((ty, depth)) = types.pop() {\n+            let span = DUMMY_SP; // FIXME\n+            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n+                Ok(result) => result,\n+                Err(ErrorReported) => {\n+                    continue;\n+                }\n+            };\n+\n+            let ty::DtorckConstraint {\n+                outlives,\n+                dtorck_types,\n+            } = result;\n+\n+            // All things in the `outlives` array may be touched by\n+            // the destructor and must be live at this point.\n+            for outlive in outlives {\n+                self.push_type_live_constraint(outlive, location);\n+            }\n+\n+            // However, there may also be some types that\n+            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n+            // associated types and parameters). We need to normalize\n+            // associated types here and possibly recursively process.\n+            for ty in dtorck_types {\n+                let ty = self.cx.normalize(&ty, location);\n+                match ty.sty {\n+                    ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+                        self.push_type_live_constraint(ty, location);\n+                    }\n+\n+                    _ => if known.insert(ty) {\n+                        types.push((ty, depth + 1));\n+                    },\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "8f18105600aed6adfac48d61c811288e5e6682f2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -12,6 +12,9 @@\n #![allow(unreachable_code)]\n \n use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n+use dataflow::FlowAtLocation;\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::MoveData;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n use rustc::infer::region_constraints::RegionConstraintData;\n use rustc::traits::{self, FulfillmentContext};\n@@ -26,22 +29,43 @@ use std::fmt;\n use syntax::ast;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n+use util::liveness::LivenessResults;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n \n+mod liveness;\n+\n /// Type checks the given `mir` in the context of the inference\n /// context `infcx`. Returns any region constraints that have yet to\n-/// be proven.\n+/// be proven. This result is includes liveness constraints that\n+/// ensure that regions appearing in the types of all local variables\n+/// are live at all points where that local variable may later be\n+/// used.\n ///\n /// This phase of type-check ought to be infallible -- this is because\n /// the original, HIR-based type-check succeeded. So if any errors\n /// occur here, we will get a `bug!` reported.\n-pub fn type_check<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+pub(crate) fn type_check<'gcx, 'tcx>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+    body_id: ast::NodeId,\n+    param_env: ty::ParamEnv<'gcx>,\n+    mir: &Mir<'tcx>,\n+    liveness: &LivenessResults,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) -> MirTypeckRegionConstraints<'tcx> {\n+    type_check_internal(infcx, body_id, param_env, mir, &mut |cx| {\n+        liveness::generate(cx, mir, liveness, flow_inits, move_data)\n+    })\n+}\n+\n+fn type_check_internal<'gcx, 'tcx>(\n+    infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n     body_id: ast::NodeId,\n     param_env: ty::ParamEnv<'gcx>,\n     mir: &Mir<'tcx>,\n+    extra: &mut FnMut(&mut TypeChecker<'_, 'gcx, 'tcx>),\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let mut checker = TypeChecker::new(infcx, body_id, param_env);\n     let errors_reported = {\n@@ -55,9 +79,12 @@ pub fn type_check<'a, 'gcx, 'tcx>(\n         checker.typeck_mir(mir);\n     }\n \n+    extra(&mut checker);\n+\n     checker.constraints\n }\n \n+\n fn mirbug(tcx: TyCtxt, span: Span, msg: &str) {\n     // We sometimes see MIR failures (notably predicate failures) due to\n     // the fact that we check rvalue sized predicates here. So use `delay_span_bug`\n@@ -503,7 +530,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n /// constraints needed for it to be valid and well-typed. Along the\n /// way, it accrues region constraints -- these can later be used by\n /// NLL region checking.\n-pub struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n     last_span: Span,\n@@ -1474,7 +1501,7 @@ impl MirPass for TypeckMir {\n         }\n         let param_env = tcx.param_env(def_id);\n         tcx.infer_ctxt().enter(|infcx| {\n-            let _region_constraint_sets = type_check(&infcx, id, param_env, mir);\n+            let _ = type_check_internal(&infcx, id, param_env, mir, &mut |_| ());\n \n             // For verification purposes, we just ignore the resulting\n             // region constraint sets. Not our problem. =)"}, {"sha": "677d13527884a938c5cc0de51eb2d3c1c809e860", "filename": "src/test/ui/nll/ty-outlives/projection-fn.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-fn.rs?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Znll -Zborrowck=mir\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+\n+trait Anything { }\n+\n+impl<T> Anything for T { }\n+\n+fn no_region<'a, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: Iterator,\n+{\n+    Box::new(x.next())\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+fn correct_region<'a, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: 'a + Iterator,\n+{\n+    Box::new(x.next())\n+}\n+\n+fn wrong_region<'a, 'b, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+{\n+    Box::new(x.next())\n+    //~^ WARNING not reporting region error due to -Znll\n+    //~| ERROR failed type test\n+}\n+\n+fn outlives_region<'a, 'b, T>(mut x: T) -> Box<dyn Anything + 'a>\n+where\n+    T: 'b + Iterator,\n+    'b: 'a,\n+{\n+    Box::new(x.next())\n+}\n+\n+fn main() {}"}, {"sha": "a478348edc11f7f20a9962c8a2ad85281380ba2a", "filename": "src/test/ui/nll/ty-outlives/projection-fn.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-fn.stderr?ref=47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "patch": "@@ -0,0 +1,26 @@\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-fn.rs:24:5\n+   |\n+24 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+warning: not reporting region error due to -Znll\n+  --> $DIR/projection-fn.rs:40:5\n+   |\n+40 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1695 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#3r, point: bb5[0], span: $DIR/projection-fn.rs:24:5: 24:23, test: IsOutlivedByAnyRegionIn([]) }\n+  --> $DIR/projection-fn.rs:24:5\n+   |\n+24 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: failed type test: TypeTest { generic_kind: ProjectionTy { substs: Slice([T]), item_def_id: DefId(2/0:1695 ~ core[2633]::iter[0]::iterator[0]::Iterator[0]::Item[0]) }, lower_bound: '_#4r, point: bb5[0], span: $DIR/projection-fn.rs:40:5: 40:23, test: IsOutlivedByAnyRegionIn(['_#2r]) }\n+  --> $DIR/projection-fn.rs:40:5\n+   |\n+40 |     Box::new(x.next())\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}