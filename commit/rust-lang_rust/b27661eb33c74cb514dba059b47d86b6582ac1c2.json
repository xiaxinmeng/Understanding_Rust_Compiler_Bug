{"sha": "b27661eb33c74cb514dba059b47d86b6582ac1c2", "node_id": "C_kwDOAAsO6NoAKGIyNzY2MWViMzNjNzRjYjUxNGRiYTA1OWI0N2Q4NmI2NTgyYWMxYzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-02T10:52:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-02T10:52:09Z"}, "message": "Auto merge of #89405 - GuillaumeGomez:fix-clippy-lints, r=cjgillot\n\nFix clippy lints\n\nI'm currently working on allowing clippy to run on librustdoc after a discussion I had with `@Mark-Simulacrum.` So in the meantime, I fixed a few lints on the compiler crates.", "tree": {"sha": "8ca6823fb95d22bff6676e007a813bc156348ec1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ca6823fb95d22bff6676e007a813bc156348ec1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b27661eb33c74cb514dba059b47d86b6582ac1c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b27661eb33c74cb514dba059b47d86b6582ac1c2", "html_url": "https://github.com/rust-lang/rust/commit/b27661eb33c74cb514dba059b47d86b6582ac1c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b27661eb33c74cb514dba059b47d86b6582ac1c2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8387aef8c378a771686878062e544af4d5e2245", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8387aef8c378a771686878062e544af4d5e2245", "html_url": "https://github.com/rust-lang/rust/commit/a8387aef8c378a771686878062e544af4d5e2245"}, {"sha": "759eba0a08ef80f958e671e822ad02e2b5409946", "url": "https://api.github.com/repos/rust-lang/rust/commits/759eba0a08ef80f958e671e822ad02e2b5409946", "html_url": "https://github.com/rust-lang/rust/commit/759eba0a08ef80f958e671e822ad02e2b5409946"}], "stats": {"total": 968, "additions": 460, "deletions": 508}, "files": [{"sha": "43032ae81cbbd88385ff88a009370fe7bdc59e03", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -277,26 +277,26 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let regioncx = Rc::new(regioncx);\n \n-    let flow_borrows = Borrows::new(tcx, &body, &regioncx, &borrow_set)\n-        .into_engine(tcx, &body)\n+    let flow_borrows = Borrows::new(tcx, body, &regioncx, &borrow_set)\n+        .into_engine(tcx, body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n-    let flow_uninits = MaybeUninitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body)\n+    let flow_uninits = MaybeUninitializedPlaces::new(tcx, body, &mdpe)\n+        .into_engine(tcx, body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n-    let flow_ever_inits = EverInitializedPlaces::new(tcx, &body, &mdpe)\n-        .into_engine(tcx, &body)\n+    let flow_ever_inits = EverInitializedPlaces::new(tcx, body, &mdpe)\n+        .into_engine(tcx, body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();\n \n-    let movable_generator = match tcx.hir().get(id) {\n+    let movable_generator = !matches!(\n+        tcx.hir().get(id),\n         Node::Expr(&hir::Expr {\n             kind: hir::ExprKind::Closure(.., Some(hir::Movability::Static)),\n             ..\n-        }) => false,\n-        _ => true,\n-    };\n+        })\n+    );\n \n     for (idx, move_data_results) in promoted_errors {\n         let promoted_body = &promoted[idx];\n@@ -374,8 +374,8 @@ fn do_mir_borrowck<'a, 'tcx>(\n     mbcx.report_move_errors(move_errors);\n \n     rustc_mir_dataflow::visit_results(\n-        &body,\n-        traversal::reverse_postorder(&body).map(|(bb, _)| bb),\n+        body,\n+        traversal::reverse_postorder(body).map(|(bb, _)| bb),\n         &results,\n         &mut mbcx,\n     );"}, {"sha": "dca9c1f04d3c0fd40672c6babd21295aeb89473b", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -526,7 +526,7 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, &bx.cx, callsite);\n+                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, bx.cx, callsite);\n             }\n             PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n                 assert!(!on_stack);"}, {"sha": "341a88824169847f23948d40631592e7f992cf27", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -105,7 +105,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let r = r.unwrap();\n \n         // Again, based on how many outputs we have\n-        let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n+        let outputs = ia.outputs.iter().zip(&outputs).filter(|&(o, _)| !o.is_indirect);\n         for (i, (_, &place)) in outputs.enumerate() {\n             let v = if num_outputs == 1 { r } else { self.extract_value(r, i as u64) };\n             OperandValue::Immediate(v).store(self, place);\n@@ -331,7 +331,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let output_type = match &output_types[..] {\n             [] => self.type_void(),\n             [ty] => ty,\n-            tys => self.type_struct(&tys, false),\n+            tys => self.type_struct(tys, false),\n         };\n         let dialect = match asm_arch {\n             InlineAsmArch::X86 | InlineAsmArch::X86_64"}, {"sha": "e2b33509b408d4e196fae7fe580a5da570377ad4", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -109,7 +109,7 @@ fn prepare_lto(\n                     .extend(exported_symbols[&cnum].iter().filter_map(symbol_filter));\n             }\n \n-            let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n+            let archive = ArchiveRO::open(path).expect(\"wanted an rlib\");\n             let obj_files = archive\n                 .iter()\n                 .filter_map(|child| child.ok().and_then(|c| c.name().map(|name| (name, c))))\n@@ -316,14 +316,14 @@ fn fat_lto(\n                 .generic_activity_with_arg(\"LLVM_fat_lto_link_module\", format!(\"{:?}\", name));\n             info!(\"linking {:?}\", name);\n             let data = bc_decoded.data();\n-            linker.add(&data).map_err(|()| {\n+            linker.add(data).map_err(|()| {\n                 let msg = format!(\"failed to load bc of {:?}\", name);\n-                write::llvm_err(&diag_handler, &msg)\n+                write::llvm_err(diag_handler, &msg)\n             })?;\n             serialized_bitcode.push(bc_decoded);\n         }\n         drop(linker);\n-        save_temp_bitcode(&cgcx, &module, \"lto.input\");\n+        save_temp_bitcode(cgcx, &module, \"lto.input\");\n \n         // Fat LTO also suffers from the invalid DWARF issue similar to Thin LTO.\n         // Here we rewrite all `DICompileUnit` pointers if there is only one `DICompileUnit`.\n@@ -347,14 +347,14 @@ fn fat_lto(\n                 ptr as *const *const libc::c_char,\n                 symbols_below_threshold.len() as libc::size_t,\n             );\n-            save_temp_bitcode(&cgcx, &module, \"lto.after-restriction\");\n+            save_temp_bitcode(cgcx, &module, \"lto.after-restriction\");\n         }\n \n         if cgcx.no_landing_pads {\n             unsafe {\n                 llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             }\n-            save_temp_bitcode(&cgcx, &module, \"lto.after-nounwind\");\n+            save_temp_bitcode(cgcx, &module, \"lto.after-nounwind\");\n         }\n     }\n \n@@ -498,7 +498,7 @@ fn thin_lto(\n             symbols_below_threshold.as_ptr(),\n             symbols_below_threshold.len() as u32,\n         )\n-        .ok_or_else(|| write::llvm_err(&diag_handler, \"failed to prepare thin LTO context\"))?;\n+        .ok_or_else(|| write::llvm_err(diag_handler, \"failed to prepare thin LTO context\"))?;\n \n         let data = ThinData(data);\n \n@@ -572,7 +572,7 @@ fn thin_lto(\n         if let Some(path) = key_map_path {\n             if let Err(err) = curr_key_map.save_to_file(&path) {\n                 let msg = format!(\"Error while writing ThinLTO key data: {}\", err);\n-                return Err(write::llvm_err(&diag_handler, &msg));\n+                return Err(write::llvm_err(diag_handler, &msg));\n             }\n         }\n \n@@ -744,8 +744,7 @@ pub unsafe fn optimize_thin_module(\n     // crates but for locally codegened modules we may be able to reuse\n     // that LLVM Context and Module.\n     let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-    let llmod_raw =\n-        parse_module(llcx, &module_name, thin_module.data(), &diag_handler)? as *const _;\n+    let llmod_raw = parse_module(llcx, module_name, thin_module.data(), &diag_handler)? as *const _;\n     let module = ModuleCodegen {\n         module_llvm: ModuleLlvm { llmod_raw, llcx, tm },\n         name: thin_module.name().to_string(),\n@@ -754,7 +753,7 @@ pub unsafe fn optimize_thin_module(\n     {\n         let target = &*module.module_llvm.tm;\n         let llmod = module.module_llvm.llmod();\n-        save_temp_bitcode(&cgcx, &module, \"thin-lto-input\");\n+        save_temp_bitcode(cgcx, &module, \"thin-lto-input\");\n \n         // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n         // using below. If we find more than one though then rustc has changed\n@@ -775,7 +774,7 @@ pub unsafe fn optimize_thin_module(\n                 .prof\n                 .generic_activity_with_arg(\"LLVM_thin_lto_remove_landing_pads\", thin_module.name());\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n-            save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-nounwind\");\n         }\n \n         // Up next comes the per-module local analyses that we do for Thin LTO.\n@@ -947,7 +946,7 @@ pub fn parse_module<'a>(\n         llvm::LLVMRustParseBitcodeForLTO(cx, data.as_ptr(), data.len(), name.as_ptr()).ok_or_else(\n             || {\n                 let msg = \"failed to parse bitcode for LTO module\";\n-                write::llvm_err(&diag_handler, msg)\n+                write::llvm_err(diag_handler, msg)\n             },\n         )\n     }"}, {"sha": "ab48c56a626634b494eef67f6f8a1da77d409bba", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -41,7 +41,7 @@ use std::sync::Arc;\n pub fn llvm_err(handler: &rustc_errors::Handler, msg: &str) -> FatalError {\n     match llvm::last_error() {\n         Some(err) => handler.fatal(&format!(\"{}: {}\", msg, err)),\n-        None => handler.fatal(&msg),\n+        None => handler.fatal(msg),\n     }\n }\n \n@@ -96,7 +96,7 @@ pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut ll\n         None\n     };\n     let config = TargetMachineFactoryConfig { split_dwarf_file };\n-    target_machine_factory(&tcx.sess, tcx.backend_optimization_level(()))(config)\n+    target_machine_factory(tcx.sess, tcx.backend_optimization_level(()))(config)\n         .unwrap_or_else(|err| llvm_err(tcx.sess.diagnostic(), &err).raise())\n }\n \n@@ -558,7 +558,7 @@ pub(crate) unsafe fn optimize(\n                 let prepare_for_thin_lto = cgcx.lto == Lto::Thin\n                     || cgcx.lto == Lto::ThinLocal\n                     || (cgcx.lto != Lto::Fat && cgcx.opts.cg.linker_plugin_lto.enabled());\n-                with_llvm_pmb(llmod, &config, opt_level, prepare_for_thin_lto, &mut |b| {\n+                with_llvm_pmb(llmod, config, opt_level, prepare_for_thin_lto, &mut |b| {\n                     llvm::LLVMRustAddLastExtensionPasses(\n                         b,\n                         extra_passes.as_ptr(),\n@@ -660,9 +660,9 @@ pub(crate) fn link(\n         let _timer =\n             cgcx.prof.generic_activity_with_arg(\"LLVM_link_module\", format!(\"{:?}\", module.name));\n         let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-        linker.add(&buffer.data()).map_err(|()| {\n+        linker.add(buffer.data()).map_err(|()| {\n             let msg = format!(\"failed to serialize module {:?}\", module.name);\n-            llvm_err(&diag_handler, &msg)\n+            llvm_err(diag_handler, &msg)\n         })?;\n     }\n     drop(linker);"}, {"sha": "9f7b8616d7817b905b1914836c9ae3cd2547eb02", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -86,7 +86,7 @@ impl ty::layout::HasParamEnv<'tcx> for Builder<'_, '_, 'tcx> {\n impl HasTargetSpec for Builder<'_, '_, 'tcx> {\n     #[inline]\n     fn target_spec(&self) -> &Target {\n-        &self.cx.target_spec()\n+        self.cx.target_spec()\n     }\n }\n "}, {"sha": "5d68d2b77d42ea0de6c529622840f7ae5afc2334", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -44,7 +44,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n \n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n-    let llfn = if let Some(llfn) = cx.get_declared_value(&sym) {\n+    let llfn = if let Some(llfn) = cx.get_declared_value(sym) {\n         // Create a fn pointer with the new signature.\n         let llptrty = fn_abi.ptr_to_llvm_type(cx);\n \n@@ -79,7 +79,7 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n             llfn\n         }\n     } else {\n-        let llfn = cx.declare_fn(&sym, &fn_abi);\n+        let llfn = cx.declare_fn(sym, fn_abi);\n         debug!(\"get_fn: not casting pointer!\");\n \n         attributes::from_fn_attrs(cx, llfn, instance);"}, {"sha": "1afa6f0283670eb80afd8a9d534c79d2bf6ec475", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -178,7 +178,7 @@ fn check_and_apply_linkage(\n         };\n         unsafe {\n             // Declare a symbol `foo` with the desired linkage.\n-            let g1 = cx.declare_global(&sym, llty2);\n+            let g1 = cx.declare_global(sym, llty2);\n             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n             // Declare an internal global `extern_with_linkage_foo` which\n@@ -188,7 +188,7 @@ fn check_and_apply_linkage(\n             // `extern_with_linkage_foo` will instead be initialized to\n             // zero.\n             let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n-            real_name.push_str(&sym);\n+            real_name.push_str(sym);\n             let g2 = cx.define_global(&real_name, llty).unwrap_or_else(|| {\n                 cx.sess().span_fatal(\n                     cx.tcx.def_span(span_def_id),\n@@ -202,7 +202,7 @@ fn check_and_apply_linkage(\n     } else {\n         // Generate an external declaration.\n         // FIXME(nagisa): investigate whether it can be changed into define_global\n-        cx.declare_global(&sym, llty)\n+        cx.declare_global(sym, llty)\n     }\n }\n \n@@ -234,7 +234,7 @@ impl CodegenCx<'ll, 'tcx> {\n                 _ => self.define_private_global(self.val_ty(cv)),\n             };\n             llvm::LLVMSetInitializer(gv, cv);\n-            set_global_alignment(&self, gv, align);\n+            set_global_alignment(self, gv, align);\n             llvm::SetUnnamedAddress(gv, llvm::UnnamedAddr::Global);\n             gv\n         }\n@@ -279,7 +279,7 @@ impl CodegenCx<'ll, 'tcx> {\n \n             g\n         } else {\n-            check_and_apply_linkage(&self, &fn_attrs, ty, sym, def_id)\n+            check_and_apply_linkage(self, fn_attrs, ty, sym, def_id)\n         };\n \n         // Thread-local statics in some other crate need to *always* be linked\n@@ -369,7 +369,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n         unsafe {\n             let attrs = self.tcx.codegen_fn_attrs(def_id);\n \n-            let (v, alloc) = match codegen_static_initializer(&self, def_id) {\n+            let (v, alloc) = match codegen_static_initializer(self, def_id) {\n                 Ok(v) => v,\n                 // Error has already been reported\n                 Err(_) => return,\n@@ -417,7 +417,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 self.statics_to_rauw.borrow_mut().push((g, new_g));\n                 new_g\n             };\n-            set_global_alignment(&self, g, self.align_of(ty));\n+            set_global_alignment(self, g, self.align_of(ty));\n             llvm::LLVMSetInitializer(g, v);\n \n             if self.should_assume_dso_local(g, true) {\n@@ -430,7 +430,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                 llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n \n-            debuginfo::create_global_var_metadata(&self, def_id, g);\n+            debuginfo::create_global_var_metadata(self, def_id, g);\n \n             if attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL) {\n                 llvm::set_thread_local_mode(g, self.tls_model);\n@@ -518,7 +518,7 @@ impl StaticMethods for CodegenCx<'ll, 'tcx> {\n                     );\n                 }\n             } else {\n-                base::set_link_section(g, &attrs);\n+                base::set_link_section(g, attrs);\n             }\n \n             if attrs.flags.contains(CodegenFnAttrFlags::USED) {"}, {"sha": "257a0ac89d86ffff881fd814b631841fba8d26dc", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -363,7 +363,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n \n     fn create_used_variable_impl(&self, name: &'static CStr, values: &[&'ll Value]) {\n         let section = cstr!(\"llvm.metadata\");\n-        let array = self.const_array(&self.type_ptr_to(self.type_i8()), values);\n+        let array = self.const_array(self.type_ptr_to(self.type_i8()), values);\n \n         unsafe {\n             let g = llvm::LLVMAddGlobal(self.llmod, self.val_ty(array), name.as_ptr());\n@@ -447,7 +447,7 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     }\n \n     fn sess(&self) -> &Session {\n-        &self.tcx.sess\n+        self.tcx.sess\n     }\n \n     fn check_overflow(&self) -> bool {"}, {"sha": "6830864ba04b4e9271a630df3f1f09af993dd66d", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -73,7 +73,7 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n             mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);\n         });\n         debug_assert!(\n-            coverage_mapping_buffer.len() > 0,\n+            !coverage_mapping_buffer.is_empty(),\n             \"Every `FunctionCoverage` should have at least one counter\"\n         );\n \n@@ -311,8 +311,7 @@ fn add_unused_functions<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     // for each region in it's MIR.\n \n     // Convert the `HashSet` of `codegenned_def_ids` to a sortable vector, and sort them.\n-    let mut sorted_codegenned_def_ids: Vec<DefId> =\n-        codegenned_def_ids.iter().map(|def_id| *def_id).collect();\n+    let mut sorted_codegenned_def_ids: Vec<DefId> = codegenned_def_ids.iter().copied().collect();\n     sorted_codegenned_def_ids.sort_unstable();\n \n     let mut first_covered_def_id_by_file: FxHashMap<Symbol, DefId> = FxHashMap::default();"}, {"sha": "ef11e2972ea3b5e3f09d02892411935b622bfa77", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -199,8 +199,8 @@ fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx\n     );\n \n     let llfn = cx.declare_fn(\n-        &tcx.symbol_name(instance).name,\n-        &cx.fn_abi_of_fn_ptr(\n+        tcx.symbol_name(instance).name,\n+        cx.fn_abi_of_fn_ptr(\n             ty::Binder::dummy(tcx.mk_fn_sig(\n                 iter::once(tcx.mk_unit()),\n                 tcx.mk_unit(),"}, {"sha": "58f8573a2acbfe0abeb91a9a1689ad460dc88e26", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/create_scope_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fcreate_scope_map.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -41,7 +41,7 @@ pub fn compute_mir_scopes(\n     // Instantiate all scopes.\n     for idx in 0..mir.source_scopes.len() {\n         let scope = SourceScope::new(idx);\n-        make_mir_scope(cx, instance, &mir, fn_dbg_scope, &has_variables, debug_context, scope);\n+        make_mir_scope(cx, instance, mir, fn_dbg_scope, &has_variables, debug_context, scope);\n     }\n }\n \n@@ -94,7 +94,7 @@ fn make_mir_scope(\n                 callee,\n             );\n             let callee_fn_abi = cx.fn_abi_of_instance(callee, ty::List::empty());\n-            cx.dbg_scope_fn(callee, &callee_fn_abi, None)\n+            cx.dbg_scope_fn(callee, callee_fn_abi, None)\n         }\n         None => unsafe {\n             llvm::LLVMRustDIBuilderCreateLexicalBlock("}, {"sha": "ae1f83d944f593fee5141e7b261bcae75465bb3b", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/gdb.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fgdb.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -59,10 +59,8 @@ pub fn get_or_insert_gdb_debug_scripts_section_global(cx: &CodegenCx<'ll, '_>) -\n }\n \n pub fn needs_gdb_debug_scripts_section(cx: &CodegenCx<'_, '_>) -> bool {\n-    let omit_gdb_pretty_printer_section = cx\n-        .tcx\n-        .sess\n-        .contains_name(&cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n+    let omit_gdb_pretty_printer_section =\n+        cx.tcx.sess.contains_name(cx.tcx.hir().krate_attrs(), sym::omit_gdb_pretty_printer_section);\n \n     !omit_gdb_pretty_printer_section\n         && cx.sess().opts.debuginfo != DebugInfo::None"}, {"sha": "f6ec5e6395f848bc480b41be1282394e4da113bd", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -477,7 +477,7 @@ fn subroutine_type_metadata(\n     let signature_metadata: Vec<_> = iter::once(\n         // return type\n         match signature.output().kind() {\n-            ty::Tuple(ref tys) if tys.is_empty() => None,\n+            ty::Tuple(tys) if tys.is_empty() => None,\n             _ => Some(type_metadata(cx, signature.output(), span)),\n         },\n     )\n@@ -647,7 +647,7 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n         ty::Never | ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n-        ty::Tuple(ref elements) if elements.is_empty() => {\n+        ty::Tuple(elements) if elements.is_empty() => {\n             MetadataCreationResult::new(basic_type_metadata(cx, t), false)\n         }\n         ty::Array(typ, _) | ty::Slice(typ) => {\n@@ -746,7 +746,7 @@ pub fn type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>, usage_site_span: Sp\n                     .finalize(cx)\n             }\n         },\n-        ty::Tuple(ref elements) => {\n+        ty::Tuple(elements) => {\n             let tys: Vec<_> = elements.iter().map(|k| k.expect_ty()).collect();\n             prepare_tuple_metadata(cx, t, &tys, unique_type_id, usage_site_span, NO_SCOPE_METADATA)\n                 .finalize(cx)\n@@ -932,7 +932,7 @@ fn basic_type_metadata(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll DIType {\n \n     let (name, encoding) = match t.kind() {\n         ty::Never => (\"!\", DW_ATE_unsigned),\n-        ty::Tuple(ref elements) if elements.is_empty() => (\"()\", DW_ATE_unsigned),\n+        ty::Tuple(elements) if elements.is_empty() => (\"()\", DW_ATE_unsigned),\n         ty::Bool => (\"bool\", DW_ATE_boolean),\n         ty::Char => (\"char\", DW_ATE_unsigned_char),\n         ty::Int(int_ty) if msvc_like_names => (int_ty.msvc_basic_name(), DW_ATE_signed),\n@@ -1123,7 +1123,7 @@ pub fn compile_unit_metadata(\n \n             let gcov_cu_info = [\n                 path_to_mdstring(debug_context.llcontext, &output_filenames.with_extension(\"gcno\")),\n-                path_to_mdstring(debug_context.llcontext, &gcda_path),\n+                path_to_mdstring(debug_context.llcontext, gcda_path),\n                 cu_desc_metadata,\n             ];\n             let gcov_metadata = llvm::LLVMMDNodeInContext(\n@@ -1963,17 +1963,13 @@ impl<'tcx> VariantInfo<'_, 'tcx> {\n     }\n \n     fn source_info(&self, cx: &CodegenCx<'ll, 'tcx>) -> Option<SourceInfo<'ll>> {\n-        match self {\n-            VariantInfo::Generator { def_id, variant_index, .. } => {\n-                let span = cx.tcx.generator_layout(*def_id).unwrap().variant_source_info\n-                    [*variant_index]\n-                    .span;\n-                if !span.is_dummy() {\n-                    let loc = cx.lookup_debug_loc(span.lo());\n-                    return Some(SourceInfo { file: file_metadata(cx, &loc.file), line: loc.line });\n-                }\n+        if let VariantInfo::Generator { def_id, variant_index, .. } = self {\n+            let span =\n+                cx.tcx.generator_layout(*def_id).unwrap().variant_source_info[*variant_index].span;\n+            if !span.is_dummy() {\n+                let loc = cx.lookup_debug_loc(span.lo());\n+                return Some(SourceInfo { file: file_metadata(cx, &loc.file), line: loc.line });\n             }\n-            _ => {}\n         }\n         None\n     }\n@@ -1994,11 +1990,11 @@ fn describe_enum_variant(\n         let unique_type_id = debug_context(cx)\n             .type_map\n             .borrow_mut()\n-            .get_unique_type_id_of_enum_variant(cx, layout.ty, &variant_name);\n+            .get_unique_type_id_of_enum_variant(cx, layout.ty, variant_name);\n         create_struct_stub(\n             cx,\n             layout.ty,\n-            &variant_name,\n+            variant_name,\n             unique_type_id,\n             Some(containing_scope),\n             DIFlags::FlagZero,\n@@ -2385,7 +2381,7 @@ fn set_members_of_composite_type(\n     {\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n-        if !composite_types_completed.insert(&composite_type_metadata) {\n+        if !composite_types_completed.insert(composite_type_metadata) {\n             bug!(\n                 \"debuginfo::set_members_of_composite_type() - \\\n                   Already completed forward declaration re-encountered.\""}, {"sha": "894320a79828504367af5018415371e9b8c785f6", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -328,7 +328,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         // name if necessary.\n         let generics = self.tcx().generics_of(enclosing_fn_def_id);\n         let substs = instance.substs.truncate_to(self.tcx(), generics);\n-        let template_parameters = get_template_parameters(self, &generics, substs, &mut name);\n+        let template_parameters = get_template_parameters(self, generics, substs, &mut name);\n \n         let linkage_name = &mangled_name_of_instance(self, instance).name;\n         // Omit the linkage_name if it is the same as subprogram name.\n@@ -559,7 +559,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         scope_metadata: &'ll DIScope,\n         file: &rustc_span::SourceFile,\n     ) -> &'ll DILexicalBlock {\n-        metadata::extend_scope_to_file(&self, scope_metadata, file)\n+        metadata::extend_scope_to_file(self, scope_metadata, file)\n     }\n \n     fn debuginfo_finalize(&self) {"}, {"sha": "22dc8d101c844644977f0c605bb9003a0026b89f", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -71,7 +71,7 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<(&'ll T\n         sym::roundf64 => \"llvm.round.f64\",\n         _ => return None,\n     };\n-    Some(cx.get_intrinsic(&llvm_name))\n+    Some(cx.get_intrinsic(llvm_name))\n }\n \n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n@@ -743,7 +743,7 @@ fn gen_fn<'ll, 'tcx>(\n ) -> (&'ll Type, &'ll Value) {\n     let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n     let llty = fn_abi.llvm_type(cx);\n-    let llfn = cx.declare_fn(name, &fn_abi);\n+    let llfn = cx.declare_fn(name, fn_abi);\n     cx.set_frame_pointer_type(llfn);\n     cx.apply_target_cpu_attr(llfn);\n     // FIXME(eddyb) find a nicer way to do this.\n@@ -1159,7 +1159,7 @@ fn generic_simd_intrinsic(\n             _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n         };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n-        let f = bx.declare_cfn(&llvm_name, llvm::UnnamedAddr::No, fn_ty);\n+        let f = bx.declare_cfn(llvm_name, llvm::UnnamedAddr::No, fn_ty);\n         let c =\n             bx.call(fn_ty, f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         Ok(c)\n@@ -1793,7 +1793,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n \n         let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n-        let f = bx.declare_cfn(&llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n+        let f = bx.declare_cfn(llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n         let v = bx.call(fn_ty, f, &[lhs, rhs], None);\n         return Ok(v);\n     }"}, {"sha": "8f4d79e7147d349ac7ab7978b654c062569757a4", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -339,7 +339,7 @@ impl ModuleLlvm {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n             let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n-            let tm_factory_config = TargetMachineFactoryConfig::new(&cgcx, name.to_str().unwrap());\n+            let tm_factory_config = TargetMachineFactoryConfig::new(cgcx, name.to_str().unwrap());\n             let tm = match (cgcx.tm_factory)(tm_factory_config) {\n                 Ok(m) => m,\n                 Err(e) => {"}, {"sha": "436d906827b5ba71c42b6c8e28adc02e95b2d0d7", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -789,7 +789,7 @@ pub mod coverageinfo {\n                 start_line,\n                 start_col,\n                 end_line,\n-                end_col: ((1 as u32) << 31) | end_col,\n+                end_col: (1_u32 << 31) | end_col,\n                 kind: RegionKind::GapRegion,\n             }\n         }"}, {"sha": "c5deb11edd094d9776c63685a1c70815e249d162", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -298,7 +298,7 @@ fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n     for (feature, desc) in &target_features {\n         println!(\"    {1:0$} - {2}.\", max_feature_len, feature, desc);\n     }\n-    if target_features.len() == 0 {\n+    if target_features.is_empty() {\n         println!(\"    Target features listing is not supported by this LLVM version.\");\n     }\n     println!(\"\\nUse +feature to enable a feature, or -feature to disable it.\");"}, {"sha": "88498cf47d8b009c17bcb9857fe0137efd00ca85", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -53,10 +53,10 @@ impl PreDefineMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         assert!(!instance.substs.needs_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n-        let lldecl = self.declare_fn(symbol_name, &fn_abi);\n+        let lldecl = self.declare_fn(symbol_name, fn_abi);\n         unsafe { llvm::LLVMRustSetLinkage(lldecl, base::linkage_to_llvm(linkage)) };\n         let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n-        base::set_link_section(lldecl, &attrs);\n+        base::set_link_section(lldecl, attrs);\n         if linkage == Linkage::LinkOnceODR || linkage == Linkage::WeakODR {\n             llvm::SetUniqueComdat(self.llmod, lldecl);\n         }\n@@ -145,10 +145,6 @@ impl CodegenCx<'ll, 'tcx> {\n \n         // With pie relocation model calls of functions defined in the translation\n         // unit can use copy relocations.\n-        if self.tcx.sess.relocation_model() == RelocModel::Pie && !is_declaration {\n-            return true;\n-        }\n-\n-        return false;\n+        self.tcx.sess.relocation_model() == RelocModel::Pie && !is_declaration\n     }\n }"}, {"sha": "2ae0a08f192d060a6067bc06a50bfc3d47461fcf", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -248,7 +248,7 @@ impl Type {\n     }\n \n     fn ptr_to(&self, address_space: AddressSpace) -> &Type {\n-        unsafe { llvm::LLVMPointerType(&self, address_space.0) }\n+        unsafe { llvm::LLVMPointerType(self, address_space.0) }\n     }\n }\n "}, {"sha": "f8c919ec2aa33a38af80f3b90be2c5b3877418d7", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n                     cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).llvm_type(cx))\n                 }\n                 ty::FnPtr(sig) => {\n-                    cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty()))\n+                    cx.fn_ptr_backend_type(cx.fn_abi_of_fn_ptr(sig, ty::List::empty()))\n                 }\n                 _ => self.scalar_llvm_type_at(cx, scalar, Size::ZERO),\n             };\n@@ -245,7 +245,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n             Variants::Single { index } => Some(index),\n             _ => None,\n         };\n-        if let Some(ref llty) = cx.type_lowering.borrow().get(&(self.ty, variant_index)) {\n+        if let Some(llty) = cx.type_lowering.borrow().get(&(self.ty, variant_index)) {\n             return llty.lltype;\n         }\n \n@@ -270,10 +270,9 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        cx.type_lowering.borrow_mut().insert(\n-            (self.ty, variant_index),\n-            TypeLowering { lltype: llty, field_remapping: field_remapping },\n-        );\n+        cx.type_lowering\n+            .borrow_mut()\n+            .insert((self.ty, variant_index), TypeLowering { lltype: llty, field_remapping });\n \n         if let Some((llty, layout)) = defer {\n             let (llfields, packed, new_field_remapping) = struct_llfields(cx, layout);"}, {"sha": "591f659f11bf4f54f12523eb0bc45f3008d1fc1d", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -125,7 +125,7 @@ fn emit_aapcs_va_arg(\n     // if the offset >= 0 then the value will be on the stack\n     let mut reg_off_v = bx.load(bx.type_i32(), reg_off, offset_align);\n     let use_stack = bx.icmp(IntPredicate::IntSGE, reg_off_v, zero);\n-    bx.cond_br(use_stack, &on_stack.llbb(), &maybe_reg.llbb());\n+    bx.cond_br(use_stack, on_stack.llbb(), maybe_reg.llbb());\n \n     // The value at this point might be in a register, but there is a chance that\n     // it could be on the stack so we have to update the offset and then check\n@@ -142,7 +142,7 @@ fn emit_aapcs_va_arg(\n     // Check to see if we have overflowed the registers as a result of this.\n     // If we have then we need to use the stack for this value\n     let use_stack = maybe_reg.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n-    maybe_reg.cond_br(use_stack, &on_stack.llbb(), &in_reg.llbb());\n+    maybe_reg.cond_br(use_stack, on_stack.llbb(), in_reg.llbb());\n \n     let top_type = bx.type_i8p();\n     let top = in_reg.struct_gep(va_list_ty, va_list_addr, reg_top_index);\n@@ -158,17 +158,17 @@ fn emit_aapcs_va_arg(\n     let reg_type = layout.llvm_type(bx);\n     let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n     let reg_value = in_reg.load(reg_type, reg_addr, layout.align.abi);\n-    in_reg.br(&end.llbb());\n+    in_reg.br(end.llbb());\n \n     // On Stack block\n     let stack_value =\n         emit_ptr_va_arg(&mut on_stack, list, target_ty, false, Align::from_bytes(8).unwrap(), true);\n-    on_stack.br(&end.llbb());\n+    on_stack.br(end.llbb());\n \n     let val = end.phi(\n         layout.immediate_llvm_type(bx),\n         &[reg_value, stack_value],\n-        &[&in_reg.llbb(), &on_stack.llbb()],\n+        &[in_reg.llbb(), on_stack.llbb()],\n     );\n \n     *bx = end;"}, {"sha": "7fd7f6b1340f49eee52825c6bdb3cbe0a2874c68", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -128,7 +128,7 @@ impl Callbacks for TimePassesCallbacks {\n }\n \n pub fn diagnostics_registry() -> Registry {\n-    Registry::new(&rustc_error_codes::DIAGNOSTICS)\n+    Registry::new(rustc_error_codes::DIAGNOSTICS)\n }\n \n /// This is the primary entry point for rustc.\n@@ -265,8 +265,8 @@ fn run_compiler(\n                         &***compiler.codegen_backend(),\n                         compiler.session(),\n                         None,\n-                        &compiler.output_dir(),\n-                        &compiler.output_file(),\n+                        compiler.output_dir(),\n+                        compiler.output_file(),\n                     );\n \n                     if should_stop == Compilation::Stop {\n@@ -330,7 +330,7 @@ fn run_compiler(\n                     let krate = queries.parse()?.take();\n                     pretty::print_after_parsing(\n                         sess,\n-                        &compiler.input(),\n+                        compiler.input(),\n                         &krate,\n                         *ppm,\n                         compiler.output_file().as_ref().map(|p| &**p),\n@@ -356,7 +356,7 @@ fn run_compiler(\n \n                 // Lint plugins are registered; now we can process command line flags.\n                 if sess.opts.describe_lints {\n-                    describe_lints(&sess, &lint_store, true);\n+                    describe_lints(sess, lint_store, true);\n                     return early_exit();\n                 }\n             }\n@@ -388,7 +388,7 @@ fn run_compiler(\n                         save::process_crate(\n                             tcx,\n                             &crate_name,\n-                            &compiler.input(),\n+                            compiler.input(),\n                             None,\n                             DumpHandler::new(\n                                 compiler.output_dir().as_ref().map(|p| &**p),\n@@ -598,15 +598,15 @@ impl RustcDefaultCalls {\n             if let Input::File(file) = compiler.input() {\n                 // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n                 sess.init_crate_types(collect_crate_types(sess, &[]));\n-                let outputs = compiler.build_output_filenames(&sess, &[]);\n+                let outputs = compiler.build_output_filenames(sess, &[]);\n                 let rlink_data = fs::read_to_string(file).unwrap_or_else(|err| {\n                     sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n                 });\n                 let codegen_results: CodegenResults =\n                     json::decode(&rlink_data).unwrap_or_else(|err| {\n                         sess.fatal(&format!(\"failed to decode rlink: {}\", err));\n                     });\n-                let result = compiler.codegen_backend().link(&sess, codegen_results, &outputs);\n+                let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n                 abort_on_err(result, sess);\n             } else {\n                 sess.fatal(\"rlink must be a file\")\n@@ -894,9 +894,9 @@ Available lint options:\n     };\n \n     println!(\"Lint groups provided by rustc:\\n\");\n-    println!(\"    {}  {}\", padded(\"name\"), \"sub-lints\");\n-    println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n-    println!(\"    {}  {}\", padded(\"warnings\"), \"all lints that are set to issue warnings\");\n+    println!(\"    {}  sub-lints\", padded(\"name\"));\n+    println!(\"    {}  ---------\", padded(\"----\"));\n+    println!(\"    {}  all lints that are set to issue warnings\", padded(\"warnings\"));\n \n     let print_lint_groups = |lints: Vec<(&'static str, Vec<LintId>)>| {\n         for (name, to) in lints {\n@@ -1217,7 +1217,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     }\n \n     for note in &xs {\n-        handler.note_without_error(&note);\n+        handler.note_without_error(note);\n     }\n \n     // If backtraces are enabled, also print the query stack\n@@ -1326,7 +1326,7 @@ mod signal_handler {\n                 std::alloc::alloc(std::alloc::Layout::from_size_align(ALT_STACK_SIZE, 1).unwrap())\n                     as *mut libc::c_void;\n             alt_stack.ss_size = ALT_STACK_SIZE;\n-            libc::sigaltstack(&mut alt_stack, std::ptr::null_mut());\n+            libc::sigaltstack(&alt_stack, std::ptr::null_mut());\n \n             let mut sa: libc::sigaction = std::mem::zeroed();\n             sa.sa_sigaction = print_stack_trace as libc::sighandler_t;"}, {"sha": "e52eef0fcbd72c21d4a523753a7890ad62a57892", "filename": "compiler/rustc_driver/src/pretty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Fpretty.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -296,7 +296,7 @@ struct TypedAnnotation<'tcx> {\n \n impl<'tcx> HirPrinterSupport<'tcx> for TypedAnnotation<'tcx> {\n     fn sess(&self) -> &Session {\n-        &self.tcx.sess\n+        self.tcx.sess\n     }\n \n     fn hir_map(&self) -> Option<hir_map::Map<'tcx>> {\n@@ -347,8 +347,7 @@ impl<'tcx> pprust_hir::PpAnn for TypedAnnotation<'tcx> {\n fn get_source(input: &Input, sess: &Session) -> (String, FileName) {\n     let src_name = input.source_name();\n     let src = String::clone(\n-        &sess\n-            .source_map()\n+        sess.source_map()\n             .get_source_file(&src_name)\n             .expect(\"get_source_file\")\n             .src"}, {"sha": "3c7908fae79beb45ff2e576ac433509a52cb6498", "filename": "compiler/rustc_interface/src/callbacks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -41,7 +41,7 @@ fn track_span_parent(def_id: rustc_span::def_id::LocalDefId) {\n fn track_diagnostic(diagnostic: &Diagnostic) {\n     tls::with_context_opt(|icx| {\n         if let Some(icx) = icx {\n-            if let Some(ref diagnostics) = icx.diagnostics {\n+            if let Some(diagnostics) = icx.diagnostics {\n                 let mut diagnostics = diagnostics.lock();\n                 diagnostics.extend(Some(diagnostic.clone()));\n             }"}, {"sha": "0861bd290df772abaa4c98bb2f293d1e1313d6e5", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -65,13 +65,7 @@ impl Compiler {\n         sess: &Session,\n         attrs: &[ast::Attribute],\n     ) -> OutputFilenames {\n-        util::build_output_filenames(\n-            &self.input,\n-            &self.output_dir,\n-            &self.output_file,\n-            &attrs,\n-            &sess,\n-        )\n+        util::build_output_filenames(&self.input, &self.output_dir, &self.output_file, attrs, sess)\n     }\n }\n "}, {"sha": "a221746f975ed32f327d12526329c2e16805a9ed", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -169,7 +169,7 @@ pub fn create_resolver(\n ) -> BoxedResolver {\n     tracing::trace!(\"create_resolver\");\n     BoxedResolver::new(sess, move |sess, resolver_arenas| {\n-        Resolver::new(sess, &krate, &crate_name, metadata_loader, &resolver_arenas)\n+        Resolver::new(sess, krate, crate_name, metadata_loader, resolver_arenas)\n     })\n }\n \n@@ -201,7 +201,7 @@ pub fn register_plugins<'a>(\n         sess.opts.cg.metadata.clone(),\n     );\n     sess.stable_crate_id.set(stable_crate_id).expect(\"not yet initialized\");\n-    rustc_incremental::prepare_session_directory(sess, &crate_name, stable_crate_id)?;\n+    rustc_incremental::prepare_session_directory(sess, crate_name, stable_crate_id)?;\n \n     if sess.opts.incremental.is_some() {\n         sess.time(\"incr_comp_garbage_collect_session_directories\", || {\n@@ -219,7 +219,7 @@ pub fn register_plugins<'a>(\n         sess.opts.debugging_opts.no_interleave_lints,\n         sess.unstable_options(),\n     );\n-    register_lints(&sess, &mut lint_store);\n+    register_lints(sess, &mut lint_store);\n \n     let registrars =\n         sess.time(\"plugin_loading\", || plugin::load::load_plugins(sess, metadata_loader, &krate));\n@@ -244,7 +244,7 @@ fn pre_expansion_lint(\n         rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n-            &krate,\n+            krate,\n             crate_attrs,\n             true,\n             None,\n@@ -270,10 +270,10 @@ pub fn configure_and_expand(\n \n     krate = sess.time(\"crate_injection\", || {\n         let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n-        rustc_builtin_macros::standard_library_imports::inject(krate, resolver, &sess, alt_std_name)\n+        rustc_builtin_macros::standard_library_imports::inject(krate, resolver, sess, alt_std_name)\n     });\n \n-    util::check_attr_crate_type(&sess, &krate.attrs, &mut resolver.lint_buffer());\n+    util::check_attr_crate_type(sess, &krate.attrs, &mut resolver.lint_buffer());\n \n     // Expand all macros\n     krate = sess.time(\"macro_expand_crate\", || {\n@@ -310,9 +310,9 @@ pub fn configure_and_expand(\n \n         // Create the config for macro expansion\n         let features = sess.features_untracked();\n-        let recursion_limit = get_recursion_limit(&krate.attrs, &sess);\n+        let recursion_limit = get_recursion_limit(&krate.attrs, sess);\n         let cfg = rustc_expand::expand::ExpansionConfig {\n-            features: Some(&features),\n+            features: Some(features),\n             recursion_limit,\n             trace_mac: sess.opts.debugging_opts.trace_macros,\n             should_test: sess.opts.test,\n@@ -327,7 +327,7 @@ pub fn configure_and_expand(\n             pre_expansion_lint(sess, lint_store, &krate, &crate_attrs, &ident.name.as_str());\n             (krate.attrs, krate.items)\n         };\n-        let mut ecx = ExtCtxt::new(&sess, cfg, resolver, Some(&extern_mod_loaded));\n+        let mut ecx = ExtCtxt::new(sess, cfg, resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));\n@@ -369,7 +369,7 @@ pub fn configure_and_expand(\n     })?;\n \n     sess.time(\"maybe_building_test_harness\", || {\n-        rustc_builtin_macros::test_harness::inject(&sess, resolver, &mut krate)\n+        rustc_builtin_macros::test_harness::inject(sess, resolver, &mut krate)\n     });\n \n     if let Some(PpMode::Source(PpSourceMode::EveryBodyLoops)) = sess.opts.pretty {\n@@ -392,8 +392,8 @@ pub fn configure_and_expand(\n     // start passing '--crate-type proc-macro'\n     if has_proc_macro_decls && sess.opts.actually_rustdoc && !is_proc_macro_crate {\n         let mut msg = sess.diagnostic().struct_warn(\n-            &\"Trying to document proc macro crate \\\n-            without passing '--crate-type proc-macro to rustdoc\",\n+            \"Trying to document proc macro crate \\\n+             without passing '--crate-type proc-macro to rustdoc\",\n         );\n \n         msg.warn(\"The generated documentation may be incorrect\");\n@@ -403,7 +403,7 @@ pub fn configure_and_expand(\n             let num_crate_types = crate_types.len();\n             let is_test_crate = sess.opts.test;\n             rustc_builtin_macros::proc_macro_harness::inject(\n-                &sess,\n+                sess,\n                 resolver,\n                 krate,\n                 is_proc_macro_crate,\n@@ -691,7 +691,7 @@ pub fn prepare_outputs(\n     );\n \n     let output_paths =\n-        generated_output_paths(sess, &outputs, compiler.output_file.is_some(), &crate_name);\n+        generated_output_paths(sess, &outputs, compiler.output_file.is_some(), crate_name);\n \n     // Ensure the source file isn't accidentally overwritten during compilation.\n     if let Some(ref input_path) = compiler.input_path {\n@@ -832,7 +832,7 @@ pub fn create_global_ctxt<'tcx>(\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),\n                 queries.as_dyn(),\n-                &crate_name,\n+                crate_name,\n                 outputs,\n             )\n         })"}, {"sha": "f188ad35605af69e6ca4e1fcf283cd891d526a4f", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -110,7 +110,7 @@ impl<'tcx> Queries<'tcx> {\n         &self.compiler.sess\n     }\n     fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n-        &self.compiler.codegen_backend()\n+        self.compiler.codegen_backend()\n     }\n \n     fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n@@ -181,7 +181,7 @@ impl<'tcx> Queries<'tcx> {\n                 &crate_name,\n             );\n             let krate = resolver.access(|resolver| {\n-                passes::configure_and_expand(&sess, &lint_store, krate, &crate_name, resolver)\n+                passes::configure_and_expand(sess, &lint_store, krate, &crate_name, resolver)\n             })?;\n             Ok((Rc::new(krate), Rc::new(RefCell::new(resolver)), lint_store))\n         })\n@@ -343,7 +343,7 @@ impl Linker {\n         let sess = &self.sess;\n         let dep_graph = self.dep_graph;\n         sess.time(\"serialize_work_products\", || {\n-            rustc_incremental::save_work_product_index(&sess, &dep_graph, work_products)\n+            rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)\n         });\n \n         let prof = self.sess.prof.clone();\n@@ -386,7 +386,7 @@ impl Compiler {\n         F: for<'tcx> FnOnce(&'tcx Queries<'tcx>) -> T,\n     {\n         let mut _timer = None;\n-        let queries = Queries::new(&self);\n+        let queries = Queries::new(self);\n         let ret = f(&queries);\n \n         // NOTE: intentionally does not compute the global context if it hasn't been built yet,"}, {"sha": "cffb087af187f9be0d080b798b90b08dd8e93bba", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -402,7 +402,7 @@ pub fn get_codegen_sysroot(\n         .iter()\n         .chain(sysroot_candidates.iter())\n         .map(|sysroot| {\n-            filesearch::make_target_lib_path(&sysroot, &target).with_file_name(\"codegen-backends\")\n+            filesearch::make_target_lib_path(sysroot, target).with_file_name(\"codegen-backends\")\n         })\n         .find(|f| {\n             info!(\"codegen backend candidate: {}\", f.display());\n@@ -619,7 +619,7 @@ pub fn build_output_filenames(\n                 .opts\n                 .crate_name\n                 .clone()\n-                .or_else(|| rustc_attr::find_crate_name(&sess, attrs).map(|n| n.to_string()))\n+                .or_else(|| rustc_attr::find_crate_name(sess, attrs).map(|n| n.to_string()))\n                 .unwrap_or_else(|| input.filestem().to_owned());\n \n             OutputFilenames::new("}, {"sha": "6493bd91ca27a836c54cb21bd80914b654474e6f", "filename": "compiler/rustc_llvm/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fsrc%2Flib.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -17,6 +17,10 @@ impl RustString {\n     pub fn len(&self) -> usize {\n         self.bytes.borrow().len()\n     }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.bytes.borrow().is_empty()\n+    }\n }\n \n /// Appending to a Rust string -- used by RawRustStringOstream."}, {"sha": "ae3a9c71c59686fc23e0120cff1abade2dfe610f", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -470,7 +470,7 @@ impl EmbargoVisitor<'tcx> {\n \n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n-        if attr::find_transparency(&attrs, md.macro_rules).0 != Transparency::Opaque {\n+        if attr::find_transparency(attrs, md.macro_rules).0 != Transparency::Opaque {\n             return;\n         }\n \n@@ -797,7 +797,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Re-exports are handled in `visit_mod`. However, in order to avoid looping over\n             // all of the items of a mod in `visit_mod` looking for use statements, we handle\n             // making sure that intermediate use statements have their visibilities updated here.\n-            hir::ItemKind::Use(ref path, _) => {\n+            hir::ItemKind::Use(path, _) => {\n                 if item_level.is_some() {\n                     self.update_visibility_of_intermediate_use_statements(path.segments.as_ref());\n                 }\n@@ -1099,11 +1099,11 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        if let hir::ExprKind::Struct(ref qpath, fields, ref base) = expr.kind {\n+        if let hir::ExprKind::Struct(qpath, fields, ref base) = expr.kind {\n             let res = self.typeck_results().qpath_res(qpath, expr.hir_id);\n             let adt = self.typeck_results().expr_ty(expr).ty_adt_def().unwrap();\n             let variant = adt.variant_of_res(res);\n-            if let Some(ref base) = *base {\n+            if let Some(base) = *base {\n                 // If the expression uses FRU we need to make sure all the unmentioned fields\n                 // are checked for privacy (RFC 736). Rather than computing the set of\n                 // unmentioned fields, just check them all.\n@@ -1312,7 +1312,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n             return;\n         }\n         match expr.kind {\n-            hir::ExprKind::Assign(_, ref rhs, _) | hir::ExprKind::Match(ref rhs, ..) => {\n+            hir::ExprKind::Assign(_, rhs, _) | hir::ExprKind::Match(rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n                 if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;\n@@ -1397,7 +1397,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n-        if let Some(ref init) = local.init {\n+        if let Some(init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {\n                 // Do not report duplicate errors for `let x = y`.\n                 return;\n@@ -1474,7 +1474,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n             match self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(did)) {\n-                Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n+                Some(Node::Item(item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1490,7 +1490,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn check_generic_bound(&mut self, bound: &hir::GenericBound<'_>) {\n         if let hir::GenericBound::Trait(ref trait_ref, _) = *bound {\n-            if self.path_is_private_type(&trait_ref.trait_ref.path) {\n+            if self.path_is_private_type(trait_ref.trait_ref.path) {\n                 self.old_error_set.insert(trait_ref.trait_ref.hir_ref_id);\n             }\n         }\n@@ -1517,7 +1517,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a\n     }\n \n     fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n-        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = ty.kind {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = ty.kind {\n             if self.inner.path_is_private_type(path) {\n                 self.contains_private = true;\n                 // Found what we're looking for, so let's stop working.\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // namespace (the contents have their own privacies).\n             hir::ItemKind::ForeignMod { .. } => {}\n \n-            hir::ItemKind::Trait(.., ref bounds, _) => {\n+            hir::ItemKind::Trait(.., bounds, _) => {\n                 if !self.trait_is_public(item.def_id) {\n                     return;\n                 }\n@@ -1586,7 +1586,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         at_outer_type: true,\n                         outer_type_is_public_path: false,\n                     };\n-                    visitor.visit_ty(&impl_.self_ty);\n+                    visitor.visit_ty(impl_.self_ty);\n                     self_contains_private = visitor.contains_private;\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n@@ -1664,12 +1664,12 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            intravisit::walk_path(self, &tr.path);\n+                            intravisit::walk_path(self, tr.path);\n \n                             // Those in 3. are warned with this call.\n                             for impl_item_ref in impl_.items {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                                if let hir::ImplItemKind::TyAlias(ref ty) = impl_item.kind {\n+                                if let hir::ImplItemKind::TyAlias(ty) = impl_item.kind {\n                                     self.visit_ty(ty);\n                                 }\n                             }\n@@ -1739,7 +1739,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                 }\n                 hir::WherePredicate::RegionPredicate(_) => {}\n                 hir::WherePredicate::EqPredicate(eq_pred) => {\n-                    self.visit_ty(&eq_pred.rhs_ty);\n+                    self.visit_ty(eq_pred.rhs_ty);\n                 }\n             }\n         }\n@@ -1752,7 +1752,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = t.kind {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = t.kind {\n             if self.path_is_private_type(path) {\n                 self.old_error_set.insert(t.hir_id);\n             }\n@@ -2191,7 +2191,7 @@ fn check_private_in_public(tcx: TyCtxt<'_>, (): ()) {\n \n     let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n         tcx,\n-        access_levels: &access_levels,\n+        access_levels,\n         in_variant: false,\n         old_error_set: Default::default(),\n     };"}, {"sha": "5befe44802f54a1341e140109ffb92625fffd426", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -132,7 +132,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         let kind_ord = param.kind.to_ord(tcx);\n-        let arg_ord = arg.to_ord(&tcx.features());\n+        let arg_ord = arg.to_ord(tcx.features());\n \n         // This note is only true when generic parameters are strictly ordered by their kind.\n         if possible_ordering_error && kind_ord.cmp(&arg_ord) != core::cmp::Ordering::Equal {\n@@ -423,7 +423,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         is_method_call: IsMethodCall,\n     ) -> GenericArgCountResult {\n         let empty_args = hir::GenericArgs::none();\n-        let suppress_mismatch = Self::check_impl_trait(tcx, seg, &generics);\n+        let suppress_mismatch = Self::check_impl_trait(tcx, seg, generics);\n \n         let gen_args = seg.args.unwrap_or(&empty_args);\n         let gen_pos = if is_method_call == IsMethodCall::Yes {"}, {"sha": "e492fd44185ca992dd06b021eecac69627c1ad5d", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -352,8 +352,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             span,\n             def_id,\n             seg,\n-            &generics,\n-            &generic_args,\n+            generics,\n+            generic_args,\n             GenericArgPosition::Type,\n             self_ty.is_some(),\n             infer_args,\n@@ -363,7 +363,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // Traits always have `Self` as a generic parameter, which means they will not return early\n         // here and so associated type bindings will be handled regardless of whether there are any\n         // non-`Self` generic parameters.\n-        if generics.params.len() == 0 {\n+        if generics.params.is_empty() {\n             return (tcx.intern_substs(&[]), arg_count);\n         }\n \n@@ -417,7 +417,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let tcx = self.astconv.tcx();\n                 match (&param.kind, arg) {\n                     (GenericParamDefKind::Lifetime, GenericArg::Lifetime(lt)) => {\n-                        self.astconv.ast_region_to_region(&lt, Some(param)).into()\n+                        self.astconv.ast_region_to_region(lt, Some(param)).into()\n                     }\n                     (&GenericParamDefKind::Type { has_default, .. }, GenericArg::Type(ty)) => {\n                         if has_default {\n@@ -441,7 +441,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             self.inferred_params.push(ty.span);\n                             tcx.ty_error().into()\n                         } else {\n-                            self.astconv.ast_ty_to_ty(&ty).into()\n+                            self.astconv.ast_ty_to_ty(ty).into()\n                         }\n                     }\n                     (GenericParamDefKind::Const { .. }, GenericArg::Const(ct)) => {\n@@ -622,10 +622,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .iter()\n             .map(|binding| {\n                 let kind = match binding.kind {\n-                    hir::TypeBindingKind::Equality { ref ty } => {\n+                    hir::TypeBindingKind::Equality { ty } => {\n                         ConvertedBindingKind::Equality(self.ast_ty_to_ty(ty))\n                     }\n-                    hir::TypeBindingKind::Constraint { ref bounds } => {\n+                    hir::TypeBindingKind::Constraint { bounds } => {\n                         ConvertedBindingKind::Constraint(bounds)\n                     }\n                 };\n@@ -908,18 +908,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if let Some((self_ty, where_clause)) = self_ty_where_predicates {\n             let self_ty_def_id = tcx.hir().local_def_id(self_ty).to_def_id();\n             for clause in where_clause {\n-                match clause {\n-                    hir::WherePredicate::BoundPredicate(pred) => {\n-                        match pred.bounded_ty.kind {\n-                            hir::TyKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n-                                Res::Def(DefKind::TyParam, def_id) if def_id == self_ty_def_id => {}\n-                                _ => continue,\n-                            },\n+                if let hir::WherePredicate::BoundPredicate(pred) = clause {\n+                    match pred.bounded_ty.kind {\n+                        hir::TyKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n+                            Res::Def(DefKind::TyParam, def_id) if def_id == self_ty_def_id => {}\n                             _ => continue,\n-                        }\n-                        search_bounds(pred.bounds);\n+                        },\n+                        _ => continue,\n                     }\n-                    _ => {}\n+                    search_bounds(pred.bounds);\n                 }\n             }\n         }\n@@ -1030,7 +1027,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         param_ty: Ty<'tcx>,\n         ast_bounds: &[hir::GenericBound<'_>],\n     ) -> Bounds<'tcx> {\n-        self.compute_bounds_inner(param_ty, &ast_bounds)\n+        self.compute_bounds_inner(param_ty, ast_bounds)\n     }\n \n     /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n@@ -1231,7 +1228,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         match binding.kind {\n-            ConvertedBindingKind::Equality(ref ty) => {\n+            ConvertedBindingKind::Equality(ty) => {\n                 // \"Desugar\" a constraint like `T: Iterator<Item = u32>` this to\n                 // the \"projection predicate\" for:\n                 //\n@@ -2207,7 +2204,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n \n                 let path_segs =\n-                    self.def_ids_for_value_path_segments(&path.segments, None, kind, def_id);\n+                    self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n                 self.prohibit_generics(path.segments.iter().enumerate().filter_map(\n@@ -2304,42 +2301,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n \n         let result_ty = match ast_ty.kind {\n-            hir::TyKind::Slice(ref ty) => tcx.mk_slice(self.ast_ty_to_ty(&ty)),\n+            hir::TyKind::Slice(ref ty) => tcx.mk_slice(self.ast_ty_to_ty(ty)),\n             hir::TyKind::Ptr(ref mt) => {\n-                tcx.mk_ptr(ty::TypeAndMut { ty: self.ast_ty_to_ty(&mt.ty), mutbl: mt.mutbl })\n+                tcx.mk_ptr(ty::TypeAndMut { ty: self.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl })\n             }\n             hir::TyKind::Rptr(ref region, ref mt) => {\n                 let r = self.ast_region_to_region(region, None);\n                 debug!(?r);\n-                let t = self.ast_ty_to_ty_inner(&mt.ty, true);\n+                let t = self.ast_ty_to_ty_inner(mt.ty, true);\n                 tcx.mk_ref(r, ty::TypeAndMut { ty: t, mutbl: mt.mutbl })\n             }\n             hir::TyKind::Never => tcx.types.never,\n-            hir::TyKind::Tup(ref fields) => {\n-                tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(&t)))\n-            }\n-            hir::TyKind::BareFn(ref bf) => {\n-                require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n+            hir::TyKind::Tup(fields) => tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(t))),\n+            hir::TyKind::BareFn(bf) => {\n+                require_c_abi_if_c_variadic(tcx, bf.decl, bf.abi, ast_ty.span);\n \n                 tcx.mk_fn_ptr(self.ty_of_fn(\n                     ast_ty.hir_id,\n                     bf.unsafety,\n                     bf.abi,\n-                    &bf.decl,\n+                    bf.decl,\n                     &hir::Generics::empty(),\n                     None,\n                     Some(ast_ty),\n                 ))\n             }\n-            hir::TyKind::TraitObject(ref bounds, ref lifetime, _) => {\n+            hir::TyKind::TraitObject(bounds, ref lifetime, _) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime, borrowed)\n             }\n             hir::TyKind::Path(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n                 debug!(?maybe_qself, ?path);\n                 let opt_self_ty = maybe_qself.as_ref().map(|qself| self.ast_ty_to_ty(qself));\n                 self.res_to_ty(opt_self_ty, path, false)\n             }\n-            hir::TyKind::OpaqueDef(item_id, ref lifetimes) => {\n+            hir::TyKind::OpaqueDef(item_id, lifetimes) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n                 let def_id = item_id.def_id.to_def_id();\n \n@@ -2354,7 +2349,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = qself.kind {\n                     path.res\n                 } else {\n                     Res::Err\n@@ -2379,7 +2374,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.hir_id);\n                 let length = ty::Const::from_anon_const(tcx, length_def_id);\n-                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n+                let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n             hir::TyKind::Typeof(ref e) => {\n@@ -2485,7 +2480,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         let input_tys = decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n         let output_ty = match decl.output {\n-            hir::FnRetTy::Return(ref output) => {\n+            hir::FnRetTy::Return(output) => {\n                 visitor.visit_ty(output);\n                 self.ast_ty_to_ty(output)\n             }"}, {"sha": "dc54f63f49c8d5de61bab688283bf2a64bea008d", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -28,7 +28,7 @@ struct ConfirmContext<'a, 'tcx> {\n impl<'a, 'tcx> Deref for ConfirmContext<'a, 'tcx> {\n     type Target = FnCtxt<'a, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n-        &self.fcx\n+        self.fcx\n     }\n }\n \n@@ -290,7 +290,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             .autoderef(self.span, self_ty)\n             .include_raw_pointers()\n             .find_map(|(ty, _)| match ty.kind() {\n-                ty::Dynamic(ref data, ..) => Some(closure(\n+                ty::Dynamic(data, ..) => Some(closure(\n                     self,\n                     ty,\n                     data.principal().unwrap_or_else(|| {\n@@ -323,7 +323,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             self.tcx,\n             self.span,\n             pick.item.def_id,\n-            &generics,\n+            generics,\n             seg,\n             IsMethodCall::Yes,\n         );\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 def_id: DefId,\n             ) -> (Option<&'a hir::GenericArgs<'a>>, bool) {\n                 if def_id == self.pick.item.def_id {\n-                    if let Some(ref data) = self.seg.args {\n+                    if let Some(data) = self.seg.args {\n                         return (Some(data), false);\n                     }\n                 }"}, {"sha": "65b3ceb869802731898acb89a8d23fed4a9d26ea", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -160,7 +160,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .unwrap_or(0);\n \n         // Account for `foo.bar<T>`;\n-        let sugg_span = span.unwrap_or_else(|| call_expr.span).shrink_to_hi();\n+        let sugg_span = span.unwrap_or(call_expr.span).shrink_to_hi();\n         let (suggestion, applicability) = (\n             format!(\"({})\", (0..params).map(|_| \"_\").collect::<Vec<_>>().join(\", \")),\n             if params > 0 { Applicability::HasPlaceholders } else { Applicability::MaybeIncorrect },\n@@ -320,7 +320,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 GenericParamDefKind::Type { .. } => {\n                     if param.index == 0 {\n                         return self_ty.into();\n-                    } else if let Some(ref input_types) = opt_input_types {\n+                    } else if let Some(input_types) = opt_input_types {\n                         return input_types[param.index as usize - 1].into();\n                     }\n                 }"}, {"sha": "9d6db32be63a4a3148a9cec18f41e16a90546f7c", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -88,7 +88,7 @@ struct ProbeContext<'a, 'tcx> {\n impl<'a, 'tcx> Deref for ProbeContext<'a, 'tcx> {\n     type Target = FnCtxt<'a, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n-        &self.fcx\n+        self.fcx\n     }\n }\n \n@@ -614,7 +614,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         let lang_items = self.tcx.lang_items();\n \n         match *self_ty.value.value.kind() {\n-            ty::Dynamic(ref data, ..) if let Some(p) = data.principal() => {\n+            ty::Dynamic(data, ..) if let Some(p) = data.principal() => {\n                 // Subtle: we can't use `instantiate_query_response` here: using it will\n                 // commit to all of the type equalities assumed by inference going through\n                 // autoderef (see the `method-probe-no-guessing` test).\n@@ -634,7 +634,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // type variables in any form, so just do that!\n                 let (QueryResponse { value: generalized_self_ty, .. }, _ignored_var_values) =\n                     self.fcx\n-                        .instantiate_canonical_with_fresh_inference_vars(self.span, &self_ty);\n+                        .instantiate_canonical_with_fresh_inference_vars(self.span, self_ty);\n \n                 self.assemble_inherent_candidates_from_object(generalized_self_ty);\n                 self.assemble_inherent_impl_candidates_for_type(p.def_id());\n@@ -1428,7 +1428,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             // match as well (or at least may match, sometimes we\n             // don't have enough information to fully evaluate).\n             match probe.kind {\n-                InherentImplCandidate(ref substs, ref ref_obligations) => {\n+                InherentImplCandidate(substs, ref ref_obligations) => {\n                     // Check whether the impl imposes obligations we have to worry about.\n                     let impl_def_id = probe.item.container.id();\n                     let impl_bounds = self.tcx.predicates_of(impl_def_id);"}, {"sha": "fd9599f55f834c45dbae8a95cdcefe1b703e709d", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 49, "deletions": 60, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -328,48 +328,44 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            ExprKind::Path(ref qpath) => {\n+                            ExprKind::Path(QPath::Resolved(_, path)) => {\n                                 // local binding\n-                                if let QPath::Resolved(_, path) = qpath {\n-                                    if let hir::def::Res::Local(hir_id) = path.res {\n-                                        let span = tcx.hir().span(hir_id);\n-                                        let snippet = tcx.sess.source_map().span_to_snippet(span);\n-                                        let filename = tcx.sess.source_map().span_to_filename(span);\n-\n-                                        let parent_node = self\n-                                            .tcx\n-                                            .hir()\n-                                            .get(self.tcx.hir().get_parent_node(hir_id));\n-                                        let msg = format!(\n-                                            \"you must specify a type for this binding, like `{}`\",\n-                                            concrete_type,\n-                                        );\n-\n-                                        match (filename, parent_node, snippet) {\n-                                            (\n-                                                FileName::Real(_),\n-                                                Node::Local(hir::Local {\n-                                                    source: hir::LocalSource::Normal,\n-                                                    ty,\n-                                                    ..\n-                                                }),\n-                                                Ok(ref snippet),\n-                                            ) => {\n-                                                err.span_suggestion(\n-                                                    // account for `let x: _ = 42;`\n-                                                    //                  ^^^^\n-                                                    span.to(ty\n-                                                        .as_ref()\n-                                                        .map(|ty| ty.span)\n-                                                        .unwrap_or(span)),\n-                                                    &msg,\n-                                                    format!(\"{}: {}\", snippet, concrete_type),\n-                                                    Applicability::MaybeIncorrect,\n-                                                );\n-                                            }\n-                                            _ => {\n-                                                err.span_label(span, msg);\n-                                            }\n+                                if let hir::def::Res::Local(hir_id) = path.res {\n+                                    let span = tcx.hir().span(hir_id);\n+                                    let snippet = tcx.sess.source_map().span_to_snippet(span);\n+                                    let filename = tcx.sess.source_map().span_to_filename(span);\n+\n+                                    let parent_node =\n+                                        self.tcx.hir().get(self.tcx.hir().get_parent_node(hir_id));\n+                                    let msg = format!(\n+                                        \"you must specify a type for this binding, like `{}`\",\n+                                        concrete_type,\n+                                    );\n+\n+                                    match (filename, parent_node, snippet) {\n+                                        (\n+                                            FileName::Real(_),\n+                                            Node::Local(hir::Local {\n+                                                source: hir::LocalSource::Normal,\n+                                                ty,\n+                                                ..\n+                                            }),\n+                                            Ok(ref snippet),\n+                                        ) => {\n+                                            err.span_suggestion(\n+                                                // account for `let x: _ = 42;`\n+                                                //                  ^^^^\n+                                                span.to(ty\n+                                                    .as_ref()\n+                                                    .map(|ty| ty.span)\n+                                                    .unwrap_or(span)),\n+                                                &msg,\n+                                                format!(\"{}: {}\", snippet, concrete_type),\n+                                                Applicability::MaybeIncorrect,\n+                                            );\n+                                        }\n+                                        _ => {\n+                                            err.span_label(span, msg);\n                                         }\n                                     }\n                                 }\n@@ -383,11 +379,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                         // Don't show generic arguments when the method can't be found in any implementation (#81576).\n                         let mut ty_str_reported = ty_str.clone();\n-                        if let ty::Adt(_, ref generics) = actual.kind() {\n+                        if let ty::Adt(_, generics) = actual.kind() {\n                             if generics.len() > 0 {\n                                 let mut autoderef = self.autoderef(span, actual);\n                                 let candidate_found = autoderef.any(|(ty, _)| {\n-                                    if let ty::Adt(ref adt_deref, _) = ty.kind() {\n+                                    if let ty::Adt(adt_deref, _) = ty.kind() {\n                                         self.tcx\n                                             .inherent_impls(adt_deref.did)\n                                             .iter()\n@@ -482,7 +478,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut label_span_not_found = || {\n                     if unsatisfied_predicates.is_empty() {\n                         err.span_label(span, format!(\"{item_kind} not found in `{ty_str}`\"));\n-                        if let ty::Adt(ref adt, _) = rcvr_ty.kind() {\n+                        if let ty::Adt(adt, _) = rcvr_ty.kind() {\n                             let mut inherent_impls_candidate = self\n                                 .tcx\n                                 .inherent_impls(adt.did)\n@@ -511,7 +507,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     }\n                                 })\n                                 .collect::<Vec<_>>();\n-                            if inherent_impls_candidate.len() > 0 {\n+                            if !inherent_impls_candidate.is_empty() {\n                                 inherent_impls_candidate.sort();\n                                 inherent_impls_candidate.dedup();\n \n@@ -565,7 +561,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n \n                         if is_accessible {\n-                            if self.is_fn_ty(&field_ty, span) {\n+                            if self.is_fn_ty(field_ty, span) {\n                                 let expr_span = expr.span.to(item_name.span);\n                                 err.multipart_suggestion(\n                                     &format!(\n@@ -605,7 +601,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     label_span_not_found();\n                 }\n \n-                if self.is_fn_ty(&rcvr_ty, span) {\n+                if self.is_fn_ty(rcvr_ty, span) {\n                     fn report_function<T: std::fmt::Display>(\n                         err: &mut DiagnosticBuilder<'_>,\n                         name: T,\n@@ -618,7 +614,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if let SelfSource::MethodCall(expr) = source {\n                         if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function(&mut err, expr_string);\n-                        } else if let ExprKind::Path(QPath::Resolved(_, ref path)) = expr.kind {\n+                        } else if let ExprKind::Path(QPath::Resolved(_, path)) = expr.kind {\n                             if let Some(segment) = path.segments.last() {\n                                 report_function(&mut err, segment.ident);\n                             }\n@@ -808,7 +804,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n \n-                    bound_list.sort_by(|(_, a), (_, b)| a.cmp(&b)); // Sort alphabetically.\n+                    bound_list.sort_by(|(_, a), (_, b)| a.cmp(b)); // Sort alphabetically.\n                     bound_list.dedup_by(|(_, a), (_, b)| a == b); // #35677\n                     bound_list.sort_by_key(|(pos, _)| *pos); // Keep the original predicate order.\n                     bound_spans.sort();\n@@ -1007,12 +1003,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if adt_def.did.is_local() {\n                     let diagnostic_items = self.tcx.diagnostic_items(trait_ref.def_id.krate);\n                     return derivables.iter().find_map(|trait_derivable| {\n-                        let item_def_id =\n-                            if let Some(item_def_id) = diagnostic_items.get(trait_derivable) {\n-                                item_def_id\n-                            } else {\n-                                return None;\n-                            };\n+                        let item_def_id = diagnostic_items.get(trait_derivable)?;\n                         if item_def_id == &trait_pred.trait_ref.def_id\n                             && !(adt_def.is_enum() && *trait_derivable == sym::Default)\n                         {\n@@ -1371,9 +1362,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n             };\n             // Obtain the span for `param` and use it for a structured suggestion.\n-            if let (Some(ref param), Some(ref table)) =\n-                (param_type, self.in_progress_typeck_results)\n-            {\n+            if let (Some(param), Some(table)) = (param_type, self.in_progress_typeck_results) {\n                 let table_owner = table.borrow().hir_owner;\n                 let generics = self.tcx.generics_of(table_owner.to_def_id());\n                 let type_param = generics.type_param(param, self.tcx);\n@@ -1384,7 +1373,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                     // instead we suggest `T: Foo + Bar` in that case.\n                     match hir.get(id) {\n-                        Node::GenericParam(ref param) => {\n+                        Node::GenericParam(param) => {\n                             let mut impl_trait = false;\n                             let has_bounds =\n                                 if let hir::GenericParamKind::Type { synthetic: Some(_), .. } =\n@@ -1558,7 +1547,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind() {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n-                ty::Dynamic(ref tr, ..) => tr.principal().map_or(false, |d| d.def_id().is_local()),\n+                ty::Dynamic(tr, ..) => tr.principal().map_or(false, |d| d.def_id().is_local()),\n                 ty::Param(_) => true,\n \n                 // Everything else (primitive types, etc.) is effectively"}, {"sha": "7450b4a4ef1c3f23c0f1554a044f9c6b708df1b4", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -271,22 +271,22 @@ fn primary_body_of(\n ) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {\n-            hir::ItemKind::Const(ref ty, body) | hir::ItemKind::Static(ref ty, _, body) => {\n+            hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n                 Some((body, Some(ty), None))\n             }\n-            hir::ItemKind::Fn(ref sig, .., body) => Some((body, None, Some(&sig))),\n+            hir::ItemKind::Fn(ref sig, .., body) => Some((body, None, Some(sig))),\n             _ => None,\n         },\n         Node::TraitItem(item) => match item.kind {\n-            hir::TraitItemKind::Const(ref ty, Some(body)) => Some((body, Some(ty), None)),\n+            hir::TraitItemKind::Const(ty, Some(body)) => Some((body, Some(ty), None)),\n             hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n-                Some((body, None, Some(&sig)))\n+                Some((body, None, Some(sig)))\n             }\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Const(ref ty, body) => Some((body, Some(ty), None)),\n-            hir::ImplItemKind::Fn(ref sig, body) => Some((body, None, Some(&sig))),\n+            hir::ImplItemKind::Const(ty, body) => Some((body, Some(ty), None)),\n+            hir::ImplItemKind::Fn(ref sig, body) => Some((body, None, Some(sig))),\n             _ => None,\n         },\n         Node::AnonConst(constant) => Some((constant.body, None, None)),\n@@ -555,16 +555,13 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt<'_>, id: LocalDefId, span: S\n     // `#[link_section]` may contain arbitrary, or even undefined bytes, but it is\n     // the consumer's responsibility to ensure all bytes that have been read\n     // have defined values.\n-    match tcx.eval_static_initializer(id.to_def_id()) {\n-        Ok(alloc) => {\n-            if alloc.relocations().len() != 0 {\n-                let msg = \"statics with a custom `#[link_section]` must be a \\\n+    if let Ok(alloc) = tcx.eval_static_initializer(id.to_def_id()) {\n+        if alloc.relocations().len() != 0 {\n+            let msg = \"statics with a custom `#[link_section]` must be a \\\n                            simple list of bytes on the wasm target with no \\\n                            extra levels of indirection such as references\";\n-                tcx.sess.span_err(span, msg);\n-            }\n+            tcx.sess.span_err(span, msg);\n         }\n-        Err(_) => {}\n     }\n }\n \n@@ -631,7 +628,7 @@ fn missing_items_err(\n     let padding: String = \" \".repeat(indentation);\n \n     for trait_item in missing_items {\n-        let snippet = suggestion_signature(&trait_item, tcx);\n+        let snippet = suggestion_signature(trait_item, tcx);\n         let code = format!(\"{}{}\\n{}\", padding, snippet, padding);\n         let msg = format!(\"implement the missing item: `{}`\", snippet);\n         let appl = Applicability::HasPlaceholders;"}, {"sha": "d684a18d5cbc0f6d5a3b2d2727acd35bd8f6603f", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -444,7 +444,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // Check if the method would be found if the type param wasn't\n                             // involved. If so, it means that adding a trait bound to the param is\n                             // enough. Otherwise we do not give the suggestion.\n-                            let mut eraser = TypeParamEraser(&self, expr.span);\n+                            let mut eraser = TypeParamEraser(self, expr.span);\n                             let needs_bound = self\n                                 .lookup_op_method(\n                                     eraser.fold_ty(lhs_ty),\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             bug!(\"type param visitor stored a non type param: {:?}\", ty.kind());\n                         }\n                     } else if !suggested_deref && !involves_fn {\n-                        suggest_impl_missing(&mut err, lhs_ty, &missing_trait);\n+                        suggest_impl_missing(&mut err, lhs_ty, missing_trait);\n                     }\n                 }\n                 err.emit();\n@@ -718,14 +718,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 }\n                             }\n                             Str | Never | Char | Tuple(_) | Array(_, _) => {}\n-                            Ref(_, ref lty, _) if *lty.kind() == Str => {}\n+                            Ref(_, lty, _) if *lty.kind() == Str => {}\n                             _ => {\n                                 let missing_trait = match op {\n                                     hir::UnOp::Neg => \"std::ops::Neg\",\n                                     hir::UnOp::Not => \"std::ops::Not\",\n                                     hir::UnOp::Deref => \"std::ops::UnDerf\",\n                                 };\n-                                suggest_impl_missing(&mut err, operand_ty, &missing_trait);\n+                                suggest_impl_missing(&mut err, operand_ty, missing_trait);\n                             }\n                         }\n                     }"}, {"sha": "0650291bacb102f8b4373f746abe607029c2b944", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected: Ty<'tcx>,\n         mut def_bm: BindingMode,\n     ) -> (Ty<'tcx>, BindingMode) {\n-        let mut expected = self.resolve_vars_with_obligations(&expected);\n+        let mut expected = self.resolve_vars_with_obligations(expected);\n \n         // Peel off as many `&` or `&mut` from the scrutinee type as possible. For example,\n         // for `match &&&mut Some(5)` the loop runs three times, aborting when it reaches\n@@ -587,7 +587,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(&p, expected, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n+            self.check_pat(p, expected, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n         }\n \n         local_ty\n@@ -697,8 +697,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             let err = self.tcx.ty_error();\n             for field in fields {\n-                let ti = TopInfo { parent_pat: Some(&pat), ..ti };\n-                self.check_pat(&field.pat, err, def_bm, ti);\n+                let ti = TopInfo { parent_pat: Some(pat), ..ti };\n+                self.check_pat(field.pat, err, def_bm, ti);\n             }\n             return err;\n         };\n@@ -707,7 +707,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.demand_eqtype_pat(pat.span, expected, pat_ty, ti);\n \n         // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, &pat, variant, fields, etc, def_bm, ti) {\n+        if self.check_struct_pat_fields(pat_ty, pat, variant, fields, etc, def_bm, ti) {\n             pat_ty\n         } else {\n             self.tcx.ty_error()\n@@ -876,7 +876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let on_error = || {\n             let parent_pat = Some(pat);\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.ty_error(), def_bm, TopInfo { parent_pat, ..ti });\n+                self.check_pat(pat, tcx.ty_error(), def_bm, TopInfo { parent_pat, ..ti });\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -961,7 +961,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n+                self.check_pat(subpat, field_ty, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n \n                 self.tcx.check_stability(\n                     variant.fields[i].did,\n@@ -1151,7 +1151,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut expected_len = elements.len();\n         if ddpos.is_some() {\n             // Require known type only when `..` is present.\n-            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).kind() {\n+            if let ty::Tuple(tys) = self.structurally_resolved_type(span, expected).kind() {\n                 expected_len = tys.len();\n             }\n         }\n@@ -1172,12 +1172,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // further errors being emitted when using the bindings. #50333\n             let element_tys_iter = (0..max_len).map(|_| tcx.ty_error());\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &tcx.ty_error(), def_bm, ti);\n+                self.check_pat(elem, tcx.ty_error(), def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, ti);\n+                self.check_pat(elem, element_tys[i].expect_ty(), def_bm, ti);\n             }\n             pat_ty\n         }\n@@ -1240,14 +1240,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n+            self.check_pat(field.pat, field_ty, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n         }\n \n         let mut unmentioned_fields = variant\n             .fields\n             .iter()\n             .map(|field| (field, field.ident.normalize_to_macros_2_0()))\n-            .filter(|(_, ident)| !used_fields.contains_key(&ident))\n+            .filter(|(_, ident)| !used_fields.contains_key(ident))\n             .collect::<Vec<_>>();\n \n         let inexistent_fields_err = if !(inexistent_fields.is_empty() || variant.is_recovered()) {\n@@ -1290,13 +1290,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.non_exhaustive_reachable_pattern(pat, &accessible_unmentioned_fields, adt_ty)\n             } else if !etc {\n                 if accessible_unmentioned_fields.is_empty() {\n-                    unmentioned_err = Some(self.error_no_accessible_fields(pat, &fields));\n+                    unmentioned_err = Some(self.error_no_accessible_fields(pat, fields));\n                 } else {\n                     unmentioned_err = Some(self.error_unmentioned_fields(\n                         pat,\n                         &accessible_unmentioned_fields,\n                         accessible_unmentioned_fields.len() != unmentioned_fields.len(),\n-                        &fields,\n+                        fields,\n                     ));\n                 }\n             }\n@@ -1763,7 +1763,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, &inner) {\n+        let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, inner) {\n             // Here, `demand::subtype` is good enough, but I don't\n             // think any errors can be introduced by using `demand::eqtype`.\n             let inner_ty = self.next_ty_var(TypeVariableOrigin {\n@@ -1777,7 +1777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let err = tcx.ty_error();\n             (err, err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, ti);\n+        self.check_pat(inner, inner_ty, def_bm, ti);\n         box_ty\n     }\n \n@@ -1792,7 +1792,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n-        let (rptr_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, &inner) {\n+        let (rptr_ty, inner_ty) = if self.check_dereferenceable(pat.span, expected, inner) {\n             // `demand::subtype` would be good enough, but using `eqtype` turns\n             // out to be equally general. See (note_1) for details.\n \n@@ -1814,7 +1814,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Look for a case like `fn foo(&foo: u32)` and suggest\n                     // `fn foo(foo: &u32)`\n                     if let Some(mut err) = err {\n-                        self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n+                        self.borrow_pat_suggestion(&mut err, pat, inner, expected);\n                         err.emit();\n                     }\n                     (rptr_ty, inner_ty)\n@@ -1824,7 +1824,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let err = tcx.ty_error();\n             (err, err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, TopInfo { parent_pat: Some(&pat), ..ti });\n+        self.check_pat(inner, inner_ty, def_bm, TopInfo { parent_pat: Some(pat), ..ti });\n         rptr_ty\n     }\n \n@@ -1880,15 +1880,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type check all the patterns before `slice`.\n         for elt in before {\n-            self.check_pat(&elt, element_ty, def_bm, ti);\n+            self.check_pat(elt, element_ty, def_bm, ti);\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n-            self.check_pat(&slice, opt_slice_ty.unwrap(), def_bm, ti);\n+            self.check_pat(slice, opt_slice_ty.unwrap(), def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n-            self.check_pat(&elt, element_ty, def_bm, ti);\n+            self.check_pat(elt, element_ty, def_bm, ti);\n         }\n         inferred\n     }"}, {"sha": "7cd7fc1681f8577cfc4c90b03aeb3e1c1bb9d0a9", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         | hir::ExprKind::Index(ref expr, _)\n         | hir::ExprKind::Unary(hir::UnOp::Deref, ref expr) = exprs.last().unwrap().kind\n         {\n-            exprs.push(&expr);\n+            exprs.push(expr);\n         }\n \n         debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n@@ -350,10 +350,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n \n             match expr.kind {\n-                hir::ExprKind::Index(ref base_expr, ..) => {\n+                hir::ExprKind::Index(base_expr, ..) => {\n                     self.convert_place_op_to_mutable(PlaceOp::Index, expr, base_expr);\n                 }\n-                hir::ExprKind::Unary(hir::UnOp::Deref, ref base_expr) => {\n+                hir::ExprKind::Unary(hir::UnOp::Deref, base_expr) => {\n                     self.convert_place_op_to_mutable(PlaceOp::Deref, expr, base_expr);\n                 }\n                 _ => {}"}, {"sha": "693246a3433e0cdb618115a212c9313b5cd6a0fe", "filename": "compiler/rustc_typeck/src/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fregionck.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -190,7 +190,7 @@ pub struct RegionCtxt<'a, 'tcx> {\n impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n     type Target = FnCtxt<'a, 'tcx>;\n     fn deref(&self) -> &Self::Target {\n-        &self.fcx\n+        self.fcx\n     }\n }\n \n@@ -292,7 +292,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         self.outlives_environment.add_implied_bounds(self.fcx, fn_sig_tys, body_id.hir_id, span);\n         self.outlives_environment.save_implied_bounds(body_id.hir_id);\n-        self.link_fn_params(&body.params);\n+        self.link_fn_params(body.params);\n         self.visit_body(body);\n         self.visit_region_obligations(body_id.hir_id);\n \n@@ -379,13 +379,13 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n     fn visit_arm(&mut self, arm: &'tcx hir::Arm<'tcx>) {\n         // see above\n-        self.constrain_bindings_in_pat(&arm.pat);\n+        self.constrain_bindings_in_pat(arm.pat);\n         intravisit::walk_arm(self, arm);\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n         // see above\n-        self.constrain_bindings_in_pat(&l.pat);\n+        self.constrain_bindings_in_pat(l.pat);\n         self.link_local(l);\n         intravisit::walk_local(self, l);\n     }\n@@ -407,13 +407,13 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionCtxt<'a, 'tcx> {\n \n         match expr.kind {\n             hir::ExprKind::AddrOf(hir::BorrowKind::Ref, m, ref base) => {\n-                self.link_addr_of(expr, m, &base);\n+                self.link_addr_of(expr, m, base);\n \n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::Match(ref discr, ref arms, _) => {\n-                self.link_match(&discr, &arms[..]);\n+            hir::ExprKind::Match(ref discr, arms, _) => {\n+                self.link_match(discr, &arms[..]);\n \n                 intravisit::walk_expr(self, expr);\n             }\n@@ -448,7 +448,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         let mut place = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n \n         let typeck_results = self.typeck_results.borrow();\n-        let adjustments = typeck_results.expr_adjustments(&expr);\n+        let adjustments = typeck_results.expr_adjustments(expr);\n         if adjustments.is_empty() {\n             return Ok(place);\n         }\n@@ -475,7 +475,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                 self.link_autoref(expr, &place, autoref);\n             }\n \n-            place = self.with_mc(|mc| mc.cat_expr_adjusted(expr, place, &adjustment))?;\n+            place = self.with_mc(|mc| mc.cat_expr_adjusted(expr, place, adjustment))?;\n         }\n \n         Ok(place)\n@@ -540,10 +540,10 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             None => {\n                 return;\n             }\n-            Some(ref expr) => &**expr,\n+            Some(expr) => &*expr,\n         };\n         let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n-        self.link_pattern(discr_cmt, &local.pat);\n+        self.link_pattern(discr_cmt, local.pat);\n     }\n \n     /// Computes the guarantors for any ref bindings in a match and\n@@ -554,7 +554,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n-            self.link_pattern(discr_cmt.clone(), &arm.pat);\n+            self.link_pattern(discr_cmt.clone(), arm.pat);\n         }\n     }\n \n@@ -567,7 +567,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             let param_cmt =\n                 self.with_mc(|mc| mc.cat_rvalue(param.hir_id, param.pat.span, param_ty));\n             debug!(\"param_ty={:?} param_cmt={:?} param={:?}\", param_ty, param_cmt, param);\n-            self.link_pattern(param_cmt, &param.pat);\n+            self.link_pattern(param_cmt, param.pat);\n         }\n     }\n \n@@ -582,7 +582,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n                     if let Some(ty::BindByReference(mutbl)) =\n                         mc.typeck_results.extract_binding_mode(self.tcx.sess, *hir_id, *span)\n                     {\n-                        self.link_region_from_node_type(*span, *hir_id, mutbl, &sub_cmt);\n+                        self.link_region_from_node_type(*span, *hir_id, mutbl, sub_cmt);\n                     }\n                 }\n             })"}, {"sha": "56547c82baf48fe5ace3981d96456a994d05e80e", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -790,7 +790,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // This is a multi-line closure with just a `{` on the first line,\n                             // so we put the `let` on its own line.\n                             // We take the indentation from the next non-empty line.\n-                            let line2 = lines.filter(|line| !line.is_empty()).next().unwrap_or_default();\n+                            let line2 = lines.find(|line| !line.is_empty()).unwrap_or_default();\n                             let indent = line2.split_once(|c: char| !c.is_whitespace()).unwrap_or_default().0;\n                             diagnostics_builder.span_suggestion(\n                                 closure_body_span.with_lo(closure_body_span.lo() + BytePos::from_usize(line1.len())).shrink_to_lo(),\n@@ -844,14 +844,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> String {\n         let mut reasons = String::new();\n \n-        if auto_trait_reasons.len() > 0 {\n+        if !auto_trait_reasons.is_empty() {\n             reasons = format!(\n                 \"{} trait implementation for closure\",\n                 auto_trait_reasons.clone().into_iter().collect::<Vec<&str>>().join(\", \")\n             );\n         }\n \n-        if auto_trait_reasons.len() > 0 && drop_reason {\n+        if !auto_trait_reasons.is_empty() && drop_reason {\n             reasons = format!(\"{} and \", reasons);\n         }\n \n@@ -885,13 +885,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let auto_traits =\n             vec![\"`Clone`\", \"`Sync`\", \"`Send`\", \"`Unpin`\", \"`UnwindSafe`\", \"`RefUnwindSafe`\"];\n \n-        let root_var_min_capture_list = if let Some(root_var_min_capture_list) =\n-            min_captures.and_then(|m| m.get(&var_hir_id))\n-        {\n-            root_var_min_capture_list\n-        } else {\n-            return None;\n-        };\n+        let root_var_min_capture_list = min_captures.and_then(|m| m.get(&var_hir_id))?;\n \n         let ty = self.infcx.resolve_vars_if_possible(self.node_ty(var_hir_id));\n \n@@ -966,14 +960,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            if capture_problems.len() > 0 {\n+            if !capture_problems.is_empty() {\n                 problematic_captures.insert(\n                     (capture.info.path_expr_id, capture.to_string(self.tcx)),\n                     capture_problems,\n                 );\n             }\n         }\n-        if problematic_captures.len() > 0 {\n+        if !problematic_captures.is_empty() {\n             return Some(problematic_captures);\n         }\n         None\n@@ -1042,7 +1036,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_moved = !projections_list.is_empty();\n \n         let is_not_completely_captured =\n-            root_var_min_capture_list.iter().any(|capture| capture.place.projections.len() > 0);\n+            root_var_min_capture_list.iter().any(|capture| !capture.place.projections.is_empty());\n \n         if is_moved\n             && is_not_completely_captured\n@@ -1056,7 +1050,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return Some(diagnostics_info);\n         }\n \n-        return None;\n+        None\n     }\n \n     /// Figures out the list of root variables (and their types) that aren't completely\n@@ -1152,7 +1146,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ));\n             }\n \n-            if capture_diagnostic.len() > 0 {\n+            if !capture_diagnostic.is_empty() {\n                 need_migrations.push((var_hir_id, responsible_captured_hir_ids));\n             }\n         }\n@@ -1857,10 +1851,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId) {\n         if !self.capture_information.contains_key(&place_with_id.place) {\n-            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n+            self.init_capture_info_for_place(place_with_id, diag_expr_id);\n         }\n \n-        self.adjust_upvar_borrow_kind_for_consume(&place_with_id, diag_expr_id);\n+        self.adjust_upvar_borrow_kind_for_consume(place_with_id, diag_expr_id);\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -1997,7 +1991,7 @@ fn restrict_capture_precision<'tcx>(\n         }\n     }\n \n-    return (place, curr_mode);\n+    (place, curr_mode)\n }\n \n /// Truncate deref of any reference.\n@@ -2066,7 +2060,7 @@ fn construct_capture_kind_reason_string(\n     place: &Place<'tcx>,\n     capture_info: &ty::CaptureInfo<'tcx>,\n ) -> String {\n-    let place_str = construct_place_string(tcx, &place);\n+    let place_str = construct_place_string(tcx, place);\n \n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),\n@@ -2077,7 +2071,7 @@ fn construct_capture_kind_reason_string(\n }\n \n fn construct_path_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n-    let place_str = construct_place_string(tcx, &place);\n+    let place_str = construct_place_string(tcx, place);\n \n     format!(\"{} used here\", place_str)\n }\n@@ -2087,7 +2081,7 @@ fn construct_capture_info_string(\n     place: &Place<'tcx>,\n     capture_info: &ty::CaptureInfo<'tcx>,\n ) -> String {\n-    let place_str = construct_place_string(tcx, &place);\n+    let place_str = construct_place_string(tcx, place);\n \n     let capture_kind_str = match capture_info.capture_kind {\n         ty::UpvarCapture::ByValue(_) => \"ByValue\".into(),"}, {"sha": "20cf9a75e1267f94d28291768221c76cd2ee3e54", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -144,20 +144,20 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         hir::ItemKind::Fn(ref sig, ..) => {\n             check_item_fn(tcx, item.hir_id(), item.ident, item.span, sig.decl);\n         }\n-        hir::ItemKind::Static(ref ty, ..) => {\n+        hir::ItemKind::Static(ty, ..) => {\n             check_item_type(tcx, item.hir_id(), ty.span, false);\n         }\n-        hir::ItemKind::Const(ref ty, ..) => {\n+        hir::ItemKind::Const(ty, ..) => {\n             check_item_type(tcx, item.hir_id(), ty.span, false);\n         }\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for it in items.iter() {\n                 let it = tcx.hir().foreign_item(it.id);\n                 match it.kind {\n-                    hir::ForeignItemKind::Fn(ref decl, ..) => {\n+                    hir::ForeignItemKind::Fn(decl, ..) => {\n                         check_item_fn(tcx, it.hir_id(), it.ident, it.span, decl)\n                     }\n-                    hir::ForeignItemKind::Static(ref ty, ..) => {\n+                    hir::ForeignItemKind::Static(ty, ..) => {\n                         check_item_type(tcx, it.hir_id(), ty.span, true)\n                     }\n                     hir::ForeignItemKind::Type => (),\n@@ -198,7 +198,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         hir::TraitItemKind::Type(_bounds, Some(ty)) => (None, ty.span),\n         _ => (None, trait_item.span),\n     };\n-    check_object_unsafe_self_trait_by_name(tcx, &trait_item);\n+    check_object_unsafe_self_trait_by_name(tcx, trait_item);\n     check_associated_item(tcx, trait_item.hir_id(), span, method_sig);\n \n     let encl_trait_hir_id = tcx.hir().get_parent_item(hir_id);\n@@ -218,7 +218,7 @@ pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         // We are looking at the `call` function of the `fn` or `fn_mut` lang item.\n         // Do some rudimentary sanity checking to avoid an ICE later (issue #83471).\n         if let Some(hir::FnSig { decl, span, .. }) = method_sig {\n-            if let &[self_ty, _] = &decl.inputs {\n+            if let [self_ty, _] = decl.inputs {\n                 if !matches!(self_ty.kind, hir::TyKind::Rptr(_, _)) {\n                     tcx.sess\n                         .struct_span_err(\n@@ -473,7 +473,7 @@ fn check_associated_item(\n                     item.def_id,\n                     &mut implied_bounds,\n                 );\n-                check_method_receiver(fcx, hir_sig, &item, self_ty);\n+                check_method_receiver(fcx, hir_sig, item, self_ty);\n             }\n             ty::AssocKind::Type => {\n                 if let ty::AssocItemContainer::TraitContainer(_) = item.container {\n@@ -794,7 +794,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n     for param in &generics.params {\n         match param.kind {\n             GenericParamDefKind::Type { .. } => {\n-                if is_our_default(&param) {\n+                if is_our_default(param) {\n                     let ty = tcx.type_of(param.def_id);\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n@@ -809,7 +809,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 }\n             }\n             GenericParamDefKind::Const { .. } => {\n-                if is_our_default(&param) {\n+                if is_our_default(param) {\n                     // FIXME(const_generics_defaults): This\n                     // is incorrect when dealing with unused substs, for example\n                     // for `struct Foo<const N: usize, const M: usize = { 1 - 2 }>`"}, {"sha": "d951df94dcf50fbb0a2d137feb5ebf182843a782", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -140,7 +140,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     // operating on scalars, we clear the overload.\n     fn fix_scalar_builtin_expr(&mut self, e: &hir::Expr<'_>) {\n         match e.kind {\n-            hir::ExprKind::Unary(hir::UnOp::Neg | hir::UnOp::Not, ref inner) => {\n+            hir::ExprKind::Unary(hir::UnOp::Neg | hir::UnOp::Not, inner) => {\n                 let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_vars_if_possible(inner_ty);\n \n@@ -150,8 +150,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                     typeck_results.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n-            hir::ExprKind::Binary(ref op, ref lhs, ref rhs)\n-            | hir::ExprKind::AssignOp(ref op, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(ref op, lhs, rhs) | hir::ExprKind::AssignOp(ref op, lhs, rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_vars_if_possible(lhs_ty);\n \n@@ -198,7 +197,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n             // All valid indexing looks like this; might encounter non-valid indexes at this point.\n             let base_ty = typeck_results\n-                .expr_ty_adjusted_opt(&base)\n+                .expr_ty_adjusted_opt(base)\n                 .map(|t| self.fcx.resolve_vars_if_possible(t).kind());\n             if base_ty.is_none() {\n                 // When encountering `return [0][0]` outside of a `fn` body we can encounter a base\n@@ -207,7 +206,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 self.tcx().sess.delay_span_bug(e.span, &format!(\"bad base: `{:?}`\", base));\n             }\n             if let Some(ty::Ref(_, base_ty, _)) = base_ty {\n-                let index_ty = typeck_results.expr_ty_adjusted_opt(&index).unwrap_or_else(|| {\n+                let index_ty = typeck_results.expr_ty_adjusted_opt(index).unwrap_or_else(|| {\n                     // When encountering `return [0][0]` outside of a `fn` body we would attempt\n                     // to access an unexistend index. We assume that more relevant errors will\n                     // already have been emitted, so we only gate on this with an ICE if no"}, {"sha": "89ce3700aadcdee53a01a18bb51ca65300b39217", "filename": "compiler/rustc_typeck/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck_unused.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -26,7 +26,7 @@ impl ItemLikeVisitor<'v> for CheckVisitor<'tcx> {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n-        if let hir::ItemKind::Use(ref path, _) = item.kind {\n+        if let hir::ItemKind::Use(path, _) = item.kind {\n             self.check_import(item.item_id(), path.span);\n         }\n     }"}, {"sha": "6a9ba9d49134ca1823c5d8267b4969b046e35357", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -56,7 +56,7 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n             ty::Foreign(did) => {\n                 self.check_def_id(item, did);\n             }\n-            ty::Dynamic(ref data, ..) if data.principal_def_id().is_some() => {\n+            ty::Dynamic(data, ..) if data.principal_def_id().is_some() => {\n                 self.check_def_id(item, data.principal_def_id().unwrap());\n             }\n             ty::Dynamic(..) => {\n@@ -410,7 +410,7 @@ impl InherentCollect<'tcx> {\n                 // OK\n             }\n             _ => {\n-                let to_implement = if assoc_items.len() == 0 {\n+                let to_implement = if assoc_items.is_empty() {\n                     String::new()\n                 } else {\n                     let plural = assoc_items.len() > 1;"}, {"sha": "b5eb74f708d5cea2cc03eccd3fe87966cd0cdaff", "filename": "compiler/rustc_typeck/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -187,7 +187,7 @@ impl ItemLikeVisitor<'v> for InherentOverlapChecker<'tcx> {\n                             .collect::<FxHashSet<usize>>();\n                         match ids.len() {\n                             0 | 1 => {\n-                                let id_to_set = if ids.len() == 0 {\n+                                let id_to_set = if ids.is_empty() {\n                                     // Create a new connected region\n                                     let region = ConnectedRegion {\n                                         idents: idents_to_add,"}, {"sha": "079604f128d433812e2a389dca16e34f0f4342de", "filename": "compiler/rustc_typeck/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -221,7 +221,7 @@ fn check_object_overlap<'tcx>(\n     }\n \n     // check for overlap with the automatic `impl Trait for dyn Trait`\n-    if let ty::Dynamic(ref data, ..) = trait_ref.self_ty().kind() {\n+    if let ty::Dynamic(data, ..) = trait_ref.self_ty().kind() {\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n "}, {"sha": "f21c5c760ea50609757b890a7e81e3a58d47c826", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 34, "deletions": 42, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -199,20 +199,16 @@ crate fn placeholder_type_error(\n                 let parent_id = tcx.hir().get_parent_node(hir_ty.hir_id);\n                 let parent_node = tcx.hir().get(parent_id);\n \n-                is_const_or_static = match parent_node {\n+                is_const_or_static = matches!(\n+                    parent_node,\n                     Node::Item(&hir::Item {\n                         kind: hir::ItemKind::Const(..) | hir::ItemKind::Static(..),\n                         ..\n-                    })\n-                    | Node::TraitItem(&hir::TraitItem {\n+                    }) | Node::TraitItem(&hir::TraitItem {\n                         kind: hir::TraitItemKind::Const(..),\n                         ..\n-                    })\n-                    | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Const(..), ..\n-                    }) => true,\n-                    _ => false,\n-                };\n+                    }) | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Const(..), .. })\n+                );\n             }\n         }\n \n@@ -681,10 +677,10 @@ impl ItemCtxt<'tcx> {\n                 _ => None,\n             })\n             .flat_map(|bp| {\n-                let bt = if is_param(self.tcx, &bp.bounded_ty, param_id) {\n+                let bt = if is_param(self.tcx, bp.bounded_ty, param_id) {\n                     Some(ty)\n                 } else if !only_self_bounds.0 {\n-                    Some(self.to_ty(&bp.bounded_ty))\n+                    Some(self.to_ty(bp.bounded_ty))\n                 } else {\n                     None\n                 };\n@@ -723,7 +719,7 @@ impl ItemCtxt<'tcx> {\n /// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n /// conversion of the type to avoid inducing unnecessary cycles.\n fn is_param(tcx: TyCtxt<'_>, ast_ty: &hir::Ty<'_>, param_id: hir::HirId) -> bool {\n-    if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.kind {\n+    if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) = ast_ty.kind {\n         match path.res {\n             Res::SelfTy(Some(def_id), None) | Res::Def(DefKind::TyParam, def_id) => {\n                 def_id == tcx.hir().local_def_id(param_id).to_def_id()\n@@ -776,7 +772,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n             tcx.ensure().generics_of(def_id);\n             tcx.ensure().type_of(def_id);\n             tcx.ensure().predicates_of(def_id);\n-            convert_enum_variant_types(tcx, def_id.to_def_id(), &enum_definition.variants);\n+            convert_enum_variant_types(tcx, def_id.to_def_id(), enum_definition.variants);\n         }\n         hir::ItemKind::Impl { .. } => {\n             tcx.ensure().generics_of(def_id);\n@@ -1153,11 +1149,11 @@ fn super_predicates_that_define_assoc_type(\n             <dyn AstConv<'_>>::compute_bounds_that_match_assoc_type(\n                 &icx,\n                 self_param_ty,\n-                &bounds,\n+                bounds,\n                 assoc_name,\n             )\n         } else {\n-            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, &bounds)\n+            <dyn AstConv<'_>>::compute_bounds(&icx, self_param_ty, bounds)\n         };\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n@@ -1334,25 +1330,25 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     match node {\n         Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, &sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, &item.generics, &sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n-            hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n+            hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n-                has_late_bound_regions(tcx, generics, &sig.decl)\n+                has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,\n         },\n@@ -1374,7 +1370,7 @@ impl<'v> Visitor<'v> for AnonConstInParamTyDetector {\n     }\n \n     fn visit_generic_param(&mut self, p: &'v hir::GenericParam<'v>) {\n-        if let GenericParamKind::Const { ref ty, default: _ } = p.kind {\n+        if let GenericParamKind::Const { ty, default: _ } = p.kind {\n             let prev = self.in_param_ty;\n             self.in_param_ty = true;\n             self.visit_ty(ty);\n@@ -1587,7 +1583,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n     let mut own_start = has_self as u32;\n     let parent_count = parent_def_id.map_or(0, |def_id| {\n         let generics = tcx.generics_of(def_id);\n-        assert_eq!(has_self, false);\n+        assert!(!has_self);\n         parent_has_self = generics.has_self;\n         own_start = generics.count() as u32;\n         generics.parent_count + generics.params.len()\n@@ -1738,9 +1734,9 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n }\n \n pub fn get_infer_ret_ty(output: &'hir hir::FnRetTy<'hir>) -> Option<&'hir hir::Ty<'hir>> {\n-    if let hir::FnRetTy::Return(ref ty) = output {\n+    if let hir::FnRetTy::Return(ty) = output {\n         if is_suggestable_infer_ty(ty) {\n-            return Some(&**ty);\n+            return Some(&*ty);\n         }\n     }\n     None\n@@ -1810,8 +1806,8 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     hir_id,\n                     sig.header.unsafety,\n                     sig.header.abi,\n-                    &sig.decl,\n-                    &generics,\n+                    sig.decl,\n+                    generics,\n                     Some(ident.span),\n                     None,\n                 ),\n@@ -1829,15 +1825,13 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             header.unsafety,\n             header.abi,\n             decl,\n-            &generics,\n+            generics,\n             Some(ident.span),\n             None,\n         ),\n \n         ForeignItem(&hir::ForeignItem {\n-            kind: ForeignItemKind::Fn(ref fn_decl, _, _),\n-            ident,\n-            ..\n+            kind: ForeignItemKind::Fn(fn_decl, _, _), ident, ..\n         }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi, ident)\n@@ -2042,9 +2036,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             match item.kind {\n                 ItemKind::Impl(ref impl_) => {\n                     if impl_.defaultness.is_default() {\n-                        is_default_impl_trait = tcx\n-                            .impl_trait_ref(def_id)\n-                            .map(|trait_ref| ty::Binder::dummy(trait_ref));\n+                        is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n                     }\n                     &impl_.generics\n                 }\n@@ -2143,7 +2135,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             GenericParamKind::Lifetime { .. } => {\n                 param.bounds.iter().for_each(|bound| match bound {\n                     hir::GenericBound::Outlives(lt) => {\n-                        let bound = <dyn AstConv<'_>>::ast_region_to_region(&icx, &lt, None);\n+                        let bound = <dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None);\n                         let outlives = ty::Binder::dummy(ty::OutlivesPredicate(region, bound));\n                         predicates.insert((outlives.to_predicate(tcx), lt.span));\n                     }\n@@ -2165,12 +2157,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n \n-                let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, param_ty, &param.bounds);\n+                let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, param_ty, param.bounds);\n                 // Params are implicitly sized unless a `?Sized` bound is found\n                 <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n                     &mut bounds,\n-                    &param.bounds,\n+                    param.bounds,\n                     Some((param.hir_id, ast_generics.where_clause.predicates)),\n                     param.span,\n                 );\n@@ -2189,7 +2181,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     for predicate in where_clause.predicates {\n         match predicate {\n             hir::WherePredicate::BoundPredicate(bound_pred) => {\n-                let ty = icx.to_ty(&bound_pred.bounded_ty);\n+                let ty = icx.to_ty(bound_pred.bounded_ty);\n                 let bound_vars = icx.tcx.late_bound_vars(bound_pred.bounded_ty.hir_id);\n \n                 // Keep the type around in a dummy predicate, in case of no bounds.\n@@ -2410,7 +2402,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-            if let Some(_) = tcx.hir().opt_const_param_default_param_hir_id(hir_id) {\n+            if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n                 // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)\n@@ -2503,10 +2495,10 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n             }\n         };\n         for (input, ty) in iter::zip(decl.inputs, fty.inputs().skip_binder()) {\n-            check(&input, ty)\n+            check(input, ty)\n         }\n         if let hir::FnRetTy::Return(ref ty) = decl.output {\n-            check(&ty, fty.output().skip_binder())\n+            check(ty, fty.output().skip_binder())\n         }\n     }\n \n@@ -2561,7 +2553,7 @@ fn from_target_feature(\n         let msg = \"malformed `target_feature` attribute input\";\n         let code = \"enable = \\\"..\\\"\".to_owned();\n         tcx.sess\n-            .struct_span_err(span, &msg)\n+            .struct_span_err(span, msg)\n             .span_suggestion(span, \"must be of the form\", code, Applicability::HasPlaceholders)\n             .emit();\n     };\n@@ -2846,7 +2838,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                 tcx,\n                 id,\n                 attr,\n-                &supported_target_features,\n+                supported_target_features,\n                 &mut codegen_fn_attrs.target_features,\n             );\n         } else if attr.has_name(sym::linkage) {\n@@ -3113,7 +3105,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         codegen_fn_attrs.flags |= CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL;\n     }\n     let check_name = |attr: &Attribute, sym| attr.has_name(sym);\n-    if let Some(name) = weak_lang_items::link_name(check_name, &attrs) {\n+    if let Some(name) = weak_lang_items::link_name(check_name, attrs) {\n         codegen_fn_attrs.export_name = Some(name);\n         codegen_fn_attrs.link_name = Some(name);\n     }"}, {"sha": "26cad8fb18058a537409508f29b074f928b7824d", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -26,9 +26,9 @@ fn associated_type_bounds<'tcx>(\n     );\n \n     let icx = ItemCtxt::new(tcx, assoc_item_def_id);\n-    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, &ast_bounds);\n+    let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n     // Associated types are implicitly sized unless a `?Sized` bound is found\n-    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, &ast_bounds, None, span);\n+    <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n \n     let trait_def_id = tcx.associated_item(assoc_item_def_id).container.id();\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n@@ -64,9 +64,9 @@ fn opaque_type_bounds<'tcx>(\n             tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n         let icx = ItemCtxt::new(tcx, opaque_def_id);\n-        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, &ast_bounds);\n+        let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, item_ty, ast_bounds);\n         // Opaque types are implicitly sized unless a `?Sized` bound is found\n-        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, &ast_bounds, None, span);\n+        <dyn AstConv<'_>>::add_implicitly_sized(&icx, &mut bounds, ast_bounds, None, span);\n         let bounds = bounds.predicates(tcx, item_ty);\n \n         debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);"}, {"sha": "2e607de1d3371d0c36fc320d52c2a2f5b22dca7e", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -312,7 +312,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n-            TraitItemKind::Const(ref ty, body_id) => body_id\n+            TraitItemKind::Const(ty, body_id) => body_id\n                 .and_then(|body_id| {\n                     if is_suggestable_infer_ty(ty) {\n                         Some(infer_placeholder_type(\n@@ -323,7 +323,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     }\n                 })\n                 .unwrap_or_else(|| icx.to_ty(ty)),\n-            TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n+            TraitItemKind::Type(_, Some(ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n@@ -334,14 +334,14 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n-            ImplItemKind::Const(ref ty, body_id) => {\n+            ImplItemKind::Const(ty, body_id) => {\n                 if is_suggestable_infer_ty(ty) {\n                     infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident, \"constant\")\n                 } else {\n                     icx.to_ty(ty)\n                 }\n             }\n-            ImplItemKind::TyAlias(ref ty) => {\n+            ImplItemKind::TyAlias(ty) => {\n                 if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id).to_def_id()).is_none() {\n                     check_feature_inherent_assoc_ty(tcx, item.span);\n                 }\n@@ -352,7 +352,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::Item(item) => {\n             match item.kind {\n-                ItemKind::Static(ref ty, .., body_id) => {\n+                ItemKind::Static(ty, .., body_id) => {\n                     if is_suggestable_infer_ty(ty) {\n                         infer_placeholder_type(\n                             tcx,\n@@ -366,7 +366,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         icx.to_ty(ty)\n                     }\n                 }\n-                ItemKind::Const(ref ty, body_id) => {\n+                ItemKind::Const(ty, body_id) => {\n                     if is_suggestable_infer_ty(ty) {\n                         infer_placeholder_type(\n                             tcx, def_id, body_id, ty.span, item.ident, \"constant\",\n@@ -375,8 +375,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         icx.to_ty(ty)\n                     }\n                 }\n-                ItemKind::TyAlias(ref self_ty, _)\n-                | ItemKind::Impl(hir::Impl { ref self_ty, .. }) => icx.to_ty(self_ty),\n+                ItemKind::TyAlias(self_ty, _)\n+                | ItemKind::Impl(hir::Impl { self_ty, .. }) => icx.to_ty(self_ty),\n                 ItemKind::Fn(..) => {\n                     let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                     tcx.mk_fn_def(def_id.to_def_id(), substs)\n@@ -395,7 +395,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         .mir_borrowck(owner.expect_local())\n                         .concrete_opaque_types\n                         .get_value_matching(|(key, _)| key.def_id == def_id.to_def_id())\n-                        .map(|concrete_ty| *concrete_ty)\n+                        .copied()\n                         .unwrap_or_else(|| {\n                             tcx.sess.delay_span_bug(\n                                 DUMMY_SP,\n@@ -446,7 +446,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n                 tcx.mk_fn_def(def_id.to_def_id(), substs)\n             }\n-            ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n+            ForeignItemKind::Static(t, _) => icx.to_ty(t),\n             ForeignItemKind::Type => tcx.mk_foreign(def_id.to_def_id()),\n         },\n \n@@ -460,7 +460,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n         },\n \n-        Node::Field(field) => icx.to_ty(&field.ty),\n+        Node::Field(field) => icx.to_ty(field.ty),\n \n         Node::Expr(&Expr { kind: ExprKind::Closure(.., gen), .. }) => {\n             let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n@@ -685,9 +685,9 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n             //\n             // requires us to explicitly process `foo()` in order\n             // to notice the defining usage of `Blah`.\n-            Node::Item(ref it) => locator.visit_item(it),\n-            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n-            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n+            Node::Item(it) => locator.visit_item(it),\n+            Node::ImplItem(it) => locator.visit_impl_item(it),\n+            Node::TraitItem(it) => locator.visit_trait_item(it),\n             other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n         }\n     }"}, {"sha": "88877ad78525a95ad7e24cee0411fafb15beff32", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -206,7 +206,7 @@ pub fn setup_constraining_predicates<'tcx>(\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n                 let inputs = parameters_for(tcx, &projection.projection_ty, true);\n-                let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n+                let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(p));\n                 if !relies_only_on_inputs {\n                     continue;\n                 }"}, {"sha": "7d0600b99e36e45d416ed6266695b0339946baba", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -124,12 +124,12 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     #[instrument(skip(self), level = \"debug\")]\n     pub fn consume_body(&mut self, body: &hir::Body<'_>) {\n         for param in body.params {\n-            let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n+            let param_ty = return_if_err!(self.mc.pat_ty_adjusted(param.pat));\n             debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n             let param_place = self.mc.cat_rvalue(param.hir_id, param.pat.span, param_ty);\n \n-            self.walk_irrefutable_pat(&param_place, &param.pat);\n+            self.walk_irrefutable_pat(&param_place, param.pat);\n         }\n \n         self.consume_expr(&body.value);\n@@ -145,7 +145,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n     fn consume_exprs(&mut self, exprs: &[hir::Expr<'_>]) {\n         for expr in exprs {\n-            self.consume_expr(&expr);\n+            self.consume_expr(expr);\n         }\n     }\n \n@@ -184,57 +184,57 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         match expr.kind {\n             hir::ExprKind::Path(_) => {}\n \n-            hir::ExprKind::Type(ref subexpr, _) => self.walk_expr(subexpr),\n+            hir::ExprKind::Type(subexpr, _) => self.walk_expr(subexpr),\n \n-            hir::ExprKind::Unary(hir::UnOp::Deref, ref base) => {\n+            hir::ExprKind::Unary(hir::UnOp::Deref, base) => {\n                 // *base\n                 self.select_from_expr(base);\n             }\n \n-            hir::ExprKind::Field(ref base, _) => {\n+            hir::ExprKind::Field(base, _) => {\n                 // base.f\n                 self.select_from_expr(base);\n             }\n \n-            hir::ExprKind::Index(ref lhs, ref rhs) => {\n+            hir::ExprKind::Index(lhs, rhs) => {\n                 // lhs[rhs]\n                 self.select_from_expr(lhs);\n                 self.consume_expr(rhs);\n             }\n \n-            hir::ExprKind::Call(ref callee, ref args) => {\n+            hir::ExprKind::Call(callee, args) => {\n                 // callee(args)\n                 self.consume_expr(callee);\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprKind::MethodCall(.., ref args, _) => {\n+            hir::ExprKind::MethodCall(.., args, _) => {\n                 // callee.m(args)\n                 self.consume_exprs(args);\n             }\n \n-            hir::ExprKind::Struct(_, ref fields, ref opt_with) => {\n+            hir::ExprKind::Struct(_, fields, ref opt_with) => {\n                 self.walk_struct_expr(fields, opt_with);\n             }\n \n-            hir::ExprKind::Tup(ref exprs) => {\n+            hir::ExprKind::Tup(exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n             hir::ExprKind::If(ref cond_expr, ref then_expr, ref opt_else_expr) => {\n-                self.consume_expr(&cond_expr);\n-                self.consume_expr(&then_expr);\n+                self.consume_expr(cond_expr);\n+                self.consume_expr(then_expr);\n                 if let Some(ref else_expr) = *opt_else_expr {\n-                    self.consume_expr(&else_expr);\n+                    self.consume_expr(else_expr);\n                 }\n             }\n \n-            hir::ExprKind::Let(ref pat, ref expr, _) => {\n-                self.walk_local(expr, pat, |t| t.borrow_expr(&expr, ty::ImmBorrow));\n+            hir::ExprKind::Let(pat, ref expr, _) => {\n+                self.walk_local(expr, pat, |t| t.borrow_expr(expr, ty::ImmBorrow));\n             }\n \n             hir::ExprKind::Match(ref discr, arms, _) => {\n-                let discr_place = return_if_err!(self.mc.cat_expr(&discr));\n+                let discr_place = return_if_err!(self.mc.cat_expr(discr));\n \n                 // Matching should not always be considered a use of the place, hence\n                 // discr does not necessarily need to be borrowed.\n@@ -243,7 +243,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n                 let mut needs_to_be_read = false;\n                 for arm in arms.iter() {\n-                    return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |place, pat| {\n+                    return_if_err!(mc.cat_pattern(discr_place.clone(), arm.pat, |place, pat| {\n                         match &pat.kind {\n                             PatKind::Binding(.., opt_sub_pat) => {\n                                 // If the opt_sub_pat is None, than the binding does not count as\n@@ -303,7 +303,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n \n                 if needs_to_be_read {\n-                    self.borrow_expr(&discr, ty::ImmBorrow);\n+                    self.borrow_expr(discr, ty::ImmBorrow);\n                 } else {\n                     let closure_def_id = match discr_place.place.base {\n                         PlaceBase::Upvar(upvar_id) => Some(upvar_id.closure_expr_id.to_def_id()),\n@@ -318,7 +318,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n                     // We always want to walk the discriminant. We want to make sure, for instance,\n                     // that the discriminant has been initialized.\n-                    self.walk_expr(&discr);\n+                    self.walk_expr(discr);\n                 }\n \n                 // treatment of the discriminant is handled while walking the arms.\n@@ -327,7 +327,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::Array(ref exprs) => {\n+            hir::ExprKind::Array(exprs) => {\n                 self.consume_exprs(exprs);\n             }\n \n@@ -336,10 +336,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n                 let bk = ty::BorrowKind::from_mutbl(m);\n-                self.borrow_expr(&base, bk);\n+                self.borrow_expr(base, bk);\n             }\n \n-            hir::ExprKind::InlineAsm(ref asm) => {\n+            hir::ExprKind::InlineAsm(asm) => {\n                 for (op, _op_sp) in asm.operands {\n                     match op {\n                         hir::InlineAsmOperand::In { expr, .. }\n@@ -360,59 +360,59 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::LlvmInlineAsm(ref ia) => {\n+            hir::ExprKind::LlvmInlineAsm(ia) => {\n                 for (o, output) in iter::zip(&ia.inner.outputs, ia.outputs_exprs) {\n                     if o.is_indirect {\n                         self.consume_expr(output);\n                     } else {\n                         self.mutate_expr(output);\n                     }\n                 }\n-                self.consume_exprs(&ia.inputs_exprs);\n+                self.consume_exprs(ia.inputs_exprs);\n             }\n \n             hir::ExprKind::Continue(..)\n             | hir::ExprKind::Lit(..)\n             | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Err => {}\n \n-            hir::ExprKind::Loop(ref blk, ..) => {\n+            hir::ExprKind::Loop(blk, ..) => {\n                 self.walk_block(blk);\n             }\n \n-            hir::ExprKind::Unary(_, ref lhs) => {\n+            hir::ExprKind::Unary(_, lhs) => {\n                 self.consume_expr(lhs);\n             }\n \n-            hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::Binary(_, lhs, rhs) => {\n                 self.consume_expr(lhs);\n                 self.consume_expr(rhs);\n             }\n \n-            hir::ExprKind::Block(ref blk, _) => {\n+            hir::ExprKind::Block(blk, _) => {\n                 self.walk_block(blk);\n             }\n \n             hir::ExprKind::Break(_, ref opt_expr) | hir::ExprKind::Ret(ref opt_expr) => {\n-                if let Some(ref expr) = *opt_expr {\n+                if let Some(expr) = *opt_expr {\n                     self.consume_expr(expr);\n                 }\n             }\n \n-            hir::ExprKind::Assign(ref lhs, ref rhs, _) => {\n+            hir::ExprKind::Assign(lhs, rhs, _) => {\n                 self.mutate_expr(lhs);\n                 self.consume_expr(rhs);\n             }\n \n-            hir::ExprKind::Cast(ref base, _) => {\n+            hir::ExprKind::Cast(base, _) => {\n                 self.consume_expr(base);\n             }\n \n-            hir::ExprKind::DropTemps(ref expr) => {\n+            hir::ExprKind::DropTemps(expr) => {\n                 self.consume_expr(expr);\n             }\n \n-            hir::ExprKind::AssignOp(_, ref lhs, ref rhs) => {\n+            hir::ExprKind::AssignOp(_, lhs, rhs) => {\n                 if self.mc.typeck_results.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n@@ -421,7 +421,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(rhs);\n             }\n \n-            hir::ExprKind::Repeat(ref base, _) => {\n+            hir::ExprKind::Repeat(base, _) => {\n                 self.consume_expr(base);\n             }\n \n@@ -433,15 +433,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(base);\n             }\n \n-            hir::ExprKind::Yield(ref value, _) => {\n+            hir::ExprKind::Yield(value, _) => {\n                 self.consume_expr(value);\n             }\n         }\n     }\n \n     fn walk_stmt(&mut self, stmt: &hir::Stmt<'_>) {\n         match stmt.kind {\n-            hir::StmtKind::Local(hir::Local { pat, init: Some(ref expr), .. }) => {\n+            hir::StmtKind::Local(hir::Local { pat, init: Some(expr), .. }) => {\n                 self.walk_local(expr, pat, |_| {});\n             }\n \n@@ -453,7 +453,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::StmtKind::Expr(ref expr) | hir::StmtKind::Semi(ref expr) => {\n-                self.consume_expr(&expr);\n+                self.consume_expr(expr);\n             }\n         }\n     }\n@@ -462,8 +462,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     where\n         F: FnMut(&mut Self),\n     {\n-        self.walk_expr(&expr);\n-        let expr_place = return_if_err!(self.mc.cat_expr(&expr));\n+        self.walk_expr(expr);\n+        let expr_place = return_if_err!(self.mc.cat_expr(expr));\n         f(self);\n         self.walk_irrefutable_pat(&expr_place, &pat);\n     }\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         }\n \n         if let Some(ref tail_expr) = blk.expr {\n-            self.consume_expr(&tail_expr);\n+            self.consume_expr(tail_expr);\n         }\n     }\n \n@@ -489,17 +489,17 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     ) {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n-            self.consume_expr(&field.expr);\n+            self.consume_expr(field.expr);\n         }\n \n         let with_expr = match *opt_with {\n-            Some(ref w) => &**w,\n+            Some(w) => &*w,\n             None => {\n                 return;\n             }\n         };\n \n-        let with_place = return_if_err!(self.mc.cat_expr(&with_expr));\n+        let with_place = return_if_err!(self.mc.cat_expr(with_expr));\n \n         // Select just those fields of the `with`\n         // expression that will actually be used\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n             place_with_id =\n-                return_if_err!(self.mc.cat_expr_adjusted(expr, place_with_id, &adjustment));\n+                return_if_err!(self.mc.cat_expr_adjusted(expr, place_with_id, adjustment));\n         }\n     }\n \n@@ -615,15 +615,15 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             FakeReadCause::ForMatchedPlace(closure_def_id),\n             discr_place.hir_id,\n         );\n-        self.walk_pat(discr_place, &arm.pat);\n+        self.walk_pat(discr_place, arm.pat);\n \n-        if let Some(hir::Guard::If(ref e)) = arm.guard {\n+        if let Some(hir::Guard::If(e)) = arm.guard {\n             self.consume_expr(e)\n         } else if let Some(hir::Guard::IfLet(_, ref e)) = arm.guard {\n             self.consume_expr(e)\n         }\n \n-        self.consume_expr(&arm.body);\n+        self.consume_expr(arm.body);\n     }\n \n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n@@ -836,7 +836,7 @@ fn delegate_consume<'a, 'tcx>(\n ) {\n     debug!(\"delegate_consume(place_with_id={:?})\", place_with_id);\n \n-    let mode = copy_or_move(&mc, place_with_id);\n+    let mode = copy_or_move(mc, place_with_id);\n \n     match mode {\n         ConsumeMode::Move => delegate.consume(place_with_id, diag_expr_id),"}, {"sha": "8ff074e2fe534e2f3abd6c1155c55c1e6363c28b", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -143,7 +143,7 @@ fn require_same_types<'tcx>(\n     tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty();\n         let mut fulfill_cx = <dyn TraitEngine<'_>>::new(infcx.tcx);\n-        match infcx.at(&cause, param_env).eq(expected, actual) {\n+        match infcx.at(cause, param_env).eq(expected, actual) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfill_cx.register_predicate_obligations(infcx, obligations);\n             }\n@@ -187,9 +187,11 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         match tcx.hir().find(hir_id) {\n             Some(Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, ref generics, _), .. })) => {\n-                let generics_param_span =\n-                    if !generics.params.is_empty() { Some(generics.span) } else { None };\n-                generics_param_span\n+                if !generics.params.is_empty() {\n+                    Some(generics.span)\n+                } else {\n+                    None\n+                }\n             }\n             _ => {\n                 span_bug!(tcx.def_span(def_id), \"main has a non-function type\");"}, {"sha": "440ce04e61a27abf231ff328a3803d5cbafe436c", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -307,13 +307,13 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 if self.typeck_results.is_method_call(expr) {\n                     self.cat_overloaded_place(expr, e_base)\n                 } else {\n-                    let base = self.cat_expr(&e_base)?;\n+                    let base = self.cat_expr(e_base)?;\n                     self.cat_deref(expr, base)\n                 }\n             }\n \n             hir::ExprKind::Field(ref base, _) => {\n-                let base = self.cat_expr(&base)?;\n+                let base = self.cat_expr(base)?;\n                 debug!(\"cat_expr(cat_field): id={} expr={:?} base={:?}\", expr.hir_id, expr, base);\n \n                 let field_idx = self\n@@ -340,7 +340,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     // dereferencing.\n                     self.cat_overloaded_place(expr, base)\n                 } else {\n-                    let base = self.cat_expr(&base)?;\n+                    let base = self.cat_expr(base)?;\n                     Ok(self.cat_projection(expr, base, expr_ty, ProjectionKind::Index))\n                 }\n             }\n@@ -350,7 +350,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 self.cat_res(expr.hir_id, expr.span, expr_ty, res)\n             }\n \n-            hir::ExprKind::Type(ref e, _) => self.cat_expr(&e),\n+            hir::ExprKind::Type(ref e, _) => self.cat_expr(e),\n \n             hir::ExprKind::AddrOf(..)\n             | hir::ExprKind::Call(..)\n@@ -674,31 +674,31 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         op(&place_with_id, pat);\n \n         match pat.kind {\n-            PatKind::Tuple(ref subpats, dots_pos) => {\n+            PatKind::Tuple(subpats, dots_pos) => {\n                 // (p1, ..., pN)\n                 let total_fields = self.total_fields_in_tuple(pat.hir_id, pat.span)?;\n \n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(total_fields, dots_pos) {\n-                    let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n+                    let subpat_ty = self.pat_ty_adjusted(subpat)?;\n                     let projection_kind = ProjectionKind::Field(i as u32, VariantIdx::new(0));\n                     let sub_place =\n                         self.cat_projection(pat, place_with_id.clone(), subpat_ty, projection_kind);\n-                    self.cat_pattern_(sub_place, &subpat, op)?;\n+                    self.cat_pattern_(sub_place, subpat, op)?;\n                 }\n             }\n \n-            PatKind::TupleStruct(ref qpath, ref subpats, dots_pos) => {\n+            PatKind::TupleStruct(ref qpath, subpats, dots_pos) => {\n                 // S(p1, ..., pN)\n                 let variant_index = self.variant_index_for_adt(qpath, pat.hir_id, pat.span)?;\n                 let total_fields =\n                     self.total_fields_in_adt_variant(pat.hir_id, variant_index, pat.span)?;\n \n                 for (i, subpat) in subpats.iter().enumerate_and_adjust(total_fields, dots_pos) {\n-                    let subpat_ty = self.pat_ty_adjusted(&subpat)?;\n+                    let subpat_ty = self.pat_ty_adjusted(subpat)?;\n                     let projection_kind = ProjectionKind::Field(i as u32, variant_index);\n                     let sub_place =\n                         self.cat_projection(pat, place_with_id.clone(), subpat_ty, projection_kind);\n-                    self.cat_pattern_(sub_place, &subpat, op)?;\n+                    self.cat_pattern_(sub_place, subpat, op)?;\n                 }\n             }\n \n@@ -708,7 +708,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                 let variant_index = self.variant_index_for_adt(qpath, pat.hir_id, pat.span)?;\n \n                 for fp in field_pats {\n-                    let field_ty = self.pat_ty_adjusted(&fp.pat)?;\n+                    let field_ty = self.pat_ty_adjusted(fp.pat)?;\n                     let field_index = self\n                         .typeck_results\n                         .field_indices()\n@@ -722,26 +722,26 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                         field_ty,\n                         ProjectionKind::Field(field_index as u32, variant_index),\n                     );\n-                    self.cat_pattern_(field_place, &fp.pat, op)?;\n+                    self.cat_pattern_(field_place, fp.pat, op)?;\n                 }\n             }\n \n             PatKind::Or(pats) => {\n                 for pat in pats {\n-                    self.cat_pattern_(place_with_id.clone(), &pat, op)?;\n+                    self.cat_pattern_(place_with_id.clone(), pat, op)?;\n                 }\n             }\n \n             PatKind::Binding(.., Some(ref subpat)) => {\n-                self.cat_pattern_(place_with_id, &subpat, op)?;\n+                self.cat_pattern_(place_with_id, subpat, op)?;\n             }\n \n             PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n                 // box p1, &p1, &mut p1.  we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type.\n                 let subplace = self.cat_deref(pat, place_with_id)?;\n-                self.cat_pattern_(subplace, &subpat, op)?;\n+                self.cat_pattern_(subplace, subpat, op)?;\n             }\n \n             PatKind::Slice(before, ref slice, after) => {\n@@ -759,20 +759,20 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                     ProjectionKind::Index,\n                 );\n                 for before_pat in before {\n-                    self.cat_pattern_(elt_place.clone(), &before_pat, op)?;\n+                    self.cat_pattern_(elt_place.clone(), before_pat, op)?;\n                 }\n                 if let Some(ref slice_pat) = *slice {\n-                    let slice_pat_ty = self.pat_ty_adjusted(&slice_pat)?;\n+                    let slice_pat_ty = self.pat_ty_adjusted(slice_pat)?;\n                     let slice_place = self.cat_projection(\n                         pat,\n                         place_with_id,\n                         slice_pat_ty,\n                         ProjectionKind::Subslice,\n                     );\n-                    self.cat_pattern_(slice_place, &slice_pat, op)?;\n+                    self.cat_pattern_(slice_place, slice_pat, op)?;\n                 }\n                 for after_pat in after {\n-                    self.cat_pattern_(elt_place.clone(), &after_pat, op)?;\n+                    self.cat_pattern_(elt_place.clone(), after_pat, op)?;\n                 }\n             }\n "}, {"sha": "bbf31de527eb3fb7205507ee6707981b3ec8859f", "filename": "compiler/rustc_typeck/src/outlives/explicit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -30,20 +30,20 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n                 match predicate.kind().skip_binder() {\n-                    ty::PredicateKind::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {\n+                    ty::PredicateKind::TypeOutlives(OutlivesPredicate(ty, reg)) => {\n                         insert_outlives_predicate(\n                             tcx,\n-                            (*ty).into(),\n+                            ty.into(),\n                             reg,\n                             span,\n                             &mut required_predicates,\n                         )\n                     }\n \n-                    ty::PredicateKind::RegionOutlives(OutlivesPredicate(ref reg1, ref reg2)) => {\n+                    ty::PredicateKind::RegionOutlives(OutlivesPredicate(reg1, reg2)) => {\n                         insert_outlives_predicate(\n                             tcx,\n-                            (*reg1).into(),\n+                            reg1.into(),\n                             reg2,\n                             span,\n                             &mut required_predicates,"}, {"sha": "957ff2525190d2f273ab1949a26dc0bebaac3050", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -22,7 +22,7 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n \n     if matches!(tcx.def_kind(item_def_id), hir::def::DefKind::AnonConst) && tcx.lazy_normalization()\n     {\n-        if let Some(_) = tcx.hir().opt_const_param_default_param_hir_id(id) {\n+        if tcx.hir().opt_const_param_default_param_hir_id(id).is_some() {\n             // In `generics_of` we set the generics' parent to be our parent's parent which means that\n             // we lose out on the predicates of our actual parent if we dont return those predicates here.\n             // (See comment in `generics_of` for more information on why the parent shenanigans is necessary)"}, {"sha": "8d3862ffc8f01c027907081f5a19ca71d0094c9d", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         &self,\n         num_params_to_take: usize,\n     ) -> String {\n-        let fn_sig = self.tcx.hir().get_if_local(self.def_id).and_then(|node| fn_sig(node));\n+        let fn_sig = self.tcx.hir().get_if_local(self.def_id).and_then(fn_sig);\n         let is_used_in_input = |def_id| {\n             fn_sig.map_or(false, |fn_sig| {\n                 fn_sig.decl.inputs.iter().any(|ty| match ty.kind {"}, {"sha": "1c8ac10818c0319940bb4b8eb0716acda272895e", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b27661eb33c74cb514dba059b47d86b6582ac1c2/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=b27661eb33c74cb514dba059b47d86b6582ac1c2", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n \n-            ty::Dynamic(ref data, r) => {\n+            ty::Dynamic(data, r) => {\n                 // The type `Foo<T+'a>` is contravariant w/r/t `'a`:\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, r, contra);"}]}