{"sha": "f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3ZmYzN2U0YzUyYTFkNjU2MjYzNWZjZDViYWI2MzA5Y2Y3NWVhMDg=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-02T00:56:28Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-01-06T21:46:33Z"}, "message": "Replace full slice notation with index calls", "tree": {"sha": "9c69736bf3830f9048f61d45943bf0fa6326782d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c69736bf3830f9048f61d45943bf0fa6326782d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "html_url": "https://github.com/rust-lang/rust/commit/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "918255ef8c3c21b2009204c3019239f8dc9f46bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/918255ef8c3c21b2009204c3019239f8dc9f46bf", "html_url": "https://github.com/rust-lang/rust/commit/918255ef8c3c21b2009204c3019239f8dc9f46bf"}], "stats": {"total": 4305, "additions": 2166, "deletions": 2139}, "files": [{"sha": "684315de0046016df09fbed0608857e08178baaa", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -676,7 +676,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n                                                .unwrap()\n                                                .to_string();\n \n-    script_str.push_str(format!(\"command script import {}\\n\", rust_pp_module_abs_path[])[]);\n+    script_str.push_str(format!(\"command script import {}\\n\", rust_pp_module_abs_path.index(&FullRange))[]);\n     script_str.push_str(\"type summary add --no-value \");\n     script_str.push_str(\"--python-function lldb_rust_formatters.print_val \");\n     script_str.push_str(\"-x \\\".*\\\" --category Rust\\n\");\n@@ -910,7 +910,7 @@ fn check_error_patterns(props: &TestProps,\n     if done { return; }\n \n     let missing_patterns =\n-        props.error_patterns[next_err_idx..];\n+        props.error_patterns.index(&(next_err_idx..));\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "3d1779445e124bfb0ed10f3220711c28b2dfa326", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -330,7 +330,7 @@ impl Bitv {\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n-            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n+            for (i, &byte) in bytes.index(&((complete_words*4)..)).iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);"}, {"sha": "eff25b6d38500214f71643f1c993463647491f80", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -556,7 +556,7 @@ impl<T> RingBuf<T> {\n             let buf = self.buffer_as_slice();\n             if contiguous {\n                 let (empty, buf) = buf.split_at(0);\n-                (buf[self.tail..self.head], empty)\n+                (buf.index(&(self.tail..self.head)), empty)\n             } else {\n                 let (mid, right) = buf.split_at(self.tail);\n                 let (left, _) = mid.split_at(self.head);"}, {"sha": "ca1fed0f78f4c307bac5b72866d79e73938f3e1e", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -55,7 +55,7 @@\n //! #![feature(slicing_syntax)]\n //! fn main() {\n //!     let numbers = [0i, 1i, 2i];\n-//!     let last_numbers = numbers[1..3];\n+//!     let last_numbers = numbers.index(&(1..3));\n //!     // last_numbers is now &[1i, 2i]\n //! }\n //! ```\n@@ -98,7 +98,7 @@ use core::iter::{range, range_step, MultiplicativeIterator};\n use core::kinds::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::{FnMut, SliceMut};\n+use core::ops::{FnMut, FullRange, Index, IndexMut};\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n use core::ptr;\n@@ -1065,12 +1065,12 @@ impl ElementSwaps {\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned[] }\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { owned.index(&FullRange) }\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.as_mut_slice_() }\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.index_mut(&FullRange) }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -1606,15 +1606,15 @@ mod tests {\n \n         // Test on stack.\n         let vec_stack: &[_] = &[1i, 2, 3];\n-        let v_b = vec_stack[1u..3u].to_vec();\n+        let v_b = vec_stack.index(&(1u..3u)).to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique[1u..6u].to_vec();\n+        let v_d = vec_unique.index(&(1u..6u)).to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1627,21 +1627,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[0..], vec);\n+        assert_eq!(vec.index(&(0..)), vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec[2..], b);\n+        assert_eq!(vec.index(&(2..)), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[4..], b);\n+        assert_eq!(vec.index(&(4..)), b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec[..4], vec);\n+        assert_eq!(vec.index(&(0..4)), vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec[..2], b);\n+        assert_eq!(vec.index(&(0..2)), b);\n         let b: &[int] = &[];\n-        assert_eq!(vec[..0], b);\n+        assert_eq!(vec.index(&(0..0)), b);\n     }\n \n \n@@ -2567,7 +2567,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v[1..3].iter() {\n+        for f in v.index(&(1..3)).iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "cb4264ec34f32a3ca58099cde223c37cdd7d4feb", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -60,7 +60,7 @@ use core::char::CharExt;\n use core::clone::Clone;\n use core::iter::AdditiveIterator;\n use core::iter::{range, Iterator, IteratorExt};\n-use core::ops;\n+use core::ops::{self, llRange, Index};\n use core::option::Option::{self, Some, None};\n use core::slice::AsSlice;\n use core::str as core_str;\n@@ -386,7 +386,7 @@ macro_rules! utf8_acc_cont_byte {\n \n #[unstable = \"trait is unstable\"]\n impl BorrowFrom<String> for str {\n-    fn borrow_from(owned: &String) -> &str { owned[] }\n+    fn borrow_from(owned: &String) -> &str { owned.index(&FullRange) }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -408,7 +408,7 @@ Section: Trait implementations\n \n /// Any string that can be represented as a slice.\n #[stable]\n-pub trait StrExt: ops::Slice<uint, str> {\n+pub trait StrExt: Index<FullRange, str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n     #[unstable = \"return type may change to be an iterator\"]\n     fn escape_default(&self) -> String {\n@@ -464,7 +464,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self.index(&FullRange).chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -477,7 +477,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self[].chars(),\n+            iter: self.index(&FullRange).chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -525,7 +525,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn contains(&self, pat: &str) -> bool {\n-        core_str::StrExt::contains(self[], pat)\n+        core_str::StrExt::contains(self.index(&FullRange), pat)\n     }\n \n     /// Returns true if a string contains a char pattern.\n@@ -541,7 +541,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed in favour of a more generic contains()\"]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(self[], pat)\n+        core_str::StrExt::contains_char(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -555,7 +555,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self[])\n+        core_str::StrExt::chars(self.index(&FullRange))\n     }\n \n     /// An iterator over the bytes of `self`\n@@ -568,13 +568,13 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self[])\n+        core_str::StrExt::bytes(self.index(&FullRange))\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     #[stable]\n     fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self[])\n+        core_str::StrExt::char_indices(self.index(&FullRange))\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -597,7 +597,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n-        core_str::StrExt::split(self[], pat)\n+        core_str::StrExt::split(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -624,7 +624,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n-        core_str::StrExt::splitn(self[], count, pat)\n+        core_str::StrExt::splitn(self.index(&FullRange), count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -653,7 +653,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed\"]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n-        core_str::StrExt::split_terminator(self[], pat)\n+        core_str::StrExt::split_terminator(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -674,7 +674,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n-        core_str::StrExt::rsplitn(self[], count, pat)\n+        core_str::StrExt::rsplitn(self.index(&FullRange), count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n@@ -699,7 +699,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might have its iterator type changed\"]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(self[], pat)\n+        core_str::StrExt::match_indices(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over the substrings of `self` separated by the pattern `sep`.\n@@ -715,7 +715,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n-        core_str::StrExt::split_str(self[], pat)\n+        core_str::StrExt::split_str(self.index(&FullRange), pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -731,7 +731,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self[])\n+        core_str::StrExt::lines(self.index(&FullRange))\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -747,7 +747,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self[])\n+        core_str::StrExt::lines_any(self.index(&FullRange))\n     }\n \n     /// Returns a slice of the given string from the byte range\n@@ -782,7 +782,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"use slice notation [a..b] instead\"]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(self[], begin, end)\n+        core_str::StrExt::slice(self.index(&FullRange), begin, end)\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -795,7 +795,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// See also `slice`, `slice_to` and `slice_chars`.\n     #[unstable = \"use slice notation [a..] instead\"]\n     fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(self[], begin)\n+        core_str::StrExt::slice_from(self.index(&FullRange), begin)\n     }\n \n     /// Returns a slice of the string from the beginning to byte\n@@ -809,7 +809,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// See also `slice`, `slice_from` and `slice_chars`.\n     #[unstable = \"use slice notation [0..a] instead\"]\n     fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(self[], end)\n+        core_str::StrExt::slice_to(self.index(&FullRange), end)\n     }\n \n     /// Returns a slice of the string from the character range\n@@ -837,7 +837,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"may have yet to prove its worth\"]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_chars(self[], begin, end)\n+        core_str::StrExt::slice_chars(self.index(&FullRange), begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -848,7 +848,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// the entire slice as well.\n     #[stable]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_unchecked(self[], begin, end)\n+        core_str::StrExt::slice_unchecked(self.index(&FullRange), begin, end)\n     }\n \n     /// Returns true if the pattern `pat` is a prefix of the string.\n@@ -860,7 +860,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn starts_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::starts_with(self[], pat)\n+        core_str::StrExt::starts_with(self.index(&FullRange), pat)\n     }\n \n     /// Returns true if the pattern `pat` is a suffix of the string.\n@@ -872,7 +872,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn ends_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::ends_with(self[], pat)\n+        core_str::StrExt::ends_with(self.index(&FullRange), pat)\n     }\n \n     /// Returns a string with all pre- and suffixes that match\n@@ -892,7 +892,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_matches(self[], pat)\n+        core_str::StrExt::trim_matches(self.index(&FullRange), pat)\n     }\n \n     /// Returns a string with all prefixes that match\n@@ -912,7 +912,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_left_matches(self[], pat)\n+        core_str::StrExt::trim_left_matches(self.index(&FullRange), pat)\n     }\n \n     /// Returns a string with all suffixes that match\n@@ -932,7 +932,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_right_matches(self[], pat)\n+        core_str::StrExt::trim_right_matches(self.index(&FullRange), pat)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -960,7 +960,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn is_char_boundary(&self, index: uint) -> bool {\n-        core_str::StrExt::is_char_boundary(self[], index)\n+        core_str::StrExt::is_char_boundary(self.index(&FullRange), index)\n     }\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -1018,7 +1018,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at(self[], start)\n+        core_str::StrExt::char_range_at(self.index(&FullRange), start)\n     }\n \n     /// Given a byte position and a str, return the previous char and its position.\n@@ -1033,7 +1033,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(self[], start)\n+        core_str::StrExt::char_range_at_reverse(self.index(&FullRange), start)\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string.\n@@ -1053,7 +1053,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at(&self, i: uint) -> char {\n-        core_str::StrExt::char_at(self[], i)\n+        core_str::StrExt::char_at(self.index(&FullRange), i)\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string.\n@@ -1064,7 +1064,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at_reverse(&self, i: uint) -> char {\n-        core_str::StrExt::char_at_reverse(self[], i)\n+        core_str::StrExt::char_at_reverse(self.index(&FullRange), i)\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n@@ -1076,7 +1076,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self[])\n+        core_str::StrExt::as_bytes(self.index(&FullRange))\n     }\n \n     /// Returns the byte index of the first character of `self` that\n@@ -1104,7 +1104,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::find(self[], pat)\n+        core_str::StrExt::find(self.index(&FullRange), pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n@@ -1132,7 +1132,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::rfind(self[], pat)\n+        core_str::StrExt::rfind(self.index(&FullRange), pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1156,7 +1156,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"might get removed in favor of a more generic find in the future\"]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n-        core_str::StrExt::find_str(self[], needle)\n+        core_str::StrExt::find_str(self.index(&FullRange), needle)\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -1179,7 +1179,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"awaiting conventions about shifting and slices\"]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(self[])\n+        core_str::StrExt::slice_shift_char(self.index(&FullRange))\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n@@ -1198,7 +1198,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        core_str::StrExt::subslice_offset(self[], inner)\n+        core_str::StrExt::subslice_offset(self.index(&FullRange), inner)\n     }\n \n     /// Return an unsafe pointer to the strings buffer.\n@@ -1209,13 +1209,13 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[stable]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self[])\n+        core_str::StrExt::as_ptr(self.index(&FullRange))\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n+        Utf16Units { encoder: Utf16Encoder::new(self.index(&FullRange).chars()) }\n     }\n \n     /// Return the number of bytes in this string\n@@ -1229,7 +1229,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[stable]\n     #[inline]\n     fn len(&self) -> uint {\n-        core_str::StrExt::len(self[])\n+        core_str::StrExt::len(self.index(&FullRange))\n     }\n \n     /// Returns true if this slice contains no bytes\n@@ -1242,7 +1242,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[inline]\n     #[stable]\n     fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self[])\n+        core_str::StrExt::is_empty(self.index(&FullRange))\n     }\n \n     /// Parse this string into the specified type.\n@@ -1256,7 +1256,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     #[inline]\n     #[unstable = \"this method was just created\"]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n-        core_str::StrExt::parse(self[])\n+        core_str::StrExt::parse(self.index(&FullRange))\n     }\n \n     /// Returns an iterator over the\n@@ -1280,7 +1280,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(self[], is_extended)\n+        UnicodeStr::graphemes(self.index(&FullRange), is_extended)\n     }\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n@@ -1295,7 +1295,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(self[], is_extended)\n+        UnicodeStr::grapheme_indices(self.index(&FullRange), is_extended)\n     }\n \n     /// An iterator over the words of a string (subsequences separated\n@@ -1311,7 +1311,7 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// ```\n     #[stable]\n     fn words(&self) -> Words {\n-        UnicodeStr::words(self[])\n+        UnicodeStr::words(self.index(&FullRange))\n     }\n \n     /// Returns a string's displayed width in columns, treating control\n@@ -1325,25 +1325,25 @@ pub trait StrExt: ops::Slice<uint, str> {\n     /// `is_cjk` = `false`) if the locale is unknown.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn width(&self, is_cjk: bool) -> uint {\n-        UnicodeStr::width(self[], is_cjk)\n+        UnicodeStr::width(self.index(&FullRange), is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n     #[stable]\n     fn trim(&self) -> &str {\n-        UnicodeStr::trim(self[])\n+        UnicodeStr::trim(self.index(&FullRange))\n     }\n \n     /// Returns a string with leading whitespace removed.\n     #[stable]\n     fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self[])\n+        UnicodeStr::trim_left(self.index(&FullRange))\n     }\n \n     /// Returns a string with trailing whitespace removed.\n     #[stable]\n     fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self[])\n+        UnicodeStr::trim_right(self.index(&FullRange))\n     }\n }\n \n@@ -2133,7 +2133,7 @@ mod tests {\n         let mut bytes = [0u8; 4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(bytes.index(&(0..len))).unwrap();\n             if Some(c) != s.chars().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }\n@@ -2145,7 +2145,7 @@ mod tests {\n         let mut bytes = [0u8; 4];\n         for c in range(0u32, 0x110000).filter_map(|c| ::core::char::from_u32(c)) {\n             let len = c.encode_utf8(&mut bytes).unwrap_or(0);\n-            let s = ::core::str::from_utf8(bytes[..len]).unwrap();\n+            let s = ::core::str::from_utf8(bytes.index(&(0..len))).unwrap();\n             if Some(c) != s.chars().rev().next() {\n                 panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n             }"}, {"sha": "69ff513a85bb3ac3fa710003c6d0f033e4396fc0", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -168,7 +168,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v[..i])\n+                res.as_mut_vec().push_all(v.index(&(0..i)))\n             };\n         }\n \n@@ -185,7 +185,7 @@ impl String {\n             macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v[subseqidx..i_]);\n+                        res.as_mut_vec().push_all(v.index(&(subseqidx..i_)));\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -254,7 +254,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v[subseqidx..total])\n+                res.as_mut_vec().push_all(v.index(&(subseqidx..total)))\n             };\n         }\n         Cow::Owned(res)\n@@ -818,30 +818,30 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n-impl<T> ops::Index<ops::Range<uint>, str> for String {\n+impl ops::Index<ops::Range<uint>, str> for String {\n     #[inline]\n-    fn index(&self, &index: &ops::Range<uint>) -> &str {\n-        self[][*index]\n+    fn index(&self, index: &ops::Range<uint>) -> &str {\n+        &self.index(&FullRange)[*index]\n     }\n }\n \n-impl<T> ops::Index<ops::RangeTo<uint>, str> for String {\n+impl ops::Index<ops::RangeTo<uint>, str> for String {\n     #[inline]\n-    fn index(&self, &index: &ops::RangeTo<uint>) -> &str {\n-        self[][*index]\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+        &self.index(&FullRange)[*index]\n     }\n }\n \n-impl<T> ops::Index<ops::RangeFrom<uint>, str> for String {\n+impl ops::Index<ops::RangeFrom<uint>, str> for String {\n     #[inline]\n-    fn index(&self, &index: &ops::RangeFrom<uint>) -> &str {\n-        self[][*index]\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+        &self.index(&FullRange)[*index]\n     }\n }\n \n-impl<T> ops::Index<ops::FullRange<uint>, str> for String {\n+impl ops::Index<ops::FullRange, str> for String {\n     #[inline]\n-    fn index(&self, &index: &ops::FullRange<uint>) -> &str {\n+    fn index(&self, _index: &ops::FullRange) -> &str {\n         unsafe { mem::transmute(self.vec.as_slice()) }\n     }\n }\n@@ -851,7 +851,7 @@ impl ops::Deref for String {\n     type Target = str;\n \n     fn deref<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec[]) }\n+        unsafe { mem::transmute(self.vec.index(&FullRange)) }\n     }\n }\n \n@@ -1230,10 +1230,10 @@ mod tests {\n     #[test]\n     fn test_slicing() {\n         let s = \"foobar\".to_string();\n-        assert_eq!(\"foobar\", s[]);\n-        assert_eq!(\"foo\", s[..3]);\n-        assert_eq!(\"bar\", s[3..]);\n-        assert_eq!(\"oob\", s[1..4]);\n+        assert_eq!(\"foobar\", s.index(&FullRange));\n+        assert_eq!(\"foo\", s.index(&(0..3)));\n+        assert_eq!(\"bar\", s.index(&(3..)));\n+        assert_eq!(\"oob\", s.index(&(1..4)));\n     }\n \n     #[test]"}, {"sha": "3f667698bae537b38072e404edfaebbb1eb50847", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 14, "deletions": 21, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -1178,7 +1178,7 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other[self.len()..];\n+        let slice = other.index(&(self.len()..));\n         self.push_all(slice);\n     }\n }\n@@ -1209,65 +1209,58 @@ impl<T> IndexMut<uint> for Vec<T> {\n     }\n }\n \n-impl<T> ops::Slice<uint, [T]> for Vec<T> {\n-    #[inline]\n-    fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n-        &mut self.as_mut_slice()[*index]\n-    }\n-}\n-\n impl<T> ops::Index<ops::Range<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn index(&self, &index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n impl<T> ops::Index<ops::RangeTo<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn index(&self, &index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n impl<T> ops::Index<ops::RangeFrom<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn index(&self, &index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n-impl<T> ops::Index<ops::FullRange<uint>, [T]> for Vec<T> {\n+impl<T> ops::Index<ops::FullRange, [T]> for Vec<T> {\n     #[inline]\n-    fn index(&self, &index: &ops::FullRange<uint>) -> &[T] {\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n         self.as_slice()\n     }\n }\n \n impl<T> ops::IndexMut<ops::Range<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n \n impl<T> ops::IndexMut<ops::RangeTo<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n \n impl<T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for Vec<T> {\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n \n-impl<T> ops::IndexMut<ops::FullRange<uint>, [T]> for Vec<T> {\n+impl<T> ops::IndexMut<ops::FullRange, [T]> for Vec<T> {\n     #[inline]\n-    fn index_mut(&mut self, &index: &ops::FullRange<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n         self.as_mut_slice()\n     }\n }\n@@ -2125,7 +2118,7 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_2() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[..6];\n+        x.index(&(0..6));\n     }\n \n     #[test]\n@@ -2139,14 +2132,14 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_4() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[1..6];\n+        x.index(&(1..6));\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_slice_out_of_bounds_5() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        x[3..2];\n+        x.index(&(3..2));\n     }\n \n     #[test]"}, {"sha": "68469059fead011665d6a6f4fd8e717d56afa0c0", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -455,7 +455,8 @@ impl<V> VecMap<V> {\n         if *key >= self.v.len() {\n             return None;\n         }\n-        self.v[*key].take()\n+        let result = &mut self.v[*key];\n+        result.take()\n     }\n }\n "}, {"sha": "37a2177b38d0cf18aab7462881dcef71c62a3819", "filename": "src/libcore/array.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -18,7 +18,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use kinds::Copy;\n-use ops::Deref;\n+use ops::{Deref, FullRange, Index};\n use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n@@ -35,19 +35,19 @@ macro_rules! array_impls {\n             #[unstable = \"waiting for Show to stabilize\"]\n             impl<T:fmt::Show> fmt::Show for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Show::fmt(&self[], f)\n+                    fmt::Show::fmt(&self.index(&FullRange), f)\n                 }\n             }\n \n             #[stable]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    self[] == other[]\n+                    self.index(&FullRange) == other.index(&FullRange)\n                 }\n                 #[inline]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    self[] != other[]\n+                    self.index(&FullRange) != other.index(&FullRange)\n                 }\n             }\n \n@@ -57,9 +57,9 @@ macro_rules! array_impls {\n                 Rhs: Deref<Target=[B]>,\n             {\n                 #[inline(always)]\n-                fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self[], &**other) }\n+                fn eq(&self, other: &Rhs) -> bool { PartialEq::eq(self.index(&FullRange), &**other) }\n                 #[inline(always)]\n-                fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self[], &**other) }\n+                fn ne(&self, other: &Rhs) -> bool { PartialEq::ne(self.index(&FullRange), &**other) }\n             }\n \n             #[stable]\n@@ -68,9 +68,9 @@ macro_rules! array_impls {\n                 Lhs: Deref<Target=[A]>\n             {\n                 #[inline(always)]\n-                fn eq(&self, other: &[B; $N]) -> bool { PartialEq::eq(&**self, other[]) }\n+                fn eq(&self, other: &[B; $N]) -> bool { PartialEq::eq(&**self, other.index(&FullRange)) }\n                 #[inline(always)]\n-                fn ne(&self, other: &[B; $N]) -> bool { PartialEq::ne(&**self, other[]) }\n+                fn ne(&self, other: &[B; $N]) -> bool { PartialEq::ne(&**self, other.index(&FullRange)) }\n             }\n \n             #[stable]\n@@ -80,31 +80,31 @@ macro_rules! array_impls {\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&self[], &other[])\n+                    PartialOrd::partial_cmp(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&self[], &other[])\n+                    PartialOrd::lt(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&self[], &other[])\n+                    PartialOrd::le(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&self[], &other[])\n+                    PartialOrd::ge(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n                 #[inline]\n                 fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&self[], &other[])\n+                    PartialOrd::gt(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n             }\n \n             #[stable]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&self[], &other[])\n+                    Ord::cmp(&self.index(&FullRange), &other.index(&FullRange))\n                 }\n             }\n         )+"}, {"sha": "d833b8fed7779ff8213ca0e515dc53dc6836d53c", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -20,7 +20,7 @@ use fmt;\n use iter::{IteratorExt, range};\n use num::{cast, Float, ToPrimitive};\n use num::FpCategory as Fp;\n-use ops::FnOnce;\n+use ops::{FnOnce, Index};\n use result::Result::Ok;\n use slice::{self, SliceExt};\n use str::{self, StrExt};\n@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(unsafe { str::from_utf8_unchecked(buf[..end]) })\n+    f(unsafe { str::from_utf8_unchecked(buf.index(&(0..end))) })\n }"}, {"sha": "19c6b29417ffd542302318c47345a794f849638c", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -19,8 +19,8 @@ use kinds::{Copy, Sized};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use ops::{Deref, FnOnce};\n use result::Result::Ok;\n+use ops::{Deref, FnOnce, Index};\n use result;\n use slice::SliceExt;\n use slice;\n@@ -413,7 +413,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                let b = unsafe { str::from_utf8_unchecked(b[0..n]) };\n+                let b = unsafe { str::from_utf8_unchecked(b.index(&(0..n))) };\n                 try!(f.buf.write_str(b));\n             }\n             if prefixed { f.buf.write_str(prefix) }\n@@ -620,7 +620,7 @@ impl Show for char {\n \n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8[..amt]) };\n+        let s: &str = unsafe { mem::transmute(utf8.index(&(0..amt))) };\n         Show::fmt(s, f)\n     }\n }"}, {"sha": "89337e0584b505488687ca6fb72667e1a2d8ddd7", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -16,6 +16,7 @@\n \n use fmt;\n use iter::IteratorExt;\n+use ops::Index;\n use num::{Int, cast};\n use slice::SliceExt;\n use str;\n@@ -61,7 +62,7 @@ trait GenericRadix {\n                 if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n-        let buf = unsafe { str::from_utf8_unchecked(buf[curr..]) };\n+        let buf = unsafe { str::from_utf8_unchecked(buf.index(&(curr..))) };\n         f.pad_integral(is_positive, self.prefix(), buf)\n     }\n }"}, {"sha": "3bcdd54463fc6e312d92201a1b296ad376da980f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -24,7 +24,7 @@ use iter::IteratorExt;\n use kinds::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr, Index};\n use option::Option;\n use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n@@ -1577,7 +1577,7 @@ macro_rules! from_str_radix_float_impl {\n                         };\n \n                         // Parse the exponent as decimal integer\n-                        let src = src[offset..];\n+                        let src = src.index(&(offset..));\n                         let (is_positive, exp) = match src.slice_shift_char() {\n                             Some(('-', src)) => (false, src.parse::<uint>()),\n                             Some(('+', src)) => (true,  src.parse::<uint>()),"}, {"sha": "a0bb0205c4287ea16bf4f46a2ef04f4aa1388712", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -43,7 +43,7 @@ use default::Default;\n use iter::*;\n use kinds::Copy;\n use num::Int;\n-use ops::{FnMut, self};\n+use ops::{FnMut, self, Index};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result;\n@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n-        (self[..mid], self[mid..])\n+        (self.index(&(0..mid)), self.index(&(mid..)))\n     }\n \n     #[inline]\n@@ -236,11 +236,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &[T] { self[1..] }\n+    fn tail(&self) -> &[T] { self.index(&(1..)) }\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        self[..self.len() - 1]\n+        self.index(&(0..(self.len() - 1)))\n     }\n \n     #[inline]\n@@ -443,13 +443,13 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n-        self.len() >= n && needle == self[..n]\n+        self.len() >= n && needle == self.index(&(0..n))\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self[m-n..]\n+        m >= n && needle == self.index(&((m-n)..))\n     }\n \n     #[unstable]\n@@ -622,6 +622,20 @@ impl<T> ops::IndexMut<ops::FullRange, [T]> for [T] {\n     }\n }\n \n+impl<T> ops::Index<ops::Range<uint>, [T]> for [T] {\n+    #[inline]\n+    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            transmute(RawSlice {\n+                    data: self.as_ptr().offset(index.start as int),\n+                    len: index.end - index.start\n+                })\n+        }\n+    }\n+}\n+\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common traits\n@@ -779,7 +793,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>, [T]> for Iter<'a, T> {\n #[experimental]\n impl<'a, T> ops::Index<ops::FullRange, [T]> for Iter<'a, T> {\n     #[inline]\n-    fn index(&self, index: &ops::FullRange) -> &[T] {\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n         self.as_slice()\n     }\n }\n@@ -868,7 +882,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>, [T]> for IterMut<'a, T> {\n #[experimental]\n impl<'a, T> ops::Index<ops::FullRange, [T]> for IterMut<'a, T> {\n     #[inline]\n-    fn index(&self, index: &ops::FullRange) -> &[T] {\n+    fn index(&self, _index: &ops::FullRange) -> &[T] {\n         make_slice!(T -> &[T]: self.ptr, self.end)\n     }\n }\n@@ -900,7 +914,7 @@ impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>, [T]> for IterMut<'a, T> {\n #[experimental]\n impl<'a, T> ops::IndexMut<ops::FullRange, [T]> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::FullRange) -> &mut [T] {\n+    fn index_mut(&mut self, _index: &ops::FullRange) -> &mut [T] {\n         make_slice!(T -> &mut [T]: self.ptr, self.end)\n     }\n }\n@@ -964,8 +978,8 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[..idx]);\n-                self.v = self.v[idx + 1..];\n+                let ret = Some(self.v.index(&(0..idx)));\n+                self.v = self.v.index(&((idx + 1)..));\n                 ret\n             }\n         }\n@@ -990,8 +1004,8 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v[idx + 1..]);\n-                self.v = self.v[..idx];\n+                let ret = Some(self.v.index(&((idx + 1)..)));\n+                self.v = self.v.index(&(0..idx));\n                 ret\n             }\n         }\n@@ -1187,8 +1201,8 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v[..self.size]);\n-            self.v = self.v[1..];\n+            let ret = Some(self.v.index(&(0..self.size)));\n+            self.v = self.v.index(&(1..));\n             ret\n         }\n     }\n@@ -1275,7 +1289,7 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v[lo..hi])\n+            Some(self.v.index(&(lo..hi)))\n         } else {\n             None\n         }"}, {"sha": "c4e97fe3b7fb338d699ac7179c62029b045c2b05", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -26,7 +26,7 @@ use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use kinds::Sized;\n use mem;\n use num::Int;\n-use ops::{Fn, FnMut};\n+use ops::{Fn, FnMut, Index};\n use option::Option::{self, None, Some};\n use ptr::PtrExt;\n use raw::{Repr, Slice};\n@@ -581,7 +581,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack[self.position .. self.position + needle.len()] == needle {\n+            if haystack.index(&(self.position .. self.position + needle.len())) == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -702,10 +702,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v[..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // v.index(&(0..period)). If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle[..crit_pos] == needle[period.. period + crit_pos] {\n+        if needle.index(&(0..crit_pos)) == needle.index(&(period.. period + crit_pos)) {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -1121,28 +1121,28 @@ mod traits {\n \n     impl ops::Index<ops::Range<uint>, str> for str {\n         #[inline]\n-        fn index(&self, &index: &ops::Range<uint>) -> &str {\n+        fn index(&self, index: &ops::Range<uint>) -> &str {\n             self.slice(index.start, index.end)\n         }\n     }\n \n     impl ops::Index<ops::RangeTo<uint>, str> for str {\n         #[inline]\n-        fn index(&self, &index: &ops::RangeTo<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n             self.slice_to(index.end)\n         }\n     }\n \n     impl ops::Index<ops::RangeFrom<uint>, str> for str {\n         #[inline]\n-        fn index(&self, &index: &ops::RangeFrom<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n             self.slice_from(index.start)\n         }\n     }\n \n     impl ops::Index<ops::FullRange, str> for str {\n         #[inline]\n-        fn index(&self, &index: &ops::FullRange) -> &str {\n+        fn index(&self, _index: &ops::FullRange) -> &str {\n             self\n         }\n     }\n@@ -1412,13 +1412,13 @@ impl StrExt for str {\n     #[inline]\n     fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes()[..n]\n+        self.len() >= n && needle.as_bytes() == self.as_bytes().index(&(0..n))\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes()[m-n..]\n+        m >= n && needle.as_bytes() == self.as_bytes().index(&((m-n)..))\n     }\n \n     #[inline]"}, {"sha": "f901e8001767d5ce6644369d23a976383d33a33b", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -167,7 +167,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8; 4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.index(&(0..n)), expect);\n     }\n \n     check('x', &[0x78]);\n@@ -181,7 +181,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16; 2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf[..n], expect);\n+        assert_eq!(buf.index(&(0..n)), expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "19bfbf3df441789fb662e494b2482baa9e9c489d", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -230,7 +230,7 @@ fn test_inspect() {\n                .collect::<Vec<uint>>();\n \n     assert_eq!(n, xs.len());\n-    assert_eq!(xs[], ys[]);\n+    assert_eq!(xs.index(&FullRange), ys.index(&FullRange));\n }\n \n #[test]\n@@ -281,47 +281,47 @@ fn test_iterator_nth() {\n fn test_iterator_last() {\n     let v: &[_] = &[0i, 1, 2, 3, 4];\n     assert_eq!(v.iter().last().unwrap(), &4);\n-    assert_eq!(v[0..1].iter().last().unwrap(), &0);\n+    assert_eq!(v.index(&(0..1)).iter().last().unwrap(), &0);\n }\n \n #[test]\n fn test_iterator_len() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().count(), 4);\n-    assert_eq!(v[0..10].iter().count(), 10);\n-    assert_eq!(v[0..0].iter().count(), 0);\n+    assert_eq!(v.index(&(0..4)).iter().count(), 4);\n+    assert_eq!(v.index(&(0..10)).iter().count(), 10);\n+    assert_eq!(v.index(&(0..0)).iter().count(), 0);\n }\n \n #[test]\n fn test_iterator_sum() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).sum(), 6);\n+    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).sum(), 6);\n     assert_eq!(v.iter().map(|&x| x).sum(), 55);\n-    assert_eq!(v[0..0].iter().map(|&x| x).sum(), 0);\n+    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).sum(), 0);\n }\n \n #[test]\n fn test_iterator_product() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).product(), 0);\n-    assert_eq!(v[1..5].iter().map(|&x| x).product(), 24);\n-    assert_eq!(v[0..0].iter().map(|&x| x).product(), 1);\n+    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).product(), 0);\n+    assert_eq!(v.index(&(1..5)).iter().map(|&x| x).product(), 24);\n+    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).product(), 1);\n }\n \n #[test]\n fn test_iterator_max() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).max(), Some(3));\n+    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).max(), Some(3));\n     assert_eq!(v.iter().map(|&x| x).max(), Some(10));\n-    assert_eq!(v[0..0].iter().map(|&x| x).max(), None);\n+    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).max(), None);\n }\n \n #[test]\n fn test_iterator_min() {\n     let v: &[_] = &[0i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-    assert_eq!(v[0..4].iter().map(|&x| x).min(), Some(0));\n+    assert_eq!(v.index(&(0..4)).iter().map(|&x| x).min(), Some(0));\n     assert_eq!(v.iter().map(|&x| x).min(), Some(0));\n-    assert_eq!(v[0..0].iter().map(|&x| x).min(), None);\n+    assert_eq!(v.index(&(0..0)).iter().map(|&x| x).min(), None);\n }\n \n #[test]"}, {"sha": "d20def89abbdf6e664692f74c13dc5f3d22021cd", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -43,31 +43,31 @@ fn iterator_to_slice() {\n \n             {\n                 let mut iter = data.iter();\n-                assert_eq!(iter[], other_data[]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n \n                 iter.next();\n-                assert_eq!(iter[], other_data[1..]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n \n                 iter.next_back();\n-                assert_eq!(iter[], other_data[1..2]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n \n                 let s = iter.as_slice();\n                 iter.next();\n-                assert_eq!(s, other_data[1..2]);\n+                assert_eq!(s, other_data.index(&(1..2)));\n             }\n             {\n                 let mut iter = data.iter_mut();\n-                assert_eq!(iter[], other_data[]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n                 // mutability:\n                 assert!(iter[mut] == other_data);\n \n                 iter.next();\n-                assert_eq!(iter[], other_data[1..]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n                 assert!(iter[mut] == other_data[mut 1..]);\n \n                 iter.next_back();\n \n-                assert_eq!(iter[], other_data[1..2]);\n+                assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n                 assert!(iter[mut] == other_data[mut 1..2]);\n \n                 let s = iter.into_slice();"}, {"sha": "3829d98c7a122a9132487beba316a47b1b6fb79c", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -212,11 +212,11 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{}`, found `{}`\", c, other)[]);\n+                self.err(format!(\"expected `{}`, found `{}`\", c, other).index(&FullRange));\n             }\n             None => {\n                 self.err(format!(\"expected `{}` but string was terminated\",\n-                                 c)[]);\n+                                 c).index(&FullRange));\n             }\n         }\n     }\n@@ -239,12 +239,12 @@ impl<'a> Parser<'a> {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input[start..pos];\n+                    return self.input.index(&(start..pos));\n                 }\n                 Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n-                    return self.input[start..self.input.len()];\n+                    return self.input.index(&(start..self.input.len()));\n                 }\n             }\n         }\n@@ -284,7 +284,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: self.input[0..0],\n+            ty: self.input.index(&(0..0)),\n         };\n         if !self.consume(':') { return spec }\n \n@@ -393,7 +393,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return self.input[0..0]; }\n+            Some(..) | None => { return self.input.index(&(0..0)); }\n         };\n         let mut end;\n         loop {\n@@ -405,7 +405,7 @@ impl<'a> Parser<'a> {\n                 None => { end = self.input.len(); break }\n             }\n         }\n-        self.input[start..end]\n+        self.input.index(&(start..end))\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "a9e4e8d251452a03aa7103559a8811b95527eac3", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -281,7 +281,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(self.opts[], Name::from_str(nm)) {\n+        match find_opt(self.opts.index(&FullRange), Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -309,7 +309,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(), Name::from_str(nm[])) {\n+            match find_opt(self.opts.as_slice(), Name::from_str(nm.index(&FullRange))) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -320,7 +320,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n-            match self.opt_val(nm[]) {\n+            match self.opt_val(nm.index(&FullRange)) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -585,7 +585,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur[]) {\n+        if !is_arg(cur.index(&FullRange)) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -595,7 +595,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur[2..curlen];\n+                let tail = cur.index(&(2..curlen));\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -631,7 +631,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur[range.next..curlen].to_string());\n+                        i_arg = Some(cur.index(&(range.next..curlen)).to_string());\n                         break;\n                     }\n \n@@ -650,29 +650,34 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     if name_pos == names.len() && !i_arg.is_none() {\n                         return Err(UnexpectedArgument(nm.to_string()));\n                     }\n-                    vals[optid].push(Given);\n+                    let v = &mut vals[optid];\n+                    v.push(Given);\n                   }\n                   Maybe => {\n                     if !i_arg.is_none() {\n-                        vals[optid]\n-                            .push(Val((i_arg.clone())\n+                        let v = &mut vals[optid];\n+                        v.push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(args[i + 1][]) {\n-                        vals[optid].push(Given);\n+                            is_arg(args[i + 1].index(&FullRange)) {\n+                        let v = &mut vals[optid];\n+                        v.push(Given);\n                     } else {\n                         i += 1;\n-                        vals[optid].push(Val(args[i].clone()));\n+                        let v = &mut vals[optid];\n+                        v.push(Val(args[i].clone()));\n                     }\n                   }\n                   Yes => {\n                     if !i_arg.is_none() {\n-                        vals[optid].push(Val(i_arg.clone().unwrap()));\n+                        let v = &mut vals[optid];\n+                        v.push(Val(i_arg.clone().unwrap()));\n                     } else if i + 1 == l {\n                         return Err(ArgumentMissing(nm.to_string()));\n                     } else {\n                         i += 1;\n-                        vals[optid].push(Val(args[i].clone()));\n+                        let v = &mut vals[optid];\n+                        v.push(Val(args[i].clone()));\n                     }\n                   }\n                 }\n@@ -717,7 +722,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(short_name[]);\n+                row.push_str(short_name.index(&FullRange));\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -728,18 +733,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name[]);\n+                row.push_str(long_name.index(&FullRange));\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint[]),\n+            Yes => row.push_str(hint.index(&FullRange)),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(hint[]);\n+                row.push_str(hint.index(&FullRange));\n                 row.push(']');\n             }\n         }\n@@ -752,7 +757,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(desc_sep[]);\n+            row.push_str(desc_sep.index(&FullRange));\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -764,14 +769,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace[], 54, |substr| {\n+        each_split_within(desc_normalized_whitespace.index(&FullRange), 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep[])[]);\n+        row.push_str(desc_rows.connect(desc_sep.index(&FullRange)).index(&FullRange));\n \n         row\n     });\n@@ -790,18 +795,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(opt.short_name[]);\n+        line.push_str(opt.short_name.index(&FullRange));\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name[]);\n+        line.push_str(opt.long_name.index(&FullRange));\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(opt.hint[]);\n+        line.push_str(opt.hint.index(&FullRange));\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -823,7 +828,7 @@ pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     line.push_str(opts.iter()\n                       .map(format_option)\n                       .collect::<Vec<String>>()\n-                      .connect(\" \")[]);\n+                      .connect(\" \").index(&FullRange));\n     line\n }\n \n@@ -886,9 +891,9 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                    ss[last_start..i + 1]),\n+                                    ss.index(&(last_start..(i + 1)))),\n             (B, Cr, OverLim)  => {\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 slice_start = last_start;\n                 B\n             }\n@@ -898,7 +903,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             }\n             (B, Ws, OverLim)  => {\n                 last_end = i;\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 A\n             }\n \n@@ -907,14 +912,14 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n                 B\n             }\n             (C, Cr, OverLim)  => {\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n             (C, Ws, OverLim)  => {\n-                *cont = it(ss[slice_start..last_end]);\n+                *cont = it(ss.index(&(slice_start..last_end)));\n                 A\n             }\n             (C, Ws, UnderLim) => {\n@@ -1408,7 +1413,7 @@ mod tests {\n         assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n         assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n         assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present(&[]));\n+        assert!(!matches_single.opts_present(&.index(&FullRange)));\n \n         assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n         assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n@@ -1429,7 +1434,7 @@ mod tests {\n         assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n         assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n         assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present(&[]));\n+        assert!(!matches_both.opts_present(&.index(&FullRange)));\n \n         assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n         assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(), \"foo\");"}, {"sha": "7e8382b26c4a06ad34720a8083e9ab2df8b47e41", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -453,7 +453,7 @@ impl<'a> LabelText<'a> {\n     pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s[]),\n+            &EscStr(ref s) => LabelText::escape_str(s.index(&FullRange)),\n         }\n     }\n \n@@ -482,7 +482,7 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(suffix[]);\n+        prefix.push_str(suffix.index(&FullRange));\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -676,7 +676,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name[]).unwrap()\n+            Id::new(self.name.index(&FullRange)).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "dd4291d6b51c8d46f2d6e13c8a2b07b6b14e3f9b", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -282,7 +282,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string()[]) => return,\n+        Some(filter) if !filter.is_match(args.to_string().index(&FullRange)) => return,\n         _ => {}\n     }\n \n@@ -377,7 +377,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(name[]) => {},\n+            Some(ref name) if !module.starts_with(name.index(&FullRange)) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -392,7 +392,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec[]),\n+        Some(spec) => directive::parse_logging_spec(spec.index(&FullRange)),\n         None => (Vec::new(), None),\n     };\n "}, {"sha": "6fe995d1c5864f2a38122b1629deb06e1c06526d", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -24,7 +24,7 @@ use core::num::{Float, Int};\n \n use {Rng, Rand};\n \n-pub use self::range::Range;\n+pub use self::range::Range as RandRange;\n pub use self::gamma::{Gamma, ChiSquared, FisherF, StudentT};\n pub use self::normal::{Normal, LogNormal};\n pub use self::exponential::Exp;\n@@ -104,7 +104,7 @@ pub struct Weighted<T> {\n /// ```\n pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n-    weight_range: Range<uint>\n+    weight_range: RandRange<uint>\n }\n \n impl<'a, T: Clone> WeightedChoice<'a, T> {\n@@ -138,7 +138,7 @@ impl<'a, T: Clone> WeightedChoice<'a, T> {\n             items: items,\n             // we're likely to be generating numbers in this range\n             // relatively often, so might as well cache it\n-            weight_range: Range::new(0, running_total)\n+            weight_range: RandRange::new(0, running_total)\n         }\n     }\n }"}, {"sha": "2369c094b9f40d12f010ae27aaad3e3672d2193a", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -12,7 +12,7 @@\n \n // this is surprisingly complicated to be both generic & correct\n \n-use core::prelude::*;\n+use core::prelude::{PartialOrd};\n use core::num::Int;\n \n use Rng;"}, {"sha": "51ae3114cadc668c8b5b7ec50bd759f87778e73c", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -58,7 +58,7 @@ use core::prelude::*;\n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use chacha::ChaChaRng;\n \n-use distributions::{Range, IndependentSample};\n+use distributions::{RandRange, IndependentSample};\n use distributions::range::SampleRange;\n \n #[cfg(test)]\n@@ -247,7 +247,7 @@ pub trait Rng : Sized {\n     /// ```\n     fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"Rng.gen_range called with low >= high\");\n-        Range::new(low, high).ind_sample(self)\n+        RandRange::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n@@ -291,7 +291,7 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// println!(\"{}\", rng.choose(&choices));\n     /// # // replace with slicing syntax when it's stable!\n-    /// assert_eq!(rng.choose(choices.slice_to(0)), None);\n+    /// assert_eq!(rng.choose(choices.index(&(0..0))), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {"}, {"sha": "5ebec32d733841796f250b596328b6482fe47d73", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -95,7 +95,7 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf[..cap], buf[cap..])\n+                (buf.index(&(0..cap)), buf.index(&(cap..)))\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result"}, {"sha": "ec070269fe1ae20d228d29a4cae08562d9d167c4", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -65,7 +65,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data[self.start..self.end]).unwrap()\n+        str::from_utf8(self.data.index(&(self.start..self.end))).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -300,7 +300,7 @@ pub mod reader {\n     pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n         F: FnOnce(&[u8]) -> T,\n     {\n-        f(d.data[d.start..d.end])\n+        f(d.data.index(&(d.start..d.end)))\n     }\n \n "}, {"sha": "5803da1d3350d541867c381caad253e904a4e0fa", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -105,7 +105,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts[1..].iter() {\n+        for inst in c.insts.index(&(1..)).iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "2d46fa1143e2653c14bbd342376eaaf82971f27d", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -18,6 +18,7 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n+use std::ops::Index;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -285,7 +286,7 @@ impl<'a> Parser<'a> {\n             true => Ok(()),\n             false => {\n                 self.err(format!(\"Expected {} but got EOF.\",\n-                                 expected)[])\n+                                 expected).index(&FullRange))\n             }\n         }\n     }\n@@ -294,10 +295,10 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n             true => self.err(format!(\"Expected '{}' but got '{}'.\",\n-                                     expected, self.cur())[]),\n+                                     expected, self.cur()).index(&FullRange)),\n             false => {\n                 self.err(format!(\"Expected '{}' but got EOF.\",\n-                                 expected)[])\n+                                 expected).index(&FullRange))\n             }\n         }\n     }\n@@ -443,14 +444,14 @@ impl<'a> Parser<'a> {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n                             return self.err(format!(\"Expected a literal, but got {}.\",\n-                                                    ast)[]),\n+                                                    ast).index(&FullRange)),\n                     }\n                 }\n                 if c2 < c {\n                     return self.err(format!(\"Invalid character class \\\n                                              range '{}-{}'\",\n                                             c,\n-                                            c2)[])\n+                                            c2).index(&FullRange))\n                 }\n                 ranges.push((c, self.cur()))\n             } else {\n@@ -488,7 +489,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name[]) {\n+        match find_class(ASCII_CLASSES, name.index(&FullRange)) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -513,18 +514,18 @@ impl<'a> Parser<'a> {\n                     return self.err(format!(\"No closing brace for counted \\\n                                              repetition starting at position \\\n                                              {}.\",\n-                                            start)[])\n+                                            start).index(&FullRange))\n                 }\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = self.chars[start+1..closer].iter().cloned()\n+        let inner = self.chars.index(&((start+1)..closer)).iter().cloned()\n                                                .collect::<String>();\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n         if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner[]));\n+            min = try!(self.parse_uint(inner.index(&FullRange)));\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n@@ -546,19 +547,19 @@ impl<'a> Parser<'a> {\n         if min > MAX_REPEAT {\n             return self.err(format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT)[]);\n+                min, MAX_REPEAT).index(&FullRange));\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n                 return self.err(format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT)[]);\n+                    m, MAX_REPEAT).index(&FullRange));\n             }\n             if m < min {\n                 return self.err(format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min)[]);\n+                     repetitions ({}).\", m, min).index(&FullRange));\n             }\n         }\n \n@@ -622,7 +623,7 @@ impl<'a> Parser<'a> {\n                 Ok(AstClass(ranges, flags))\n             }\n             _ => {\n-                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n+                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c).index(&FullRange))\n             }\n         }\n     }\n@@ -642,7 +643,7 @@ impl<'a> Parser<'a> {\n                     Some(i) => i,\n                     None => return self.err(format!(\n                         \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari)[]),\n+                        self.chari).index(&FullRange)),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -656,10 +657,10 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name[]) {\n+        match find_class(UNICODE_CLASSES, name.index(&FullRange)) {\n             None => {\n                 return self.err(format!(\"Could not find Unicode class '{}'\",\n-                                        name)[])\n+                                        name).index(&FullRange))\n             }\n             Some(ranges) => {\n                 Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n@@ -682,11 +683,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s[], 8) {\n+        match num::from_str_radix::<u32>(s.index(&FullRange), 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n                 self.err(format!(\"Could not parse '{}' as octal number.\",\n-                                 s)[])\n+                                 s).index(&FullRange))\n             }\n         }\n     }\n@@ -704,12 +705,12 @@ impl<'a> Parser<'a> {\n                 None => {\n                     return self.err(format!(\"Missing '}}' for unclosed \\\n                                              '{{' at position {}\",\n-                                            start)[])\n+                                            start).index(&FullRange))\n                 }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer)[])\n+        self.parse_hex_digits(self.slice(start, closer).index(&FullRange))\n     }\n \n     // Parses a two-digit hex number.\n@@ -729,7 +730,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as hex number.\", s)[])\n+                self.err(format!(\"Could not parse '{}' as hex number.\", s).index(&FullRange))\n             }\n         }\n     }\n@@ -755,7 +756,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.names.contains(&name) {\n             return self.err(format!(\"Duplicate capture group name '{}'.\",\n-                                    name)[])\n+                                    name).index(&FullRange))\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -789,7 +790,7 @@ impl<'a> Parser<'a> {\n                     if sign < 0 {\n                         return self.err(format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1))[])\n+                            self.slice(start, self.chari + 1)).index(&FullRange))\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -800,7 +801,7 @@ impl<'a> Parser<'a> {\n                         if !saw_flag {\n                             return self.err(format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1))[])\n+                                self.slice(start, self.chari + 1)).index(&FullRange))\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -812,7 +813,7 @@ impl<'a> Parser<'a> {\n                     return Ok(())\n                 }\n                 _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur())[]),\n+                    \"Unrecognized flag '{}'.\", self.cur()).index(&FullRange)),\n             }\n         }\n     }\n@@ -910,7 +911,7 @@ impl<'a> Parser<'a> {\n             Some(i) => Ok(i),\n             None => {\n                 self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s)[])\n+                                 s).index(&FullRange))\n             }\n         }\n     }\n@@ -920,7 +921,7 @@ impl<'a> Parser<'a> {\n             Some(c) => Ok(c),\n             None => {\n                 self.err(format!(\"Could not decode '{}' to unicode \\\n-                                  character.\", n)[])\n+                                  character.\", n).index(&FullRange))\n             }\n         }\n     }\n@@ -953,7 +954,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        self.chars[start..end].iter().cloned().collect()\n+        self.chars.index(&(start..end)).iter().cloned().collect()\n     }\n }\n "}, {"sha": "cb2690ce80ca1facca0eaf58d8f9bb075cfc8da9", "filename": "src/libregex/re.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -238,19 +238,19 @@ impl Regex {\n             }\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(text[last_match..s]);\n-            new.push_str(rep.reg_replace(&cap)[]);\n+            new.push_str(text.index(&(last_match..s)));\n+            new.push_str(rep.reg_replace(&cap).index(&FullRange));\n             last_match = e;\n         }\n-        new.push_str(text[last_match..text.len()]);\n+        new.push_str(text.index(&(last_match..text.len())));\n         return new;\n     }\n \n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => original[],\n-            Native(ExNative { ref original, .. }) => original[],\n+            Dynamic(ExDynamic { ref original, .. }) => original.index(&FullRange),\n+            Native(ExNative { ref original, .. }) => original.index(&FullRange),\n         }\n     }\n \n@@ -347,13 +347,13 @@ impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n                 if self.last >= text.len() {\n                     None\n                 } else {\n-                    let s = text[self.last..text.len()];\n+                    let s = text.index(&(self.last..text.len()));\n                     self.last = text.len();\n                     Some(s)\n                 }\n             }\n             Some((s, e)) => {\n-                let matched = text[self.last..s];\n+                let matched = text.index(&(self.last..s));\n                 self.last = e;\n                 Some(matched)\n             }\n@@ -384,7 +384,7 @@ impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n         } else {\n             self.cur += 1;\n             if self.cur >= self.limit {\n-                Some(text[self.splits.last..text.len()])\n+                Some(text.index(&(self.splits.last..text.len())))\n             } else {\n                 self.splits.next()\n             }\n@@ -517,7 +517,7 @@ impl<'t> Captures<'t> {\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(text[], NoExpand(\"$\"))\n+        re.replace_all(text.index(&FullRange), NoExpand(\"$\"))\n     }\n \n     /// Returns the number of captured groups."}, {"sha": "b422ac668ca8dd0c39e3c84004a4dfbc6a839103", "filename": "src/libregex/test/matches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Ftest%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Ftest%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmatches.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -121,7 +121,7 @@ mat!{match_basic_110, r\"a[b-d]\", r\"aac\", Some((1, 3))}\n mat!{match_basic_111, r\"a[-b]\", r\"a-\", Some((0, 2))}\n mat!{match_basic_112, r\"a[b-]\", r\"a-\", Some((0, 2))}\n mat!{match_basic_113, r\"a]\", r\"a]\", Some((0, 2))}\n-mat!{match_basic_114, r\"a[]]b\", r\"a]b\", Some((0, 3))}\n+mat!{match_basic_114, r\"a.index(&FullRange)]b\", r\"a]b\", Some((0, 3))}\n mat!{match_basic_115, r\"a[^bc]d\", r\"aed\", Some((0, 3))}\n mat!{match_basic_116, r\"a[^-b]c\", r\"adc\", Some((0, 3))}\n mat!{match_basic_117, r\"a[^]b]c\", r\"adc\", Some((0, 3))}"}, {"sha": "04c430da4d29080f222f10cb935b57aa1482e7c5", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -152,7 +152,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_bytes();\n-                    let haystack = self.input.as_bytes()[self.ic..];\n+                    let haystack = self.input.as_bytes().index(&(self.ic..));\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {\n@@ -503,7 +503,8 @@ impl Threads {\n \n     #[inline]\n     fn groups<'r>(&'r mut self, i: uint) -> &'r mut [Option<uint>] {\n-        self.queue[i].groups.as_mut_slice()\n+        let q = &mut self.queue[i];\n+        q.groups.as_mut_slice()\n     }\n }\n "}, {"sha": "1d446817c189d4c5e1bbdf33e384e41f118e7abc", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -506,7 +506,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, m[]);\n+            cx.span_lint(BOX_POINTERS, span, m.index(&FullRange));\n         }\n     }\n }\n@@ -586,7 +586,7 @@ impl LintPass for RawPointerDerive {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(item.attrs[], \"automatically_derived\") {\n+        if !attr::contains_name(item.attrs.index(&FullRange), \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -769,11 +769,11 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, it.attrs[], s.span);\n+                        warned |= check_must_use(cx, it.attrs.index(&FullRange), s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        warned |= check_must_use(cx, attrs[], s.span);\n+                        warned |= check_must_use(cx, attrs.index(&FullRange), s.span);\n                     });\n                 }\n             }\n@@ -795,7 +795,7 @@ impl LintPass for UnusedResults {\n                             msg.push_str(s.get());\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, msg[]);\n+                    cx.span_lint(UNUSED_MUST_USE, sp, msg.index(&FullRange));\n                     return true;\n                 }\n             }\n@@ -841,7 +841,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m[]);\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m.index(&FullRange));\n         }\n     }\n }\n@@ -981,7 +981,7 @@ impl NonSnakeCase {\n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get()))[]);\n+                        sort, s, to_snake_case(s.get())).index(&FullRange));\n         }\n     }\n }\n@@ -1068,7 +1068,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>()[])[]);\n+                                .collect::<String>().index(&FullRange)).index(&FullRange));\n                 }\n             }\n             _ => {}\n@@ -1085,7 +1085,7 @@ impl LintPass for NonUpperCaseGlobals {\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n                                 s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>()[])[]);\n+                                    .collect::<String>().index(&FullRange)).index(&FullRange));\n                 }\n             }\n             _ => {}\n@@ -1110,7 +1110,7 @@ impl UnusedParens {\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              format!(\"unnecessary parentheses around {}\",\n-                                     msg)[])\n+                                     msg).index(&FullRange))\n             }\n         }\n \n@@ -1212,7 +1212,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n-                                                 m[]);\n+                                                 m.index(&FullRange));\n                                 },\n                                 _ => ()\n                             }\n@@ -1251,7 +1251,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str())[])\n+                                              be removed\", ident.node.as_str()).index(&FullRange))\n                     }\n                 }\n             }\n@@ -1355,7 +1355,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms.iter() {\n-                self.check_unused_mut_pat(cx, a.pats[])\n+                self.check_unused_mut_pat(cx, a.pats.index(&FullRange))\n             }\n         }\n     }\n@@ -1476,7 +1476,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                format!(\"missing documentation for {}\", desc)[]);\n+                format!(\"missing documentation for {}\", desc).index(&FullRange));\n         }\n     }\n }\n@@ -1490,7 +1490,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(l[], \"hidden\"),\n+                Some(l) => attr::contains_name(l.index(&FullRange), \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1512,7 +1512,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, krate.attrs[],\n+        self.check_missing_docs_attrs(cx, None, krate.attrs.index(&FullRange),\n                                      krate.span, \"crate\");\n     }\n \n@@ -1526,7 +1526,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.index(&FullRange),\n                                      it.span, desc);\n     }\n \n@@ -1539,13 +1539,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs[],\n+            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.index(&FullRange),\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.index(&FullRange),\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1555,14 +1555,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              sf.node.attrs[], sf.span,\n+                                              sf.node.attrs.index(&FullRange), sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.index(&FullRange),\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n@@ -1674,7 +1674,7 @@ impl Stability {\n             _ => format!(\"use of {} item\", label)\n         };\n \n-        cx.span_lint(lint, span, msg[]);\n+        cx.span_lint(lint, span, msg.index(&FullRange));\n     }\n \n     fn is_internal(&self, cx: &Context, span: Span) -> bool {"}, {"sha": "fa451e03ab93837c3d26b5a10bf72fdcc4f0c976", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -104,7 +104,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints[]\n+        self.lints.index(&FullRange)\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -124,11 +124,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg[]),\n-                    (Some(sess), false) => sess.bug(msg[]),\n+                    (None, _) => early_error(msg.index(&FullRange)),\n+                    (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg[]),\n+                    (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n                 }\n             }\n \n@@ -149,11 +149,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(msg[]),\n-                (Some(sess), false) => sess.bug(msg[]),\n+                (None, _) => early_error(msg.index(&FullRange)),\n+                (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(msg[]),\n+                (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n             }\n         }\n     }\n@@ -267,8 +267,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, warning[]),\n-                    None => sess.warn(warning[]),\n+                    Some(span) => sess.span_warn(span, warning.index(&FullRange)),\n+                    None => sess.warn(warning.index(&FullRange)),\n                 };\n                 Some(lint_id)\n             }\n@@ -278,21 +278,21 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.find_lint(lint_name[], sess, None) {\n+            match self.find_lint(lint_name.index(&FullRange), sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(lint_name[]) {\n+                                                 .get(lint_name.index(&FullRange)) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n                                      self.set_level(*lint_id, (level, CommandLine)))\n                              .collect::<Vec<()>>();\n                         }\n                         None => sess.err(format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name)[]),\n+                                                 level.as_str(), lint_name).index(&FullRange)),\n                     }\n                 }\n             }\n@@ -403,10 +403,10 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, msg[]),\n-        (Warn, None)     => sess.warn(msg[]),\n-        (Deny, Some(sp)) => sess.span_err(sp, msg[]),\n-        (Deny, None)     => sess.err(msg[]),\n+        (Warn, Some(sp)) => sess.span_warn(sp, msg.index(&FullRange)),\n+        (Warn, None)     => sess.warn(msg.index(&FullRange)),\n+        (Deny, Some(sp)) => sess.span_err(sp, msg.index(&FullRange)),\n+        (Deny, None)     => sess.err(msg.index(&FullRange)),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n@@ -499,7 +499,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                                 None => {\n                                     self.span_lint(builtin::UNKNOWN_LINTS, span,\n                                                format!(\"unknown `{}` attribute: `{}`\",\n-                                                       level.as_str(), lint_name)[]);\n+                                                       level.as_str(), lint_name).index(&FullRange));\n                                     continue;\n                                 }\n                             }\n@@ -515,7 +515,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     self.tcx.sess.span_err(span,\n                                            format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name)[]);\n+                                                   lint_name).index(&FullRange));\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -550,22 +550,22 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(it.attrs[], |cx| {\n+        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(it.attrs[], |cx| {\n+        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(i.attrs[], |cx| {\n+        self.with_lint_attrs(i.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i));\n             visit::walk_view_item(cx, i);\n@@ -591,7 +591,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs[], |cx| {\n+                self.with_lint_attrs(m.attrs.index(&FullRange), |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -607,7 +607,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(t.attrs[], |cx| {\n+        self.with_lint_attrs(t.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -624,14 +624,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(s.node.attrs[], |cx| {\n+        self.with_lint_attrs(s.node.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(v.node.attrs[], |cx| {\n+        self.with_lint_attrs(v.node.attrs.index(&FullRange), |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -725,7 +725,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {\n-                    self.span_lint(lint_id.lint, span, msg[])\n+                    self.span_lint(lint_id.lint, span, msg.index(&FullRange))\n                 }\n             }\n         }\n@@ -771,7 +771,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs[], |cx| {\n+    cx.with_lint_attrs(krate.attrs.index(&FullRange), |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;\n@@ -791,7 +791,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         for &(lint, span, ref msg) in v.iter() {\n             tcx.sess.span_bug(span,\n                               format!(\"unprocessed lint {} at {}: {}\",\n-                                      lint.as_str(), tcx.map.node_to_string(*id), *msg)[])\n+                                      lint.as_str(), tcx.map.node_to_string(*id), *msg).index(&FullRange))\n         }\n     }\n "}, {"sha": "08d19dcb607300a061c9a093cb1e97b22e2899b4", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -65,7 +65,8 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn should_link(i: &ast::ViewItem) -> bool {\n-    !attr::contains_name(i.attrs[], \"no_link\")\n+    !attr::contains_name(i.attrs.index(&FullRange), \"no_link\")\n+\n }\n \n struct CrateInfo {\n@@ -89,14 +90,15 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n+        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s).index(&FullRange));\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n         None => {}\n     }\n }\n \n+\n fn register_native_lib(sess: &Session,\n                        span: Option<Span>,\n                        name: String,\n@@ -187,8 +189,8 @@ impl<'a> CrateReader<'a> {\n         match self.extract_crate_info(i) {\n             Some(info) => {\n                 let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      info.ident[],\n-                                                      info.name[],\n+                                                      info.ident.index(&FullRange),\n+                                                      info.name.index(&FullRange),\n                                                       None,\n                                                       i.span,\n                                                       PathKind::Crate);\n@@ -433,8 +435,8 @@ impl<'a> CrateReader<'a> {\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   dep.name[],\n-                                                   dep.name[],\n+                                                   dep.name.index(&FullRange),\n+                                                   dep.name.index(&FullRange),\n                                                    Some(&dep.hash),\n                                                    span,\n                                                    PathKind::Dependency);\n@@ -445,7 +447,7 @@ impl<'a> CrateReader<'a> {\n     pub fn read_plugin_metadata<'b>(&'b mut self,\n                                     vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n         let info = self.extract_crate_info(vi).unwrap();\n-        let target_triple = self.sess.opts.target_triple[];\n+        let target_triple = self.sess.opts.target_triple.index(&FullRange);\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n@@ -454,8 +456,8 @@ impl<'a> CrateReader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n             span: vi.span,\n-            ident: ident[],\n-            crate_name: name[],\n+            ident: ident.index(&FullRange),\n+            crate_name: name.index(&FullRange),\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n@@ -480,11 +482,11 @@ impl<'a> CrateReader<'a> {\n         };\n \n         let dylib = library.dylib.clone();\n-        let register = should_link && self.existing_match(info.name[], None).is_none();\n+        let register = should_link && self.existing_match(info.name.as_slice(), None).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, info.ident[],\n-                                info.name[], vi.span, library);\n+            let (_, cmd, _) = self.register_crate(&None, info.ident.index(&FullRange),\n+                                info.name.index(&FullRange), vi.span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata\n@@ -505,8 +507,8 @@ impl<'a> CrateReader<'a> {\n impl<'a> PluginMetadata<'a> {\n     /// Read exported macros\n     pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n-        let imported_from = Some(token::intern(self.info.ident[]).ident());\n-        let source_name = format!(\"<{} macros>\", self.info.ident[]);\n+        let imported_from = Some(token::intern(self.info.ident.index(&FullRange)).ident());\n+        let source_name = format!(\"<{} macros>\", self.info.ident.index(&FullRange));\n         let mut macros = vec![];\n         decoder::each_exported_macro(self.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n@@ -548,7 +550,7 @@ impl<'a> PluginMetadata<'a> {\n                                   self.info.ident,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(self.vi_span, message[]);\n+            self.sess.span_err(self.vi_span, message.index(&FullRange));\n             self.sess.abort_if_errors();\n         }\n \n@@ -561,7 +563,7 @@ impl<'a> PluginMetadata<'a> {\n                 let message = format!(\"plugin crate `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n                                        self.info.ident);\n-                self.sess.span_err(self.vi_span, message[]);\n+                self.sess.span_err(self.vi_span, message.index(&FullRange));\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "9249bce276edd9abab48a72989f72a4b1c179c9e", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -95,7 +95,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(cdata.name[]))];\n+    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.index(&FullRange)))];\n     r.push_all(path.as_slice());\n     r\n }"}, {"sha": "25ce8a6889d0e42e13a38f90987935e6539cff95", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -75,7 +75,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data[elt.start + 4 .. elt.end]) {\n+        if eq_fn(elt.data.index(&((elt.start + 4) .. elt.end))) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -89,7 +89,7 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes[0u..4u], 0u, 4u) as ast::NodeId\n+            bytes.index(&(0u..4u)), 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,\n@@ -1191,7 +1191,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash)[]);\n+        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).index(&FullRange));\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,"}, {"sha": "592fbe4d64ec7f86bdf624a62d5aa33a7a25d2b2", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -95,7 +95,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id)[]);\n+    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).index(&FullRange));\n }\n \n #[derive(Clone)]\n@@ -154,7 +154,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(s[]);\n+    rbml_w.wr_str(s.index(&FullRange));\n     rbml_w.end_tag();\n }\n \n@@ -264,7 +264,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id)[]);\n+                format!(\"encode_symbol: id not found {}\", id).index(&FullRange));\n         }\n     }\n     rbml_w.end_tag();\n@@ -332,8 +332,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, variant.node.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, variant.node.attrs[]);\n+        encode_attributes(rbml_w, variant.node.attrs.index(&FullRange));\n+        encode_repr_attrs(rbml_w, ecx, variant.node.attrs.index(&FullRange));\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -344,9 +344,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 fields[],\n+                                                 fields.index(&FullRange),\n                                                  index);\n-                encode_struct_fields(rbml_w, fields[], def_id);\n+                encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -386,12 +386,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(def_to_string(method_def_id)[]);\n+    rbml_w.wr_str(def_to_string(method_def_id).index(&FullRange));\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name))[]);\n+                          token::get_name(method_name)).index(&FullRange));\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -529,7 +529,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(def_to_string(exp.def_id)[]);\n+                rbml_w.wr_str(def_to_string(exp.def_id).index(&FullRange));\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -562,13 +562,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)).index(&FullRange));\n             rbml_w.end_tag();\n             true\n         });\n@@ -580,7 +580,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(def_to_string(local_def(did))[]);\n+            rbml_w.wr_str(def_to_string(local_def(did)).index(&FullRange));\n             rbml_w.end_tag();\n         }\n     }\n@@ -615,7 +615,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(ch.to_string()[]);\n+    rbml_w.wr_str(ch.to_string().index(&FullRange));\n     rbml_w.end_tag();\n }\n \n@@ -627,7 +627,7 @@ fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n         ty::FnMutUnboxedClosureKind => 'm',\n         ty::FnOnceUnboxedClosureKind => 'o',\n     };\n-    rbml_w.wr_str(ch.to_string()[]);\n+    rbml_w.wr_str(ch.to_string().index(&FullRange));\n     rbml_w.end_tag();\n }\n \n@@ -788,7 +788,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id)[]);\n+                             def_to_string(param.def_id).index(&FullRange));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -864,9 +864,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, ast_method.attrs[]);\n+            encode_attributes(rbml_w, ast_method.attrs.index(&FullRange));\n             let any_types = !pty.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(ast_method.attrs[]) {\n+            if any_types || is_default_impl || should_inline(ast_method.attrs.index(&FullRange)) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -912,7 +912,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, typedef.attrs[]);\n+            encode_attributes(rbml_w, typedef.attrs.index(&FullRange));\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1046,7 +1046,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1072,8 +1072,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs[]);\n-        if tps_len > 0u || should_inline(item.attrs[]) {\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        if tps_len > 0u || should_inline(item.attrs.index(&FullRange)) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1089,7 +1089,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            item.attrs[],\n+                            item.attrs.index(&FullRange),\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1106,7 +1106,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(foreign_item.id))[]);\n+            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).index(&FullRange));\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1134,8 +1134,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1152,7 +1152,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 (*enum_definition).variants[],\n+                                 (*enum_definition).variants.index(&FullRange),\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1164,7 +1164,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         fields[],\n+                                         fields.index(&FullRange),\n                                          index);\n \n         /* Index the class*/\n@@ -1178,16 +1178,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, fields[], def_id);\n+        encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1219,7 +1219,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n@@ -1323,7 +1323,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs[]);\n+        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n@@ -1341,7 +1341,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id.def_id())[]);\n+            rbml_w.wr_str(def_to_string(method_def_id.def_id()).index(&FullRange));\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1433,14 +1433,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs[]);\n+                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs[]);\n+                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1449,7 +1449,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      associated_type.attrs[]);\n+                                      associated_type.attrs.index(&FullRange));\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1603,7 +1603,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        buckets[h % 256].push(elt);\n+        (&mut buckets[h % 256]).push(elt);\n     }\n \n     rbml_w.start_tag(tag_index);\n@@ -1869,7 +1869,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, field.node.attrs[]);\n+            encode_attributes(self.rbml_w, field.node.attrs.index(&FullRange));\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1941,13 +1941,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)).index(&FullRange));\n             rbml_w.end_tag();\n             true\n         });\n@@ -2116,17 +2116,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name[]);\n+    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.index(&FullRange));\n     encode_crate_triple(&mut rbml_w,\n                         tcx.sess\n                            .opts\n                            .target_triple\n-                           []);\n+                           .index(&FullRange));\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, krate.attrs[]);\n+    encode_attributes(&mut rbml_w, krate.attrs.index(&FullRange));\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "6f75770bcb827ca08e7455830ad597180ace70f2", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -315,14 +315,14 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message[]);\n+        self.sess.span_err(self.span, message.index(&FullRange));\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display())[]);\n+                            self.ident, i+1, got, path.display()).index(&FullRange));\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -332,15 +332,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     format!(\"crate `{}` path {}{}: {}\",\n-                            self.ident, \"#\", i+1, path.display())[]);\n+                            self.ident, \"#\", i+1, path.display()).index(&FullRange));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display())[]);\n+                                    r.ident, i+1, path.display()).index(&FullRange));\n                     }\n                 }\n             }\n@@ -386,7 +386,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(rlib_prefix[]) &&\n+            let (hash, rlib) = if file.starts_with(rlib_prefix.index(&FullRange)) &&\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n@@ -446,26 +446,26 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name)[]);\n+                            self.crate_name).index(&FullRange));\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                   p.display()).index(&FullRange));\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n                             self.sess.note(format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                   p.display()).index(&FullRange));\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), name[]);\n+                    note_crate_name(self.sess.diagnostic(), name.index(&FullRange));\n                 }\n                 None\n             }\n@@ -519,19 +519,19 @@ impl<'a> Context<'a> {\n                                    format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name)[]);\n+                                           self.crate_name).index(&FullRange));\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap()\n-                                               .display())[]);\n+                                               .display()).index(&FullRange));\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     format!(r\"candidate #{}: {}\", error,\n-                                            lib.display())[]);\n+                                            lib.display()).index(&FullRange));\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -606,30 +606,30 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashSet::new();\n         let mut dylibs = HashSet::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(l[])).filter(|loc| {\n+            let mut locs = locs.iter().map(|l| Path::new(l.index(&FullRange))).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display())[]);\n+                                     self.crate_name, loc.display()).index(&FullRange));\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n                         sess.err(format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display())[]);\n+                                         self.crate_name, loc.display()).index(&FullRange));\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix[]) && file.ends_with(suffix[]) {\n+                    if file.starts_with(prefix.index(&FullRange)) && file.ends_with(suffix.index(&FullRange)) {\n                         return true\n                     }\n                 }\n                 sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display())[]);\n+                                 self.crate_name, loc.display()).index(&FullRange));\n                 false\n             });\n \n@@ -662,7 +662,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(format!(\"crate name: {}\", name)[]);\n+    diag.handler().note(format!(\"crate name: {}\", name).index(&FullRange));\n }\n \n impl ArchiveMetadata {"}, {"sha": "135cd8d8d081e540feef1a12c1d2ff56d71ea300", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -98,7 +98,7 @@ fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data[start_pos..end_pos]);\n+    return op(st.data.index(&(start_pos..end_pos)));\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -251,7 +251,7 @@ fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n         '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n         c => {\n             st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c)[])\n+                                    c).index(&FullRange))\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n         }\n         '[' => {\n             let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(parse_str(st, ']')[]);\n+            let ident = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -357,7 +357,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '|');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']')[]);\n+        let nm = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -481,7 +481,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let name = token::intern(parse_str(st, ']')[]);\n+        let name = token::intern(parse_str(st, ']').index(&FullRange));\n         return ty::mk_param(tcx, space, index, name);\n       }\n       '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n@@ -637,7 +637,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(abi_str[]).expect(abi_str)\n+        abi::lookup(abi_str.index(&FullRange)).expect(abi_str)\n     })\n }\n \n@@ -733,8 +733,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         panic!();\n     }\n \n-    let crate_part = buf[0u..colon_idx];\n-    let def_part = buf[colon_idx + 1u..len];\n+    let crate_part = buf.index(&(0u..colon_idx));\n+    let def_part = buf.index(&((colon_idx + 1u)..len));\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "955f522b8041b36dfe2b2694ab530cab157c7618", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -48,7 +48,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       format!(\"unbound path {}\",\n-                                              path.repr(tcx))[])\n+                                              path.repr(tcx)).index(&FullRange))\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "7f11317a4b96a7c40f9701818d1d75b8b763ce65", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -132,7 +132,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| x[])\n+            path_as_str.as_ref().map(|x| x.index(&FullRange))\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -1900,7 +1900,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n             None => {\n                 dcx.tcx.sess.bug(\n                     format!(\"unknown tag found in side tables: {:x}\",\n-                            tag)[]);\n+                            tag).index(&FullRange));\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1985,7 +1985,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag)[]);\n+                                    tag).index(&FullRange));\n                     }\n                 }\n             }"}, {"sha": "2f0e3aeee9b526b54c2f059eab68113ff8ca70a0", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(arm.pats[],\n+                    let pats_exit = self.pats_any(arm.pats.index(&FullRange),\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -616,14 +616,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"no loop scope for id {}\",\n-                                    loop_id)[]);\n+                                    loop_id).index(&FullRange));\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             format!(\"bad entry `{}` in def_map for label\",\n-                                    r)[]);\n+                                    r).index(&FullRange));\n                     }\n                 }\n             }"}, {"sha": "34dae07642d99d1ef8b8a9bd4316786e7545e72e", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -52,7 +52,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name[]).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.index(&FullRange)).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n@@ -85,7 +85,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\", i, s[])[]);\n+            label.push_str(format!(\"exiting scope_{} {}\", i, s.index(&FullRange)).index(&FullRange));\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "5024e5c4f77de0ebdc745e4751d24b569301968a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -74,11 +74,11 @@ impl<'a> CheckLoopVisitor<'a> {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` inside of a closure\", name)[]);\n+                                   format!(\"`{}` inside of a closure\", name).index(&FullRange));\n             }\n             Normal => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` outside of loop\", name)[]);\n+                                   format!(\"`{}` outside of loop\", name).index(&FullRange));\n             }\n         }\n     }"}, {"sha": "5712ce3792ea68cb0cac9dc9881a6e7103c09b4e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -47,7 +47,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n-/// + _     + []             +\n+/// + _     + .index(&FullRange)             +\n /// ++++++++++++++++++++++++++\n /// + true  + [First]        +\n /// ++++++++++++++++++++++++++\n@@ -161,7 +161,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                arm.pats[]);\n+                                                arm.pats.index(&FullRange));\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -198,7 +198,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms[], source);\n+            check_arms(cx, inlined_arms.index(&FullRange), source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -230,7 +230,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                     pat.span,\n                     format!(\"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat))[]);\n+                            pat_to_string(uncovered_pat)).index(&FullRange));\n             });\n \n             // Check legality of move bindings.\n@@ -303,7 +303,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, v[], LeaveOutWitness) {\n+            match is_useful(cx, &seen, v.index(&FullRange), LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -355,7 +355,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match pats[] {\n+            let witness = match pats.index(&FullRange) {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -609,7 +609,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = pats[];\n+                                let pat_slice = pats.index(&FullRange);\n                                 let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n@@ -656,10 +656,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r[], &ctor, 0u, arity)\n+        specialize(cx, r.index(&FullRange), &ctor, 0u, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0u, arity) {\n-        Some(v) => is_useful(cx, &matrix, v[], witness),\n+        Some(v) => is_useful(cx, &matrix, v.index(&FullRange), witness),\n         None => NotUseful\n     }\n }\n@@ -729,7 +729,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n-/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n+/// For instance, a tuple pattern (_, 42u, Some(.index(&FullRange))) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n     match ty.sty {\n@@ -926,8 +926,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n     };\n     head.map(|mut head| {\n-        head.push_all(r[..col]);\n-        head.push_all(r[col + 1..]);\n+        head.push_all(r.index(&(0..col)));\n+        head.push_all(r.index(&((col + 1)..)));\n         head\n     })\n }\n@@ -1044,7 +1044,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             format!(\"binding pattern {} is not an \\\n                                      identifier: {}\",\n                                     p.id,\n-                                    p.node)[]);\n+                                    p.node).index(&FullRange));\n                     }\n                 }\n             }"}, {"sha": "994a2b0dc8abc8a0b20c347c1db0cedf5ca10fd5", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         };\n \n         self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix)[]);\n+                                                to have {}\", suffix).index(&FullRange));\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -170,7 +170,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n                                        format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg())[])\n+                                                destructors\", self.msg()).index(&FullRange))\n             }\n             _ => {}\n         }\n@@ -234,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n                         let msg = \"constants cannot refer to other statics, \\\n                                    insert an intermediate constant \\\n                                    instead\";\n-                        self.tcx.sess.span_err(e.span, msg[]);\n+                        self.tcx.sess.span_err(e.span, msg.index(&FullRange));\n                     }\n                     _ => {}\n                 }"}, {"sha": "75851f0a8533327f145a660515996b30935fc132", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -105,7 +105,7 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                           _ => {\n                             self.sess.span_err(e.span,\n                               format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node))[]);\n+                                      self.ast_map.node_to_string(def_id.node)).index(&FullRange));\n                             return;\n                           },\n                         }"}, {"sha": "213b4ac4736b604d40b5c7081f388aa79b841439", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -48,7 +48,7 @@ use std::rc::Rc;\n //     target uses\". This _includes_ integer-constants, plus the following\n //     constructors:\n //\n-//        fixed-size vectors and strings: [] and \"\"/_\n+//        fixed-size vectors and strings: .index(&FullRange) and \"\"/_\n //        vector and string slices: &[] and &\"\"\n //        tuples: (,)\n //        enums: foo(...)\n@@ -117,7 +117,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants[], variant_def.node)\n+                    variant_expr(variants.index(&FullRange), variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -138,7 +138,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(variants[], variant_def.node).map(|e| e.id)\n+                    variant_expr(variants.index(&FullRange), variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -364,7 +364,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s[])\n+        Err(s) => tcx.sess.span_fatal(e.span, s.index(&FullRange))\n     }\n }\n "}, {"sha": "49ae1bce193a0ada23ec1a8e7aed8e0b8ecf9bb4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n-                temp_bits[]\n+                temp_bits.index(&FullRange)\n             }\n         };\n         debug!(\"{} each_bit_for_node({}, cfgidx={}) bits={}\",\n@@ -421,7 +421,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(orig_kills[]);\n+                bits.clone_from_slice(orig_kills.index(&FullRange));\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -554,7 +554,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF)[]);\n+            result.push_str(format!(\"{:02x}\", v & 0xFF).index(&FullRange));\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "8182dec2db064ce0eeb2f79c23518f912c73187b", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name)[]);\n+                                 data.name).index(&FullRange));\n             });\n             return Vec::new();\n         }\n@@ -197,7 +197,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 })[]);\n+                                 }).index(&FullRange));\n             }\n         }\n     }\n@@ -222,7 +222,7 @@ fn add_library(sess: &session::Session,\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name)[]);\n+                                 data.name).index(&FullRange));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "ca20cbc736dc03e7278308af2b0dee467b66fc51", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -869,7 +869,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx()))[])\n+                                    method_ty.repr(self.tcx())).index(&FullRange))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -1191,7 +1191,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected def: {} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg[])\n+                                tcx.sess.span_bug(pat.span, msg.index(&FullRange))\n                             }\n                         }\n                     }"}, {"sha": "9122359bb9ef3e7852a91aa40711eb8422df0495", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -142,7 +142,7 @@ pub trait Combine<'tcx> : Sized {\n                             for _ in a_regions.iter() {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            invariance[]\n+                            invariance.index(&FullRange)\n                         }\n                     };\n \n@@ -480,7 +480,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx))[]);\n+                    b.repr(this.infcx().tcx)).index(&FullRange));\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -856,7 +856,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx()))[]);\n+                            r.repr(self.tcx())).index(&FullRange));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "1566a7938d3dd6e4178f9b16ac80dc8d464e3403", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -200,9 +200,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(var_origins[],\n-                                                     trace_origins[],\n-                                                     same_regions[]);\n+                        self.report_processed_errors(var_origins.index(&FullRange),\n+                                                     trace_origins.index(&FullRange),\n+                                                     same_regions.index(&FullRange));\n                     }\n                 }\n             }\n@@ -376,7 +376,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr))[]);\n+                 ty::type_err_to_str(self.tcx, terr)).index(&FullRange));\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -445,25 +445,25 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx))[]);\n+                        sub.user_string(self.tcx)).index(&FullRange));\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)).index(&FullRange));\n             }\n \n             _ => {\n@@ -472,15 +472,15 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     format!(\n                         \"{} may not live long enough\",\n-                        labeled_user_string)[]);\n+                        labeled_user_string).index(&FullRange));\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} must be valid for \", labeled_user_string)[],\n+                    format!(\"{} must be valid for \", labeled_user_string).index(&FullRange),\n                     sub,\n                     \"...\");\n             }\n@@ -522,7 +522,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[]);\n+                                .to_string()).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -534,7 +534,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[],\n+                                .to_string()).index(&FullRange),\n                     sup,\n                     \"\");\n             }\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_string())[]);\n+                                                      .to_string()).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -622,7 +622,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -648,7 +648,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -714,7 +714,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -861,7 +861,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(taken[]);\n+        let life_giver = LifeGiver::with_taken(taken.index(&FullRange));\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(inputs[], lifetime,\n+            inputs = self.rebuild_args_ty(inputs.index(&FullRange), lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -972,7 +972,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names[0][]).name;\n+            let name = token::str_to_ident(names[0].index(&FullRange)).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1222,7 +1222,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 .sess\n                                 .fatal(format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path))[])\n+                                        pprust::path_to_string(path)).index(&FullRange))\n                         }\n                         Some(&d) => d\n                     };\n@@ -1420,7 +1420,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, msg[]);\n+        self.tcx.sess.span_help(span, msg.index(&FullRange));\n     }\n \n     fn report_inference_failure(&self,\n@@ -1463,7 +1463,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             var_origin.span(),\n             format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description)[]);\n+                    var_description).index(&FullRange));\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1511,7 +1511,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             format!(\"...so that {} ({})\",\n-                                    desc, values_str)[]);\n+                                    desc, values_str).index(&FullRange));\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc)[]);\n+                            format!(\"...so that {}\", desc).index(&FullRange));\n                     }\n                 }\n             }\n@@ -1537,7 +1537,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_string())[])\n+                            .to_string()).index(&FullRange))\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1562,7 +1562,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string())[]);\n+                                id).get().to_string()).index(&FullRange));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1606,7 +1606,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1618,28 +1618,28 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)).index(&FullRange));\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the type `{}` \\\n                              will meet the declared lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)).index(&FullRange));\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\")[]);\n+                                are satisfied\").index(&FullRange));\n             }\n         }\n     }\n@@ -1691,15 +1691,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(gen.lifetimes[]);\n+                    taken.push_all(gen.lifetimes.index(&FullRange));\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(m.pe_generics().lifetimes[]);\n+                        taken.push_all(m.pe_generics().lifetimes.index(&FullRange));\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1758,10 +1758,10 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_string(self.counter.get())[]);\n+            s.push_str(num_to_string(self.counter.get()).index(&FullRange));\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(s[]).name);\n+                                    token::str_to_ident(s.index(&FullRange)).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "cd4705d4fb2db19169083ad548a4150fd0fbd8ec", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -189,7 +189,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 span,\n                 format!(\"region {} is not associated with \\\n                          any bound region from A!\",\n-                        r0)[])\n+                        r0).index(&FullRange))\n         }\n     }\n \n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"could not find original bound region for {}\", r)[]);\n+                format!(\"could not find original bound region for {}\", r).index(&FullRange));\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r)[]);\n+                    format!(\"found non-region-vid: {}\", r).index(&FullRange));\n             }\n         }).collect()\n }"}, {"sha": "a3d94e8b844b54b6ab03c4d0046b30e01798aa55", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -1002,7 +1002,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.span_err(sp, format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str)[]);\n+                    error_str).index(&FullRange));\n \n                 for err in err.iter() {\n                     ty::note_and_explain_type_err(self.tcx, *err)"}, {"sha": "ea5d8456117bac30a2c2128364f45e576342040b", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 origin.span(),\n                 format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx))[]);\n+                        sup.repr(self.tcx)).index(&FullRange));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -736,7 +736,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\n                 format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx))[]);\n+                        b.repr(self.tcx)).index(&FullRange));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -753,7 +753,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {}, {}\",\n                         a,\n-                        b)[]);\n+                        b).index(&FullRange));\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -836,7 +836,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               self.tcx.sess.bug(\n                   format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx))[]);\n+                          b.repr(self.tcx)).index(&FullRange));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -856,7 +856,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {}, {}\",\n                             a,\n-                            b)[]);\n+                            b).index(&FullRange));\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -977,7 +977,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n-            self.extract_values_and_collect_conflicts(var_data[],\n+            self.extract_values_and_collect_conflicts(var_data.index(&FullRange),\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values\n@@ -1415,7 +1415,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     for var {}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)).index(&FullRange));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1459,7 +1459,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)).index(&FullRange));\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "9035d72e9a2fb633443a928ed7441d04779b6e6a", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug(\n                         format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx))[]);\n+                                t.repr(self.infcx.tcx)).index(&FullRange));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "24cfe51123058970caa01a030ef40fd0244dc303", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id)[]);\n+                                        node_id).index(&FullRange));\n           }\n         }\n     }\n@@ -597,7 +597,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.ir.tcx.sess.span_bug(\n                 span,\n                 format!(\"no live node registered for node {}\",\n-                        node_id)[]);\n+                        node_id).index(&FullRange));\n           }\n         }\n     }\n@@ -1132,7 +1132,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(exprs[], succ)\n+            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1157,7 +1157,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(args[], succ);\n+            let succ = self.propagate_through_exprs(args.index(&FullRange), succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1170,11 +1170,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(args[], succ)\n+            self.propagate_through_exprs(args.index(&FullRange), succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(exprs[], succ)\n+            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {"}, {"sha": "af80edb739eb51ef1c389f95abad1b4cfdb9996a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -594,7 +594,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx()))[]);\n+                                  ty.repr(self.tcx())).index(&FullRange));\n                   }\n               }\n           }\n@@ -1505,7 +1505,7 @@ impl<'tcx> Repr<'tcx> for InteriorKind {\n                 token::get_name(fld).get().to_string()\n             }\n             InteriorField(PositionalField(i)) => format!(\"#{}\", i),\n-            InteriorElement(_) => \"[]\".to_string(),\n+            InteriorElement(_) => \".index(&FullRange)\".to_string(),\n         }\n     }\n }"}, {"sha": "df545c7570a020e613454ab75224e854ceed7767", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -615,10 +615,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg[]);\n+                self.tcx.sess.span_err(span, msg.index(&FullRange));\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, msg[])\n+                        self.tcx.sess.span_note(span, msg.index(&FullRange))\n                     }\n                     None => {},\n                 }\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg[]);\n+        self.tcx.sess.span_err(span, msg.index(&FullRange));\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -742,7 +742,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                              method_id,\n                                              None,\n                                              format!(\"method `{}`\",\n-                                                     string)[]));\n+                                                     string).index(&FullRange)));\n     }\n \n     // Checks that a path is in scope.\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   format!(\"{} `{}`\", tyname, name)[])\n+                                   format!(\"{} `{}`\", tyname, name).index(&FullRange))\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "51602e88f9342c3dfe0a84ff545d448b54dcb15c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs[]) {\n+    if attributes_specify_inlining(item.attrs.index(&FullRange)) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs[]) ||\n+    if attributes_specify_inlining(method.attrs.index(&FullRange)) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    method.attrs[]) {\n+                                    method.attrs.index(&FullRange)) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 None => {\n                     self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item)[])\n+                                              search_item).index(&FullRange))\n                 }\n             }\n         }\n@@ -341,7 +341,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     .bug(format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item))[])\n+                                     .node_to_string(search_item)).index(&FullRange))\n             }\n         }\n     }"}, {"sha": "5be092eb1bd3ebd0d1b16f169b7f0c12b62585d4", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -643,7 +643,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n     // due to rule C.\n     //\n-    // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n+    // FIXME(#6308) -- Note that `.index(&FullRange)` patterns work more smoothly post-DST.\n \n     match local.init {\n         Some(ref expr) => {"}, {"sha": "6cdbd9872bc4ed5b1e3548c1bab87f9014ce6f20", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -399,7 +399,7 @@ impl<'a> LifetimeContext<'a> {\n         self.sess.span_err(\n             lifetime_ref.span,\n             format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name))[]);\n+                    token::get_name(lifetime_ref.name)).index(&FullRange));\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -413,7 +413,7 @@ impl<'a> LifetimeContext<'a> {\n                         lifetime.lifetime.span,\n                         format!(\"illegal lifetime parameter name: `{}`\",\n                                 token::get_name(lifetime.lifetime.name))\n-                            []);\n+                            .index(&FullRange));\n                 }\n             }\n \n@@ -427,7 +427,7 @@ impl<'a> LifetimeContext<'a> {\n                         format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.lifetime.name))\n-                            []);\n+                            .index(&FullRange));\n                 }\n             }\n "}, {"sha": "a3973d5854263b276bfbaff9cc92e6232ad959ab", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -604,7 +604,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                      (space={}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i)[]);\n+                                    space, i).index(&FullRange));\n                             }\n                         }\n                 }\n@@ -661,7 +661,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx()))[]);\n+                            self.substs.repr(self.tcx())).index(&FullRange));\n             }\n         };\n "}, {"sha": "49c7d6aafaa5e4583057a7a5cad507d3f2a593c9", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -137,7 +137,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_err => {\n             tcx.sess.bug(\n                 format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx))[])\n+                        ty.repr(tcx)).index(&FullRange))\n         }\n     }\n }"}, {"sha": "fd6773afb765d055ed795aaa26feb21b25069ffe", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -339,5 +339,5 @@ pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n         span,\n         format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit)[]);\n+            suggested_limit).index(&FullRange));\n }"}, {"sha": "c5800f3b48caa9beae129cde604a1214b3b96c4d", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        self.predicates[]\n+        self.predicates.index(&FullRange)\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it"}, {"sha": "4ffae39ea44f0150a31392d2ccdc59336fce7f6b", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -903,7 +903,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), caller_trait_refs[]);\n+                self.tcx(), caller_trait_refs.index(&FullRange));\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -1467,7 +1467,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx()))[]);\n+                        self_ty.repr(self.tcx())).index(&FullRange));\n             }\n         };\n \n@@ -1637,7 +1637,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }\n@@ -1816,7 +1816,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx()))[]);\n+                            self_ty.repr(self.tcx())).index(&FullRange));\n             }\n         };\n \n@@ -1946,7 +1946,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }"}, {"sha": "af35b9e0e8273c5690a890f2bea4dd60eb2dbea4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -2006,8 +2006,8 @@ impl<'tcx> Predicate<'tcx> {\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n /// Here, the `Generics` for `Foo` would contain a list of bounds like\n-/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n+/// `[.index(&FullRange), [U:Bar<T>]]`.  Now if there were some particular reference\n+/// like `Foo<int,uint>`, then the `GenericBounds` would be `[.index(&FullRange),\n /// [uint:Bar<int>]]`.\n #[derive(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n@@ -2184,7 +2184,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             _ => {\n                 cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id))[])\n+                                    cx.map.node_to_string(id)).index(&FullRange))\n             }\n         }\n     }\n@@ -2269,7 +2269,7 @@ impl UnboxedClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(err[]),\n+            Err(err) => cx.sess.fatal(err.index(&FullRange)),\n         }\n     }\n }\n@@ -2590,7 +2590,7 @@ impl FlagComputation {\n             }\n \n             &ty_tup(ref ts) => {\n-                self.add_tys(ts[]);\n+                self.add_tys(ts.index(&FullRange));\n             }\n \n             &ty_bare_fn(_, ref f) => {\n@@ -2613,7 +2613,7 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(fn_sig.0.inputs[]);\n+        computation.add_tys(fn_sig.0.inputs.index(&FullRange));\n \n         if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n@@ -2782,7 +2782,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n     bounds.len() == 0 ||\n-        bounds[1..].iter().enumerate().all(\n+        bounds.index(&(1..)).iter().enumerate().all(\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n@@ -3037,7 +3037,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty))[]),\n+                                 ty_to_string(cx, ty)).index(&FullRange)),\n     }\n }\n \n@@ -3371,7 +3371,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds[],\n+                    TypeContents::union(flds.index(&FullRange),\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -3395,15 +3395,15 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(tys[],\n+                TypeContents::union(tys.index(&FullRange),\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(variants[], |variant| {\n-                        TypeContents::union(variant.args[],\n+                    TypeContents::union(variants.index(&FullRange), |variant| {\n+                        TypeContents::union(variant.args.index(&FullRange),\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -3986,7 +3986,7 @@ pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty))[])\n+                                 ty_to_string(cx, ty)).index(&FullRange))\n     }\n }\n \n@@ -4087,7 +4087,7 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id))[])\n+                    cx.map.node_to_string(id)).index(&FullRange))\n     }\n }\n \n@@ -4100,7 +4100,7 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id))[])\n+                   cx.map.node_to_string(id)).index(&FullRange))\n     }\n }\n \n@@ -4187,7 +4187,7 @@ pub fn ty_region(tcx: &ctxt,\n             tcx.sess.span_bug(\n                 span,\n                 format!(\"ty_region() invoked on an inappropriate ty: {}\",\n-                        s)[]);\n+                        s).index(&FullRange));\n         }\n     }\n }\n@@ -4248,11 +4248,11 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n         Some(f) => {\n             cx.sess.bug(format!(\"Node id {} is not an expr: {}\",\n                                 id,\n-                                f)[]);\n+                                f).index(&FullRange));\n         }\n         None => {\n             cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id)[]);\n+                                in the node map\", id).index(&FullRange));\n         }\n     }\n }\n@@ -4268,14 +4268,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                     cx.sess.bug(\n                         format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n-                                pat)[]);\n+                                pat).index(&FullRange));\n                 }\n             }\n         }\n         r => {\n             cx.sess.bug(format!(\"Variable id {} maps to {}, not local\",\n                                 id,\n-                                r)[]);\n+                                r).index(&FullRange));\n         }\n     }\n }\n@@ -4306,7 +4306,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             cx.sess.bug(\n                                 format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n                                          {}\",\n-                                        b)[]);\n+                                        b).index(&FullRange));\n                         }\n                     }\n                 }\n@@ -4334,7 +4334,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                                          []);\n+                                                          .index(&FullRange));\n                                 }\n                             }\n                         }\n@@ -4397,7 +4397,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeLength with bad sty: {}\",\n-                                          ty_to_string(cx, ty))[])\n+                                          ty_to_string(cx, ty)).index(&FullRange))\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, substs) => {\n@@ -4409,7 +4409,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n-                                          ty_to_string(cx, ty))[])\n+                                          ty_to_string(cx, ty)).index(&FullRange))\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n@@ -4422,7 +4422,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {}\", expr.id)[]);\n+                \"no def-map entry for expr {}\", expr.id).index(&FullRange));\n         }\n     }\n }\n@@ -4517,7 +4517,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                         expr.span,\n                         format!(\"uncategorized def for expr {}: {}\",\n                                 expr.id,\n-                                def)[]);\n+                                def).index(&FullRange));\n                 }\n             }\n         }\n@@ -4642,7 +4642,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n-              .collect::<Vec<String>>())[]);\n+              .collect::<Vec<String>>()).index(&FullRange));\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -4897,7 +4897,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(ms[]);\n+                            ast_util::split_trait_methods(ms.index(&FullRange));\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -4916,14 +4916,14 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                     _ => {\n                         cx.sess.bug(format!(\"provided_trait_methods: `{}` is \\\n                                              not a trait\",\n-                                            id)[])\n+                                            id).index(&FullRange))\n                     }\n                 }\n             }\n             _ => {\n                 cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a \\\n                                      trait\",\n-                                    id)[])\n+                                    id).index(&FullRange))\n             }\n         }\n     } else {\n@@ -5160,7 +5160,7 @@ impl<'tcx> VariantInfo<'tcx> {\n             },\n             ast::StructVariantKind(ref struct_def) => {\n \n-                let fields: &[StructField] = struct_def.fields[];\n+                let fields: &[StructField] = struct_def.fields.index(&FullRange);\n \n                 assert!(fields.len() > 0);\n \n@@ -5311,7 +5311,7 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 cx.sess\n                                                   .span_err(e.span,\n                                                             format!(\"expected constant: {}\",\n-                                                                    *err)[]);\n+                                                                    *err).index(&FullRange));\n                                             }\n                                         },\n                                     None => {}\n@@ -5601,7 +5601,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             _ => {\n                 cx.sess.bug(\n                     format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node))[]);\n+                            cx.map.node_to_string(did.node)).index(&FullRange));\n             }\n         }\n     } else {\n@@ -5634,7 +5634,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(i.to_string()[]),\n+            name: token::intern(i.to_string().index(&FullRange)),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5845,7 +5845,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected positive integer for repeat count, found {}\",\n-                found)[]);\n+                found).index(&FullRange));\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5860,7 +5860,7 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n             };\n             tcx.sess.span_err(count_expr.span, format!(\n                 \"expected constant integer for repeat count, found {}\",\n-                found)[]);\n+                found).index(&FullRange));\n         }\n     }\n     0\n@@ -6644,7 +6644,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(d[])\n+        Some(d) => f(d.index(&FullRange))\n     }\n }\n "}, {"sha": "a38298d52dd877a86625433ab9aa585aa857b45b", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -223,17 +223,17 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, err[])\n+            Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(symbol[]) {\n+                match lib.symbol(symbol.index(&FullRange)) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, err[])\n+                    Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n                 };\n \n             // Intentionally leak the dynamic library. We can't ever unload it"}, {"sha": "88a71e53b6034752cb30f0036686786f1db6efe1", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -559,17 +559,17 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n                         early_error(format!(\"codegen option `{}` takes no \\\n-                                             value\", key)[])\n+                                             value\", key).index(&FullRange))\n                     }\n                     (None, Some(type_desc)) => {\n                         early_error(format!(\"codegen option `{0}` requires \\\n                                              {1} (-C {0}=<value>)\",\n-                                            key, type_desc)[])\n+                                            key, type_desc).index(&FullRange))\n                     }\n                     (Some(value), Some(type_desc)) => {\n                         early_error(format!(\"incorrect value `{}` for codegen \\\n                                              option `{}` - {} was expected\",\n-                                             value, key, type_desc)[])\n+                                             value, key, type_desc).index(&FullRange))\n                     }\n                     (None, None) => unreachable!()\n                 }\n@@ -579,7 +579,7 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n         }\n         if !found {\n             early_error(format!(\"unknown codegen option: `{}`\",\n-                                key)[]);\n+                                key).index(&FullRange));\n         }\n     }\n     return cg;\n@@ -592,10 +592,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = sess.target.target.target_endian[];\n-    let arch = sess.target.target.arch[];\n-    let wordsz = sess.target.target.target_word_size[];\n-    let os = sess.target.target.target_os[];\n+    let end = sess.target.target.target_endian.index(&FullRange);\n+    let arch = sess.target.target.arch.index(&FullRange);\n+    let wordsz = sess.target.target.target_word_size.index(&FullRange);\n+    let os = sess.target.target.target_os.index(&FullRange);\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -631,23 +631,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(default_cfg[]);\n+    v.push_all(default_cfg.index(&FullRange));\n     v\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(opts.target_triple[]) {\n+    let target = match Target::search(opts.target_triple.index(&FullRange)) {\n         Ok(t) => t,\n         Err(e) => {\n-            sp.handler().fatal((format!(\"Error loading target specification: {}\", e))[]);\n+            sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).index(&FullRange));\n     }\n     };\n \n-    let (int_type, uint_type) = match target.target_word_size[] {\n+    let (int_type, uint_type) = match target.target_word_size.index(&FullRange) {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w))[])\n+                                            target-word-size {}\", w)).index(&FullRange))\n     };\n \n     Config {\n@@ -845,7 +845,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(e[]));\n+        .unwrap_or_else(|e| early_error(e.index(&FullRange)));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -873,7 +873,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n         if this_bit == 0 {\n             early_error(format!(\"unknown debug flag: {}\",\n-                                *debug_flag)[])\n+                                *debug_flag).index(&FullRange))\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -918,7 +918,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n                         early_error(format!(\"unknown emission type: `{}`\",\n-                                            part)[])\n+                                            part).index(&FullRange))\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -957,7 +957,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(arg) => {\n                     early_error(format!(\"optimization level needs to be \\\n                                          between 0-3 (instead was `{}`)\",\n-                                        arg)[]);\n+                                        arg).index(&FullRange));\n                 }\n             }\n         } else {\n@@ -995,7 +995,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             Some(arg) => {\n                 early_error(format!(\"debug info level needs to be between \\\n                                      0-2 (instead was `{}`)\",\n-                                    arg)[]);\n+                                    arg).index(&FullRange));\n             }\n         }\n     } else {\n@@ -1013,7 +1013,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = SearchPaths::new();\n     for s in matches.opt_strs(\"L\").iter() {\n-        search_paths.add_path(s[]);\n+        search_paths.add_path(s.index(&FullRange));\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -1045,7 +1045,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (_, s) => {\n                 early_error(format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s)[]);\n+                                    s).index(&FullRange));\n             }\n         };\n         (name.to_string(), kind)\n@@ -1089,7 +1089,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s[]) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.index(&FullRange)) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n@@ -1099,7 +1099,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Some(arg) => {\n             early_error(format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg)[])\n+                                arg).index(&FullRange))\n         }\n     };\n \n@@ -1201,15 +1201,15 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], optgroups()[]) {\n+            &match getopts(&[\"--test\".to_string()], optgroups().index(&FullRange)) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg[], \"test\")));\n+        assert!((attr::contains_name(cfg.index(&FullRange), \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1218,7 +1218,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           optgroups()[]) {\n+                           optgroups().index(&FullRange)) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1238,7 +1238,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], optgroups()[]).unwrap();\n+            ], optgroups().index(&FullRange)).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1249,7 +1249,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], optgroups()[]).unwrap();\n+            ], optgroups().index(&FullRange)).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1259,7 +1259,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], optgroups()[]).unwrap();\n+            ], optgroups().index(&FullRange)).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "94a6bca4e06e588a6fcd0a31ecea5144f51a99ce", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -174,7 +174,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      format!(\"impossible case reached: {}\", msg)[]);\n+                      format!(\"impossible case reached: {}\", msg).index(&FullRange));\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n@@ -216,7 +216,7 @@ impl Session {\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    self.opts.target_triple[],\n+                                    self.opts.target_triple.index(&FullRange),\n                                     &self.opts.search_paths,\n                                     kind)\n     }"}, {"sha": "8f5820d92c589772274043332863a7ddb27d7a66", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -48,7 +48,7 @@ fn test_lev_distance() {\n     for c in range(0u32, MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(c[], c[]), 0);\n+        assert_eq!(lev_distance(c.index(&FullRange), c.index(&FullRange)), 0);\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";"}, {"sha": "55bba3e4215d67cc14c04dd8df0ed5e4ccb7a41a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -55,12 +55,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n         None\n       }\n     }\n@@ -271,7 +271,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_string())[]);\n+            s.push_str(format!(\"extern {} \", abi.to_string()).index(&FullRange));\n         };\n \n         s.push_str(\"fn\");\n@@ -290,7 +290,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             Some(def_id) => {\n                 s.push_str(\" {\");\n                 let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(path_str[]);\n+                s.push_str(path_str.index(&FullRange));\n                 s.push_str(\"}\");\n             }\n             None => { }\n@@ -305,7 +305,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_string(cx, \"\", true, region)[]);\n+                s.push_str(region_to_string(cx, \"\", true, region).index(&FullRange));\n             }\n         }\n \n@@ -324,15 +324,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str[]);\n+                                   bounds_str.index(&FullRange));\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str[]);\n+                                   bounds_str.index(&FullRange));\n             }\n         }\n \n@@ -365,7 +365,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t)[]);\n+                   s.push_str(ty_to_string(cx, t).index(&FullRange));\n                 }\n             }\n             ty::FnDiverging => {\n@@ -402,7 +402,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(mt_to_string(cx, tm)[]);\n+            buf.push_str(mt_to_string(cx, tm).index(&FullRange));\n             buf\n         }\n         ty_open(typ) =>\n@@ -412,7 +412,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match strs[] {\n+            match strs.index(&FullRange) {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -541,19 +541,19 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[..tps.len() - num_defaults].iter() {\n+    for t in tps.index(&(0..(tps.len() - num_defaults))).iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n+                    strs[0].index(&(1 .. (strs[0].len() - 2))) // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n+                    strs[0].index(&(1 .. (strs[0].len() - 1))) // Remove '(' and ')'\n                 } else {\n-                    strs[0][]\n+                    strs[0].index(&FullRange)\n                 },\n                 if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n     } else if strs.len() > 0 {\n@@ -566,7 +566,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s[0u..32u].to_string();\n+        s = s.index(&(0u..32u)).to_string();\n     }\n     return s;\n }\n@@ -631,15 +631,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self[])\n+        repr_vec(tcx, self.index(&FullRange))\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self[])\n+        repr_vec(tcx, self.index(&FullRange))\n     }\n }\n "}, {"sha": "6040f55ceeba039b347cd8e372cfda8469e72ac5", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -116,7 +116,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n                                   -> &[UndoLog<T,U>] {\n-        self.undo_log[snapshot.length..]\n+        self.undo_log.index(&(snapshot.length..))\n     }\n \n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {"}, {"sha": "5a5a310c56dee546180f4bee8f41a6c935713ac9", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => ar[],\n+        Some(ref ar) => ar.index(&FullRange),\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -75,22 +75,22 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n             if !o.status.success() {\n                 handler.err(format!(\"{} failed with: {}\",\n                                  cmd,\n-                                 o.status)[]);\n+                                 o.status).index(&FullRange));\n                 handler.note(format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(o.output\n-                                                  []).unwrap())\n-                          []);\n+                                                  .index(&FullRange)).unwrap())\n+                          .index(&FullRange));\n                 handler.note(format!(\"stderr ---\\n{}\",\n                                   str::from_utf8(o.error\n-                                                  []).unwrap())\n-                          []);\n+                                                  .index(&FullRange)).unwrap())\n+                          .index(&FullRange));\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            handler.err(format!(\"could not exec `{}`: {}\", ar[],\n-                             e)[]);\n+            handler.err(format!(\"could not exec `{}`: {}\", ar.index(&FullRange),\n+                             e).index(&FullRange));\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -106,16 +106,16 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths.iter() {\n         debug!(\"looking for {} inside {}\", name, path.display());\n-        let test = path.join(oslibname[]);\n+        let test = path.join(oslibname.index(&FullRange));\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(unixlibname[]);\n+            let test = path.join(unixlibname.index(&FullRange));\n             if test.exists() { return test }\n         }\n     }\n     handler.fatal(format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name)[]);\n+                          name).index(&FullRange));\n }\n \n impl<'a> Archive<'a> {\n@@ -147,7 +147,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(output.output[]).unwrap();\n+        let output = str::from_utf8(output.output.index(&FullRange)).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -179,9 +179,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = find_library(name,\n-                                    self.archive.slib_prefix[],\n-                                    self.archive.slib_suffix[],\n-                                    self.archive.lib_search_paths[],\n+                                    self.archive.slib_prefix.index(&FullRange),\n+                                    self.archive.slib_suffix.index(&FullRange),\n+                                    self.archive.lib_search_paths.index(&FullRange),\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n@@ -197,12 +197,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = obj_start[];\n+        let obj_start = obj_start.index(&FullRange);\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, name[], |fname: &str| {\n+        self.add_archive(rlib, name.index(&FullRange), |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -239,7 +239,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), args[]);\n+                       \"s\", Some(self.work_dir.path()), args.index(&FullRange));\n             }\n             return self.archive;\n         }\n@@ -259,7 +259,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), args[]);\n+                       \"cruS\", Some(self.work_dir.path()), args.index(&FullRange));\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -274,7 +274,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), args[]);\n+               flags, Some(self.work_dir.path()), args.index(&FullRange));\n \n         self.archive\n     }\n@@ -316,7 +316,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(filename[]);\n+            let new_filename = self.work_dir.path().join(filename.index(&FullRange));\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "b6f080094cfba73c92f4f2fb450d22ec319b3b55", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -44,15 +44,15 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(config, libs[]);\n-    flags.push_all(rpaths_to_flags(rpaths[])[]);\n+    let rpaths = get_rpaths(config, libs.index(&FullRange));\n+    flags.push_all(rpaths_to_flags(rpaths.index(&FullRange)).index(&FullRange));\n     flags\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath)[]));\n+        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).index(&FullRange)));\n     }\n     return ret;\n }\n@@ -82,14 +82,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths[]);\n-    log_rpaths(\"fallback\", fallback_rpaths[]);\n+    log_rpaths(\"relative\", rel_rpaths.index(&FullRange));\n+    log_rpaths(\"fallback\", fallback_rpaths.index(&FullRange));\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(fallback_rpaths[]);\n+    rpaths.push_all(fallback_rpaths.index(&FullRange));\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths[]);\n+    let rpaths = minimize_rpaths(rpaths.index(&FullRange));\n     return rpaths;\n }\n \n@@ -140,7 +140,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath[]) {\n+        if set.insert(rpath.index(&FullRange)) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "f33971a6ac0c2f2e4ad6f0e310bf22eed39a186d", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -140,7 +140,7 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.slice_mut(self.buffer_idx, size),\n-                        input[..buffer_remaining]);\n+                        input.index(&(0..buffer_remaining)));\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n@@ -156,7 +156,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input[i..i + size]);\n+            func(input.index(&(i..(i + size))));\n             i += size;\n         }\n \n@@ -166,7 +166,7 @@ impl FixedBuffer for FixedBuffer64 {\n         let input_remaining = input.len() - i;\n         copy_memory(\n             self.buffer.slice_to_mut(input_remaining),\n-            input[i..]);\n+            input.index(&(i..)));\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -188,7 +188,7 @@ impl FixedBuffer for FixedBuffer64 {\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer[..64];\n+        return self.buffer.index(&(0..64));\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }"}, {"sha": "00f1f2402c76ed8a1a8a36f3020cff83a4661403", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -65,7 +65,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.hash[]\n+        self.hash.index(&FullRange)\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -358,7 +358,7 @@ mod svh_visitor {\n             fn macro_name(mac: &Mac) -> token::InternedString {\n                 match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = path.segments[];\n+                        let s = path.segments.index(&FullRange);\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "5f5ad7efdf1bf73e8194965fb6781566d1874576", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -225,7 +225,7 @@ impl Target {\n                 Some(val) => val,\n                 None =>\n                     handler.fatal((format!(\"Field {} in target specification is required\", name))\n-                                  [])\n+                                  .index(&FullRange))\n             }\n         };\n \n@@ -242,16 +242,16 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_string()\n+                obj.find(name.index(&FullRange)).map(|o| o.as_string()\n                                     .map(|s| base.options.$key_name = s.to_string()));\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_boolean().map(|s| base.options.$key_name = s));\n+                obj.find(name.index(&FullRange)).map(|o| o.as_boolean().map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name[]).map(|o| o.as_array()\n+                obj.find(name.index(&FullRange)).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )\n@@ -367,7 +367,7 @@ impl Target {\n \n         let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n \n-        let paths = os::split_paths(target_path[]);\n+        let paths = os::split_paths(target_path.index(&FullRange));\n         // FIXME 16351: add a sane default search path?\n \n         for dir in paths.iter() {"}, {"sha": "837630c0d61ea025ae7d4749bb7d48d191804431", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -465,23 +465,23 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg)[])\n+                                nl, new_loan_msg).index(&FullRange))\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg)[]);\n+                                nl, ol_pronoun, old_loan_msg).index(&FullRange));\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n+                                nl, new_loan_msg, new_loan.kind.to_user_str()).index(&FullRange));\n                 }\n \n                 (_, _) => {\n@@ -494,7 +494,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg)[]);\n+                                old_loan_msg).index(&FullRange));\n                 }\n             }\n \n@@ -503,7 +503,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl)[]);\n+                                nl).index(&FullRange));\n                 }\n                 _ => { }\n             }\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n+                format!(\"{}; {}\", borrow_summary, rule_summary).index(&FullRange));\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -622,13 +622,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.bccx.span_err(\n                     span,\n                     format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_string(copy_path)[])\n-                    []);\n+                            self.bccx.loan_path_to_string(copy_path).index(&FullRange))\n+                    .index(&FullRange));\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n+                    .index(&FullRange));\n             }\n         }\n     }\n@@ -647,20 +647,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path)[]),\n+                                self.bccx.loan_path_to_string(move_path).index(&FullRange)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path)[])\n+                                self.bccx.loan_path_to_string(move_path).index(&FullRange))\n                 };\n \n-                self.bccx.span_err(span, err_message[]);\n+                self.bccx.span_err(span, err_message.index(&FullRange));\n                 self.bccx.span_note(\n                     loan_span,\n                     format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n+                    .index(&FullRange));\n             }\n         }\n     }\n@@ -810,7 +810,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n@@ -819,7 +819,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n@@ -829,14 +829,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp))[]);\n+                                self.bccx.loan_path_to_string(&*lp)).index(&FullRange));\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n                         format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n                 }\n             }\n         }\n@@ -956,10 +956,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         self.bccx.span_err(\n             span,\n             format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n         self.bccx.span_note(\n             loan.span,\n             format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n     }\n }"}, {"sha": "e309ba0a6348e88231053739fb93dd93a9d228f1", "filename": "src/librustc_borrowck/borrowck/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fdoc.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -138,7 +138,7 @@\n //! - `FREEZE` means that the `LV` cannot be borrowed immutably;\n //!\n //! Finally, it is never possible to move from an lvalue that appears in a\n-//! restriction. This implies that the \"empty restriction\" `(LV, [])`,\n+//! restriction. This implies that the \"empty restriction\" `(LV, .index(&FullRange))`,\n //! which contains an empty set of actions, still has a purpose---it\n //! prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n //! action because that would imply that sometimes moves are permitted\n@@ -476,7 +476,7 @@\n //! ```text\n //! &mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n //! &LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n-//! &const LV => RESTRICTIONS(LV, LT, [])\n+//! &const LV => RESTRICTIONS(LV, LT, .index(&FullRange))\n //! ```\n //!\n //! The reasoning here is that a mutable borrow must be the only writer,\n@@ -542,7 +542,7 @@\n //! restricting `MUTATE` and `CLAIM` actions:\n //!\n //! ```text\n-//! RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+//! RESTRICTIONS(*LV, LT, ACTIONS) = .index(&FullRange)                    // R-Deref-Imm-Borrowed\n //!   TYPE(LV) = &LT' Ty\n //!   LT <= LT'                                            // (1)\n //!   ACTIONS subset of [MUTATE, CLAIM]\n@@ -660,7 +660,7 @@\n //! necessary to add any restrictions at all to the final result.\n //!\n //! ```text\n-//!     RESTRICTIONS(*LV, LT, []) = []                         // R-Deref-Freeze-Borrowed\n+//!     RESTRICTIONS(*LV, LT, .index(&FullRange)) = .index(&FullRange)                         // R-Deref-Freeze-Borrowed\n //!       TYPE(LV) = &const Ty\n //! ```\n //!"}, {"sha": "8b4029f30d93f4f432c5769d7bb0a0166def1a6c", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -38,7 +38,7 @@ enum Fragment {\n     // This represents the collection of all but one of the elements\n     // from an array at the path described by the move path index.\n     // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `[]`).\n+    // of InteriorElement (i.e. array dereference `.index(&FullRange)`).\n     AllButOneFrom(MovePathIndex),\n }\n \n@@ -123,12 +123,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                item.attrs[],\n+                item.attrs.index(&FullRange),\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                m.attrs[],\n+                m.attrs.index(&FullRange),\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                m.attrs[],\n-            _ => [][],\n+                m.attrs.index(&FullRange),\n+            _ => [].index(&FullRange),\n         };\n \n         let span_err =\n@@ -144,7 +144,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = |&:| this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -156,7 +156,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = |&:| f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {}\", path_lps(moved[]));\n+    debug!(\"fragments 1 moved: {}\", path_lps(moved.index(&FullRange)));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {}\", path_lps(assigned[]));\n+    debug!(\"fragments 1 assigned: {}\", path_lps(assigned.index(&FullRange)));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {}\", path_lps(parents[]));\n+    debug!(\"fragments 2 parents: {}\", path_lps(parents.index(&FullRange)));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, parents[]));\n-    debug!(\"fragments 3 moved: {}\", path_lps(moved[]));\n+    moved.retain(|f| non_member(*f, parents.index(&FullRange)));\n+    debug!(\"fragments 3 moved: {}\", path_lps(moved.index(&FullRange)));\n \n-    assigned.retain(|f| non_member(*f, parents[]));\n-    debug!(\"fragments 3 assigned: {}\", path_lps(assigned[]));\n+    assigned.retain(|f| non_member(*f, parents.index(&FullRange)));\n+    debug!(\"fragments 3 assigned: {}\", path_lps(assigned.index(&FullRange)));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -247,16 +247,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved[]));\n+    debug!(\"fragments 4 unmoved: {}\", frag_lps(unmoved.index(&FullRange)));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, parents[]) &&\n-            non_member(mpi, moved[]) &&\n-            non_member(mpi, assigned[])\n+        Just(mpi) => non_member(mpi, parents.index(&FullRange)) &&\n+            non_member(mpi, moved.index(&FullRange)) &&\n+            non_member(mpi, assigned.index(&FullRange))\n     });\n-    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved[]));\n+    debug!(\"fragments 5 unmoved: {}\", frag_lps(unmoved.index(&FullRange)));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -433,7 +433,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, msg[])\n+            tcx.sess.opt_span_bug(opt_span, msg.index(&FullRange))\n         }\n     }\n }"}, {"sha": "86498af7d950cc5e8222447fe256e6ae3c9d4d45", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -307,7 +307,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             format!(\"invalid borrow lifetime: {}\",\n-                                    loan_region)[]);\n+                                    loan_region).index(&FullRange));\n                     }\n                 };\n                 debug!(\"loan_scope = {}\", loan_scope);"}, {"sha": "1bb143e1dc8d3c87d66a7534bf0cc2e3090070d9", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -120,7 +120,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n             bccx.span_err(\n                 move_from.span,\n                 format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from))[]);\n+                        bccx.cmt_to_string(&*move_from)).index(&FullRange));\n         }\n \n         mc::cat_downcast(ref b, _) |\n@@ -132,7 +132,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx))[]);\n+                                b.ty.user_string(bccx.tcx)).index(&FullRange));\n                 },\n                 _ => panic!(\"this path should not cause illegal move\")\n             }\n@@ -155,10 +155,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name)[]);\n+                    pat_name).index(&FullRange));\n     } else {\n         bccx.span_note(move_to_span,\n                        format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name)[]);\n+                               pat_name).index(&FullRange));\n     }\n }"}, {"sha": "36e1a4861120cde007aa2706b5b37d8f86828ab2", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -137,7 +137,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             all_loans[],\n+                             all_loans.index(&FullRange),\n                              id,\n                              decl,\n                              body);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_string(&err)[]);\n+            self.bckerr_to_string(&err).index(&FullRange));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -527,7 +527,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     use_span,\n                     format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp))[]);\n+                            self.loan_path_to_string(lp)).index(&FullRange));\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -569,7 +569,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl)[]);\n+                            nl).index(&FullRange));\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n                                                    {}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r).index(&FullRange))\n                     }\n                 };\n                 let (suggestion, _) =\n@@ -599,7 +599,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion).index(&FullRange));\n             }\n \n             move_data::MovePat => {\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx))[]);\n+                            pat_ty.user_string(self.tcx)).index(&FullRange));\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -626,7 +626,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n                                                    {}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r).index(&FullRange))\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -642,7 +642,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion).index(&FullRange));\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -673,7 +673,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp))[]);\n+                    self.loan_path_to_string(lp)).index(&FullRange));\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -799,25 +799,25 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     format!(\"{} in an aliasable location\",\n-                             prefix)[]);\n+                             prefix).index(&FullRange));\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n                                        format!(\"{} in a captured outer \\\n-                                               variable in an `Fn` closure\", prefix)[]);\n+                                               variable in an `Fn` closure\", prefix).index(&FullRange));\n                 span_help!(self.tcx.sess, self.tcx.map.span(id),\n                            \"consider changing this closure to take self by mutable reference\");\n             }\n             mc::AliasableStatic(..) |\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix)[]);\n+                    format!(\"{} in a static location\", prefix).index(&FullRange));\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix)[]);\n+                    format!(\"{} in a `&` reference\", prefix).index(&FullRange));\n             }\n         }\n \n@@ -885,12 +885,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 note_and_explain_region(\n                     self.tcx,\n                     format!(\"{} would have to be valid for \",\n-                            descr)[],\n+                            descr).index(&FullRange),\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr)[],\n+                    format!(\"...but {} is only valid for \", descr).index(&FullRange),\n                     ptr_scope,\n                     \"\");\n             }\n@@ -910,7 +910,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n                 out.push(')');\n             }\n \n@@ -924,7 +924,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(idx.to_string()[]);\n+                        out.push_str(idx.to_string().index(&FullRange));\n                     }\n                 }\n             }\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n                 out.push(')');\n             }\n "}, {"sha": "648b389414a56d6ace78f82912122263237197ab", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(self.dataflow_for_variant(e, n, variant)[]);\n+            sets.push_str(self.dataflow_for_variant(e, n, variant).index(&FullRange));\n         }\n         sets\n     }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(loan_str[]);\n+            set.push_str(loan_str.index(&FullRange));\n             saw_some = true;\n             true\n         });\n@@ -101,7 +101,8 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let dfcx = &self.analysis_data.loans;\n         let loan_index_to_path = |&mut: loan_index| {\n             let all_loans = &self.analysis_data.all_loans;\n-            all_loans[loan_index].loan_path()\n+            let l: &borrowck::Loan = &all_loans[loan_index];\n+            l.loan_path()\n         };\n         self.build_set(e, cfgidx, dfcx, loan_index_to_path)\n     }\n@@ -111,7 +112,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let move_index_to_path = |&mut: move_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let moves = move_data.moves.borrow();\n-            let the_move = &(*moves)[move_index];\n+            let the_move: &borrowck::move_data::Move = &(*moves)[move_index];\n             move_data.path_loan_path(the_move.path)\n         };\n         self.build_set(e, cfgidx, dfcx, move_index_to_path)\n@@ -122,7 +123,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n         let assign_index_to_path = |&mut: assign_index| {\n             let move_data = &self.analysis_data.move_data.move_data;\n             let assignments = move_data.var_assignments.borrow();\n-            let assignment = &(*assignments)[assign_index];\n+            let assignment: &borrowck::move_data::Assignment = &(*assignments)[assign_index];\n             move_data.path_loan_path(assignment.path)\n         };\n         self.build_set(e, cfgidx, dfcx, assign_index_to_path)"}, {"sha": "baeca7c8ffdbbc459944e043e315d0d68079b02b", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -58,12 +58,12 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 krate.attrs[],\n+                                                 krate.attrs.index(&FullRange),\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), krate.attrs[],\n+            let id = link::find_crate_name(Some(&sess), krate.attrs.index(&FullRange),\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, id[],\n+                = match phase_2_configure_and_expand(&sess, krate, id.index(&FullRange),\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -75,7 +75,7 @@ pub fn compile_input(sess: Session,\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, id[]);\n+        write_out_deps(&sess, input, &outputs, id.index(&FullRange));\n \n         if stop_after_phase_2(&sess) { return; }\n \n@@ -171,9 +171,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, krate.attrs[]);\n+        collect_crate_types(sess, krate.attrs.index(&FullRange));\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, krate.attrs[]);\n+        collect_crate_metadata(sess, krate.attrs.index(&FullRange));\n \n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -268,8 +268,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path[]).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n+                new_path.extend(os::split_paths(_old_path.index(&FullRange)).into_iter());\n+                os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -533,7 +533,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              sess.opts.output_types[],\n+                              sess.opts.output_types.index(&FullRange),\n                               outputs));\n     }\n \n@@ -547,14 +547,14 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path[]).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(new_path[]).unwrap());\n+    new_path.extend(os::split_paths(old_path.index(&FullRange)).into_iter());\n+    os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           trans.link.crate_name[]));\n+                           trans.link.crate_name.index(&FullRange)));\n \n     os::setenv(\"PATH\", old_path);\n }\n@@ -643,7 +643,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(fmap.name[]))\n+                                   .map(|fmap| escape_dep_filename(fmap.name.index(&FullRange)))\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -657,7 +657,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e)[]);\n+                               deps_filename.display(), e).index(&FullRange));\n         }\n     }\n }\n@@ -728,7 +728,7 @@ pub fn collect_crate_types(session: &Session,\n         if !res {\n             session.warn(format!(\"dropping unsupported crate type `{}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple)[]);\n+                                 *crate_type, session.opts.target_triple).index(&FullRange));\n         }\n \n         res"}, {"sha": "3fd5198ee4c4eaf77acd2724fb149c27b8c7e4de", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -105,12 +105,12 @@ fn run_compiler(args: &[String]) {\n     let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n-            match descriptions.find_description(code[]) {\n+            match descriptions.find_description(code.index(&FullRange)) {\n                 Some(ref description) => {\n                     println!(\"{}\", description);\n                 }\n                 None => {\n-                    early_error(format!(\"no extended information for {}\", code)[]);\n+                    early_error(format!(\"no extended information for {}\", code).index(&FullRange));\n                 }\n             }\n             return;\n@@ -136,7 +136,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free[0][];\n+            let ifile = matches.free[0].index(&FullRange);\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -313,7 +313,7 @@ Available lint options:\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(name[]), lint.default_level.as_str(), lint.desc);\n+                     padded(name.index(&FullRange)), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -343,7 +343,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(name[]), desc);\n+                     padded(name.index(&FullRange)), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -409,7 +409,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(args[], config::optgroups()[]) {\n+        match getopts::getopts(args.index(&FullRange), config::optgroups().index(&FullRange)) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -583,15 +583,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note[], None, diagnostic::Note)\n+                    emitter.emit(None, note.index(&FullRange), None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,\n                                      format!(\"failed to read internal \\\n-                                              stderr: {}\", e)[],\n+                                              stderr: {}\", e).index(&FullRange),\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "06ef06a214f48e0f268b9c8badcee2044b9883bd", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -296,7 +296,7 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s,\n                               ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr))[]));\n+                                  ty::expr_ty(tcx, expr)).index(&FullRange)));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -370,7 +370,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts[])),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(parts.index(&FullRange))),\n         }\n     }\n \n@@ -382,7 +382,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(message[])\n+            sess.fatal(message.index(&FullRange))\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -509,7 +509,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, id[], None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, id.index(&FullRange), None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -528,7 +528,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(src_name[])\n+    let src = sess.codemap().get_filemap(src_name.index(&FullRange))\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -589,15 +589,15 @@ pub fn pretty_print_input(sess: Session,\n             debug!(\"pretty printing flow graph for {}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\")[])\n+                                     unique path suffix (b::c::d)\").index(&FullRange))\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid)[])\n+                                   nodeid).index(&FullRange))\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -615,8 +615,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message[]),\n-                        None => sess.fatal(message[])\n+                        Some(sp) => sess.span_fatal(sp, message.index(&FullRange)),\n+                        None => sess.fatal(message.index(&FullRange))\n                     }\n                 }\n             }"}, {"sha": "3cacc1e232a8b83e22240509c7900cae313fbe38", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -279,7 +279,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(name[]))\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(name.index(&FullRange)))\n     }\n \n     pub fn re_early_bound(&self,"}, {"sha": "0a64404a7828e704edaf8fb9b6446081052af302", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -221,14 +221,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.resolve_error(sp,\n                         format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name))[]);\n+                             token::get_name(name)).index(&FullRange));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n                                  format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name))[]);\n+                                      token::get_name(name)).index(&FullRange));\n                         }\n                     }\n                 }\n@@ -1201,7 +1201,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path[]),\n+                                                 .module_path.index(&FullRange)),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions"}, {"sha": "d8c7a62e1948da70f01798da2a97102fc5b035ea", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -1071,10 +1071,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n                                           import_directive.module_path\n-                                                          [],\n+                                                          .index(&FullRange),\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, msg[]);\n+                    self.resolve_error(span, msg.index(&FullRange));\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -1104,7 +1104,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(names[])\n+        self.names_to_string(names.index(&FullRange))\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -1168,7 +1168,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(module_path[]),\n+               self.names_to_string(module_path.index(&FullRange)),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -1177,7 +1177,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           module_path[],\n+                                           module_path.index(&FullRange),\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -1774,7 +1774,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, msg[]);\n+                self.session.span_err(import_span, msg.index(&FullRange));\n             }\n             Some(_) | None => {}\n         }\n@@ -1789,7 +1789,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, msg[]);\n+            self.session.span_err(import_span, msg.index(&FullRange));\n         }\n     }\n \n@@ -1814,7 +1814,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg[]);\n+                    self.session.span_err(import_span, msg.index(&FullRange));\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1836,7 +1836,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg[]);\n+                    self.session.span_err(import_span, msg.index(&FullRange));\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1854,7 +1854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, msg[]);\n+                            self.session.span_err(import_span, msg.index(&FullRange));\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1867,7 +1867,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, msg[]);\n+                                        self.session.span_err(span, msg.index(&FullRange));\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1876,7 +1876,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, msg[]);\n+                                    self.session.span_err(import_span, msg.index(&FullRange));\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1906,7 +1906,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 .span_err(span,\n                           format!(\"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get()).index(&FullRange));\n         }\n     }\n \n@@ -1925,7 +1925,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                           format!(\"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get()).index(&FullRange));\n         }\n     }\n \n@@ -1973,7 +1973,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == module_name[] {\n+                    let msg = if \"???\" == module_name.index(&FullRange) {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name,\n@@ -2086,14 +2086,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = mpath[];\n+                let mpath = mpath.index(&FullRange);\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            mpath[idx + 1..],\n-                                            mpath[0..idx - 1]);\n+                                            mpath.index(&((idx + 1)..)),\n+                                            mpath.index(&(0..(idx - 1))));\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -2268,7 +2268,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               true) {\n                 Failed(Some((span, msg))) =>\n                     self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                     msg)[]),\n+                                                     msg).index(&FullRange)),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -2528,7 +2528,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, err[]);\n+                self.resolve_error((*imports)[index].span, err.index(&FullRange));\n             }\n         }\n \n@@ -2620,7 +2620,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {} in bindings\", d)[])\n+                    format!(\"unexpected {} in bindings\", d).index(&FullRange))\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -2766,7 +2766,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs[i + 1..], def_like, span);\n+                    return self.upvarify(ribs.index(&((i + 1)..)), def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -2859,7 +2859,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            impl_items[]);\n+                                            impl_items.index(&FullRange));\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n@@ -2937,7 +2937,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields[]);\n+                                    struct_def.fields.index(&FullRange));\n             }\n \n             ItemMod(ref module_) => {\n@@ -3010,7 +3010,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name))[])\n+                                                       name)).index(&FullRange))\n                     }\n                     seen_bindings.insert(name);\n \n@@ -3182,7 +3182,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg[]);\n+                self.resolve_error(trait_reference.path.span, msg.index(&FullRange));\n             }\n             Some(def) => {\n                 match def {\n@@ -3194,14 +3194,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(trait_reference.path.span,\n                                            format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path))[]);\n+                                                       &trait_reference.path)).index(&FullRange));\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n                                 format!(\"`type` aliases cannot be used for traits\")\n-                                    []);\n+                                    .index(&FullRange));\n                         }\n                     }\n                 }\n@@ -3398,7 +3398,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(span,\n                                     format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str)[]);\n+                                            path_str).index(&FullRange));\n             }\n         }\n     }\n@@ -3467,7 +3467,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1)[]);\n+                                i + 1).index(&FullRange));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -3476,7 +3476,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1)[]);\n+                                    i + 1).index(&FullRange));\n                     }\n                   }\n                 }\n@@ -3489,7 +3489,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\")[]);\n+                                \"#\", i + 1, \"#\").index(&FullRange));\n                 }\n             }\n         }\n@@ -3604,7 +3604,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, msg[]);\n+                        self.resolve_error(ty.span, msg.index(&FullRange));\n                     }\n                 }\n             }\n@@ -3676,7 +3676,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed))[]);\n+                                        token::get_name(renamed)).index(&FullRange));\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -3728,7 +3728,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   [])\n+                                                   .index(&FullRange))\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n@@ -3737,7 +3737,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident))[]);\n+                                            token::get_ident(ident)).index(&FullRange));\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -3763,13 +3763,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier))[]);\n+                                        path.segments.last().unwrap().identifier)).index(&FullRange));\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n                                     token::get_ident(\n-                                        path.segments.last().unwrap().identifier))[]);\n+                                        path.segments.last().unwrap().identifier)).index(&FullRange));\n                         }\n                     }\n \n@@ -3800,7 +3800,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     def: {}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, msg[]);\n+                            self.resolve_error(path.span, msg.index(&FullRange));\n                         }\n                     }\n                 }\n@@ -3862,7 +3862,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) => {\n                         self.resolve_error(span, format!(\"failed to resolve: {}\",\n-                                                         msg)[]);\n+                                                         msg).index(&FullRange));\n                     }\n                     None => ()\n                 }\n@@ -4057,7 +4057,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path[],\n+                                       module_path.index(&FullRange),\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -4072,7 +4072,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg).index(&FullRange));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -4115,7 +4115,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path[],\n+                                                 module_path.index(&FullRange),\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -4125,13 +4125,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(module_path[]));\n+                                          self.names_to_string(module_path.index(&FullRange)));\n                         (path.span, msg)\n                     }\n                 };\n \n                 self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg).index(&FullRange));\n                 return None;\n             }\n \n@@ -4172,7 +4172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs[], name, span)\n+                self.search_ribs(self.type_ribs.index(&FullRange), name, span)\n             }\n         };\n \n@@ -4227,7 +4227,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) =>\n                         self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                         msg)[]),\n+                                                         msg).index(&FullRange)),\n                     None => ()\n                 }\n \n@@ -4284,7 +4284,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                name_path[],\n+                                                name_path.index(&FullRange),\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -4322,7 +4322,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, name_path[]) {\n+        match get_module(self, path.span, name_path.index(&FullRange)) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -4533,7 +4533,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 def: {}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, msg[]);\n+                        self.resolve_error(path.span, msg.index(&FullRange));\n                     }\n                 }\n \n@@ -4594,7 +4594,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(\n                             expr.span,\n                             format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label))[])\n+                                    token::get_ident(label)).index(&FullRange))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -4733,7 +4733,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   then {}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def)[]);\n+                                 def).index(&FullRange));\n             },\n             Vacant(entry) => { entry.insert(def); },\n         }\n@@ -4749,7 +4749,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(pat.span,\n                                    format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr)[]);\n+                                           descr).index(&FullRange));\n             }\n         }\n     }\n@@ -4785,7 +4785,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return \"???\".to_string();\n         }\n         self.names_to_string(names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>()[])\n+                                  .collect::<Vec<ast::Name>>().index(&FullRange))\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "388bc4a4d30d91c8d59f5d38f7a9368f299f1d64", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -128,7 +128,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |&: s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, s[], span);\n+        creader::validate_crate_name(sess, s.index(&FullRange), span);\n         s\n     };\n \n@@ -146,7 +146,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, msg[]);\n+                    sess.span_err(attr.span, msg.index(&FullRange));\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -192,17 +192,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crate_name[]);\n+    symbol_hasher.input_str(link_meta.crate_name.index(&FullRange));\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(meta[]);\n+        symbol_hasher.input_str(meta.index(&FullRange));\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t)[]);\n+    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).index(&FullRange));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher)[]);\n+    hash.push_str(truncated_hash_result(symbol_hasher).index(&FullRange));\n     hash\n }\n \n@@ -251,7 +251,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr[1..]);\n+                result.push_str(tstr.index(&(1..)));\n             }\n         }\n     }\n@@ -260,7 +260,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result[]);\n+        return format!(\"_{}\", result.index(&FullRange));\n     }\n \n     return result;\n@@ -286,12 +286,12 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani)[]);\n+        n.push_str(format!(\"{}{}\", sani.len(), sani).index(&FullRange));\n     }\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, token::get_name(e.name()).get()[])\n+        push(&mut n, token::get_name(e.name()).get().index(&FullRange))\n     }\n \n     match hash {\n@@ -329,17 +329,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, hash[])\n+    exported_name(path, hash.index(&FullRange))\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s[])),\n+    let path = [PathName(token::intern(s.index(&FullRange))),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash[]))\n+    mangle(ast_map::Values(path.iter()), Some(hash.index(&FullRange)))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -359,7 +359,7 @@ pub fn remove(sess: &Session, path: &Path) {\n         Err(e) => {\n             sess.err(format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e)[]);\n+                             e).index(&FullRange));\n         }\n     }\n }\n@@ -374,7 +374,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(format!(\"invalid output type `{}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple)[]);\n+                             crate_type, sess.opts.target_triple).index(&FullRange));\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -439,8 +439,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (sess.target.target.options.dll_prefix[],\n-                                    sess.target.target.options.dll_suffix[]);\n+            let (prefix, suffix) = (sess.target.target.options.dll_prefix.index(&FullRange),\n+                                    sess.target.target.options.dll_suffix.index(&FullRange));\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -450,7 +450,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = sess.target.target.options.exe_suffix[];\n+            let suffix = sess.target.target.options.exe_suffix.index(&FullRange);\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -479,12 +479,12 @@ fn link_binary_output(sess: &Session,\n     if !out_is_writeable {\n         sess.fatal(format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display())[]);\n+                           out_filename.display()).index(&FullRange));\n     }\n     else if !obj_is_writeable {\n         sess.fatal(format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display())[]);\n+                           obj_filename.display()).index(&FullRange));\n     }\n \n     match crate_type {\n@@ -539,7 +539,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(l[]).unwrap();\n+                ab.add_native_library(l.index(&FullRange)).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -587,12 +587,12 @@ fn link_rlib<'a>(sess: &'a Session,\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n             match fs::File::create(&metadata).write(trans.metadata\n-                                                         []) {\n+                                                         .index(&FullRange)) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e)[]);\n+                                     e).index(&FullRange));\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -608,27 +608,27 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // extension to it. This is to work around a bug in LLDB that\n                 // would cause it to crash if the name of a file in an archive\n                 // was exactly 16 bytes.\n-                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i)[]);\n+                let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).index(&FullRange));\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    format!(\"{}.bytecode.deflate\", i)[]);\n+                    format!(\"{}.bytecode.deflate\", i).index(&FullRange));\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n                     Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                                 e)[])\n+                                                 e).index(&FullRange))\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(bc_data[]) {\n+                let bc_data_deflated = match flate::deflate_bytes(bc_data.index(&FullRange)) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display())[])\n+                                               bc_filename.display()).index(&FullRange))\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e)[])\n+                                            file: {}\", e).index(&FullRange))\n                     }\n                 };\n \n@@ -637,7 +637,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e)[]);\n+                                          {}\", e).index(&FullRange));\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -677,7 +677,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(bc_data_deflated[]) };\n+    try! { writer.write(bc_data_deflated.index(&FullRange)) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -728,11 +728,11 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 name)[]);\n+                                 name).index(&FullRange));\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, name[], sess.lto()).unwrap();\n+        ab.add_rlib(&p, name.index(&FullRange), sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -754,7 +754,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(format!(\"{}: {}\", name, *lib)[]);\n+        sess.note(format!(\"{}: {}\", name, *lib).index(&FullRange));\n     }\n }\n \n@@ -768,12 +768,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname[]);\n+    let mut cmd = Command::new(pname.index(&FullRange));\n \n-    cmd.args(sess.target.target.options.pre_link_args[]);\n+    cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(sess.target.target.options.post_link_args[]);\n+    cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -793,11 +793,11 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(format!(\"{}\", &cmd)[]);\n+                                 prog.status).index(&FullRange));\n+                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n                 let mut output = prog.error.clone();\n-                output.push_all(prog.output[]);\n-                sess.note(str::from_utf8(output[]).unwrap());\n+                output.push_all(prog.output.index(&FullRange));\n+                sess.note(str::from_utf8(output.index(&FullRange)).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n@@ -806,7 +806,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e).index(&FullRange));\n             sess.abort_if_errors();\n         }\n     }\n@@ -818,7 +818,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e)[]);\n+                sess.err(format!(\"failed to run dsymutil: {}\", e).index(&FullRange));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -867,7 +867,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(v[]);\n+            cmd.arg(v.index(&FullRange));\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -992,7 +992,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(v[]);\n+                cmd.arg(v.index(&FullRange));\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1004,7 +1004,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = sess.opts.target_triple[];\n+        let target_triple = sess.opts.target_triple.index(&FullRange);\n         let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1021,14 +1021,14 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(rpath::get_rpath_flags(rpath_config)[]);\n+        cmd.args(rpath::get_rpath_flags(rpath_config).index(&FullRange));\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n-    cmd.args(used_link_args[]);\n+    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).index(&FullRange));\n+    cmd.args(used_link_args.index(&FullRange));\n }\n \n // # Native library linking\n@@ -1082,14 +1082,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(l[],\n-                                            sess.target.target.options.staticlib_prefix[],\n-                                            sess.target.target.options.staticlib_suffix[],\n-                                            search_path[],\n+            let lib = archive::find_library(l.index(&FullRange),\n+                                            sess.target.target.options.staticlib_prefix.index(&FullRange),\n+                                            sess.target.target.options.staticlib_suffix.index(&FullRange),\n+                                            search_path.index(&FullRange),\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(v[]);\n+            cmd.arg(v.index(&FullRange));\n         }\n     }\n     if takes_hints {\n@@ -1102,7 +1102,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(l[]);\n+                cmd.arg(\"-framework\").arg(l.index(&FullRange));\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1158,7 +1158,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n         if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n-            stem[3..]\n+            stem.index(&(3..))\n         } else {\n             stem\n         }\n@@ -1183,9 +1183,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = name[3..name.len() - 5]; // chop off lib/.rlib\n+            let name = name.index(&(3..(name.len() - 5))); // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 format!(\"altering {}.rlib\", name)[],\n+                 format!(\"altering {}.rlib\", name).index(&FullRange),\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1194,7 +1194,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e)[]);\n+                                         e).index(&FullRange));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1206,7 +1206,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     Err(e) => {\n                         sess.err(format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e)[]);\n+                                         e).index(&FullRange));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1220,9 +1220,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(format!(\"{}.o\", name)[]);\n+                archive.remove_file(format!(\"{}.o\", name).index(&FullRange));\n                 let files = archive.files();\n-                if files.iter().any(|s| s[].ends_with(\".o\")) {\n+                if files.iter().any(|s| s.index(&FullRange).ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });\n@@ -1244,7 +1244,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(v[]);\n+        cmd.arg(v.index(&FullRange));\n     }\n }\n \n@@ -1286,7 +1286,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(lib[]);\n+                    cmd.arg(lib.index(&FullRange));\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "450b4176b7abebe6315b4781fb08d16ff88f814e", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -54,29 +54,29 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             Some(p) => p,\n             None => {\n                 sess.fatal(format!(\"could not find rlib for: `{}`\",\n-                                   name)[]);\n+                                   name).index(&FullRange));\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = file[3..file.len() - 5]; // chop off lib/.rlib\n+        let file = file.index(&(3..(file.len() - 5))); // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n-                                  format!(\"check for {}.{}.bytecode.deflate\", name, i)[],\n+                                  format!(\"check for {}.{}.bytecode.deflate\", name, i).index(&FullRange),\n                                   (),\n                                   |_| {\n                                       archive.read(format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i)[])\n+                                                           file, i).index(&FullRange))\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n                         sess.fatal(format!(\"missing compressed bytecode in {}\",\n-                                           path.display())[]);\n+                                           path.display()).index(&FullRange));\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -91,20 +91,20 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded[\n+                        let compressed_data = bc_encoded.index(&(\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint];\n+                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)));\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n                             None => {\n                                 sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                                   name)[])\n+                                                   name).index(&FullRange))\n                             }\n                         }\n                     } else {\n                         sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                           version)[])\n+                                           version).index(&FullRange))\n                     }\n                 })\n             } else {\n@@ -115,7 +115,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                               name)[])\n+                                               name).index(&FullRange))\n                         }\n                     }\n                 })\n@@ -124,15 +124,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 format!(\"ll link {}.{}\", name, i)[],\n+                 format!(\"ll link {}.{}\", name, i).index(&FullRange),\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            name[]));\n+                                            name.index(&FullRange)));\n                 }\n             });\n         }\n@@ -186,7 +186,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc[..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           bc.index(&(0..magic_id_byte_count)) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -198,8 +198,8 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes[position_in_bytes..\n-                          position_in_bytes + mem::size_of::<T>()];\n+    let byte_data = bytes.index(&(position_in_bytes..\n+                                  (position_in_bytes + mem::size_of::<T>())));\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "f27f7dc571937e03392799565aa2a71ef036efbf", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -47,14 +47,14 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(msg[]);\n+            handler.fatal(msg.index(&FullRange));\n         } else {\n             let err = ffi::c_str_to_bytes(&cstr);\n             let err = String::from_utf8_lossy(err.as_slice()).to_string();\n             libc::free(cstr as *mut _);\n             handler.fatal(format!(\"{}: {}\",\n-                                  msg[],\n-                                  err[])[]);\n+                                  msg.index(&FullRange),\n+                                  err.index(&FullRange)).index(&FullRange));\n         }\n     }\n }\n@@ -104,13 +104,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           diag.msg[],\n-                                           code[],\n+                                           diag.msg.index(&FullRange),\n+                                           code.index(&FullRange),\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 diag.msg[],\n+                                 diag.msg.index(&FullRange),\n                                  diag.lvl);\n                 },\n             }\n@@ -165,8 +165,8 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => s[],\n-        None => sess.target.target.options.relocation_model[]\n+        Some(ref s) => s.index(&FullRange),\n+        None => sess.target.target.options.relocation_model.index(&FullRange)\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n@@ -177,7 +177,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(format!(\"{} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model)[]);\n+                                 .relocation_model).index(&FullRange));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -198,8 +198,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => s[],\n-        None => sess.target.target.options.code_model[]\n+        Some(ref s) => s.index(&FullRange),\n+        None => sess.target.target.options.code_model.index(&FullRange)\n     };\n \n     let code_model = match code_model_arg {\n@@ -212,13 +212,13 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(format!(\"{} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model)[]);\n+                                 .code_model).index(&FullRange));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = sess.target.target.llvm_target[];\n+    let triple = sess.target.target.llvm_target.index(&FullRange);\n \n     let tm = unsafe {\n         let triple = CString::from_slice(triple.as_bytes());\n@@ -350,13 +350,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, msg[]),\n-                None     => sess.err(msg[]),\n+                Some(ei) => sess.span_err(ei.call_site, msg.index(&FullRange)),\n+                None     => sess.err(msg.index(&FullRange)),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(msg[]);\n+            cgcx.handler.err(msg.index(&FullRange));\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n@@ -381,8 +381,8 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n                 cgcx.handler.note(format!(\"optimization {} for {} at {}: {}\",\n                                           opt.kind.describe(),\n                                           pass_name,\n-                                          if loc.is_empty() { \"[unknown]\" } else { loc[] },\n-                                          llvm::twine_to_string(opt.message))[]);\n+                                          if loc.is_empty() { \"[unknown]\" } else { loc.index(&FullRange) },\n+                                          llvm::twine_to_string(opt.message)).index(&FullRange));\n             }\n         }\n \n@@ -518,14 +518,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(format!(\"{}.s\", name_extra)[]);\n+            let path = output_names.with_extension(format!(\"{}.s\", name_extra).index(&FullRange));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(format!(\"{}.o\", name_extra)[]);\n+            let path = output_names.with_extension(format!(\"{}.o\", name_extra).index(&FullRange));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -639,7 +639,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, trans.reachable[], work_items);\n+        run_work_singlethreaded(sess, trans.reachable.index(&FullRange), work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -667,7 +667,7 @@ pub fn run_passes(sess: &Session,\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n                 sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext)[]);\n+                                  ext).index(&FullRange));\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -700,20 +700,20 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(pname[]);\n+        let mut cmd = Command::new(pname.index(&FullRange));\n \n-        cmd.args(sess.target.target.options.pre_link_args[]);\n+        cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n-            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index)[]));\n+            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).index(&FullRange)));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(sess.target.target.options.post_link_args[]);\n+        cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n \n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n@@ -726,14 +726,14 @@ pub fn run_passes(sess: &Session,\n             Ok(status) => {\n                 if !status.success() {\n                     sess.err(format!(\"linking of {} with `{}` failed\",\n-                                     output_path.display(), cmd)[]);\n+                                     output_path.display(), cmd).index(&FullRange));\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n                 sess.err(format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e)[]);\n+                                 e).index(&FullRange));\n                 sess.abort_if_errors();\n             },\n         }\n@@ -818,12 +818,12 @@ pub fn run_passes(sess: &Session,\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(ext[]));\n+                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(ext[]));\n+                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n             }\n         }\n \n@@ -949,7 +949,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname[]);\n+    let mut cmd = Command::new(pname.index(&FullRange));\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -960,18 +960,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             if !prog.status.success() {\n                 sess.err(format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(format!(\"{}\", &cmd)[]);\n+                                 prog.status).index(&FullRange));\n+                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n                 let mut note = prog.error.clone();\n-                note.push_all(prog.output[]);\n-                sess.note(str::from_utf8(note[]).unwrap());\n+                note.push_all(prog.output.index(&FullRange));\n+                sess.note(str::from_utf8(note.index(&FullRange)).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n             sess.err(format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e).index(&FullRange));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1004,7 +1004,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         for arg in sess.opts.cg.llvm_args.iter() {\n-            add((*arg)[]);\n+            add((*arg).index(&FullRange));\n         }\n     }\n "}, {"sha": "b27421ea4266190ceba1bf3e4c0b4f282e360193", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, cmd.name[], n);\n+            self.fmt.external_crate_str(krate.span, cmd.name.index(&FullRange), n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -143,7 +143,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname[],\n+                                     qualname.index(&FullRange),\n                                      self.cur_scope);\n         }\n     }\n@@ -161,7 +161,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname[],\n+                                     qualname.index(&FullRange),\n                                      self.cur_scope);\n         }\n     }\n@@ -180,17 +180,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  qualname[]);\n+                                  qualname.index(&FullRange));\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths[..len-2];\n+        let sub_paths = sub_paths.index(&(0..(len-2)));\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname[],\n+                                     qualname.index(&FullRange),\n                                      self.cur_scope);\n         }\n     }\n@@ -199,7 +199,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id)[]);\n+                                  ref_id).index(&FullRange));\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -212,7 +212,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id)[]);\n+                                             ref_id).index(&FullRange));\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -241,7 +241,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n                 self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {}\",\n-                                                 def)[]);\n+                                                 def).index(&FullRange));\n             },\n         }\n     }\n@@ -262,8 +262,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_string(p)[],\n-                                    typ[]);\n+                                    path_to_string(p).index(&FullRange),\n+                                    typ.index(&FullRange));\n             }\n             self.collected_paths.clear();\n         }\n@@ -285,14 +285,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&**ty)[]);\n+                            result.push_str(ty_to_string(&**ty).index(&FullRange));\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n                                 Some(def_id) => {\n                                     result.push_str(\" as \");\n                                     result.push_str(\n-                                        ty::item_path_str(&self.analysis.ty_cx, def_id)[]);\n+                                        ty::item_path_str(&self.analysis.ty_cx, def_id).index(&FullRange));\n                                 },\n                                 None => {}\n                             }\n@@ -302,7 +302,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id)[]);\n+                                                       impl_id.node, method.id).index(&FullRange));\n                         },\n                     }\n                 },\n@@ -312,7 +312,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                impl_id.node,\n                                                method.id,\n                                                self.analysis.ty_cx.map.get(impl_id.node)\n-                                              )[]);\n+                                              ).index(&FullRange));\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -328,20 +328,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id)[]);\n+                                                       def_id.node, method.id).index(&FullRange));\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n                                        format!(\"Could not find container for method {}\",\n-                                               method.id)[]);\n+                                               method.id).index(&FullRange));\n                 },\n             },\n         };\n \n         qualname.push_str(get_ident(method.pe_ident()).get());\n-        let qualname = qualname[];\n+        let qualname = qualname.index(&FullRange);\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -430,13 +430,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         name.get()[],\n-                                                         qualname[],\n-                                                         typ[],\n+                                                         name.get().index(&FullRange),\n+                                                         qualname.index(&FullRange),\n+                                                         typ.index(&FullRange),\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)[]),\n+                                                       qualname).index(&FullRange)),\n                 }\n             },\n             _ => (),\n@@ -463,7 +463,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 name[],\n+                                 name.index(&FullRange),\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -480,10 +480,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        qualname[],\n+                        qualname.index(&FullRange),\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname[]);\n+        self.process_formals(&decl.inputs, qualname.index(&FullRange));\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n@@ -497,7 +497,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -519,9 +519,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname[],\n-                            value[],\n-                            ty_to_string(&*typ)[],\n+                            qualname.index(&FullRange),\n+                            value.index(&FullRange),\n+                            ty_to_string(&*typ).index(&FullRange),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -542,9 +542,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname[],\n+                            qualname.index(&FullRange),\n                             \"\",\n-                            ty_to_string(&*typ)[],\n+                            ty_to_string(&*typ).index(&FullRange),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -568,17 +568,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            qualname[],\n+                            qualname.index(&FullRange),\n                             self.cur_scope,\n-                            val[]);\n+                            val.index(&FullRange));\n \n         // fields\n         for field in def.fields.iter() {\n-            self.process_struct_field_def(field, qualname[], item.id);\n+            self.process_struct_field_def(field, qualname.index(&FullRange), item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname[], item.id);\n+        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -591,12 +591,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                enum_name[],\n+                                                enum_name.index(&FullRange),\n                                                 self.cur_scope,\n-                                                val[]),\n+                                                val.index(&FullRange)),\n             None => self.sess.span_bug(item.span,\n                                        format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)[]),\n+                                               enum_name).index(&FullRange)),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n@@ -612,9 +612,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               qualname[],\n-                                               enum_name[],\n-                                               val[],\n+                                               qualname.index(&FullRange),\n+                                               enum_name.index(&FullRange),\n+                                               val.index(&FullRange),\n                                                item.id);\n                     for arg in args.iter() {\n                         self.visit_ty(&*arg.ty);\n@@ -630,20 +630,20 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        qualname[],\n-                        enum_name[],\n-                        val[],\n+                        qualname.index(&FullRange),\n+                        enum_name.index(&FullRange),\n+                        val.index(&FullRange),\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n-                        self.process_struct_field_def(field, qualname[], variant.node.id);\n+                        self.process_struct_field_def(field, qualname.index(&FullRange), variant.node.id);\n                         self.visit_ty(&*field.node.ty);\n                     }\n                 }\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, enum_name[], item.id);\n+        self.process_generic_params(ty_params, item.span, enum_name.index(&FullRange), item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -703,9 +703,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           qualname[],\n+                           qualname.index(&FullRange),\n                            self.cur_scope,\n-                           val[]);\n+                           val.index(&FullRange));\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -737,7 +737,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname[], item.id);\n+        self.process_generic_params(generics, item.span, qualname.index(&FullRange), item.id);\n         for method in methods.iter() {\n             self.visit_trait_item(method)\n         }\n@@ -755,9 +755,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         qualname[],\n+                         qualname.index(&FullRange),\n                          self.cur_scope,\n-                         filename[]);\n+                         filename.index(&FullRange));\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -774,7 +774,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&id) {\n             self.sess.span_bug(span,\n-                               format!(\"def_map has no key for {} in visit_expr\", id)[]);\n+                               format!(\"def_map has no key for {} in visit_expr\", id).index(&FullRange));\n         }\n         let def = &(*def_map)[id];\n         let sub_span = self.span.span_for_last_ident(span);\n@@ -841,7 +841,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                           self.cur_scope),\n             _ => self.sess.span_bug(span,\n                                     format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span))[]),\n+                                            self.span.snippet(span)).index(&FullRange)),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -959,7 +959,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args[]);\n+        visit::walk_exprs(self, args.index(&FullRange));\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -976,7 +976,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(p.span,\n                                            format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span))[]);\n+                                                   self.span.snippet(p.span)).index(&FullRange));\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n@@ -1061,11 +1061,11 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     qualname[],\n-                                     value[]);\n+                                     qualname.index(&FullRange),\n+                                     value.index(&FullRange));\n \n                 self.visit_ty(&**ty);\n-                self.process_generic_params(ty_params, item.span, qualname[], item.id);\n+                self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n             },\n             ast::ItemMac(_) => (),\n             _ => visit::walk_item(self, item),\n@@ -1122,12 +1122,12 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(method_type.span,\n                                            format!(\"Could not find trait for method {}\",\n-                                                   method_type.id)[]);\n+                                                   method_type.id).index(&FullRange));\n                     },\n                 };\n \n                 qualname.push_str(get_ident(method_type.ident).get());\n-                let qualname = qualname[];\n+                let qualname = qualname.index(&FullRange);\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1262,7 +1262,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           id,\n                                           cnum,\n                                           name,\n-                                          s[],\n+                                          s.index(&FullRange),\n                                           self.cur_scope);\n             },\n         }\n@@ -1371,8 +1371,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(ex.id.to_string()[]);\n-                self.process_formals(&decl.inputs, id[]);\n+                id.push_str(ex.id.to_string().index(&FullRange));\n+                self.process_formals(&decl.inputs, id.index(&FullRange));\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n@@ -1418,7 +1418,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\", id)[]);\n+                                   format!(\"def_map has no key for {} in visit_arm\", id).index(&FullRange));\n             }\n             let def = &(*def_map)[id];\n             match *def {\n@@ -1433,8 +1433,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     self.fmt.variable_str(p.span,\n                                           Some(p.span),\n                                           id,\n-                                          path_to_string(p)[],\n-                                          value[],\n+                                          path_to_string(p).index(&FullRange),\n+                                          value.index(&FullRange),\n                                           \"\")\n                 }\n                 def::DefVariant(..) => {\n@@ -1488,9 +1488,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_string(p)[],\n-                                  value[],\n-                                  typ[]);\n+                                  path_to_string(p).index(&FullRange),\n+                                  value.index(&FullRange),\n+                                  typ.index(&FullRange));\n         }\n         self.collected_paths.clear();\n \n@@ -1509,7 +1509,7 @@ pub fn process_crate(sess: &Session,\n     }\n \n     assert!(analysis.glob_map.is_some());\n-    let cratename = match attr::find_crate_name(krate.attrs[]) {\n+    let cratename = match attr::find_crate_name(krate.attrs.index(&FullRange)) {\n         Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1530,7 +1530,7 @@ pub fn process_crate(sess: &Session,\n \n     match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n         Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e)[]),\n+                           root_path.display(), e).index(&FullRange)),\n         _ => (),\n     }\n \n@@ -1547,7 +1547,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(format!(\"Could not open {}: {}\", disp, e)[]);\n+            sess.fatal(format!(\"Could not open {}: {}\", disp, e).index(&FullRange));\n         }\n     };\n     root_path.pop();\n@@ -1573,7 +1573,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(cratename[], krate);\n+    visitor.dump_crate_info(cratename.index(&FullRange), krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "5352fcc2fedd971cb4da45c314334bfe24909455", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -41,7 +41,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(result[]);\n+        self.record(result.index(&FullRange));\n     }\n }\n \n@@ -160,15 +160,15 @@ impl<'a> FmtStrs<'a> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len())[]);\n+                kind, fields.len(), values.len()).index(&FullRange));\n         }\n \n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s[..1020]\n+                s.index(&(0..1020))\n             } else {\n-                s[]\n+                s.index(&FullRange)\n             }\n         });\n \n@@ -184,7 +184,7 @@ impl<'a> FmtStrs<'a> {\n             }\n         )));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(ss[]);\n+            s.push_str(ss.index(&FullRange));\n             s\n         }))\n     }\n@@ -198,7 +198,7 @@ impl<'a> FmtStrs<'a> {\n         if needs_span {\n             self.span.sess.span_bug(span, format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label)[]);\n+                label).index(&FullRange));\n         }\n         assert!(!dump_spans);\n \n@@ -212,9 +212,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(values_str[]);\n+        result.push_str(values_str.index(&FullRange));\n         result.push_str(\"\\n\");\n-        self.recorder.record(result[]);\n+        self.recorder.record(result.index(&FullRange));\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -237,15 +237,15 @@ impl<'a> FmtStrs<'a> {\n         if !needs_span {\n             self.span.sess.span_bug(span,\n                                     format!(\"Called record_with_span for '{}' \\\n-                                             which does not require a span\", label)[]);\n+                                             which does not require a span\", label).index(&FullRange));\n         }\n \n         let values_str = match self.make_values_str(label, fields, values, span) {\n             Some(vs) => vs,\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(result[]);\n+        self.recorder.record(result.index(&FullRange));\n     }\n \n     pub fn check_and_record(&mut self,\n@@ -275,7 +275,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(id.to_string()[]);\n+        qualname.push_str(id.to_string().index(&FullRange));\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "8d249b8bfe9036c55f21ff0bb5b110e994118eab", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -218,7 +218,7 @@ impl<'a> SpanUtils<'a> {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n                 format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line)[]);\n+                        self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -244,7 +244,7 @@ impl<'a> SpanUtils<'a> {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span, format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line)[]);\n+                         self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n                 }\n                 return result\n             }"}, {"sha": "f55076e7484e5560c54622dee7e6f78035f9c3d7", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -427,7 +427,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(br.pats[]).map(|pats| {\n+        e(br.pats.index(&FullRange)).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -471,8 +471,8 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            let mut r = pats[..col].to_vec();\n-            r.push_all(pats[col + 1..]);\n+            let mut r = pats.index(&(0..col)).to_vec();\n+            r.push_all(pats.index(&((col + 1)..)));\n             Some(r)\n         } else {\n             None\n@@ -548,7 +548,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats[], &ctor, col, variant_size)\n+        check_match::specialize(&mcx, pats.index(&FullRange), &ctor, col, variant_size)\n     )\n }\n \n@@ -790,7 +790,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         let did = langcall(cx,\n                            None,\n                            format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t))[],\n+                                   cx.ty_to_string(rhs_t)).index(&FullRange),\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n@@ -945,7 +945,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          expanded[],\n+                                          expanded.index(&FullRange),\n                                           vals,\n                                           chk,\n                                           col,\n@@ -967,7 +967,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx = compile_guard(bcx,\n                                         &**guard_expr,\n                                         m[0].data,\n-                                        m[1..m.len()],\n+                                        m.index(&(1..m.len())),\n                                         vals,\n                                         chk,\n                                         has_genuine_default);\n@@ -990,8 +990,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let mut vals_left = vals[0u..col].to_vec();\n-    vals_left.push_all(vals[col + 1u..]);\n+    let mut vals_left = vals.index(&(0u..col)).to_vec();\n+    vals_left.push_all(vals.index(&((col + 1u)..)));\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1037,8 +1037,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                         field_vals.len())\n             );\n             let mut vals = field_vals;\n-            vals.push_all(vals_left[]);\n-            compile_submatch(bcx, pats[], vals[], chk, has_genuine_default);\n+            vals.push_all(vals_left.index(&FullRange));\n+            compile_submatch(bcx, pats.index(&FullRange), vals.index(&FullRange), chk, has_genuine_default);\n             return;\n         }\n         _ => ()\n@@ -1191,10 +1191,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(vals_left[]);\n+        opt_vals.push_all(vals_left.index(&FullRange));\n         compile_submatch(opt_cx,\n-                         opt_ms[],\n-                         opt_vals[],\n+                         opt_ms.index(&FullRange),\n+                         opt_vals.index(&FullRange),\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1213,8 +1213,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 defaults[],\n-                                 vals_left[],\n+                                 defaults.index(&FullRange),\n+                                 vals_left.index(&FullRange),\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1333,21 +1333,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         bcx.ident(ident)[]));\n+                                         bcx.ident(ident).index(&FullRange)));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 bcx.ident(ident)[]);\n+                                 bcx.ident(ident).index(&FullRange));\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 bcx.ident(ident)[]);\n+                                 bcx.ident(ident).index(&FullRange));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1415,7 +1415,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches[], &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, matches.index(&FullRange), &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1429,7 +1429,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs[]);\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.index(&FullRange));\n     return bcx;\n }\n \n@@ -1582,7 +1582,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident)[]);\n+    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).index(&FullRange));\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1620,7 +1620,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx()))[]);\n+                                 pat.repr(bcx.tcx())).index(&FullRange));\n     }\n \n     let _indenter = indenter();"}, {"sha": "60fc29c7c831dce33ad796aff0364b56312751c1", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -154,7 +154,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, elems[], false, t), false)\n+            Univariant(mk_struct(cx, elems.index(&FullRange), false, t), false)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n@@ -165,17 +165,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(cx.tcx().types.bool); }\n \n-            Univariant(mk_struct(cx, ftys[], packed, t), dtor)\n+            Univariant(mk_struct(cx, ftys.index(&FullRange), packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n             let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n             let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, upvar_types[], false, t), false)\n+            Univariant(mk_struct(cx, upvar_types.index(&FullRange), false, t), false)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).index(&FullRange).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -185,7 +185,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys[], false, t),\n+                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n                                   dtor);\n             }\n \n@@ -208,7 +208,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id))[]);\n+                                                        def_id)).index(&FullRange));\n             }\n \n             if cases.len() == 1 {\n@@ -217,7 +217,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                return Univariant(mk_struct(cx, ftys[], false, t),\n+                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n                                   dtor);\n             }\n \n@@ -226,7 +226,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases[discr].tys[],\n+                        let st = mk_struct(cx, cases[discr].tys.index(&FullRange),\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n@@ -316,17 +316,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.push_all(c.tys[]);\n+                ftys.push_all(c.tys.index(&FullRange));\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, ftys[], false, t)\n+                mk_struct(cx, ftys.index(&FullRange), false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, fields[], t);\n+            ensure_enum_fits_in_address_space(cx, ity, fields.index(&FullRange), t);\n \n             General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t))[])\n+                           ty_to_string(cx.tcx(), t)).index(&FullRange))\n     }\n }\n \n@@ -412,7 +412,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, self.tys[], false, scapegoat).size == 0\n+        mk_struct(cx, self.tys.index(&FullRange), false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n@@ -451,9 +451,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, lltys[], packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, lltys.index(&FullRange), packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, lltys[], packed);\n+    let llty_rec = Type::struct_(cx, lltys.index(&FullRange), packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -502,7 +502,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().target.target.arch[] {\n+            attempts = match cx.sess().target.target.arch.index(&FullRange) {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -628,7 +628,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false, false)[],\n+            llty.set_struct_body(struct_llfields(cx, st, false, false).index(&FullRange),\n                                  st.packed)\n     }\n }\n@@ -644,7 +644,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst)[],\n+                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).index(&FullRange),\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -663,7 +663,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(sts[]);\n+            let (size, align) = union_size_and_align(sts.index(&FullRange));\n             let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n@@ -684,10 +684,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           Type::array(&discr_ty, align_s / discr_size - 1),\n                           fill_ty];\n             match name {\n-                None => Type::struct_(cx, fields[], false),\n+                None => Type::struct_(cx, fields.index(&FullRange), false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(fields[], false);\n+                    llty.set_struct_body(fields.index(&FullRange), false);\n                     llty\n                 }\n             }\n@@ -765,7 +765,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, discrfield[]);\n+    let llptrptr = GEPi(bcx, scrutinee, discrfield.index(&FullRange));\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n@@ -853,7 +853,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, discrfield[]);\n+                let llptrptr = GEPi(bcx, val, discrfield.index(&FullRange));\n                 let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n@@ -935,7 +935,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, fields[], st.packed);\n+        let real_ty = Type::struct_(ccx, fields.index(&FullRange), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -967,14 +967,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    format!(\"enum-variant-iter-{}\", discr.to_string())[]\n+                    format!(\"enum-variant-iter-{}\", discr.to_string()).index(&FullRange)\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, fields[], case.packed);\n+                let real_ty = Type::struct_(ccx, fields.index(&FullRange), case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -1051,14 +1051,14 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, f[]);\n+            let mut contents = build_const_struct(ccx, case, f.index(&FullRange));\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, contents[], false)\n+            C_struct(ccx, contents.index(&FullRange), false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, contents[], st.packed)\n+            C_struct(ccx, contents.index(&FullRange), st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -1072,7 +1072,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             if discr == nndiscr {\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals)[],\n+                                                 vals).index(&FullRange),\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n@@ -1082,7 +1082,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals[])[],\n+                                                 vals.index(&FullRange)).index(&FullRange),\n                          false)\n             }\n         }"}, {"sha": "890f046be1b2efd226c8e7c691711aae89c0e414", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -71,7 +71,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(ext_inputs[]);\n+    inputs.push_all(ext_inputs.index(&FullRange));\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -91,18 +91,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(more_clobbers[]);\n+        clobbers.push_str(more_clobbers.index(&FullRange));\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(clobbers[]);\n+        constraints.push_str(clobbers.index(&FullRange));\n     } else {\n-        constraints.push_str(clobbers[]);\n+        constraints.push_str(clobbers.index(&FullRange));\n     }\n \n-    debug!(\"Asm Constraints: {}\", constraints[]);\n+    debug!(\"Asm Constraints: {}\", constraints.index(&FullRange));\n \n     let num_outputs = outputs.len();\n \n@@ -112,7 +112,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), output_types[], false)\n+        Type::struct_(bcx.ccx(), output_types.index(&FullRange), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "e69bfb57670f3c44d4886b4dd5e6b241e08aecb5", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -249,7 +249,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n-        set_llvm_fn_attrs(ccx, attrs[], f)\n+        set_llvm_fn_attrs(ccx, attrs.index(&FullRange), f)\n     });\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -303,7 +303,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected closure or fn\")\n     };\n \n-    let llfty = type_of_rust_fn(ccx, env, inputs[], output, abi);\n+    let llfty = type_of_rust_fn(ccx, env, inputs.index(&FullRange), output, abi);\n     debug!(\"decl_rust_fn(input count={},type={})\",\n            inputs.len(),\n            ccx.tn().type_to_string(llfty));\n@@ -369,7 +369,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Err(s) => {\n             bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s)[]);\n+                                     s).index(&FullRange));\n         }\n     }\n }\n@@ -488,7 +488,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym)[]);\n+        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).index(&FullRange));\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -525,7 +525,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      name[],\n+                      name.index(&FullRange),\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -774,8 +774,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_string()[])\n-                                     []);\n+                                      variant.disr_val.to_string().index(&FullRange))\n+                                     .index(&FullRange));\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -800,7 +800,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t))[])\n+                                   ty_to_string(cx.tcx(), t)).index(&FullRange))\n       }\n     }\n     return cx;\n@@ -882,7 +882,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t))[]);\n+                                  ty_to_string(cx.tcx(), rhs_t)).index(&FullRange));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -936,14 +936,14 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, name[], did)\n+                    get_extern_rust_fn(ccx, t, name.index(&FullRange), did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name[])\n+                                                      name.index(&FullRange))\n                 }\n             }\n         }\n@@ -990,7 +990,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs[],\n+                              llargs.index(&FullRange),\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes));\n@@ -1006,7 +1006,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs[], Some(attributes));\n+        let llresult = Call(bcx, llfn, llargs.index(&FullRange), Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1123,7 +1123,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().target.target.target_word_size[] {\n+    let key = match ccx.sess().target.target.target_word_size.index(&FullRange) {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1170,7 +1170,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().target.target.target_word_size[] {\n+    let intrinsic_key = match ccx.sess().target.target.target_word_size.index(&FullRange) {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1658,7 +1658,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => types[],\n+        ty::ty_tup(ref types) => types.index(&FullRange),\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1846,29 +1846,29 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  monomorphized_arg_types[])\n+                                  monomorphized_arg_types.index(&FullRange))\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            monomorphized_arg_types[])\n+            monomorphized_arg_types.index(&FullRange))\n     };\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n-                                 decl.inputs[],\n+                                 decl.inputs.index(&FullRange),\n                                  arg_datums)\n         }\n         closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                decl.inputs[],\n+                decl.inputs.index(&FullRange),\n                 arg_datums,\n-                monomorphized_arg_types[])\n+                monomorphized_arg_types.index(&FullRange))\n         }\n     };\n \n@@ -1985,7 +1985,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx))[])\n+                     ctor_ty.repr(tcx)).index(&FullRange))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2008,7 +2008,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      fields[],\n+                                      fields.index(&FullRange),\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       call_info);\n@@ -2057,7 +2057,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty))[])\n+                    ty_to_string(ccx.tcx(), ctor_ty)).index(&FullRange))\n     };\n \n     let arena = TypedArena::new();\n@@ -2069,7 +2069,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys[]);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.index(&FullRange));\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2155,7 +2155,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                             *lvlsrc.unwrap(), Some(sp),\n                             format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest)[]);\n+                                    largest).index(&FullRange));\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2239,7 +2239,7 @@ pub fn update_linkage(ccx: &CrateContext,\n     if let Some(id) = id {\n         let item = ccx.tcx().map.get(id);\n         if let ast_map::NodeItem(i) = item {\n-            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs[], \"linkage\") {\n+            if let Some(name) = attr::first_attr_value_str_by_name(i.attrs.index(&FullRange), \"linkage\") {\n                 if let Some(linkage) = llvm_linkage_by_name(name.get()) {\n                     llvm::SetLinkage(llval, linkage);\n                 } else {\n@@ -2273,7 +2273,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(item.attrs[]);\n+            let trans_everywhere = attr::requests_inline(item.attrs.index(&FullRange));\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2284,7 +2284,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            item.attrs[],\n+                                                            item.attrs.index(&FullRange),\n                                                             llfn,\n                                                             &Substs::trans_empty(),\n                                                             item.id,\n@@ -2296,7 +2296,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              &Substs::trans_empty(),\n                              item.id,\n-                             item.attrs[]);\n+                             item.attrs.index(&FullRange));\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2313,7 +2313,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         impl_items[],\n+                         impl_items.index(&FullRange),\n                          generics,\n                          item.id);\n       }\n@@ -2343,7 +2343,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs[], \"static_assert\") {\n+          if attr::contains_name(item.attrs.index(&FullRange), \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2420,7 +2420,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, sym[]);\n+    let llfn = decl_rust_fn(ccx, node_type, sym.index(&FullRange));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2462,7 +2462,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n             match fn_sig.0.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(t_in[]);\n+                    inputs.push_all(t_in.index(&FullRange));\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2597,7 +2597,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n                           llfty: Type) -> ValueRef {\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n-    let llfn = decl_fn(ccx, sym[], cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    let llfn = decl_fn(ccx, sym.index(&FullRange), cc, llfty, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2650,7 +2650,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s[]); }\n+                    Err(s) => { ccx.sess().fatal(s.index(&FullRange)); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2742,7 +2742,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = |&:| exported_name(ccx, id, ty, i.attrs[]);\n+            let sym = |&:| exported_name(ccx, id, ty, i.attrs.index(&FullRange));\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2765,16 +2765,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(sym[]) {\n+                        if contains_null(sym.index(&FullRange)) {\n                             ccx.sess().fatal(\n                                 format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym)[]);\n+                                         value: `{}`\", sym).index(&FullRange));\n                         }\n                         let buf = CString::from_slice(sym.as_bytes());\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n-                        if attr::contains_name(i.attrs[],\n+                        if attr::contains_name(i.attrs.index(&FullRange),\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2799,19 +2799,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, i.attrs[], llfn);\n+                    set_llvm_fn_attrs(ccx, i.attrs.index(&FullRange), llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(i.attrs[],\n+            match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange),\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(sect.get()) {\n                         ccx.sess().fatal(format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get())[]);\n+                                                 sect.get()).index(&FullRange));\n                     }\n                     unsafe {\n                         let buf = CString::from_slice(sect.get().as_bytes());\n@@ -2854,7 +2854,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get()[])\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().index(&FullRange))\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2877,7 +2877,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    enm.attrs[]);\n+                                    enm.attrs.index(&FullRange));\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2905,7 +2905,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                     id,\n                                     ty,\n                                     struct_item.attrs\n-                                               []);\n+                                               .index(&FullRange));\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n@@ -2914,7 +2914,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         ref variant => {\n             ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {}\",\n-                                   variant)[])\n+                                   variant).index(&FullRange))\n         }\n     };\n \n@@ -2935,10 +2935,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs[]);\n+    let sym = exported_name(ccx, id, mty, m.attrs.index(&FullRange));\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, m.attrs[], llfn);\n+    set_llvm_fn_attrs(ccx, m.attrs.index(&FullRange), llfn);\n     llfn\n }\n \n@@ -2977,7 +2977,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed[]);\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.index(&FullRange));\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n@@ -3106,7 +3106,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(link_meta.crate_name[],\n+    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.index(&FullRange),\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3208,7 +3208,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(krate.attrs[], \"no_builtins\");\n+    let no_builtins = attr::contains_name(krate.attrs.index(&FullRange), \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "d0eaf799af1bd04a41103f123cbce80eb5311acb", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -552,11 +552,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec[..ixs.len()])\n+            self.inbounds_gep(base, small_vec.index(&(0..ixs.len())))\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v[])\n+            self.inbounds_gep(base, v.index(&FullRange))\n         }\n     }\n \n@@ -764,8 +764,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s[]);\n-            self.add_comment(s[]);\n+            debug!(\"{}\", s.index(&FullRange));\n+            self.add_comment(s.index(&FullRange));\n         }\n     }\n \n@@ -802,7 +802,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(argtys[], &output);\n+        let fty = Type::func(argtys.index(&FullRange), &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "a901142467b8debfa535b1133190ca84d962fd34", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -108,7 +108,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().target.target.arch[] {\n+    match ccx.sess().target.target.arch.index(&FullRange) {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -119,6 +119,6 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-                              []),\n+                              .index(&FullRange)),\n     }\n }"}, {"sha": "f40072d1cba3eb33597ecba6aa76da7ebdefe023", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -318,7 +318,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(cls[i + 1u..]);\n+                let vec_len = llvec_len(cls.index(&((i + 1u)..)));\n                 let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "498182c17e223a5ee56378ba63bd95978c58bfb7", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -114,7 +114,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     expr.span,\n                     format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty))[]);\n+                            bcx.ty_to_string(datum.ty)).index(&FullRange));\n             }\n         }\n     }\n@@ -207,7 +207,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"cannot translate def {} \\\n-                             to a callable thing!\", def)[]);\n+                             to a callable thing!\", def).index(&FullRange));\n             }\n         }\n     }\n@@ -293,7 +293,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx))[]);\n+                                           bare_fn_ty.repr(tcx)).index(&FullRange));\n             }\n         };\n     let tuple_input_ty = ty::mk_tup(tcx, input_tys.to_vec());\n@@ -317,7 +317,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              function_name[]);\n+                              function_name.index(&FullRange));\n \n     //\n     let block_arena = TypedArena::new();\n@@ -352,7 +352,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(llargs[]),\n+                           ArgVals(llargs.index(&FullRange)),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, output_ty);\n@@ -775,7 +775,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n-                                      llargs[],\n+                                      llargs.index(&FullRange),\n                                       callee_ty,\n                                       call_info);\n         bcx = b;\n@@ -814,7 +814,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n-                                         llargs[], arg_tys);\n+                                         llargs.index(&FullRange), arg_tys);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);"}, {"sha": "ac64e10ecc80969cb677fa7853580b318869e8e2", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -406,7 +406,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         self.ccx.sess().bug(\n             format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope)).index(&FullRange));\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -588,7 +588,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id)[]);\n+                                not in scope\", id).index(&FullRange));\n                     }\n                 }\n             }\n@@ -657,7 +657,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            name[],\n+                                            name.index(&FullRange),\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -704,7 +704,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name[], None);\n+                    pad_bcx = self.new_block(true, name.index(&FullRange), None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -1025,7 +1025,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n         }\n         None => {\n             tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n-                                 id)[])\n+                                 id).index(&FullRange))\n         }\n     }\n }"}, {"sha": "233cbe8f28003481455e51fcbe39d31955cdd315", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -154,7 +154,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values[]);\n+    let cdata_ty = mk_closure_tys(tcx, bound_values.index(&FullRange));\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -183,7 +183,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         if ccx.sess().asm_comments() {\n             add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx))[]);\n+                                     bv.to_string(ccx)).index(&FullRange));\n         }\n \n         let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n@@ -420,7 +420,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, fty, s[]);\n+    let llfn = decl_internal_rust_fn(ccx, fty, s.index(&FullRange));\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -444,7 +444,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::ty_fn_ret(fty),\n                   ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(freevars[],\n+                  ClosureEnv::new(freevars.index(&FullRange),\n                                   BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n@@ -489,7 +489,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, symbol[]);\n+    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.index(&FullRange));\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -542,7 +542,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   function_type.sig.0.output,\n                   function_type.abi,\n-                  ClosureEnv::new(freevars[],\n+                  ClosureEnv::new(freevars.index(&FullRange),\n                                   UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate\n@@ -579,3 +579,4 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n \n     bcx\n }\n+"}, {"sha": "8596583d4a592d10056a0ffe0a5ce7a64cf03bad", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -218,7 +218,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n     let num = token::gensym(name).uint();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(format!(\"{}:{}\", name, num)[]))\n+    PathName(token::gensym(format!(\"{}:{}\", name, num).index(&FullRange)))\n }\n \n #[derive(Copy)]\n@@ -546,7 +546,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(format!(\n-                    \"no def associated with node id {}\", nid)[]);\n+                    \"no def associated with node id {}\", nid).index(&FullRange));\n             }\n         }\n     }\n@@ -976,7 +976,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 span,\n                 format!(\"Encountered error `{}` selecting `{}` during trans\",\n                         e.repr(tcx),\n-                        trait_ref.repr(tcx))[])\n+                        trait_ref.repr(tcx)).index(&FullRange))\n         }\n     };\n \n@@ -1069,7 +1069,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                 infcx.tcx.sess.span_bug(\n                     span,\n                     format!(\"Encountered errors `{}` fulfilling during trans\",\n-                            errors.repr(infcx.tcx))[]);\n+                            errors.repr(infcx.tcx)).index(&FullRange));\n             }\n         }\n     }\n@@ -1109,7 +1109,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n         tcx.sess.bug(format!(\"type parameters for node {} include inference types: {}\",\n-                             node, substs.repr(tcx))[]);\n+                             node, substs.repr(tcx)).index(&FullRange));\n     }\n \n     monomorphize::apply_param_substs(tcx,\n@@ -1127,8 +1127,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, msg[]),\n-                None => bcx.tcx().sess.fatal(msg[]),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, msg.index(&FullRange)),\n+                None => bcx.tcx().sess.fatal(msg.index(&FullRange)),\n             }\n         }\n     }"}, {"sha": "f9b14e1de4fdb2a9ab9dcbfb77651c174297928a", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -54,7 +54,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty))[])\n+                                ty_to_string(cx.tcx(), lit_int_ty)).index(&FullRange))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -74,7 +74,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, data[]),\n+        ast::LitBinary(ref data) => C_binary_slice(cx, data.index(&FullRange)),\n     }\n }\n \n@@ -93,9 +93,9 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, vs[], false)\n+        C_struct(cx, vs.index(&FullRange), false)\n     } else {\n-        C_array(llunitty, vs[])\n+        C_array(llunitty, vs.index(&FullRange))\n     };\n     (v, llunitty)\n }\n@@ -149,13 +149,13 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n                 }\n                 _ => {\n                     cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t))[])\n+                                          ty_to_string(cx.tcx(), t)).index(&FullRange))\n                 }\n             }\n         }\n         None => {\n             cx.sess().bug(format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t))[])\n+                                  ty_to_string(cx.tcx(), t)).index(&FullRange))\n         }\n     }\n }\n@@ -252,15 +252,15 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                         }\n                                         _ => cx.sess().span_bug(e.span,\n                                             format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty))[])\n+                                                    ty_to_string(cx.tcx(), ty)).index(&FullRange))\n                                     }\n                                 }\n                                 _ => {\n                                     cx.sess()\n                                       .span_bug(e.span,\n                                                 format!(\"unimplemented const \\\n                                                          autoref {}\",\n-                                                        autoref)[])\n+                                                        autoref).index(&FullRange))\n                                 }\n                             }\n                         }\n@@ -281,7 +281,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n         }\n         cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n-                         csize, tsize)[]);\n+                         csize, tsize).index(&FullRange));\n     }\n     (llconst, ety_adjusted)\n }\n@@ -431,7 +431,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt))[])\n+                                                      ty_to_string(cx.tcx(), bt)).index(&FullRange))\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n@@ -440,12 +440,12 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                       _ => cx.sess().span_bug(base.span,\n                                               format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt))[])\n+                                                      ty_to_string(cx.tcx(), bt)).index(&FullRange))\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt))[])\n+                                                  ty_to_string(cx.tcx(), bt)).index(&FullRange))\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -546,8 +546,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(es[]);\n-              adt::trans_const(cx, &*repr, 0, vals[])\n+              let vals = map_list(es.index(&FullRange));\n+              adt::trans_const(cx, &*repr, 0, vals.index(&FullRange))\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -578,7 +578,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, cs[])\n+                  adt::trans_const(cx, &*repr, discr, cs.index(&FullRange))\n               })\n           }\n           ast::ExprVec(ref es) => {\n@@ -595,9 +595,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             };\n             let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs[], false)\n+                C_struct(cx, vs.index(&FullRange), false)\n             } else {\n-                C_array(llunitty, vs[])\n+                C_array(llunitty, vs.index(&FullRange))\n             }\n           }\n           ast::ExprPath(_) => {\n@@ -645,20 +645,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(args[]);\n-                      adt::trans_const(cx, &*repr, 0, arg_vals[])\n+                      let arg_vals = map_list(args.index(&FullRange));\n+                      adt::trans_const(cx, &*repr, 0, arg_vals.index(&FullRange))\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(args[]);\n+                      let arg_vals = map_list(args.index(&FullRange));\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       arg_vals[])\n+                                       arg_vals.index(&FullRange))\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "585b338b0262bc5f54aac934feaa9058fcf6a025", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id[]);\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.index(&FullRange));\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n \n@@ -374,7 +374,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          []);\n+                                          .index(&FullRange));\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -721,7 +721,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n     pub fn obj_size_bound(&self) -> u64 {\n-        match self.sess().target.target.target_word_size[] {\n+        match self.sess().target.target.target_word_size.index(&FullRange) {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n             _ => unreachable!() // error handled by config::build_target_config\n@@ -731,7 +731,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx()))[])\n+                    obj.repr(self.tcx())).index(&FullRange))\n     }\n }\n "}, {"sha": "67e8b4f686a3db5a6234c2bee5c027d7f4b5952d", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -48,7 +48,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, s.repr(cx.tcx())[]);\n+        add_span_comment(cx, s.span, s.repr(cx.tcx()).index(&FullRange));\n     }\n \n     let mut bcx = cx;\n@@ -188,7 +188,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(name[], thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(name.index(&FullRange), thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -437,7 +437,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(format!(\"{} in def-map for label\",\n-                                               r)[])\n+                                               r).index(&FullRange))\n                 }\n             }\n         }\n@@ -501,7 +501,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name[]);\n+    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -510,7 +510,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args[],\n+                                      args.index(&FullRange),\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n@@ -526,7 +526,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name[]);\n+    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n@@ -537,7 +537,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args[],\n+                                      args.index(&FullRange),\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;"}, {"sha": "6a1df82056d491c2ebf75150bbf96ef2b0e13a7d", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -464,7 +464,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n             }\n             _ => bcx.tcx().sess.bug(\n                 format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty))[])\n+                        bcx.ty_to_string(self.ty)).index(&FullRange))\n         };\n         Datum {\n             val: val,"}, {"sha": "5777ee78800124caea414b0999b85ab112317963", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -285,7 +285,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n+                                   ppaux::ty_to_string(cx.tcx(), type_)).index(&FullRange));\n         }\n     }\n \n@@ -298,7 +298,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  unique_type_id_str[])[]);\n+                                  unique_type_id_str.index(&FullRange)).index(&FullRange));\n         }\n     }\n \n@@ -335,13 +335,13 @@ impl<'tcx> TypeMap<'tcx> {\n         // unique ptr (~)       -> {~ :pointee-uid:}\n         // @-ptr (@)            -> {@ :pointee-uid:}\n         // sized vec ([T; x])   -> {[:size:] :element-uid:}\n-        // unsized vec ([T])    -> {[] :element-uid:}\n+        // unsized vec ([T])    -> {.index(&FullRange) :element-uid:}\n         // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n         // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n         //                             :return-type-uid: : (:bounds:)*}\n         // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n-        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // unique vec box (~.index(&FullRange)) -> {HEAP_VEC_BOX<:pointee-uid:>}\n         // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.get(&type_).cloned() {\n@@ -379,14 +379,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(component_type_id[]);\n+                    unique_type_id.push_str(component_type_id.index(&FullRange));\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id[]);\n+                unique_type_id.push_str(inner_type_id.index(&FullRange));\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -396,7 +396,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id[]);\n+                unique_type_id.push_str(inner_type_id.index(&FullRange));\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -406,21 +406,21 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id[]);\n+                unique_type_id.push_str(inner_type_id.index(&FullRange));\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(format!(\"[{}]\", len)[]);\n+                        unique_type_id.push_str(format!(\"[{}]\", len).index(&FullRange));\n                     }\n                     None => {\n-                        unique_type_id.push_str(\"[]\");\n+                        unique_type_id.push_str(\".index(&FullRange)\");\n                     }\n                 };\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id[]);\n+                unique_type_id.push_str(inner_type_id.index(&FullRange));\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -445,7 +445,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(parameter_type_id[]);\n+                    unique_type_id.push_str(parameter_type_id.index(&FullRange));\n                     unique_type_id.push(',');\n                 }\n \n@@ -458,7 +458,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(return_type_id[]);\n+                        unique_type_id.push_str(return_type_id.index(&FullRange));\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -474,8 +474,8 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             _ => {\n                 cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {}\",\n-                                      ppaux::ty_to_string(cx.tcx(), type_)[],\n-                                      type_.sty)[])\n+                                      ppaux::ty_to_string(cx.tcx(), type_).index(&FullRange),\n+                                      type_.sty).index(&FullRange))\n             }\n         };\n \n@@ -518,7 +518,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(format!(\"{:x}\", def_id.node)[]);\n+            output.push_str(format!(\"{:x}\", def_id.node).index(&FullRange));\n \n             // Maybe check that there is no self type here.\n \n@@ -531,7 +531,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(param_type_id[]);\n+                    output.push_str(param_type_id.index(&FullRange));\n                     output.push(',');\n                 }\n \n@@ -573,7 +573,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(parameter_type_id[]);\n+            unique_type_id.push_str(parameter_type_id.index(&FullRange));\n             unique_type_id.push(',');\n         }\n \n@@ -587,7 +587,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id[]);\n+                unique_type_id.push_str(return_type_id.index(&FullRange));\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -618,7 +618,7 @@ impl<'tcx> TypeMap<'tcx> {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n                                            self.get_unique_type_id_as_string(enum_type_id)\n-                                               [],\n+                                               .index(&FullRange),\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -799,19 +799,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {}\",\n-                                        var_item)[])\n+                                        var_item).index(&FullRange))\n                 }\n             }\n         },\n         _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {}\",\n-                                   var_item)[])\n+                                   var_item).index(&FullRange))\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, loc.file.name[]), loc.line as c_uint)\n+        (file_metadata(cx, loc.file.name.index(&FullRange)), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -822,7 +822,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).get().to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(var_name[]);\n+        namespace_node.mangled_name_of_contained_item(var_name.index(&FullRange));\n     let var_scope = namespace_node.scope;\n \n     let var_name = CString::from_slice(var_name.as_bytes());\n@@ -861,7 +861,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {}\",\n-                            node_id)[]);\n+                            node_id).index(&FullRange));\n             }\n         };\n \n@@ -915,7 +915,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {}\",\n-                                 ast_item)[]);\n+                                 ast_item).index(&FullRange));\n                 }\n             }\n         }\n@@ -925,7 +925,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {}\",\n-                                ast_item)[]);\n+                                ast_item).index(&FullRange));\n         }\n     };\n \n@@ -955,7 +955,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations[..address_op_count]\n+        address_operations: address_operations.index(&(0..address_op_count))\n     };\n \n     declare_local(bcx,\n@@ -1032,7 +1032,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     format!(\"no entry in lllocals table for {}\",\n-                            node_id)[]);\n+                            node_id).index(&FullRange));\n             }\n         };\n \n@@ -1146,7 +1146,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Some(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && bytes[bytes.len()-1 ..] == b\"}\" {\n+            if bytes.len() > 0 && bytes.index(&((bytes.len()-1)..)) == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -1290,7 +1290,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(name[]);\n+                    let name = token::str_to_ident(name.index(&FullRange));\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1322,7 +1322,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     cx.sess()\n                       .bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n-                                    fnitem)[])\n+                                    fnitem).index(&FullRange))\n                 }\n             }\n         }\n@@ -1333,7 +1333,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {}\",\n-                                   fnitem)[])\n+                                   fnitem).index(&FullRange))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1342,7 +1342,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name[]);\n+    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1369,7 +1369,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            function_name[]);\n+            function_name.index(&FullRange));\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1457,7 +1457,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature[]);\n+        return create_DIArray(DIB(cx), signature.index(&FullRange));\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1492,7 +1492,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(actual_self_type_name[]);\n+            name_to_append_suffix_to.push_str(actual_self_type_name.index(&FullRange));\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1531,7 +1531,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(actual_type_name[]);\n+            name_to_append_suffix_to.push_str(actual_type_name.index(&FullRange));\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1558,7 +1558,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), template_params[]);\n+        return create_DIArray(DIB(cx), template_params.index(&FullRange));\n     }\n }\n \n@@ -1652,7 +1652,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, filename[]);\n+    let file_metadata = file_metadata(cx, filename.index(&FullRange));\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1738,7 +1738,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            full_path[work_dir.len() + 1u..full_path.len()]\n+            full_path.index(&((work_dir.len() + 1u)..full_path.len()))\n         } else {\n             full_path\n         };\n@@ -1770,7 +1770,7 @@ fn scope_metadata(fcx: &FunctionContext,\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n                 format!(\"debuginfo: Could not find scope info for node {}\",\n-                        node)[]);\n+                        node).index(&FullRange));\n         }\n     }\n }\n@@ -1966,7 +1966,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                         cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      []);\n+                                      .index(&FullRange));\n                     }\n                 }\n \n@@ -1978,7 +1978,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions[]);\n+                                              member_descriptions.index(&FullRange));\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2050,7 +2050,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  struct_name[],\n+                                                  struct_name.index(&FullRange),\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2111,7 +2111,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           tuple_name[],\n+                           tuple_name.index(&FullRange),\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2171,7 +2171,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      member_descriptions[]);\n+                                                      member_descriptions.index(&FullRange));\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2204,7 +2204,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  member_descriptions[]);\n+                                                  member_descriptions.index(&FullRange));\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2304,7 +2304,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              variant_member_descriptions[]);\n+                                              variant_member_descriptions.index(&FullRange));\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2383,7 +2383,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    [],\n+                                    .index(&FullRange),\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2450,7 +2450,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name[]);\n+    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2637,7 +2637,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor)[]);\n+                                       llvm_version_minor).index(&FullRange));\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2675,7 +2675,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata[]);\n+        let type_array = create_DIArray(DIB(cx), member_metadata.index(&FullRange));\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -2774,7 +2774,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    member_llvm_types[],\n+                                    member_llvm_types.index(&FullRange),\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2796,11 +2796,11 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name[]);\n+    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           slice_type_name[],\n+                                           slice_type_name.index(&FullRange),\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2846,7 +2846,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), signature_metadata[]))\n+                create_DIArray(DIB(cx), signature_metadata.index(&FullRange)))\n         },\n         false);\n }\n@@ -2872,7 +2872,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   pp_type_name[])[]);\n+                                   pp_type_name.index(&FullRange)).index(&FullRange));\n         }\n     };\n \n@@ -2886,7 +2886,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            trait_type_name[],\n+                            trait_type_name.index(&FullRange),\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -3006,13 +3006,13 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   elements[],\n+                                   elements.index(&FullRange),\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n             cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {}\",\n-                                  sty)[])\n+                                  sty).index(&FullRange))\n         }\n     };\n \n@@ -3030,9 +3030,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                unique_type_id_str[],\n+                                                unique_type_id_str.index(&FullRange),\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, error_message[]);\n+                    cx.sess().span_bug(usage_site_span, error_message.index(&FullRange));\n                 }\n             };\n \n@@ -3045,9 +3045,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            unique_type_id_str[],\n+                            unique_type_id_str.index(&FullRange),\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, error_message[]);\n+                        cx.sess().span_bug(usage_site_span, error_message.index(&FullRange));\n                     }\n                 }\n                 None => {\n@@ -3253,7 +3253,7 @@ fn create_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name[]);\n+        let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3375,7 +3375,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, loc.file.name[]);\n+                        let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3849,7 +3849,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange));\n         }\n     }\n \n@@ -3932,21 +3932,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(format!(\"{}\", string.get().len())[]);\n+            output.push_str(format!(\"{}\", string.get().len()).index(&FullRange));\n             output.push_str(string.get());\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(format!(\"{}\", item_name.len())[]);\n+        name.push_str(format!(\"{}\", item_name.len()).index(&FullRange));\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta().crate_name[]\n+    cx.link_meta().crate_name.index(&FullRange)\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4023,7 +4023,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             None => {\n                 cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {}\",\n-                                      def_id)[]);\n+                                      def_id).index(&FullRange));\n             }\n         }\n     })"}, {"sha": "fe5333061c7004b924874b17417882d21c005c50", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -318,7 +318,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     unsized_info(bcx, k, id, ty_substs[tp_index], identity)\n                 }\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty))[])\n+                                          bcx.ty_to_string(unadjusted_ty)).index(&FullRange))\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n                 // Note that we preserve binding levels here:\n@@ -451,7 +451,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty))[])\n+                                        bcx.ty_to_string(datum_ty)).index(&FullRange))\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -657,7 +657,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {}\",\n-                        expr.node)[]);\n+                        expr.node).index(&FullRange));\n         }\n     }\n }\n@@ -1006,7 +1006,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {}\",\n-                        expr.node)[]);\n+                        expr.node).index(&FullRange));\n         }\n     }\n }\n@@ -1032,14 +1032,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, arms[], dest)\n+            _match::trans_match(bcx, expr, &**discr, arms.index(&FullRange), dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         fields[],\n+                         fields.index(&FullRange),\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1104,7 +1104,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      numbered_fields[],\n+                      numbered_fields.index(&FullRange),\n                       None,\n                       dest,\n                       Some(NodeInfo { id: expr.id, span: expr.span }))\n@@ -1148,21 +1148,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      args[],\n+                                      args.index(&FullRange),\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(args[]),\n+                                   callee::ArgExprs(args.index(&FullRange)),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(args[]),\n+                                      callee::ArgExprs(args.index(&FullRange)),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1211,7 +1211,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {}\",\n-                        expr.node)[]);\n+                        expr.node).index(&FullRange));\n         }\n     }\n }\n@@ -1261,7 +1261,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, format!(\n                 \"Non-DPS def {} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id))[]);\n+                def, bcx.node_id_to_string(ref_expr.id)).index(&FullRange));\n         }\n     }\n }\n@@ -1290,7 +1290,7 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.tcx().sess.span_bug(ref_expr.span, format!(\n                     \"trans_def_fn_unadjusted invoked on: {} for {}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx()))[]);\n+                    ref_expr.repr(ccx.tcx())).index(&FullRange));\n         }\n     }\n }\n@@ -1310,7 +1310,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid)[]);\n+                        nid).index(&FullRange));\n                 }\n             }\n         }\n@@ -1320,7 +1320,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid)[]);\n+                        nid).index(&FullRange));\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n@@ -1330,7 +1330,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.sess().unimpl(format!(\n                 \"unsupported def type in trans_local_var: {}\",\n-                def)[]);\n+                def).index(&FullRange));\n         }\n     }\n }\n@@ -1347,11 +1347,11 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::ty_struct(did, substs) => {\n-            op(0, struct_fields(tcx, did, substs)[])\n+            op(0, struct_fields(tcx, did, substs).index(&FullRange))\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, tup_fields(v[])[])\n+            op(0, tup_fields(v.index(&FullRange)).index(&FullRange))\n         }\n \n         ty::ty_enum(_, substs) => {\n@@ -1361,7 +1361,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.bug(format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx))[]);\n+                        ty.repr(tcx)).index(&FullRange));\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n@@ -1372,7 +1372,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                             op(variant_info.disr_val,\n                                struct_fields(tcx,\n                                              variant_id,\n-                                             substs)[])\n+                                             substs).index(&FullRange))\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\\n@@ -1386,7 +1386,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         _ => {\n             tcx.sess.bug(format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx))[]);\n+                ty.repr(tcx)).index(&FullRange));\n         }\n     }\n }\n@@ -1441,7 +1441,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         trans_adt(bcx,\n                   ty,\n                   discr,\n-                  numbered_fields[],\n+                  numbered_fields.index(&FullRange),\n                   optbase,\n                   dest,\n                   Some(NodeInfo { id: expr_id, span: expr_span }))\n@@ -2078,7 +2078,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out)[])\n+                                            k_out).index(&FullRange))\n                 }\n             }\n         }\n@@ -2087,7 +2087,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out)[])\n+                                    k_out).index(&FullRange))\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2249,7 +2249,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx()))[]);\n+                        datum.ty.repr(bcx.tcx())).index(&FullRange));\n         }\n     };\n "}, {"sha": "a90f0dbbf151ba5717bffa18ed0aba050c4d553c", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -109,7 +109,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(foreign_item.attrs[],\n+    match attr::first_attr_value_str_by_name(foreign_item.attrs.index(&FullRange),\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -233,13 +233,13 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => (fn_ty.abi, fn_ty.sig.clone()),\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys[]);\n+    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.index(&FullRange));\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys[],\n+                                         llsig.llarg_tys.index(&FullRange),\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys[];\n+    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.index(&FullRange);\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -365,7 +365,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        llargs_foreign[],\n+                                        llargs_foreign.index(&FullRange),\n                                         cc,\n                                         Some(attrs));\n \n@@ -435,7 +435,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             lname.get()[]);\n+                                             lname.get().index(&FullRange));\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -567,15 +567,15 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx))[]);\n+                                       t.repr(tcx)).index(&FullRange));\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, ps[]);\n+        let llfn = base::decl_internal_rust_fn(ccx, t, ps.index(&FullRange));\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -748,7 +748,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"calling llrustfn = {}, t = {}\",\n                ccx.tn().val_to_string(llrustfn), t.repr(ccx.tcx()));\n         let attributes = base::get_fn_llvm_attributes(ccx, t);\n-        let llrust_ret_val = builder.call(llrustfn, llrust_args[], Some(attributes));\n+        let llrust_ret_val = builder.call(llrustfn, llrust_args.index(&FullRange), Some(attributes));\n \n         // Get the return value where the foreign fn expects it.\n         let llforeign_ret_ty = match tys.fn_ty.ret_ty.cast {\n@@ -815,9 +815,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(i.attrs[], \"link_name\") {\n+    match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange), \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(i.attrs[]) {\n+        None => match weak_lang_items::link_name(i.attrs.index(&FullRange)) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -858,7 +858,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys[],\n+                                       llsig.llarg_tys.index(&FullRange),\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -867,9 +867,9 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(llsig.llarg_tys[]),\n+           ccx.tn().types_to_str(llsig.llarg_tys.index(&FullRange)),\n            ccx.tn().type_to_string(llsig.llret_ty),\n-           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()[]),\n+           ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().index(&FullRange)),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n            llsig.ret_def);\n \n@@ -919,7 +919,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.0.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys[], &llreturn_ty)\n+        Type::func(llargument_tys.index(&FullRange), &llreturn_ty)\n     }\n }\n "}, {"sha": "056842657ad29193931298f05497b364899a0cb1", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -161,7 +161,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, old_sym.index(&FullRange), llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -232,7 +232,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             f.sig.0.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty))[])\n+                                    bcx.ty_to_string(fty)).index(&FullRange))\n     };\n \n     let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n@@ -293,7 +293,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args[], dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args.index(&FullRange), dtor_ty, None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -352,7 +352,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n         _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t))[])\n+                                    bcx.ty_to_string(t)).index(&FullRange))\n     }\n }\n \n@@ -424,7 +424,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t))[]);\n+                                                bcx.ty_to_string(t)).index(&FullRange));\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -494,7 +494,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        ppaux::ty_to_string(ccx.tcx(), t)[]);\n+        ppaux::ty_to_string(ccx.tcx(), t).index(&FullRange));\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -513,8 +513,8 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        format!(\"glue_{}\", name)[]);\n-    let llfn = decl_cdecl_fn(ccx, fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n+        format!(\"glue_{}\", name).index(&FullRange));\n+    let llfn = decl_cdecl_fn(ccx, fn_nm.index(&FullRange), llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "53ce8dd64b87d4055028e74cf70fb0eab1c82b0a", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -77,7 +77,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let trans_everywhere = attr::requests_inline(method.attrs[]);\n+                    let trans_everywhere = attr::requests_inline(method.attrs.index(&FullRange));\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n@@ -229,7 +229,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Here, in this call, which I've written with explicit UFCS\n     // notation, the set of type parameters will be:\n     //\n-    //     rcvr_type: [] <-- nothing declared on the trait itself\n+    //     rcvr_type: .index(&FullRange) <-- nothing declared on the trait itself\n     //     rcvr_self: [Vec<int>] <-- the self type\n     //     rcvr_method: [String] <-- method type parameter\n     //\n@@ -268,11 +268,11 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             //\n             // Recall that we matched `<Vec<int> as Convert>`. Trait\n             // resolution will have given us a substitution\n-            // containing `impl_substs=[[T=int],[],[]]` (the type\n+            // containing `impl_substs=[[T=int],.index(&FullRange),.index(&FullRange)]` (the type\n             // parameters defined on the impl). We combine\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n-            // `callee_substs=[[T=int],[],[U=String]]`.\n+            // `callee_substs=[[T=int],.index(&FullRange),[U=String]]`.\n             let subst::SeparateVecsPerParamSpace {\n                 types: impl_type,\n                 selfs: impl_self,\n@@ -290,7 +290,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             tcx.sess.bug(format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx))[]);\n+                                 vtbl.repr(tcx)).index(&FullRange));\n         }\n     }\n }\n@@ -378,7 +378,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx()))[]);\n+                        vtable.repr(bcx.tcx())).index(&FullRange));\n         }\n     }\n }\n@@ -728,7 +728,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx.sess().bug(\n                     format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx()))[]);\n+                            vtable.repr(bcx.tcx())).index(&FullRange));\n             }\n         }\n     });\n@@ -760,7 +760,7 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n \n     unsafe {\n-        let tbl = C_struct(ccx, components[], false);\n+        let tbl = C_struct(ccx, components.index(&FullRange), false);\n         let sym = token::gensym(\"vtable\");\n         let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n         let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),"}, {"sha": "df67866e5b02576071ff6aacfd2b542dc773771e", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -131,7 +131,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         hash = format!(\"h{}\", state.result());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, hash[])\n+            exported_name(path, hash.index(&FullRange))\n         })\n     };\n \n@@ -141,9 +141,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |&mut : abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s[])\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s.index(&FullRange))\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, s[])\n+            decl_internal_rust_fn(ccx, mono_ty, s.index(&FullRange))\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -177,12 +177,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, i.attrs[]);\n+                  let needs_body = setup_lldecl(d, i.attrs.index(&FullRange));\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(hash[]));\n+                              Some(hash.index(&FullRange)));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -206,7 +206,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       args[],\n+                                       args.index(&FullRange),\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);\n@@ -220,7 +220,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs[]);\n+                    let needs_body = setup_lldecl(d, mth.attrs.index(&FullRange));\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -241,7 +241,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs[]);\n+                    let needs_body = setup_lldecl(d, mth.attrs.index(&FullRange));\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n@@ -250,15 +250,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     ccx.sess().bug(format!(\"can't monomorphize a {}\",\n-                                           map_node)[])\n+                                           map_node).index(&FullRange))\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields[],\n+                                     struct_def.fields.index(&FullRange),\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -276,7 +276,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(format!(\"can't monomorphize a {}\",\n-                                   map_node)[])\n+                                   map_node).index(&FullRange))\n         }\n     };\n "}, {"sha": "a4f51bc50e567df7f18241cabb330277ff91e841", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -103,7 +103,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx().sess.target.target.target_word_size[] {\n+        match ccx.tcx().sess.target.target.target_word_size.index(&FullRange) {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "c6c2749f378345ff31d5bffb1fff11aad6befa6f", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -137,7 +137,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(atys[], &lloutputtype)\n+    Type::func(atys.index(&FullRange), &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -182,7 +182,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     let llsizingty = match t.sty {\n         _ if !lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t))[])\n+                                  ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -235,7 +235,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t))[])\n+                                  ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -312,7 +312,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, name[])\n+          adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n       }\n       ty::ty_unboxed_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -323,7 +323,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, name[])\n+          adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -379,7 +379,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, name[])\n+              adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n           }\n       }\n \n@@ -398,7 +398,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t))[])\n+                                     ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "7d36d01cc506067b382a54f4918274e6cfc19ba4", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -197,7 +197,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n                                     help_name\n                                 } else {\n                                     format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                }[]);\n+                                }.index(&FullRange));\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -347,7 +347,7 @@ fn create_substs_for_ast_path<'tcx>(\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count).index(&FullRange));\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n@@ -358,7 +358,7 @@ fn create_substs_for_ast_path<'tcx>(\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count).index(&FullRange));\n     }\n \n     let mut substs = Substs::new_type(types, regions);\n@@ -377,7 +377,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n+    for param in ty_param_defs.index(&(supplied_ty_param_count..)).iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter.\n@@ -556,7 +556,7 @@ pub fn instantiate_trait_ref<'tcx>(\n         _ => {\n             this.tcx().sess.span_fatal(\n                 ast_trait_ref.path.span,\n-                format!(\"`{}` is not a trait\", ast_trait_ref.path.user_string(this.tcx()))[]);\n+                format!(\"`{}` is not a trait\", ast_trait_ref.path.user_string(this.tcx())).index(&FullRange));\n         }\n     }\n }\n@@ -825,7 +825,7 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   format!(\"unbound path {}\",\n-                                          path.repr(this.tcx()))[])\n+                                          path.repr(this.tcx())).index(&FullRange))\n                 }\n                 Some(&d) => d\n             };\n@@ -847,7 +847,7 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                             this.tcx().sess.span_bug(\n                                 path.span,\n                                 format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx()))[]);\n+                                        ty.repr(this.tcx())).index(&FullRange));\n                         }\n                     }\n                 }\n@@ -1067,10 +1067,10 @@ pub fn ast_ty_to_ty<'tcx>(\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds[]) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.index(&FullRange)) {\n                     Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this, rscope, ast_ty.span,\n-                                                 trait_ref, projection_bounds, bounds[])\n+                                                 trait_ref, projection_bounds, bounds.index(&FullRange))\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err\n@@ -1105,15 +1105,15 @@ pub fn ast_ty_to_ty<'tcx>(\n                 ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds[])\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.index(&FullRange))\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      format!(\"unbound path {}\",\n-                                             path.repr(tcx))[])\n+                                             path.repr(tcx)).index(&FullRange))\n                     }\n                     Some(&d) => d\n                 };\n@@ -1152,7 +1152,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                             format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node))[]);\n+                                    tcx.map.node_to_string(id.node)).index(&FullRange));\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n@@ -1171,7 +1171,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get())[]);\n+                                                  .get()).index(&FullRange));\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n@@ -1181,7 +1181,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n                                                      as a type: {}\",\n-                                                    a_def)[]);\n+                                                    a_def).index(&FullRange));\n                     }\n                 }\n             }\n@@ -1209,7 +1209,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                             ast_ty.span,\n                             format!(\"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r)[]);\n+                                    *r).index(&FullRange));\n                     }\n                 }\n             }\n@@ -1331,7 +1331,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n-        decl.inputs[]\n+        decl.inputs.index(&FullRange)\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()\n@@ -1546,7 +1546,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n {\n-    let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n+    let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds.index(&FullRange));\n \n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n@@ -1596,7 +1596,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n         this.tcx().sess.span_err(\n             b.trait_ref.path.span,\n             format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\")[]);\n+                     as closure or object bounds\").index(&FullRange));\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1669,7 +1669,7 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n         tcx.sess.span_err(\n             span,\n             format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\")[]);\n+                     explicit lifetime bound required\").index(&FullRange));\n     }\n     return Some(r);\n }\n@@ -1695,7 +1695,7 @@ fn compute_region_bound<'tcx>(\n                 None => {\n                     this.tcx().sess.span_err(\n                         span,\n-                        format!(\"explicit lifetime bound required\")[]);\n+                        format!(\"explicit lifetime bound required\").index(&FullRange));\n                     ty::ReStatic\n                 }\n             }"}, {"sha": "a9018c8985a2f24b4a6c30792f5991f48b6c9166", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -315,7 +315,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx()))[])\n+                            self_ty.repr(self.tcx())).index(&FullRange))\n             }\n         }\n     }\n@@ -370,7 +370,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx()))[]);\n+                        method_self_ty.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }"}, {"sha": "f495885bd108d113fe497d7c7f5c9eeaab602e89", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -266,7 +266,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                                 span,\n                                 format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx()))[]);\n+                                    transformed_self_ty.repr(fcx.tcx())).index(&FullRange));\n                         }\n                     }\n                 }\n@@ -276,7 +276,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                         span,\n                         format!(\n                             \"unexpected explicit self type in operator method: {}\",\n-                            method_ty.explicit_self)[]);\n+                            method_ty.explicit_self).index(&FullRange));\n                 }\n             }\n         }\n@@ -330,7 +330,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_field {\n                 cx.sess.span_note(span,\n                     format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring)[]);\n+                            function stored in the `{0}` field\", method_ustring).index(&FullRange));\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "3bc29bb9ef737787c27ca9f55ecbd1c9088d779c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -576,7 +576,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     self.tcx().sess.span_bug(\n                         self.span,\n                         format!(\"No entry for unboxed closure: {}\",\n-                                closure_def_id.repr(self.tcx()))[]);\n+                                closure_def_id.repr(self.tcx())).index(&FullRange));\n                 }\n             };\n \n@@ -745,15 +745,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, self.inherent_candidates[]) {\n+        match self.consider_candidates(self_ty, self.inherent_candidates.index(&FullRange)) {\n             None => {}\n             Some(pick) => {\n                 return Some(pick);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(self_ty, self.extension_candidates[])\n+        self.consider_candidates(self_ty, self.extension_candidates.index(&FullRange))\n     }\n \n     fn consider_candidates(&self,\n@@ -768,7 +768,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(applicable_candidates[]) {\n+            match self.collapse_candidates_to_trait_pick(applicable_candidates.index(&FullRange)) {\n                 Some(pick) => { return Some(Ok(pick)); }\n                 None => { }\n             }\n@@ -864,7 +864,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             Some(data) => data,\n             None => return None,\n         };\n-        if probes[1..].iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n+        if probes.index(&(1..)).iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n             return None;\n         }\n "}, {"sha": "25e53c74f257211ea91c37ccad5f2dce88f794d0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -593,7 +593,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    let arg_tys = fn_sig.inputs[];\n+    let arg_tys = fn_sig.inputs.index(&FullRange);\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -691,7 +691,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants[],\n+                            enum_definition.variants.index(&FullRange),\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -989,7 +989,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self))[]);\n+                            &impl_m.explicit_self)).index(&FullRange));\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n@@ -999,7 +999,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self))[]);\n+                            &trait_m.explicit_self)).index(&FullRange));\n             return;\n         }\n         _ => {\n@@ -1360,7 +1360,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 span,\n                 format!(\"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                        token::get_name(impl_m.name))[]);\n+                        token::get_name(impl_m.name)).index(&FullRange));\n             return false;\n         }\n \n@@ -1412,7 +1412,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                          from its counterpart `{}` \\\n                          declared in the trait\",\n                         impl_param.name.user_string(tcx),\n-                        trait_param.name.user_string(tcx))[]);\n+                        trait_param.name.user_string(tcx)).index(&FullRange));\n                 true\n             } else {\n                 false\n@@ -1422,14 +1422,14 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                 tcx.sess.span_note(\n                     span,\n                     format!(\"the impl is missing the following bounds: `{}`\",\n-                            missing.user_string(tcx))[]);\n+                            missing.user_string(tcx)).index(&FullRange));\n             }\n \n             if extra.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n                     format!(\"the impl has the following extra bounds: `{}`\",\n-                            extra.user_string(tcx))[]);\n+                            extra.user_string(tcx)).index(&FullRange));\n             }\n \n             if err {\n@@ -1700,7 +1700,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     span,\n                     format!(\"no type for local variable {}\",\n-                            nid)[]);\n+                            nid).index(&FullRange));\n             }\n         }\n     }\n@@ -2034,7 +2034,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                            self.tag())[]);\n+                                            self.tag()).index(&FullRange));\n             }\n         }\n     }\n@@ -2064,7 +2064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag())[]);\n+                            self.tag()).index(&FullRange));\n             }\n         }\n     }\n@@ -2544,7 +2544,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    err_string[]);\n+                                    err_string.index(&FullRange));\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2571,7 +2571,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                         format!(\"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n                                                 maybe try .iter()\",\n-                                                ty_string)[]);\n+                                                ty_string).index(&FullRange));\n             }\n             fcx.tcx().types.err\n         }\n@@ -2609,7 +2609,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                             format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n-                                            []);\n+                                            .index(&FullRange));\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -2636,7 +2636,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             err_inputs[],\n+                             err_inputs.index(&FullRange),\n                              args_no_rcvr,\n                              autoref_args,\n                              false,\n@@ -3088,7 +3088,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n+        let args: Vec<_> = args.index(&(1..)).iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n@@ -3406,7 +3406,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        lookup_field_ty(tcx, base_id, fields[],\n+                        lookup_field_ty(tcx, base_id, fields.index(&FullRange),\n                                         field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3469,7 +3469,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            lookup_tup_field_ty(tcx, base_id, fields[],\n+                            lookup_tup_field_ty(tcx, base_id, fields.index(&FullRange),\n                                                 idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3634,7 +3634,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       class_fields[],\n+                                       class_fields.index(&FullRange),\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n@@ -3677,7 +3677,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(substitutions),\n-                                       variant_fields[],\n+                                       variant_fields.index(&FullRange),\n                                        fields,\n                                        true,\n                                        Some(enum_id));\n@@ -4056,7 +4056,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           callee::check_call(fcx, expr, &**callee, args.as_slice());\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args[], tps[], lvalue_pref);\n+        check_method_call(fcx, expr, ident, args.index(&FullRange), tps.index(&FullRange), lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {\n@@ -4144,7 +4144,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expected = expected.only_has_type();\n         let flds = expected.map_to_option(fcx, |ty| {\n             match ty.sty {\n-                ty::ty_tup(ref flds) => Some(flds[]),\n+                ty::ty_tup(ref flds) => Some(flds.index(&FullRange)),\n                 _ => None\n             }\n         });\n@@ -4178,7 +4178,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, fields[]);\n+                                          variant_id, fields.index(&FullRange));\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -4187,7 +4187,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             fields[],\n+                                             fields.index(&FullRange),\n                                              base_expr);\n                 def_id\n             },\n@@ -4200,7 +4200,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 fields[],\n+                                                 fields.index(&FullRange),\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -4209,7 +4209,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     fields[],\n+                                                     fields.index(&FullRange),\n                                                      base_expr);\n                     }\n                 }\n@@ -4250,7 +4250,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description)[]);\n+                                         type_error_description).index(&FullRange));\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4971,7 +4971,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-                    [].get(0).unwrap_or(&attr::ReprAny);\n+                    .index(&FullRange).get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n@@ -5642,7 +5642,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s[]); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, s.index(&FullRange)); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -5658,7 +5658,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                 ty::mk_struct(ccx.tcx, did,\n                                               ccx.tcx.mk_substs(subst::Substs::empty()))),\n                     Err(msg) => {\n-                        tcx.sess.span_fatal(it.span, msg[]);\n+                        tcx.sess.span_fatal(it.span, msg.index(&FullRange));\n                     }\n                 }\n             },"}, {"sha": "ffb721dd7ac7d284185d76a3b575686173b9caa2", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -189,7 +189,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n         }\n         _ => {\n             tcx.sess.bug(format!(\"unexpected def in region_of_def: {}\",\n-                                 def)[])\n+                                 def).index(&FullRange))\n         }\n     }\n }\n@@ -282,13 +282,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"No fn-sig entry for id={}\", id)[]);\n+                    format!(\"No fn-sig entry for id={}\", id).index(&FullRange));\n             }\n         };\n \n         let len = self.region_bound_pairs.len();\n-        self.relate_free_regions(fn_sig[], body.id);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs[]);\n+        self.relate_free_regions(fn_sig.index(&FullRange), body.id);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs.index(&FullRange));\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n@@ -627,7 +627,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, arms[]);\n+            link_match(rcx, &**discr, arms.index(&FullRange));\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -952,7 +952,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n                             format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx()))[])\n+                                    method.ty.repr(rcx.tcx())).index(&FullRange))\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n@@ -1318,7 +1318,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                         span,\n                         format!(\"Illegal upvar id: {}\",\n                                 upvar_id.repr(\n-                                    rcx.tcx()))[]);\n+                                    rcx.tcx())).index(&FullRange));\n                 }\n             }\n         }"}, {"sha": "84d94b0392e9df33be97a4fab3d0c9d7e49f5e1a", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n             ty::ty_open(_) => {\n                 self.tcx.sess.bug(\n                     format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx))[]);\n+                            ty.repr(self.tcx)).index(&FullRange));\n             }\n         }\n     }"}, {"sha": "e302609bf228b52160820ae0faa461914addd6fc", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -74,15 +74,15 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 source_expr.span,\n                 format!(\"can only cast an boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                        ty::ty_sort_string(fcx.tcx(), source_ty)).index(&FullRange));\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n                 format!(\"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                        ty::ty_sort_string(fcx.tcx(), source_ty)).index(&FullRange));\n         }\n \n         _ => {"}, {"sha": "7597a410f62bf23057967fbec4d9f73a654356c8", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -81,7 +81,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             inference_context.tcx.sess.span_bug(\n                 span,\n                 format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx))[]);\n+                        ty.repr(inference_context.tcx)).index(&FullRange));\n         }\n     }\n }\n@@ -490,15 +490,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                  format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name)).index(&FullRange))\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n                                  format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name)).index(&FullRange))\n                 }\n                 Err(ty::TypeIsStructural) => {\n                     tcx.sess"}, {"sha": "cc36065656cb328fcb47cfb955b87dda52860e0c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -211,7 +211,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, input_tys[], enum_ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, input_tys.index(&FullRange), enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -258,7 +258,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items[],\n+                                    trait_items.index(&FullRange),\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -272,7 +272,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items[],\n+                                    trait_items.index(&FullRange),\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -774,7 +774,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n-                                                inputs[],\n+                                                inputs.index(&FullRange),\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n@@ -815,7 +815,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n             ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                     trait_id.node)[])\n+                                     trait_id.node).index(&FullRange))\n         }\n     }\n }\n@@ -840,7 +840,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {}\", s)[]);\n+                format!(\"trait_def_of_item invoked on {}\", s).index(&FullRange));\n         }\n     };\n \n@@ -1025,8 +1025,8 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                generics.lifetimes[],\n-                generics.ty_params[],\n+                generics.lifetimes.index(&FullRange),\n+                generics.ty_params.index(&FullRange),\n                 ty::Generics::empty(),\n                 &generics.where_clause)\n }\n@@ -1044,8 +1044,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    ast_generics.lifetimes[],\n-                    ast_generics.ty_params[],\n+                    ast_generics.lifetimes.index(&FullRange),\n+                    ast_generics.ty_params.index(&FullRange),\n                     ty::Generics::empty(),\n                     &ast_generics.where_clause);\n \n@@ -1130,8 +1130,8 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx,\n                 subst::FnSpace,\n-                early_lifetimes[],\n-                generics.ty_params[],\n+                early_lifetimes.index(&FullRange),\n+                generics.ty_params.index(&FullRange),\n                 base_generics,\n                 &generics.where_clause)\n }\n@@ -1318,7 +1318,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n                                 param_ty.to_ty(ccx.tcx),\n-                                param.bounds[],\n+                                param.bounds.index(&FullRange,\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n@@ -1399,7 +1399,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             tcx,\n-            param_bounds.trait_bounds[],\n+            param_bounds.trait_bounds.index(&FullRange),\n             |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {"}, {"sha": "f7abd8a1cc6a6642966977d60567090db3d60868", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -207,7 +207,7 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n                               format!(\"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr))[]);\n+                                                          terr)).index(&FullRange));\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n@@ -256,7 +256,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                               format!(\"main has a non-function type: found \\\n                                        `{}`\",\n                                       ppaux::ty_to_string(tcx,\n-                                                       main_t))[]);\n+                                                       main_t)).index(&FullRange));\n         }\n     }\n }\n@@ -307,7 +307,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             tcx.sess.span_bug(start_span,\n                               format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_string(tcx, start_t))[]);\n+                                      ppaux::ty_to_string(tcx, start_t)).index(&FullRange));\n         }\n     }\n }"}, {"sha": "3ca0e40c51ed49c3f5bf4e6d2b6c022868b2c30a", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -564,7 +564,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.bug(format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id))[]);\n+                        self.tcx().map.node_to_string(param_id)).index(&FullRange));\n             }\n         }\n     }\n@@ -839,7 +839,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx()))[]);\n+                            ty.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }\n@@ -919,7 +919,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     .sess\n                     .bug(format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx()))[]);\n+                                 region.repr(self.tcx())).index(&FullRange));\n             }\n         }\n     }\n@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), found[]);\n+                tcx.sess.span_err(tcx.map.span(item_id), found.index(&FullRange));\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "e6d1dfd62d0fafe68fdc1823c669b33c8f26985e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -798,7 +798,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs[1..]\n+            _ => all_inputs.index(&(1..))\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -836,7 +836,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs[1..]\n+            _ => self.decl.inputs.index(&(1..))\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1132,7 +1132,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::Binder(ty::FnSig {\n-                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n+                    inputs: self.fty.sig.0.inputs.index(&(1..)).to_vec(),\n                     ..self.fty.sig.0.clone()\n                 });\n                 let s = match s {"}, {"sha": "6c0f6610802b4bfd681c6ca0f78b170af927e489", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -311,7 +311,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments[..amt].iter() {\n+                for seg in path.segments.index(&(0..amt)).iter() {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -326,7 +326,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n                 }\n             }\n             None => {\n-                for seg in path.segments[..amt].iter() {\n+                for seg in path.segments.index(&(0..amt)).iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }"}, {"sha": "3d2c5e2cbb5fb4d933455b5744c1636362518e33", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(out[]).into_owned()\n+    String::from_utf8_lossy(out.index(&FullRange)).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "18c79fb9c5982f56d4443833536b093818f2b1a9", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -193,7 +193,6 @@\n //! ```\n \n use self::JsonEvent::*;\n-use self::StackElement::*;\n use self::ErrorCode::*;\n use self::ParserError::*;\n use self::DecoderError::*;\n@@ -208,7 +207,7 @@ use std::num::{Float, Int};\n use std::num::FpCategory as Fp;\n use std::str::FromStr;\n use std::string;\n-use std::ops;\n+use std::ops::Index;\n use unicode::str as unicode_str;\n use unicode::str::Utf16Item;\n \n@@ -384,7 +383,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n         };\n \n         if start < i {\n-            try!(wr.write_str(v[start..i]));\n+            try!(wr.write_str(v.index(&(start..i))));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -393,7 +392,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n     }\n \n     if start != v.len() {\n-        try!(wr.write_str(v[start..]));\n+        try!(wr.write_str(v.index(&(start..))));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -402,7 +401,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n-    let buf = unsafe { str::from_utf8_unchecked(buf[0..n]) };\n+    let buf = unsafe { str::from_utf8_unchecked(buf.index(&(0..n))) };\n     escape_str(writer, buf)\n }\n \n@@ -415,7 +414,7 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(BUF[..n])\n+        wr.write_str(BUF.index(&(0..n)))\n     } else {\n         Ok(())\n     }\n@@ -624,7 +623,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf[]).unwrap();\n+        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -895,7 +894,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf[]).unwrap();\n+        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -1028,7 +1027,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(s[]),\n+            Json::String(ref s) => Some(s.index(&FullRange)),\n             _ => None\n         }\n     }\n@@ -1187,7 +1186,7 @@ pub struct Stack {\n }\n \n /// StackElements compose a Stack.\n-/// For example, Key(\"foo\"), Key(\"bar\"), Index(3) and Key(\"x\") are the\n+/// For example, StackElement::Key(\"foo\"), StackElement::Key(\"bar\"), StackElement::Index(3) and StackElement::Key(\"x\") are the\n /// StackElements compositing the stack that represents foo.bar[3].x\n #[derive(PartialEq, Clone, Show)]\n pub enum StackElement<'l> {\n@@ -1219,10 +1218,11 @@ impl Stack {\n     /// at the top.\n     pub fn get<'l>(&'l self, idx: uint) -> StackElement<'l> {\n         match self.stack[idx] {\n-            InternalIndex(i) => Index(i),\n+            InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n-                Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. start as uint + size as uint]).unwrap())\n+                StackElement::Key(str::from_utf8(\n+                    self.str_buffer.index(&((start as uint) .. (start as uint + size as uint))))\n+                        .unwrap())\n             }\n         }\n     }\n@@ -1261,24 +1261,24 @@ impl Stack {\n     pub fn top<'l>(&'l self) -> Option<StackElement<'l>> {\n         return match self.stack.last() {\n             None => None,\n-            Some(&InternalIndex(i)) => Some(Index(i)),\n+            Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n-                Some(Key(str::from_utf8(\n-                    self.str_buffer[start as uint .. (start+size) as uint]\n+                Some(StackElement::Key(str::from_utf8(\n+                    self.str_buffer.index(&((start as uint) .. (start+size) as uint))\n                 ).unwrap()))\n             }\n         }\n     }\n \n-    // Used by Parser to insert Key elements at the top of the stack.\n+    // Used by Parser to insert StackElement::Key elements at the top of the stack.\n     fn push_key(&mut self, key: string::String) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n         for c in key.as_bytes().iter() {\n             self.str_buffer.push(*c);\n         }\n     }\n \n-    // Used by Parser to insert Index elements at the top of the stack.\n+    // Used by Parser to insert StackElement::Index elements at the top of the stack.\n     fn push_index(&mut self, index: u32) {\n         self.stack.push(InternalIndex(index));\n     }\n@@ -1948,7 +1948,7 @@ impl<T: Iterator<Item=char>> Builder<T> {\n                 _ => {}\n             }\n             let key = match self.parser.stack().top() {\n-                Some(Key(k)) => { k.to_string() }\n+                Some(StackElement::Key(k)) => { k.to_string() }\n                 _ => { panic!(\"invalid state\"); }\n             };\n             match self.build_value() {\n@@ -2143,7 +2143,7 @@ impl ::Decoder for Decoder {\n                 return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter().position(|n| *n == name[]) {\n+        let idx = match names.iter().position(|n| *n == name.index(&FullRange)) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -3351,7 +3351,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf[]).unwrap();\n+        let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3367,7 +3367,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf[]).unwrap();\n+        let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3407,7 +3407,7 @@ mod tests {\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n \n-            let printed = from_utf8(writer[]).unwrap();\n+            let printed = from_utf8(writer.index(&FullRange)).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();\n@@ -3477,20 +3477,20 @@ mod tests {\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n             vec![\n                 (ObjectStart,             vec![]),\n-                  (StringValue(\"bar\".to_string()),   vec![Key(\"foo\")]),\n-                  (ArrayStart,            vec![Key(\"array\")]),\n-                    (U64Value(0),         vec![Key(\"array\"), Index(0)]),\n-                    (U64Value(1),         vec![Key(\"array\"), Index(1)]),\n-                    (U64Value(2),         vec![Key(\"array\"), Index(2)]),\n-                    (U64Value(3),         vec![Key(\"array\"), Index(3)]),\n-                    (U64Value(4),         vec![Key(\"array\"), Index(4)]),\n-                    (U64Value(5),         vec![Key(\"array\"), Index(5)]),\n-                  (ArrayEnd,              vec![Key(\"array\")]),\n-                  (ArrayStart,            vec![Key(\"idents\")]),\n-                    (NullValue,           vec![Key(\"idents\"), Index(0)]),\n-                    (BooleanValue(true),  vec![Key(\"idents\"), Index(1)]),\n-                    (BooleanValue(false), vec![Key(\"idents\"), Index(2)]),\n-                  (ArrayEnd,              vec![Key(\"idents\")]),\n+                  (StringValue(\"bar\".to_string()),   vec![StackElement::Key(\"foo\")]),\n+                  (ArrayStart,            vec![StackElement::Key(\"array\")]),\n+                    (U64Value(0),         vec![StackElement::Key(\"array\"), StackElement::Index(0)]),\n+                    (U64Value(1),         vec![StackElement::Key(\"array\"), StackElement::Index(1)]),\n+                    (U64Value(2),         vec![StackElement::Key(\"array\"), StackElement::Index(2)]),\n+                    (U64Value(3),         vec![StackElement::Key(\"array\"), StackElement::Index(3)]),\n+                    (U64Value(4),         vec![StackElement::Key(\"array\"), StackElement::Index(4)]),\n+                    (U64Value(5),         vec![StackElement::Key(\"array\"), StackElement::Index(5)]),\n+                  (ArrayEnd,              vec![StackElement::Key(\"array\")]),\n+                  (ArrayStart,            vec![StackElement::Key(\"idents\")]),\n+                    (NullValue,           vec![StackElement::Key(\"idents\"), StackElement::Index(0)]),\n+                    (BooleanValue(true),  vec![StackElement::Key(\"idents\"), StackElement::Index(1)]),\n+                    (BooleanValue(false), vec![StackElement::Key(\"idents\"), StackElement::Index(2)]),\n+                  (ArrayEnd,              vec![StackElement::Key(\"idents\")]),\n                 (ObjectEnd,               vec![]),\n             ]\n         );\n@@ -3530,27 +3530,27 @@ mod tests {\n             \"{\\\"a\\\": 3}\",\n             vec![\n                 (ObjectStart,        vec![]),\n-                  (U64Value(3),      vec![Key(\"a\")]),\n+                  (U64Value(3),      vec![StackElement::Key(\"a\")]),\n                 (ObjectEnd,          vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n             vec![\n                 (ObjectStart,           vec![]),\n-                  (NullValue,           vec![Key(\"a\")]),\n-                  (BooleanValue(true),  vec![Key(\"b\")]),\n+                  (NullValue,           vec![StackElement::Key(\"a\")]),\n+                  (BooleanValue(true),  vec![StackElement::Key(\"b\")]),\n                 (ObjectEnd,             vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n             vec![\n                 (ObjectStart,           vec![]),\n-                  (F64Value(1.0),       vec![Key(\"a\")]),\n-                  (ArrayStart,          vec![Key(\"b\")]),\n-                    (BooleanValue(true),vec![Key(\"b\"), Index(0)]),\n-                  (ArrayEnd,            vec![Key(\"b\")]),\n+                  (F64Value(1.0),       vec![StackElement::Key(\"a\")]),\n+                  (ArrayStart,          vec![StackElement::Key(\"b\")]),\n+                    (BooleanValue(true),vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n+                  (ArrayEnd,            vec![StackElement::Key(\"b\")]),\n                 (ObjectEnd,             vec![]),\n             ]\n         );\n@@ -3565,16 +3565,16 @@ mod tests {\n             }\"#,\n             vec![\n                 (ObjectStart,                   vec![]),\n-                  (F64Value(1.0),               vec![Key(\"a\")]),\n-                  (ArrayStart,                  vec![Key(\"b\")]),\n-                    (BooleanValue(true),        vec![Key(\"b\"), Index(0)]),\n-                    (StringValue(\"foo\\nbar\".to_string()),  vec![Key(\"b\"), Index(1)]),\n-                    (ObjectStart,               vec![Key(\"b\"), Index(2)]),\n-                      (ObjectStart,             vec![Key(\"b\"), Index(2), Key(\"c\")]),\n-                        (NullValue,             vec![Key(\"b\"), Index(2), Key(\"c\"), Key(\"d\")]),\n-                      (ObjectEnd,               vec![Key(\"b\"), Index(2), Key(\"c\")]),\n-                    (ObjectEnd,                 vec![Key(\"b\"), Index(2)]),\n-                  (ArrayEnd,                    vec![Key(\"b\")]),\n+                  (F64Value(1.0),               vec![StackElement::Key(\"a\")]),\n+                  (ArrayStart,                  vec![StackElement::Key(\"b\")]),\n+                    (BooleanValue(true),        vec![StackElement::Key(\"b\"), StackElement::Index(0)]),\n+                    (StringValue(\"foo\\nbar\".to_string()),  vec![StackElement::Key(\"b\"), StackElement::Index(1)]),\n+                    (ObjectStart,               vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n+                      (ObjectStart,             vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")]),\n+                        (NullValue,             vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\"), StackElement::Key(\"d\")]),\n+                      (ObjectEnd,               vec![StackElement::Key(\"b\"), StackElement::Index(2), StackElement::Key(\"c\")]),\n+                    (ObjectEnd,                 vec![StackElement::Key(\"b\"), StackElement::Index(2)]),\n+                  (ArrayEnd,                    vec![StackElement::Key(\"b\")]),\n                 (ObjectEnd,                     vec![]),\n             ]\n         );\n@@ -3600,53 +3600,53 @@ mod tests {\n             \"[true]\",\n             vec![\n                 (ArrayStart,             vec![]),\n-                    (BooleanValue(true), vec![Index(0)]),\n+                    (BooleanValue(true), vec![StackElement::Index(0)]),\n                 (ArrayEnd,               vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[ false ]\",\n             vec![\n                 (ArrayStart,              vec![]),\n-                    (BooleanValue(false), vec![Index(0)]),\n+                    (BooleanValue(false), vec![StackElement::Index(0)]),\n                 (ArrayEnd,                vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[null]\",\n             vec![\n                 (ArrayStart,    vec![]),\n-                    (NullValue, vec![Index(0)]),\n+                    (NullValue, vec![StackElement::Index(0)]),\n                 (ArrayEnd,      vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[3, 1]\",\n             vec![\n                 (ArrayStart,      vec![]),\n-                    (U64Value(3), vec![Index(0)]),\n-                    (U64Value(1), vec![Index(1)]),\n+                    (U64Value(3), vec![StackElement::Index(0)]),\n+                    (U64Value(1), vec![StackElement::Index(1)]),\n                 (ArrayEnd,        vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n             vec![\n                 (ArrayStart,      vec![]),\n-                    (U64Value(3), vec![Index(0)]),\n-                    (U64Value(2), vec![Index(1)]),\n+                    (U64Value(3), vec![StackElement::Index(0)]),\n+                    (U64Value(2), vec![StackElement::Index(1)]),\n                 (ArrayEnd,        vec![]),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n             vec![\n                 (ArrayStart,           vec![]),\n-                    (U64Value(2),      vec![Index(0)]),\n-                    (ArrayStart,       vec![Index(1)]),\n-                        (U64Value(4),  vec![Index(1), Index(0)]),\n-                        (U64Value(1),  vec![Index(1), Index(1)]),\n-                    (ArrayEnd,         vec![Index(1)]),\n+                    (U64Value(2),      vec![StackElement::Index(0)]),\n+                    (ArrayStart,       vec![StackElement::Index(1)]),\n+                        (U64Value(4),  vec![StackElement::Index(1), StackElement::Index(0)]),\n+                        (U64Value(1),  vec![StackElement::Index(1), StackElement::Index(1)]),\n+                    (ArrayEnd,         vec![StackElement::Index(1)]),\n                 (ArrayEnd,             vec![]),\n             ]\n         );\n@@ -3695,50 +3695,50 @@ mod tests {\n         stack.bump_index();\n \n         assert!(stack.len() == 1);\n-        assert!(stack.is_equal_to(&[Index(1)]));\n-        assert!(stack.starts_with(&[Index(1)]));\n-        assert!(stack.ends_with(&[Index(1)]));\n+        assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n+        assert!(stack.starts_with(&[StackElement::Index(1)]));\n+        assert!(stack.ends_with(&[StackElement::Index(1)]));\n         assert!(stack.last_is_index());\n-        assert!(stack.get(0) == Index(1));\n+        assert!(stack.get(0) == StackElement::Index(1));\n \n         stack.push_key(\"foo\".to_string());\n \n         assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with(&[Index(1)]));\n-        assert!(stack.ends_with(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.ends_with(&[Key(\"foo\")]));\n+        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1)]));\n+        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n         assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == Index(1));\n-        assert!(stack.get(1) == Key(\"foo\"));\n+        assert!(stack.get(0) == StackElement::Index(1));\n+        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n \n         stack.push_key(\"bar\".to_string());\n \n         assert!(stack.len() == 3);\n-        assert!(stack.is_equal_to(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n-        assert!(stack.starts_with(&[Index(1)]));\n-        assert!(stack.starts_with(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n-        assert!(stack.ends_with(&[Key(\"bar\")]));\n-        assert!(stack.ends_with(&[Key(\"foo\"), Key(\"bar\")]));\n-        assert!(stack.ends_with(&[Index(1), Key(\"foo\"), Key(\"bar\")]));\n+        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1)]));\n+        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+        assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n+        assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n         assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == Index(1));\n-        assert!(stack.get(1) == Key(\"foo\"));\n-        assert!(stack.get(2) == Key(\"bar\"));\n+        assert!(stack.get(0) == StackElement::Index(1));\n+        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+        assert!(stack.get(2) == StackElement::Key(\"bar\"));\n \n         stack.pop();\n \n         assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.starts_with(&[Index(1)]));\n-        assert!(stack.ends_with(&[Index(1), Key(\"foo\")]));\n-        assert!(stack.ends_with(&[Key(\"foo\")]));\n+        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.starts_with(&[StackElement::Index(1)]));\n+        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+        assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n         assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == Index(1));\n-        assert!(stack.get(1) == Key(\"foo\"));\n+        assert!(stack.get(0) == StackElement::Index(1));\n+        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n     }\n \n     #[test]"}, {"sha": "edaee31462c7fa2c9c38c12732c63340e7331590", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -326,7 +326,7 @@ impl Encodable for str {\n \n impl Encodable for String {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self[])\n+        s.emit_str(self.index(&FullRange))\n     }\n }\n "}, {"sha": "50538d3e43def43f5df8407a74cc061acd563bd8", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -37,7 +37,7 @@ pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {\n-            Some(s) => s[],\n+            Some(s) => s.index(&FullRange),\n             None => \"Box<Any>\",\n         }\n     };"}, {"sha": "11d48dff32aedfe4e5638189a57fb99dacab114b", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -15,7 +15,7 @@\n use cmp;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::{IteratorExt, ExactSizeIterator};\n-use ops::Drop;\n+use ops::{Drop, Index};\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n@@ -100,7 +100,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n             self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n-        Ok(self.buf[self.pos..self.cap])\n+        Ok(self.buf.index(&(self.pos..self.cap)))\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -117,7 +117,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available[..nread]);\n+            slice::bytes::copy_memory(buf, available.index(&(0..nread)));\n             nread\n         };\n         self.pos += nread;\n@@ -171,7 +171,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf[..self.pos]);\n+            let ret = self.inner.as_mut().unwrap().write(self.buf.index(&(0..self.pos)));\n             self.pos = 0;\n             ret\n         } else {\n@@ -263,9 +263,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf[..i + 1]));\n+                try!(self.inner.write(buf.index(&(0..(i + 1)))));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf[i + 1..]));\n+                try!(self.inner.write(buf.index(&((i + 1)..))));\n                 Ok(())\n             }\n             None => self.inner.write(buf),\n@@ -517,7 +517,7 @@ mod test {\n         assert_eq!(a, w.get_ref()[]);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n-        assert_eq!(a, w[]);\n+        assert_eq!(a, w.index(&FullRange));\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -614,14 +614,14 @@ mod test {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufferedReader::with_capacity(1, buf[]);\n+        let mut reader = BufferedReader::with_capacity(1, buf.index(&FullRange));\n         assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, buf[]);\n+        let mut reader = BufferedReader::with_capacity(1, buf.index(&FullRange));\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "bcd0c09b77d616c2bb6f69b1b38ba1eee637d6b6", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -13,6 +13,7 @@ use cmp;\n use sync::mpsc::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n+use ops::Index;\n use result::Result::{Ok, Err};\n use slice::{bytes, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n@@ -90,7 +91,7 @@ impl Reader for ChanReader {\n                 Some(src) => {\n                     let dst = buf.slice_from_mut(num_read);\n                     let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(dst, src[..count]);\n+                    bytes::copy_memory(dst, src.index(&(0..count)));\n                     count\n                 },\n                 None => 0,"}, {"sha": "0fffb2fafbe6c4a4410884828fad59f16690b4f1", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -889,7 +889,7 @@ mod test {\n             let mut read_buf = [0; 1028];\n             let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 -1|0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf[..n]).unwrap().to_string()\n+                n => str::from_utf8(read_buf.index(&(0..n))).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }"}, {"sha": "2c2824cbb3bc1a1bc13c31627bacd1559e988485", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -13,6 +13,7 @@\n //! Readers and Writers for in-memory buffers\n \n use cmp::min;\n+use prelude::Index;\n use option::Option::None;\n use result::Result::{Err, Ok};\n use io;\n@@ -159,7 +160,7 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf[self.pos.. self.pos + write_len];\n+            let input = self.buf.index(&(self.pos.. (self.pos + write_len)));\n             let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n@@ -187,7 +188,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf[self.pos..])\n+            Ok(self.buf.index(&(self.pos..)))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -204,7 +205,7 @@ impl<'a> Reader for &'a [u8] {\n \n         let write_len = min(buf.len(), self.len());\n         {\n-            let input = self[..write_len];\n+            let input = self.index(&(0..write_len));\n             let output = buf.slice_to_mut(write_len);\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -227,7 +228,7 @@ impl<'a> Buffer for &'a [u8] {\n \n     #[inline]\n     fn consume(&mut self, amt: uint) {\n-        *self = self[amt..];\n+        *self = self.index(&(amt..));\n     }\n }\n \n@@ -286,7 +287,7 @@ impl<'a> Writer for BufWriter<'a> {\n \n             Ok(())\n         } else {\n-            slice::bytes::copy_memory(dst, src[..dst_len]);\n+            slice::bytes::copy_memory(dst, src.index(&(0..dst_len)));\n \n             self.pos += dst_len;\n \n@@ -349,7 +350,7 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf[self.pos.. self.pos + write_len];\n+            let input = self.buf.index(&(self.pos.. (self.pos + write_len)));\n             let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n@@ -377,7 +378,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf[self.pos..])\n+            Ok(self.buf.index(&(self.pos..)))\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -498,7 +499,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.index(&(0..3)), b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -524,7 +525,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.index(&(0..3)), b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = &mut in_buf.as_slice();\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -551,7 +552,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf[0..3], b);\n+        assert_eq!(buf.index(&(0..3)), b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));"}, {"sha": "465c4f9c5c7d25e1b02be8fb537d826437c7c070", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -234,7 +234,7 @@ use int;\n use iter::{Iterator, IteratorExt};\n use kinds::Sized;\n use mem::transmute;\n-use ops::FnOnce;\n+use ops::{FnOnce, Index};\n use option::Option;\n use option::Option::{Some, None};\n use os;\n@@ -1068,7 +1068,7 @@ pub trait Writer {\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n         let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(buf[..n])\n+        self.write(buf.index(&(0..n)))\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1453,7 +1453,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available[..i + 1]);\n+                        res.push_all(available.index(&(0..(i + 1))));\n                         used = i + 1;\n                         break\n                     }\n@@ -1492,7 +1492,7 @@ pub trait Buffer: Reader {\n                 }\n             }\n         }\n-        match str::from_utf8(buf[..width]).ok() {\n+        match str::from_utf8(buf.index(&(0..width))).ok() {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }"}, {"sha": "6cb2463fcbca51233ca62662140489ef666f6d11", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -22,7 +22,7 @@ use fmt;\n use io::{self, IoResult, IoError};\n use io::net;\n use iter::{Iterator, IteratorExt};\n-use ops::{FnOnce, FnMut};\n+use ops::{FnOnce, FnMut, Index};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n@@ -313,7 +313,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16; 8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head[..head_size], tail[..tail_size]))\n+        Some(ipv6_addr_from_head_tail(head.index(&(0..head_size)), tail.index(&(0..tail_size))))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "c0254a3e7a205a01382c9e9c649f79822348de10", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt[..cmp::min(amt.len(), self.limit)];\n+        let buf = amt.index(&(0..cmp::min(amt.len(), self.limit)));\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -220,7 +220,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf[mut ..len]).map(|()| len)\n+            self.writer.write(buf.index_mut(&(0..len))).map(|()| len)\n         })\n     }\n }\n@@ -234,7 +234,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf[..len]));\n+        try!(w.write(buf.index(&(0..len))));\n     }\n }\n "}, {"sha": "021aae5a6011a9072ed11e507f6d46aedb9788b4", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -68,6 +68,7 @@ use fmt;\n use iter::IteratorExt;\n use option::Option;\n use option::Option::{None, Some};\n+use prelude::{FullRange, Index};\n use str;\n use str::StrExt;\n use string::{String, CowString};\n@@ -351,7 +352,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n                     Some(1) if name == b\"..\" => name,\n-                    Some(pos) => name[..pos]\n+                    Some(pos) => name.index(&(0..pos))\n                 }\n             })\n         }\n@@ -398,7 +399,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(name[pos+1..])\n+                    Some(pos) => Some(name.index(&((pos+1)..)))\n                 }\n             }\n         }\n@@ -474,7 +475,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n             let extlen = extension.container_as_bytes().len();\n             match (name.rposition_elem(&dot), extlen) {\n                 (None, 0) | (Some(0), 0) => None,\n-                (Some(idx), 0) => Some(name[..idx].to_vec()),\n+                (Some(idx), 0) => Some(name.index(&(0..idx)).to_vec()),\n                 (idx, extlen) => {\n                     let idx = match idx {\n                         None | Some(0) => name.len(),\n@@ -483,7 +484,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n \n                     let mut v;\n                     v = Vec::with_capacity(idx + extlen + 1);\n-                    v.push_all(name[..idx]);\n+                    v.push_all(name.index(&(0..idx)));\n                     v.push(dot);\n                     v.push_all(extension.container_as_bytes());\n                     Some(v)\n@@ -869,7 +870,7 @@ impl BytesContainer for String {\n     }\n     #[inline]\n     fn container_as_str(&self) -> Option<&str> {\n-        Some(self[])\n+        Some(self.index(&FullRange))\n     }\n     #[inline]\n     fn is_str(_: Option<&String>) -> bool { true }\n@@ -885,7 +886,7 @@ impl BytesContainer for [u8] {\n impl BytesContainer for Vec<u8> {\n     #[inline]\n     fn container_as_bytes(&self) -> &[u8] {\n-        self[]\n+        self.index(&FullRange)\n     }\n }\n "}, {"sha": "7f37d3b23c8f06b2137917610db6c7e0f16e45a6", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -16,6 +16,7 @@ use hash;\n use io::Writer;\n use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map};\n+use prelude::v1::Index;\n use kinds::Sized;\n use option::Option::{self, Some, None};\n use slice::{AsSlice, Split, SliceExt, SliceConcatExt};\n@@ -119,7 +120,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => {\n+            Some(idx) if self.repr.index(&((idx+1)..)) == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -129,7 +130,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(self.repr[..idx+1]);\n+                v.push_all(self.repr.index(&(0..(idx+1))));\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -170,9 +171,9 @@ impl GenericPath for Path {\n         match self.sepidx {\n             None if b\"..\" == self.repr => self.repr.as_slice(),\n             None => dot_static,\n-            Some(0) => self.repr[..1],\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n-            Some(idx) => self.repr[..idx]\n+            Some(0) => self.repr.index(&(0..1)),\n+            Some(idx) if self.repr.index(&((idx+1)..)) == b\"..\" => self.repr.as_slice(),\n+            Some(idx) => self.repr.index(&(0..idx))\n         }\n     }\n \n@@ -181,9 +182,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr ||\n                 b\"..\" == self.repr => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr[idx+1..] == b\"..\" => None,\n-            Some(0) if self.repr[1..].is_empty() => None,\n-            Some(idx) => Some(self.repr[idx+1..])\n+            Some(idx) if self.repr.index(&((idx+1)..)) == b\"..\" => None,\n+            Some(0) if self.repr.index(&(1..)).is_empty() => None,\n+            Some(idx) => Some(self.repr.index(&((idx+1)..)))\n         }\n     }\n \n@@ -325,7 +326,7 @@ impl Path {\n         // borrowck is being very picky\n         let val = {\n             let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == SEP_BYTE;\n-            let v_ = if is_abs { v.as_slice()[1..] } else { v.as_slice() };\n+            let v_ = if is_abs { v.as_slice().index(&(1..)) } else { v.as_slice() };\n             let comps = normalize_helper(v_, is_abs);\n             match comps {\n                 None => None,\n@@ -364,7 +365,7 @@ impl Path {\n     /// A path of \"/\" yields no components. A path of \".\" yields one component.\n     pub fn components<'a>(&'a self) -> Components<'a> {\n         let v = if self.repr[0] == SEP_BYTE {\n-            self.repr[1..]\n+            self.repr.index(&(1..))\n         } else { self.repr.as_slice() };\n         let is_sep_byte: fn(&u8) -> bool = is_sep_byte; // coerce to fn ptr\n         let mut ret = v.split(is_sep_byte);"}, {"sha": "d469bb4d767ad91417126213cd90d6a76b635191", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 62, "deletions": 61, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -24,6 +24,7 @@ use iter::{AdditiveIterator, Extend};\n use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option::{self, Some, None};\n+use prelude::{FullRange, Index};\n use slice::{SliceExt, SliceConcatExt};\n use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n@@ -165,30 +166,30 @@ impl GenericPathUnsafe for Path {\n                 s.push_str(\"..\");\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s[]);\n+                self.update_normalized(s.index(&FullRange));\n             }\n             None => {\n                 self.update_normalized(filename);\n             }\n-            Some((_,idxa,end)) if self.repr[idxa..end] == \"..\" => {\n+            Some((_,idxa,end)) if self.repr.index(&(idxa..end)) == \"..\" => {\n                 let mut s = String::with_capacity(end + 1 + filename.len());\n-                s.push_str(self.repr[0..end]);\n+                s.push_str(self.repr.index(&(0..end)));\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s[]);\n+                self.update_normalized(s.index(&FullRange));\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n                 let mut s = String::with_capacity(idxb + filename.len());\n-                s.push_str(self.repr[0..idxb]);\n+                s.push_str(self.repr.index(&(0..idxb)));\n                 s.push_str(filename);\n-                self.update_normalized(s[]);\n+                self.update_normalized(s.index(&FullRange));\n             }\n             Some((idxb,_,_)) => {\n                 let mut s = String::with_capacity(idxb + 1 + filename.len());\n-                s.push_str(self.repr[0..idxb]);\n+                s.push_str(self.repr.index(&(0..idxb)));\n                 s.push(SEP);\n                 s.push_str(filename);\n-                self.update_normalized(s[]);\n+                self.update_normalized(s.index(&FullRange));\n             }\n         }\n     }\n@@ -207,12 +208,12 @@ impl GenericPathUnsafe for Path {\n         let path = path.container_as_str().unwrap();\n         fn is_vol_abs(path: &str, prefix: Option<PathPrefix>) -> bool {\n             // assume prefix is Some(DiskPrefix)\n-            let rest = path[prefix_len(prefix)..];\n+            let rest = path.index(&(prefix_len(prefix)..));\n             !rest.is_empty() && rest.as_bytes()[0].is_ascii() && is_sep(rest.as_bytes()[0] as char)\n         }\n         fn shares_volume(me: &Path, path: &str) -> bool {\n             // path is assumed to have a prefix of Some(DiskPrefix)\n-            let repr = me.repr[];\n+            let repr = me.repr.index(&FullRange);\n             match me.prefix {\n                 Some(DiskPrefix) => {\n                     repr.as_bytes()[0] == path.as_bytes()[0].to_ascii_uppercase()\n@@ -244,7 +245,7 @@ impl GenericPathUnsafe for Path {\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n             let mut s = String::with_capacity(me.repr.len() + 1 + pathlen);\n-            s.push_str(me.repr[]);\n+            s.push_str(me.repr.index(&FullRange));\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n             match me.prefix {\n@@ -256,17 +257,17 @@ impl GenericPathUnsafe for Path {\n             }\n             match path_ {\n                 None => s.push_str(path),\n-                Some(p) => s.push_str(p[]),\n+                Some(p) => s.push_str(p.index(&FullRange)),\n             };\n-            me.update_normalized(s[])\n+            me.update_normalized(s.index(&FullRange))\n         }\n \n         if !path.is_empty() {\n             let prefix = parse_prefix(path);\n             match prefix {\n                 Some(DiskPrefix) if !is_vol_abs(path, prefix) && shares_volume(self, path) => {\n                     // cwd-relative path, self is on the same volume\n-                    append_path(self, path[prefix_len(prefix)..]);\n+                    append_path(self, path.index(&(prefix_len(prefix)..)));\n                 }\n                 Some(_) => {\n                     // absolute path, or cwd-relative and self is not same volume\n@@ -312,7 +313,7 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     #[inline]\n     fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        Some(self.repr[])\n+        Some(self.repr.index(&FullRange))\n     }\n \n     #[inline]\n@@ -334,17 +335,17 @@ impl GenericPath for Path {\n     /// Always returns a `Some` value.\n     fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n         Some(match self.sepidx_or_prefix_len() {\n-            None if \"..\" == self.repr => self.repr[],\n+            None if \"..\" == self.repr => self.repr.index(&FullRange),\n             None => \".\",\n-            Some((_,idxa,end)) if self.repr[idxa..end] == \"..\" => self.repr[],\n-            Some((idxb,_,end)) if self.repr[idxb..end] == \"\\\\\" => self.repr[],\n-            Some((0,idxa,_)) => self.repr[0..idxa],\n+            Some((_,idxa,end)) if self.repr.index(&(idxa..end)) == \"..\" => self.repr.index(&FullRange),\n+            Some((idxb,_,end)) if self.repr.index(&(idxb..end)) == \"\\\\\" => self.repr.index(&FullRange),\n+            Some((0,idxa,_)) => self.repr.index(&(0..idxa)),\n             Some((idxb,idxa,_)) => {\n                 match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) if idxb == self.prefix_len() => {\n-                        self.repr[0..idxa]\n+                        self.repr.index(&(0..idxa))\n                     }\n-                    _ => self.repr[0..idxb]\n+                    _ => self.repr.index(&(0..idxb))\n                 }\n             }\n         })\n@@ -358,13 +359,13 @@ impl GenericPath for Path {\n     /// See `GenericPath::filename_str` for info.\n     /// Always returns a `Some` value if `filename` returns a `Some` value.\n     fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        let repr = self.repr[];\n+        let repr = self.repr.index(&FullRange);\n         match self.sepidx_or_prefix_len() {\n             None if \".\" == repr || \"..\" == repr => None,\n             None => Some(repr),\n-            Some((_,idxa,end)) if repr[idxa..end] == \"..\" => None,\n+            Some((_,idxa,end)) if repr.index(&(idxa..end)) == \"..\" => None,\n             Some((_,idxa,end)) if idxa == end => None,\n-            Some((_,idxa,end)) => Some(repr[idxa..end])\n+            Some((_,idxa,end)) => Some(repr.index(&(idxa..end)))\n         }\n     }\n \n@@ -396,7 +397,7 @@ impl GenericPath for Path {\n                 true\n             }\n             Some((idxb,idxa,end)) if idxb == idxa && idxb == end => false,\n-            Some((idxb,_,end)) if self.repr[idxb..end] == \"\\\\\" => false,\n+            Some((idxb,_,end)) if self.repr.index(&(idxb..end)) == \"\\\\\" => false,\n             Some((idxb,idxa,_)) => {\n                 let trunc = match self.prefix {\n                     Some(DiskPrefix) | Some(VerbatimDiskPrefix) | None => {\n@@ -416,15 +417,15 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    self.repr[0..self.prefix_len()+1]\n+                    self.repr.index(&(0..(self.prefix_len()+1)))\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    self.repr[0..self.prefix_len()+1]\n+                    self.repr.index(&(0..(self.prefix_len()+1)))\n                 }\n-                _ => self.repr[0..self.prefix_len()]\n+                _ => self.repr.index(&(0..self.prefix_len()))\n             }))\n         } else if is_vol_relative(self) {\n-            Some(Path::new(self.repr[0..1]))\n+            Some(Path::new(self.repr.index(&(0..1))))\n         } else {\n             None\n         }\n@@ -443,7 +444,7 @@ impl GenericPath for Path {\n     fn is_absolute(&self) -> bool {\n         match self.prefix {\n             Some(DiskPrefix) => {\n-                let rest = self.repr[self.prefix_len()..];\n+                let rest = self.repr.index(&(self.prefix_len()..));\n                 rest.len() > 0 && rest.as_bytes()[0] == SEP_BYTE\n             }\n             Some(_) => true,\n@@ -618,15 +619,15 @@ impl Path {\n     /// Does not distinguish between absolute and cwd-relative paths, e.g.\n     /// C:\\foo and C:foo.\n     pub fn str_components<'a>(&'a self) -> StrComponents<'a> {\n-        let repr = self.repr[];\n+        let repr = self.repr.index(&FullRange);\n         let s = match self.prefix {\n             Some(_) => {\n                 let plen = self.prefix_len();\n                 if repr.len() > plen && repr.as_bytes()[plen] == SEP_BYTE {\n-                    repr[plen+1..]\n-                } else { repr[plen..] }\n+                    repr.index(&((plen+1)..))\n+                } else { repr.index(&(plen..)) }\n             }\n-            None if repr.as_bytes()[0] == SEP_BYTE => repr[1..],\n+            None if repr.as_bytes()[0] == SEP_BYTE => repr.index(&(1..)),\n             None => repr\n         };\n         let some: fn(&'a str) -> Option<&'a str> = Some; // coerce to fn ptr\n@@ -646,8 +647,8 @@ impl Path {\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {\n-        let s_repr = self.repr[];\n-        let o_repr = other.repr[];\n+        let s_repr = self.repr.index(&FullRange);\n+        let o_repr = other.repr.index(&FullRange);\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n@@ -664,14 +665,14 @@ impl Path {\n                     o_repr.as_bytes()[4].to_ascii_lowercase()\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n-                s_repr[2..self.prefix_len()] == o_repr[8..other.prefix_len()]\n+                s_repr.index(&(2..self.prefix_len())) == o_repr.index(&(8..other.prefix_len()))\n             }\n             (Some(VerbatimUNCPrefix(_,_)), Some(UNCPrefix(_,_))) => {\n-                s_repr[8..self.prefix_len()] == o_repr[2..other.prefix_len()]\n+                s_repr.index(&(8..self.prefix_len())) == o_repr.index(&(2..other.prefix_len()))\n             }\n             (None, None) => true,\n             (a, b) if a == b => {\n-                s_repr[0..self.prefix_len()] == o_repr[0..other.prefix_len()]\n+                s_repr.index(&(0..self.prefix_len())) == o_repr.index(&(0..other.prefix_len()))\n             }\n             _ => false\n         }\n@@ -725,7 +726,7 @@ impl Path {\n                         match prefix.unwrap() {\n                             DiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(s[0..len]);\n+                                let mut s = String::from_str(s.index(&(0..len)));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[0] = (*v)[0].to_ascii_uppercase();\n@@ -740,7 +741,7 @@ impl Path {\n                             }\n                             VerbatimDiskPrefix => {\n                                 let len = prefix_len(prefix) + is_abs as uint;\n-                                let mut s = String::from_str(s[0..len]);\n+                                let mut s = String::from_str(s.index(&(0..len)));\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n                                     v[4] = (*v)[4].to_ascii_uppercase();\n@@ -750,14 +751,14 @@ impl Path {\n                             _ => {\n                                 let plen = prefix_len(prefix);\n                                 if s.len() > plen {\n-                                    Some(String::from_str(s[0..plen]))\n+                                    Some(String::from_str(s.index(&(0..plen))))\n                                 } else { None }\n                             }\n                         }\n                     } else if is_abs && comps.is_empty() {\n                         Some(repeat(SEP).take(1).collect())\n                     } else {\n-                        let prefix_ = s[0..prefix_len(prefix)];\n+                        let prefix_ = s.index(&(0..prefix_len(prefix)));\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n@@ -768,15 +769,15 @@ impl Path {\n                                 s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n-                                s.push_str(prefix_[0..4]);\n+                                s.push_str(prefix_.index(&(0..4)));\n                                 s.push(prefix_.as_bytes()[4].to_ascii_uppercase() as char);\n-                                s.push_str(prefix_[5..]);\n+                                s.push_str(prefix_.index(&(5..)));\n                             }\n                             Some(UNCPrefix(a,b)) => {\n                                 s.push_str(\"\\\\\\\\\");\n-                                s.push_str(prefix_[2..a+2]);\n+                                s.push_str(prefix_.index(&(2..(a+2))));\n                                 s.push(SEP);\n-                                s.push_str(prefix_[3+a..3+a+b]);\n+                                s.push_str(prefix_.index(&((3+a)..(3+a+b))));\n                             }\n                             Some(_) => s.push_str(prefix_),\n                             None => ()\n@@ -801,8 +802,8 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    self.repr[0..self.repr.len()-1]\n-                } else { self.repr[] };\n+                    self.repr.index(&(0..(self.repr.len()-1)))\n+                } else { self.repr.index(&FullRange) };\n         let sep_test: fn(char) -> bool = if !prefix_is_verbatim(self.prefix) {\n             is_sep\n         } else {\n@@ -881,17 +882,17 @@ pub fn is_verbatim(path: &Path) -> bool {\n /// non-verbatim, the non-verbatim version is returned.\n /// Otherwise, None is returned.\n pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n-    let repr = path.repr[];\n+    let repr = path.repr.index(&FullRange);\n     let new_path = match path.prefix {\n         Some(VerbatimPrefix(_)) | Some(DeviceNSPrefix(_)) => return None,\n         Some(UNCPrefix(_,_)) | Some(DiskPrefix) | None => return Some(path.clone()),\n         Some(VerbatimDiskPrefix) => {\n             // \\\\?\\D:\\\n-            Path::new(repr[4..])\n+            Path::new(repr.index(&(4..)))\n         }\n         Some(VerbatimUNCPrefix(_,_)) => {\n             // \\\\?\\UNC\\server\\share\n-            Path::new(format!(r\"\\{}\", repr[7..]))\n+            Path::new(format!(r\"\\{}\", repr.index(&(7..))))\n         }\n     };\n     if new_path.prefix.is_none() {\n@@ -900,8 +901,8 @@ pub fn make_non_verbatim(path: &Path) -> Option<Path> {\n         return None;\n     }\n     // now ensure normalization didn't change anything\n-    if repr[path.prefix_len()..] ==\n-        new_path.repr[new_path.prefix_len()..] {\n+    if repr.index(&(path.prefix_len()..)) ==\n+        new_path.repr.index(&(new_path.prefix_len()..)) {\n         Some(new_path)\n     } else {\n         None\n@@ -966,13 +967,13 @@ pub enum PathPrefix {\n fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n     if path.starts_with(\"\\\\\\\\\") {\n         // \\\\\n-        path = path[2..];\n+        path = path.index(&(2..));\n         if path.starts_with(\"?\\\\\") {\n             // \\\\?\\\n-            path = path[2..];\n+            path = path.index(&(2..));\n             if path.starts_with(\"UNC\\\\\") {\n                 // \\\\?\\UNC\\server\\share\n-                path = path[4..];\n+                path = path.index(&(4..));\n                 let (idx_a, idx_b) = match parse_two_comps(path, is_sep_verbatim) {\n                     Some(x) => x,\n                     None => (path.len(), 0)\n@@ -993,7 +994,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             }\n         } else if path.starts_with(\".\\\\\") {\n             // \\\\.\\path\n-            path = path[2..];\n+            path = path.index(&(2..));\n             let idx = path.find('\\\\').unwrap_or(path.len());\n             return Some(DeviceNSPrefix(idx));\n         }\n@@ -1018,7 +1019,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             None => return None,\n             Some(x) => x\n         };\n-        path = path[idx_a+1..];\n+        path = path.index(&((idx_a+1)..));\n         let idx_b = path.find(f).unwrap_or(path.len());\n         Some((idx_a, idx_b))\n     }\n@@ -1032,8 +1033,8 @@ fn normalize_helper<'a>(s: &'a str, prefix: Option<PathPrefix>) -> (bool, Option\n         is_sep_verbatim\n     };\n     let is_abs = s.len() > prefix_len(prefix) && f(s.char_at(prefix_len(prefix)));\n-    let s_ = s[prefix_len(prefix)..];\n-    let s_ = if is_abs { s_[1..] } else { s_ };\n+    let s_ = s.index(&(prefix_len(prefix)..));\n+    let s_ = if is_abs { s_.index(&(1..)) } else { s_ };\n \n     if is_abs && s_.is_empty() {\n         return (is_abs, match prefix {"}, {"sha": "fd84f22094282a4a7d203c7d444e623e4f2c3ff8", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -544,7 +544,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n     // MAX_CALLBACKS, so we're sure to clamp it as necessary.\n     let callbacks = {\n         let amt = CALLBACK_CNT.load(Ordering::SeqCst);\n-        CALLBACKS[..cmp::min(amt, MAX_CALLBACKS)]\n+        CALLBACKS.index(&(0..cmp::min(amt, MAX_CALLBACKS)))\n     };\n     for cb in callbacks.iter() {\n         match cb.load(Ordering::SeqCst) {"}, {"sha": "59f654a95caa6e9f2e07fed18c3dc080e604cb5f", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -131,7 +131,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     impl<'a> fmt::Writer for BufWriter<'a> {\n         fn write_str(&mut self, bytes: &str) -> fmt::Result {\n             let left = self.buf.slice_from_mut(self.pos);\n-            let to_write = bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n+            let to_write = bytes.as_bytes().index(&(0..cmp::min(bytes.len(), left.len())));\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();\n             Ok(())\n@@ -142,7 +142,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     let mut msg = [0u8; 512];\n     let mut w = BufWriter { buf: &mut msg, pos: 0 };\n     let _ = write!(&mut w, \"{}\", args);\n-    let msg = str::from_utf8(w.buf[mut ..w.pos]).unwrap_or(\"aborted\");\n+    let msg = str::from_utf8(w.buf.index_mut(&(0..w.pos))).unwrap_or(\"aborted\");\n     let msg = if msg.is_empty() {\"aborted\"} else {msg};\n \n     // Give some context to the message"}, {"sha": "b2cc807eb111d51879b19067a357de57ce01b462", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -437,7 +437,8 @@ impl<T> Buffer<T> {\n         let start = self.start;\n         self.size -= 1;\n         self.start = (self.start + 1) % self.buf.len();\n-        self.buf[start].take().unwrap()\n+        let result = &mut self.buf[start];\n+        result.take().unwrap()\n     }\n \n     fn size(&self) -> uint { self.size }"}, {"sha": "902942d7244f7687b248098d00b700c4ab86f0f6", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -469,7 +469,7 @@ pub fn write<T, L, W>(fd: sock_t,\n             // Also as with read(), we use MSG_DONTWAIT to guard ourselves\n             // against unforeseen circumstances.\n             let _guard = lock();\n-            let ptr = buf[written..].as_ptr();\n+            let ptr = buf.index(&(written..)).as_ptr();\n             let len = buf.len() - written;\n             match retry(|| write(deadline.is_some(), ptr, len)) {\n                 -1 if wouldblock() => {}"}, {"sha": "fcde5c01080fd363afa3b2617ad45713315aeeb1", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -36,7 +36,7 @@ const BUF_BYTES : uint = 2048u;\n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n     match v.iter().position(|c| *c == 0) {\n         // don't include the 0\n-        Some(i) => v[..i],\n+        Some(i) => v.index(&(0..i)),\n         None => v\n     }\n }"}, {"sha": "016757ef63e7d9410c6a16e01448e5fdd62e5302", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -453,7 +453,7 @@ impl UnixStream {\n             }\n             let ret = unsafe {\n                 libc::WriteFile(self.handle(),\n-                                buf[offset..].as_ptr() as libc::LPVOID,\n+                                buf.index(&(offset..)).as_ptr() as libc::LPVOID,\n                                 (buf.len() - offset) as libc::DWORD,\n                                 &mut bytes_written,\n                                 &mut overlapped)"}, {"sha": "54e6a338178e42477a4f31a1a3e820bd68b956d0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -199,7 +199,7 @@ impl Encodable for Ident {\n #[cfg(stage0)]\n impl<D: Decoder<E>, E> Decodable<D, E> for Ident {\n     fn decode(d: &mut D) -> Result<Ident, E> {\n-        Ok(str_to_ident(try!(d.read_str())[]))\n+        Ok(str_to_ident(try!(d.read_str()).index(&FullRange)))\n     }\n }\n "}, {"sha": "efd35f73d4534748d66f559ae0328e22345adbc3", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -99,7 +99,7 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n         if !s.is_empty() {\n             s.push_str(\"::\");\n         }\n-        s.push_str(e[]);\n+        s.push_str(e.index(&FullRange));\n         s\n     }).to_string()\n }\n@@ -476,20 +476,20 @@ impl<'ast> Map<'ast> {\n         F: FnOnce(Option<&[Attribute]>) -> T,\n     {\n         let attrs = match self.get(id) {\n-            NodeItem(i) => Some(i.attrs[]),\n-            NodeForeignItem(fi) => Some(fi.attrs[]),\n+            NodeItem(i) => Some(i.attrs.index(&FullRange)),\n+            NodeForeignItem(fi) => Some(fi.attrs.index(&FullRange)),\n             NodeTraitItem(ref tm) => match **tm {\n-                RequiredMethod(ref type_m) => Some(type_m.attrs[]),\n-                ProvidedMethod(ref m) => Some(m.attrs[]),\n-                TypeTraitItem(ref typ) => Some(typ.attrs[]),\n+                RequiredMethod(ref type_m) => Some(type_m.attrs.index(&FullRange)),\n+                ProvidedMethod(ref m) => Some(m.attrs.index(&FullRange)),\n+                TypeTraitItem(ref typ) => Some(typ.attrs.index(&FullRange)),\n             },\n             NodeImplItem(ref ii) => {\n                 match **ii {\n-                    MethodImplItem(ref m) => Some(m.attrs[]),\n-                    TypeImplItem(ref t) => Some(t.attrs[]),\n+                    MethodImplItem(ref m) => Some(m.attrs.index(&FullRange)),\n+                    TypeImplItem(ref t) => Some(t.attrs.index(&FullRange)),\n                 }\n             }\n-            NodeVariant(ref v) => Some(v.node.attrs[]),\n+            NodeVariant(ref v) => Some(v.node.attrs.index(&FullRange)),\n             // unit/tuple structs take the attributes straight from\n             // the struct definition.\n             // FIXME(eddyb) make this work again (requires access to the map).\n@@ -513,7 +513,7 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: parts[..parts.len() - 1],\n+            in_which: parts.index(&(0..(parts.len() - 1))),\n             idx: 0,\n         }\n     }\n@@ -590,7 +590,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n                 None => return false,\n                 Some((node_id, name)) => (node_id, name),\n             };\n-            if part[] != mod_name.as_str() {\n+            if part.index(&FullRange) != mod_name.as_str() {\n                 return false;\n             }\n             cursor = self.map.get_parent(mod_id);\n@@ -628,7 +628,7 @@ impl<'a, 'ast> NodesMatchingSuffix<'a, 'ast> {\n     // We are looking at some node `n` with a given name and parent\n     // id; do their names match what I am seeking?\n     fn matches_names(&self, parent_of_n: NodeId, name: Name) -> bool {\n-        name.as_str() == self.item_name[] &&\n+        name.as_str() == self.item_name.index(&FullRange) &&\n             self.suffix_matches(parent_of_n)\n     }\n }\n@@ -1040,7 +1040,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n \n fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     let id_str = format!(\" (id={})\", id);\n-    let id_str = if include_id { id_str[] } else { \"\" };\n+    let id_str = if include_id { id_str.index(&FullRange) } else { \"\" };\n \n     match map.find(id) {\n         Some(NodeItem(item)) => {"}, {"sha": "aad6f1152065999f019291fb8b566eaf43644f40", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -238,11 +238,11 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push('.');\n-            pretty.push_str(pprust::path_to_string(&trait_ref.path)[]);\n+            pretty.push_str(pprust::path_to_string(&trait_ref.path).index(&FullRange));\n         }\n         None => {}\n     }\n-    token::gensym_ident(pretty[])\n+    token::gensym_ident(pretty.index(&FullRange))\n }\n \n pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n@@ -704,7 +704,7 @@ pub fn pat_is_ident(pat: P<ast::Pat>) -> bool {\n pub fn path_name_eq(a : &ast::Path, b : &ast::Path) -> bool {\n     (a.span == b.span)\n     && (a.global == b.global)\n-    && (segments_name_eq(a.segments[], b.segments[]))\n+    && (segments_name_eq(a.segments.index(&FullRange), b.segments.index(&FullRange)))\n }\n \n // are two arrays of segments equal when compared unhygienically?\n@@ -792,13 +792,13 @@ mod test {\n     #[test] fn idents_name_eq_test() {\n         assert!(segments_name_eq(\n             [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange),\n             [Ident{name:Name(3),ctxt:104}, Ident{name:Name(78),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange)));\n         assert!(!segments_name_eq(\n             [Ident{name:Name(3),ctxt:4}, Ident{name:Name(78),ctxt:82}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[],\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange),\n             [Ident{name:Name(3),ctxt:104}, Ident{name:Name(77),ctxt:182}]\n-                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>()[]));\n+                .iter().map(ident_to_segment).collect::<Vec<PathSegment>>().index(&FullRange)));\n     }\n }"}, {"sha": "97f70d416db6b157131baf4d114af9e66bcf295c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -97,7 +97,7 @@ impl AttrMetaMethods for MetaItem {\n \n     fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n         match self.node {\n-            MetaList(_, ref l) => Some(l[]),\n+            MetaList(_, ref l) => Some(l.index(&FullRange)),\n             _ => None\n         }\n     }\n@@ -136,7 +136,7 @@ impl AttributeMethods for Attribute {\n             let meta = mk_name_value_item_str(\n                 InternedString::new(\"doc\"),\n                 token::intern_and_get_ident(strip_doc_comment_decoration(\n-                        comment.get())[]));\n+                        comment.get()).index(&FullRange)));\n             if self.node.style == ast::AttrOuter {\n                 f(&mk_attr_outer(self.node.id, meta))\n             } else {\n@@ -296,9 +296,9 @@ pub fn find_inline_attr(attrs: &[Attribute]) -> InlineAttr {\n             }\n             MetaList(ref n, ref items) if *n == \"inline\" => {\n                 mark_used(attr);\n-                if contains_name(items[], \"always\") {\n+                if contains_name(items.index(&FullRange), \"always\") {\n                     InlineAlways\n-                } else if contains_name(items[], \"never\") {\n+                } else if contains_name(items.index(&FullRange), \"never\") {\n                     InlineNever\n                 } else {\n                     InlineHint\n@@ -332,7 +332,7 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n             !cfg_matches(diagnostic, cfgs, &*mis[0])\n         }\n         ast::MetaList(ref pred, _) => {\n-            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred)[]);\n+            diagnostic.span_err(cfg.span, format!(\"invalid predicate `{}`\", pred).index(&FullRange));\n             false\n         },\n         ast::MetaWord(_) | ast::MetaNameValue(..) => contains(cfgs, cfg),\n@@ -396,7 +396,7 @@ pub fn require_unique_names(diagnostic: &SpanHandler, metas: &[P<MetaItem>]) {\n \n         if !set.insert(name.clone()) {\n             diagnostic.span_fatal(meta.span,\n-                                  format!(\"duplicate meta item `{}`\", name)[]);\n+                                  format!(\"duplicate meta item `{}`\", name).index(&FullRange));\n         }\n     }\n }"}, {"sha": "6d329fe614c997e86f58409f9e0d5b13f1f85e14", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -321,9 +321,9 @@ impl FileMap {\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n             let begin = begin.to_uint();\n-            let slice = self.src[begin..];\n+            let slice = self.src.index(&(begin..));\n             match slice.find('\\n') {\n-                Some(e) => slice[0..e],\n+                Some(e) => slice.index(&(0..e)),\n                 None => slice\n             }.to_string()\n         })\n@@ -368,9 +368,9 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.starts_with(\"\\u{feff}\") {\n-            String::from_str(src[3..])\n+            String::from_str(src.index(&(3..)))\n         } else {\n-            String::from_str(src[])\n+            String::from_str(src.index(&FullRange))\n         };\n \n         // Append '\\n' in case it's not already there.\n@@ -457,8 +457,8 @@ impl CodeMap {\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some(begin.fm.src[begin.pos.to_uint()..\n-                              end.pos.to_uint()].to_string())\n+            Some(begin.fm.src.index(&(begin.pos.to_uint()..\n+                                      end.pos.to_uint())).to_string())\n         }\n     }\n "}, {"sha": "f43a236341effcfebb9cf390eedf7cadd2685174", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -123,7 +123,7 @@ impl SpanHandler {\n         panic!(ExplicitBug);\n     }\n     pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n-        self.span_bug(sp, format!(\"unimplemented {}\", msg)[]);\n+        self.span_bug(sp, format!(\"unimplemented {}\", msg).index(&FullRange));\n     }\n     pub fn handler<'a>(&'a self) -> &'a Handler {\n         &self.handler\n@@ -166,7 +166,7 @@ impl Handler {\n                         self.err_count.get());\n           }\n         }\n-        self.fatal(s[]);\n+        self.fatal(s.index(&FullRange));\n     }\n     pub fn warn(&self, msg: &str) {\n         self.emit.borrow_mut().emit(None, msg, None, Warning);\n@@ -182,7 +182,7 @@ impl Handler {\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(format!(\"unimplemented {}\", msg)[]);\n+        self.bug(format!(\"unimplemented {}\", msg).index(&FullRange));\n     }\n     pub fn emit(&self,\n                 cmsp: Option<(&codemap::CodeMap, Span)>,\n@@ -277,7 +277,7 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n             // to be miscolored. We assume this is rare enough that we don't\n             // have to worry about it.\n             if msg.ends_with(\"\\n\") {\n-                try!(t.write_str(msg[0..msg.len()-1]));\n+                try!(t.write_str(msg.index(&(0..(msg.len()-1)))));\n                 try!(t.reset());\n                 try!(t.write_str(\"\\n\"));\n             } else {\n@@ -299,16 +299,16 @@ fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n     }\n \n     try!(print_maybe_styled(dst,\n-                            format!(\"{}: \", lvl.to_string())[],\n+                            format!(\"{}: \", lvl.to_string()).index(&FullRange),\n                             term::attr::ForegroundColor(lvl.color())));\n     try!(print_maybe_styled(dst,\n-                            format!(\"{}\", msg)[],\n+                            format!(\"{}\", msg).index(&FullRange),\n                             term::attr::Bold));\n \n     match code {\n         Some(code) => {\n             let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled(dst, format!(\" [{}]\", code.clone())[], style));\n+            try!(print_maybe_styled(dst, format!(\" [{}]\", code.clone()).index(&FullRange), style));\n         }\n         None => ()\n     }\n@@ -398,12 +398,12 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         // the span)\n         let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n         let ses = cm.span_to_string(span_end);\n-        try!(print_diagnostic(dst, ses[], lvl, msg, code));\n+        try!(print_diagnostic(dst, ses.index(&FullRange), lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(custom_highlight_lines(dst, cm, sp, lvl, lines));\n         }\n     } else {\n-        try!(print_diagnostic(dst, ss[], lvl, msg, code));\n+        try!(print_diagnostic(dst, ss.index(&FullRange), lvl, msg, code));\n         if rsp.is_full_span() {\n             try!(highlight_lines(dst, cm, sp, lvl, lines));\n         }\n@@ -413,9 +413,9 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n         Some(code) =>\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                 Some(_) => {\n-                    try!(print_diagnostic(dst, ss[], Help,\n+                    try!(print_diagnostic(dst, ss.index(&FullRange), Help,\n                                           format!(\"pass `--explain {}` to see a detailed \\\n-                                                   explanation\", code)[], None));\n+                                                   explanation\", code).index(&FullRange), None));\n                 }\n                 None => ()\n             },\n@@ -432,9 +432,9 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let fm = &*lines.file;\n \n     let mut elided = false;\n-    let mut display_lines = lines.lines[];\n+    let mut display_lines = lines.lines.index(&FullRange);\n     if display_lines.len() > MAX_LINES {\n-        display_lines = display_lines[0u..MAX_LINES];\n+        display_lines = display_lines.index(&(0u..MAX_LINES));\n         elided = true;\n     }\n     // Print the offending lines\n@@ -494,7 +494,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n             }\n         }\n         try!(print_maybe_styled(err,\n-                                format!(\"{}\\n\", s)[],\n+                                format!(\"{}\\n\", s).index(&FullRange),\n                                 term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n@@ -514,7 +514,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           -> io::IoResult<()> {\n     let fm = &*lines.file;\n \n-    let lines = lines.lines[];\n+    let lines = lines.lines.index(&FullRange);\n     if lines.len() > MAX_LINES {\n         if let Some(line) = fm.get_line(lines[0]) {\n             try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n@@ -545,7 +545,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     s.push('^');\n     s.push('\\n');\n     print_maybe_styled(w,\n-                       s[],\n+                       s.index(&FullRange),\n                        term::attr::ForegroundColor(lvl.color()))\n }\n \n@@ -560,12 +560,12 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                 codemap::MacroAttribute => (\"#[\", \"]\"),\n                 codemap::MacroBang => (\"\", \"!\")\n             };\n-            try!(print_diagnostic(w, ss[], Note,\n+            try!(print_diagnostic(w, ss.index(&FullRange), Note,\n                                   format!(\"in expansion of {}{}{}\", pre,\n                                           ei.callee.name,\n-                                          post)[], None));\n+                                          post).index(&FullRange), None));\n             let ss = cm.span_to_string(ei.call_site);\n-            try!(print_diagnostic(w, ss[], Note, \"expansion site\", None));\n+            try!(print_diagnostic(w, ss.index(&FullRange), Note, \"expansion site\", None));\n             Ok(Some(ei.call_site))\n         }\n         None => Ok(None)\n@@ -578,6 +578,6 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n {\n     match opt {\n         Some(t) => t,\n-        None => diag.handler().bug(msg()[]),\n+        None => diag.handler().bug(msg().index(&FullRange)),\n     }\n }"}, {"sha": "0f4ebd74b66c72c38ec0f8f62a1cf887d71aec8c", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -58,7 +58,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n             Some(previous_span) => {\n                 ecx.span_warn(span, format!(\n                     \"diagnostic code {} already used\", token::get_ident(code).get()\n-                )[]);\n+                ).index(&FullRange));\n                 ecx.span_note(previous_span, \"previous invocation\");\n             },\n             None => ()\n@@ -87,12 +87,12 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, format!(\n                 \"diagnostic code {} already registered\", token::get_ident(*code).get()\n-            )[]);\n+            ).index(&FullRange));\n         }\n     });\n     let sym = Ident::new(token::gensym((\n         \"__register_diagnostic_\".to_string() + token::get_ident(*code).get()\n-    )[]));\n+    ).index(&FullRange)));\n     MacItems::new(vec![quote_item!(ecx, mod $sym {}).unwrap()].into_iter())\n }\n "}, {"sha": "04dec0e8028417a376b62e37dabb4c864f683b5d", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -100,7 +100,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(format!(\n-                                        \"={}\", operand)[]))\n+                                        \"={}\", operand).index(&FullRange)))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");"}, {"sha": "52e402689ba770aea8fcd2f443f88751b4386f5a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -539,7 +539,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n-        v.push(token::str_to_ident(self.ecfg.crate_name[]));\n+        v.push(token::str_to_ident(self.ecfg.crate_name.index(&FullRange)));\n         v.extend(self.mod_path.iter().map(|a| *a));\n         return v;\n     }\n@@ -548,7 +548,7 @@ impl<'a> ExtCtxt<'a> {\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name)[]);\n+                                    ei.callee.name).index(&FullRange));\n         }\n \n         let mut call_site = ei.call_site;\n@@ -670,7 +670,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_err(sp, format!(\"{} takes no arguments\", name)[]);\n+        cx.span_err(sp, format!(\"{} takes no arguments\", name).index(&FullRange));\n     }\n }\n \n@@ -683,12 +683,12 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                -> Option<String> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, format!(\"{} takes 1 argument\", name)[]);\n+        cx.span_err(sp, format!(\"{} takes 1 argument\", name).index(&FullRange));\n         return None\n     }\n     let ret = cx.expander().fold_expr(p.parse_expr());\n     if p.token != token::Eof {\n-        cx.span_err(sp, format!(\"{} takes 1 argument\", name)[]);\n+        cx.span_err(sp, format!(\"{} takes 1 argument\", name).index(&FullRange));\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n         s.get().to_string()"}, {"sha": "e3561e86070844372f4e8368982037b60fc7af2c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -709,7 +709,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n                                       token::intern_and_get_ident(loc.file\n-                                                                  .name[]));\n+                                                                  .name.index(&FullRange)));\n         let expr_line = self.expr_uint(span, loc.line);\n         let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);"}, {"sha": "1f1781dceb30b2eb9b233659b26b86605e686a1a", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -40,14 +40,14 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                        accumulator.push_str(format!(\"{}\", i)[]);\n+                        accumulator.push_str(format!(\"{}\", i).index(&FullRange));\n                     }\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Minus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                        accumulator.push_str(format!(\"-{}\", i)[]);\n+                        accumulator.push_str(format!(\"-{}\", i).index(&FullRange));\n                     }\n                     ast::LitBool(b) => {\n-                        accumulator.push_str(format!(\"{}\", b)[]);\n+                        accumulator.push_str(format!(\"{}\", b).index(&FullRange));\n                     }\n                     ast::LitByte(..) |\n                     ast::LitBinary(..) => {\n@@ -62,5 +62,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n     }\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(accumulator[])))\n+            token::intern_and_get_ident(accumulator.index(&FullRange))))\n }"}, {"sha": "02f702248cb6676d7b8dfcfbf9739dec5aa6ef64", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -40,7 +40,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree]\n             }\n         }\n     }\n-    let res = str_to_ident(res_str[]);\n+    let res = str_to_ident(res_str.index(&FullRange));\n \n     let e = P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "2189f7d83d820a34ccbbfe9e3ea95ada63212add", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -29,12 +29,12 @@ pub fn expand_deriving_bound<F>(cx: &mut ExtCtxt,\n                 \"Send\" | \"Sync\" => {\n                     return cx.span_err(span,\n                                        format!(\"{} is an unsafe trait and it \\\n-                                               should be implemented explicitly\", *tname)[])\n+                                               should be implemented explicitly\", *tname).index(&FullRange))\n                 }\n                 ref tname => {\n                     cx.span_bug(span,\n                                 format!(\"expected built-in trait name but \\\n-                                         found {}\", *tname)[])\n+                                         found {}\", *tname).index(&FullRange))\n                 }\n             }\n         },"}, {"sha": "d9d6cebd05c90d6f4bfaaee5b5e566a2b6e6add6", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -80,11 +80,11 @@ fn cs_clone(\n         EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         format!(\"non-matching enum variants in \\\n-                                 `deriving({})`\", name)[])\n+                                 `deriving({})`\", name).index(&FullRange))\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span,\n-                        format!(\"static method in `deriving({})`\", name)[])\n+                        format!(\"static method in `deriving({})`\", name).index(&FullRange))\n         }\n     }\n \n@@ -101,7 +101,7 @@ fn cs_clone(\n                 None => {\n                     cx.span_bug(trait_span,\n                                 format!(\"unnamed field in normal struct in \\\n-                                         `deriving({})`\", name)[])\n+                                         `deriving({})`\", name).index(&FullRange))\n                 }\n             };\n             cx.field_imm(field.span, ident, subcall(field))"}, {"sha": "a9289f0175a6961aa1ee4d4dc0978b16c4a24f38", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -198,7 +198,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(cx, span,\n                            token::intern_and_get_ident(format!(\"_field{}\",\n-                                                               i)[]),\n+                                                               i).index(&FullRange)),\n                            i)\n                 }).collect();\n "}, {"sha": "7114217d51d0ac602b565e62cf5e7642bcfc4dd9", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -183,7 +183,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let name = match name {\n                     Some(id) => token::get_ident(id),\n                     None => {\n-                        token::intern_and_get_ident(format!(\"_field{}\", i)[])\n+                        token::intern_and_get_ident(format!(\"_field{}\", i).index(&FullRange))\n                     }\n                 };\n                 let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "8ef9a7dc012394a6d718cc1c2031f4cc0bd0fd67", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -510,15 +510,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     struct_def,\n                     type_ident,\n-                    self_args[],\n-                    nonself_args[])\n+                    self_args.index(&FullRange),\n+                    nonself_args.index(&FullRange))\n             } else {\n                 method_def.expand_struct_method_body(cx,\n                                                      self,\n                                                      struct_def,\n                                                      type_ident,\n-                                                     self_args[],\n-                                                     nonself_args[])\n+                                                     self_args.index(&FullRange),\n+                                                     nonself_args.index(&FullRange))\n             };\n \n             method_def.create_method(cx,\n@@ -550,15 +550,15 @@ impl<'a> TraitDef<'a> {\n                     self,\n                     enum_def,\n                     type_ident,\n-                    self_args[],\n-                    nonself_args[])\n+                    self_args.index(&FullRange),\n+                    nonself_args.index(&FullRange))\n             } else {\n                 method_def.expand_enum_method_body(cx,\n                                                    self,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args,\n-                                                   nonself_args[])\n+                                                   nonself_args.index(&FullRange))\n             };\n \n             method_def.create_method(cx,\n@@ -645,7 +645,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(format!(\"__arg_{}\", i)[]);\n+            let ident = cx.ident_of(format!(\"__arg_{}\", i).index(&FullRange));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -752,7 +752,7 @@ impl<'a> MethodDef<'a> {\n                                              struct_path,\n                                              struct_def,\n                                              format!(\"__self_{}\",\n-                                                     i)[],\n+                                                     i).index(&FullRange),\n                                              ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -908,22 +908,22 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name|cx.ident_of(name[]))\n+            .map(|name|cx.ident_of(name.index(&FullRange)))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to a uint\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n-            .map(|name| { let vi_suffix = format!(\"{}_vi\", name[]);\n-                          cx.ident_of(vi_suffix[]) })\n+            .map(|name| { let vi_suffix = format!(\"{}_vi\", name.index(&FullRange));\n+                          cx.ident_of(vi_suffix.index(&FullRange)) })\n             .collect::<Vec<ast::Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n         let catch_all_substructure = EnumNonMatchingCollapsed(\n-            self_arg_idents, variants[], vi_idents[]);\n+            self_arg_idents, variants.index(&FullRange), vi_idents.index(&FullRange));\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n@@ -945,12 +945,12 @@ impl<'a> MethodDef<'a> {\n                 let mut subpats = Vec::with_capacity(self_arg_names.len());\n                 let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n                 let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, self_arg_names[0][]);\n+                    let (p, idents) = mk_self_pat(cx, self_arg_names[0].index(&FullRange));\n                     subpats.push(p);\n                     idents\n                 };\n                 for self_arg_name in self_arg_names.tail().iter() {\n-                    let (p, idents) = mk_self_pat(cx, self_arg_name[]);\n+                    let (p, idents) = mk_self_pat(cx, self_arg_name.index(&FullRange));\n                     subpats.push(p);\n                     self_pats_idents.push(idents);\n                 }\n@@ -1006,7 +1006,7 @@ impl<'a> MethodDef<'a> {\n                                                 &**variant,\n                                                 field_tuples);\n                 let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, self_args[], nonself_args,\n+                    cx, trait_, type_ident, self_args.index(&FullRange), nonself_args,\n                     &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n@@ -1059,7 +1059,7 @@ impl<'a> MethodDef<'a> {\n             }\n \n             let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, self_args[], nonself_args,\n+                cx, trait_, type_ident, self_args.index(&FullRange), nonself_args,\n                 &catch_all_substructure);\n \n             // Builds the expression:\n@@ -1263,7 +1263,7 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `derive`\");\n                 }\n             };\n-            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i)[]);\n+            let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).index(&FullRange));\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n                 sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n@@ -1309,7 +1309,7 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i)[]);\n+                    let ident = cx.ident_of(format!(\"{}_{}\", prefix, i).index(&FullRange));\n                     let path1 = codemap::Spanned{span: sp, node: ident};\n                     paths.push(path1);\n                     let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n@@ -1352,20 +1352,20 @@ pub fn cs_fold<F>(use_foldl: bool,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      field.other[])\n+                      field.other.index(&FullRange))\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      field.other[])\n+                      field.other.index(&FullRange))\n                 })\n             }\n         },\n         EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_f.call_mut((cx, trait_span, (all_args[], tuple),\n+            enum_nonmatch_f.call_mut((cx, trait_span, (all_args.index(&FullRange), tuple),\n                                       substructure.nonself_args)),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")\n@@ -1405,7 +1405,7 @@ pub fn cs_same_method<F>(f: F,\n             f(cx, trait_span, called)\n         },\n         EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_f.call_mut((cx, trait_span, (all_self_args[], tuple),\n+            enum_nonmatch_f.call_mut((cx, trait_span, (all_self_args.index(&FullRange), tuple),\n                                      substructure.nonself_args)),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `derive`\")"}, {"sha": "b44aa9dbd9fcbb90384a58dbbe40db433f8c6eab", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -123,7 +123,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                 cx.span_err(titem.span,\n                                             format!(\"unknown `derive` \\\n                                                      trait: `{}`\",\n-                                                    *tname)[]);\n+                                                    *tname).index(&FullRange));\n                             }\n                         };\n                     }"}, {"sha": "70d6da0f88b0264f8cfb15c73d38da31631d0da2", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -127,7 +127,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let formatter = substr.nonself_args[0].clone();\n \n     let meth = cx.ident_of(\"write_fmt\");\n-    let s = token::intern_and_get_ident(format_string[]);\n+    let s = token::intern_and_get_ident(format_string.index(&FullRange));\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!"}, {"sha": "eb3544e3c5c7f0aaacd08999f0bb1ac8311f56a5", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -30,7 +30,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n         Some(v) => v\n     };\n \n-    let e = match os::getenv(var[]) {\n+    let e = match os::getenv(var.index(&FullRange)) {\n       None => {\n           cx.expr_path(cx.path_all(sp,\n                                    true,\n@@ -56,7 +56,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                    cx.ident_of(\"Some\")),\n                               vec!(cx.expr_str(sp,\n                                                token::intern_and_get_ident(\n-                                          s[]))))\n+                                          s.index(&FullRange)))))\n       }\n     };\n     MacExpr::new(e)\n@@ -83,7 +83,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => {\n             token::intern_and_get_ident(format!(\"environment variable `{}` \\\n                                                  not defined\",\n-                                                var)[])\n+                                                var).index(&FullRange))\n         }\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n@@ -106,7 +106,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp, msg.get());\n             cx.expr_uint(sp, 0)\n         }\n-        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s[]))\n+        Some(s) => cx.expr_str(sp, token::intern_and_get_ident(s.index(&FullRange)))\n     };\n     MacExpr::new(e)\n }"}, {"sha": "75aea623de658a8e54e8bef69dc61a0ced4f9bd7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -287,7 +287,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         format!(\"macro undefined: '{}!'\",\n-                                extnamestr.get())[]);\n+                                extnamestr.get()).index(&FullRange));\n \n                     // let compilation continue\n                     None\n@@ -303,7 +303,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 },\n                             });\n                         let fm = fresh_mark();\n-                        let marked_before = mark_tts(tts[], fm);\n+                        let marked_before = mark_tts(tts.index(&FullRange), fm);\n \n                         // The span that we pass to the expanders we want to\n                         // be the root of the call stack. That's the most\n@@ -314,7 +314,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         let opt_parsed = {\n                             let expanded = expandfun.expand(fld.cx,\n                                                             mac_span,\n-                                                            marked_before[]);\n+                                                            marked_before.index(&FullRange));\n                             parse_thunk(expanded)\n                         };\n                         let parsed = match opt_parsed {\n@@ -323,8 +323,8 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                 fld.cx.span_err(\n                                     pth.span,\n                                     format!(\"non-expression macro in expression position: {}\",\n-                                            extnamestr.get()[]\n-                                            )[]);\n+                                            extnamestr.get().index(&FullRange)\n+                                            ).index(&FullRange));\n                                 return None;\n                             }\n                         };\n@@ -334,7 +334,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             format!(\"'{}' is not a tt-style macro\",\n-                                    extnamestr.get())[]);\n+                                    extnamestr.get()).index(&FullRange));\n                         None\n                     }\n                 }\n@@ -439,7 +439,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n             if valid_ident {\n                 fld.cx.mod_push(it.ident);\n             }\n-            let macro_use = contains_macro_use(fld, new_attrs[]);\n+            let macro_use = contains_macro_use(fld, new_attrs.index(&FullRange));\n             let result = with_exts_frame!(fld.cx.syntax_env,\n                                           macro_use,\n                                           noop_fold_item(it, fld));\n@@ -566,7 +566,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n             None => {\n                 fld.cx.span_err(path_span,\n                                 format!(\"macro undefined: '{}!'\",\n-                                        extnamestr)[]);\n+                                        extnamestr).index(&FullRange));\n                 // let compilation continue\n                 return SmallVector::zero();\n             }\n@@ -579,7 +579,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                                       format!(\"macro {}! expects no ident argument, \\\n                                         given '{}'\",\n                                       extnamestr,\n-                                      token::get_ident(it.ident))[]);\n+                                      token::get_ident(it.ident)).index(&FullRange));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -591,14 +591,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_before = mark_tts(tts[], fm);\n-                    expander.expand(fld.cx, it.span, marked_before[])\n+                    let marked_before = mark_tts(tts.index(&FullRange), fm);\n+                    expander.expand(fld.cx, it.span, marked_before.index(&FullRange))\n                 }\n                 IdentTT(ref expander, span) => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get())[]);\n+                                                extnamestr.get()).index(&FullRange));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -610,13 +610,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                         }\n                     });\n                     // mark before expansion:\n-                    let marked_tts = mark_tts(tts[], fm);\n+                    let marked_tts = mark_tts(tts.index(&FullRange), fm);\n                     expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n                 MacroRulesTT => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n-                                        format!(\"macro_rules! expects an ident argument\")[]);\n+                                        format!(\"macro_rules! expects an ident argument\")\n+                                            .index(&FullRange));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -648,7 +649,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     format!(\"{}! is not legal in item position\",\n-                                            extnamestr.get())[]);\n+                                            extnamestr.get()).index(&FullRange));\n                     return SmallVector::zero();\n                 }\n             }\n@@ -667,7 +668,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             format!(\"non-item macro in item position: {}\",\n-                                    extnamestr.get())[]);\n+                                    extnamestr.get()).index(&FullRange));\n             return SmallVector::zero();\n         }\n     };\n@@ -913,7 +914,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 format!(\"macro undefined: '{}!'\",\n-                                        extnamestr)[]);\n+                                        extnamestr).index(&FullRange));\n                 // let compilation continue\n                 return DummyResult::raw_pat(span);\n             }\n@@ -930,19 +931,19 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     });\n \n                     let fm = fresh_mark();\n-                    let marked_before = mark_tts(tts[], fm);\n+                    let marked_before = mark_tts(tts.index(&FullRange), fm);\n                     let mac_span = fld.cx.original_span();\n                     let expanded = match expander.expand(fld.cx,\n                                         mac_span,\n-                                        marked_before[]).make_pat() {\n+                                        marked_before.index(&FullRange)).make_pat() {\n                         Some(e) => e,\n                         None => {\n                             fld.cx.span_err(\n                                 pth.span,\n                                 format!(\n                                     \"non-pattern macro in pattern position: {}\",\n                                     extnamestr.get()\n-                                )[]\n+                                ).index(&FullRange)\n                             );\n                             return DummyResult::raw_pat(span);\n                         }\n@@ -954,7 +955,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     format!(\"{}! is not legal in pattern position\",\n-                                            extnamestr.get())[]);\n+                                            extnamestr.get()).index(&FullRange));\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1231,7 +1232,7 @@ impl Folder for Marker {\n             node: match node {\n                 MacInvocTT(path, tts, ctxt) => {\n                     MacInvocTT(self.fold_path(path),\n-                               self.fold_tts(tts[]),\n+                               self.fold_tts(tts.index(&FullRange)),\n                                mtwt::apply_mark(self.mark, ctxt))\n                 }\n             },\n@@ -1712,7 +1713,7 @@ foo_module!();\n                 let string = ident.get();\n                 \"xx\" == string\n             }).collect();\n-        let cxbinds: &[&ast::Ident] = cxbinds[];\n+        let cxbinds: &[&ast::Ident] = cxbinds.index(&FullRange);\n         let cxbind = match cxbinds {\n             [b] => b,\n             _ => panic!(\"expected just one binding for ext_cx\")"}, {"sha": "85a3a5ebcae3a6ce9850a451528e070201ccae38", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -113,7 +113,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 _ => {\n                     ecx.span_err(p.span,\n                                  format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string())[]);\n+                                         p.this_token_to_string()).index(&FullRange));\n                     return None;\n                 }\n             };\n@@ -126,7 +126,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n                                  format!(\"duplicate argument named `{}`\",\n-                                         name)[]);\n+                                         name).index(&FullRange));\n                     ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n                     continue\n                 }\n@@ -217,7 +217,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     let msg = format!(\"invalid reference to argument `{}` ({})\",\n                                       arg, self.describe_num_args());\n \n-                    self.ecx.span_err(self.fmtsp, msg[]);\n+                    self.ecx.span_err(self.fmtsp, msg.index(&FullRange));\n                     return;\n                 }\n                 {\n@@ -237,7 +237,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     Some(e) => e.span,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n-                        self.ecx.span_err(self.fmtsp, msg[]);\n+                        self.ecx.span_err(self.fmtsp, msg.index(&FullRange));\n                         return;\n                     }\n                 };\n@@ -280,19 +280,19 @@ impl<'a, 'b> Context<'a, 'b> {\n                                   format!(\"argument redeclared with type `{}` when \\\n                                            it was previously `{}`\",\n                                           *ty,\n-                                          *cur)[]);\n+                                          *cur).index(&FullRange));\n             }\n             (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           *cur)[]);\n+                                           *cur).index(&FullRange));\n             }\n             (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           *ty)[]);\n+                                           *ty).index(&FullRange));\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -357,7 +357,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(self.literal[]);\n+        let s = token::intern_and_get_ident(self.literal.index(&FullRange));\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -509,7 +509,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None => continue // error already generated\n             };\n \n-            let name = self.ecx.ident_of(format!(\"__arg{}\", i)[]);\n+            let name = self.ecx.ident_of(format!(\"__arg{}\", i).index(&FullRange));\n             pats.push(self.ecx.pat_ident(e.span, name));\n             locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n                                             self.ecx.expr_ident(e.span, name)));\n@@ -526,7 +526,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             };\n \n             let lname = self.ecx.ident_of(format!(\"__arg{}\",\n-                                                  *name)[]);\n+                                                  *name).index(&FullRange));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n@@ -606,7 +606,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n             Known(ref tyname) => {\n-                match tyname[] {\n+                match tyname.index(&FullRange) {\n                     \"\"  => \"Show\",\n                     \"?\" => \"Show\",\n                     \"e\" => \"LowerExp\",\n@@ -619,7 +619,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     _ => {\n                         ecx.span_err(sp,\n                                      format!(\"unknown format trait `{}`\",\n-                                             *tyname)[]);\n+                                             *tyname).index(&FullRange));\n                         \"Dummy\"\n                     }\n                 }\n@@ -710,7 +710,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n     if !parser.errors.is_empty() {\n         cx.ecx.span_err(cx.fmtsp, format!(\"invalid format string: {}\",\n-                                          parser.errors.remove(0))[]);\n+                                          parser.errors.remove(0)).index(&FullRange));\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {"}, {"sha": "49d6b255c81c7143dd009c6027f0d02297a91137", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -223,7 +223,7 @@ pub fn marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n }\n \n // the internal function for computing marks\n-// it's not clear to me whether it's better to use a [] mutable\n+// it's not clear to me whether it's better to use a .index(&FullRange) mutable\n // vector or a cons-list for this.\n fn marksof_internal(ctxt: SyntaxContext,\n                     stopname: Name,"}, {"sha": "66c7381e43344a0fabbd436c665af97774bfc5bc", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -473,7 +473,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n }\n \n fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident((*str)[])).collect()\n+    strs.iter().map(|str| str_to_ident((*str).index(&FullRange))).collect()\n }\n \n fn id_ext(str: &str) -> ast::Ident {\n@@ -675,7 +675,7 @@ fn mk_tt(cx: &ExtCtxt, tt: &ast::TokenTree) -> Vec<P<ast::Stmt>> {\n             for i in range(0, tt.len()) {\n                 seq.push(tt.get_tt(i));\n             }\n-            mk_tts(cx, seq[])\n+            mk_tts(cx, seq.index(&FullRange))\n         }\n         ast::TtToken(sp, ref tok) => {\n             let e_sp = cx.expr_ident(sp, id_ext(\"_sp\"));\n@@ -764,7 +764,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let stmt_let_tt = cx.stmt_let(sp, true, id_ext(\"tt\"), cx.expr_vec_ng(sp));\n \n     let mut vector = vec!(stmt_let_sp, stmt_let_tt);\n-    vector.extend(mk_tts(cx, tts[]).into_iter());\n+    vector.extend(mk_tts(cx, tts.index(&FullRange)).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n                      Vec::new(),"}, {"sha": "5c966ed98231fa2ae39c3dd3504569862cb63abd", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -57,15 +57,15 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name[]);\n+    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n     base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacExpr::new(cx.expr_str(sp,\n-                                   token::intern_and_get_ident(s[])))\n+                                   token::intern_and_get_ident(s.index(&FullRange))))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n@@ -78,7 +78,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                    .connect(\"::\");\n     base::MacExpr::new(cx.expr_str(\n             sp,\n-            token::intern_and_get_ident(string[])))\n+            token::intern_and_get_ident(string.index(&FullRange))))\n }\n \n /// include! : parse the given file as an expr\n@@ -137,7 +137,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             cx.span_err(sp,\n                         format!(\"couldn't read {}: {}\",\n                                 file.display(),\n-                                e)[]);\n+                                e).index(&FullRange));\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => bytes,\n@@ -147,15 +147,15 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = file.display().to_string();\n-            let interned = token::intern_and_get_ident(src[]);\n+            let interned = token::intern_and_get_ident(src.index(&FullRange));\n             cx.codemap().new_filemap(filename, src);\n \n             base::MacExpr::new(cx.expr_str(sp, interned))\n         }\n         Err(_) => {\n             cx.span_err(sp,\n                         format!(\"{} wasn't a utf-8 file\",\n-                                file.display())[]);\n+                                file.display()).index(&FullRange));\n             return DummyResult::expr(sp);\n         }\n     }\n@@ -177,7 +177,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     match File::open(&file).read_to_end() {\n         Err(e) => {\n             cx.span_err(sp,\n-                        format!(\"couldn't read {}: {}\", file.display(), e)[]);\n+                        format!(\"couldn't read {}: {}\", file.display(), e).index(&FullRange));\n             return DummyResult::expr(sp);\n         }\n         Ok(bytes) => {"}, {"sha": "328e302bef30afa92d94ac24b2d01599082f25d9", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -153,7 +153,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n                 seq.num_captures\n             }\n             &TtDelimited(_, ref delim) => {\n-                count_names(delim.tts[])\n+                count_names(delim.tts.index(&FullRange))\n             }\n             &TtToken(_, MatchNt(..)) => {\n                 1\n@@ -165,7 +165,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n \n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n-    let match_idx_hi = count_names(ms[]);\n+    let match_idx_hi = count_names(ms.index(&FullRange));\n     let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n@@ -229,7 +229,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n                         p_s.span_diagnostic\n                            .span_fatal(sp,\n                                        format!(\"duplicated bind name: {}\",\n-                                               string.get())[])\n+                                               string.get()).index(&FullRange))\n                     }\n                 }\n             }\n@@ -254,13 +254,13 @@ pub fn parse_or_else(sess: &ParseSess,\n                      rdr: TtReader,\n                      ms: Vec<TokenTree> )\n                      -> HashMap<Ident, Rc<NamedMatch>> {\n-    match parse(sess, cfg, rdr, ms[]) {\n+    match parse(sess, cfg, rdr, ms.index(&FullRange)) {\n         Success(m) => m,\n         Failure(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, str[])\n+            sess.span_diagnostic.span_fatal(sp, str.index(&FullRange))\n         }\n         Error(sp, str) => {\n-            sess.span_diagnostic.span_fatal(sp, str[])\n+            sess.span_diagnostic.span_fatal(sp, str.index(&FullRange))\n         }\n     }\n }\n@@ -341,7 +341,7 @@ pub fn parse(sess: &ParseSess,\n                         // Only touch the binders we have actually bound\n                         for idx in range(ei.match_lo, ei.match_hi) {\n                             let sub = (ei.matches[idx]).clone();\n-                            new_pos.matches[idx]\n+                            (&mut new_pos.matches[idx])\n                                    .push(Rc::new(MatchedSeq(sub, mk_sp(ei.sp_lo,\n                                                                        sp.hi))));\n                         }\n@@ -386,7 +386,7 @@ pub fn parse(sess: &ParseSess,\n                             new_ei.idx += 1u;\n                             //we specifically matched zero repeats.\n                             for idx in range(ei.match_cur, ei.match_cur + seq.num_captures) {\n-                                new_ei.matches[idx].push(Rc::new(MatchedSeq(Vec::new(), sp)));\n+                                (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(Vec::new(), sp)));\n                             }\n \n                             cur_eis.push(new_ei);\n@@ -444,10 +444,10 @@ pub fn parse(sess: &ParseSess,\n         if token_name_eq(&tok, &token::Eof) {\n             if eof_eis.len() == 1u {\n                 let mut v = Vec::new();\n-                for dv in eof_eis[0].matches.iter_mut() {\n+                for dv in (&mut eof_eis[0]).matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n-                return Success(nameize(sess, ms, v[]));\n+                return Success(nameize(sess, ms, v.index(&FullRange)));\n             } else if eof_eis.len() > 1u {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n@@ -486,7 +486,7 @@ pub fn parse(sess: &ParseSess,\n                   TtToken(_, MatchNt(_, name, _, _)) => {\n                     let name_string = token::get_ident(name);\n                     let match_cur = ei.match_cur;\n-                    ei.matches[match_cur].push(Rc::new(MatchedNonterminal(\n+                    (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get()))));\n                     ei.idx += 1u;\n                     ei.match_cur += 1;\n@@ -522,7 +522,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         _ => {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal((format!(\"expected ident, found {}\",\n-                             token_str[]))[])\n+                             token_str.index(&FullRange))).index(&FullRange))\n         }\n       },\n       \"path\" => {\n@@ -536,7 +536,7 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n         res\n       }\n       _ => {\n-          p.fatal(format!(\"unsupported builtin nonterminal parser: {}\", name)[])\n+          p.fatal(format!(\"unsupported builtin nonterminal parser: {}\", name).index(&FullRange))\n       }\n     }\n }"}, {"sha": "805af484e281a1e1e0eab54c200e50fda9509689", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -52,7 +52,7 @@ impl<'a> ParserAnyMacro<'a> {\n                                following\",\n                               token_str);\n             let span = parser.span;\n-            parser.span_err(span, msg[]);\n+            parser.span_err(span, msg.index(&FullRange));\n         }\n     }\n }\n@@ -126,8 +126,8 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n                           self.name,\n                           self.imported_from,\n                           arg,\n-                          self.lhses[],\n-                          self.rhses[])\n+                          self.lhses.index(&FullRange),\n+                          self.rhses.index(&FullRange))\n     }\n }\n \n@@ -154,7 +154,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n         match **lhs {\n           MatchedNonterminal(NtTT(ref lhs_tt)) => {\n             let lhs_tt = match **lhs_tt {\n-                TtDelimited(_, ref delim) => delim.tts[],\n+                TtDelimited(_, ref delim) => delim.tts.index(&FullRange),\n                 _ => cx.span_fatal(sp, \"malformed macro lhs\")\n             };\n             // `None` is because we're not interpolating\n@@ -194,13 +194,13 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 best_fail_spot = sp;\n                 best_fail_msg = (*msg).clone();\n               },\n-              Error(sp, ref msg) => cx.span_fatal(sp, msg[])\n+              Error(sp, ref msg) => cx.span_fatal(sp, msg.index(&FullRange))\n             }\n           }\n           _ => cx.bug(\"non-matcher found in parsed lhses\")\n         }\n     }\n-    cx.span_fatal(best_fail_spot, best_fail_msg[]);\n+    cx.span_fatal(best_fail_spot, best_fail_msg.index(&FullRange));\n }\n \n // Note that macro-by-example's input is also matched against a token tree:"}, {"sha": "7ca920a61962a9b5f15933e65b958380dce747c0", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -240,7 +240,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                     }\n                     LisContradiction(ref msg) => {\n                         // FIXME #2887 blame macro invoker instead\n-                        r.sp_diag.span_fatal(sp.clone(), msg[]);\n+                        r.sp_diag.span_fatal(sp.clone(), msg.index(&FullRange));\n                     }\n                     LisConstraint(len, _) => {\n                         if len == 0 {\n@@ -297,7 +297,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                                 r.sp_diag.span_fatal(\n                                     r.cur_span, /* blame the macro writer */\n                                     format!(\"variable '{}' is still repeating at this depth\",\n-                                            token::get_ident(ident))[]);\n+                                            token::get_ident(ident)).index(&FullRange));\n                             }\n                         }\n                     }"}, {"sha": "afe149e9d69330af7f7183ba7d20f1f908d07695", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -149,7 +149,7 @@ impl<'a> Context<'a> {\n             self.span_handler.span_err(span, explain);\n             self.span_handler.span_help(span, format!(\"add #![feature({})] to the \\\n                                                        crate attributes to enable\",\n-                                                      feature)[]);\n+                                                      feature).index(&FullRange));\n         }\n     }\n \n@@ -240,7 +240,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n         match i.node {\n             ast::ItemForeignMod(ref foreign_module) => {\n-                if attr::contains_name(i.attrs[], \"link_args\") {\n+                if attr::contains_name(i.attrs.index(&FullRange), \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n                                       \"the `link_args` attribute is not portable \\\n                                        across platforms, it is recommended to \\\n@@ -254,14 +254,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n \n             ast::ItemFn(..) => {\n-                if attr::contains_name(i.attrs[], \"plugin_registrar\") {\n+                if attr::contains_name(i.attrs.index(&FullRange), \"plugin_registrar\") {\n                     self.gate_feature(\"plugin_registrar\", i.span,\n                                       \"compiler plugins are experimental and possibly buggy\");\n                 }\n             }\n \n             ast::ItemStruct(..) => {\n-                if attr::contains_name(i.attrs[], \"simd\") {\n+                if attr::contains_name(i.attrs.index(&FullRange), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }\n@@ -303,7 +303,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        if attr::contains_name(i.attrs[], \"linkage\") {\n+        if attr::contains_name(i.attrs.index(&FullRange), \"linkage\") {\n             self.gate_feature(\"linkage\", i.span,\n                               \"the `linkage` attribute is experimental \\\n                                and not portable across platforms\")"}, {"sha": "f4810cee5f89d37962d65f950a4ff915693f84db", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -92,7 +92,7 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(format!(\"expected `#`, found `{}`\", token_str)[]);\n+                self.fatal(format!(\"expected `#`, found `{}`\", token_str).index(&FullRange));\n             }\n         };\n "}, {"sha": "e7fc5aac9c772cb0b20bbe83a980185efb4ed724", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -82,7 +82,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         while j > i && lines[j - 1].trim().is_empty() {\n             j -= 1;\n         }\n-        return lines[i..j].iter().map(|x| (*x).clone()).collect();\n+        return lines.index(&(i..j)).iter().map(|x| (*x).clone()).collect();\n     }\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n@@ -116,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                line[i + 1..line.len()].to_string()\n+                line.index(&((i + 1)..line.len())).to_string()\n             }).collect()\n         } else {\n             lines\n@@ -127,12 +127,12 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n     for prefix in ONLINERS.iter() {\n         if comment.starts_with(*prefix) {\n-            return comment[prefix.len()..].to_string();\n+            return comment.index(&(prefix.len()..)).to_string();\n         }\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let lines = comment[3u..comment.len() - 2u]\n+        let lines = comment.index(&(3u..(comment.len() - 2u)))\n             .lines_any()\n             .map(|s| s.to_string())\n             .collect::<Vec<String> >();\n@@ -187,7 +187,7 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n         let line = rdr.read_one_line_comment();\n         debug!(\"{}\", line);\n         // Doc comments are not put in comments.\n-        if is_doc_comment(line[]) {\n+        if is_doc_comment(line.index(&FullRange)) {\n             break;\n         }\n         lines.push(line);\n@@ -224,10 +224,10 @@ fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n fn trim_whitespace_prefix_and_push_line(lines: &mut Vec<String> ,\n                                         s: String, col: CharPos) {\n     let len = s.len();\n-    let s1 = match all_whitespace(s[], col) {\n+    let s1 = match all_whitespace(s.index(&FullRange), col) {\n         Some(col) => {\n             if col < len {\n-                s[col..len].to_string()\n+                s.index(&(col..len)).to_string()\n             } else {\n                 \"\".to_string()\n             }\n@@ -261,7 +261,7 @@ fn read_block_comment(rdr: &mut StringReader,\n             rdr.bump();\n             rdr.bump();\n         }\n-        if is_block_doc_comment(curr_line[]) {\n+        if is_block_doc_comment(curr_line.index(&FullRange)) {\n             return\n         }\n         assert!(!curr_line.contains_char('\\n'));"}, {"sha": "850d527fe3970148e803616ebcea97851ba3847c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -196,7 +196,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.fatal_span_(from_pos, to_pos, m[]);\n+        self.fatal_span_(from_pos, to_pos, m.index(&FullRange));\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending an\n@@ -205,7 +205,7 @@ impl<'a> StringReader<'a> {\n         let mut m = m.to_string();\n         m.push_str(\": \");\n         for c in c.escape_default() { m.push(c) }\n-        self.err_span_(from_pos, to_pos, m[]);\n+        self.err_span_(from_pos, to_pos, m.index(&FullRange));\n     }\n \n     /// Report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -214,8 +214,8 @@ impl<'a> StringReader<'a> {\n         m.push_str(\": \");\n         let from = self.byte_offset(from_pos).to_uint();\n         let to = self.byte_offset(to_pos).to_uint();\n-        m.push_str(self.filemap.src[from..to]);\n-        self.fatal_span_(from_pos, to_pos, m[]);\n+        m.push_str(self.filemap.src.index(&(from..to)));\n+        self.fatal_span_(from_pos, to_pos, m.index(&FullRange));\n     }\n \n     /// Advance peek_tok and peek_span to refer to the next token, and\n@@ -301,7 +301,7 @@ impl<'a> StringReader<'a> {\n             while i < s.len() {\n                 let str::CharRange { ch, next } = s.char_range_at(i);\n                 if ch == '\\r' {\n-                    if j < i { buf.push_str(s[j..i]); }\n+                    if j < i { buf.push_str(s.index(&(j..i))); }\n                     j = next;\n                     if next >= s.len() || s.char_at(next) != '\\n' {\n                         let pos = start + BytePos(i as u32);\n@@ -311,7 +311,7 @@ impl<'a> StringReader<'a> {\n                 }\n                 i = next;\n             }\n-            if j < s.len() { buf.push_str(s[j..]); }\n+            if j < s.len() { buf.push_str(s.index(&(j..))); }\n             buf\n         }\n     }\n@@ -556,7 +556,7 @@ impl<'a> StringReader<'a> {\n                     self.translate_crlf(start_bpos, string,\n                                         \"bare CR not allowed in block doc-comment\")\n                 } else { string.into_cow() };\n-                token::DocComment(token::intern(string[]))\n+                token::DocComment(token::intern(string.index(&FullRange)))\n             } else {\n                 token::Comment\n             };\n@@ -1110,7 +1110,7 @@ impl<'a> StringReader<'a> {\n                 // expansion purposes. See #12512 for the gory details of why\n                 // this is necessary.\n                 let ident = self.with_str_from(start, |lifetime_name| {\n-                    str_to_ident(format!(\"'{}\", lifetime_name)[])\n+                    str_to_ident(format!(\"'{}\", lifetime_name).index(&FullRange))\n                 });\n \n                 // Conjure up a \"keyword checking ident\" to make sure that"}, {"sha": "24a909cc5fb94d49924aad10f75d84ee33ab7d5e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -256,17 +256,17 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n         Err(e) => {\n             err(format!(\"couldn't read {}: {}\",\n                         path.display(),\n-                        e)[]);\n+                        e).index(&FullRange));\n             unreachable!()\n         }\n     };\n-    match str::from_utf8(bytes[]).ok() {\n+    match str::from_utf8(bytes.index(&FullRange)).ok() {\n         Some(s) => {\n             return string_to_filemap(sess, s.to_string(),\n                                      path.as_str().unwrap().to_string())\n         }\n         None => {\n-            err(format!(\"{} is not UTF-8 encoded\", path.display())[])\n+            err(format!(\"{} is not UTF-8 encoded\", path.display()).index(&FullRange))\n         }\n     }\n     unreachable!()\n@@ -398,18 +398,18 @@ pub fn char_lit(lit: &str) -> (char, int) {\n     }\n \n     let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n-    let msg2 = msg[];\n+    let msg2 = msg.index(&FullRange);\n \n     fn esc(len: uint, lit: &str) -> Option<(char, int)> {\n-        num::from_str_radix(lit[2..len], 16)\n+        num::from_str_radix(lit.index(&(2..len)), 16)\n         .and_then(char::from_u32)\n         .map(|x| (x, len as int))\n     }\n \n     let unicode_escape = |&: | -> Option<(char, int)>\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n-            let subslice = lit[3..idx];\n+            let subslice = lit.index(&(3..idx));\n             num::from_str_radix(subslice, 16)\n                 .and_then(char::from_u32)\n                 .map(|x| (x, subslice.chars().count() as int + 4))\n@@ -471,7 +471,7 @@ pub fn str_lit(lit: &str) -> String {\n                             eat(&mut chars);\n                         } else {\n                             // otherwise, a normal escape\n-                            let (c, n) = char_lit(lit[i..]);\n+                            let (c, n) = char_lit(lit.index(&(i..)));\n                             for _ in range(0, n - 1) { // we don't need to move past the first \\\n                                 chars.next();\n                             }\n@@ -534,7 +534,7 @@ pub fn raw_str_lit(lit: &str) -> String {\n fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n     s.len() > 1 &&\n         first_chars.contains(&s.char_at(0)) &&\n-        s[1..].chars().all(|c| '0' <= c && c <= '9')\n+        s.index(&(1..)).chars().all(|c| '0' <= c && c <= '9')\n }\n \n fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n@@ -547,7 +547,7 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.span_err(sp, &*format!(\"illegal width `{}` for float literal, \\\n-                                          valid widths are 32 and 64\", suf[1..]));\n+                                          valid widths are 32 and 64\", suf.index(&(1..))));\n             } else {\n                 sd.span_err(sp, &*format!(\"illegal suffix `{}` for float literal, \\\n                                           valid suffixes are `f32` and `f64`\", suf));\n@@ -583,7 +583,7 @@ pub fn byte_lit(lit: &str) -> (u8, uint) {\n             b'\\'' => b'\\'',\n             b'0' => b'\\0',\n             _ => {\n-                match ::std::num::from_str_radix::<u64>(lit[2..4], 16) {\n+                match ::std::num::from_str_radix::<u64>(lit.index(&(2..4)), 16) {\n                     Some(c) =>\n                         if c > 0xFF {\n                             panic!(err(2))\n@@ -633,7 +633,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n                     }\n                     _ => {\n                         // otherwise, a normal escape\n-                        let (c, n) = byte_lit(lit[i..]);\n+                        let (c, n) = byte_lit(lit.index(&(i..)));\n                         // we don't need to move past the first \\\n                         for _ in range(0, n - 1) {\n                             chars.next();\n@@ -662,7 +662,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let mut s = s2[];\n+    let mut s = s2.index(&FullRange);\n \n     debug!(\"integer_lit: {}, {}\", s, suffix);\n \n@@ -695,7 +695,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n     }\n \n     if base != 10 {\n-        s = s[2..];\n+        s = s.index(&(2..));\n     }\n \n     if let Some(suf) = suffix {\n@@ -717,7 +717,7 @@ pub fn integer_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) ->\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.span_err(sp, &*format!(\"illegal width `{}` for integer literal; \\\n                                               valid widths are 8, 16, 32 and 64\",\n-                                              suf[1..]));\n+                                              suf.index(&(1..))));\n                 } else {\n                     sd.span_err(sp, &*format!(\"illegal suffix `{}` for numeric literal\", suf));\n                 }\n@@ -815,27 +815,27 @@ mod test {\n     #[test]\n     fn string_to_tts_macro () {\n         let tts = string_to_tts(\"macro_rules! zip (($a)=>($a))\".to_string());\n-        let tts: &[ast::TokenTree] = tts[];\n+        let tts: &[ast::TokenTree] = tts.index(&FullRange);\n         match tts {\n             [ast::TtToken(_, token::Ident(name_macro_rules, token::Plain)),\n              ast::TtToken(_, token::Not),\n              ast::TtToken(_, token::Ident(name_zip, token::Plain)),\n              ast::TtDelimited(_, ref macro_delimed)]\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match macro_delimed.tts[] {\n+                match macro_delimed.tts.index(&FullRange) {\n                     [ast::TtDelimited(_, ref first_delimed),\n                      ast::TtToken(_, token::FatArrow),\n                      ast::TtDelimited(_, ref second_delimed)]\n                     if macro_delimed.delim == token::Paren => {\n-                        match first_delimed.tts[] {\n+                        match first_delimed.tts.index(&FullRange) {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {}\", **first_delimed),\n                         }\n-                        match second_delimed.tts[] {\n+                        match second_delimed.tts.index(&FullRange) {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if second_delimed.delim == token::Paren\n@@ -1113,24 +1113,24 @@ mod test {\n         let use_s = \"use foo::bar::baz;\";\n         let vitem = string_to_view_item(use_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s[], use_s);\n+        assert_eq!(vitem_s.index(&FullRange), use_s);\n \n         let use_s = \"use foo::bar as baz;\";\n         let vitem = string_to_view_item(use_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s[], use_s);\n+        assert_eq!(vitem_s.index(&FullRange), use_s);\n     }\n \n     #[test] fn parse_extern_crate() {\n         let ex_s = \"extern crate foo;\";\n         let vitem = string_to_view_item(ex_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s[], ex_s);\n+        assert_eq!(vitem_s.index(&FullRange), ex_s);\n \n         let ex_s = \"extern crate \\\"foo\\\" as bar;\";\n         let vitem = string_to_view_item(ex_s.to_string());\n         let vitem_s = view_item_to_string(&vitem);\n-        assert_eq!(vitem_s[], ex_s);\n+        assert_eq!(vitem_s.index(&FullRange), ex_s);\n     }\n \n     fn get_spans_of_pat_idents(src: &str) -> Vec<Span> {\n@@ -1209,7 +1209,7 @@ mod test {\n         let docs = item.attrs.iter().filter(|a| a.name().get() == \"doc\")\n                     .map(|a| a.value_str().unwrap().get().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n-        assert_eq!(docs[], b);\n+        assert_eq!(docs.index(&FullRange), b);\n \n         let source = \"/** doc comment\\r\\n *  with CRLF */\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name, source, Vec::new(), &sess).unwrap();"}, {"sha": "23728c74ae8b5542b175305a362d6ceec870f2eb", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -127,13 +127,13 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               kind_str: &str,\n               desc: &str) {\n         self.span_err(sp,\n-                      format!(\"obsolete syntax: {}\", kind_str)[]);\n+                      format!(\"obsolete syntax: {}\", kind_str).index(&FullRange));\n \n         if !self.obsolete_set.contains(&kind) {\n             self.sess\n                 .span_diagnostic\n                 .handler()\n-                .note(format!(\"{}\", desc)[]);\n+                .note(format!(\"{}\", desc).index(&FullRange));\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "f35f42d5aca300b589248f33d0c4b24527c083b0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -389,12 +389,12 @@ impl<'a> Parser<'a> {\n         let token_str = Parser::token_to_string(t);\n         let last_span = self.last_span;\n         self.span_fatal(last_span, format!(\"unexpected token: `{}`\",\n-                                                token_str)[]);\n+                                                token_str).index(&FullRange));\n     }\n \n     pub fn unexpected(&mut self) -> ! {\n         let this_token = self.this_token_to_string();\n-        self.fatal(format!(\"unexpected token: `{}`\", this_token)[]);\n+        self.fatal(format!(\"unexpected token: `{}`\", this_token).index(&FullRange));\n     }\n \n     /// Expect and consume the token t. Signal an error if\n@@ -408,7 +408,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   this_token_str)[])\n+                                   this_token_str).index(&FullRange))\n             }\n         } else {\n             self.expect_one_of(slice::ref_slice(t), &[]);\n@@ -449,7 +449,7 @@ impl<'a> Parser<'a> {\n             expected.push_all(&*self.expected_tokens);\n             expected.sort_by(|a, b| a.to_string().cmp(&b.to_string()));\n             expected.dedup();\n-            let expect = tokens_to_string(expected[]);\n+            let expect = tokens_to_string(expected.index(&FullRange));\n             let actual = self.this_token_to_string();\n             self.fatal(\n                 (if expected.len() != 1 {\n@@ -460,7 +460,7 @@ impl<'a> Parser<'a> {\n                     (format!(\"expected {}, found `{}`\",\n                              expect,\n                              actual))\n-                })[]\n+                }).index(&FullRange)\n             )\n         }\n     }\n@@ -493,7 +493,7 @@ impl<'a> Parser<'a> {\n             // might be unit-struct construction; check for recoverableinput error.\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n             expected.push_all(inedible);\n-            self.check_for_erroneous_unit_struct_expecting(expected[]);\n+            self.check_for_erroneous_unit_struct_expecting(expected.index(&FullRange));\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -510,9 +510,9 @@ impl<'a> Parser<'a> {\n                .as_ref()\n                .map_or(false, |t| t.is_ident() || t.is_path()) {\n             let mut expected = edible.iter().map(|x| x.clone()).collect::<Vec<_>>();\n-            expected.push_all(inedible[]);\n+            expected.push_all(inedible.index(&FullRange));\n             self.check_for_erroneous_unit_struct_expecting(\n-                expected[]);\n+                expected.index(&FullRange));\n         }\n         self.expect_one_of(edible, inedible)\n     }\n@@ -535,7 +535,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal((format!(\"expected ident, found `{}`\",\n-                                    token_str))[])\n+                                    token_str)).index(&FullRange))\n             }\n         }\n     }\n@@ -593,7 +593,7 @@ impl<'a> Parser<'a> {\n             let id_interned_str = token::get_name(kw.to_name());\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n-                               id_interned_str, token_str)[])\n+                               id_interned_str, token_str).index(&FullRange))\n         }\n     }\n \n@@ -604,7 +604,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             self.span_err(span,\n                           format!(\"expected identifier, found keyword `{}`\",\n-                                  token_str)[]);\n+                                  token_str).index(&FullRange));\n         }\n     }\n \n@@ -613,7 +613,7 @@ impl<'a> Parser<'a> {\n         if self.token.is_reserved_keyword() {\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"`{}` is a reserved keyword\",\n-                               token_str)[])\n+                               token_str).index(&FullRange))\n         }\n     }\n \n@@ -633,7 +633,7 @@ impl<'a> Parser<'a> {\n                     Parser::token_to_string(&token::BinOp(token::And));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    found_token,\n-                                   token_str)[])\n+                                   token_str).index(&FullRange))\n             }\n         }\n     }\n@@ -654,7 +654,7 @@ impl<'a> Parser<'a> {\n                     Parser::token_to_string(&token::BinOp(token::Or));\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    token_str,\n-                                   found_token)[])\n+                                   found_token).index(&FullRange))\n             }\n         }\n     }\n@@ -697,7 +697,7 @@ impl<'a> Parser<'a> {\n             let token_str = Parser::token_to_string(&token::Lt);\n             self.fatal(format!(\"expected `{}`, found `{}`\",\n                                token_str,\n-                               found_token)[])\n+                               found_token).index(&FullRange))\n         }\n     }\n \n@@ -749,7 +749,7 @@ impl<'a> Parser<'a> {\n                 let this_token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `{}`, found `{}`\",\n                                    gt_str,\n-                                   this_token_str)[])\n+                                   this_token_str).index(&FullRange))\n             }\n         }\n     }\n@@ -1369,7 +1369,7 @@ impl<'a> Parser<'a> {\n                     let (inner_attrs, body) =\n                         p.parse_inner_attrs_and_block();\n                     let mut attrs = attrs;\n-                    attrs.push_all(inner_attrs[]);\n+                    attrs.push_all(inner_attrs.index(&FullRange));\n                     ProvidedMethod(P(ast::Method {\n                         attrs: attrs,\n                         id: ast::DUMMY_NODE_ID,\n@@ -1388,7 +1388,7 @@ impl<'a> Parser<'a> {\n                   _ => {\n                       let token_str = p.this_token_to_string();\n                       p.fatal((format!(\"expected `;` or `{{`, found `{}`\",\n-                                       token_str))[])\n+                                       token_str)).index(&FullRange))\n                   }\n                 }\n             }\n@@ -1584,7 +1584,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let this_token_str = self.this_token_to_string();\n             let msg = format!(\"expected type, found `{}`\", this_token_str);\n-            self.fatal(msg[]);\n+            self.fatal(msg.index(&FullRange));\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n@@ -1726,14 +1726,14 @@ impl<'a> Parser<'a> {\n \n                     token::Str_(s) => {\n                         (true,\n-                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str())[]),\n+                         LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).index(&FullRange)),\n                                 ast::CookedStr))\n                     }\n                     token::StrRaw(s, n) => {\n                         (true,\n                          LitStr(\n                             token::intern_and_get_ident(\n-                                parse::raw_str_lit(s.as_str())[]),\n+                                parse::raw_str_lit(s.as_str()).index(&FullRange)),\n                             ast::RawStr(n)))\n                     }\n                     token::Binary(i) =>\n@@ -1977,7 +1977,7 @@ impl<'a> Parser<'a> {\n                 };\n             }\n             _ => {\n-                self.fatal(format!(\"expected a lifetime name\")[]);\n+                self.fatal(format!(\"expected a lifetime name\").index(&FullRange));\n             }\n         }\n     }\n@@ -2015,7 +2015,7 @@ impl<'a> Parser<'a> {\n                     let msg = format!(\"expected `,` or `>` after lifetime \\\n                                       name, found `{}`\",\n                                       this_token_str);\n-                    self.fatal(msg[]);\n+                    self.fatal(msg.index(&FullRange));\n                 }\n             }\n         }\n@@ -2515,7 +2515,7 @@ impl<'a> Parser<'a> {\n                     let last_span = self.last_span;\n                     let fstr = n.as_str();\n                     self.span_err(last_span,\n-                                  format!(\"unexpected token: `{}`\", n.as_str())[]);\n+                                  format!(\"unexpected token: `{}`\", n.as_str()).index(&FullRange));\n                     if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n                         let float = match fstr.parse::<f64>() {\n                             Some(f) => f,\n@@ -2524,7 +2524,7 @@ impl<'a> Parser<'a> {\n                         self.span_help(last_span,\n                             format!(\"try parenthesizing the first index; e.g., `(foo.{}){}`\",\n                                     float.trunc() as uint,\n-                                    float.fract().to_string()[1..])[]);\n+                                    float.fract().to_string().index(&(1..))).index(&FullRange));\n                     }\n                     self.abort_if_errors();\n \n@@ -2561,18 +2561,18 @@ impl<'a> Parser<'a> {\n                     MutImmutable\n                 };\n                 match self.token {\n-                    // e[]\n+                    // e.index(&FullRange)\n                     token::CloseDelim(token::Bracket) => {\n                         self.bump();\n                         hi = self.span.hi;\n                         let slice = self.mk_slice(e, None, None, mutbl);\n                         e = self.mk_expr(lo, hi, slice)\n                     }\n-                    // e[..e]\n+                    // e.index(&(0..e))\n                     token::DotDot => {\n                         self.bump();\n                         match self.token {\n-                            // e[..]\n+                            // e.index(&(..))\n                             token::CloseDelim(token::Bracket) => {\n                                 self.bump();\n                                 hi = self.span.hi;\n@@ -2581,9 +2581,9 @@ impl<'a> Parser<'a> {\n \n                                 self.span_err(e.span, \"incorrect slicing expression: `[..]`\");\n                                 self.span_note(e.span,\n-                                    \"use `expr[]` to construct a slice of the whole of expr\");\n+                                    \"use `expr.index(&FullRange)` to construct a slice of the whole of expr\");\n                             }\n-                            // e[..e]\n+                            // e.index(&(0..e))\n                             _ => {\n                                 hi = self.span.hi;\n                                 let e2 = self.parse_expr();\n@@ -2593,20 +2593,20 @@ impl<'a> Parser<'a> {\n                             }\n                         }\n                     }\n-                    // e[e] | e[e..] | e[e..e]\n+                    // e[e] | e.index(&(e..)) | e.index(&(e..e))\n                     _ => {\n                         let ix = self.parse_expr_res(RESTRICTION_NO_DOTS);\n                         match self.token {\n-                            // e[e..] | e[e..e]\n+                            // e.index(&(e..)) | e.index(&(e..e))\n                             token::DotDot => {\n                                 self.bump();\n                                 let e2 = match self.token {\n-                                    // e[e..]\n+                                    // e.index(&(e..))\n                                     token::CloseDelim(token::Bracket) => {\n                                         self.bump();\n                                         None\n                                     }\n-                                    // e[e..e]\n+                                    // e.index(&(e..e))\n                                     _ => {\n                                         let e2 = self.parse_expr_res(RESTRICTION_NO_DOTS);\n                                         self.commit_expr_expecting(&*e2,\n@@ -2711,7 +2711,7 @@ impl<'a> Parser<'a> {\n                   };\n                   let token_str = p.this_token_to_string();\n                   p.fatal(format!(\"incorrect close delimiter: `{}`\",\n-                                  token_str)[])\n+                                  token_str).index(&FullRange))\n               },\n               /* we ought to allow different depths of unquotation */\n               token::Dollar if p.quote_depth > 0u => {\n@@ -2729,7 +2729,7 @@ impl<'a> Parser<'a> {\n                     let seq = match seq {\n                         Spanned { node, .. } => node,\n                     };\n-                    let name_num = macro_parser::count_names(seq[]);\n+                    let name_num = macro_parser::count_names(seq.index(&FullRange));\n                     TtSequence(mk_sp(sp.lo, p.span.hi),\n                                Rc::new(SequenceRepetition {\n                                    tts: seq,\n@@ -2890,7 +2890,7 @@ impl<'a> Parser<'a> {\n                         let this_token_to_string = self.this_token_to_string();\n                         self.span_err(span,\n                                       format!(\"expected expression, found `{}`\",\n-                                              this_token_to_string)[]);\n+                                              this_token_to_string).index(&FullRange));\n                         let box_span = mk_sp(lo, self.last_span.hi);\n                         self.span_help(box_span,\n                                        \"perhaps you meant `box() (foo)` instead?\");\n@@ -3273,7 +3273,7 @@ impl<'a> Parser<'a> {\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `{}`, found `{}`\", \"}\",\n-                                       token_str)[])\n+                                       token_str).index(&FullRange))\n                 }\n                 etc = true;\n                 break;\n@@ -3294,7 +3294,7 @@ impl<'a> Parser<'a> {\n                     BindByRef(..) | BindByValue(MutMutable) => {\n                         let token_str = self.this_token_to_string();\n                         self.fatal(format!(\"unexpected `{}`\",\n-                                           token_str)[])\n+                                           token_str).index(&FullRange))\n                     }\n                     _ => {}\n                 }\n@@ -3577,7 +3577,7 @@ impl<'a> Parser<'a> {\n             let span = self.span;\n             let tok_str = self.this_token_to_string();\n             self.span_fatal(span,\n-                            format!(\"expected identifier, found `{}`\", tok_str)[]);\n+                            format!(\"expected identifier, found `{}`\", tok_str).index(&FullRange));\n         }\n         let ident = self.parse_ident();\n         let last_span = self.last_span;\n@@ -3674,7 +3674,7 @@ impl<'a> Parser<'a> {\n \n         let lo = self.span.lo;\n         if self.token.is_keyword(keywords::Let) {\n-            check_expected_item(self, item_attrs[]);\n+            check_expected_item(self, item_attrs.index(&FullRange));\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n             P(spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID)))\n@@ -3683,7 +3683,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, item_attrs[]);\n+            check_expected_item(self, item_attrs.index(&FullRange));\n \n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n@@ -3711,7 +3711,7 @@ impl<'a> Parser<'a> {\n                     let tok_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected {}`(` or `{{`, found `{}`\",\n                                        ident_str,\n-                                       tok_str)[])\n+                                       tok_str).index(&FullRange))\n                 },\n             };\n \n@@ -3759,7 +3759,7 @@ impl<'a> Parser<'a> {\n             }\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n-            let item_err = Parser::expected_item_err(item_attrs[]);\n+            let item_err = Parser::expected_item_err(item_attrs.index(&FullRange));\n             match self.parse_item_or_view_item(item_attrs, false) {\n                 IoviItem(i) => {\n                     let hi = i.span.hi;\n@@ -3803,7 +3803,7 @@ impl<'a> Parser<'a> {\n             let sp = self.span;\n             let tok = self.this_token_to_string();\n             self.span_fatal_help(sp,\n-                                 format!(\"expected `{{`, found `{}`\", tok)[],\n+                                 format!(\"expected `{{`, found `{}`\", tok).index(&FullRange),\n                                  \"place this code inside a block\");\n         }\n \n@@ -3857,13 +3857,13 @@ impl<'a> Parser<'a> {\n         while self.token != token::CloseDelim(token::Brace) {\n             // parsing items even when they're not allowed lets us give\n             // better error messages and recover more gracefully.\n-            attributes_box.push_all(self.parse_outer_attributes()[]);\n+            attributes_box.push_all(self.parse_outer_attributes().index(&FullRange));\n             match self.token {\n                 token::Semi => {\n                     if !attributes_box.is_empty() {\n                         let last_span = self.last_span;\n                         self.span_err(last_span,\n-                                      Parser::expected_item_err(attributes_box[]));\n+                                      Parser::expected_item_err(attributes_box.index(&FullRange)));\n                         attributes_box = Vec::new();\n                     }\n                     self.bump(); // empty\n@@ -3955,7 +3955,7 @@ impl<'a> Parser<'a> {\n         if !attributes_box.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attributes_box[]));\n+                          Parser::expected_item_err(attributes_box.index(&FullRange)));\n         }\n \n         let hi = self.span.hi;\n@@ -4399,7 +4399,7 @@ impl<'a> Parser<'a> {\n             _ => {\n                 let token_str = self.this_token_to_string();\n                 self.fatal(format!(\"expected `self`, found `{}`\",\n-                                   token_str)[])\n+                                   token_str).index(&FullRange))\n             }\n         }\n     }\n@@ -4553,7 +4553,7 @@ impl<'a> Parser<'a> {\n                 _ => {\n                     let token_str = self.this_token_to_string();\n                     self.fatal(format!(\"expected `,` or `)`, found `{}`\",\n-                                       token_str)[])\n+                                       token_str).index(&FullRange))\n                 }\n             }\n             }\n@@ -4729,7 +4729,7 @@ impl<'a> Parser<'a> {\n                 let (inner_attrs, body) = self.parse_inner_attrs_and_block();\n                 let body_span = body.span;\n                 let mut new_attrs = attrs;\n-                new_attrs.push_all(inner_attrs[]);\n+                new_attrs.push_all(inner_attrs.index(&FullRange));\n                 (ast::MethDecl(ident,\n                                generics,\n                                abi,\n@@ -4948,7 +4948,7 @@ impl<'a> Parser<'a> {\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone()))[]);\n+                    token::get_ident(class_name.clone())).index(&FullRange));\n             }\n \n             self.bump();\n@@ -4987,7 +4987,7 @@ impl<'a> Parser<'a> {\n             if fields.len() == 0 {\n                 self.fatal(format!(\"unit-like struct definition should be \\\n                     written as `struct {};`\",\n-                    token::get_ident(class_name.clone()))[]);\n+                    token::get_ident(class_name.clone())).index(&FullRange));\n             }\n \n             self.parse_where_clause(generics);\n@@ -5002,7 +5002,7 @@ impl<'a> Parser<'a> {\n         } else {\n             let token_str = self.this_token_to_string();\n             self.fatal(format!(\"expected `where`, `{}`, `(`, or `;` after struct \\\n-                name, found `{}`\", \"{\", token_str)[]);\n+                name, found `{}`\", \"{\", token_str).index(&FullRange));\n         }\n     }\n \n@@ -5022,7 +5022,7 @@ impl<'a> Parser<'a> {\n                 let token_str = self.this_token_to_string();\n                 self.span_fatal_help(span,\n                                      format!(\"expected `,`, or `}}`, found `{}`\",\n-                                             token_str)[],\n+                                             token_str).index(&FullRange),\n                                      \"struct fields should be separated by commas\")\n             }\n         }\n@@ -5109,7 +5109,7 @@ impl<'a> Parser<'a> {\n             let mut attrs = self.parse_outer_attributes();\n             if first {\n                 let mut tmp = attrs_remaining.clone();\n-                tmp.push_all(attrs[]);\n+                tmp.push_all(attrs.index(&FullRange));\n                 attrs = tmp;\n                 first = false;\n             }\n@@ -5126,7 +5126,7 @@ impl<'a> Parser<'a> {\n               _ => {\n                   let token_str = self.this_token_to_string();\n                   self.fatal(format!(\"expected item, found `{}`\",\n-                                     token_str)[])\n+                                     token_str).index(&FullRange))\n               }\n             }\n         }\n@@ -5135,7 +5135,7 @@ impl<'a> Parser<'a> {\n             // We parsed attributes for the first item but didn't find it\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attrs_remaining[]));\n+                          Parser::expected_item_err(attrs_remaining.index(&FullRange)));\n         }\n \n         ast::Mod {\n@@ -5205,7 +5205,7 @@ impl<'a> Parser<'a> {\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n         prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(self.mod_path_stack[]);\n+        let mod_path = Path::new(\".\").join_many(self.mod_path_stack.index(&FullRange));\n         let dir_path = prefix.join(&mod_path);\n         let mod_string = token::get_ident(id);\n         let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name(\n@@ -5215,8 +5215,8 @@ impl<'a> Parser<'a> {\n                 let mod_name = mod_string.get().to_string();\n                 let default_path_str = format!(\"{}.rs\", mod_name);\n                 let secondary_path_str = format!(\"{}/mod.rs\", mod_name);\n-                let default_path = dir_path.join(default_path_str[]);\n-                let secondary_path = dir_path.join(secondary_path_str[]);\n+                let default_path = dir_path.join(default_path_str.index(&FullRange));\n+                let secondary_path = dir_path.join(secondary_path_str.index(&FullRange));\n                 let default_exists = default_path.exists();\n                 let secondary_exists = secondary_path.exists();\n \n@@ -5231,13 +5231,13 @@ impl<'a> Parser<'a> {\n                                    format!(\"maybe move this module `{0}` \\\n                                             to its own directory via \\\n                                             `{0}/mod.rs`\",\n-                                           this_module)[]);\n+                                           this_module).index(&FullRange));\n                     if default_exists || secondary_exists {\n                         self.span_note(id_sp,\n                                        format!(\"... or maybe `use` the module \\\n                                                 `{}` instead of possibly \\\n                                                 redeclaring it\",\n-                                               mod_name)[]);\n+                                               mod_name).index(&FullRange));\n                     }\n                     self.abort_if_errors();\n                 }\n@@ -5248,12 +5248,12 @@ impl<'a> Parser<'a> {\n                     (false, false) => {\n                         self.span_fatal_help(id_sp,\n                                              format!(\"file not found for module `{}`\",\n-                                                     mod_name)[],\n+                                                     mod_name).index(&FullRange),\n                                              format!(\"name the file either {} or {} inside \\\n                                                      the directory {}\",\n                                                      default_path_str,\n                                                      secondary_path_str,\n-                                                     dir_path.display())[]);\n+                                                     dir_path.display()).index(&FullRange));\n                     }\n                     (true, true) => {\n                         self.span_fatal_help(\n@@ -5262,7 +5262,7 @@ impl<'a> Parser<'a> {\n                                      and {}\",\n                                     mod_name,\n                                     default_path_str,\n-                                    secondary_path_str)[],\n+                                    secondary_path_str).index(&FullRange),\n                             \"delete or rename one of them to remove the ambiguity\");\n                     }\n                 }\n@@ -5284,11 +5284,11 @@ impl<'a> Parser<'a> {\n                 let mut err = String::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in included_mod_stack.slice(i, len).iter() {\n-                    err.push_str(p.display().as_cow()[]);\n+                    err.push_str(p.display().as_cow().index(&FullRange));\n                     err.push_str(\" -> \");\n                 }\n-                err.push_str(path.display().as_cow()[]);\n-                self.span_fatal(id_sp, err[]);\n+                err.push_str(path.display().as_cow().index(&FullRange));\n+                self.span_fatal(id_sp, err.index(&FullRange));\n             }\n             None => ()\n         }\n@@ -5369,7 +5369,7 @@ impl<'a> Parser<'a> {\n         if !attrs_remaining.is_empty() {\n             let last_span = self.last_span;\n             self.span_err(last_span,\n-                          Parser::expected_item_err(attrs_remaining[]));\n+                          Parser::expected_item_err(attrs_remaining.index(&FullRange)));\n         }\n         assert!(self.token == token::CloseDelim(token::Brace));\n         ast::ForeignMod {\n@@ -5410,7 +5410,7 @@ impl<'a> Parser<'a> {\n                     self.span_help(span,\n                                    format!(\"perhaps you meant to enclose the crate name `{}` in \\\n                                            a string?\",\n-                                          the_ident.as_str())[]);\n+                                          the_ident.as_str()).index(&FullRange));\n                     None\n                 } else {\n                     None\n@@ -5436,7 +5436,7 @@ impl<'a> Parser<'a> {\n                 self.span_fatal(span,\n                                 format!(\"expected extern crate name but \\\n                                          found `{}`\",\n-                                        token_str)[]);\n+                                        token_str).index(&FullRange));\n             }\n         };\n \n@@ -5534,7 +5534,7 @@ impl<'a> Parser<'a> {\n                     self.span_err(start_span,\n                         format!(\"unit-like struct variant should be written \\\n                                  without braces, as `{},`\",\n-                                token::get_ident(ident))[]);\n+                                token::get_ident(ident)).index(&FullRange));\n                 }\n                 kind = StructVariantKind(struct_def);\n             } else if self.check(&token::OpenDelim(token::Paren)) {\n@@ -5619,7 +5619,7 @@ impl<'a> Parser<'a> {\n                             format!(\"illegal ABI: expected one of [{}], \\\n                                      found `{}`\",\n                                     abi::all_names().connect(\", \"),\n-                                    the_string)[]);\n+                                    the_string).index(&FullRange));\n                         None\n                     }\n                 }\n@@ -5681,7 +5681,7 @@ impl<'a> Parser<'a> {\n                                  format!(\"`extern mod` is obsolete, use \\\n                                           `extern crate` instead \\\n                                           to refer to external \\\n-                                          crates.\")[])\n+                                          crates.\").index(&FullRange))\n                 }\n                 return self.parse_item_extern_crate(lo, visibility, attrs);\n             }\n@@ -5709,7 +5709,7 @@ impl<'a> Parser<'a> {\n             let token_str = self.this_token_to_string();\n             self.span_fatal(span,\n                             format!(\"expected `{}` or `fn`, found `{}`\", \"{\",\n-                                    token_str)[]);\n+                                    token_str).index(&FullRange));\n         }\n \n         if self.eat_keyword(keywords::Virtual) {\n@@ -5822,7 +5822,7 @@ impl<'a> Parser<'a> {\n         if self.eat_keyword(keywords::Mod) {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) =\n-                self.parse_item_mod(attrs[]);\n+                self.parse_item_mod(attrs.index(&FullRange));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -6162,7 +6162,7 @@ impl<'a> Parser<'a> {\n                                   macros_allowed: bool)\n                                   -> ParsedItemsAndViewItems {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(self.parse_outer_attributes()[]);\n+        attrs.push_all(self.parse_outer_attributes().index(&FullRange));\n         // First, parse view items.\n         let mut view_items : Vec<ast::ViewItem> = Vec::new();\n         let mut items = Vec::new();\n@@ -6244,7 +6244,7 @@ impl<'a> Parser<'a> {\n                            macros_allowed: bool)\n         -> ParsedItemsAndViewItems {\n         let mut attrs = first_item_attrs;\n-        attrs.push_all(self.parse_outer_attributes()[]);\n+        attrs.push_all(self.parse_outer_attributes().index(&FullRange));\n         let mut foreign_items = Vec::new();\n         loop {\n             match self.parse_foreign_item(attrs, macros_allowed) {"}, {"sha": "ca683a5647246bbc6778b0a1c46f343f701a567f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -479,7 +479,7 @@ macro_rules! declare_special_idents_and_keywords {(\n         $(init_vec.push($si_str);)*\n         $(init_vec.push($sk_str);)*\n         $(init_vec.push($rk_str);)*\n-        interner::StrInterner::prefill(init_vec[])\n+        interner::StrInterner::prefill(init_vec.index(&FullRange))\n     }\n }}\n \n@@ -628,7 +628,7 @@ impl InternedString {\n \n     #[inline]\n     pub fn get<'a>(&'a self) -> &'a str {\n-        self.string[]\n+        self.string.index(&FullRange)\n     }\n }\n \n@@ -652,37 +652,37 @@ impl BytesContainer for InternedString {\n \n impl fmt::Show for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.string[])\n+        write!(f, \"{}\", self.string.index(&FullRange))\n     }\n }\n \n impl<'a> PartialEq<&'a str> for InternedString {\n     #[inline(always)]\n     fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(self.string[], *other)\n+        PartialEq::eq(self.string.index(&FullRange), *other)\n     }\n     #[inline(always)]\n     fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(self.string[], *other)\n+        PartialEq::ne(self.string.index(&FullRange), *other)\n     }\n }\n \n impl<'a> PartialEq<InternedString > for &'a str {\n     #[inline(always)]\n     fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, other.string[])\n+        PartialEq::eq(*self, other.string.index(&FullRange))\n     }\n     #[inline(always)]\n     fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, other.string[])\n+        PartialEq::ne(*self, other.string.index(&FullRange))\n     }\n }\n \n #[cfg(stage0)]\n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n         Ok(get_name(get_ident_interner().intern(\n-                    try!(d.read_str())[])))\n+                    try!(d.read_str()).index(&FullRange))))\n     }\n }\n \n@@ -697,7 +697,7 @@ impl Decodable for InternedString {\n #[cfg(stage0)]\n impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n-        s.emit_str(self.string[])\n+        s.emit_str(self.string.index(&FullRange))\n     }\n }\n "}, {"sha": "52306075c21ec37740b3a57bb095b3c0b092d645", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -140,7 +140,7 @@ pub fn buf_str(toks: Vec<Token>,\n         }\n         s.push_str(format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(toks[i].clone()))[]);\n+                           tok_str(toks[i].clone())).index(&FullRange));\n         i += 1u;\n         i %= n;\n     }\n@@ -602,7 +602,7 @@ impl Printer {\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(s[])\n+            self.print_str(s.index(&FullRange))\n           }\n           Eof => {\n             // Eof should never get here."}, {"sha": "9a38f6c8ac325d0dc928912989b10004f859c8a5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -114,7 +114,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                                       out,\n                                       ann,\n                                       is_expanded);\n-    try!(s.print_mod(&krate.module, krate.attrs[]));\n+    try!(s.print_mod(&krate.module, krate.attrs.index(&FullRange)));\n     try!(s.print_remaining_comments());\n     eof(&mut s.s)\n }\n@@ -580,7 +580,7 @@ impl<'a> State<'a> {\n     pub fn synth_comment(&mut self, text: String) -> IoResult<()> {\n         try!(word(&mut self.s, \"/*\"));\n         try!(space(&mut self.s));\n-        try!(word(&mut self.s, text[]));\n+        try!(word(&mut self.s, text.index(&FullRange)));\n         try!(space(&mut self.s));\n         word(&mut self.s, \"*/\")\n     }\n@@ -685,7 +685,7 @@ impl<'a> State<'a> {\n             }\n             ast::TyTup(ref elts) => {\n                 try!(self.popen());\n-                try!(self.commasep(Inconsistent, elts[],\n+                try!(self.commasep(Inconsistent, elts.index(&FullRange),\n                                    |s, ty| s.print_type(&**ty)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -721,10 +721,10 @@ impl<'a> State<'a> {\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n                 try!(self.print_type(&**ty));\n-                try!(self.print_bounds(\"+\", bounds[]));\n+                try!(self.print_bounds(\"+\", bounds.index(&FullRange)));\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                try!(self.print_bounds(\"\", bounds[]));\n+                try!(self.print_bounds(\"\", bounds.index(&FullRange)));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n@@ -759,7 +759,7 @@ impl<'a> State<'a> {\n                               item: &ast::ForeignItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs[]));\n+        try!(self.print_outer_attributes(item.attrs.index(&FullRange)));\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 try!(self.print_fn(&**decl, None, abi::Rust, item.ident, generics,\n@@ -770,7 +770,7 @@ impl<'a> State<'a> {\n             }\n             ast::ForeignItemStatic(ref t, m) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"static\")[]));\n+                                                    \"static\").index(&FullRange)));\n                 if m {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -787,7 +787,7 @@ impl<'a> State<'a> {\n     fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n                              -> IoResult<()>\n     {\n-        try!(self.print_outer_attributes(typedef.attrs[]));\n+        try!(self.print_outer_attributes(typedef.attrs.index(&FullRange)));\n         try!(self.word_space(\"type\"));\n         try!(self.print_ty_param(&typedef.ty_param));\n         word(&mut self.s, \";\")\n@@ -806,12 +806,12 @@ impl<'a> State<'a> {\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs[]));\n+        try!(self.print_outer_attributes(item.attrs.index(&FullRange)));\n         try!(self.ann.pre(self, NodeItem(item)));\n         match item.node {\n             ast::ItemStatic(ref ty, m, ref expr) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"static\")[]));\n+                                                    \"static\").index(&FullRange)));\n                 if m == ast::MutMutable {\n                     try!(self.word_space(\"mut\"));\n                 }\n@@ -828,7 +828,7 @@ impl<'a> State<'a> {\n             }\n             ast::ItemConst(ref ty, ref expr) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"const\")[]));\n+                                                    \"const\").index(&FullRange)));\n                 try!(self.print_ident(item.ident));\n                 try!(self.word_space(\":\"));\n                 try!(self.print_type(&**ty));\n@@ -851,29 +851,29 @@ impl<'a> State<'a> {\n                     item.vis\n                 ));\n                 try!(word(&mut self.s, \" \"));\n-                try!(self.print_block_with_attrs(&**body, item.attrs[]));\n+                try!(self.print_block_with_attrs(&**body, item.attrs.index(&FullRange)));\n             }\n             ast::ItemMod(ref _mod) => {\n                 try!(self.head(visibility_qualified(item.vis,\n-                                                    \"mod\")[]));\n+                                                    \"mod\").index(&FullRange)));\n                 try!(self.print_ident(item.ident));\n                 try!(self.nbsp());\n                 try!(self.bopen());\n-                try!(self.print_mod(_mod, item.attrs[]));\n+                try!(self.print_mod(_mod, item.attrs.index(&FullRange)));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemForeignMod(ref nmod) => {\n                 try!(self.head(\"extern\"));\n-                try!(self.word_nbsp(nmod.abi.to_string()[]));\n+                try!(self.word_nbsp(nmod.abi.to_string().index(&FullRange)));\n                 try!(self.bopen());\n-                try!(self.print_foreign_mod(nmod, item.attrs[]));\n+                try!(self.print_foreign_mod(nmod, item.attrs.index(&FullRange)));\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemTy(ref ty, ref params) => {\n                 try!(self.ibox(indent_unit));\n                 try!(self.ibox(0u));\n                 try!(self.word_nbsp(visibility_qualified(item.vis,\n-                                                         \"type\")[]));\n+                                                         \"type\").index(&FullRange)));\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(params));\n                 try!(self.end()); // end the inner ibox\n@@ -895,7 +895,7 @@ impl<'a> State<'a> {\n                 ));\n             }\n             ast::ItemStruct(ref struct_def, ref generics) => {\n-                try!(self.head(visibility_qualified(item.vis,\"struct\")[]));\n+                try!(self.head(visibility_qualified(item.vis,\"struct\").index(&FullRange)));\n                 try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n \n@@ -936,7 +936,7 @@ impl<'a> State<'a> {\n \n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n-                try!(self.print_inner_attributes(item.attrs[]));\n+                try!(self.print_inner_attributes(item.attrs.index(&FullRange)));\n                 for impl_item in impl_items.iter() {\n                     match *impl_item {\n                         ast::MethodImplItem(ref meth) => {\n@@ -967,7 +967,7 @@ impl<'a> State<'a> {\n                         real_bounds.push(b);\n                     }\n                 }\n-                try!(self.print_bounds(\":\", real_bounds[]));\n+                try!(self.print_bounds(\":\", real_bounds.index(&FullRange)));\n                 try!(self.print_where_clause(generics));\n                 try!(word(&mut self.s, \" \"));\n                 try!(self.bopen());\n@@ -985,7 +985,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(tts[]));\n+                try!(self.print_tts(tts.index(&FullRange)));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end());\n@@ -1019,12 +1019,12 @@ impl<'a> State<'a> {\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n                           visibility: ast::Visibility) -> IoResult<()> {\n-        try!(self.head(visibility_qualified(visibility, \"enum\")[]));\n+        try!(self.head(visibility_qualified(visibility, \"enum\").index(&FullRange)));\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n         try!(self.print_where_clause(generics));\n         try!(space(&mut self.s));\n-        self.print_variants(enum_definition.variants[], span)\n+        self.print_variants(enum_definition.variants.index(&FullRange), span)\n     }\n \n     pub fn print_variants(&mut self,\n@@ -1034,7 +1034,7 @@ impl<'a> State<'a> {\n         for v in variants.iter() {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n-            try!(self.print_outer_attributes(v.node.attrs[]));\n+            try!(self.print_outer_attributes(v.node.attrs.index(&FullRange)));\n             try!(self.ibox(indent_unit));\n             try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n@@ -1062,7 +1062,7 @@ impl<'a> State<'a> {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());\n                 try!(self.commasep(\n-                    Inconsistent, struct_def.fields[],\n+                    Inconsistent, struct_def.fields.index(&FullRange),\n                     |s, field| {\n                         match field.node.kind {\n                             ast::NamedField(..) => panic!(\"unexpected named field\"),\n@@ -1092,7 +1092,7 @@ impl<'a> State<'a> {\n                     ast::NamedField(ident, visibility) => {\n                         try!(self.hardbreak_if_not_bol());\n                         try!(self.maybe_print_comment(field.span.lo));\n-                        try!(self.print_outer_attributes(field.node.attrs[]));\n+                        try!(self.print_outer_attributes(field.node.attrs.index(&FullRange)));\n                         try!(self.print_visibility(visibility));\n                         try!(self.print_ident(ident));\n                         try!(self.word_nbsp(\":\"));\n@@ -1116,7 +1116,7 @@ impl<'a> State<'a> {\n     pub fn print_tt(&mut self, tt: &ast::TokenTree) -> IoResult<()> {\n         match *tt {\n             ast::TtToken(_, ref tk) => {\n-                try!(word(&mut self.s, token_to_string(tk)[]));\n+                try!(word(&mut self.s, token_to_string(tk).index(&FullRange)));\n                 match *tk {\n                     parse::token::DocComment(..) => {\n                         hardbreak(&mut self.s)\n@@ -1125,11 +1125,11 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::TtDelimited(_, ref delimed) => {\n-                try!(word(&mut self.s, token_to_string(&delimed.open_token())[]));\n+                try!(word(&mut self.s, token_to_string(&delimed.open_token()).index(&FullRange)));\n                 try!(space(&mut self.s));\n-                try!(self.print_tts(delimed.tts[]));\n+                try!(self.print_tts(delimed.tts.index(&FullRange)));\n                 try!(space(&mut self.s));\n-                word(&mut self.s, token_to_string(&delimed.close_token())[])\n+                word(&mut self.s, token_to_string(&delimed.close_token()).index(&FullRange))\n             },\n             ast::TtSequence(_, ref seq) => {\n                 try!(word(&mut self.s, \"$(\"));\n@@ -1139,7 +1139,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \")\"));\n                 match seq.separator {\n                     Some(ref tk) => {\n-                        try!(word(&mut self.s, token_to_string(tk)[]));\n+                        try!(word(&mut self.s, token_to_string(tk).index(&FullRange)));\n                     }\n                     None => {},\n                 }\n@@ -1170,7 +1170,7 @@ impl<'a> State<'a> {\n                 if !args.is_empty() {\n                     try!(self.popen());\n                     try!(self.commasep(Consistent,\n-                                       args[],\n+                                       args.index(&FullRange),\n                                        |s, arg| s.print_type(&*arg.ty)));\n                     try!(self.pclose());\n                 }\n@@ -1194,7 +1194,7 @@ impl<'a> State<'a> {\n     pub fn print_ty_method(&mut self, m: &ast::TypeMethod) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(m.span.lo));\n-        try!(self.print_outer_attributes(m.attrs[]));\n+        try!(self.print_outer_attributes(m.attrs.index(&FullRange)));\n         try!(self.print_ty_fn(None,\n                               None,\n                               m.unsafety,\n@@ -1226,7 +1226,7 @@ impl<'a> State<'a> {\n     pub fn print_method(&mut self, meth: &ast::Method) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(meth.span.lo));\n-        try!(self.print_outer_attributes(meth.attrs[]));\n+        try!(self.print_outer_attributes(meth.attrs.index(&FullRange)));\n         match meth.node {\n             ast::MethDecl(ident,\n                           ref generics,\n@@ -1244,7 +1244,7 @@ impl<'a> State<'a> {\n                                    Some(&explicit_self.node),\n                                    vis));\n                 try!(word(&mut self.s, \" \"));\n-                self.print_block_with_attrs(&**body, meth.attrs[])\n+                self.print_block_with_attrs(&**body, meth.attrs.index(&FullRange))\n             },\n             ast::MethMac(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                             ..}) => {\n@@ -1253,7 +1253,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.cbox(indent_unit));\n                 try!(self.popen());\n-                try!(self.print_tts(tts[]));\n+                try!(self.print_tts(tts.index(&FullRange)));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n                 self.end()\n@@ -1520,7 +1520,7 @@ impl<'a> State<'a> {\n             ast::ExprVec(ref exprs) => {\n                 try!(self.ibox(indent_unit));\n                 try!(word(&mut self.s, \"[\"));\n-                try!(self.commasep_exprs(Inconsistent, exprs[]));\n+                try!(self.commasep_exprs(Inconsistent, exprs.index(&FullRange)));\n                 try!(word(&mut self.s, \"]\"));\n                 try!(self.end());\n             }\n@@ -1540,7 +1540,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"{\"));\n                 try!(self.commasep_cmnt(\n                     Consistent,\n-                    fields[],\n+                    fields.index(&FullRange),\n                     |s, field| {\n                         try!(s.ibox(indent_unit));\n                         try!(s.print_ident(field.ident.node));\n@@ -1566,15 +1566,15 @@ impl<'a> State<'a> {\n             }\n             ast::ExprTup(ref exprs) => {\n                 try!(self.popen());\n-                try!(self.commasep_exprs(Inconsistent, exprs[]));\n+                try!(self.commasep_exprs(Inconsistent, exprs.index(&FullRange)));\n                 if exprs.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n                 }\n                 try!(self.pclose());\n             }\n             ast::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_maybe_paren(&**func));\n-                try!(self.print_call_post(args[]));\n+                try!(self.print_call_post(args.index(&FullRange)));\n             }\n             ast::ExprMethodCall(ident, ref tys, ref args) => {\n                 let base_args = args.slice_from(1);\n@@ -1583,7 +1583,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(ident.node));\n                 if tys.len() > 0u {\n                     try!(word(&mut self.s, \"::<\"));\n-                    try!(self.commasep(Inconsistent, tys[],\n+                    try!(self.commasep(Inconsistent, tys.index(&FullRange),\n                                        |s, ty| s.print_type(&**ty)));\n                     try!(word(&mut self.s, \">\"));\n                 }\n@@ -1780,11 +1780,11 @@ impl<'a> State<'a> {\n                 try!(self.print_string(a.asm.get(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.outputs[],\n+                try!(self.commasep(Inconsistent, a.outputs.index(&FullRange),\n                                    |s, &(ref co, ref o, is_rw)| {\n                     match co.get().slice_shift_char() {\n                         Some(('=', operand)) if is_rw => {\n-                            try!(s.print_string(format!(\"+{}\", operand)[],\n+                            try!(s.print_string(format!(\"+{}\", operand).index(&FullRange),\n                                                 ast::CookedStr))\n                         }\n                         _ => try!(s.print_string(co.get(), ast::CookedStr))\n@@ -1797,7 +1797,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.inputs[],\n+                try!(self.commasep(Inconsistent, a.inputs.index(&FullRange),\n                                    |s, &(ref co, ref o)| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     try!(s.popen());\n@@ -1808,7 +1808,7 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, a.clobbers[],\n+                try!(self.commasep(Inconsistent, a.clobbers.index(&FullRange),\n                                    |s, co| {\n                     try!(s.print_string(co.get(), ast::CookedStr));\n                     Ok(())\n@@ -1882,15 +1882,15 @@ impl<'a> State<'a> {\n     pub fn print_ident(&mut self, ident: ast::Ident) -> IoResult<()> {\n         if self.encode_idents_with_hygiene {\n             let encoded = ident.encode_with_hygiene();\n-            try!(word(&mut self.s, encoded[]))\n+            try!(word(&mut self.s, encoded.index(&FullRange)))\n         } else {\n             try!(word(&mut self.s, token::get_ident(ident).get()))\n         }\n         self.ann.post(self, NodeIdent(&ident))\n     }\n \n     pub fn print_uint(&mut self, i: uint) -> IoResult<()> {\n-        word(&mut self.s, i.to_string()[])\n+        word(&mut self.s, i.to_string().index(&FullRange))\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> IoResult<()> {\n@@ -1964,7 +1964,7 @@ impl<'a> State<'a> {\n                     }\n                     try!(self.commasep(\n                         Inconsistent,\n-                        data.types[],\n+                        data.types.index(&FullRange),\n                         |s, ty| s.print_type(&**ty)));\n                         comma = true;\n                 }\n@@ -1987,7 +1987,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \"(\"));\n                 try!(self.commasep(\n                     Inconsistent,\n-                    data.inputs[],\n+                    data.inputs.index(&FullRange),\n                     |s, ty| s.print_type(&**ty)));\n                 try!(word(&mut self.s, \")\"));\n \n@@ -2040,7 +2040,7 @@ impl<'a> State<'a> {\n                     Some(ref args) => {\n                         if !args.is_empty() {\n                             try!(self.popen());\n-                            try!(self.commasep(Inconsistent, args[],\n+                            try!(self.commasep(Inconsistent, args.index(&FullRange),\n                                               |s, p| s.print_pat(&**p)));\n                             try!(self.pclose());\n                         }\n@@ -2052,7 +2052,7 @@ impl<'a> State<'a> {\n                 try!(self.nbsp());\n                 try!(self.word_space(\"{\"));\n                 try!(self.commasep_cmnt(\n-                    Consistent, fields[],\n+                    Consistent, fields.index(&FullRange),\n                     |s, f| {\n                         try!(s.cbox(indent_unit));\n                         if !f.node.is_shorthand {\n@@ -2073,7 +2073,7 @@ impl<'a> State<'a> {\n             ast::PatTup(ref elts) => {\n                 try!(self.popen());\n                 try!(self.commasep(Inconsistent,\n-                                   elts[],\n+                                   elts.index(&FullRange),\n                                    |s, p| s.print_pat(&**p)));\n                 if elts.len() == 1 {\n                     try!(word(&mut self.s, \",\"));\n@@ -2101,7 +2101,7 @@ impl<'a> State<'a> {\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.commasep(Inconsistent,\n-                                   before[],\n+                                   before.index(&FullRange),\n                                    |s, p| s.print_pat(&**p)));\n                 for p in slice.iter() {\n                     if !before.is_empty() { try!(self.word_space(\",\")); }\n@@ -2115,7 +2115,7 @@ impl<'a> State<'a> {\n                     if !after.is_empty() { try!(self.word_space(\",\")); }\n                 }\n                 try!(self.commasep(Inconsistent,\n-                                   after[],\n+                                   after.index(&FullRange),\n                                    |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n@@ -2132,7 +2132,7 @@ impl<'a> State<'a> {\n         }\n         try!(self.cbox(indent_unit));\n         try!(self.ibox(0u));\n-        try!(self.print_outer_attributes(arm.attrs[]));\n+        try!(self.print_outer_attributes(arm.attrs.index(&FullRange)));\n         let mut first = true;\n         for p in arm.pats.iter() {\n             if first {\n@@ -2232,7 +2232,7 @@ impl<'a> State<'a> {\n \n         // HACK(eddyb) ignore the separately printed self argument.\n         let args = if first {\n-            decl.inputs[]\n+            decl.inputs.index(&FullRange)\n         } else {\n             decl.inputs.slice_from(1)\n         };\n@@ -2398,7 +2398,7 @@ impl<'a> State<'a> {\n             ints.push(i);\n         }\n \n-        try!(self.commasep(Inconsistent, ints[], |s, &idx| {\n+        try!(self.commasep(Inconsistent, ints.index(&FullRange), |s, &idx| {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = &generics.lifetimes[idx];\n                 s.print_lifetime_def(lifetime)\n@@ -2415,7 +2415,7 @@ impl<'a> State<'a> {\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n         try!(self.print_ident(param.ident));\n-        try!(self.print_bounds(\":\", param.bounds[]));\n+        try!(self.print_bounds(\":\", param.bounds.index(&FullRange)));\n         match param.default {\n             Some(ref default) => {\n                 try!(space(&mut self.s));\n@@ -2491,7 +2491,7 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, name.get()));\n                 try!(self.popen());\n                 try!(self.commasep(Consistent,\n-                                   items[],\n+                                   items.index(&FullRange),\n                                    |s, i| s.print_meta_item(&**i)));\n                 try!(self.pclose());\n             }\n@@ -2527,7 +2527,7 @@ impl<'a> State<'a> {\n                     try!(self.print_path(path, false));\n                     try!(word(&mut self.s, \"::{\"));\n                 }\n-                try!(self.commasep(Inconsistent, idents[], |s, w| {\n+                try!(self.commasep(Inconsistent, idents.index(&FullRange), |s, w| {\n                     match w.node {\n                         ast::PathListIdent { name, .. } => {\n                             s.print_ident(name)\n@@ -2545,7 +2545,7 @@ impl<'a> State<'a> {\n     pub fn print_view_item(&mut self, item: &ast::ViewItem) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(item.span.lo));\n-        try!(self.print_outer_attributes(item.attrs[]));\n+        try!(self.print_outer_attributes(item.attrs.index(&FullRange)));\n         try!(self.print_visibility(item.vis));\n         match item.node {\n             ast::ViewItemExternCrate(id, ref optional_path, _) => {\n@@ -2687,7 +2687,7 @@ impl<'a> State<'a> {\n             try!(self.pclose());\n         }\n \n-        try!(self.print_bounds(\":\", bounds[]));\n+        try!(self.print_bounds(\":\", bounds.index(&FullRange)));\n \n         try!(self.print_fn_output(decl));\n \n@@ -2746,7 +2746,7 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(lit.span.lo));\n         match self.next_lit(lit.span.lo) {\n             Some(ref ltrl) => {\n-                return word(&mut self.s, (*ltrl).lit[]);\n+                return word(&mut self.s, (*ltrl).lit.index(&FullRange));\n             }\n             _ => ()\n         }\n@@ -2756,35 +2756,35 @@ impl<'a> State<'a> {\n                 let mut res = String::from_str(\"b'\");\n                 ascii::escape_default(byte, |c| res.push(c as char));\n                 res.push('\\'');\n-                word(&mut self.s, res[])\n+                word(&mut self.s, res.index(&FullRange))\n             }\n             ast::LitChar(ch) => {\n                 let mut res = String::from_str(\"'\");\n                 for c in ch.escape_default() {\n                     res.push(c);\n                 }\n                 res.push('\\'');\n-                word(&mut self.s, res[])\n+                word(&mut self.s, res.index(&FullRange))\n             }\n             ast::LitInt(i, t) => {\n                 match t {\n                     ast::SignedIntLit(st, ast::Plus) => {\n                         word(&mut self.s,\n-                             ast_util::int_ty_to_string(st, Some(i as i64))[])\n+                             ast_util::int_ty_to_string(st, Some(i as i64)).index(&FullRange))\n                     }\n                     ast::SignedIntLit(st, ast::Minus) => {\n                         let istr = ast_util::int_ty_to_string(st, Some(-(i as i64)));\n                         word(&mut self.s,\n-                             format!(\"-{}\", istr)[])\n+                             format!(\"-{}\", istr).index(&FullRange))\n                     }\n                     ast::UnsignedIntLit(ut) => {\n-                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i))[])\n+                        word(&mut self.s, ast_util::uint_ty_to_string(ut, Some(i)).index(&FullRange))\n                     }\n                     ast::UnsuffixedIntLit(ast::Plus) => {\n-                        word(&mut self.s, format!(\"{}\", i)[])\n+                        word(&mut self.s, format!(\"{}\", i).index(&FullRange))\n                     }\n                     ast::UnsuffixedIntLit(ast::Minus) => {\n-                        word(&mut self.s, format!(\"-{}\", i)[])\n+                        word(&mut self.s, format!(\"-{}\", i).index(&FullRange))\n                     }\n                 }\n             }\n@@ -2793,7 +2793,7 @@ impl<'a> State<'a> {\n                      format!(\n                          \"{}{}\",\n                          f.get(),\n-                         ast_util::float_ty_to_string(t)[])[])\n+                         ast_util::float_ty_to_string(t).index(&FullRange)).index(&FullRange))\n             }\n             ast::LitFloatUnsuffixed(ref f) => word(&mut self.s, f.get()),\n             ast::LitBool(val) => {\n@@ -2805,7 +2805,7 @@ impl<'a> State<'a> {\n                     ascii::escape_default(ch as u8,\n                                           |ch| escaped.push(ch as char));\n                 }\n-                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped)[])\n+                word(&mut self.s, format!(\"b\\\"{}\\\"\", escaped).index(&FullRange))\n             }\n         }\n     }\n@@ -2846,7 +2846,7 @@ impl<'a> State<'a> {\n             comments::Mixed => {\n                 assert_eq!(cmnt.lines.len(), 1u);\n                 try!(zerobreak(&mut self.s));\n-                try!(word(&mut self.s, cmnt.lines[0][]));\n+                try!(word(&mut self.s, cmnt.lines[0].index(&FullRange)));\n                 zerobreak(&mut self.s)\n             }\n             comments::Isolated => {\n@@ -2855,7 +2855,7 @@ impl<'a> State<'a> {\n                     // Don't print empty lines because they will end up as trailing\n                     // whitespace\n                     if !line.is_empty() {\n-                        try!(word(&mut self.s, line[]));\n+                        try!(word(&mut self.s, line.index(&FullRange)));\n                     }\n                     try!(hardbreak(&mut self.s));\n                 }\n@@ -2864,13 +2864,13 @@ impl<'a> State<'a> {\n             comments::Trailing => {\n                 try!(word(&mut self.s, \" \"));\n                 if cmnt.lines.len() == 1u {\n-                    try!(word(&mut self.s, cmnt.lines[0][]));\n+                    try!(word(&mut self.s, cmnt.lines[0].index(&FullRange)));\n                     hardbreak(&mut self.s)\n                 } else {\n                     try!(self.ibox(0u));\n                     for line in cmnt.lines.iter() {\n                         if !line.is_empty() {\n-                            try!(word(&mut self.s, line[]));\n+                            try!(word(&mut self.s, line.index(&FullRange)));\n                         }\n                         try!(hardbreak(&mut self.s));\n                     }\n@@ -2903,7 +2903,7 @@ impl<'a> State<'a> {\n                          string=st))\n             }\n         };\n-        word(&mut self.s, st[])\n+        word(&mut self.s, st.index(&FullRange))\n     }\n \n     pub fn next_comment(&mut self) -> Option<comments::Comment> {\n@@ -2934,7 +2934,7 @@ impl<'a> State<'a> {\n             Some(abi::Rust) => Ok(()),\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_string()[])\n+                self.word_nbsp(abi.to_string().index(&FullRange))\n             }\n             None => Ok(())\n         }\n@@ -2945,7 +2945,7 @@ impl<'a> State<'a> {\n         match opt_abi {\n             Some(abi) => {\n                 try!(self.word_nbsp(\"extern\"));\n-                self.word_nbsp(abi.to_string()[])\n+                self.word_nbsp(abi.to_string().index(&FullRange))\n             }\n             None => Ok(())\n         }\n@@ -2961,7 +2961,7 @@ impl<'a> State<'a> {\n \n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n-            try!(self.word_nbsp(abi.to_string()[]));\n+            try!(self.word_nbsp(abi.to_string().index(&FullRange)));\n         }\n \n         word(&mut self.s, \"fn\")"}, {"sha": "daa51203287b3744b6b17dcb10c274f454f8e1e3", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -40,7 +40,7 @@ pub fn maybe_inject_prelude(krate: ast::Crate) -> ast::Crate {\n }\n \n fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs[], \"no_std\")\n+    !attr::contains_name(krate.attrs.index(&FullRange), \"no_std\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -56,7 +56,7 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n \n         // The name to use in `extern crate \"name\" as std;`\n         let actual_crate_name = match self.alt_std_name {\n-            Some(ref s) => token::intern_and_get_ident(s[]),\n+            Some(ref s) => token::intern_and_get_ident(s.index(&FullRange)),\n             None => token::intern_and_get_ident(\"std\"),\n         };\n \n@@ -104,7 +104,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n         attr::mark_used(&no_std_attr);\n         krate.attrs.push(no_std_attr);\n \n-        if !no_prelude(krate.attrs[]) {\n+        if !no_prelude(krate.attrs.index(&FullRange)) {\n             // only add `use std::prelude::*;` if there wasn't a\n             // `#![no_implicit_prelude]` at the crate level.\n             // fold_mod() will insert glob path.\n@@ -124,7 +124,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(item.attrs[]) {\n+        if !no_prelude(item.attrs.index(&FullRange)) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree"}, {"sha": "0b2c45ee3a779685a1cd33e917ae736b5ef97f29", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -73,14 +73,14 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(krate.config[], \"test\");\n+    let should_test = attr::contains_name(krate.config.index(&FullRange), \"test\");\n \n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(krate.attrs[],\n+        attr::first_attr_value_str_by_name(krate.attrs.index(&FullRange),\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n@@ -119,7 +119,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             self.cx.path.push(ident);\n         }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path[]));\n+               ast_util::path_name_i(self.cx.path.index(&FullRange)));\n \n         if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n@@ -277,8 +277,8 @@ fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     config::strip_items(krate, |attrs| {\n-        !attr::contains_name(attrs[], \"test\") &&\n-        !attr::contains_name(attrs[], \"bench\")\n+        !attr::contains_name(attrs.index(&FullRange), \"test\") &&\n+        !attr::contains_name(attrs.index(&FullRange), \"bench\")\n     })\n }\n \n@@ -291,7 +291,7 @@ enum HasTestSignature {\n \n \n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(i.attrs[], \"test\");\n+    let has_test_attr = attr::contains_name(i.attrs.index(&FullRange), \"test\");\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n@@ -329,7 +329,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(i.attrs[], \"bench\");\n+    let has_bench_attr = attr::contains_name(i.attrs.index(&FullRange), \"bench\");\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n@@ -384,7 +384,7 @@ We're going to be building a module that looks more or less like:\n mod __test {\n   extern crate test (name = \"test\", vers = \"...\");\n   fn main() {\n-    test::test_main_static(::os::args()[], tests)\n+    test::test_main_static(::os::args().index(&FullRange), tests)\n   }\n \n   static tests : &'static [test::TestDescAndFn] = &[\n@@ -510,8 +510,8 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crate_name(krate.attrs[]) {\n-        Some(ref s) if \"test\" == s.get()[] => true,\n+    match attr::find_crate_name(krate.attrs.index(&FullRange)) {\n+        Some(ref s) if \"test\" == s.get().index(&FullRange) => true,\n         _ => false\n     }\n }\n@@ -551,11 +551,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     // creates $name: $expr\n     let field = |&: name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(path[]));\n+    debug!(\"encoding {}\", ast_util::path_name_i(path.index(&FullRange)));\n \n     // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = ast_util::path_name_i(path[]);\n-    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string[]));\n+    let path_string = ast_util::path_name_i(path.index(&FullRange));\n+    let name_expr = ecx.expr_str(span, token::intern_and_get_ident(path_string.index(&FullRange)));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,"}, {"sha": "93de342d487dccdc32e8c55fcdc576e552c19cf0", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -28,7 +28,7 @@ pub struct Interner<T> {\n     vect: RefCell<Vec<T> >,\n }\n \n-// when traits can extend traits, we should extend index<Name,T> to get []\n+// when traits can extend traits, we should extend index<Name,T> to get .index(&FullRange)\n impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n@@ -109,27 +109,27 @@ impl Eq for RcStr {}\n \n impl Ord for RcStr {\n     fn cmp(&self, other: &RcStr) -> Ordering {\n-        self[].cmp(other[])\n+        self.index(&FullRange).cmp(other.index(&FullRange))\n     }\n }\n \n impl fmt::Show for RcStr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use std::fmt::Show;\n-        self[].fmt(f)\n+        self.index(&FullRange).fmt(f)\n     }\n }\n \n impl BorrowFrom<RcStr> for str {\n     fn borrow_from(owned: &RcStr) -> &str {\n-        owned.string[]\n+        owned.string.index(&FullRange)\n     }\n }\n \n impl Deref for RcStr {\n     type Target = str;\n \n-    fn deref(&self) -> &str { self.string[] }\n+    fn deref(&self) -> &str { self.string.index(&FullRange) }\n }\n \n /// A StrInterner differs from Interner<String> in that it accepts\n@@ -139,7 +139,7 @@ pub struct StrInterner {\n     vect: RefCell<Vec<RcStr> >,\n }\n \n-/// When traits can extend traits, we should extend index<Name,T> to get []\n+/// When traits can extend traits, we should extend index<Name,T> to get .index(&FullRange)\n impl StrInterner {\n     pub fn new() -> StrInterner {\n         StrInterner {"}, {"sha": "71c71017850f274405fe744bcbe0937098b51de1", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -180,7 +180,7 @@ impl<T: Writer+Send> TerminfoTerminal<T> {\n             }\n         };\n \n-        let entry = open(term[]);\n+        let entry = open(term.index(&FullRange));\n         if entry.is_err() {\n             if os::getenv(\"MSYSCON\").map_or(false, |s| {\n                     \"mintty.exe\" == s"}, {"sha": "4617be4f3f63c9f21857adaf8885dfacb243a41a", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -284,13 +284,13 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n \n \n             // Find the offset of the NUL we want to go to\n-            let nulpos = string_table[offset as uint .. string_table_bytes as uint]\n+            let nulpos = string_table.index(&((offset as uint) .. (string_table_bytes as uint)))\n                 .iter().position(|&b| b == 0);\n             match nulpos {\n                 Some(len) => {\n                     string_map.insert(name.to_string(),\n-                                      string_table[offset as uint ..\n-                                          offset as uint + len].to_vec())\n+                                      string_table.index(&((offset as uint) ..\n+                                          (offset as uint + len))).to_vec())\n                 },\n                 None => {\n                     return Err(\"invalid file: missing NUL in \\"}, {"sha": "38be68600798e1f80b599e8e37634c548ce328a7", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -61,13 +61,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     for p in dirs_to_search.iter() {\n         if p.exists() {\n             let f = first_char.to_string();\n-            let newp = p.join_many(&[f[], term]);\n+            let newp = p.join_many(&[f.index(&FullRange), term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n-            let newp = p.join_many(&[f[], term]);\n+            let newp = p.join_many(&[f.index(&FullRange), term]);\n             if newp.exists() {\n                 return Some(box newp);\n             }"}, {"sha": "76df9ea45610d6d860ed49f5a31bdc641a9f8246", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -952,7 +952,7 @@ fn should_sort_failures_before_printing_them() {\n \n     st.write_failures().unwrap();\n     let s = match st.out {\n-        Raw(ref m) => String::from_utf8_lossy(m[]),\n+        Raw(ref m) => String::from_utf8_lossy(m.index(&FullRange)),\n         Pretty(_) => unreachable!()\n     };\n "}, {"sha": "7109dc7948ed5ca9635646163201a0ac9bb3805a", "filename": "src/test/bench/shootout-fasta-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta-redux.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -130,7 +130,7 @@ impl<'a, W: Writer> RepeatFasta<'a, W> {\n         copy_memory(buf.as_mut_slice(), alu);\n         let buf_len = buf.len();\n         copy_memory(buf.slice_mut(alu_len, buf_len),\n-                    alu[..LINE_LEN]);\n+                    alu.index(&(0..LINE_LEN)));\n \n         let mut pos = 0;\n         let mut bytes;\n@@ -206,7 +206,7 @@ impl<'a, W: Writer> RandomFasta<'a, W> {\n         for i in range(0u, chars_left) {\n             buf[i] = self.nextc();\n         }\n-        self.out.write(buf[..chars_left])\n+        self.out.write(buf.index(&(0..chars_left)))\n     }\n }\n "}, {"sha": "65127868b8788f3fd5f4f66121b0772fd76234de", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -247,14 +247,14 @@ fn generate_frequencies(mut input: &[u8], frame: uint) -> Table {\n     // Pull first frame.\n     for _ in range(0, frame) {\n         code = code.push_char(input[0]);\n-        input = input[1..];\n+        input = input.index(&(1..));\n     }\n     frequencies.lookup(code, BumpCallback);\n \n     while input.len() != 0 && input[0] != ('>' as u8) {\n         code = code.rotate(input[0], frame);\n         frequencies.lookup(code, BumpCallback);\n-        input = input[1..];\n+        input = input.index(&(1..));\n     }\n     frequencies\n }"}, {"sha": "79a6dd005a7acca3493a11a845df5f758a7872ec", "filename": "src/test/compile-fail/borrowck-array-double-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -12,7 +12,7 @@ fn f() {\n     let mut a = [box 0i, box 1i];\n     drop(a[0]);\n     a[1] = box 2i;\n-    drop(a[0]); //~ ERROR use of moved value: `a[..]`\n+    drop(a[0]); //~ ERROR use of moved value: `a.index(&(..))`\n }\n \n fn main() {"}, {"sha": "b328ea722a09a8741ffb5fb1d737a16ce4ce5e05", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -14,6 +14,6 @@ fn main() {\n         [1, 2, tail..] => tail,\n         _ => unreachable!()\n     };\n-    a[0] = 0; //~ ERROR cannot assign to `a[..]` because it is borrowed\n+    a[0] = 0; //~ ERROR cannot assign to `a.index(&(..))` because it is borrowed\n     t[0];\n }"}, {"sha": "0d8631788a9e1855ed207e352a257bc058121135", "filename": "src/test/compile-fail/packed-struct-generic-transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpacked-struct-generic-transmute.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -34,6 +34,6 @@ fn main() {\n     let foo = Foo { bar: [1u8, 2, 3, 4, 5], baz: 10i32 };\n     unsafe {\n         let oof: Oof<[u8; 5], i32> = mem::transmute(foo);\n-        println!(\"{} {}\", oof.rab[], oof.zab);\n+        println!(\"{} {}\", oof.rab.index(&FullRange), oof.zab);\n     }\n }"}, {"sha": "26281c2e90754e6738352d1d99c06da0ff116944", "filename": "src/test/compile-fail/slice-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-1.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test slicing expr[..] is an error and gives a helpful error message.\n+// Test slicing expr.index(&(..)) is an error and gives a helpful error message.\n \n struct Foo;\n \n fn main() {\n     let x = Foo;\n-    x[..]; //~ ERROR incorrect slicing expression: `[..]`\n-    //~^ NOTE use `expr[]` to construct a slice of the whole of expr\n+    x.index(&(..)); //~ ERROR incorrect slicing expression: `[..]`\n+    //~^ NOTE use `expr.index(&FullRange)` to construct a slice of the whole of expr\n }"}, {"sha": "1e850d6307eb4e972581e390bf9e6a01d6b1eb1d", "filename": "src/test/compile-fail/slice-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-2.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -16,8 +16,8 @@ struct Foo;\n \n fn main() {\n     let x = Foo;\n-    x[]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    x[Foo..]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    x[..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n-    x[Foo..Foo]; //~ ERROR cannot take a slice of a value with type `Foo`\n+    x.index(&FullRange); //~ ERROR cannot take a slice of a value with type `Foo`\n+    x.index(&(Foo..)); //~ ERROR cannot take a slice of a value with type `Foo`\n+    x.index(&(0..Foo)); //~ ERROR cannot take a slice of a value with type `Foo`\n+    x.index(&(Foo..Foo)); //~ ERROR cannot take a slice of a value with type `Foo`\n }"}, {"sha": "7839013ee2224f9fdb95316ffc61215d8a302b5b", "filename": "src/test/compile-fail/slice-borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-borrow.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -16,6 +16,6 @@ fn main() {\n     let y;\n     {\n         let x: &[int] = &[1, 2, 3, 4, 5]; //~ ERROR borrowed value does not live long enough\n-        y = x[1..];\n+        y = x.index(&(1..));\n     }\n }"}, {"sha": "b7d7ea67f067c975b8421dd5682c54c91a5b9ff0", "filename": "src/test/compile-fail/slice-mut-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut-2.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Can't mutably slice an immutable slice\n     let slice: &mut [int] = &mut [0, 1];\n-    x[2..4] = slice; //~ ERROR cannot borrow\n+    x.index(&(2..4)) = slice; //~ ERROR cannot borrow\n }"}, {"sha": "3d621580f5d4ae1d43dab3479e8324d22634ab18", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -15,5 +15,5 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable.\n-    let y: &mut[_] = x[2..4]; //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutabl\n+    let y: &mut[_] = x.index(&(2..4)); //~ ERROR cannot borrow immutable dereference of `&`-pointer as mutabl\n }"}, {"sha": "f2cb5f82a6c4c93ee67b382dc0e99f86a81c2d1a", "filename": "src/test/debuginfo/vec-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvec-slices.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -93,7 +93,7 @@ fn main() {\n     let empty: &[i64] = &[];\n     let singleton: &[i64] = &[1];\n     let multiple: &[i64] = &[2, 3, 4, 5];\n-    let slice_of_slice = multiple[1..3];\n+    let slice_of_slice = multiple.index(&(1..3));\n \n     let padded_tuple: &[(i32, i16)] = &[(6, 7), (8, 9)];\n "}, {"sha": "6eb4bc352d1944c82dddb8820cc3019fb29363d4", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -35,7 +35,7 @@ fn test_rbml<'a, 'b, A:\n     let mut rbml_w = EBwriter::Encoder::new(&mut wr);\n     a1.encode(&mut rbml_w);\n \n-    let d: serialize::rbml::Doc<'a> = EBDoc::new(wr[]);\n+    let d: serialize::rbml::Doc<'a> = EBDoc::new(wr.index(&FullRange));\n     let mut decoder: EBReader::Decoder<'a> = EBreader::Decoder::new(d);\n     let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);"}, {"sha": "459060d349ce4935e17f54d4282ee9888cbdf8e0", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -59,7 +59,7 @@ fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder<'a>> +\n     let mut w = Vec::new();\n     let mut e = Encoder::new(&mut w);\n     obj.encode(&mut e);\n-    let doc = rbml::Doc::new(@w[]);\n+    let doc = rbml::Doc::new(@w.index(&FullRange));\n     let mut dec = Decoder::new(doc);\n     let obj2 = Decodable::decode(&mut dec);\n     assert!(obj == obj2);"}, {"sha": "4e1aa454a881db717a5dfcd9101ebd95de8564aa", "filename": "src/test/run-pass/issue-15730.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-15730.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-15730.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15730.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     let mut array = [1, 2, 3];\n-    let pie_slice = array[1..2];\n+    let pie_slice = &array[1..2];\n }"}, {"sha": "9d1a51ad79c08310f78099665dcbceebe7540202", "filename": "src/test/run-pass/issue-17503.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-17503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17503.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -15,7 +15,7 @@ fn main() {\n     let ss: &&[int] = &s;\n     let sss: &&&[int] = &ss;\n \n-    println!(\"{}\", s[..3]);\n-    println!(\"{}\", ss[3..]);\n-    println!(\"{}\", sss[2..4]);\n+    println!(\"{}\", s.index(&(0..3)));\n+    println!(\"{}\", ss.index(&(3..)));\n+    println!(\"{}\", sss.index(&(2..4)));\n }"}, {"sha": "115a96d52898d10b9ae6c1f58cc1a114e75567f1", "filename": "src/test/run-pass/issue-3888-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3888-2.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -11,7 +11,7 @@\n #![feature(slicing_syntax)]\n \n fn vec_peek<'r, T>(v: &'r [T]) -> &'r [T] {\n-    v[1..5]\n+    v.index(&(1..5))\n }\n \n pub fn main() {}"}, {"sha": "fa75b5d2583d5c37578ca4aff9cdbae2df7202e4", "filename": "src/test/run-pass/issue-4464.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-4464.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4464.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -10,6 +10,6 @@\n \n #![feature(slicing_syntax)]\n \n-fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v[i..j] }\n+fn broken(v: &[u8], i: uint, j: uint) -> &[u8] { v.index(&(i..j)) }\n \n pub fn main() {}"}, {"sha": "706f640c18d951852beb74f01c1f9ef283357ef3", "filename": "src/test/run-pass/issue-8898.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fissue-8898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8898.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -18,11 +18,11 @@ pub fn main() {\n     let abc = [1i, 2, 3];\n     let tf = [true, false];\n     let x  = [(), ()];\n-    let slice = x[0..1];\n+    let slice = x.index(&(0..1));\n \n-    assert_repr_eq(abc[], \"[1, 2, 3]\".to_string());\n-    assert_repr_eq(tf[], \"[true, false]\".to_string());\n-    assert_repr_eq(x[], \"[(), ()]\".to_string());\n+    assert_repr_eq(abc.index(&FullRange), \"[1, 2, 3]\".to_string());\n+    assert_repr_eq(tf.index(&FullRange), \"[true, false]\".to_string());\n+    assert_repr_eq(x.index(&FullRange), \"[(), ()]\".to_string());\n     assert_repr_eq(slice, \"[()]\".to_string());\n-    assert_repr_eq(x[], \"[(), ()]\".to_string());\n+    assert_repr_eq(x.index(&FullRange), \"[(), ()]\".to_string());\n }"}, {"sha": "e5a617634632f911963a2a9c8f4e22dabd602858", "filename": "src/test/run-pass/repeated-vector-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frepeated-vector-syntax.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -19,5 +19,5 @@ pub fn main() {\n         print!(\"{}, \", (*xi)[]);\n     }\n     println!(\"]\");\n-    println!(\"{}\", y[]);\n+    println!(\"{}\", y.index(&FullRange));\n }"}, {"sha": "7be05b9d71e538ca4fa709fed0424269e05d7dbd", "filename": "src/test/run-pass/slice-2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -15,23 +15,23 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];\n-    assert!(x[] == cmp);\n+    assert!(x.index(&FullRange) == cmp);\n     let cmp: &[int] = &[3, 4, 5];\n-    assert!(x[2..] == cmp);\n+    assert!(x.index(&(2..)) == cmp);\n     let cmp: &[int] = &[1, 2, 3];\n-    assert!(x[..3] == cmp);\n+    assert!(x.index(&(0..3)) == cmp);\n     let cmp: &[int] = &[2, 3, 4];\n-    assert!(x[1..4] == cmp);\n+    assert!(x.index(&(1..4)) == cmp);\n \n     let x: Vec<int> = vec![1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];\n-    assert!(x[] == cmp);\n+    assert!(x.index(&FullRange) == cmp);\n     let cmp: &[int] = &[3, 4, 5];\n-    assert!(x[2..] == cmp);\n+    assert!(x.index(&(2..)) == cmp);\n     let cmp: &[int] = &[1, 2, 3];\n-    assert!(x[..3] == cmp);\n+    assert!(x.index(&(0..3)) == cmp);\n     let cmp: &[int] = &[2, 3, 4];\n-    assert!(x[1..4] == cmp);\n+    assert!(x.index(&(1..4)) == cmp);\n \n     let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n     {"}, {"sha": "87de4246f3e6dad5e93da0616168fd6e240f1fd9", "filename": "src/test/run-pass/slice-panic-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-1.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that is a slicing expr[..] fails, the correct cleanups happen.\n+// Test that is a slicing expr.index(&(..)) fails, the correct cleanups happen.\n \n #![feature(slicing_syntax)]\n \n@@ -24,7 +24,7 @@ impl Drop for Foo {\n \n fn foo() {\n     let x: &[_] = &[Foo, Foo];\n-    x[3..4];\n+    x.index(&(3..4));\n }\n \n fn main() {"}, {"sha": "afffaba64ded76a2ee94811f2257ba6a08b6be90", "filename": "src/test/run-pass/slice-panic-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-panic-2.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that is a slicing expr[..] fails, the correct cleanups happen.\n+// Test that is a slicing expr.index(&(..)) fails, the correct cleanups happen.\n \n #![feature(slicing_syntax)]\n "}, {"sha": "c6dfc8dfd23a3dfcf0ea5dad93bedb16f992caba", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7ff37e4c52a1d6562635fcd5bab6309cf75ea08/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=f7ff37e4c52a1d6562635fcd5bab6309cf75ea08", "patch": "@@ -58,10 +58,10 @@ impl SliceMut<Foo, Foo> for Foo {\n }\n fn main() {\n     let mut x = Foo;\n-    x[];\n-    x[Foo..];\n-    x[..Foo];\n-    x[Foo..Foo];\n+    x.index(&FullRange);\n+    x.index(&(Foo..));\n+    x.index(&(0..Foo));\n+    x.index(&(Foo..Foo));\n     x[mut];\n     x[mut Foo..];\n     x[mut ..Foo];"}]}