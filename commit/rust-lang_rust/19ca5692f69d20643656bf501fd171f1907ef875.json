{"sha": "19ca5692f69d20643656bf501fd171f1907ef875", "node_id": "C_kwDOAAsO6NoAKDE5Y2E1NjkyZjY5ZDIwNjQzNjU2YmY1MDFmZDE3MWYxOTA3ZWY4NzU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-19T03:36:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-19T03:36:37Z"}, "message": "Auto merge of #110100 - compiler-errors:no-infer-pred-must-hold, r=jackh726\n\ndo not allow inference in `predicate_must_hold` (alternative approach)\n\nSee the FCP description for more info, but tl;dr is that we should not return `EvaluatedToOkModuloRegions` if an obligation may hold only with some choice of inference vars being constrained.\n\nAttempts to solve this in the approach laid out by lcnr here: https://github.com/rust-lang/rust/pull/109558#discussion_r1147318134, rather than by eagerly replacing infer vars with placeholders which is a bit too restrictive.\n\nr? `@ghost`", "tree": {"sha": "ffe30221656a138154b3174a1503cd8037a03ed6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffe30221656a138154b3174a1503cd8037a03ed6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19ca5692f69d20643656bf501fd171f1907ef875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19ca5692f69d20643656bf501fd171f1907ef875", "html_url": "https://github.com/rust-lang/rust/commit/19ca5692f69d20643656bf501fd171f1907ef875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19ca5692f69d20643656bf501fd171f1907ef875/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92f5dea0ebe2e34ad8411e8cd8a0c97dd45b3400", "url": "https://api.github.com/repos/rust-lang/rust/commits/92f5dea0ebe2e34ad8411e8cd8a0c97dd45b3400", "html_url": "https://github.com/rust-lang/rust/commit/92f5dea0ebe2e34ad8411e8cd8a0c97dd45b3400"}, {"sha": "c06e61151cbcb89c6dc3df4fa2f0f9eaf914452d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c06e61151cbcb89c6dc3df4fa2f0f9eaf914452d", "html_url": "https://github.com/rust-lang/rust/commit/c06e61151cbcb89c6dc3df4fa2f0f9eaf914452d"}], "stats": {"total": 72, "additions": 47, "deletions": 25}, "files": [{"sha": "28dad8592a8551067395fd7533a5297b9f839023", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/19ca5692f69d20643656bf501fd171f1907ef875/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ca5692f69d20643656bf501fd171f1907ef875/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=19ca5692f69d20643656bf501fd171f1907ef875", "patch": "@@ -143,35 +143,36 @@ pub fn type_known_to_meet_bound_modulo_regions<'tcx>(\n fn pred_known_to_hold_modulo_regions<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    pred: impl ToPredicate<'tcx> + TypeVisitable<TyCtxt<'tcx>>,\n+    pred: impl ToPredicate<'tcx>,\n ) -> bool {\n-    let has_non_region_infer = pred.has_non_region_infer();\n     let obligation = Obligation::new(infcx.tcx, ObligationCause::dummy(), param_env, pred);\n \n     let result = infcx.evaluate_obligation_no_overflow(&obligation);\n     debug!(?result);\n \n-    if result.must_apply_modulo_regions() && !has_non_region_infer {\n+    if result.must_apply_modulo_regions() {\n         true\n     } else if result.may_apply() {\n-        // Because of inference \"guessing\", selection can sometimes claim\n-        // to succeed while the success requires a guess. To ensure\n-        // this function's result remains infallible, we must confirm\n-        // that guess. While imperfect, I believe this is sound.\n-\n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let ocx = ObligationCtxt::new(infcx);\n-        ocx.register_obligation(obligation);\n-        let errors = ocx.select_all_or_error();\n-        match errors.as_slice() {\n-            [] => true,\n-            errors => {\n-                debug!(?errors);\n-                false\n+        // Sometimes obligations are ambiguous because the recursive evaluator\n+        // is not smart enough, so we fall back to fulfillment when we're not certain\n+        // that an obligation holds or not. Even still, we must make sure that\n+        // the we do no inference in the process of checking this obligation.\n+        let goal = infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));\n+        infcx.probe(|_| {\n+            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+            ocx.register_obligation(obligation);\n+\n+            let errors = ocx.select_all_or_error();\n+            match errors.as_slice() {\n+                // Only known to hold if we did no inference.\n+                [] => infcx.shallow_resolve(goal) == goal,\n+\n+                errors => {\n+                    debug!(?errors);\n+                    false\n+                }\n             }\n-        }\n+        })\n     } else {\n         false\n     }"}, {"sha": "b366bbd531bc132f2eac193aad01edc8132c71d9", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19ca5692f69d20643656bf501fd171f1907ef875/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ca5692f69d20643656bf501fd171f1907ef875/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=19ca5692f69d20643656bf501fd171f1907ef875", "patch": "@@ -537,14 +537,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            if this.tcx().trait_solver_next() {\n-                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])\n+            let goal =\n+                this.infcx.resolve_vars_if_possible((obligation.predicate, obligation.param_env));\n+            let mut result = if this.tcx().trait_solver_next() {\n+                this.evaluate_predicates_recursively_in_new_solver([obligation.clone()])?\n             } else {\n                 this.evaluate_predicate_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n                     obligation.clone(),\n-                )\n+                )?\n+            };\n+            // If the predicate has done any inference, then downgrade the\n+            // result to ambiguous.\n+            if this.infcx.shallow_resolve(goal) != goal {\n+                result = result.max(EvaluatedToAmbig);\n             }\n+            Ok(result)\n         })\n     }\n "}, {"sha": "c1ed4c28a0300573ea5e8690d85c6ab15e31715c", "filename": "tests/ui/traits/copy-guessing.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19ca5692f69d20643656bf501fd171f1907ef875/tests%2Fui%2Ftraits%2Fcopy-guessing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19ca5692f69d20643656bf501fd171f1907ef875/tests%2Fui%2Ftraits%2Fcopy-guessing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcopy-guessing.rs?ref=19ca5692f69d20643656bf501fd171f1907ef875", "patch": "@@ -1,5 +1,3 @@\n-// run-pass\n-\n #![allow(dead_code)]\n #![allow(drop_copy)]\n \n@@ -20,6 +18,7 @@ fn assert_impls_fn<R,T: Fn()->R>(_: &T){}\n \n fn main() {\n     let n = None;\n+    //~^ ERROR type annotations needed for `Option<T>`\n     let e = S(&n);\n     let f = || {\n         // S being copy is critical for this to work"}, {"sha": "568b7e5a64af967bd857cd3a79c82a10d097ea05", "filename": "tests/ui/traits/copy-guessing.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19ca5692f69d20643656bf501fd171f1907ef875/tests%2Fui%2Ftraits%2Fcopy-guessing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19ca5692f69d20643656bf501fd171f1907ef875/tests%2Fui%2Ftraits%2Fcopy-guessing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fcopy-guessing.stderr?ref=19ca5692f69d20643656bf501fd171f1907ef875", "patch": "@@ -0,0 +1,14 @@\n+error[E0282]: type annotations needed for `Option<T>`\n+  --> $DIR/copy-guessing.rs:20:9\n+   |\n+LL |     let n = None;\n+   |         ^\n+   |\n+help: consider giving `n` an explicit type, where the type for type parameter `T` is specified\n+   |\n+LL |     let n: Option<T> = None;\n+   |          +++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}