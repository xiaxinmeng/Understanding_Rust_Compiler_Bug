{"sha": "f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzg3OWZkZDhhYWQ2N2NmNGY2ZWRkM2FhY2IwMTg5YzI4NGM5MjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T04:57:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-20T04:57:49Z"}, "message": "auto merge of #5442 : pcwalton/rust/extern-block-restriction, r=pcwalton\n\nr? @graydon", "tree": {"sha": "872abff783f535fce31af87b8bceeba0f10bf8dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/872abff783f535fce31af87b8bceeba0f10bf8dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "html_url": "https://github.com/rust-lang/rust/commit/f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cb9ca92962dbbe8ffd813c016e9d6f809dd285b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cb9ca92962dbbe8ffd813c016e9d6f809dd285b", "html_url": "https://github.com/rust-lang/rust/commit/4cb9ca92962dbbe8ffd813c016e9d6f809dd285b"}, {"sha": "f8dab3a6c0adff63854d5e238961a771419d23b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8dab3a6c0adff63854d5e238961a771419d23b7", "html_url": "https://github.com/rust-lang/rust/commit/f8dab3a6c0adff63854d5e238961a771419d23b7"}], "stats": {"total": 599, "additions": 411, "deletions": 188}, "files": [{"sha": "6a3ed22cea9b92493896a41c134cde1589a925d1", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -1221,9 +1221,8 @@ pub mod funcs {\n         #[nolink]\n         #[abi = \"cdecl\"]\n         pub mod fcntl {\n+            use libc::types::os::arch::c95::{c_int, c_char};\n             pub extern {\n-                use libc::types::os::arch::c95::{c_int, c_char};\n-\n                 #[link_name = \"_open\"]\n                 unsafe fn open(path: *c_char, oflag: c_int, mode: c_int)\n                             -> c_int;\n@@ -1562,11 +1561,11 @@ pub mod funcs {\n     #[cfg(target_os = \"macos\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod bsd44 {\n+        use libc::types::common::c95::{c_void};\n+        use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n+\n         #[abi = \"cdecl\"]\n         pub extern {\n-            use libc::types::common::c95::{c_void};\n-            use libc::types::os::arch::c95::{c_char, c_int, c_uint, size_t};\n-\n             unsafe fn sysctl(name: *c_int, namelen: c_uint,\n                       oldp: *mut c_void, oldlenp: *mut size_t,\n                       newp: *c_void, newlen: size_t) -> c_int;"}, {"sha": "92e2ec51306e20cd862bc837fefc561e2ddf804c", "filename": "src/libcore/rt/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fenv.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -44,4 +44,4 @@ pub fn get() -> &Environment {\n \n extern {\n     fn rust_get_rt_env() -> &Environment;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "60dbc8b82da1155ae3feb7b5c71f61d4689969d8", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -70,7 +70,7 @@ enum CleanupJob {\n \n pub impl Scheduler {\n \n-    static fn new(event_loop: ~EventLoopObject) -> Scheduler {\n+    static pub fn new(event_loop: ~EventLoopObject) -> Scheduler {\n         Scheduler {\n             event_loop: event_loop,\n             task_queue: WorkQueue::new(),\n@@ -296,7 +296,7 @@ pub struct Task {\n }\n \n impl Task {\n-    static fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n+    static pub fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n         // XXX: Putting main into a ~ so it's a thin pointer and can\n         // be passed to the spawn function.  Another unfortunate\n         // allocation"}, {"sha": "b5e7d4f3aa2153843c123406a5a0a91b1ed97adc", "filename": "src/libcore/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fstack.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -37,8 +37,7 @@ pub impl StackSegment {\n pub struct StackPool(());\n \n impl StackPool {\n-\n-    static fn new() -> StackPool { StackPool(()) }\n+    static pub fn new() -> StackPool { StackPool(()) }\n \n     fn take_segment(&self, min_size: uint) -> StackSegment {\n         StackSegment::new(min_size)"}, {"sha": "5dccf90096e029dc82b3357329d18a62fab22dfe", "filename": "src/libcore/rt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -20,7 +20,7 @@ struct Thread {\n }\n \n impl Thread {\n-    static fn start(main: ~fn()) -> Thread {\n+    static pub fn start(main: ~fn()) -> Thread {\n         fn substart(main: &fn()) -> *raw_thread {\n             unsafe { rust_raw_thread_start(&main) }\n         }"}, {"sha": "760812252bc73761a77ea3d4b9753503615b7f8b", "filename": "src/libcore/task/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibcore%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Frt.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -30,7 +30,7 @@ pub type rust_task = libc::c_void;\n #[allow(non_camel_case_types)] // runtime type\n pub type rust_closure = libc::c_void;\n \n-extern {\n+pub extern {\n     #[rust_stack]\n     fn rust_task_yield(task: *rust_task) -> bool;\n "}, {"sha": "c4644a611648dfc117a7098689fcbcb6a7d516c0", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -146,6 +146,7 @@ fn item_family(item: ebml::Doc) -> Family {\n \n fn item_visibility(item: ebml::Doc) -> ast::visibility {\n     let visibility = reader::get_doc(item, tag_items_data_item_visibility);\n+    debug!(\"item visibility for %?\", item_family(item));\n     match reader::doc_as_u8(visibility) as char {\n         'y' => ast::public,\n         'n' => ast::private,"}, {"sha": "f6eff900164885743fc82b1b21ca2e4035383ba4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -896,6 +896,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'r');\n+                encode_visibility(ebml_w, ast::public);\n                 ebml_w.end_tag();\n               }\n               provided(m) => {\n@@ -911,6 +912,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n                 encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'p');\n+                encode_visibility(ebml_w, m.vis);\n                 ebml_w.end_tag();\n               }\n             }\n@@ -945,6 +947,11 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             let mut m_path = vec::append(~[], path); // :-(\n             m_path += [ast_map::path_name(item.ident)];\n             encode_path(ecx, ebml_w, m_path, ast_map::path_name(ty_m.ident));\n+\n+            // For now, use the item visibility until trait methods can have\n+            // real visibility in the AST.\n+            encode_visibility(ebml_w, item.vis);\n+\n             ebml_w.end_tag();\n         }\n \n@@ -1033,7 +1040,7 @@ fn encode_info_for_items(ecx: @EncodeContext, ebml_w: writer::Encoder,\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n                 match ecx.tcx.items.get(&ni.id) {\n-                    ast_map::node_foreign_item(_, abi, pt) => {\n+                    ast_map::node_foreign_item(_, abi, _, pt) => {\n                         encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                                      index, /*bad*/copy *pt,\n                                                      abi);"}, {"sha": "adc1a7ce3f43b91a3dd411fd042aa21983d505c8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 257, "deletions": 88, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -22,15 +22,19 @@ use middle::typeck::{method_super};\n use middle::typeck::{method_static, method_trait};\n \n use core::util::ignore;\n-use syntax::ast::{def_variant, expr_field, expr_method_call, expr_struct};\n-use syntax::ast::{expr_unary, ident, item_struct, item_enum, item_impl};\n-use syntax::ast::{item_trait, local_crate, node_id, pat_struct, private};\n-use syntax::ast::{provided, public, required};\n+use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n+use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n+use syntax::ast::{expr_struct, expr_unary, ident, inherited, item_enum};\n+use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n+use syntax::ast::{item_trait, local_crate, node_id, pat_struct, path};\n+use syntax::ast::{private, provided, public, required, stmt_decl, visibility};\n use syntax::ast;\n-use syntax::ast_map::{node_item, node_method};\n+use syntax::ast_map::{node_foreign_item, node_item, node_method};\n+use syntax::ast_map::{node_trait_method};\n use syntax::ast_map;\n use syntax::ast_util::{Private, Public, is_local};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n+use syntax::attr;\n use syntax::codemap::span;\n use syntax::visit;\n \n@@ -39,18 +43,37 @@ pub fn check_crate(tcx: ty::ctxt,\n                    crate: @ast::crate) {\n     let privileged_items = @mut ~[];\n \n-    // Adds structs that are privileged to this scope.\n-    let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n-        let mut count = 0;\n-        for items.each |item| {\n-            match item.node {\n-                item_struct(*) | item_trait(*) | item_impl(*)\n-                | item_enum(*) => {\n-                    privileged_items.push(item.id);\n-                    count += 1;\n+    // Adds an item to its scope.\n+    let add_privileged_item: @fn(@ast::item, &mut uint) = |item, count| {\n+        match item.node {\n+            item_struct(*) | item_trait(*) | item_enum(*) |\n+            item_fn(*) => {\n+                privileged_items.push(item.id);\n+                *count += 1;\n+            }\n+            item_impl(_, _, _, ref methods) => {\n+                for methods.each |method| {\n+                    privileged_items.push(method.id);\n+                    *count += 1;\n+                }\n+                privileged_items.push(item.id);\n+                *count += 1;\n+            }\n+            item_foreign_mod(ref foreign_mod) => {\n+                for foreign_mod.items.each |foreign_item| {\n+                    privileged_items.push(foreign_item.id);\n+                    *count += 1;\n                 }\n-                _ => {}\n             }\n+            _ => {}\n+        }\n+    };\n+\n+    // Adds items that are privileged to this scope.\n+    let add_privileged_items: @fn(&[@ast::item]) -> uint = |items| {\n+        let mut count = 0;\n+        for items.each |&item| {\n+            add_privileged_item(item, &mut count);\n         }\n         count\n     };\n@@ -84,6 +107,128 @@ pub fn check_crate(tcx: ty::ctxt,\n         }\n     };\n \n+    // Returns the ID of the container (impl or trait) that a crate-local\n+    // method belongs to.\n+    let local_method_container_id:\n+            @fn(span: span, method_id: node_id) -> def_id =\n+            |span, method_id| {\n+        match tcx.items.find(&method_id) {\n+            Some(node_method(_, impl_id, _)) => impl_id,\n+            Some(node_trait_method(_, trait_id, _)) => trait_id,\n+            Some(_) => {\n+                tcx.sess.span_bug(span,\n+                                  fmt!(\"method was a %s?!\",\n+                                       ast_map::node_id_to_str(\n+                                            tcx.items,\n+                                            method_id,\n+                                            tcx.sess.parse_sess.interner)));\n+            }\n+            None => {\n+                tcx.sess.span_bug(span, ~\"method not found in \\\n+                                          AST map?!\");\n+            }\n+        }\n+    };\n+\n+    // Returns true if a crate-local method is private and false otherwise.\n+    let method_is_private: @fn(span: span, method_id: node_id) -> bool =\n+            |span, method_id| {\n+        let check = |vis: visibility, container_id: def_id| {\n+            let mut is_private = false;\n+            if vis == private {\n+                is_private = true;\n+            } else if vis == public {\n+                is_private = false;\n+            } else {\n+                // Look up the enclosing impl.\n+                if container_id.crate != local_crate {\n+                    tcx.sess.span_bug(span,\n+                                      ~\"local method isn't in local \\\n+                                        impl?!\");\n+                }\n+\n+                match tcx.items.find(&container_id.node) {\n+                    Some(node_item(item, _)) => {\n+                        match item.node {\n+                            item_impl(_, None, _, _)\n+                                    if item.vis != public => {\n+                                is_private = true;\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    Some(_) => {\n+                        tcx.sess.span_bug(span, ~\"impl wasn't an item?!\");\n+                    }\n+                    None => {\n+                        tcx.sess.span_bug(span, ~\"impl wasn't in AST map?!\");\n+                    }\n+                }\n+            }\n+\n+            is_private\n+        };\n+\n+        match tcx.items.find(&method_id) {\n+            Some(node_method(method, impl_id, _)) => {\n+                check(method.vis, impl_id)\n+            }\n+            Some(node_trait_method(trait_method, trait_id, _)) => {\n+                match *trait_method {\n+                    required(_) => check(public, trait_id),\n+                    provided(method) => check(method.vis, trait_id),\n+                }\n+            }\n+            Some(_) => {\n+                tcx.sess.span_bug(span,\n+                                  fmt!(\"method_is_private: method was a %s?!\",\n+                                       ast_map::node_id_to_str(\n+                                            tcx.items,\n+                                            method_id,\n+                                            tcx.sess.parse_sess.interner)));\n+            }\n+            None => {\n+                tcx.sess.span_bug(span, ~\"method not found in \\\n+                                          AST map?!\");\n+            }\n+        }\n+    };\n+\n+    // Returns true if the given local item is private and false otherwise.\n+    let local_item_is_private: @fn(span: span, item_id: node_id) -> bool =\n+            |span, item_id| {\n+        let mut f: &fn(node_id) -> bool = |_| false;\n+        f = |item_id| {\n+            match tcx.items.find(&item_id) {\n+                Some(node_item(item, _)) => item.vis != public,\n+                Some(node_foreign_item(_, _, vis, _)) => vis != public,\n+                Some(node_method(method, impl_did, _)) => {\n+                    match method.vis {\n+                        private => true,\n+                        public => false,\n+                        inherited => f(impl_did.node)\n+                    }\n+                }\n+                Some(node_trait_method(_, trait_did, _)) => f(trait_did.node),\n+                Some(_) => {\n+                    tcx.sess.span_bug(span,\n+                                      fmt!(\"local_item_is_private: item was \\\n+                                            a %s?!\",\n+                                           ast_map::node_id_to_str(\n+                                                tcx.items,\n+                                                item_id,\n+                                                tcx.sess\n+                                                   .parse_sess\n+                                                   .interner)));\n+                }\n+                None => {\n+                    tcx.sess.span_bug(span, ~\"item not found in AST map?!\");\n+                }\n+            }\n+        };\n+        f(item_id)\n+    };\n+\n     // Checks that a private field is in scope.\n     let check_field: @fn(span: span, id: ast::def_id, ident: ast::ident) =\n             |span, id, ident| {\n@@ -99,86 +244,76 @@ pub fn check_crate(tcx: ty::ctxt,\n         }\n     };\n \n+    // Given the ID of a method, checks to ensure it's in scope.\n+    let check_method_common: @fn(span: span,\n+                                 method_id: def_id,\n+                                 name: &ident) =\n+            |span, method_id, name| {\n+        if method_id.crate == local_crate {\n+            let is_private = method_is_private(span, method_id.node);\n+            let container_id = local_method_container_id(span,\n+                                                         method_id.node);\n+            if is_private &&\n+                    (container_id.crate != local_crate ||\n+                     !privileged_items.contains(&(container_id.node))) {\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"method `%s` is private\",\n+                                       *tcx.sess\n+                                           .parse_sess\n+                                           .interner\n+                                           .get(*name)));\n+            }\n+        } else {\n+            let visibility =\n+                csearch::get_method_visibility(tcx.sess.cstore,\n+                                               method_id);\n+            if visibility != public {\n+                tcx.sess.span_err(span,\n+                                  fmt!(\"method `%s` is private\",\n+                                       *tcx.sess.parse_sess.interner\n+                                           .get(*name)));\n+            }\n+        }\n+    };\n+\n+    // Checks that a private path is in scope.\n+    let check_path: @fn(span: span, def: def, path: @path) =\n+            |span, def, path| {\n+        debug!(\"checking path\");\n+        match def {\n+            def_static_method(method_id, _, _) => {\n+                debug!(\"found static method def, checking it\");\n+                check_method_common(span, method_id, path.idents.last())\n+            }\n+            def_fn(def_id, _) => {\n+                if def_id.crate == local_crate {\n+                    if local_item_is_private(span, def_id.node) &&\n+                            !privileged_items.contains(&def_id.node) {\n+                        tcx.sess.span_err(span,\n+                                          fmt!(\"function `%s` is private\",\n+                                               *tcx.sess\n+                                                   .parse_sess\n+                                                   .interner\n+                                                   .get(copy *path\n+                                                             .idents\n+                                                             .last())));\n+                    }\n+                } else {\n+                    // XXX: Check privacy in external crates.\n+                }\n+            }\n+            _ => {}\n+        }\n+    };\n+\n     // Checks that a private method is in scope.\n     let check_method: @fn(span: span,\n                           origin: &method_origin,\n                           ident: ast::ident) =\n             |span, origin, ident| {\n         match *origin {\n             method_static(method_id) => {\n-                if method_id.crate == local_crate {\n-                    match tcx.items.find(&method_id.node) {\n-                        Some(node_method(method, impl_id, _)) => {\n-                            let mut is_private = false;\n-                            if method.vis == private {\n-                                is_private = true;\n-                            } else if method.vis == public {\n-                                is_private = false;\n-                            } else {\n-                                // Look up the enclosing impl.\n-                                if impl_id.crate != local_crate {\n-                                    tcx.sess.span_bug(span,\n-                                                      ~\"local method isn't \\\n-                                                        in local impl?!\");\n-                                }\n-\n-                                match tcx.items.find(&impl_id.node) {\n-                                    Some(node_item(item, _)) => {\n-                                        match item.node {\n-                                            item_impl(_, None, _, _)\n-                                                    if item.vis != public => {\n-                                                is_private = true;\n-                                            }\n-                                            _ => {}\n-                                        }\n-                                    }\n-                                    Some(_) => {\n-                                        tcx.sess.span_bug(span,\n-                                                          ~\"impl wasn't an \\\n-                                                            item?!\");\n-                                    }\n-                                    None => {\n-                                        tcx.sess.span_bug(span,\n-                                                          ~\"impl wasn't in \\\n-                                                            AST map?!\");\n-                                    }\n-                                }\n-                            }\n-\n-                            if is_private &&\n-                                    (impl_id.crate != local_crate ||\n-                                     !privileged_items\n-                                     .contains(&(impl_id.node))) {\n-                                tcx.sess.span_err(span,\n-                                                  fmt!(\"method `%s` is \\\n-                                                        private\",\n-                                                       *tcx.sess\n-                                                           .parse_sess\n-                                                           .interner\n-                                                           .get(method\n-                                                                .ident)));\n-                            }\n-                        }\n-                        Some(_) => {\n-                            tcx.sess.span_bug(span, ~\"method wasn't \\\n-                                                      actually a method?!\");\n-                        }\n-                        None => {\n-                            tcx.sess.span_bug(span, ~\"method not found in \\\n-                                                      AST map?!\");\n-                        }\n-                    }\n-                } else {\n-                    let visibility =\n-                        csearch::get_method_visibility(tcx.sess.cstore,\n-                                                       method_id);\n-                    if visibility != public {\n-                        tcx.sess.span_err(span,\n-                                          fmt!(\"method `%s` is private\",\n-                                               *tcx.sess.parse_sess.interner\n-                                                   .get(ident)));\n-                    }\n-                }\n+                check_method_common(span, method_id, &ident)\n             }\n             method_param(method_param {\n                 trait_id: trait_id,\n@@ -257,6 +392,37 @@ pub fn check_crate(tcx: ty::ctxt,\n                 ignore(privileged_items.pop());\n             }\n         },\n+        visit_item: |item, method_map, visitor| {\n+            // Do not check privacy inside items with the resolve_unexported\n+            // attribute. This is used for the test runner.\n+            if !attr::contains_name(attr::attr_metas(/*bad*/copy item.attrs),\n+                                    ~\"!resolve_unexported\") {\n+                visit::visit_item(item, method_map, visitor);\n+            }\n+        },\n+        visit_block: |block, method_map, visitor| {\n+            // Gather up all the privileged items.\n+            let mut n_added = 0;\n+            for block.node.stmts.each |stmt| {\n+                match stmt.node {\n+                    stmt_decl(decl, _) => {\n+                        match decl.node {\n+                            decl_item(item) => {\n+                                add_privileged_item(item, &mut n_added);\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            visit::visit_block(block, method_map, visitor);\n+\n+            for n_added.times {\n+                ignore(privileged_items.pop());\n+            }\n+        },\n         visit_expr: |expr, method_map: &method_map, visitor| {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n@@ -310,6 +476,9 @@ pub fn check_crate(tcx: ty::ctxt,\n                         _ => {}\n                     }\n                 }\n+                expr_path(path) => {\n+                    check_path(expr.span, tcx.def_map.get(&expr.id), path);\n+                }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {"}, {"sha": "55cf1ae23b8fc7a8c2e2e322f2ffb40f4387e4c4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -2428,7 +2428,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             exprt = true;\n             register_method(ccx, id, pth, m)\n           }\n-          ast_map::node_foreign_item(ni, _, pth) => {\n+          ast_map::node_foreign_item(ni, _, _, pth) => {\n             exprt = true;\n             match ni.node {\n                 ast::foreign_item_fn(*) => {"}, {"sha": "14336a203ced4eea84e89e5cfc431e2bc09e24b2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -266,6 +266,7 @@ pub fn trans_fn_ref_with_vtables(\n         match map_node {\n             ast_map::node_foreign_item(_,\n                                        ast::foreign_abi_rust_intrinsic,\n+                                       _,\n                                        _) => {\n                 must_monomorphise = true;\n             }"}, {"sha": "dadd51b324847ed68ad435c6153b93de93b89b57", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -1083,7 +1083,7 @@ fn abi_of_foreign_fn(ccx: @CrateContext, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n       None => match ccx.tcx.items.get(&i.id) {\n-        ast_map::node_foreign_item(_, abi, _) => abi,\n+        ast_map::node_foreign_item(_, abi, _, _) => abi,\n         // ??\n         _ => fail!(~\"abi_of_foreign_fn: not foreign\")\n       },"}, {"sha": "feddbabdcad3fbf9b0952923f69d77f2674c8597", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -94,7 +94,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n       ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n-      ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, pt)\n+      ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, _, pt)\n       => (pt, i.ident, i.span),\n       ast_map::node_foreign_item(*) => {\n         // Foreign externs don't have to be monomorphized.\n@@ -181,7 +181,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_item(*) => {\n           ccx.tcx.sess.bug(~\"Can't monomorphize this kind of item\")\n       }\n-      ast_map::node_foreign_item(i, _, _) => {\n+      ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n           foreign::trans_intrinsic(ccx, d, i, pt, psubsts.get(),\n                                 ref_id);"}, {"sha": "2adf9926f2d4d4e4ed7d6c8b0bd5ecefd82185f5", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -76,7 +76,7 @@ fn traverse_def_id(cx: ctx, did: def_id) {\n     match n {\n       ast_map::node_item(item, _) => traverse_public_item(cx, item),\n       ast_map::node_method(_, impl_id, _) => traverse_def_id(cx, impl_id),\n-      ast_map::node_foreign_item(item, _, _) => {\n+      ast_map::node_foreign_item(item, _, _, _) => {\n         cx.rmap.insert(item.id, ());\n       }\n       ast_map::node_variant(ref v, _, _) => {"}, {"sha": "77e10b2fbda64c5dc17e7068dbcd12f1e38ede3a", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -118,7 +118,9 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n       }\n       ast_map::node_foreign_item(i@@foreign_item { node: foreign_item_fn(*),\n                                                    _ },\n-                                 abi, _) => {\n+                                 abi,\n+                                 _,\n+                                 _) => {\n         if abi == foreign_abi_rust_intrinsic {\n             let flags = match *cx.ccx.sess.str_of(i.ident) {\n                 ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |"}, {"sha": "9520da7a5d271925c7f156860db00c37ea1f6ab3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -3762,7 +3762,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::append_one(/*bad*/copy *path, item_elt)\n           }\n \n-          ast_map::node_foreign_item(nitem, _, path) => {\n+          ast_map::node_foreign_item(nitem, _, _, path) => {\n             vec::append_one(/*bad*/copy *path,\n                             ast_map::path_name(nitem.ident))\n           }"}, {"sha": "dacc9553cd24f232e9b026b030a21c2d946d5404", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -139,7 +139,7 @@ impl AstConv for CrateCtxt {\n               Some(ast_map::node_item(item, _)) => {\n                 ty_of_item(self, item)\n               }\n-              Some(ast_map::node_foreign_item(foreign_item, _, _)) => {\n+              Some(ast_map::node_foreign_item(foreign_item, _, _, _)) => {\n                 ty_of_foreign_item(self, foreign_item)\n               }\n               ref x => {"}, {"sha": "0bf2f50e63fc57c24db308bd7c7c786ef4cea5bb", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -116,7 +116,7 @@ fn parse_item_attrs<T:Owned>(\n     do astsrv::exec(srv) |ctxt| {\n         let attrs = match ctxt.ast_map.get(&id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n-          ast_map::node_foreign_item(item, _, _) => copy item.attrs,\n+          ast_map::node_foreign_item(item, _, _, _) => copy item.attrs,\n           _ => fail!(~\"parse_item_attrs: not an item\")\n         };\n         parse_attrs(attrs)"}, {"sha": "638274d0bb8ee62c8944530065045bc42be97dee", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -74,7 +74,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n           ast_map::node_foreign_item(@ast::foreign_item {\n             ident: ident,\n             node: ast::foreign_item_fn(ref decl, _, ref tys), _\n-          }, _, _) => {\n+          }, _, _, _) => {\n             Some(pprust::fun_to_str(decl, ident, None, tys,\n                                     extract::interner()))\n           }"}, {"sha": "9371055556ef54256cb8f7722150f8b38d6caeca", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -87,7 +87,7 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n \n pub enum ast_node {\n     node_item(@item, @path),\n-    node_foreign_item(@foreign_item, foreign_abi, @path),\n+    node_foreign_item(@foreign_item, foreign_abi, visibility, @path),\n     node_trait_method(@trait_method, def_id /* trait did */,\n                       @path /* path to the trait */),\n     node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n@@ -170,7 +170,9 @@ pub fn map_decoded_item(diag: @span_handler,\n     match ii {\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n-        cx.map.insert(i.id, node_foreign_item(i, foreign_abi_rust_intrinsic,\n+        cx.map.insert(i.id, node_foreign_item(i,\n+                                              foreign_abi_rust_intrinsic,\n+                                              i.vis,    // Wrong but OK\n                                               @path));\n       }\n       ii_method(impl_did, m) => {\n@@ -277,10 +279,18 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n                 Right(abi) => abi\n             };\n             for nm.items.each |nitem| {\n+                // Compute the visibility for this native item.\n+                let visibility = match nitem.vis {\n+                    public => public,\n+                    private => private,\n+                    inherited => i.vis\n+                };\n+\n                 cx.map.insert(nitem.id,\n                     node_foreign_item(\n                         *nitem,\n                         abi,\n+                        visibility,\n                         // FIXME (#2543)\n                         if nm.sort == ast::named {\n                             extend(cx, i.ident)\n@@ -380,7 +390,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         };\n         fmt!(\"%s %s (id=%?)\", item_str, path_str, id)\n       }\n-      Some(node_foreign_item(item, abi, path)) => {\n+      Some(node_foreign_item(item, abi, _, path)) => {\n         fmt!(\"foreign item %s with abi %? (id=%?)\",\n              path_ident_to_str(*path, item.ident, itr), abi, id)\n       }"}, {"sha": "62e1d20e9b2bea762f67bf2579dc079a1733427d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 76, "deletions": 38, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -120,7 +120,7 @@ pub enum item_or_view_item {\n \n enum view_item_parse_mode {\n     VIEW_ITEMS_AND_ITEMS_ALLOWED,\n-    VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n+    FOREIGN_ITEMS_ALLOWED,\n     IMPORTS_AND_ITEMS_ALLOWED\n }\n \n@@ -642,9 +642,9 @@ pub impl Parser {\n                 self.obsolete(*self.last_span, ObsoleteMutVector);\n             }\n \n-            // Parse the `* e` in `[ int * e ]`\n+            // Parse the `, ..e` in `[ int, ..e ]`\n             // where `e` is a const expression\n-            let t = match self.maybe_parse_fixed_vstore_with_star() {\n+            let t = match self.maybe_parse_fixed_vstore() {\n                 None => ty_vec(mt),\n                 Some(suffix) => ty_fixed_length_vec(mt, suffix)\n             };\n@@ -815,8 +815,14 @@ pub impl Parser {\n         })\n     }\n \n-    fn maybe_parse_fixed_vstore_with_star(&self) -> Option<@ast::expr> {\n+    fn maybe_parse_fixed_vstore(&self) -> Option<@ast::expr> {\n         if self.eat(&token::BINOP(token::STAR)) {\n+            // XXX: Obsolete; remove after snapshot.\n+            Some(self.parse_expr())\n+        } else if *self.token == token::COMMA &&\n+                self.look_ahead(1) == token::DOTDOT {\n+            self.bump();\n+            self.bump();\n             Some(self.parse_expr())\n         } else {\n             None\n@@ -3538,7 +3544,12 @@ pub impl Parser {\n     fn parse_item_foreign_const(&self, vis: ast::visibility,\n                                 +attrs: ~[attribute]) -> @foreign_item {\n         let lo = self.span.lo;\n-        self.expect_keyword(&~\"const\");\n+\n+        // XXX: Obsolete; remove after snap.\n+        if !self.eat_keyword(&~\"const\") {\n+            self.expect_keyword(&~\"static\");\n+        }\n+\n         let ident = self.parse_ident();\n         self.expect(&token::COLON);\n         let ty = self.parse_ty(false);\n@@ -3567,7 +3578,7 @@ pub impl Parser {\n \n     fn parse_foreign_item(&self, +attrs: ~[attribute]) -> @foreign_item {\n         let vis = self.parse_visibility();\n-        if self.is_keyword(&~\"const\") {\n+        if self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\") {\n             self.parse_item_foreign_const(vis, attrs)\n         } else {\n             self.parse_item_foreign_fn(attrs)\n@@ -3585,7 +3596,7 @@ pub impl Parser {\n             items: _,\n             foreign_items: foreign_items\n         } = self.parse_items_and_view_items(first_item_attrs,\n-                                         VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED,\n+                                            FOREIGN_ITEMS_ALLOWED,\n                                             true);\n \n         let mut items: ~[@foreign_item] = foreign_items;\n@@ -3925,17 +3936,24 @@ pub impl Parser {\n             visibility = inherited;\n         }\n \n-        if items_allowed && self.eat_keyword(&~\"const\") {\n+        if items_allowed &&\n+                (self.is_keyword(&~\"const\") ||\n+                (self.is_keyword(&~\"static\") &&\n+                    !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n             // CONST ITEM\n+            self.bump();\n             let (ident, item_, extra_attrs) = self.parse_item_const();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if foreign_items_allowed && self.is_keyword(&~\"const\") {\n+        }\n+        if foreign_items_allowed &&\n+                (self.is_keyword(&~\"const\") || self.is_keyword(&~\"static\")) {\n             // FOREIGN CONST ITEM\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n-        } else if items_allowed &&\n+        }\n+        if items_allowed &&\n             // FUNCTION ITEM (not sure about lookahead condition...)\n             self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n@@ -3944,21 +3962,24 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"pure\") {\n+        }\n+        if items_allowed && self.eat_keyword(&~\"pure\") {\n             // PURE FUNCTION ITEM\n             // NB: We parse this as impure for bootstrapping purposes.\n             self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if foreign_items_allowed &&\n+        }\n+        if foreign_items_allowed &&\n             (self.is_keyword(&~\"fn\") || self.is_keyword(&~\"pure\") ||\n              self.is_keyword(&~\"unsafe\")) {\n             // FOREIGN FUNCTION ITEM (no items allowed)\n                 let item = self.parse_item_foreign_fn(attrs);\n                 return iovi_foreign_item(item);\n-        } else if items_allowed && self.is_keyword(&~\"unsafe\")\n+        }\n+        if items_allowed && self.is_keyword(&~\"unsafe\")\n             && self.look_ahead(1u) != token::LBRACE {\n             // UNSAFE FUNCTION ITEM (where items are allowed)\n             self.bump();\n@@ -3967,7 +3988,8 @@ pub impl Parser {\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(&~\"extern\") {\n+        }\n+        if self.eat_keyword(&~\"extern\") {\n             if items_allowed && self.eat_keyword(&~\"fn\") {\n                 // EXTERN FUNCTION ITEM\n                 let (ident, item_, extra_attrs) =\n@@ -3977,47 +3999,62 @@ pub impl Parser {\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n-            // EXTERN MODULE ITEM\n-            return self.parse_item_foreign_mod(lo, visibility, attrs,\n-                                               items_allowed);\n-        } else if items_allowed && self.eat_keyword(&~\"mod\") {\n+            if !foreign_items_allowed {\n+                // EXTERN MODULE ITEM\n+                return self.parse_item_foreign_mod(lo, visibility, attrs,\n+                                                   items_allowed);\n+            }\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"type\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"type\") {\n             // TYPE ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_type();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"enum\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"enum\") {\n             // ENUM ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_enum();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"trait\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"trait\") {\n             // TRAIT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_trait();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"impl\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"impl\") {\n             // IMPL ITEM\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_impl(visibility);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if items_allowed && self.eat_keyword(&~\"struct\") {\n+        }\n+        if items_allowed && !foreign_items_allowed &&\n+                self.eat_keyword(&~\"struct\") {\n             // STRUCT ITEM\n             let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n-        } else if self.eat_keyword(&~\"use\") {\n+        }\n+        if !foreign_items_allowed && self.eat_keyword(&~\"use\") {\n             // USE ITEM\n             let view_item = self.parse_use();\n             self.expect(&token::SEMI);\n@@ -4027,7 +4064,8 @@ pub impl Parser {\n                 vis: visibility,\n                 span: mk_sp(lo, self.last_span.hi)\n             });\n-        } else if macros_allowed && !self.is_any_keyword(&copy *self.token)\n+        }\n+        if macros_allowed && !self.is_any_keyword(&copy *self.token)\n                 && self.look_ahead(1) == token::NOT\n                 && (is_plain_ident(&self.look_ahead(2))\n                     || self.look_ahead(2) == token::LPAREN\n@@ -4070,16 +4108,16 @@ pub impl Parser {\n             let item_ = item_mac(m);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, id, item_,\n                                           visibility, attrs));\n-        } else {\n-            // FAILURE TO PARSE ITEM\n-            if visibility != inherited {\n-                let mut s = ~\"unmatched visibility `\";\n-                s += if visibility == public { ~\"pub\" } else { ~\"priv\" };\n-                s += ~\"`\";\n-                self.span_fatal(*self.last_span, s);\n-            }\n-            return iovi_none;\n-        };\n+        }\n+\n+        // FAILURE TO PARSE ITEM\n+        if visibility != inherited {\n+            let mut s = ~\"unmatched visibility `\";\n+            s += if visibility == public { ~\"pub\" } else { ~\"priv\" };\n+            s += ~\"`\";\n+            self.span_fatal(*self.last_span, s);\n+        }\n+        return iovi_none;\n     }\n \n     fn parse_item(&self, +attrs: ~[attribute]) -> Option<@ast::item> {\n@@ -4246,17 +4284,17 @@ pub impl Parser {\n \n         let items_allowed = match mode {\n             VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => true,\n-            VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED => false\n+            FOREIGN_ITEMS_ALLOWED => false\n         };\n \n         let restricted_to_imports = match mode {\n             IMPORTS_AND_ITEMS_ALLOWED => true,\n             VIEW_ITEMS_AND_ITEMS_ALLOWED |\n-            VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED => false\n+            FOREIGN_ITEMS_ALLOWED => false\n         };\n \n         let foreign_items_allowed = match mode {\n-            VIEW_ITEMS_AND_FOREIGN_ITEMS_ALLOWED => true,\n+            FOREIGN_ITEMS_ALLOWED => true,\n             VIEW_ITEMS_AND_ITEMS_ALLOWED | IMPORTS_AND_ITEMS_ALLOWED => false\n         };\n "}, {"sha": "e2d48979fab1659303512f76e0c72b3bd6ff8efb", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -424,7 +424,7 @@ pub fn print_type_ex(s: @ps, &&ty: @ast::Ty, print_colons: bool) {\n             ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n-        word(s.s, ~\" * \");\n+        word(s.s, ~\", ..\");\n         print_expr(s, v);\n         word(s.s, ~\"]\");\n       }\n@@ -452,7 +452,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n         end(s); // end the outer fn box\n       }\n       ast::foreign_item_const(t) => {\n-        head(s, ~\"const\");\n+        head(s, ~\"static\");\n         print_ident(s, item.ident);\n         word_space(s, ~\":\");\n         print_type(s, t);\n@@ -471,7 +471,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n     (s.ann.pre)(ann_node);\n     match /*bad*/ copy item.node {\n       ast::item_const(ty, expr) => {\n-        head(s, visibility_qualified(item.vis, ~\"const\"));\n+        head(s, visibility_qualified(item.vis, ~\"static\"));\n         print_ident(s, item.ident);\n         word_space(s, ~\":\");\n         print_type(s, ty);"}, {"sha": "d9b4112b1bd86ea87ab4a3eaf5db661e8fd0bbaf", "filename": "src/test/compile-fail/static-method-privacy.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-method-privacy.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -0,0 +1,11 @@\n+mod a {\n+    pub struct S;\n+    impl S {\n+        static fn new() -> S { S }\n+    }\n+}\n+\n+fn main() {\n+    let _ = a::S::new();    //~ ERROR function `new` is private\n+}\n+"}, {"sha": "24eb5337d25f70d25d05f6340d529fba0642d71a", "filename": "src/test/pretty/blank-lines.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Fpretty%2Fblank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Fpretty%2Fblank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fblank-lines.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // pp-exact\n-fn f() -> [int * 3] {\n+fn f() -> [int, ..3] {\n     let picard = 0;\n \n     let data = 1;"}, {"sha": "223825f60a7493adae68e5fb686dded4f6477f14", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -121,13 +121,6 @@ mod test_foreign_items {\n mod test_use_statements {\n     #[cfg(bogus)]\n     use flippity_foo;\n-\n-    pub mod rustrt {\n-        pub extern {\n-            #[cfg(bogus)]\n-            use flippity_foo;\n-        }\n-    }\n }\n \n mod test_methods {"}, {"sha": "feebcdff921613dad66f2d01b83e803cc8cc315f", "filename": "src/test/run-pass/import-from-foreign.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4cb9ca92962dbbe8ffd813c016e9d6f809dd285b/src%2Ftest%2Frun-pass%2Fimport-from-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cb9ca92962dbbe8ffd813c016e9d6f809dd285b/src%2Ftest%2Frun-pass%2Fimport-from-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport-from-foreign.rs?ref=4cb9ca92962dbbe8ffd813c016e9d6f809dd285b", "patch": "@@ -1,25 +0,0 @@\n-// xfail-fast\n-\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod spam {\n-    pub fn ham() { }\n-    pub fn eggs() { }\n-}\n-\n-mod rustrt {\n-    #[abi = \"cdecl\"]\n-    pub extern {\n-        pub use spam::{ham, eggs};\n-    }\n-}\n-\n-pub fn main() { rustrt::ham(); rustrt::eggs(); }"}, {"sha": "f5c691d512e1225d190c188e4c84239ad1f535f3", "filename": "src/test/run-pass/new-style-constants.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-style-constants.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -0,0 +1,8 @@\n+use core::io::println;\n+\n+static FOO: int = 3;\n+\n+fn main() {\n+    println(fmt!(\"%d\", FOO));\n+}\n+"}, {"sha": "44261458a9aed6fcf61f226c1da087ffb5fc7a3c", "filename": "src/test/run-pass/new-style-fixed-length-vec.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Frun-pass%2Fnew-style-fixed-length-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c879fdd8aad67cf4f6edd3aacb0189c284c920/src%2Ftest%2Frun-pass%2Fnew-style-fixed-length-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-style-fixed-length-vec.rs?ref=f3c879fdd8aad67cf4f6edd3aacb0189c284c920", "patch": "@@ -0,0 +1,10 @@\n+use core::io::println;\n+\n+static FOO: [int, ..3] = [1, 2, 3];\n+\n+fn main() {\n+    println(fmt!(\"%d %d %d\", FOO[0], FOO[1], FOO[2]));\n+}\n+\n+\n+"}]}