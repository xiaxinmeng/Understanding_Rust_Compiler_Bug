{"sha": "2d67edd32c71ac32c8dafb7106e7187993750629", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNjdlZGQzMmM3MWFjMzJjOGRhZmI3MTA2ZTcxODc5OTM3NTA2Mjk=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-25T00:06:51Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T11:11:11Z"}, "message": "Move const eval query components into their own module", "tree": {"sha": "ee06833633ea9e19bce3f4fcb6d6c3fd15bdaaf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee06833633ea9e19bce3f4fcb6d6c3fd15bdaaf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d67edd32c71ac32c8dafb7106e7187993750629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d67edd32c71ac32c8dafb7106e7187993750629", "html_url": "https://github.com/rust-lang/rust/commit/2d67edd32c71ac32c8dafb7106e7187993750629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d67edd32c71ac32c8dafb7106e7187993750629/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40", "html_url": "https://github.com/rust-lang/rust/commit/3e7fa3c6f22798d4228a0dc3ec50bdf185084d40"}], "stats": {"total": 462, "additions": 234, "deletions": 228}, "files": [{"sha": "c308bf8a46c2fb55624e347c10ff35cf259c0520", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 226, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/2d67edd32c71ac32c8dafb7106e7187993750629/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d67edd32c71ac32c8dafb7106e7187993750629/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=2d67edd32c71ac32c8dafb7106e7187993750629", "patch": "@@ -5,12 +5,8 @@ use std::error::Error;\n use std::fmt;\n use std::hash::Hash;\n \n-use crate::interpret::eval_nullary_intrinsic;\n-use crate::interpret::eval_nullary_intrinsic;\n-use rustc::hir::def::DefKind;\n use rustc::mir;\n-use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n-use rustc::traits::Reveal;\n+use rustc::mir::interpret::ScalarMaybeUndef;\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::{self, subst::Subst, TyCtxt};\n \n@@ -21,15 +17,14 @@ use syntax::{\n \n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InterpCx,\n-    InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemoryKind, OpTy, RawConst, RefTracking,\n-    Scalar, StackPopCleanup,\n+    InterpResult, MPlaceTy, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n \n mod error;\n-mod machine;\n+mod query;\n \n pub use error::*;\n-pub use machine::*;\n+pub use query::*;\n \n /// The `InterpCx` is only meant to be used to do field and index projections into constants for\n /// `simd_shuffle` and const patterns in match arms.\n@@ -225,220 +220,3 @@ pub fn const_variant_index<'tcx>(\n     let op = ecx.eval_const_to_op(val, None).unwrap();\n     ecx.read_discriminant(op).unwrap().1\n }\n-\n-/// Turn an interpreter error into something to report to the user.\n-/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-/// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n-    ecx: &InterpCx<'mir, 'tcx, M>,\n-    mut error: InterpErrorInfo<'tcx>,\n-) -> ConstEvalErr<'tcx> {\n-    error.print_backtrace();\n-    let stacktrace = ecx.generate_stacktrace(None);\n-    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n-}\n-\n-pub fn note_on_undefined_behavior_error() -> &'static str {\n-    \"The rules on what exactly is undefined behavior aren't clear, \\\n-     so this check might be overzealous. Please open an issue on the rustc \\\n-     repository if you believe it should not be considered undefined behavior.\"\n-}\n-\n-fn validate_and_turn_into_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    constant: RawConst<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    let cid = key.value;\n-    let def_id = cid.instance.def.def_id();\n-    let is_static = tcx.is_static(def_id);\n-    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n-    let val = (|| {\n-        let mplace = ecx.raw_const_to_mplace(constant)?;\n-        let mut ref_tracking = RefTracking::new(mplace);\n-        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n-            ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n-        }\n-        // Now that we validated, turn this into a proper constant.\n-        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n-        // whether they become immediates.\n-        if is_static || cid.promoted.is_some() {\n-            let ptr = mplace.ptr.to_ptr()?;\n-            Ok(tcx.mk_const(ty::Const {\n-                val: ty::ConstKind::Value(ConstValue::ByRef {\n-                    alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                    offset: ptr.offset,\n-                }),\n-                ty: mplace.layout.ty,\n-            }))\n-        } else {\n-            Ok(op_to_const(&ecx, mplace.into()))\n-        }\n-    })();\n-\n-    val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error);\n-        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n-            Ok(mut diag) => {\n-                diag.note(note_on_undefined_behavior_error());\n-                diag.emit();\n-                ErrorHandled::Reported\n-            }\n-            Err(err) => err,\n-        }\n-    })\n-}\n-\n-pub fn const_eval_validated_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    // see comment in const_eval_raw_provider for what we're doing here\n-    if key.param_env.reveal == Reveal::All {\n-        let mut key = key.clone();\n-        key.param_env.reveal = Reveal::UserFacing;\n-        match tcx.const_eval_validated(key) {\n-            // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {\n-                // Promoteds should never be \"too generic\" when getting evaluated.\n-                // They either don't get evaluated, or we are in a monomorphic context\n-                assert!(key.value.promoted.is_none());\n-            }\n-            // dedupliate calls\n-            other => return other,\n-        }\n-    }\n-\n-    // We call `const_eval` for zero arg intrinsics, too, in order to cache their value.\n-    // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n-    if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n-        let ty = key.value.instance.ty(tcx);\n-        let substs = match ty.kind {\n-            ty::FnDef(_, substs) => substs,\n-            _ => bug!(\"intrinsic with type {:?}\", ty),\n-        };\n-        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n-            let span = tcx.def_span(def_id);\n-            let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n-            error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n-        });\n-    }\n-\n-    tcx.const_eval_raw(key).and_then(|val| validate_and_turn_into_const(tcx, val, key))\n-}\n-\n-pub fn const_eval_raw_provider<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n-) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n-    // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n-    // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n-    // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n-    // computed. For a large percentage of constants that will already have succeeded. Only\n-    // associated constants of generic functions will fail due to not enough monomorphization\n-    // information being available.\n-\n-    // In case we fail in the `UserFacing` variant, we just do the real computation.\n-    if key.param_env.reveal == Reveal::All {\n-        let mut key = key.clone();\n-        key.param_env.reveal = Reveal::UserFacing;\n-        match tcx.const_eval_raw(key) {\n-            // try again with reveal all as requested\n-            Err(ErrorHandled::TooGeneric) => {}\n-            // dedupliate calls\n-            other => return other,\n-        }\n-    }\n-    if cfg!(debug_assertions) {\n-        // Make sure we format the instance even if we do not print it.\n-        // This serves as a regression test against an ICE on printing.\n-        // The next two lines concatenated contain some discussion:\n-        // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n-        // subject/anon_const_instance_printing/near/135980032\n-        let instance = key.value.instance.to_string();\n-        trace!(\"const eval: {:?} ({})\", key, instance);\n-    }\n-\n-    let cid = key.value;\n-    let def_id = cid.instance.def.def_id();\n-\n-    if def_id.is_local() && tcx.typeck_tables_of(def_id).tainted_by_errors {\n-        return Err(ErrorHandled::Reported);\n-    }\n-\n-    let is_static = tcx.is_static(def_id);\n-\n-    let span = tcx.def_span(cid.instance.def_id());\n-    let mut ecx = InterpCx::new(\n-        tcx.at(span),\n-        key.param_env,\n-        CompileTimeInterpreter::new(),\n-        MemoryExtra { can_access_statics: is_static },\n-    );\n-\n-    let res = ecx.load_mir(cid.instance.def, cid.promoted);\n-    res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, *body))\n-        .and_then(|place| {\n-            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n-        })\n-        .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error);\n-            // errors in statics are always emitted as fatal errors\n-            if is_static {\n-                // Ensure that if the above error was either `TooGeneric` or `Reported`\n-                // an error must be reported.\n-                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n-                tcx.sess.delay_span_bug(\n-                    err.span,\n-                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n-                );\n-                v\n-            } else if def_id.is_local() {\n-                // constant defined in this crate, we can figure out a lint level!\n-                match tcx.def_kind(def_id) {\n-                    // constants never produce a hard error at the definition site. Anything else is\n-                    // a backwards compatibility hazard (and will break old versions of winapi for sure)\n-                    //\n-                    // note that validation may still cause a hard error on this very same constant,\n-                    // because any code that existed before validation could not have failed validation\n-                    // thus preventing such a hard error from being a backwards compatibility hazard\n-                    Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-                        err.report_as_lint(\n-                            tcx.at(tcx.def_span(def_id)),\n-                            \"any use of this value will cause an error\",\n-                            hir_id,\n-                            Some(err.span),\n-                        )\n-                    }\n-                    // promoting runtime code is only allowed to error if it references broken constants\n-                    // any other kind of error will be reported to the user as a deny-by-default lint\n-                    _ => {\n-                        if let Some(p) = cid.promoted {\n-                            let span = tcx.promoted_mir(def_id)[p].span;\n-                            if let err_inval!(ReferencedConstant) = err.error {\n-                                err.report_as_error(\n-                                    tcx.at(span),\n-                                    \"evaluation of constant expression failed\",\n-                                )\n-                            } else {\n-                                err.report_as_lint(\n-                                    tcx.at(span),\n-                                    \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n-                                    Some(err.span),\n-                                )\n-                            }\n-                        // anything else (array lengths, enum initializers, constant patterns) are reported\n-                        // as hard errors\n-                        } else {\n-                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n-                        }\n-                    }\n-                }\n-            } else {\n-                // use of broken constant from other crate\n-                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n-            }\n-        })\n-}"}, {"sha": "c2db3c31f85be45e667944cf1287b57ca43cc6d9", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2d67edd32c71ac32c8dafb7106e7187993750629/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d67edd32c71ac32c8dafb7106e7187993750629/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=2d67edd32c71ac32c8dafb7106e7187993750629", "patch": "@@ -1,8 +1,8 @@\n use std::error::Error;\n use std::fmt;\n \n-use crate::interpret::InterpErrorInfo;\n-\n+use super::InterpCx;\n+use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n #[derive(Clone, Debug)]\n pub enum ConstEvalError {\n     NeedsRfc(String),\n@@ -28,3 +28,15 @@ impl fmt::Display for ConstEvalError {\n }\n \n impl Error for ConstEvalError {}\n+\n+/// Turn an interpreter error into something to report to the user.\n+/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n+/// Should be called only if the error is actually going to to be reported!\n+pub fn error_to_const_error<'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+    ecx: &InterpCx<'mir, 'tcx, M>,\n+    mut error: InterpErrorInfo<'tcx>,\n+) -> ConstEvalErr<'tcx> {\n+    error.print_backtrace();\n+    let stacktrace = ecx.generate_stacktrace(None);\n+    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+}"}, {"sha": "0a33143e8c682756a2fde583fb35ae3279f05a9b", "filename": "src/librustc_mir/const_eval/query.rs", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/2d67edd32c71ac32c8dafb7106e7187993750629/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d67edd32c71ac32c8dafb7106e7187993750629/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fquery.rs?ref=2d67edd32c71ac32c8dafb7106e7187993750629", "patch": "@@ -0,0 +1,216 @@\n+use crate::interpret::eval_nullary_intrinsic;\n+use rustc::hir::def::DefKind;\n+use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc::traits::Reveal;\n+use rustc::ty::{self, TyCtxt};\n+\n+use crate::interpret::{ConstValue, GlobalId, InterpCx, RawConst, RefTracking};\n+\n+use super::{\n+    error_to_const_error, eval_body_using_ecx, mk_eval_cx, op_to_const, CompileTimeInterpreter,\n+};\n+\n+pub fn note_on_undefined_behavior_error() -> &'static str {\n+    \"The rules on what exactly is undefined behavior aren't clear, \\\n+     so this check might be overzealous. Please open an issue on the rustc \\\n+     repository if you believe it should not be considered undefined behavior.\"\n+}\n+\n+fn validate_and_turn_into_const<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    constant: RawConst<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n+) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+    let cid = key.value;\n+    let def_id = cid.instance.def.def_id();\n+    let is_static = tcx.is_static(def_id);\n+    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n+    let val = (|| {\n+        let mplace = ecx.raw_const_to_mplace(constant)?;\n+        let mut ref_tracking = RefTracking::new(mplace);\n+        while let Some((mplace, path)) = ref_tracking.todo.pop() {\n+            ecx.validate_operand(mplace.into(), path, Some(&mut ref_tracking))?;\n+        }\n+        // Now that we validated, turn this into a proper constant.\n+        // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n+        // whether they become immediates.\n+        if is_static || cid.promoted.is_some() {\n+            let ptr = mplace.ptr.to_ptr()?;\n+            Ok(tcx.mk_const(ty::Const {\n+                val: ty::ConstKind::Value(ConstValue::ByRef {\n+                    alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                    offset: ptr.offset,\n+                }),\n+                ty: mplace.layout.ty,\n+            }))\n+        } else {\n+            Ok(op_to_const(&ecx, mplace.into()))\n+        }\n+    })();\n+\n+    val.map_err(|error| {\n+        let err = error_to_const_error(&ecx, error);\n+        match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n+            Ok(mut diag) => {\n+                diag.note(note_on_undefined_behavior_error());\n+                diag.emit();\n+                ErrorHandled::Reported\n+            }\n+            Err(err) => err,\n+        }\n+    })\n+}\n+\n+pub fn const_eval_validated_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n+) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n+    // see comment in const_eval_raw_provider for what we're doing here\n+    if key.param_env.reveal == Reveal::All {\n+        let mut key = key.clone();\n+        key.param_env.reveal = Reveal::UserFacing;\n+        match tcx.const_eval_validated(key) {\n+            // try again with reveal all as requested\n+            Err(ErrorHandled::TooGeneric) => {\n+                // Promoteds should never be \"too generic\" when getting evaluated.\n+                // They either don't get evaluated, or we are in a monomorphic context\n+                assert!(key.value.promoted.is_none());\n+            }\n+            // dedupliate calls\n+            other => return other,\n+        }\n+    }\n+\n+    // We call `const_eval` for zero arg intrinsics, too, in order to cache their value.\n+    // Catch such calls and evaluate them instead of trying to load a constant's MIR.\n+    if let ty::InstanceDef::Intrinsic(def_id) = key.value.instance.def {\n+        let ty = key.value.instance.ty(tcx);\n+        let substs = match ty.kind {\n+            ty::FnDef(_, substs) => substs,\n+            _ => bug!(\"intrinsic with type {:?}\", ty),\n+        };\n+        return eval_nullary_intrinsic(tcx, key.param_env, def_id, substs).map_err(|error| {\n+            let span = tcx.def_span(def_id);\n+            let error = ConstEvalErr { error: error.kind, stacktrace: vec![], span };\n+            error.report_as_error(tcx.at(span), \"could not evaluate nullary intrinsic\")\n+        });\n+    }\n+\n+    tcx.const_eval_raw(key).and_then(|val| validate_and_turn_into_const(tcx, val, key))\n+}\n+\n+pub fn const_eval_raw_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n+) -> ::rustc::mir::interpret::ConstEvalRawResult<'tcx> {\n+    // Because the constant is computed twice (once per value of `Reveal`), we are at risk of\n+    // reporting the same error twice here. To resolve this, we check whether we can evaluate the\n+    // constant in the more restrictive `Reveal::UserFacing`, which most likely already was\n+    // computed. For a large percentage of constants that will already have succeeded. Only\n+    // associated constants of generic functions will fail due to not enough monomorphization\n+    // information being available.\n+\n+    // In case we fail in the `UserFacing` variant, we just do the real computation.\n+    if key.param_env.reveal == Reveal::All {\n+        let mut key = key.clone();\n+        key.param_env.reveal = Reveal::UserFacing;\n+        match tcx.const_eval_raw(key) {\n+            // try again with reveal all as requested\n+            Err(ErrorHandled::TooGeneric) => {}\n+            // dedupliate calls\n+            other => return other,\n+        }\n+    }\n+    if cfg!(debug_assertions) {\n+        // Make sure we format the instance even if we do not print it.\n+        // This serves as a regression test against an ICE on printing.\n+        // The next two lines concatenated contain some discussion:\n+        // https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/\n+        // subject/anon_const_instance_printing/near/135980032\n+        let instance = key.value.instance.to_string();\n+        trace!(\"const eval: {:?} ({})\", key, instance);\n+    }\n+\n+    let cid = key.value;\n+    let def_id = cid.instance.def.def_id();\n+\n+    if def_id.is_local() && tcx.typeck_tables_of(def_id).tainted_by_errors {\n+        return Err(ErrorHandled::Reported);\n+    }\n+\n+    let is_static = tcx.is_static(def_id);\n+\n+    let span = tcx.def_span(cid.instance.def_id());\n+    let mut ecx = InterpCx::new(\n+        tcx.at(span),\n+        key.param_env,\n+        CompileTimeInterpreter::new(),\n+        MemoryExtra { can_access_statics: is_static },\n+    );\n+\n+    let res = ecx.load_mir(cid.instance.def, cid.promoted);\n+    res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, *body))\n+        .and_then(|place| {\n+            Ok(RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n+        })\n+        .map_err(|error| {\n+            let err = error_to_const_error(&ecx, error);\n+            // errors in statics are always emitted as fatal errors\n+            if is_static {\n+                // Ensure that if the above error was either `TooGeneric` or `Reported`\n+                // an error must be reported.\n+                let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n+                tcx.sess.delay_span_bug(\n+                    err.span,\n+                    &format!(\"static eval failure did not emit an error: {:#?}\", v),\n+                );\n+                v\n+            } else if def_id.is_local() {\n+                // constant defined in this crate, we can figure out a lint level!\n+                match tcx.def_kind(def_id) {\n+                    // constants never produce a hard error at the definition site. Anything else is\n+                    // a backwards compatibility hazard (and will break old versions of winapi for sure)\n+                    //\n+                    // note that validation may still cause a hard error on this very same constant,\n+                    // because any code that existed before validation could not have failed validation\n+                    // thus preventing such a hard error from being a backwards compatibility hazard\n+                    Some(DefKind::Const) | Some(DefKind::AssocConst) => {\n+                        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                        err.report_as_lint(\n+                            tcx.at(tcx.def_span(def_id)),\n+                            \"any use of this value will cause an error\",\n+                            hir_id,\n+                            Some(err.span),\n+                        )\n+                    }\n+                    // promoting runtime code is only allowed to error if it references broken constants\n+                    // any other kind of error will be reported to the user as a deny-by-default lint\n+                    _ => {\n+                        if let Some(p) = cid.promoted {\n+                            let span = tcx.promoted_mir(def_id)[p].span;\n+                            if let err_inval!(ReferencedConstant) = err.error {\n+                                err.report_as_error(\n+                                    tcx.at(span),\n+                                    \"evaluation of constant expression failed\",\n+                                )\n+                            } else {\n+                                err.report_as_lint(\n+                                    tcx.at(span),\n+                                    \"reaching this expression at runtime will panic or abort\",\n+                                    tcx.hir().as_local_hir_id(def_id).unwrap(),\n+                                    Some(err.span),\n+                                )\n+                            }\n+                        // anything else (array lengths, enum initializers, constant patterns) are reported\n+                        // as hard errors\n+                        } else {\n+                            err.report_as_error(ecx.tcx, \"evaluation of constant value failed\")\n+                        }\n+                    }\n+                }\n+            } else {\n+                // use of broken constant from other crate\n+                err.report_as_error(ecx.tcx, \"could not evaluate constant\")\n+            }\n+        })\n+}"}]}