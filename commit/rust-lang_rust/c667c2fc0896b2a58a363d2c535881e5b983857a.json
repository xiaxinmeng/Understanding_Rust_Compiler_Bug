{"sha": "c667c2fc0896b2a58a363d2c535881e5b983857a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NjdjMmZjMDg5NmIyYTU4YTM2M2QyYzUzNTg4MWU1Yjk4Mzg1N2E=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-23T21:06:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-24T09:10:16Z"}, "message": "Remove methods is_struct/is_tuple/is_unit from VariantData", "tree": {"sha": "4116c0d210c4535f319e4c5f1ae483dabe5e9373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4116c0d210c4535f319e4c5f1ae483dabe5e9373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c667c2fc0896b2a58a363d2c535881e5b983857a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c667c2fc0896b2a58a363d2c535881e5b983857a", "html_url": "https://github.com/rust-lang/rust/commit/c667c2fc0896b2a58a363d2c535881e5b983857a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c667c2fc0896b2a58a363d2c535881e5b983857a/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17", "html_url": "https://github.com/rust-lang/rust/commit/5c3d1e5d76fdc6d9f40ab13a6a342e1f7ceb4f17"}], "stats": {"total": 311, "additions": 130, "deletions": 181}, "files": [{"sha": "7895919e15078c01fd8aedeeb7802d5b43685dbc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -2208,33 +2208,6 @@ impl VariantData {\n             VariantData::Tuple(_, hir_id) | VariantData::Unit(hir_id) => Some(hir_id),\n         }\n     }\n-\n-    /// Does this `VariantData` represent a `Struct`-struct/variant?\n-    pub fn is_struct(&self) -> bool {\n-        if let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Does this `VariantData` represent a tuple struct/variant?\n-    pub fn is_tuple(&self) -> bool {\n-        if let VariantData::Tuple(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Does this `VariantData` represent a unit struct/variant?\n-    pub fn is_unit(&self) -> bool {\n-        if let VariantData::Unit(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n }\n \n // The bodies for items are stored \"out of line\", in a separate"}, {"sha": "cdd4043f4bc2189624ac137b55d0aa23ea853af3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -860,41 +860,44 @@ impl<'a> State<'a> {\n                         -> io::Result<()> {\n         self.print_name(name)?;\n         self.print_generic_params(&generics.params)?;\n-        if !struct_def.is_struct() {\n-            if struct_def.is_tuple() {\n-                self.popen()?;\n-                self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                    s.maybe_print_comment(field.span.lo())?;\n-                    s.print_outer_attributes(&field.attrs)?;\n-                    s.print_visibility(&field.vis)?;\n-                    s.print_type(&field.ty)\n-                })?;\n-                self.pclose()?;\n-            }\n-            self.print_where_clause(&generics.where_clause)?;\n-            if print_finalizer {\n-                self.s.word(\";\")?;\n+        match struct_def {\n+            hir::VariantData::Tuple(..) | hir::VariantData::Unit(..) => {\n+                if let hir::VariantData::Tuple(..) = struct_def {\n+                    self.popen()?;\n+                    self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n+                        s.maybe_print_comment(field.span.lo())?;\n+                        s.print_outer_attributes(&field.attrs)?;\n+                        s.print_visibility(&field.vis)?;\n+                        s.print_type(&field.ty)\n+                    })?;\n+                    self.pclose()?;\n+                }\n+                self.print_where_clause(&generics.where_clause)?;\n+                if print_finalizer {\n+                    self.s.word(\";\")?;\n+                }\n+                self.end()?;\n+                self.end() // close the outer-box\n             }\n-            self.end()?;\n-            self.end() // close the outer-box\n-        } else {\n-            self.print_where_clause(&generics.where_clause)?;\n-            self.nbsp()?;\n-            self.bopen()?;\n-            self.hardbreak_if_not_bol()?;\n-\n-            for field in struct_def.fields() {\n+            hir::VariantData::Struct(..) => {\n+                self.print_where_clause(&generics.where_clause)?;\n+                self.nbsp()?;\n+                self.bopen()?;\n                 self.hardbreak_if_not_bol()?;\n-                self.maybe_print_comment(field.span.lo())?;\n-                self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(&field.vis)?;\n-                self.print_ident(field.ident)?;\n-                self.word_nbsp(\":\")?;\n-                self.print_type(&field.ty)?;\n-                self.s.word(\",\")?;\n-            }\n \n-            self.bclose(span)\n+                for field in struct_def.fields() {\n+                    self.hardbreak_if_not_bol()?;\n+                    self.maybe_print_comment(field.span.lo())?;\n+                    self.print_outer_attributes(&field.attrs)?;\n+                    self.print_visibility(&field.vis)?;\n+                    self.print_ident(field.ident)?;\n+                    self.word_nbsp(\":\")?;\n+                    self.print_type(&field.ty)?;\n+                    self.s.word(\",\")?;\n+                }\n+\n+                self.bclose(span)\n+            }\n         }\n     }\n "}, {"sha": "4e2aefe623167ffdb16e967db09ada688b74ca7e", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -661,7 +661,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 }\n             }\n             ItemKind::Union(ref vdata, _) => {\n-                if !vdata.is_struct() {\n+                if let VariantData::Tuple(..) | VariantData::Unit(..) = vdata {\n                     self.err_handler().span_err(item.span,\n                                                 \"tuple and unit unions are not permitted\");\n                 }"}, {"sha": "ddd68c483790e04d2f3e3e689d87168de1790d3b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -3192,12 +3192,11 @@ pub enum VariantKind {\n \n impl Clean<VariantKind> for hir::VariantData {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantKind {\n-        if self.is_struct() {\n-            VariantKind::Struct(self.clean(cx))\n-        } else if self.is_unit() {\n-            VariantKind::CLike\n-        } else {\n-            VariantKind::Tuple(self.fields().iter().map(|x| x.ty.clean(cx)).collect())\n+        match self {\n+            hir::VariantData::Struct(..) => VariantKind::Struct(self.clean(cx)),\n+            hir::VariantData::Tuple(..) =>\n+                VariantKind::Tuple(self.fields().iter().map(|x| x.ty.clean(cx)).collect()),\n+            hir::VariantData::Unit(..) => VariantKind::CLike,\n         }\n     }\n }"}, {"sha": "bcc8fdf8cd4e7fc68e3955b3214d8b69e9aff66f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -2155,33 +2155,6 @@ impl VariantData {\n             VariantData::Tuple(_, id) | VariantData::Unit(id) => Some(id),\n         }\n     }\n-\n-    /// Does this `VariantData` represent a `Struct`-struct/variant?\n-    pub fn is_struct(&self) -> bool {\n-        if let VariantData::Struct(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Does this `VariantData` represent a tuple struct/variant?\n-    pub fn is_tuple(&self) -> bool {\n-        if let VariantData::Tuple(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// Does this `VariantData` represent a unit struct/variant?\n-    pub fn is_unit(&self) -> bool {\n-        if let VariantData::Unit(..) = *self {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n }\n \n /// An item."}, {"sha": "f5a9aded8455e5a40a5bd8ec9ac60fa88e521324", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -1550,44 +1550,47 @@ impl<'a> State<'a> {\n                         print_finalizer: bool) -> io::Result<()> {\n         self.print_ident(ident)?;\n         self.print_generic_params(&generics.params)?;\n-        if !struct_def.is_struct() {\n-            if struct_def.is_tuple() {\n-                self.popen()?;\n-                self.commasep(\n-                    Inconsistent, struct_def.fields(),\n-                    |s, field| {\n-                        s.maybe_print_comment(field.span.lo())?;\n-                        s.print_outer_attributes(&field.attrs)?;\n-                        s.print_visibility(&field.vis)?;\n-                        s.print_type(&field.ty)\n-                    }\n-                )?;\n-                self.pclose()?;\n-            }\n-            self.print_where_clause(&generics.where_clause)?;\n-            if print_finalizer {\n-                self.s.word(\";\")?;\n+        match struct_def {\n+            ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+                if let ast::VariantData::Tuple(..) = struct_def {\n+                    self.popen()?;\n+                    self.commasep(\n+                        Inconsistent, struct_def.fields(),\n+                        |s, field| {\n+                            s.maybe_print_comment(field.span.lo())?;\n+                            s.print_outer_attributes(&field.attrs)?;\n+                            s.print_visibility(&field.vis)?;\n+                            s.print_type(&field.ty)\n+                        }\n+                    )?;\n+                    self.pclose()?;\n+                }\n+                self.print_where_clause(&generics.where_clause)?;\n+                if print_finalizer {\n+                    self.s.word(\";\")?;\n+                }\n+                self.end()?;\n+                self.end() // close the outer-box\n             }\n-            self.end()?;\n-            self.end() // close the outer-box\n-        } else {\n-            self.print_where_clause(&generics.where_clause)?;\n-            self.nbsp()?;\n-            self.bopen()?;\n-            self.hardbreak_if_not_bol()?;\n-\n-            for field in struct_def.fields() {\n+            ast::VariantData::Struct(..) => {\n+                self.print_where_clause(&generics.where_clause)?;\n+                self.nbsp()?;\n+                self.bopen()?;\n                 self.hardbreak_if_not_bol()?;\n-                self.maybe_print_comment(field.span.lo())?;\n-                self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(&field.vis)?;\n-                self.print_ident(field.ident.unwrap())?;\n-                self.word_nbsp(\":\")?;\n-                self.print_type(&field.ty)?;\n-                self.s.word(\",\")?;\n-            }\n \n-            self.bclose(span)\n+                for field in struct_def.fields() {\n+                    self.hardbreak_if_not_bol()?;\n+                    self.maybe_print_comment(field.span.lo())?;\n+                    self.print_outer_attributes(&field.attrs)?;\n+                    self.print_visibility(&field.vis)?;\n+                    self.print_ident(field.ident.unwrap())?;\n+                    self.word_nbsp(\":\")?;\n+                    self.print_type(&field.ty)?;\n+                    self.s.word(\",\")?;\n+                }\n+\n+                self.bclose(span)\n+            }\n         }\n     }\n "}, {"sha": "7c47c6ff79ac1f25d45f077c2887f3e67029e43d", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 46, "deletions": 50, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -51,9 +51,9 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n     // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n     // based on the \"shape\".\n-    let (ident, is_struct) = match *substr.fields {\n-        Struct(vdata, _) => (substr.type_ident, vdata.is_struct()),\n-        EnumMatching(_, _, v, _) => (v.node.ident, v.node.data.is_struct()),\n+    let (ident, vdata, fields) = match substr.fields {\n+        Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n+        EnumMatching(_, _, v, fields) => (v.node.ident, &v.node.data, fields),\n         EnumNonMatchingCollapsed(..) |\n         StaticStruct(..) |\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),\n@@ -67,55 +67,51 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n     let fmt = substr.nonself_args[0].clone();\n \n-    let mut stmts = match *substr.fields {\n-        Struct(_, ref fields) |\n-        EnumMatching(.., ref fields) => {\n-            let mut stmts = vec![];\n-            if !is_struct {\n-                // tuple struct/\"normal\" variant\n-                let expr =\n-                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n-                stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n-\n-                for field in fields {\n-                    // Use double indirection to make sure this works for unsized types\n-                    let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                    let field = cx.expr_addr_of(field.span, field);\n-\n-                    let expr = cx.expr_method_call(span,\n-                                                   builder_expr.clone(),\n-                                                   Ident::from_str(\"field\"),\n-                                                   vec![field]);\n-\n-                    // Use `let _ = expr;` to avoid triggering the\n-                    // unused_results lint.\n-                    stmts.push(stmt_let_undescore(cx, span, expr));\n-                }\n-            } else {\n-                // normal struct/struct variant\n-                let expr =\n-                    cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n-                stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n-\n-                for field in fields {\n-                    let name = cx.expr_lit(field.span,\n-                                           ast::LitKind::Str(field.name.unwrap().name,\n-                                                             ast::StrStyle::Cooked));\n-\n-                    // Use double indirection to make sure this works for unsized types\n-                    let field = cx.expr_addr_of(field.span, field.self_.clone());\n-                    let field = cx.expr_addr_of(field.span, field);\n-                    let expr = cx.expr_method_call(span,\n-                                                   builder_expr.clone(),\n-                                                   Ident::from_str(\"field\"),\n-                                                   vec![name, field]);\n-                    stmts.push(stmt_let_undescore(cx, span, expr));\n-                }\n+    let mut stmts = vec![];\n+    match vdata {\n+        ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n+            // tuple struct/\"normal\" variant\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_tuple\"), vec![name]);\n+            stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n+\n+            for field in fields {\n+                // Use double indirection to make sure this works for unsized types\n+                let field = cx.expr_addr_of(field.span, field.self_.clone());\n+                let field = cx.expr_addr_of(field.span, field);\n+\n+                let expr = cx.expr_method_call(span,\n+                                                builder_expr.clone(),\n+                                                Ident::from_str(\"field\"),\n+                                                vec![field]);\n+\n+                // Use `let _ = expr;` to avoid triggering the\n+                // unused_results lint.\n+                stmts.push(stmt_let_undescore(cx, span, expr));\n             }\n-            stmts\n         }\n-        _ => unreachable!(),\n-    };\n+        ast::VariantData::Struct(..) => {\n+            // normal struct/struct variant\n+            let expr =\n+                cx.expr_method_call(span, fmt, Ident::from_str(\"debug_struct\"), vec![name]);\n+            stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n+\n+            for field in fields {\n+                let name = cx.expr_lit(field.span,\n+                                        ast::LitKind::Str(field.name.unwrap().name,\n+                                                            ast::StrStyle::Cooked));\n+\n+                // Use double indirection to make sure this works for unsized types\n+                let field = cx.expr_addr_of(field.span, field.self_.clone());\n+                let field = cx.expr_addr_of(field.span, field);\n+                let expr = cx.expr_method_call(span,\n+                                                builder_expr.clone(),\n+                                                Ident::from_str(\"field\"),\n+                                                vec![name, field]);\n+                stmts.push(stmt_let_undescore(cx, span, expr));\n+            }\n+        }\n+    }\n \n     let expr = cx.expr_method_call(span, builder_expr, Ident::from_str(\"finish\"), vec![]);\n "}, {"sha": "dc0d72a7830e633b646be56054f818ccbad66cd3", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c667c2fc0896b2a58a363d2c535881e5b983857a/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c667c2fc0896b2a58a363d2c535881e5b983857a", "patch": "@@ -1539,6 +1539,7 @@ impl<'a> TraitDef<'a> {\n             }\n         }\n \n+        let is_tuple = if let ast::VariantData::Tuple(..) = struct_def { true } else { false };\n         match (just_spans.is_empty(), named_idents.is_empty()) {\n             (false, false) => {\n                 cx.span_bug(self.span,\n@@ -1547,9 +1548,10 @@ impl<'a> TraitDef<'a> {\n             }\n             // named fields\n             (_, false) => Named(named_idents),\n-            // empty structs\n-            _ if struct_def.is_struct() => Named(named_idents),\n-            _ => Unnamed(just_spans, struct_def.is_tuple()),\n+            // unnamed fields\n+            (false, _) => Unnamed(just_spans, is_tuple),\n+            // empty\n+            _ => Named(Vec::new()),\n         }\n     }\n "}]}