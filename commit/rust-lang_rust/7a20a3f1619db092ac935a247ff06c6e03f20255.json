{"sha": "7a20a3f1619db092ac935a247ff06c6e03f20255", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhMjBhM2YxNjE5ZGIwOTJhYzkzNWEyNDdmZjA2YzZlMDNmMjAyNTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-01T19:20:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-13T17:20:28Z"}, "message": "change to use an O(1) data structure for looking up point indices\n\nConverting a `RegionElementIndex` to a `Location` is O(n) though could\ntrivially be O(log n), but we don't do it that much anyhow -- just on\nerror and debugging.", "tree": {"sha": "3f8a8fa976042f43f7d32a7b66d3782134707b69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f8a8fa976042f43f7d32a7b66d3782134707b69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7a20a3f1619db092ac935a247ff06c6e03f20255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7a20a3f1619db092ac935a247ff06c6e03f20255", "html_url": "https://github.com/rust-lang/rust/commit/7a20a3f1619db092ac935a247ff06c6e03f20255", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7a20a3f1619db092ac935a247ff06c6e03f20255/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77663a677da13757e7aa0b4d1a2bc77612000ab9", "url": "https://api.github.com/repos/rust-lang/rust/commits/77663a677da13757e7aa0b4d1a2bc77612000ab9", "html_url": "https://github.com/rust-lang/rust/commit/77663a677da13757e7aa0b4d1a2bc77612000ab9"}], "stats": {"total": 98, "additions": 77, "deletions": 21}, "files": [{"sha": "c1518b28daba59a5a6d45824f6c9dfb53c9ab4ab", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7a20a3f1619db092ac935a247ff06c6e03f20255/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a20a3f1619db092ac935a247ff06c6e03f20255/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=7a20a3f1619db092ac935a247ff06c6e03f20255", "patch": "@@ -107,16 +107,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let num_region_variables = var_origins.len();\n         let num_universal_regions = universal_regions.len();\n \n-        let mut points = Vec::new();\n-        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n-            for statement_index in 0..block_data.statements.len() + 1 {\n-                points.push(Location {\n-                    block,\n-                    statement_index,\n-                });\n-            }\n-        }\n-        let elements = &Rc::new(RegionValueElements::new(points, num_universal_regions));\n+        let elements = &Rc::new(RegionValueElements::new(mir, num_universal_regions));\n \n         // Create a RegionDefinition for each inference variable.\n         let definitions = var_origins"}, {"sha": "849ccd3259a2459f6247241f68f3532e179bebc5", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 76, "deletions": 11, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7a20a3f1619db092ac935a247ff06c6e03f20255/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a20a3f1619db092ac935a247ff06c6e03f20255/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=7a20a3f1619db092ac935a247ff06c6e03f20255", "patch": "@@ -1,32 +1,66 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n use std::rc::Rc;\n use rustc_data_structures::bitvec::BitMatrix;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::Location;\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::RegionVid;\n \n /// Maps between the various kinds of elements of a region value to\n /// the internal indices that w use.\n pub(super) struct RegionValueElements {\n-    points: Vec<Location>,\n+    /// For each basic block, how many points are contained within?\n+    statements_before_block: IndexVec<BasicBlock, usize>,\n+    num_points: usize,\n     num_universal_regions: usize,\n }\n \n impl RegionValueElements {\n-    pub(super) fn new(points: Vec<Location>, num_universal_regions: usize) -> Self {\n+    pub(super) fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n+        let mut num_points = 0;\n+        let statements_before_block =\n+            mir.basic_blocks()\n+               .iter()\n+               .map(|block_data| {\n+                   let v = num_points;\n+                   num_points += block_data.statements.len() + 1;\n+                   v\n+               })\n+               .collect();\n+\n+        debug!(\"RegionValueElements(num_universal_regions={:?})\", num_universal_regions);\n+        debug!(\"RegionValueElements: statements_before_block={:#?}\", statements_before_block);\n+        debug!(\"RegionValueElements: num_points={:#?}\", num_points);\n+\n         Self {\n-            points,\n+            statements_before_block,\n             num_universal_regions,\n+            num_points,\n         }\n     }\n \n+    /// Total number of element indices that exist.\n+    pub(super) fn num_elements(&self) -> usize {\n+        self.num_points + self.num_universal_regions\n+    }\n+\n     /// Converts an element of a region value into a `RegionElementIndex`.\n     pub(super) fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n         elem.to_element_index(self)\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n     pub(super) fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        (0..self.points.len()).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n+        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n     }\n \n     /// Iterates over the `RegionElementIndex` for all points in the CFG.\n@@ -36,10 +70,42 @@ impl RegionValueElements {\n \n     /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n     pub(super) fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n+        debug!(\"to_element(i={:?})\", i);\n+\n         if let Some(r) = self.to_universal_region(i) {\n             RegionElement::UniversalRegion(r)\n         } else {\n-            RegionElement::Location(self.points[i.index() - self.num_universal_regions])\n+            let point_index = i.index() - self.num_universal_regions;\n+\n+            // Find the basic block. We have a vector with the\n+            // starting index of the statement in each block. Imagine\n+            // we have statement #22, and we have a vector like:\n+            //\n+            // [0, 10, 20]\n+            //\n+            // In that case, this represents point_index 2 of\n+            // basic block BB2. We know this because BB0 accounts for\n+            // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+            // 20...\n+            //\n+            // To compute this, we could do a binary search, but\n+            // because I am lazy we instead iterate through to find\n+            // the last point where the \"first index\" (0, 10, or 20)\n+            // was less than the statement index (22). In our case, this will\n+            // be (BB2, 20).\n+            //\n+            // Nit: we could do a binary search here but I'm too lazy.\n+            let (block, &first_index) =\n+                self.statements_before_block\n+                    .iter_enumerated()\n+                    .filter(|(_, first_index)| **first_index <= point_index)\n+                    .last()\n+                    .unwrap();\n+\n+            RegionElement::Location(Location {\n+                block,\n+                statement_index: point_index - first_index,\n+            })\n         }\n     }\n \n@@ -85,8 +151,9 @@ pub(super) trait ToElementIndex {\n \n impl ToElementIndex for Location {\n     fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n-        let index = elements.points.binary_search(&self).unwrap();\n-        RegionElementIndex::new(index + elements.num_universal_regions)\n+        let Location { block, statement_index } = self;\n+        let start_index = elements.statements_before_block[block];\n+        RegionElementIndex::new(elements.num_universal_regions + start_index + statement_index)\n     }\n }\n \n@@ -120,11 +187,9 @@ impl RegionValues {\n             \"universal regions are a subset of the region variables\"\n         );\n \n-        let num_columns = elements.points.len() + elements.num_universal_regions;\n-\n         Self {\n             elements: elements.clone(),\n-            matrix: BitMatrix::new(num_region_variables, num_columns),\n+            matrix: BitMatrix::new(num_region_variables, elements.num_elements()),\n         }\n     }\n "}]}