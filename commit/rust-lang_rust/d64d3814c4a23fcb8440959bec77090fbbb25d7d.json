{"sha": "d64d3814c4a23fcb8440959bec77090fbbb25d7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NGQzODE0YzRhMjNmY2I4NDQwOTU5YmVjNzcwOTBmYmJiMjVkN2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-16T01:39:47Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-24T21:06:01Z"}, "message": "Rename `builtin` => `global`.", "tree": {"sha": "20072ec61a63e197c1d1aab52c942f917a24ac65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20072ec61a63e197c1d1aab52c942f917a24ac65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d64d3814c4a23fcb8440959bec77090fbbb25d7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d64d3814c4a23fcb8440959bec77090fbbb25d7d", "html_url": "https://github.com/rust-lang/rust/commit/d64d3814c4a23fcb8440959bec77090fbbb25d7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d64d3814c4a23fcb8440959bec77090fbbb25d7d/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64e9af47f4e517208fc1dd950340a0c046ad87b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/64e9af47f4e517208fc1dd950340a0c046ad87b5", "html_url": "https://github.com/rust-lang/rust/commit/64e9af47f4e517208fc1dd950340a0c046ad87b5"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "86e0d0039d1a7c4a517308a66177409be5516995", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d64d3814c4a23fcb8440959bec77090fbbb25d7d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64d3814c4a23fcb8440959bec77090fbbb25d7d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=d64d3814c4a23fcb8440959bec77090fbbb25d7d", "patch": "@@ -539,7 +539,7 @@ impl<'a> Resolver<'a> {\n                            binding: &'a NameBinding<'a>,\n                            span: Span,\n                            allow_shadowing: bool) {\n-        if self.builtin_macros.insert(name, binding).is_some() && !allow_shadowing {\n+        if self.global_macros.insert(name, binding).is_some() && !allow_shadowing {\n             let msg = format!(\"`{}` is already in scope\", name);\n             let note =\n                 \"macro-expanded `#[macro_use]`s may not shadow existing macros (see RFC 1560)\";"}, {"sha": "879d8816488b20e8a1e8fc420b4215ee59e986a2", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d64d3814c4a23fcb8440959bec77090fbbb25d7d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64d3814c4a23fcb8440959bec77090fbbb25d7d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d64d3814c4a23fcb8440959bec77090fbbb25d7d", "patch": "@@ -1174,7 +1174,7 @@ pub struct Resolver<'a> {\n \n     crate_loader: &'a mut CrateLoader,\n     macro_names: FxHashSet<Name>,\n-    builtin_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n+    global_macros: FxHashMap<Name, &'a NameBinding<'a>>,\n     lexical_macro_resolutions: Vec<(Name, &'a Cell<LegacyScope<'a>>)>,\n     macro_map: FxHashMap<DefId, Rc<SyntaxExtension>>,\n     macro_defs: FxHashMap<Mark, DefId>,\n@@ -1372,7 +1372,7 @@ impl<'a> Resolver<'a> {\n \n             crate_loader: crate_loader,\n             macro_names: FxHashSet(),\n-            builtin_macros: FxHashMap(),\n+            global_macros: FxHashMap(),\n             lexical_macro_resolutions: Vec::new(),\n             macro_map: FxHashMap(),\n             macro_exports: Vec::new(),\n@@ -2429,9 +2429,9 @@ impl<'a> Resolver<'a> {\n                 };\n             }\n         }\n-        let is_builtin = self.builtin_macros.get(&path[0].name).cloned()\n+        let is_global = self.global_macros.get(&path[0].name).cloned()\n             .map(|binding| binding.get_macro(self).kind() == MacroKind::Bang).unwrap_or(false);\n-        if primary_ns != MacroNS && (is_builtin || self.macro_names.contains(&path[0].name)) {\n+        if primary_ns != MacroNS && (is_global || self.macro_names.contains(&path[0].name)) {\n             // Return some dummy definition, it's enough for error reporting.\n             return Some(\n                 PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))"}, {"sha": "3d6c6896549a4bb8f5996bc7615526b73218f41e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d64d3814c4a23fcb8440959bec77090fbbb25d7d/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d64d3814c4a23fcb8440959bec77090fbbb25d7d/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=d64d3814c4a23fcb8440959bec77090fbbb25d7d", "patch": "@@ -84,21 +84,21 @@ pub struct LegacyBinding<'a> {\n #[derive(Copy, Clone)]\n pub enum MacroBinding<'a> {\n     Legacy(&'a LegacyBinding<'a>),\n-    Builtin(&'a NameBinding<'a>),\n+    Global(&'a NameBinding<'a>),\n     Modern(&'a NameBinding<'a>),\n }\n \n impl<'a> MacroBinding<'a> {\n     pub fn span(self) -> Span {\n         match self {\n             MacroBinding::Legacy(binding) => binding.span,\n-            MacroBinding::Builtin(binding) | MacroBinding::Modern(binding) => binding.span,\n+            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding.span,\n         }\n     }\n \n     pub fn binding(self) -> &'a NameBinding<'a> {\n         match self {\n-            MacroBinding::Builtin(binding) | MacroBinding::Modern(binding) => binding,\n+            MacroBinding::Global(binding) | MacroBinding::Modern(binding) => binding,\n             MacroBinding::Legacy(_) => panic!(\"unexpected MacroBinding::Legacy\"),\n         }\n     }\n@@ -189,7 +189,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             vis: ty::Visibility::Invisible,\n             expansion: Mark::root(),\n         });\n-        self.builtin_macros.insert(ident.name, binding);\n+        self.global_macros.insert(ident.name, binding);\n     }\n \n     fn resolve_imports(&mut self) {\n@@ -207,7 +207,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 attr::mark_known(&attrs[i]);\n             }\n \n-            match self.builtin_macros.get(&name).cloned() {\n+            match self.global_macros.get(&name).cloned() {\n                 Some(binding) => match *binding.get_macro(self) {\n                     MultiModifier(..) | MultiDecorator(..) | SyntaxExtension::AttrProcMacro(..) => {\n                         return Some(attrs.remove(i))\n@@ -239,7 +239,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n                     }\n                     let trait_name = traits[j].segments[0].identifier.name;\n                     let legacy_name = Symbol::intern(&format!(\"derive_{}\", trait_name));\n-                    if !self.builtin_macros.contains_key(&legacy_name) {\n+                    if !self.global_macros.contains_key(&legacy_name) {\n                         continue\n                     }\n                     let span = traits.remove(j).span;\n@@ -429,13 +429,13 @@ impl<'a> Resolver<'a> {\n         loop {\n             let result = if let Some(module) = module {\n                 // Since expanded macros may not shadow the lexical scope and\n-                // globs may not shadow builtin macros (both enforced below),\n+                // globs may not shadow global macros (both enforced below),\n                 // we resolve with restricted shadowing (indicated by the penultimate argument).\n                 self.resolve_ident_in_module(module, ident, ns, true, record_used)\n                     .map(MacroBinding::Modern)\n             } else {\n-                self.builtin_macros.get(&ident.name).cloned().ok_or(determinacy)\n-                    .map(MacroBinding::Builtin)\n+                self.global_macros.get(&ident.name).cloned().ok_or(determinacy)\n+                    .map(MacroBinding::Global)\n             };\n \n             match result.map(MacroBinding::binding) {\n@@ -520,11 +520,11 @@ impl<'a> Resolver<'a> {\n \n         let binding = if let Some(binding) = binding {\n             MacroBinding::Legacy(binding)\n-        } else if let Some(binding) = self.builtin_macros.get(&name).cloned() {\n+        } else if let Some(binding) = self.global_macros.get(&name).cloned() {\n             if !self.use_extern_macros {\n                 self.record_use(Ident::with_empty_ctxt(name), MacroNS, binding, DUMMY_SP);\n             }\n-            MacroBinding::Builtin(binding)\n+            MacroBinding::Global(binding)\n         } else {\n             return None;\n         };\n@@ -564,7 +564,7 @@ impl<'a> Resolver<'a> {\n                         .span_note(binding.span, &msg2)\n                         .emit();\n                 },\n-                (Some(MacroBinding::Builtin(binding)), Ok(MacroBinding::Builtin(_))) => {\n+                (Some(MacroBinding::Global(binding)), Ok(MacroBinding::Global(_))) => {\n                     self.record_use(ident, MacroNS, binding, span);\n                     self.err_if_macro_use_proc_macro(ident.name, span, binding);\n                 },\n@@ -593,11 +593,11 @@ impl<'a> Resolver<'a> {\n             find_best_match_for_name(self.macro_names.iter(), name, None)\n         } else {\n             None\n-        // Then check builtin macros.\n+        // Then check global macros.\n         }.or_else(|| {\n             // FIXME: get_macro needs an &mut Resolver, can we do it without cloning?\n-            let builtin_macros = self.builtin_macros.clone();\n-            let names = builtin_macros.iter().filter_map(|(name, binding)| {\n+            let global_macros = self.global_macros.clone();\n+            let names = global_macros.iter().filter_map(|(name, binding)| {\n                 if binding.get_macro(self).kind() == kind {\n                     Some(name)\n                 } else {"}]}