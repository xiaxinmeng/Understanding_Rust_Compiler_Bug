{"sha": "cffaf0e7a82e7b95bf76f37ad074451409a995e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZmFmMGU3YTgyZTdiOTViZjc2ZjM3YWQwNzQ0NTE0MDlhOTk1ZTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-23T01:00:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-23T01:00:48Z"}, "message": "Auto merge of #26435 - gsingh93:master, r=nikomatsakis\n\nWhen a method exists in an impl but can not be used due to missing trait bounds for the type parameters, we should inform the user which trait bounds are missing.\r\n\r\nFor example, this code\r\n```\r\n// Note this is missing a Debug impl\r\nstruct Foo;\r\n\r\nfn main() {\r\n    let a: Result<(), Foo> = Ok(());\r\n    a.unwrap()\r\n}\r\n```\r\nNow gives the following error:\r\n```\r\n/home/gulshan/tmp/tmp.rs:6:7: 6:15 error: no method named `unwrap` found for type `core::result::Result<(), Foo>` in the current scope\r\n/home/gulshan/tmp/tmp.rs:6     a.unwrap()\r\n                                 ^~~~~~~~\r\n/home/gulshan/tmp/tmp.rs:6:7: 6:15 note: The method `unwrap` exists but the following trait bounds were not satisfied: `Foo : core::fmt::Debug`\r\nerror: aborting due to previous error\r\n```\r\n\r\nFixes https://github.com/rust-lang/rust/issues/20941.", "tree": {"sha": "66199c0ae047156541f38f1bd1fe5614cce15004", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66199c0ae047156541f38f1bd1fe5614cce15004"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cffaf0e7a82e7b95bf76f37ad074451409a995e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cffaf0e7a82e7b95bf76f37ad074451409a995e9", "html_url": "https://github.com/rust-lang/rust/commit/cffaf0e7a82e7b95bf76f37ad074451409a995e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cffaf0e7a82e7b95bf76f37ad074451409a995e9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8dbd71fc8dcf106eaedca6e52f55b0dcc82b7c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8dbd71fc8dcf106eaedca6e52f55b0dcc82b7c1", "html_url": "https://github.com/rust-lang/rust/commit/a8dbd71fc8dcf106eaedca6e52f55b0dcc82b7c1"}, {"sha": "a006a82724d1efec712f0f0d337aeeaf3f14258c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a006a82724d1efec712f0f0d337aeeaf3f14258c", "html_url": "https://github.com/rust-lang/rust/commit/a006a82724d1efec712f0f0d337aeeaf3f14258c"}], "stats": {"total": 152, "additions": 120, "deletions": 32}, "files": [{"sha": "e5a57fa9c138e17e17ec02f435c28e99579fe4dd", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=cffaf0e7a82e7b95bf76f37ad074451409a995e9", "patch": "@@ -16,7 +16,7 @@ use middle::def;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n-use middle::ty::{self, AsPredicate, ToPolyTraitRef};\n+use middle::ty::{self, AsPredicate, ToPolyTraitRef, TraitRef};\n use middle::infer;\n \n use syntax::ast::DefId;\n@@ -32,11 +32,9 @@ mod confirm;\n mod probe;\n mod suggest;\n \n-pub enum MethodError {\n-    // Did not find an applicable method, but we did find various\n-    // static methods that may apply, as well as a list of\n-    // not-in-scope traits which may work.\n-    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>, probe::Mode),\n+pub enum MethodError<'tcx> {\n+    // Did not find an applicable method, but we did find various near-misses that may work.\n+    NoMatch(NoMatchData<'tcx>),\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n@@ -45,9 +43,32 @@ pub enum MethodError {\n     ClosureAmbiguity(/* DefId of fn trait */ ast::DefId),\n }\n \n+// Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n+// could lead to matches if satisfied, and a list of not-in-scope traits which may work.\n+pub struct NoMatchData<'tcx> {\n+    pub static_candidates: Vec<CandidateSource>,\n+    pub unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n+    pub out_of_scope_traits: Vec<ast::DefId>,\n+    pub mode: probe::Mode\n+}\n+\n+impl<'tcx> NoMatchData<'tcx> {\n+    pub fn new(static_candidates: Vec<CandidateSource>,\n+               unsatisfied_predicates: Vec<TraitRef<'tcx>>,\n+               out_of_scope_traits: Vec<ast::DefId>,\n+               mode: probe::Mode) -> Self {\n+        NoMatchData {\n+            static_candidates: static_candidates,\n+            unsatisfied_predicates: unsatisfied_predicates,\n+            out_of_scope_traits: out_of_scope_traits,\n+            mode: mode\n+        }\n+    }\n+}\n+\n // A pared down enum describing just the places from which a method\n // candidate can arise. Used for error reporting only.\n-#[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n     ImplSource(ast::DefId),\n     TraitSource(/* trait id */ ast::DefId),\n@@ -93,7 +114,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         supplied_method_types: Vec<ty::Ty<'tcx>>,\n                         call_expr: &'tcx ast::Expr,\n                         self_expr: &'tcx ast::Expr)\n-                        -> Result<ty::MethodCallee<'tcx>, MethodError>\n+                        -> Result<ty::MethodCallee<'tcx>, MethodError<'tcx>>\n {\n     debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n            method_name,\n@@ -305,7 +326,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               method_name: ast::Name,\n                               self_ty: ty::Ty<'tcx>,\n                               expr_id: ast::NodeId)\n-                              -> Result<(def::Def, LastPrivate), MethodError>\n+                              -> Result<(def::Def, LastPrivate), MethodError<'tcx>>\n {\n     let mode = probe::Mode::Path;\n     let pick = try!(probe::probe(fcx, span, mode, method_name, self_ty, expr_id));"}, {"sha": "46bffa8ccabdaefbaf905208c036e2ddb6e350a4", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 50, "deletions": 19, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=cffaf0e7a82e7b95bf76f37ad074451409a995e9", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use super::MethodError;\n+use super::NoMatchData;\n use super::ItemIndex;\n-use super::{CandidateSource,ImplSource,TraitSource};\n+use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n use check;\n@@ -19,7 +20,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty::{self, RegionEscape, Ty, ToPolyTraitRef};\n+use middle::ty::{self, RegionEscape, Ty, ToPolyTraitRef, TraitRef};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -42,7 +43,14 @@ struct ProbeContext<'a, 'tcx:'a> {\n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n     impl_dups: HashSet<ast::DefId>,\n+\n+    /// Collects near misses when the candidate functions are missing a `self` keyword and is only\n+    /// used for error reporting\n     static_candidates: Vec<CandidateSource>,\n+\n+    /// Collects near misses when trait bounds for type parameters are unsatisfied and is only used\n+    /// for error reporting\n+    unsatisfied_predicates: Vec<TraitRef<'tcx>>\n }\n \n #[derive(Debug)]\n@@ -104,7 +112,7 @@ pub enum PickKind<'tcx> {\n     WhereClausePick(/* Trait */ ty::PolyTraitRef<'tcx>, ItemIndex),\n }\n \n-pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n+pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError<'tcx>>;\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum Mode {\n@@ -141,7 +149,8 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let steps = if mode == Mode::MethodCall {\n         match create_steps(fcx, span, self_ty) {\n             Some(steps) => steps,\n-            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new(), mode)),\n+            None =>return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(), Vec::new(),\n+                                                                    Vec::new(), mode))),\n         }\n     } else {\n         vec![CandidateStep {\n@@ -242,6 +251,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             steps: Rc::new(steps),\n             opt_simplified_steps: opt_simplified_steps,\n             static_candidates: Vec::new(),\n+            unsatisfied_predicates: Vec::new(),\n         }\n     }\n \n@@ -563,7 +573,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_traits_in_scope(&mut self,\n                                                          expr_id: ast::NodeId)\n-                                                         -> Result<(),MethodError>\n+                                                         -> Result<(), MethodError<'tcx>>\n     {\n         let mut duplicates = HashSet::new();\n         let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n@@ -577,7 +587,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         Ok(())\n     }\n \n-    fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(),MethodError> {\n+    fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n         let mut duplicates = HashSet::new();\n         for trait_info in suggest::all_traits(self.fcx.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n@@ -589,7 +599,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_extension_candidates_for_trait(&mut self,\n                                                trait_def_id: ast::DefId)\n-                                               -> Result<(),MethodError>\n+                                               -> Result<(), MethodError<'tcx>>\n     {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n@@ -709,7 +719,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                    trait_def_id: ast::DefId,\n                                    item: ty::ImplOrTraitItem<'tcx>,\n                                    item_index: usize)\n-                                   -> Result<(),MethodError>\n+                                   -> Result<(), MethodError<'tcx>>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n         let tcx = self.tcx();\n@@ -868,6 +878,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         let static_candidates = mem::replace(&mut self.static_candidates, vec![]);\n+        let unsatisfied_predicates = mem::replace(&mut self.unsatisfied_predicates, vec![]);\n \n         // things failed, so lets look at all traits, for diagnostic purposes now:\n         self.reset();\n@@ -892,7 +903,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     }\n                 }\n             }).collect(),\n-            Some(Err(MethodError::NoMatch(_, others, _))) => {\n+            Some(Err(MethodError::NoMatch(NoMatchData { out_of_scope_traits: others, .. }))) => {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n@@ -903,7 +914,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             None => vec![],\n         };\n \n-        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits, self.mode))\n+        Err(MethodError::NoMatch(NoMatchData::new(static_candidates, unsatisfied_predicates,\n+                                                  out_of_scope_traits, self.mode)))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {\n@@ -991,25 +1003,35 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n+        let mut possibly_unsatisfied_predicates = Vec::new();\n+\n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, &self.inherent_candidates) {\n+        match self.consider_candidates(self_ty, &self.inherent_candidates,\n+                                       &mut possibly_unsatisfied_predicates) {\n             None => {}\n             Some(pick) => {\n                 return Some(pick);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(self_ty, &self.extension_candidates)\n+        let res = self.consider_candidates(self_ty, &self.extension_candidates,\n+                                           &mut possibly_unsatisfied_predicates);\n+        if let None = res {\n+            self.unsatisfied_predicates.extend(possibly_unsatisfied_predicates);\n+        }\n+        res\n     }\n \n     fn consider_candidates(&self,\n                            self_ty: Ty<'tcx>,\n-                           probes: &[Candidate<'tcx>])\n+                           probes: &[Candidate<'tcx>],\n+                           possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>)\n                            -> Option<PickResult<'tcx>> {\n         let mut applicable_candidates: Vec<_> =\n             probes.iter()\n-                  .filter(|&probe| self.consider_probe(self_ty, probe))\n+                  .filter(|&probe| self.consider_probe(self_ty,\n+                                                       probe,possibly_unsatisfied_predicates))\n                   .collect();\n \n         debug!(\"applicable_candidates: {:?}\", applicable_candidates);\n@@ -1032,7 +1054,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         })\n     }\n \n-    fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>) -> bool {\n+    fn consider_probe(&self, self_ty: Ty<'tcx>, probe: &Candidate<'tcx>,\n+                      possibly_unsatisfied_predicates: &mut Vec<TraitRef<'tcx>>) -> bool {\n         debug!(\"consider_probe: self_ty={:?} probe={:?}\",\n                self_ty,\n                probe);\n@@ -1071,10 +1094,18 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     debug!(\"impl_obligations={:?}\", obligations);\n \n                     // Evaluate those obligations to see if they might possibly hold.\n-                    obligations.iter()\n-                        .chain(norm_obligations.iter()).chain(ref_obligations.iter())\n-                        .all(|o| selcx.evaluate_obligation(o))\n-\n+                    let mut all_true = true;\n+                    for o in obligations.iter()\n+                        .chain(norm_obligations.iter())\n+                        .chain(ref_obligations.iter()) {\n+                        if !selcx.evaluate_obligation(o) {\n+                            all_true = false;\n+                            if let &ty::Predicate::Trait(ref pred) = &o.predicate {\n+                                possibly_unsatisfied_predicates.push(pred.0.trait_ref);\n+                            }\n+                        }\n+                    }\n+                    all_true\n                 }\n \n                 ProjectionCandidate(..) |"}, {"sha": "2325b9852c73dc4c62b1835e64e2765fa4ba8c4f", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cffaf0e7a82e7b95bf76f37ad074451409a995e9", "patch": "@@ -29,23 +29,26 @@ use syntax::print::pprust;\n use std::cell;\n use std::cmp::Ordering;\n \n-use super::{MethodError, CandidateSource, impl_item, trait_item};\n+use super::{MethodError, NoMatchData, CandidateSource, impl_item, trait_item};\n use super::probe::Mode;\n \n pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n                               item_name: ast::Name,\n                               rcvr_expr: Option<&ast::Expr>,\n-                              error: MethodError)\n+                              error: MethodError<'tcx>)\n {\n     // avoid suggestions when we don't know what's going on.\n     if ty::type_is_error(rcvr_ty) {\n         return\n     }\n \n     match error {\n-        MethodError::NoMatch(static_sources, out_of_scope_traits, mode) => {\n+        MethodError::NoMatch(NoMatchData { static_candidates: static_sources,\n+                                           unsatisfied_predicates,\n+                                           out_of_scope_traits,\n+                                           mode }) => {\n             let cx = fcx.tcx();\n \n             fcx.type_error_message(\n@@ -118,13 +121,28 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             if !static_sources.is_empty() {\n-                fcx.tcx().sess.fileline_note(\n+                cx.sess.fileline_note(\n                     span,\n                     \"found defined static methods, maybe a `self` is missing?\");\n \n                 report_candidates(fcx, span, item_name, static_sources);\n             }\n \n+            if !unsatisfied_predicates.is_empty() {\n+                let bound_list = unsatisfied_predicates.iter()\n+                    .map(|p| format!(\"`{} : {}`\",\n+                                     p.self_ty(),\n+                                     p))\n+                    .collect::<Vec<_>>()\n+                    .connect(\", \");\n+                cx.sess.fileline_note(\n+                    span,\n+                    &format!(\"the method `{}` exists but the \\\n+                             following trait bounds were not satisfied: {}\",\n+                             item_name,\n+                             bound_list));\n+            }\n+\n             suggest_traits_to_import(fcx, span, rcvr_ty, item_name,\n                                      rcvr_expr, out_of_scope_traits)\n         }"}, {"sha": "375d5076ea2f8e9c6bc432f629a26a5ae87133ff", "filename": "src/test/compile-fail/method-help-unsatisfied-bound.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Ftest%2Fcompile-fail%2Fmethod-help-unsatisfied-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffaf0e7a82e7b95bf76f37ad074451409a995e9/src%2Ftest%2Fcompile-fail%2Fmethod-help-unsatisfied-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-help-unsatisfied-bound.rs?ref=cffaf0e7a82e7b95bf76f37ad074451409a995e9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+fn main() {\n+    let a: Result<(), Foo> = Ok(());\n+    a.unwrap();\n+    //~^ ERROR no method named `unwrap` found for type `core::result::Result<(), Foo>`\n+    //~| NOTE the following trait bounds were not satisfied: `Foo : core::fmt::Debug`\n+}"}]}