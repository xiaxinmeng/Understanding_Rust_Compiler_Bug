{"sha": "4d11db650137a8b515fd6cbef60bccd9bbe37869", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMTFkYjY1MDEzN2E4YjUxNWZkNmNiZWY2MGJjY2Q5YmJlMzc4Njk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-29T18:55:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-29T18:55:12Z"}, "message": "Auto merge of #29129 - cuviper:impl-from-for-floats, r=alexcrichton\n\nThis is a spiritual successor to #28921, completing the \"upcast\" idea from rust-num/num#97.", "tree": {"sha": "19604ad7399bd745877503264f04fcf6383459d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19604ad7399bd745877503264f04fcf6383459d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d11db650137a8b515fd6cbef60bccd9bbe37869", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d11db650137a8b515fd6cbef60bccd9bbe37869", "html_url": "https://github.com/rust-lang/rust/commit/4d11db650137a8b515fd6cbef60bccd9bbe37869", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d11db650137a8b515fd6cbef60bccd9bbe37869/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a18e0b27077c763df4f9e06b42192717025f0bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/a18e0b27077c763df4f9e06b42192717025f0bfc", "html_url": "https://github.com/rust-lang/rust/commit/a18e0b27077c763df4f9e06b42192717025f0bfc"}, {"sha": "1a19f9877ad1d582ac80f8e765eff879e00222ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a19f9877ad1d582ac80f8e765eff879e00222ea", "html_url": "https://github.com/rust-lang/rust/commit/1a19f9877ad1d582ac80f8e765eff879e00222ea"}], "stats": {"total": 84, "additions": 81, "deletions": 3}, "files": [{"sha": "801315d86db454ffd27279d50a8aebf15e44b796", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4d11db650137a8b515fd6cbef60bccd9bbe37869/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d11db650137a8b515fd6cbef60bccd9bbe37869/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4d11db650137a8b515fd6cbef60bccd9bbe37869", "patch": "@@ -1473,14 +1473,14 @@ impl fmt::Display for ParseIntError {\n \n pub use num::dec2flt::ParseFloatError;\n \n-// Conversion traits for primitive integer types\n+// Conversion traits for primitive integer and float types\n // Conversions T -> T are covered by a blanket impl and therefore excluded\n // Some conversions from and to usize/isize are not implemented due to portability concerns\n macro_rules! impl_from {\n     ($Small: ty, $Large: ty) => {\n-        #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")]\n+        #[stable(feature = \"lossless_prim_conv\", since = \"1.5.0\")]\n         impl From<$Small> for $Large {\n-            #[stable(feature = \"lossless_int_conv\", since = \"1.5.0\")]\n+            #[stable(feature = \"lossless_prim_conv\", since = \"1.5.0\")]\n             #[inline]\n             fn from(small: $Small) -> $Large {\n                 small as $Large\n@@ -1514,3 +1514,24 @@ impl_from! { u8, i64 }\n impl_from! { u16, i32 }\n impl_from! { u16, i64 }\n impl_from! { u32, i64 }\n+\n+// Note: integers can only be represented with full precision in a float if\n+// they fit in the significand, which is 24 bits in f32 and 53 bits in f64.\n+// Lossy float conversions are not implemented at this time.\n+\n+// Signed -> Float\n+impl_from! { i8, f32 }\n+impl_from! { i8, f64 }\n+impl_from! { i16, f32 }\n+impl_from! { i16, f64 }\n+impl_from! { i32, f64 }\n+\n+// Unsigned -> Float\n+impl_from! { u8, f32 }\n+impl_from! { u8, f64 }\n+impl_from! { u16, f32 }\n+impl_from! { u16, f64 }\n+impl_from! { u32, f64 }\n+\n+// Float -> Float\n+impl_from! { f32, f64 }"}, {"sha": "738761f3911b67da48a9eb0268728bbb30f67242", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4d11db650137a8b515fd6cbef60bccd9bbe37869/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d11db650137a8b515fd6cbef60bccd9bbe37869/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=4d11db650137a8b515fd6cbef60bccd9bbe37869", "patch": "@@ -177,4 +177,61 @@ mod tests {\n     test_impl_from! { test_u16i32, u16, i32 }\n     test_impl_from! { test_u16i64, u16, i64 }\n     test_impl_from! { test_u32i64, u32, i64 }\n+\n+    // Signed -> Float\n+    test_impl_from! { test_i8f32, i8, f32 }\n+    test_impl_from! { test_i8f64, i8, f64 }\n+    test_impl_from! { test_i16f32, i16, f32 }\n+    test_impl_from! { test_i16f64, i16, f64 }\n+    test_impl_from! { test_i32f64, i32, f64 }\n+\n+    // Unsigned -> Float\n+    test_impl_from! { test_u8f32, u8, f32 }\n+    test_impl_from! { test_u8f64, u8, f64 }\n+    test_impl_from! { test_u16f32, u16, f32 }\n+    test_impl_from! { test_u16f64, u16, f64 }\n+    test_impl_from! { test_u32f64, u32, f64 }\n+\n+    // Float -> Float\n+    #[test]\n+    fn test_f32f64() {\n+        use core::f32;\n+\n+        let max: f64 = f32::MAX.into();\n+        assert_eq!(max as f32, f32::MAX);\n+        assert!(max.is_normal());\n+\n+        let min: f64 = f32::MIN.into();\n+        assert_eq!(min as f32, f32::MIN);\n+        assert!(min.is_normal());\n+\n+        let min_positive: f64 = f32::MIN_POSITIVE.into();\n+        assert_eq!(min_positive as f32, f32::MIN_POSITIVE);\n+        assert!(min_positive.is_normal());\n+\n+        let epsilon: f64 = f32::EPSILON.into();\n+        assert_eq!(epsilon as f32, f32::EPSILON);\n+        assert!(epsilon.is_normal());\n+\n+        let zero: f64 = (0.0f32).into();\n+        assert_eq!(zero as f32, 0.0f32);\n+        assert!(zero.is_sign_positive());\n+\n+        let neg_zero: f64 = (-0.0f32).into();\n+        assert_eq!(neg_zero as f32, -0.0f32);\n+        assert!(neg_zero.is_sign_negative());\n+\n+        let infinity: f64 = f32::INFINITY.into();\n+        assert_eq!(infinity as f32, f32::INFINITY);\n+        assert!(infinity.is_infinite());\n+        assert!(infinity.is_sign_positive());\n+\n+        let neg_infinity: f64 = f32::NEG_INFINITY.into();\n+        assert_eq!(neg_infinity as f32, f32::NEG_INFINITY);\n+        assert!(neg_infinity.is_infinite());\n+        assert!(neg_infinity.is_sign_negative());\n+\n+        let nan: f64 = f32::NAN.into();\n+        assert!(nan.is_nan());\n+    }\n }"}]}