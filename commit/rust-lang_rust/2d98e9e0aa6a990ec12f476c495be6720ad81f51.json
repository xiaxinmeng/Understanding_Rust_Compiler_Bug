{"sha": "2d98e9e0aa6a990ec12f476c495be6720ad81f51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOThlOWUwYWE2YTk5MGVjMTJmNDc2YzQ5NWJlNjcyMGFkODFmNTE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-17T20:18:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-19T13:34:28Z"}, "message": "create type ascription for any cast\n\nAlso, avoid shadowing of the `ty` variable by giving the `cast_ty` and\n`var_ty` variables different names.  We want to get the user-provided\ntype from `cast_ty.hir_id`.", "tree": {"sha": "dc405990480911084885468b27c089fbccde5103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc405990480911084885468b27c089fbccde5103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d98e9e0aa6a990ec12f476c495be6720ad81f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d98e9e0aa6a990ec12f476c495be6720ad81f51", "html_url": "https://github.com/rust-lang/rust/commit/2d98e9e0aa6a990ec12f476c495be6720ad81f51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d98e9e0aa6a990ec12f476c495be6720ad81f51/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80ad300b890c07d4c95fbf63c0f9cd3e397e545f", "url": "https://api.github.com/repos/rust-lang/rust/commits/80ad300b890c07d4c95fbf63c0f9cd3e397e545f", "html_url": "https://github.com/rust-lang/rust/commit/80ad300b890c07d4c95fbf63c0f9cd3e397e545f"}], "stats": {"total": 77, "additions": 52, "deletions": 25}, "files": [{"sha": "a3e0c11551529940a5cf9843d1a6c24a0ae54bb0", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 39, "deletions": 25, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2d98e9e0aa6a990ec12f476c495be6720ad81f51/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d98e9e0aa6a990ec12f476c495be6720ad81f51/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=2d98e9e0aa6a990ec12f476c495be6720ad81f51", "patch": "@@ -637,12 +637,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 name: Field::new(cx.tcx.field_index(expr.id, cx.tables)),\n             }\n         }\n-        hir::ExprKind::Cast(ref source, ref ty) => {\n+        hir::ExprKind::Cast(ref source, ref cast_ty) => {\n+            // Check for a user-given type annotation on this `cast`\n+            let user_ty = cx.tables.user_provided_tys().get(cast_ty.hir_id)\n+                .map(|&t| UserTypeAnnotation::Ty(t));\n+\n+            debug!(\n+                \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n+                expr,\n+                cast_ty.hir_id,\n+                user_ty,\n+            );\n+\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            if let Some(&TyCastKind::CoercionCast) = cx.tables()\n-                                                    .cast_kinds()\n-                                                    .get(source.hir_id) {\n+            let cast = if let Some(&TyCastKind::CoercionCast) =\n+                cx.tables()\n+                .cast_kinds()\n+                .get(source.hir_id)\n+            {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {\n@@ -679,32 +692,33 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 } else {\n                     None\n                 };\n-                let source = if let Some((did, offset, ty)) = var {\n+\n+                let source = if let Some((did, offset, var_ty)) = var {\n                     let mk_const = |literal| Expr {\n                         temp_lifetime,\n-                        ty,\n+                        ty: var_ty,\n                         span: expr.span,\n                         kind: ExprKind::Literal { literal, user_ty: None },\n                     }.to_ref();\n                     let offset = mk_const(ty::Const::from_bits(\n                         cx.tcx,\n                         offset as u128,\n-                        cx.param_env.and(ty),\n+                        cx.param_env.and(var_ty),\n                     ));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = Substs::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(ty::Const::unevaluated(cx.tcx(), did, substs, ty));\n+                            let lhs = mk_const(ty::Const::unevaluated(cx.tcx(), did, substs, var_ty));\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n                                 rhs: offset,\n                             };\n                             Expr {\n                                 temp_lifetime,\n-                                ty,\n+                                ty: var_ty,\n                                 span: expr.span,\n                                 kind: bin,\n                             }.to_ref()\n@@ -715,25 +729,25 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     source.to_ref()\n                 };\n \n-                let cast = ExprKind::Cast { source };\n+                ExprKind::Cast { source }\n+            };\n \n-                if let Some(user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n-                    // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n-                    //       inefficient, revisit this when performance becomes an issue.\n-                    let cast_expr = Expr {\n-                        temp_lifetime,\n-                        ty: expr_ty,\n-                        span: expr.span,\n-                        kind: cast,\n-                    };\n+            if let Some(user_ty) = user_ty {\n+                // NOTE: Creating a new Expr and wrapping a Cast inside of it may be\n+                //       inefficient, revisit this when performance becomes an issue.\n+                let cast_expr = Expr {\n+                    temp_lifetime,\n+                    ty: expr_ty,\n+                    span: expr.span,\n+                    kind: cast,\n+                };\n \n-                    ExprKind::ValueTypeAscription {\n-                        source: cast_expr.to_ref(),\n-                        user_ty: UserTypeAnnotation::Ty(*user_ty),\n-                    }\n-                } else {\n-                    cast\n+                ExprKind::ValueTypeAscription {\n+                    source: cast_expr.to_ref(),\n+                    user_ty: user_ty,\n                 }\n+            } else {\n+                cast\n             }\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {"}, {"sha": "a35035b07ba5463256bf0e95a9f4b3deddb27adc", "filename": "src/test/ui/nll/user-annotations/cast_static_lifetime.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2d98e9e0aa6a990ec12f476c495be6720ad81f51/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2d98e9e0aa6a990ec12f476c495be6720ad81f51/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fcast_static_lifetime.stderr?ref=2d98e9e0aa6a990ec12f476c495be6720ad81f51", "patch": "@@ -0,0 +1,13 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/cast_static_lifetime.rs:16:19\n+   |\n+LL |     let y: &u32 = (&x) as &'static u32;\n+   |                   ^^^^ borrowed value does not live long enough\n+LL | }\n+   | - `x` dropped here while still borrowed\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}