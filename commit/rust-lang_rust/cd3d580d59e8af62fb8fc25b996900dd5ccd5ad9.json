{"sha": "cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkM2Q1ODBkNTllOGFmNjJmYjhmYzI1Yjk5NjkwMGRkNWNjZDVhZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T01:24:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T01:24:13Z"}, "message": "Auto merge of #57869 - Centril:rollup, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #57179 (Update std/lib.rs docs to reflect Rust 2018 usage)\n - #57730 (Merge visitors in AST validation)\n - #57779 (Recover from parse errors in literal struct fields and incorrect float literals)\n - #57793 (Explain type mismatch cause pointing to return type when it is `impl Trait`)\n - #57795 (Use structured suggestion in stead of notes)\n - #57817 (Add error for trailing angle brackets.)\n - #57834 (Stabilize Any::get_type_id and rename to type_id)\n - #57836 (Fix some cross crate existential type ICEs)\n - #57840 (Fix issue 57762)\n - #57844 (use port 80 for retrieving GPG key)\n - #57858 (Ignore line ending on older git versions)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "bdd151640dbbe35520823f2a649f56b24d8336e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd151640dbbe35520823f2a649f56b24d8336e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "html_url": "https://github.com/rust-lang/rust/commit/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19f8958f827e379be9b0ffc93fca580ec8ffac77", "url": "https://api.github.com/repos/rust-lang/rust/commits/19f8958f827e379be9b0ffc93fca580ec8ffac77", "html_url": "https://github.com/rust-lang/rust/commit/19f8958f827e379be9b0ffc93fca580ec8ffac77"}, {"sha": "e90cdfd50768feb612dcea84ea25a725c72df39a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e90cdfd50768feb612dcea84ea25a725c72df39a", "html_url": "https://github.com/rust-lang/rust/commit/e90cdfd50768feb612dcea84ea25a725c72df39a"}], "stats": {"total": 1150, "additions": 840, "deletions": 310}, "files": [{"sha": "f0b1c67bd0fdd22c92f1498e14e4174772892f5d", "filename": ".gitattributes", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -9,3 +9,7 @@ src/etc/installer/gfx/* binary\n *.woff binary\n src/vendor/** -text\n Cargo.lock -merge linguist-generated=false\n+\n+# Older git versions try to fix line endings on images, this prevents it.\n+*.png binary\n+*.ico binary"}, {"sha": "c39be14941c90f0f6952f738db0e4786ca0e4507", "filename": "src/ci/docker/dist-various-1/install-x86_64-redox.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -6,7 +6,7 @@ set -ex\n apt-get update\n apt-get install -y --no-install-recommends software-properties-common apt-transport-https\n \n-apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys AA12E97F0881517F\n+apt-key adv --batch --yes --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys AA12E97F0881517F\n add-apt-repository -y 'deb https://static.redox-os.org/toolchain/apt /'\n \n apt-get update"}, {"sha": "2afd9e0c07237bfc0739d8ba1ff9ea497475757c", "filename": "src/libcore/any.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -81,28 +81,24 @@ pub trait Any: 'static {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(get_type_id)]\n-    ///\n     /// use std::any::{Any, TypeId};\n     ///\n     /// fn is_string(s: &dyn Any) -> bool {\n-    ///     TypeId::of::<String>() == s.get_type_id()\n+    ///     TypeId::of::<String>() == s.type_id()\n     /// }\n     ///\n     /// fn main() {\n     ///     assert_eq!(is_string(&0), false);\n     ///     assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// }\n     /// ```\n-    #[unstable(feature = \"get_type_id\",\n-               reason = \"this method will likely be replaced by an associated static\",\n-               issue = \"27745\")]\n-    fn get_type_id(&self) -> TypeId;\n+    #[stable(feature = \"get_type_id\", since = \"1.34.0\")]\n+    fn type_id(&self) -> TypeId;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: 'static + ?Sized > Any for T {\n-    fn get_type_id(&self) -> TypeId { TypeId::of::<T>() }\n+    fn type_id(&self) -> TypeId { TypeId::of::<T>() }\n }\n \n ///////////////////////////////////////////////////////////////////////////////\n@@ -161,10 +157,10 @@ impl dyn Any {\n         let t = TypeId::of::<T>();\n \n         // Get TypeId of the type in the trait object\n-        let boxed = self.get_type_id();\n+        let concrete = self.type_id();\n \n         // Compare both TypeIds on equality\n-        t == boxed\n+        t == concrete\n     }\n \n     /// Returns some reference to the boxed value if it is of type `T`, or"}, {"sha": "9f63038c3623bfc06fe7572632e9516b54df02fa", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1164,7 +1164,10 @@ fn use_enum_fallback(cx: &CodegenCx) -> bool {\n     // On MSVC we have to use the fallback mode, because LLVM doesn't\n     // lower variant parts to PDB.\n     return cx.sess().target.target.options.is_like_msvc\n-        || llvm_util::get_major_version() < 7;\n+        // LLVM version 7 did not release with an important bug fix;\n+        // but the required patch is in the LLVM 8.  Rust LLVM reports\n+        // 8 as well.\n+        || llvm_util::get_major_version() < 8;\n }\n \n // Describes the members of an enum value: An enum is described as a union of"}, {"sha": "ad6296e1a3bd863d96b097e8e1c23f3f93e382f5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -893,6 +893,9 @@ impl<'a, 'tcx> CrateMetadata {\n             EntryKind::AssociatedType(container) => {\n                 (ty::AssociatedKind::Type, container, false)\n             }\n+            EntryKind::AssociatedExistential(container) => {\n+                (ty::AssociatedKind::Existential, container, false)\n+            }\n             _ => bug!(\"cannot get associated-item of `{:?}`\", def_key)\n         };\n "}, {"sha": "d1a3d7c1f81e038343f2249c821764b10a7abe59", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 106, "deletions": 144, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -6,6 +6,7 @@\n // This pass is supposed to perform only simple checks not requiring name resolution\n // or type checking or some other kind of complex analysis.\n \n+use std::mem;\n use rustc::lint;\n use rustc::session::Session;\n use syntax::ast::*;\n@@ -20,9 +21,73 @@ use errors::Applicability;\n \n struct AstValidator<'a> {\n     session: &'a Session,\n+\n+    // Used to ban nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n+    // Nested `impl Trait` _is_ allowed in associated type position,\n+    // e.g `impl Iterator<Item=impl Debug>`\n+    outer_impl_trait: Option<Span>,\n+\n+    // Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n+    // or `Foo::Bar<impl Trait>`\n+    is_impl_trait_banned: bool,\n }\n \n impl<'a> AstValidator<'a> {\n+    fn with_banned_impl_trait(&mut self, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.is_impl_trait_banned, true);\n+        f(self);\n+        self.is_impl_trait_banned = old;\n+    }\n+\n+    fn with_impl_trait(&mut self, outer_impl_trait: Option<Span>, f: impl FnOnce(&mut Self)) {\n+        let old = mem::replace(&mut self.outer_impl_trait, outer_impl_trait);\n+        f(self);\n+        self.outer_impl_trait = old;\n+    }\n+\n+    // Mirrors visit::walk_ty, but tracks relevant state\n+    fn walk_ty(&mut self, t: &'a Ty) {\n+        match t.node {\n+            TyKind::ImplTrait(..) => {\n+                self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n+            }\n+            TyKind::Path(ref qself, ref path) => {\n+                // We allow these:\n+                //  - `Option<impl Trait>`\n+                //  - `option::Option<impl Trait>`\n+                //  - `option::Option<T>::Foo<impl Trait>\n+                //\n+                // But not these:\n+                //  - `<impl Trait>::Foo`\n+                //  - `option::Option<impl Trait>::Foo`.\n+                //\n+                // To implement this, we disallow `impl Trait` from `qself`\n+                // (for cases like `<impl Trait>::Foo>`)\n+                // but we allow `impl Trait` in `GenericArgs`\n+                // iff there are no more PathSegments.\n+                if let Some(ref qself) = *qself {\n+                    // `impl Trait` in `qself` is always illegal\n+                    self.with_banned_impl_trait(|this| this.visit_ty(&qself.ty));\n+                }\n+\n+                // Note that there should be a call to visit_path here,\n+                // so if any logic is added to process `Path`s a call to it should be\n+                // added both in visit_path and here. This code mirrors visit::walk_path.\n+                for (i, segment) in path.segments.iter().enumerate() {\n+                    // Allow `impl Trait` iff we're on the final path segment\n+                    if i == path.segments.len() - 1 {\n+                        self.visit_path_segment(path.span, segment);\n+                    } else {\n+                        self.with_banned_impl_trait(|this| {\n+                            this.visit_path_segment(path.span, segment)\n+                        });\n+                    }\n+                }\n+            }\n+            _ => visit::walk_ty(self, t),\n+        }\n+    }\n+\n     fn err_handler(&self) -> &errors::Handler {\n         &self.session.diagnostic()\n     }\n@@ -267,6 +332,19 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"trait object types\", false);\n             }\n             TyKind::ImplTrait(_, ref bounds) => {\n+                if self.is_impl_trait_banned {\n+                    struct_span_err!(self.session, ty.span, E0667,\n+                        \"`impl Trait` is not allowed in path parameters\").emit();\n+                }\n+\n+                if let Some(outer_impl_trait) = self.outer_impl_trait {\n+                    struct_span_err!(self.session, ty.span, E0666,\n+                                    \"nested `impl Trait` is not allowed\")\n+                        .span_label(outer_impl_trait, \"outer `impl Trait`\")\n+                        .span_label(ty.span, \"nested `impl Trait` here\")\n+                        .emit();\n+\n+                }\n                 if !bounds.iter()\n                           .any(|b| if let GenericBound::Trait(..) = *b { true } else { false }) {\n                     self.err_handler().span_err(ty.span, \"at least one trait must be specified\");\n@@ -275,7 +353,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             _ => {}\n         }\n \n-        visit::walk_ty(self, ty)\n+        self.walk_ty(ty)\n     }\n \n     fn visit_label(&mut self, label: &'a Label) {\n@@ -414,6 +492,28 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_foreign_item(self, fi)\n     }\n \n+    // Mirrors visit::walk_generic_args, but tracks relevant state\n+    fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n+        match *generic_args {\n+            GenericArgs::AngleBracketed(ref data) => {\n+                walk_list!(self, visit_generic_arg, &data.args);\n+                // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n+                // are allowed to contain nested `impl Trait`.\n+                self.with_impl_trait(None, |this| {\n+                    walk_list!(this, visit_assoc_type_binding, &data.bindings);\n+                });\n+            }\n+            GenericArgs::Parenthesized(ref data) => {\n+                walk_list!(self, visit_ty, &data.inputs);\n+                if let Some(ref type_) = data.output {\n+                    // `-> Foo` syntax is essentially an associated type binding,\n+                    // so it is also allowed to contain nested `impl Trait`.\n+                    self.with_impl_trait(None, |this| visit::walk_ty(this, type_));\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_generics(&mut self, generics: &'a Generics) {\n         let mut seen_non_lifetime_param = false;\n         let mut seen_default = None;\n@@ -490,148 +590,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     }\n }\n \n-// Bans nested `impl Trait`, e.g., `impl Into<impl Debug>`.\n-// Nested `impl Trait` _is_ allowed in associated type position,\n-// e.g `impl Iterator<Item=impl Debug>`\n-struct NestedImplTraitVisitor<'a> {\n-    session: &'a Session,\n-    outer_impl_trait: Option<Span>,\n-}\n-\n-impl<'a> NestedImplTraitVisitor<'a> {\n-    fn with_impl_trait<F>(&mut self, outer_impl_trait: Option<Span>, f: F)\n-        where F: FnOnce(&mut NestedImplTraitVisitor<'a>)\n-    {\n-        let old_outer_impl_trait = self.outer_impl_trait;\n-        self.outer_impl_trait = outer_impl_trait;\n-        f(self);\n-        self.outer_impl_trait = old_outer_impl_trait;\n-    }\n-}\n-\n-\n-impl<'a> Visitor<'a> for NestedImplTraitVisitor<'a> {\n-    fn visit_ty(&mut self, t: &'a Ty) {\n-        if let TyKind::ImplTrait(..) = t.node {\n-            if let Some(outer_impl_trait) = self.outer_impl_trait {\n-                struct_span_err!(self.session, t.span, E0666,\n-                                 \"nested `impl Trait` is not allowed\")\n-                    .span_label(outer_impl_trait, \"outer `impl Trait`\")\n-                    .span_label(t.span, \"nested `impl Trait` here\")\n-                    .emit();\n-\n-            }\n-            self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t));\n-        } else {\n-            visit::walk_ty(self, t);\n-        }\n-    }\n-    fn visit_generic_args(&mut self, _: Span, generic_args: &'a GenericArgs) {\n-        match *generic_args {\n-            GenericArgs::AngleBracketed(ref data) => {\n-                for arg in &data.args {\n-                    self.visit_generic_arg(arg)\n-                }\n-                for type_binding in &data.bindings {\n-                    // Type bindings such as `Item=impl Debug` in `Iterator<Item=Debug>`\n-                    // are allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(None, |this| visit::walk_ty(this, &type_binding.ty));\n-                }\n-            }\n-            GenericArgs::Parenthesized(ref data) => {\n-                for type_ in &data.inputs {\n-                    self.visit_ty(type_);\n-                }\n-                if let Some(ref type_) = data.output {\n-                    // `-> Foo` syntax is essentially an associated type binding,\n-                    // so it is also allowed to contain nested `impl Trait`.\n-                    self.with_impl_trait(None, |this| visit::walk_ty(this, type_));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _mac: &Spanned<Mac_>) {\n-        // covered in AstValidator\n-    }\n-}\n-\n-// Bans `impl Trait` in path projections like `<impl Iterator>::Item` or `Foo::Bar<impl Trait>`.\n-struct ImplTraitProjectionVisitor<'a> {\n-    session: &'a Session,\n-    is_banned: bool,\n-}\n-\n-impl<'a> ImplTraitProjectionVisitor<'a> {\n-    fn with_ban<F>(&mut self, f: F)\n-        where F: FnOnce(&mut ImplTraitProjectionVisitor<'a>)\n-    {\n-        let old_is_banned = self.is_banned;\n-        self.is_banned = true;\n-        f(self);\n-        self.is_banned = old_is_banned;\n-    }\n-}\n-\n-impl<'a> Visitor<'a> for ImplTraitProjectionVisitor<'a> {\n-    fn visit_ty(&mut self, t: &'a Ty) {\n-        match t.node {\n-            TyKind::ImplTrait(..) => {\n-                if self.is_banned {\n-                    struct_span_err!(self.session, t.span, E0667,\n-                        \"`impl Trait` is not allowed in path parameters\").emit();\n-                }\n-            }\n-            TyKind::Path(ref qself, ref path) => {\n-                // We allow these:\n-                //  - `Option<impl Trait>`\n-                //  - `option::Option<impl Trait>`\n-                //  - `option::Option<T>::Foo<impl Trait>\n-                //\n-                // But not these:\n-                //  - `<impl Trait>::Foo`\n-                //  - `option::Option<impl Trait>::Foo`.\n-                //\n-                // To implement this, we disallow `impl Trait` from `qself`\n-                // (for cases like `<impl Trait>::Foo>`)\n-                // but we allow `impl Trait` in `GenericArgs`\n-                // iff there are no more PathSegments.\n-                if let Some(ref qself) = *qself {\n-                    // `impl Trait` in `qself` is always illegal\n-                    self.with_ban(|this| this.visit_ty(&qself.ty));\n-                }\n-\n-                for (i, segment) in path.segments.iter().enumerate() {\n-                    // Allow `impl Trait` iff we're on the final path segment\n-                    if i == path.segments.len() - 1 {\n-                        visit::walk_path_segment(self, path.span, segment);\n-                    } else {\n-                        self.with_ban(|this|\n-                            visit::walk_path_segment(this, path.span, segment));\n-                    }\n-                }\n-            }\n-            _ => visit::walk_ty(self, t),\n-        }\n-    }\n-\n-    fn visit_mac(&mut self, _mac: &Spanned<Mac_>) {\n-        // covered in AstValidator\n-    }\n-}\n-\n pub fn check_crate(session: &Session, krate: &Crate) {\n-    visit::walk_crate(\n-        &mut NestedImplTraitVisitor {\n-            session,\n-            outer_impl_trait: None,\n-        }, krate);\n-\n-    visit::walk_crate(\n-        &mut ImplTraitProjectionVisitor {\n-            session,\n-            is_banned: false,\n-        }, krate);\n-\n-    visit::walk_crate(&mut AstValidator { session }, krate)\n+    visit::walk_crate(&mut AstValidator {\n+        session,\n+        outer_impl_trait: None,\n+        is_impl_trait_banned: false,\n+    }, krate)\n }"}, {"sha": "3db73800d640a207df802a55ad05adde84a53a88", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -680,6 +680,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 module.populated.set(true);\n             }\n+            Def::Existential(..) |\n             Def::TraitAlias(..) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }"}, {"sha": "d1dfe9469fb774753afedee85e4c200ec058c8f5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1199,7 +1199,6 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                     (self.final_ty.unwrap_or(self.expected_ty), expression_ty)\n                 };\n \n-                let reason_label = \"expected because of this statement\";\n                 let mut db;\n                 match cause.code {\n                     ObligationCauseCode::ReturnNoExpression => {\n@@ -1209,63 +1208,20 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n                         db.span_label(cause.span, \"return type is not `()`\");\n                     }\n                     ObligationCauseCode::BlockTailExpression(blk_id) => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n-\n-                        let expr = expression.unwrap_or_else(|| {\n-                            span_bug!(cause.span,\n-                                      \"supposed to be part of a block tail expression, but the \\\n-                                       expression is empty\");\n-                        });\n-                        let pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n-                            &mut db,\n-                            expr,\n+                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n+                        db = self.report_return_mismatched_types(\n+                            cause,\n                             expected,\n                             found,\n-                            cause.span,\n-                            blk_id,\n+                            err,\n+                            fcx,\n+                            parent_id,\n+                            expression.map(|expr| (expr, blk_id)),\n                         );\n-                        // FIXME: replace with navigating up the chain until hitting an fn or\n-                        // bailing if no \"pass-through\" Node is found, in order to provide a\n-                        // suggestion when encountering something like:\n-                        // ```\n-                        // fn foo(a: bool) -> impl Debug {\n-                        //     if a {\n-                        //         bar()?;\n-                        //     }\n-                        //     {\n-                        //         let x = unsafe { bar() };\n-                        //         x\n-                        //     }\n-                        // }\n-                        // ```\n-                        //\n-                        // Verify that this is a tail expression of a function, otherwise the\n-                        // label pointing out the cause for the type coercion will be wrong\n-                        // as prior return coercions would not be relevant (#57664).\n-                        let parent_id = fcx.tcx.hir().get_parent_node(blk_id);\n-                        let parent = fcx.tcx.hir().get(fcx.tcx.hir().get_parent_node(parent_id));\n-                        if fcx.get_node_fn_decl(parent).is_some() && !pointing_at_return_type {\n-                            if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n-                                db.span_label(*sp, reason_label);\n-                            }\n-                        }\n                     }\n-                    ObligationCauseCode::ReturnType(_id) => {\n-                        db = fcx.report_mismatched_types(cause, expected, found, err);\n-                        let _id = fcx.tcx.hir().get_parent_node(_id);\n-                        let mut pointing_at_return_type = false;\n-                        if let Some((fn_decl, can_suggest)) = fcx.get_fn_decl(_id) {\n-                            pointing_at_return_type = fcx.suggest_missing_return_type(\n-                                &mut db, &fn_decl, expected, found, can_suggest);\n-                        }\n-                        if let (Some(sp), false) = (\n-                            fcx.ret_coercion_span.borrow().as_ref(),\n-                            pointing_at_return_type,\n-                        ) {\n-                            if !sp.overlaps(cause.span) {\n-                                db.span_label(*sp, reason_label);\n-                            }\n-                        }\n+                    ObligationCauseCode::ReturnType(id) => {\n+                        db = self.report_return_mismatched_types(\n+                            cause, expected, found, err, fcx, id, None);\n                     }\n                     _ => {\n                         db = fcx.report_mismatched_types(cause, expected, found, err);\n@@ -1283,6 +1239,59 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n         }\n     }\n \n+    fn report_return_mismatched_types<'a>(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+        fcx: &FnCtxt<'a, 'gcx, 'tcx>,\n+        id: syntax::ast::NodeId,\n+        expression: Option<(&'gcx hir::Expr, syntax::ast::NodeId)>,\n+    ) -> DiagnosticBuilder<'a> {\n+        let mut db = fcx.report_mismatched_types(cause, expected, found, err);\n+\n+        let mut pointing_at_return_type = false;\n+        let mut return_sp = None;\n+\n+        // Verify that this is a tail expression of a function, otherwise the\n+        // label pointing out the cause for the type coercion will be wrong\n+        // as prior return coercions would not be relevant (#57664).\n+        let parent_id = fcx.tcx.hir().get_parent_node(id);\n+        let fn_decl = if let Some((expr, blk_id)) = expression {\n+            pointing_at_return_type = fcx.suggest_mismatched_types_on_tail(\n+                &mut db,\n+                expr,\n+                expected,\n+                found,\n+                cause.span,\n+                blk_id,\n+            );\n+            let parent = fcx.tcx.hir().get(parent_id);\n+            fcx.get_node_fn_decl(parent).map(|(fn_decl, _, is_main)| (fn_decl, is_main))\n+        } else {\n+            fcx.get_fn_decl(parent_id)\n+        };\n+\n+        if let (Some((fn_decl, can_suggest)), _) = (fn_decl, pointing_at_return_type) {\n+            if expression.is_none() {\n+                pointing_at_return_type |= fcx.suggest_missing_return_type(\n+                    &mut db, &fn_decl, expected, found, can_suggest);\n+            }\n+            if !pointing_at_return_type {\n+                return_sp = Some(fn_decl.output.span()); // `impl Trait` return type\n+            }\n+        }\n+        if let (Some(sp), Some(return_sp)) = (fcx.ret_coercion_span.borrow().as_ref(), return_sp) {\n+            db.span_label(return_sp, \"expected because this return type...\");\n+            db.span_label( *sp, format!(\n+                \"...is found to be `{}` here\",\n+                fcx.resolve_type_vars_with_obligations(expected),\n+            ));\n+        }\n+        db\n+    }\n+\n     pub fn complete<'a>(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n         if let Some(final_ty) = self.final_ty {\n             final_ty"}, {"sha": "f71a163cee26156b813ee12dbb0126837c5dcdeb", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -304,7 +304,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         );\n                         if let Some(suggestion) = suggestion {\n                             // enum variant\n-                            err.help(&format!(\"did you mean `{}`?\", suggestion));\n+                            err.span_suggestion_with_applicability(\n+                                item_name.span,\n+                                \"did you mean\",\n+                                suggestion.to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n                         }\n                         err\n                     }\n@@ -440,7 +445,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(lev_candidate) = lev_candidate {\n-                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.ident));\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"did you mean\",\n+                        lev_candidate.ident.to_string(),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n                 err.emit();\n             }"}, {"sha": "6cae8d6fc5b9434c943cc39b48e5ae563355f678", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -608,8 +608,8 @@ fn check_existential_types<'a, 'fcx, 'gcx, 'tcx>(\n             if let ty::Opaque(def_id, substs) = ty.sty {\n                 trace!(\"check_existential_types: opaque_ty, {:?}, {:?}\", def_id, substs);\n                 let generics = tcx.generics_of(def_id);\n-                // only check named existential types\n-                if generics.parent.is_none() {\n+                // only check named existential types defined in this crate\n+                if generics.parent.is_none() && def_id.is_local() {\n                     let opaque_node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n                     if may_define_existential_type(tcx, fn_def_id, opaque_node_id) {\n                         trace!(\"check_existential_types may define. Generics: {:#?}\", generics);"}, {"sha": "82f3463dba0fc32b77329674168e2146eef96811", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -7,11 +7,9 @@\n //! primitives](#primitives), [standard macros](#macros), [I/O] and\n //! [multithreading], among [many other things][other].\n //!\n-//! `std` is available to all Rust crates by default, just as if each one\n-//! contained an `extern crate std;` import at the [crate root]. Therefore the\n+//! `std` is available to all Rust crates by default. Therefore the\n //! standard library can be accessed in [`use`] statements through the path\n-//! `std`, as in [`use std::env`], or in expressions through the absolute path\n-//! `::std`, as in [`::std::env::args`].\n+//! `std`, as in [`use std::env`].\n //!\n //! # How to read this documentation\n //!\n@@ -157,7 +155,6 @@\n //! [TCP]: net/struct.TcpStream.html\n //! [The Rust Prelude]: prelude/index.html\n //! [UDP]: net/struct.UdpSocket.html\n-//! [`::std::env::args`]: env/fn.args.html\n //! [`Arc`]: sync/struct.Arc.html\n //! [owned slice]: boxed/index.html\n //! [`Cell`]: cell/struct.Cell.html\n@@ -191,7 +188,6 @@\n //! [`thread`]: thread/index.html\n //! [`use std::env`]: env/index.html\n //! [`use`]: ../book/ch07-02-modules-and-use-to-control-scope-and-privacy.html#the-use-keyword-to-bring-paths-into-a-scope\n-//! [crate root]: ../book/ch07-01-packages-and-crates-for-making-libraries-and-executables.html\n //! [crates.io]: https://crates.io\n //! [deref-coercions]: ../book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n //! [files]: fs/struct.File.html"}, {"sha": "af521848e9057f04beb511691186156bba4cbf6d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -140,6 +140,20 @@ pub enum GenericArgs {\n }\n \n impl GenericArgs {\n+    pub fn is_parenthesized(&self) -> bool {\n+        match *self {\n+            Parenthesized(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_angle_bracketed(&self) -> bool {\n+        match *self {\n+            AngleBracketed(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn span(&self) -> Span {\n         match *self {\n             AngleBracketed(ref data) => data.span,"}, {"sha": "c7e33a16564280152c54b69bafeeffb219e852b7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 227, "deletions": 14, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -100,6 +100,7 @@ pub enum PathStyle {\n enum SemiColonMode {\n     Break,\n     Ignore,\n+    Comma,\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n@@ -1988,6 +1989,44 @@ impl<'a> Parser<'a> {\n \n                 result.unwrap()\n             }\n+            token::Dot if self.look_ahead(1, |t| match t {\n+                token::Literal(parse::token::Lit::Integer(_) , _) => true,\n+                _ => false,\n+            }) => { // recover from `let x = .4;`\n+                let lo = self.span;\n+                self.bump();\n+                if let token::Literal(\n+                    parse::token::Lit::Integer(val),\n+                    suffix,\n+                ) = self.token {\n+                    let suffix = suffix.and_then(|s| {\n+                        let s = s.as_str().get();\n+                        if [\"f32\", \"f64\"].contains(&s) {\n+                            Some(s)\n+                        } else {\n+                            None\n+                        }\n+                    }).unwrap_or(\"\");\n+                    self.bump();\n+                    let sp = lo.to(self.prev_span);\n+                    let mut err = self.diagnostic()\n+                        .struct_span_err(sp, \"float literals must have an integer part\");\n+                    err.span_suggestion_with_applicability(\n+                        sp,\n+                        \"must have an integer part\",\n+                        format!(\"0.{}{}\", val, suffix),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                    return Ok(match suffix {\n+                        \"f32\" => ast::LitKind::Float(val, ast::FloatTy::F32),\n+                        \"f64\" => ast::LitKind::Float(val, ast::FloatTy::F64),\n+                        _ => ast::LitKind::FloatUnsuffixed(val),\n+                    });\n+                } else {\n+                    unreachable!();\n+                };\n+            }\n             _ => { return self.unexpected_last(&self.token); }\n         };\n \n@@ -2149,7 +2188,27 @@ impl<'a> Parser<'a> {\n                            enable_warning: bool)\n                            -> PResult<'a, ()> {\n         loop {\n-            segments.push(self.parse_path_segment(style, enable_warning)?);\n+            let segment = self.parse_path_segment(style, enable_warning)?;\n+            if style == PathStyle::Expr {\n+                // In order to check for trailing angle brackets, we must have finished\n+                // recursing (`parse_path_segment` can indirectly call this function),\n+                // that is, the next token must be the highlighted part of the below example:\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                      ^ here\n+                //\n+                // As opposed to the below highlight (if we had only finished the first\n+                // recursion):\n+                //\n+                // `Foo::<Bar as Baz<T>>::Qux`\n+                //                     ^ here\n+                //\n+                // `PathStyle::Expr` is only provided at the root invocation and never in\n+                // `parse_path_segment` to recurse and therefore can be checked to maintain\n+                // this invariant.\n+                self.check_trailing_angle_brackets(&segment, token::ModSep);\n+            }\n+            segments.push(segment);\n \n             if self.is_import_coupler() || !self.eat(&token::ModSep) {\n                 return Ok(());\n@@ -2656,8 +2715,24 @@ impl<'a> Parser<'a> {\n                 break;\n             }\n \n+            let mut recovery_field = None;\n+            if let token::Ident(ident, _) = self.token {\n+                if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n+                    // Use in case of error after field-looking code: `S { foo: () with a }`\n+                    let mut ident = ident.clone();\n+                    ident.span = self.span;\n+                    recovery_field = Some(ast::Field {\n+                        ident,\n+                        span: self.span,\n+                        expr: self.mk_expr(self.span, ExprKind::Err, ThinVec::new()),\n+                        is_shorthand: false,\n+                        attrs: ThinVec::new(),\n+                    });\n+                }\n+            }\n+            let mut parsed_field = None;\n             match self.parse_field() {\n-                Ok(f) => fields.push(f),\n+                Ok(f) => parsed_field = Some(f),\n                 Err(mut e) => {\n                     e.span_label(struct_sp, \"while parsing this struct\");\n                     e.emit();\n@@ -2666,19 +2741,28 @@ impl<'a> Parser<'a> {\n                     // what comes next as additional fields, rather than\n                     // bailing out until next `}`.\n                     if self.token != token::Comma {\n-                        self.recover_stmt();\n-                        break;\n+                        self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n+                        if self.token != token::Comma {\n+                            break;\n+                        }\n                     }\n                 }\n             }\n \n             match self.expect_one_of(&[token::Comma],\n                                      &[token::CloseDelim(token::Brace)]) {\n-                Ok(()) => {}\n+                Ok(()) => if let Some(f) = parsed_field.or(recovery_field) {\n+                    // only include the field if there's no parse error for the field name\n+                    fields.push(f);\n+                }\n                 Err(mut e) => {\n+                    if let Some(f) = recovery_field {\n+                        fields.push(f);\n+                    }\n+                    e.span_label(struct_sp, \"while parsing this struct\");\n                     e.emit();\n-                    self.recover_stmt();\n-                    break;\n+                    self.recover_stmt_(SemiColonMode::Comma, BlockMode::Ignore);\n+                    self.eat(&token::Comma);\n                 }\n             }\n         }\n@@ -2757,6 +2841,8 @@ impl<'a> Parser<'a> {\n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let segment = self.parse_path_segment(PathStyle::Expr, true)?;\n+        self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n+\n         Ok(match self.token {\n             token::OpenDelim(token::Paren) => {\n                 // Method call `expr.f()`\n@@ -2784,6 +2870,116 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// This function checks if there are trailing angle brackets and produces\n+    /// a diagnostic to suggest removing them.\n+    ///\n+    /// ```ignore (diagnostic)\n+    /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+    ///                                                        ^^ help: remove extra angle brackets\n+    /// ```\n+    fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: token::Token) {\n+        // This function is intended to be invoked after parsing a path segment where there are two\n+        // cases:\n+        //\n+        // 1. A specific token is expected after the path segment.\n+        //    eg. `x.foo(`, `x.foo::<u32>(` (parenthesis - method call),\n+        //        `Foo::`, or `Foo::<Bar>::` (mod sep - continued path).\n+        // 2. No specific token is expected after the path segment.\n+        //    eg. `x.foo` (field access)\n+        //\n+        // This function is called after parsing `.foo` and before parsing the token `end` (if\n+        // present). This includes any angle bracket arguments, such as `.foo::<u32>` or\n+        // `Foo::<Bar>`.\n+\n+        // We only care about trailing angle brackets if we previously parsed angle bracket\n+        // arguments. This helps stop us incorrectly suggesting that extra angle brackets be\n+        // removed in this case:\n+        //\n+        // `x.foo >> (3)` (where `x.foo` is a `u32` for example)\n+        //\n+        // This case is particularly tricky as we won't notice it just looking at the tokens -\n+        // it will appear the same (in terms of upcoming tokens) as below (since the `::<u32>` will\n+        // have already been parsed):\n+        //\n+        // `x.foo::<u32>>>(3)`\n+        let parsed_angle_bracket_args = segment.args\n+            .as_ref()\n+            .map(|args| args.is_angle_bracketed())\n+            .unwrap_or(false);\n+\n+        debug!(\n+            \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n+            parsed_angle_bracket_args,\n+        );\n+        if !parsed_angle_bracket_args {\n+            return;\n+        }\n+\n+        // Keep the span at the start so we can highlight the sequence of `>` characters to be\n+        // removed.\n+        let lo = self.span;\n+\n+        // We need to look-ahead to see if we have `>` characters without moving the cursor forward\n+        // (since we might have the field access case and the characters we're eating are\n+        // actual operators and not trailing characters - ie `x.foo >> 3`).\n+        let mut position = 0;\n+\n+        // We can encounter `>` or `>>` tokens in any order, so we need to keep track of how\n+        // many of each (so we can correctly pluralize our error messages) and continue to\n+        // advance.\n+        let mut number_of_shr = 0;\n+        let mut number_of_gt = 0;\n+        while self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            if *t == token::BinOp(token::BinOpToken::Shr) {\n+                number_of_shr += 1;\n+                true\n+            } else if *t == token::Gt {\n+                number_of_gt += 1;\n+                true\n+            } else {\n+                false\n+            }\n+        }) {\n+            position += 1;\n+        }\n+\n+        // If we didn't find any trailing `>` characters, then we have nothing to error about.\n+        debug!(\n+            \"check_trailing_angle_brackets: number_of_gt={:?} number_of_shr={:?}\",\n+            number_of_gt, number_of_shr,\n+        );\n+        if number_of_gt < 1 && number_of_shr < 1 {\n+            return;\n+        }\n+\n+        // Finally, double check that we have our end token as otherwise this is the\n+        // second case.\n+        if self.look_ahead(position, |t| {\n+            trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n+            *t == end\n+        }) {\n+            // Eat from where we started until the end token so that parsing can continue\n+            // as if we didn't have those extra angle brackets.\n+            self.eat_to_tokens(&[&end]);\n+            let span = lo.until(self.span);\n+\n+            let plural = number_of_gt > 1 || number_of_shr >= 1;\n+            self.diagnostic()\n+                .struct_span_err(\n+                    span,\n+                    &format!(\"unmatched angle bracket{}\", if plural { \"s\" } else { \"\" }),\n+                )\n+                .span_suggestion_with_applicability(\n+                    span,\n+                    &format!(\"remove extra angle bracket{}\", if plural { \"s\" } else { \"\" }),\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n+    }\n+\n     fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         let mut e = e0;\n         let mut hi;\n@@ -4542,13 +4738,13 @@ impl<'a> Parser<'a> {\n                 token::CloseDelim(token::DelimToken::Brace) => {\n                     if brace_depth == 0 {\n                         debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n-                        return;\n+                        break;\n                     }\n                     brace_depth -= 1;\n                     self.bump();\n                     if in_block && bracket_depth == 0 && brace_depth == 0 {\n                         debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n-                        return;\n+                        break;\n                     }\n                 }\n                 token::CloseDelim(token::DelimToken::Bracket) => {\n@@ -4560,15 +4756,25 @@ impl<'a> Parser<'a> {\n                 }\n                 token::Eof => {\n                     debug!(\"recover_stmt_ return - Eof\");\n-                    return;\n+                    break;\n                 }\n                 token::Semi => {\n                     self.bump();\n                     if break_on_semi == SemiColonMode::Break &&\n                        brace_depth == 0 &&\n                        bracket_depth == 0 {\n                         debug!(\"recover_stmt_ return - Semi\");\n-                        return;\n+                        break;\n+                    }\n+                }\n+                token::Comma => {\n+                    if break_on_semi == SemiColonMode::Comma &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n+                        break;\n+                    } else {\n+                        self.bump();\n                     }\n                 }\n                 _ => {\n@@ -7275,9 +7481,16 @@ impl<'a> Parser<'a> {\n             // CONST ITEM\n             if self.eat_keyword(keywords::Mut) {\n                 let prev_span = self.prev_span;\n-                self.diagnostic().struct_span_err(prev_span, \"const globals cannot be mutable\")\n-                                 .help(\"did you mean to declare a static?\")\n-                                 .emit();\n+                let mut err = self.diagnostic()\n+                    .struct_span_err(prev_span, \"const globals cannot be mutable\");\n+                err.span_label(prev_span, \"cannot be mutable\");\n+                err.span_suggestion_with_applicability(\n+                    const_span,\n+                    \"you might want to declare a static instead\",\n+                    \"static\".to_owned(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n             let prev_span = self.prev_span;"}, {"sha": "356e24d18a78fad3609c348cd9d3da5bf2744eda", "filename": "src/test/ui/auto-ref-slice-plus-ref.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fauto-ref-slice-plus-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fauto-ref-slice-plus-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-ref-slice-plus-ref.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -2,12 +2,11 @@ error[E0599]: no method named `test_mut` found for type `std::vec::Vec<{integer}\n   --> $DIR/auto-ref-slice-plus-ref.rs:7:7\n    |\n LL |     a.test_mut(); //~ ERROR no method named `test_mut` found\n-   |       ^^^^^^^^\n+   |       ^^^^^^^^ help: did you mean: `get_mut`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `test_mut`, perhaps you need to implement it:\n            candidate #1: `MyIter`\n-   = help: did you mean `get_mut`?\n \n error[E0599]: no method named `test` found for type `std::vec::Vec<{integer}>` in the current scope\n   --> $DIR/auto-ref-slice-plus-ref.rs:8:7"}, {"sha": "a6346a5233f4c3d12877c10fbdfb39bf25093546", "filename": "src/test/ui/block-result/issue-3563.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-3563.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -2,9 +2,7 @@ error[E0599]: no method named `b` found for type `&Self` in the current scope\n   --> $DIR/issue-3563.rs:3:17\n    |\n LL |         || self.b()\n-   |                 ^\n-   |\n-   = help: did you mean `a`?\n+   |                 ^ help: did you mean: `a`\n \n error: aborting due to previous error\n "}, {"sha": "19844503a48048e345967c0dbbe10cc27498e904", "filename": "src/test/ui/empty/empty-struct-braces-expr.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fempty%2Fempty-struct-braces-expr.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -51,20 +51,18 @@ error[E0599]: no variant named `Empty3` found for type `empty_struct::XE` in the\n    |\n LL |     let xe3 = XE::Empty3; //~ ERROR no variant named `Empty3` found for type\n    |               ----^^^^^^\n-   |               |\n+   |               |   |\n+   |               |   help: did you mean: `XEmpty3`\n    |               variant not found in `empty_struct::XE`\n-   |\n-   = help: did you mean `XEmpty3`?\n \n error[E0599]: no variant named `Empty3` found for type `empty_struct::XE` in the current scope\n   --> $DIR/empty-struct-braces-expr.rs:23:19\n    |\n LL |     let xe3 = XE::Empty3(); //~ ERROR no variant named `Empty3` found for type\n    |               ----^^^^^^\n-   |               |\n+   |               |   |\n+   |               |   help: did you mean: `XEmpty3`\n    |               variant not found in `empty_struct::XE`\n-   |\n-   = help: did you mean `XEmpty3`?\n \n error: aborting due to 8 previous errors\n "}, {"sha": "af2d209826e19a2ff375feddbc4f02f7d68fdeba", "filename": "src/test/ui/existential_types/auxiliary/cross_crate_ice.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,12 @@\n+// Crate that exports an existential type. Used for testing cross-crate.\n+\n+#![crate_type=\"rlib\"]\n+\n+#![feature(existential_type)]\n+\n+pub existential type Foo: std::fmt::Debug;\n+\n+pub fn foo() -> Foo {\n+    5\n+}\n+"}, {"sha": "39ec5394febe42f8f251370e4c2bc2aebc54bc5d", "filename": "src/test/ui/existential_types/auxiliary/cross_crate_ice2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fauxiliary%2Fcross_crate_ice2.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,21 @@\n+// Crate that exports an existential type. Used for testing cross-crate.\n+\n+#![crate_type=\"rlib\"]\n+\n+#![feature(existential_type)]\n+\n+pub trait View {\n+    type Tmp: Iterator<Item = u32>;\n+\n+    fn test(&self) -> Self::Tmp;\n+}\n+\n+pub struct X;\n+\n+impl View for X {\n+    existential type Tmp: Iterator<Item = u32>;\n+\n+    fn test(&self) -> Self::Tmp {\n+        vec![1,2,3].into_iter()\n+    }\n+}"}, {"sha": "c5d5ca916a48aa94e1226ed22f8a6936c5440d31", "filename": "src/test/ui/existential_types/cross_crate_ice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fcross_crate_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fcross_crate_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fcross_crate_ice.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,16 @@\n+// aux-build:cross_crate_ice.rs\n+// compile-pass\n+\n+extern crate cross_crate_ice;\n+\n+struct Bar(cross_crate_ice::Foo);\n+\n+impl Bar {\n+    fn zero(&self) -> &cross_crate_ice::Foo {\n+        &self.0\n+    }\n+}\n+\n+fn main() {\n+    let _ = cross_crate_ice::foo();\n+}"}, {"sha": "a0f3933ce33b23c5293e6496ca30763f8a2ea714", "filename": "src/test/ui/existential_types/cross_crate_ice2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fcross_crate_ice2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fexistential_types%2Fcross_crate_ice2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fcross_crate_ice2.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,11 @@\n+// aux-build:cross_crate_ice2.rs\n+// compile-pass\n+\n+extern crate cross_crate_ice2;\n+\n+use cross_crate_ice2::View;\n+\n+fn main() {\n+    let v = cross_crate_ice2::X;\n+    v.test();\n+}"}, {"sha": "6cd9d07748c27043ddd019388e3b08cd98373007", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,8 +1,11 @@\n error[E0308]: mismatched types\n   --> $DIR/equality.rs:15:5\n    |\n+LL | fn two(x: bool) -> impl Foo {\n+   |                    -------- expected because this return type...\n+LL |     if x {\n LL |         return 1_i32;\n-   |                ----- expected because of this statement\n+   |                ----- ...is found to be `i32` here\n LL |     }\n LL |     0_u32\n    |     ^^^^^ expected i32, found u32"}, {"sha": "9cad002036fff4cc8b6f9fc1de814fab0e0b6df2", "filename": "src/test/ui/issues/issue-23217.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-23217.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-23217.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23217.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -5,10 +5,9 @@ LL | pub enum SomeEnum {\n    | ----------------- variant `A` not found here\n LL |     B = SomeEnum::A,\n    |         ----------^\n-   |         |\n+   |         |         |\n+   |         |         help: did you mean: `B`\n    |         variant not found in `SomeEnum`\n-   |\n-   = help: did you mean `B`?\n \n error: aborting due to previous error\n "}, {"sha": "b6f520c644b32a659afd967d8a03cb7d4f9438f9", "filename": "src/test/ui/issues/issue-28344.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28344.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -11,8 +11,7 @@ LL |     let x: u8 = BitXor::bitor(0 as u8, 0 as u8);\n    |                 --------^^^^^\n    |                 |\n    |                 function or associated item not found in `dyn std::ops::BitXor<_>`\n-   |\n-   = help: did you mean `bitxor`?\n+   |                 help: did you mean: `bitxor`\n \n error[E0191]: the value of the associated type `Output` (from the trait `std::ops::BitXor`) must be specified\n   --> $DIR/issue-28344.rs:8:13\n@@ -27,8 +26,7 @@ LL |     let g = BitXor::bitor;\n    |             --------^^^^^\n    |             |\n    |             function or associated item not found in `dyn std::ops::BitXor<_>`\n-   |\n-   = help: did you mean `bitxor`?\n+   |             help: did you mean: `bitxor`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "77d0b53ad216bbef9be9f34168281a8a88c41df1", "filename": "src/test/ui/issues/issue-28971.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-28971.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-28971.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28971.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -5,9 +5,10 @@ LL | enum Foo {\n    | -------- variant `Baz` not found here\n ...\n LL |             Foo::Baz(..) => (),\n-   |             -----^^^---- variant not found in `Foo`\n-   |\n-   = help: did you mean `Bar`?\n+   |             -----^^^----\n+   |             |    |\n+   |             |    help: did you mean: `Bar`\n+   |             variant not found in `Foo`\n \n error: aborting due to previous error\n "}, {"sha": "96d6814b0fe93762e7fd885fd3f0e9c82ce28024", "filename": "src/test/ui/issues/issue-50264-inner-deref-trait/result-deref-err.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50264-inner-deref-trait%2Fresult-deref-err.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -2,11 +2,10 @@ error[E0599]: no method named `deref_err` found for type `std::result::Result<_,\n   --> $DIR/result-deref-err.rs:4:28\n    |\n LL |     let _result = &Err(41).deref_err();\n-   |                            ^^^^^^^^^\n+   |                            ^^^^^^^^^ help: did you mean: `deref_ok`\n    |\n    = note: the method `deref_err` exists but the following trait bounds were not satisfied:\n            `{integer} : std::ops::Deref`\n-   = help: did you mean `deref_ok`?\n \n error: aborting due to previous error\n "}, {"sha": "4e9453653735a45d5cfc0d2b8f37f775d795a5bf", "filename": "src/test/ui/issues/issue-52496.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-52496.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-52496.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52496.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,12 @@\n+struct Foo { bar: f64, baz: i64, bat: i64 }\n+\n+fn main() {\n+    let _ = Foo { bar: .5, baz: 42 };\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR missing field `bat` in initializer of `Foo`\n+    let bar = 1.5f32;\n+    let _ = Foo { bar.into(), bat: -1, . };\n+    //~^ ERROR expected one of\n+    //~| ERROR missing fields `bar`, `baz` in initializer of `Foo`\n+    //~| ERROR expected identifier, found `.`\n+}"}, {"sha": "43009a15bd49a2466cba97a6fa403de17b536ffb", "filename": "src/test/ui/issues/issue-52496.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-52496.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-52496.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52496.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,37 @@\n+error: float literals must have an integer part\n+  --> $DIR/issue-52496.rs:4:24\n+   |\n+LL |     let _ = Foo { bar: .5, baz: 42 };\n+   |                        ^^ help: must have an integer part: `0.5`\n+\n+error: expected one of `,` or `}`, found `.`\n+  --> $DIR/issue-52496.rs:8:22\n+   |\n+LL |     let _ = Foo { bar.into(), bat: -1, . };\n+   |             ---      ^ expected one of `,` or `}` here\n+   |             |\n+   |             while parsing this struct\n+\n+error: expected identifier, found `.`\n+  --> $DIR/issue-52496.rs:8:40\n+   |\n+LL |     let _ = Foo { bar.into(), bat: -1, . };\n+   |             ---                        ^ expected identifier\n+   |             |\n+   |             while parsing this struct\n+\n+error[E0063]: missing field `bat` in initializer of `Foo`\n+  --> $DIR/issue-52496.rs:4:13\n+   |\n+LL |     let _ = Foo { bar: .5, baz: 42 };\n+   |             ^^^ missing `bat`\n+\n+error[E0063]: missing fields `bar`, `baz` in initializer of `Foo`\n+  --> $DIR/issue-52496.rs:8:13\n+   |\n+LL |     let _ = Foo { bar.into(), bat: -1, . };\n+   |             ^^^ missing `bar`, `baz`\n+\n+error: aborting due to 5 previous errors\n+\n+For more information about this error, try `rustc --explain E0063`."}, {"sha": "d6a14a6e11f674de9723f7e40f37632ee84da761", "filename": "src/test/ui/issues/issue-54521-1.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-1.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,16 @@\n+// compile-pass\n+\n+// This test checks that the `remove extra angle brackets` error doesn't happen for some\n+// potential edge-cases..\n+\n+struct X {\n+    len: u32,\n+}\n+\n+fn main() {\n+    let x = X { len: 3 };\n+\n+    let _ = x.len > (3);\n+\n+    let _ = x.len >> (3);\n+}"}, {"sha": "a91c4fe43ea46e066bb67e386fd58c3e5d451505", "filename": "src/test/ui/issues/issue-54521-2.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.fixed?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = Vec::<usize>>>::new();\n+//                     ^^ help: remove extra angle brackets\n+// ```\n+\n+fn main() {\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>::new();\n+    //~^ ERROR unmatched angle bracket\n+}"}, {"sha": "3639aac87ee7fdae4b695fc02f47c1e378f51bc3", "filename": "src/test/ui/issues/issue-54521-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = Vec::<usize>>>::new();\n+//                     ^^ help: remove extra angle brackets\n+// ```\n+\n+fn main() {\n+    let _ = Vec::<usize>>>>>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>>>>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>>>::new();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = Vec::<usize>>::new();\n+    //~^ ERROR unmatched angle bracket\n+}"}, {"sha": "9556b83b730a4ecbda08ab50a9daad9e3ebf2a75", "filename": "src/test/ui/issues/issue-54521-2.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521-2.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,26 @@\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521-2.rs:11:25\n+   |\n+LL |     let _ = Vec::<usize>>>>>::new();\n+   |                         ^^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521-2.rs:14:25\n+   |\n+LL |     let _ = Vec::<usize>>>>::new();\n+   |                         ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521-2.rs:17:25\n+   |\n+LL |     let _ = Vec::<usize>>>::new();\n+   |                         ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-54521-2.rs:20:25\n+   |\n+LL |     let _ = Vec::<usize>>::new();\n+   |                         ^ help: remove extra angle bracket\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "84ab6866cf133e61f086e0184068d33cf7e53b44", "filename": "src/test/ui/issues/issue-54521.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521.fixed?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+//                                                        ^^ help: remove extra angle brackets\n+// ```\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+}"}, {"sha": "f1d68504178804baba3f333a4b102c1c9d3f83a2", "filename": "src/test/ui/issues/issue-54521.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+//                                                        ^^ help: remove extra angle brackets\n+// ```\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>();\n+    //~^ ERROR unmatched angle bracket\n+}"}, {"sha": "ffefbfd0348a8d8c1c7c64bcac07e048e92a611a", "filename": "src/test/ui/issues/issue-54521.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fissues%2Fissue-54521.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54521.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,26 @@\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521.rs:11:60\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>>>();\n+   |                                                            ^^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521.rs:14:60\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>>();\n+   |                                                            ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-54521.rs:17:60\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n+   |                                                            ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-54521.rs:20:60\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>();\n+   |                                                            ^ help: remove extra angle bracket\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "795a8c7631d9a84d28b78bffd908933ba79e7d43", "filename": "src/test/ui/parser/issue-17718-const-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fissue-17718-const-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fissue-17718-const-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-17718-const-mut.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,6 +1,6 @@\n const\n mut //~ ERROR: const globals cannot be mutable\n-//~^ HELP did you mean to declare a static?\n+//~^^ HELP you might want to declare a static instead\n FOO: usize = 3;\n \n fn main() {"}, {"sha": "19f9fe19ef5abaf88a018db5e5d6ec003e2c1cbe", "filename": "src/test/ui/parser/issue-17718-const-mut.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fissue-17718-const-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fissue-17718-const-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-17718-const-mut.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,10 +1,10 @@\n error: const globals cannot be mutable\n   --> $DIR/issue-17718-const-mut.rs:2:1\n    |\n+LL | const\n+   | ----- help: you might want to declare a static instead: `static`\n LL | mut //~ ERROR: const globals cannot be mutable\n-   | ^^^\n-   |\n-   = help: did you mean to declare a static?\n+   | ^^^ cannot be mutable\n \n error: aborting due to previous error\n "}, {"sha": "2c1e152dcee750ceb10b086d0428453405c048e1", "filename": "src/test/ui/parser/removed-syntax-with-1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-1.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -5,7 +5,6 @@ fn main() {\n     }\n \n     let a = S { foo: (), bar: () };\n-    let b = S { foo: () with a };\n+    let b = S { foo: () with a, bar: () };\n     //~^ ERROR expected one of `,`, `.`, `?`, `}`, or an operator, found `with`\n-    //~| ERROR missing field `bar` in initializer of `main::S`\n }"}, {"sha": "a157873916a649779a6bf94b8ee84ebc692bb4d9", "filename": "src/test/ui/parser/removed-syntax-with-1.stderr", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-1.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,15 +1,10 @@\n error: expected one of `,`, `.`, `?`, `}`, or an operator, found `with`\n   --> $DIR/removed-syntax-with-1.rs:8:25\n    |\n-LL |     let b = S { foo: () with a };\n-   |                         ^^^^ expected one of `,`, `.`, `?`, `}`, or an operator here\n+LL |     let b = S { foo: () with a, bar: () };\n+   |             -           ^^^^ expected one of `,`, `.`, `?`, `}`, or an operator here\n+   |             |\n+   |             while parsing this struct\n \n-error[E0063]: missing field `bar` in initializer of `main::S`\n-  --> $DIR/removed-syntax-with-1.rs:8:13\n-   |\n-LL |     let b = S { foo: () with a };\n-   |             ^ missing `bar`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0063`."}, {"sha": "f666da49696ba6499a352052288992918b6d225b", "filename": "src/test/ui/parser/removed-syntax-with-2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -7,6 +7,5 @@ fn main() {\n     let a = S { foo: (), bar: () };\n     let b = S { foo: (), with a };\n     //~^ ERROR expected one of `,` or `}`, found `a`\n-    //~| ERROR cannot find value `with` in this scope\n-    //~| ERROR struct `main::S` has no field named `with`\n+    //~| ERROR missing field `bar` in initializer of `main::S`\n }"}, {"sha": "7717b49d3a2c7d443c98770a5a28208776a80018", "filename": "src/test/ui/parser/removed-syntax-with-2.stderr", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fremoved-syntax-with-2.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -2,23 +2,16 @@ error: expected one of `,` or `}`, found `a`\n   --> $DIR/removed-syntax-with-2.rs:8:31\n    |\n LL |     let b = S { foo: (), with a };\n-   |                               ^ expected one of `,` or `}` here\n+   |             -                 ^ expected one of `,` or `}` here\n+   |             |\n+   |             while parsing this struct\n \n-error[E0425]: cannot find value `with` in this scope\n-  --> $DIR/removed-syntax-with-2.rs:8:26\n+error[E0063]: missing field `bar` in initializer of `main::S`\n+  --> $DIR/removed-syntax-with-2.rs:8:13\n    |\n LL |     let b = S { foo: (), with a };\n-   |                          ^^^^ not found in this scope\n+   |             ^ missing `bar`\n \n-error[E0560]: struct `main::S` has no field named `with`\n-  --> $DIR/removed-syntax-with-2.rs:8:26\n-   |\n-LL |     let b = S { foo: (), with a };\n-   |                          ^^^^ `main::S` does not have this field\n-   |\n-   = note: available fields are: `foo`, `bar`\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0425, E0560.\n-For more information about an error, try `rustc --explain E0425`.\n+For more information about this error, try `rustc --explain E0063`."}, {"sha": "58c40b3d96a4973af4ccf42bccd710f69345900a", "filename": "src/test/ui/parser/struct-field-numeric-shorthand.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,6 +1,9 @@\n struct Rgb(u8, u8, u8);\n \n fn main() {\n-    let _ = Rgb { 0, 1, 2 }; //~ ERROR expected identifier, found `0`\n-                             //~| ERROR missing fields `0`, `1`, `2` in initializer of `Rgb`\n+    let _ = Rgb { 0, 1, 2 };\n+    //~^ ERROR expected identifier, found `0`\n+    //~| ERROR expected identifier, found `1`\n+    //~| ERROR expected identifier, found `2`\n+    //~| ERROR missing fields `0`, `1`, `2` in initializer of `Rgb`\n }"}, {"sha": "cfb1f8201475469697bf279cf7b945673ec5cfb1", "filename": "src/test/ui/parser/struct-field-numeric-shorthand.stderr", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,17 +1,33 @@\n error: expected identifier, found `0`\n   --> $DIR/struct-field-numeric-shorthand.rs:4:19\n    |\n-LL |     let _ = Rgb { 0, 1, 2 }; //~ ERROR expected identifier, found `0`\n+LL |     let _ = Rgb { 0, 1, 2 };\n    |             ---   ^ expected identifier\n    |             |\n    |             while parsing this struct\n \n+error: expected identifier, found `1`\n+  --> $DIR/struct-field-numeric-shorthand.rs:4:22\n+   |\n+LL |     let _ = Rgb { 0, 1, 2 };\n+   |             ---      ^ expected identifier\n+   |             |\n+   |             while parsing this struct\n+\n+error: expected identifier, found `2`\n+  --> $DIR/struct-field-numeric-shorthand.rs:4:25\n+   |\n+LL |     let _ = Rgb { 0, 1, 2 };\n+   |             ---         ^ expected identifier\n+   |             |\n+   |             while parsing this struct\n+\n error[E0063]: missing fields `0`, `1`, `2` in initializer of `Rgb`\n   --> $DIR/struct-field-numeric-shorthand.rs:4:13\n    |\n-LL |     let _ = Rgb { 0, 1, 2 }; //~ ERROR expected identifier, found `0`\n+LL |     let _ = Rgb { 0, 1, 2 };\n    |             ^^^ missing `0`, `1`, `2`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0063`."}, {"sha": "5ebe00e624fc1ddfa2fc564d217078ef3f26257a", "filename": "src/test/ui/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,8 +1,11 @@\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:5:5\n    |\n+LL | fn foo() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n LL |         return 0i32;\n-   |                ---- expected because of this statement\n+   |                ---- ...is found to be `i32` here\n LL |     }\n LL |     1u32\n    |     ^^^^ expected i32, found u32\n@@ -13,8 +16,11 @@ LL |     1u32\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:13:16\n    |\n+LL | fn bar() -> impl std::fmt::Display {\n+   |             ---------------------- expected because this return type...\n+LL |     if false {\n LL |         return 0i32;\n-   |                ---- expected because of this statement\n+   |                ---- ...is found to be `i32` here\n LL |     } else {\n LL |         return 1u32;\n    |                ^^^^ expected i32, found u32\n@@ -25,10 +31,12 @@ LL |         return 1u32;\n error[E0308]: mismatched types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:19:5\n    |\n+LL |   fn baz() -> impl std::fmt::Display {\n+   |               ---------------------- expected because this return type...\n LL | /     if false {\n LL | |     //~^ ERROR mismatched types\n LL | |         return 0i32;\n-   | |                ---- expected because of this statement\n+   | |                ---- ...is found to be `i32` here\n LL | |     } else {\n LL | |         1u32\n LL | |     }"}, {"sha": "506ef8900b881e69d95737365d0dc00135ec19a0", "filename": "src/test/ui/suggestions/recover-invalid-float.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fsuggestions%2Frecover-invalid-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fsuggestions%2Frecover-invalid-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frecover-invalid-float.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,11 @@\n+fn main() {\n+    let _: usize = .3;\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+    let _: usize = .42f32;\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+    let _: usize = .5f64;\n+    //~^ ERROR float literals must have an integer part\n+    //~| ERROR mismatched types\n+}"}, {"sha": "c464676b444cc391344ad6ba0ceac1c5b058269f", "filename": "src/test/ui/suggestions/recover-invalid-float.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fsuggestions%2Frecover-invalid-float.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fsuggestions%2Frecover-invalid-float.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frecover-invalid-float.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -0,0 +1,42 @@\n+error: float literals must have an integer part\n+  --> $DIR/recover-invalid-float.rs:2:20\n+   |\n+LL |     let _: usize = .3;\n+   |                    ^^ help: must have an integer part: `0.3`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-invalid-float.rs:5:20\n+   |\n+LL |     let _: usize = .42f32;\n+   |                    ^^^^^^ help: must have an integer part: `0.42f32`\n+\n+error: float literals must have an integer part\n+  --> $DIR/recover-invalid-float.rs:8:20\n+   |\n+LL |     let _: usize = .5f64;\n+   |                    ^^^^^ help: must have an integer part: `0.5f64`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-invalid-float.rs:2:20\n+   |\n+LL |     let _: usize = .3;\n+   |                    ^^ expected usize, found floating-point number\n+   |\n+   = note: expected type `usize`\n+              found type `{float}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-invalid-float.rs:5:20\n+   |\n+LL |     let _: usize = .42f32;\n+   |                    ^^^^^^ expected usize, found f32\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-invalid-float.rs:8:20\n+   |\n+LL |     let _: usize = .5f64;\n+   |                    ^^^^^ expected usize, found f64\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b7727cf03a4e7e50c3f8414199e8dfec85788453", "filename": "src/test/ui/suggestions/suggest-methods.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-methods.stderr?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -5,25 +5,19 @@ LL | struct Foo;\n    | ----------- method `bat` not found for this\n ...\n LL |     f.bat(1.0); //~ ERROR no method named\n-   |       ^^^\n-   |\n-   = help: did you mean `bar`?\n+   |       ^^^ help: did you mean: `bar`\n \n error[E0599]: no method named `is_emtpy` found for type `std::string::String` in the current scope\n   --> $DIR/suggest-methods.rs:21:15\n    |\n LL |     let _ = s.is_emtpy(); //~ ERROR no method named\n-   |               ^^^^^^^^\n-   |\n-   = help: did you mean `is_empty`?\n+   |               ^^^^^^^^ help: did you mean: `is_empty`\n \n error[E0599]: no method named `count_eos` found for type `u32` in the current scope\n   --> $DIR/suggest-methods.rs:25:19\n    |\n LL |     let _ = 63u32.count_eos(); //~ ERROR no method named\n-   |                   ^^^^^^^^^\n-   |\n-   = help: did you mean `count_zeros`?\n+   |                   ^^^^^^^^^ help: did you mean: `count_zeros`\n \n error[E0599]: no method named `count_o` found for type `u32` in the current scope\n   --> $DIR/suggest-methods.rs:28:19"}, {"sha": "6254157e25da3eb960bfbbae82f677d0546a7fbb", "filename": "src/test/ui/traits/trait-privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Ftraits%2Ftrait-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9/src%2Ftest%2Fui%2Ftraits%2Ftrait-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-privacy.rs?ref=cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "patch": "@@ -1,5 +1,4 @@\n // compile-pass\n-#![feature(get_type_id)]\n #![allow(dead_code)]\n mod foo {\n     pub use self::bar::T;\n@@ -18,7 +17,7 @@ fn g() {\n \n fn f() {\n     let error = ::std::thread::spawn(|| {}).join().unwrap_err();\n-    error.get_type_id(); // Regression test for #21670\n+    error.type_id(); // Regression test for #21670\n }\n \n "}]}