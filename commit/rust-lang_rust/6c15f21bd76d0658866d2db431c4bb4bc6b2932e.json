{"sha": "6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMTVmMjFiZDc2ZDA2NTg4NjZkMmRiNDMxYzRiYjRiYzZiMjkzMmU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-13T12:36:10Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:09:18Z"}, "message": "port region.rs from oldvisit to <V:Visitor> trait API.", "tree": {"sha": "ffae7a9a6d9a737501300693ddc4463446fd4eb2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffae7a9a6d9a737501300693ddc4463446fd4eb2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "html_url": "https://github.com/rust-lang/rust/commit/6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c15f21bd76d0658866d2db431c4bb4bc6b2932e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca", "html_url": "https://github.com/rust-lang/rust/commit/69e822dcb3af7bceac1b1a3af4eeb2d67c1b12ca"}], "stats": {"total": 224, "additions": 135, "deletions": 89}, "files": [{"sha": "ddd22a0add4c66ac300fc935389e30f327740991", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 135, "deletions": 89, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/6c15f21bd76d0658866d2db431c4bb4bc6b2932e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c15f21bd76d0658866d2db431c4bb4bc6b2932e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=6c15f21bd76d0658866d2db431c4bb4bc6b2932e", "patch": "@@ -34,7 +34,10 @@ use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::parse::token;\n use syntax::parse::token::special_idents;\n-use syntax::{ast, oldvisit};\n+use syntax::{ast, visit};\n+use syntax::visit::{Visitor,fn_kind};\n+use syntax::ast::{Block,item,fn_decl,NodeId,arm,pat,stmt,expr,Local};\n+use syntax::ast::{Ty,TypeMethod,struct_field};\n \n /**\n The region maps encode information about region relationships.\n@@ -323,48 +326,53 @@ fn parent_to_expr(cx: Context, child_id: ast::NodeId, sp: span) {\n     }\n }\n \n-fn resolve_block(blk: &ast::Block,\n-                 (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_block(visitor: &mut RegionResolutionVisitor,\n+                 blk: &ast::Block,\n+                 cx: Context) {\n     // Record the parent of this block.\n     parent_to_expr(cx, blk.id, blk.span);\n \n     // Descend.\n     let new_cx = Context {var_parent: Some(blk.id),\n                           parent: Some(blk.id),\n                           ..cx};\n-    oldvisit::visit_block(blk, (new_cx, visitor));\n+    visit::walk_block(visitor, blk, new_cx);\n }\n \n-fn resolve_arm(arm: &ast::arm,\n-               (cx, visitor): (Context, oldvisit::vt<Context>)) {\n-    oldvisit::visit_arm(arm, (cx, visitor));\n+fn resolve_arm(visitor: &mut RegionResolutionVisitor,\n+               arm: &ast::arm,\n+               cx: Context) {\n+    visit::walk_arm(visitor, arm, cx);\n }\n \n-fn resolve_pat(pat: @ast::pat,\n-               (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_pat(visitor: &mut RegionResolutionVisitor,\n+               pat: @ast::pat,\n+               cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, pat.id, pat.span);\n-    oldvisit::visit_pat(pat, (cx, visitor));\n+    visit::walk_pat(visitor, pat, cx);\n }\n \n-fn resolve_stmt(stmt: @ast::stmt,\n-                (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n+                stmt: @ast::stmt,\n+                cx: Context) {\n     match stmt.node {\n         ast::stmt_decl(*) => {\n-            oldvisit::visit_stmt(stmt, (cx, visitor));\n+            visit::walk_stmt(visitor, stmt, cx);\n         }\n         ast::stmt_expr(_, stmt_id) |\n         ast::stmt_semi(_, stmt_id) => {\n             parent_to_expr(cx, stmt_id, stmt.span);\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n-            oldvisit::visit_stmt(stmt, (expr_cx, visitor));\n+            visit::walk_stmt(visitor, stmt, expr_cx);\n         }\n         ast::stmt_mac(*) => cx.sess.bug(\"unexpanded macro\")\n     }\n }\n \n-fn resolve_expr(expr: @ast::expr,\n-                (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n+                expr: @ast::expr,\n+                cx: Context) {\n     parent_to_expr(cx, expr.id, expr.span);\n \n     let mut new_cx = cx;\n@@ -400,30 +408,32 @@ fn resolve_expr(expr: @ast::expr,\n     };\n \n \n-    oldvisit::visit_expr(expr, (new_cx, visitor));\n+    visit::walk_expr(visitor, expr, new_cx);\n }\n \n-fn resolve_local(local: @ast::Local,\n-                 (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_local(visitor: &mut RegionResolutionVisitor,\n+                 local: @ast::Local,\n+                 cx: Context) {\n     assert_eq!(cx.var_parent, cx.parent);\n     parent_to_expr(cx, local.id, local.span);\n-    oldvisit::visit_local(local, (cx, visitor));\n+    visit::walk_local(visitor, local, cx);\n }\n \n-fn resolve_item(item: @ast::item,\n-                (cx, visitor): (Context, oldvisit::vt<Context>)) {\n+fn resolve_item(visitor: &mut RegionResolutionVisitor,\n+                item: @ast::item,\n+                cx: Context) {\n     // Items create a new outer block scope as far as we're concerned.\n     let new_cx = Context {var_parent: None, parent: None, ..cx};\n-    oldvisit::visit_item(item, (new_cx, visitor));\n+    visit::walk_item(visitor, item, new_cx);\n }\n \n-fn resolve_fn(fk: &oldvisit::fn_kind,\n+fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n+              fk: &visit::fn_kind,\n               decl: &ast::fn_decl,\n               body: &ast::Block,\n               sp: span,\n               id: ast::NodeId,\n-              (cx, visitor): (Context,\n-                              oldvisit::vt<Context>)) {\n+              cx: Context) {\n     debug!(\"region::resolve_fn(id=%?, \\\n                                span=%?, \\\n                                body.id=%?, \\\n@@ -438,26 +448,58 @@ fn resolve_fn(fk: &oldvisit::fn_kind,\n                            var_parent: Some(body.id),\n                            ..cx};\n     match *fk {\n-        oldvisit::fk_method(_, _, method) => {\n+        visit::fk_method(_, _, method) => {\n             cx.region_maps.record_parent(method.self_id, body.id);\n         }\n         _ => {}\n     }\n-    oldvisit::visit_fn_decl(decl, (decl_cx, visitor));\n+    visit::walk_fn_decl(visitor, decl, decl_cx);\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     let body_cx = match *fk {\n-        oldvisit::fk_item_fn(*) |\n-        oldvisit::fk_method(*) => {\n+        visit::fk_item_fn(*) |\n+        visit::fk_method(*) => {\n             Context {parent: None, var_parent: None, ..cx}\n         }\n-        oldvisit::fk_anon(*) |\n-        oldvisit::fk_fn_block(*) => {\n+        visit::fk_anon(*) |\n+        visit::fk_fn_block(*) => {\n             cx\n         }\n     };\n-    (visitor.visit_block)(body, (body_cx, visitor));\n+    visitor.visit_block(body, body_cx);\n+}\n+\n+struct RegionResolutionVisitor;\n+\n+impl Visitor<Context> for RegionResolutionVisitor {\n+\n+    fn visit_block(&mut self, b:&Block, cx:Context) {\n+        resolve_block(self, b, cx);\n+    }\n+\n+    fn visit_item(&mut self, i:@item, cx:Context) {\n+        resolve_item(self, i, cx);\n+    }\n+\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl, b:&Block, s:span, n:NodeId, cx:Context) {\n+        resolve_fn(self, fk, fd, b, s, n, cx);\n+    }\n+    fn visit_arm(&mut self, a:&arm, cx:Context) {\n+        resolve_arm(self, a, cx);\n+    }\n+    fn visit_pat(&mut self, p:@pat, cx:Context) {\n+        resolve_pat(self, p, cx);\n+    }\n+    fn visit_stmt(&mut self, s:@stmt, cx:Context) {\n+        resolve_stmt(self, s, cx);\n+    }\n+    fn visit_expr(&mut self, ex:@expr, cx:Context) {\n+        resolve_expr(self, ex, cx);\n+    }\n+    fn visit_local(&mut self, l:@Local, cx:Context) {\n+        resolve_local(self, l, cx);\n+    }\n }\n \n pub fn resolve_crate(sess: Session,\n@@ -474,18 +516,8 @@ pub fn resolve_crate(sess: Session,\n                       region_maps: region_maps,\n                       parent: None,\n                       var_parent: None};\n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_block: resolve_block,\n-        visit_item: resolve_item,\n-        visit_fn: resolve_fn,\n-        visit_arm: resolve_arm,\n-        visit_pat: resolve_pat,\n-        visit_stmt: resolve_stmt,\n-        visit_expr: resolve_expr,\n-        visit_local: resolve_local,\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (cx, visitor));\n+    let mut visitor = RegionResolutionVisitor;\n+    visit::walk_crate(&mut visitor, crate, cx);\n     return region_maps;\n }\n \n@@ -700,46 +732,45 @@ impl DetermineRpCtxt {\n     }\n }\n \n-fn determine_rp_in_item(item: @ast::item,\n-                        (cx, visitor): (@mut DetermineRpCtxt,\n-                                        oldvisit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_item(visitor: &mut DetermineRpVisitor,\n+                        item: @ast::item,\n+                        cx: @mut DetermineRpCtxt) {\n     do cx.with(item.id, true) {\n-        oldvisit::visit_item(item, (cx, visitor));\n+        visit::walk_item(visitor, item, cx);\n     }\n }\n \n-fn determine_rp_in_fn(fk: &oldvisit::fn_kind,\n+fn determine_rp_in_fn(visitor: &mut DetermineRpVisitor,\n+                      fk: &visit::fn_kind,\n                       decl: &ast::fn_decl,\n                       body: &ast::Block,\n                       _: span,\n                       _: ast::NodeId,\n-                      (cx, visitor): (@mut DetermineRpCtxt,\n-                                      oldvisit::vt<@mut DetermineRpCtxt>)) {\n+                      cx: @mut DetermineRpCtxt) {\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for a in decl.inputs.iter() {\n-                (visitor.visit_ty)(&a.ty, (cx, visitor));\n+                visitor.visit_ty(&a.ty, cx);\n             }\n         }\n-        (visitor.visit_ty)(&decl.output, (cx, visitor));\n-        let generics = oldvisit::generics_of_fn(fk);\n-        (visitor.visit_generics)(&generics, (cx, visitor));\n-        (visitor.visit_block)(body, (cx, visitor));\n+        visitor.visit_ty(&decl.output, cx);\n+        let generics = visit::generics_of_fn(fk);\n+        visitor.visit_generics(&generics, cx);\n+        visitor.visit_block(body, cx);\n     }\n }\n \n-fn determine_rp_in_ty_method(ty_m: &ast::TypeMethod,\n-                             (cx, visitor):\n-                             (@mut DetermineRpCtxt,\n-                              oldvisit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty_method(visitor: &mut DetermineRpVisitor,\n+                             ty_m: &ast::TypeMethod,\n+                             cx: @mut DetermineRpCtxt) {\n     do cx.with(cx.item_id, false) {\n-        oldvisit::visit_ty_method(ty_m, (cx, visitor));\n+        visit::walk_ty_method(visitor, ty_m, cx);\n     }\n }\n \n-fn determine_rp_in_ty(ty: &ast::Ty,\n-                      (cx, visitor): (@mut DetermineRpCtxt,\n-                                      oldvisit::vt<@mut DetermineRpCtxt>)) {\n+fn determine_rp_in_ty(visitor: &mut DetermineRpVisitor,\n+                      ty: &ast::Ty,\n+                      cx: @mut DetermineRpCtxt) {\n     // we are only interested in types that will require an item to\n     // be region-parameterized.  if cx.item_id is zero, then this type\n     // is not a member of a type defn nor is it a constitutent of an\n@@ -823,14 +854,14 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n     match ty.node {\n       ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n       ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n-        visit_mt(mt, (cx, visitor));\n+        visit_mt(visitor, mt, cx);\n       }\n \n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for tp in path.types.iter() {\n-                (visitor.visit_ty)(tp, (cx, visitor));\n+                visitor.visit_ty(tp, cx);\n             }\n         }\n       }\n@@ -843,37 +874,59 @@ fn determine_rp_in_ty(ty: &ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for a in decl.inputs.iter() {\n-                    (visitor.visit_ty)(&a.ty, (cx, visitor));\n+                    visitor.visit_ty(&a.ty, cx);\n                 }\n             }\n-            (visitor.visit_ty)(&decl.output, (cx, visitor));\n+            visitor.visit_ty(&decl.output, cx);\n         }\n       }\n \n       _ => {\n-        oldvisit::visit_ty(ty, (cx, visitor));\n+        visit::walk_ty(visitor, ty, cx);\n       }\n     }\n \n-    fn visit_mt(mt: &ast::mt,\n-                (cx, visitor): (@mut DetermineRpCtxt,\n-                                oldvisit::vt<@mut DetermineRpCtxt>)) {\n+    fn visit_mt(visitor: &mut DetermineRpVisitor,\n+                mt: &ast::mt,\n+                cx: @mut DetermineRpCtxt) {\n         // mutability is invariant\n         if mt.mutbl == ast::m_mutbl {\n             do cx.with_ambient_variance(rv_invariant) {\n-                (visitor.visit_ty)(mt.ty, (cx, visitor));\n+                visitor.visit_ty(mt.ty, cx);\n             }\n         } else {\n-            (visitor.visit_ty)(mt.ty, (cx, visitor));\n+            visitor.visit_ty(mt.ty, cx);\n         }\n     }\n }\n \n-fn determine_rp_in_struct_field(\n-        cm: @ast::struct_field,\n-        (cx, visitor): (@mut DetermineRpCtxt,\n-                        oldvisit::vt<@mut DetermineRpCtxt>)) {\n-    oldvisit::visit_struct_field(cm, (cx, visitor));\n+fn determine_rp_in_struct_field(visitor: &mut DetermineRpVisitor,\n+                                cm: @ast::struct_field,\n+                                cx: @mut DetermineRpCtxt) {\n+    visit::walk_struct_field(visitor, cm, cx);\n+}\n+\n+struct DetermineRpVisitor;\n+\n+impl Visitor<@mut DetermineRpCtxt> for DetermineRpVisitor {\n+\n+    fn visit_fn(&mut self, fk:&fn_kind, fd:&fn_decl,\n+                b:&Block, s:span, n:NodeId, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_fn(self, fk, fd, b, s, n, e);\n+    }\n+    fn visit_item(&mut self, i:@item, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_item(self, i, e);\n+    }\n+    fn visit_ty(&mut self, t:&Ty, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_ty(self, t, e);\n+    }\n+    fn visit_ty_method(&mut self, t:&TypeMethod, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_ty_method(self, t, e);\n+    }\n+    fn visit_struct_field(&mut self, s:@struct_field, e:@mut DetermineRpCtxt) {\n+        determine_rp_in_struct_field(self, s, e);\n+    }\n+\n }\n \n pub fn determine_rp_in_crate(sess: Session,\n@@ -894,15 +947,8 @@ pub fn determine_rp_in_crate(sess: Session,\n     };\n \n     // Gather up the base set, worklist and dep_map\n-    let visitor = oldvisit::mk_vt(@oldvisit::Visitor {\n-        visit_fn: determine_rp_in_fn,\n-        visit_item: determine_rp_in_item,\n-        visit_ty: determine_rp_in_ty,\n-        visit_ty_method: determine_rp_in_ty_method,\n-        visit_struct_field: determine_rp_in_struct_field,\n-        .. *oldvisit::default_visitor()\n-    });\n-    oldvisit::visit_crate(crate, (cx, visitor));\n+    let mut visitor = DetermineRpVisitor;\n+    visit::walk_crate(&mut visitor, crate, cx);\n \n     // Propagate indirect dependencies\n     //"}]}