{"sha": "5160b49e678496e8e3a704a3d0d03daae8e1fb30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNjBiNDllNjc4NDk2ZThlM2E3MDRhM2QwZDAzZGFhZThlMWZiMzA=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-27T10:16:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-27T10:16:01Z"}, "message": "Merge pull request #2308 from davidalber/recursive-test-files\n\nAdding ability to recursively find test files", "tree": {"sha": "20b514f7c4d11b6168ad7fed790036dfcf3fca44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20b514f7c4d11b6168ad7fed790036dfcf3fca44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5160b49e678496e8e3a704a3d0d03daae8e1fb30", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaQ3LhCRBK7hj4Ov3rIwAAdHIIAGPLgrr9tO3tJim1zY2h9xEQ\nxwEp5sYeySSmp5qL7+kKo3lq4M+1rX2NiFjBlAtcM/ZXQ0GrP9voqItOAv3/TXZs\nqqtbno2fm/h+cOqUHbTCoipN1FnT7XRs9INK9Y2R/RJfatilm/MoiTEdJ7yX2BWs\nPsZMKtekXg3HrtyNDzD5UtkNYtBg5QcH4U0z6FQxUlDP3n96Qkk+fKzvbNwxaW7q\nk2CnM3ZFULhJvR8VqD1n9PdlqLB3ppYp5jqew+ekYSz46EfuNle3uGyxli8vKxuD\noFcR4g9fwPjAfY7mZ+c/R8cpvjk4S1Fp9mUjeE4WsVWm8UN1+gnCDhEJ4EkH3yA=\n=0uUE\n-----END PGP SIGNATURE-----\n", "payload": "tree 20b514f7c4d11b6168ad7fed790036dfcf3fca44\nparent 656edbf0f041d83cd564c5ae742c7720f005b005\nparent 65a48da02da8e7594af69ad03f0517241cb71096\nauthor Seiichi Uchida <seuchida@gmail.com> 1514369761 +0900\ncommitter GitHub <noreply@github.com> 1514369761 +0900\n\nMerge pull request #2308 from davidalber/recursive-test-files\n\nAdding ability to recursively find test files"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5160b49e678496e8e3a704a3d0d03daae8e1fb30", "html_url": "https://github.com/rust-lang/rust/commit/5160b49e678496e8e3a704a3d0d03daae8e1fb30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5160b49e678496e8e3a704a3d0d03daae8e1fb30/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "656edbf0f041d83cd564c5ae742c7720f005b005", "url": "https://api.github.com/repos/rust-lang/rust/commits/656edbf0f041d83cd564c5ae742c7720f005b005", "html_url": "https://github.com/rust-lang/rust/commit/656edbf0f041d83cd564c5ae742c7720f005b005"}, {"sha": "65a48da02da8e7594af69ad03f0517241cb71096", "url": "https://api.github.com/repos/rust-lang/rust/commits/65a48da02da8e7594af69ad03f0517241cb71096", "html_url": "https://github.com/rust-lang/rust/commit/65a48da02da8e7594af69ad03f0517241cb71096"}], "stats": {"total": 52, "additions": 29, "deletions": 23}, "files": [{"sha": "69da2b2e43228b51a22c0de94e9e43ace060e68e", "filename": "tests/system.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5160b49e678496e8e3a704a3d0d03daae8e1fb30/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5160b49e678496e8e3a704a3d0d03daae8e1fb30/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=5160b49e678496e8e3a704a3d0d03daae8e1fb30", "patch": "@@ -30,8 +30,26 @@ use rustfmt::rustfmt_diff::*;\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n \n-fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> PathBuf {\n-    dir_entry.expect(\"Couldn't get DirEntry\").path().to_owned()\n+// Returns a `Vec` containing `PathBuf`s of files with a rs extension in the\n+// given path. The `recursive` argument controls if files from subdirectories\n+// are also returned.\n+fn get_test_files(path: &Path, recursive: bool) -> Vec<PathBuf> {\n+    let mut files = vec![];\n+    if path.is_dir() {\n+        for entry in fs::read_dir(path).expect(&format!(\n+            \"Couldn't read directory {}\",\n+            path.to_str().unwrap()\n+        )) {\n+            let entry = entry.expect(\"Couldn't get DirEntry\");\n+            let path = entry.path();\n+            if path.is_dir() && recursive {\n+                files.append(&mut get_test_files(&path, recursive));\n+            } else if path.extension().map_or(false, |f| f == \"rs\") {\n+                files.push(path);\n+            }\n+        }\n+    }\n+    files\n }\n \n // Integration tests. The files in the tests/source are formatted and compared\n@@ -41,10 +59,7 @@ fn get_path_string(dir_entry: io::Result<fs::DirEntry>) -> PathBuf {\n #[test]\n fn system_tests() {\n     // Get all files in the tests/source directory.\n-    let files = fs::read_dir(\"tests/source\").expect(\"Couldn't read source dir\");\n-    // Turn a DirEntry into a String that represents the relative path to the\n-    // file.\n-    let files = files.map(get_path_string);\n+    let files = get_test_files(Path::new(\"tests/source\"), true);\n     let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n@@ -56,8 +71,7 @@ fn system_tests() {\n // the only difference is the coverage mode\n #[test]\n fn coverage_tests() {\n-    let files = fs::read_dir(\"tests/coverage/source\").expect(\"Couldn't read source dir\");\n-    let files = files.map(get_path_string);\n+    let files = get_test_files(Path::new(\"tests/coverage/source\"), true);\n     let (_reports, count, fails) = check_files(files);\n \n     println!(\"Ran {} tests in coverage mode.\", count);\n@@ -102,9 +116,7 @@ fn assert_output(source: &Path, expected_filename: &Path) {\n #[test]\n fn idempotence_tests() {\n     // Get all files in the tests/target directory.\n-    let files = fs::read_dir(\"tests/target\")\n-        .expect(\"Couldn't read target dir\")\n-        .map(get_path_string);\n+    let files = get_test_files(Path::new(\"tests/target\"), true);\n     let (_reports, count, fails) = check_files(files);\n \n     // Display results.\n@@ -116,13 +128,10 @@ fn idempotence_tests() {\n // no warnings are emitted.\n #[test]\n fn self_tests() {\n-    let files = fs::read_dir(\"src/bin\")\n-        .expect(\"Couldn't read src dir\")\n-        .chain(fs::read_dir(\"tests\").expect(\"Couldn't read tests dir\"))\n-        .map(get_path_string);\n-    // Hack because there's no `IntoIterator` impl for `[T; N]`.\n-    let files = files.chain(Some(PathBuf::from(\"src/lib.rs\")).into_iter());\n-    let files = files.chain(Some(PathBuf::from(\"build.rs\")).into_iter());\n+    let mut files = get_test_files(Path::new(\"src/bin\"), false);\n+    files.append(&mut get_test_files(Path::new(\"tests\"), false));\n+    files.push(PathBuf::from(\"src/lib.rs\"));\n+    files.push(PathBuf::from(\"build.rs\"));\n \n     let (reports, count, fails) = check_files(files);\n     let mut warnings = 0;\n@@ -197,15 +206,12 @@ fn format_lines_errors_are_reported() {\n \n // For each file, run rustfmt and collect the output.\n // Returns the number of files checked and the number of failures.\n-fn check_files<I>(files: I) -> (Vec<FormatReport>, u32, u32)\n-where\n-    I: Iterator<Item = PathBuf>,\n-{\n+fn check_files(files: Vec<PathBuf>) -> (Vec<FormatReport>, u32, u32) {\n     let mut count = 0;\n     let mut fails = 0;\n     let mut reports = vec![];\n \n-    for file_name in files.filter(|f| f.extension().map_or(false, |f| f == \"rs\")) {\n+    for file_name in files {\n         debug!(\"Testing '{}'...\", file_name.display());\n \n         match idempotent_check(file_name) {"}]}