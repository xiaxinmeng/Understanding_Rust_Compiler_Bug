{"sha": "7426853ba255940b880f2e7f8026d60b94b42404", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MjY4NTNiYTI1NTk0MGI4ODBmMmU3ZjgwMjZkNjBiOTRiNDI0MDQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-01-30T21:45:57Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-02-09T21:55:34Z"}, "message": "Reduce the number of `RefCell`s in `InferCtxt`.\n\n`InferCtxt` contains six structures within `RefCell`s. Every time we\ncreate and dispose of (commit or rollback) a snapshot we have to\n`borrow_mut` each one of them.\n\nThis commit moves the six structures under a single `RefCell`, which\ngives significant speed-ups by reducing the number of `borrow_mut`\ncalls. To avoid runtime errors I had to reduce the lifetimes of dynamic\nborrows in a couple of places.", "tree": {"sha": "3fd4f6e957b91db962536b680edcb3f5eec792b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fd4f6e957b91db962536b680edcb3f5eec792b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7426853ba255940b880f2e7f8026d60b94b42404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7426853ba255940b880f2e7f8026d60b94b42404", "html_url": "https://github.com/rust-lang/rust/commit/7426853ba255940b880f2e7f8026d60b94b42404", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7426853ba255940b880f2e7f8026d60b94b42404/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a", "html_url": "https://github.com/rust-lang/rust/commit/a19edd6b161521a4f66716b3b45b8cf4d3f03f3a"}], "stats": {"total": 563, "additions": 321, "deletions": 242}, "files": [{"sha": "85fafa349151e42c339c3453daac54d8989cc294", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -317,7 +317,9 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                 let r = self\n                     .infcx\n                     .unwrap()\n-                    .borrow_region_constraints()\n+                    .inner\n+                    .borrow_mut()\n+                    .unwrap_region_constraints()\n                     .opportunistic_resolve_var(self.tcx, vid);\n                 debug!(\n                     \"canonical: region var found with vid {:?}, \\\n@@ -621,7 +623,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n \n     /// Returns the universe in which `vid` is defined.\n     fn region_var_universe(&self, vid: ty::RegionVid) -> ty::UniverseIndex {\n-        self.infcx.unwrap().borrow_region_constraints().var_universe(vid)\n+        self.infcx.unwrap().inner.borrow_mut().unwrap_region_constraints().var_universe(vid)\n     }\n \n     /// Creates a canonical variable (with the given `info`)"}, {"sha": "9eb961255c29518ba5c2b8a369cdee92b3f9d1bd", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -74,8 +74,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         match (&a.kind, &b.kind) {\n             // Relate integral variables to other types\n             (&ty::Infer(ty::IntVar(a_id)), &ty::Infer(ty::IntVar(b_id))) => {\n-                self.int_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .int_unification_table\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| int_unification_error(a_is_expected, e))?;\n                 Ok(a)\n@@ -95,8 +96,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n \n             // Relate floating-point variables to other types\n             (&ty::Infer(ty::FloatVar(a_id)), &ty::Infer(ty::FloatVar(b_id))) => {\n-                self.float_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .float_unification_table\n                     .unify_var_var(a_id, b_id)\n                     .map_err(|e| float_unification_error(relation.a_is_expected(), e))?;\n                 Ok(a)\n@@ -131,8 +133,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n             return Ok(a);\n         }\n \n-        let a = replace_if_possible(self.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(self.const_unification_table.borrow_mut(), b);\n+        let a = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, a);\n+        let b = replace_if_possible(&mut self.inner.borrow_mut().const_unification_table, b);\n \n         let a_is_expected = relation.a_is_expected();\n \n@@ -141,8 +143,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                 ty::ConstKind::Infer(InferConst::Var(a_vid)),\n                 ty::ConstKind::Infer(InferConst::Var(b_vid)),\n             ) => {\n-                self.const_unification_table\n+                self.inner\n                     .borrow_mut()\n+                    .const_unification_table\n                     .unify_var_var(a_vid, b_vid)\n                     .map_err(|e| const_unification_error(a_is_expected, e))?;\n                 return Ok(a);\n@@ -174,8 +177,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::ConstVid<'tcx>,\n         value: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        self.const_unification_table\n+        self.inner\n             .borrow_mut()\n+            .const_unification_table\n             .unify_var_value(\n                 vid,\n                 ConstVarValue {\n@@ -196,8 +200,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::IntVid,\n         val: ty::IntVarValue,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.int_unification_table\n+        self.inner\n             .borrow_mut()\n+            .int_unification_table\n             .unify_var_value(vid, Some(val))\n             .map_err(|e| int_unification_error(vid_is_expected, e))?;\n         match val {\n@@ -212,8 +217,9 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n         vid: ty::FloatVid,\n         val: ast::FloatTy,\n     ) -> RelateResult<'tcx, Ty<'tcx>> {\n-        self.float_unification_table\n+        self.inner\n             .borrow_mut()\n+            .float_unification_table\n             .unify_var_value(vid, Some(ty::FloatVarValue(val)))\n             .map_err(|e| float_unification_error(vid_is_expected, e))?;\n         Ok(self.tcx.mk_mach_float(val))\n@@ -260,7 +266,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         use self::RelationDir::*;\n \n         // Get the actual variable that b_vid has been inferred to\n-        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_unknown());\n+        debug_assert!(self.infcx.inner.borrow_mut().type_variables.probe(b_vid).is_unknown());\n \n         debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n \n@@ -280,7 +286,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             \"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n             a_ty, dir, b_vid, b_ty\n         );\n-        self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n+        self.infcx.inner.borrow_mut().type_variables.instantiate(b_vid, b_ty);\n \n         if needs_wf {\n             self.obligations.push(Obligation::new(\n@@ -338,7 +344,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n \n         debug!(\"generalize: ambient_variance = {:?}\", ambient_variance);\n \n-        let for_universe = match self.infcx.type_variables.borrow_mut().probe(for_vid) {\n+        let for_universe = match self.infcx.inner.borrow_mut().type_variables.probe(for_vid) {\n             v @ TypeVariableValue::Known { .. } => {\n                 panic!(\"instantiating {:?} which has a known value {:?}\", for_vid, v,)\n             }\n@@ -350,7 +356,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n-            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n             for_universe,\n             ambient_variance,\n             needs_wf: false,\n@@ -502,17 +508,16 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n         // us from creating infinitely sized types.\n         match t.kind {\n             ty::Infer(ty::TyVar(vid)) => {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n-                let vid = variables.root_var(vid);\n-                let sub_vid = variables.sub_root_var(vid);\n+                let vid = self.infcx.inner.borrow_mut().type_variables.root_var(vid);\n+                let sub_vid = self.infcx.inner.borrow_mut().type_variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n                     // If sub-roots are equal, then `for_vid` and\n                     // `vid` are related via subtyping.\n                     Err(TypeError::CyclicTy(self.root_ty))\n                 } else {\n-                    match variables.probe(vid) {\n+                    let probe = self.infcx.inner.borrow_mut().type_variables.probe(vid);\n+                    match probe {\n                         TypeVariableValue::Known { value: u } => {\n-                            drop(variables);\n                             debug!(\"generalize: known value {:?}\", u);\n                             self.relate(&u, &u)\n                         }\n@@ -536,8 +541,13 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                                 ty::Covariant | ty::Contravariant => (),\n                             }\n \n-                            let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(self.for_universe, false, origin);\n+                            let origin =\n+                                *self.infcx.inner.borrow_mut().type_variables.var_origin(vid);\n+                            let new_var_id = self.infcx.inner.borrow_mut().type_variables.new_var(\n+                                self.for_universe,\n+                                false,\n+                                origin,\n+                            );\n                             let u = self.tcx().mk_ty_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\", vid, u);\n                             Ok(u)\n@@ -612,7 +622,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n         match c.val {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val {\n                     ConstVariableValue::Known { value: u } => self.relate(&u, &u),"}, {"sha": "018bbe035431e9e4f1cc84d2bff67eee000884b6", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -72,14 +72,14 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n \n         debug!(\"{}.tys: replacements ({:?}, {:?})\", self.tag(), a, b);\n \n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_id)), &ty::Infer(TyVar(b_id))) => {\n-                infcx.type_variables.borrow_mut().equate(a_id, b_id);\n+                infcx.inner.borrow_mut().type_variables.equate(a_id, b_id);\n             }\n \n             (&ty::Infer(TyVar(a_id)), _) => {\n@@ -105,7 +105,12 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n     ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n         let origin = Subtype(box self.fields.trace.clone());\n-        self.fields.infcx.borrow_region_constraints().make_eqregion(origin, a, b);\n+        self.fields\n+            .infcx\n+            .inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .make_eqregion(origin, a, b);\n         Ok(a)\n     }\n "}, {"sha": "0d7fce7eac6c528c834bd180cc654151a067489b", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -47,9 +47,12 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n                 if ty.walk().any(|inner_ty| {\n                     inner_ty == self.target_ty\n                         || match (&inner_ty.kind, &self.target_ty.kind) {\n-                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => {\n-                                self.infcx.type_variables.borrow_mut().sub_unified(a_vid, b_vid)\n-                            }\n+                            (&Infer(TyVar(a_vid)), &Infer(TyVar(b_vid))) => self\n+                                .infcx\n+                                .inner\n+                                .borrow_mut()\n+                                .type_variables\n+                                .sub_unified(a_vid, b_vid),\n                             _ => false,\n                         }\n                 }) {\n@@ -166,7 +169,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         highlight: Option<ty::print::RegionHighlightMode>,\n     ) -> (String, Option<Span>, Cow<'static, str>, Option<String>, Option<&'static str>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.kind {\n-            let ty_vars = self.type_variables.borrow();\n+            let ty_vars = &self.inner.borrow().type_variables;\n             let var_origin = ty_vars.var_origin(ty_vid);\n             if let TypeVariableOriginKind::TypeParameterDefinition(name, def_id) = var_origin.kind {\n                 let parent_def_id = def_id.and_then(|def_id| self.tcx.parent(def_id));\n@@ -224,7 +227,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n-            let ty_vars = self.type_variables.borrow();\n+            let ty_vars = &self.inner.borrow().type_variables;\n             let getter = move |ty_vid| {\n                 let var_origin = ty_vars.var_origin(ty_vid);\n                 if let TypeVariableOriginKind::TypeParameterDefinition(name, _) = var_origin.kind {"}, {"sha": "0190989267bb459e9d8819b8747b09eb9f2c7894", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -154,14 +154,15 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n         match t.kind {\n             ty::Infer(ty::TyVar(v)) => {\n-                let opt_ty = self.infcx.type_variables.borrow_mut().probe(v).known();\n+                let opt_ty = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n                 self.freshen_ty(opt_ty, ty::TyVar(v), ty::FreshTy)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self.freshen_ty(\n                 self.infcx\n-                    .int_unification_table\n+                    .inner\n                     .borrow_mut()\n+                    .int_unification_table\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::IntVar(v),\n@@ -170,8 +171,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n             ty::Infer(ty::FloatVar(v)) => self.freshen_ty(\n                 self.infcx\n-                    .float_unification_table\n+                    .inner\n                     .borrow_mut()\n+                    .float_unification_table\n                     .probe_value(v)\n                     .map(|v| v.to_type(tcx)),\n                 ty::FloatVar(v),\n@@ -225,8 +227,14 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match ct.val {\n             ty::ConstKind::Infer(ty::InferConst::Var(v)) => {\n-                let opt_ct =\n-                    self.infcx.const_unification_table.borrow_mut().probe_value(v).val.known();\n+                let opt_ct = self\n+                    .infcx\n+                    .inner\n+                    .borrow_mut()\n+                    .const_unification_table\n+                    .probe_value(v)\n+                    .val\n+                    .known();\n                 return self.freshen_const(\n                     opt_ct,\n                     ty::InferConst::Var(v),"}, {"sha": "d0b7bb32b9815cdd46806a4c94a12729db86f39a", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -8,11 +8,10 @@ use super::{ConstVariableOrigin, RegionVariableOrigin};\n use rustc_data_structures::unify as ut;\n use ut::UnifyKey;\n \n-use std::cell::RefMut;\n use std::ops::Range;\n \n fn const_vars_since_snapshot<'tcx>(\n-    mut table: RefMut<'_, ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>>,\n+    table: &mut ut::UnificationTable<ut::InPlace<ConstVid<'tcx>>>,\n     snapshot: &ut::Snapshot<ut::InPlace<ConstVid<'tcx>>>,\n ) -> (Range<ConstVid<'tcx>>, Vec<ConstVariableOrigin>) {\n     let range = table.vars_since_snapshot(snapshot);\n@@ -82,23 +81,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     // going to be popped, so we will have to\n                     // eliminate any references to them.\n \n-                    let type_vars = self\n-                        .type_variables\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.type_snapshot);\n-                    let int_vars = self\n-                        .int_unification_table\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.int_snapshot);\n-                    let float_vars = self\n-                        .float_unification_table\n-                        .borrow_mut()\n-                        .vars_since_snapshot(&snapshot.float_snapshot);\n-                    let region_vars = self\n-                        .borrow_region_constraints()\n+                    let mut inner = self.inner.borrow_mut();\n+                    let type_vars =\n+                        inner.type_variables.vars_since_snapshot(&snapshot.type_snapshot);\n+                    let int_vars =\n+                        inner.int_unification_table.vars_since_snapshot(&snapshot.int_snapshot);\n+                    let float_vars =\n+                        inner.float_unification_table.vars_since_snapshot(&snapshot.float_snapshot);\n+                    let region_vars = inner\n+                        .unwrap_region_constraints()\n                         .vars_since_snapshot(&snapshot.region_constraints_snapshot);\n                     let const_vars = const_vars_since_snapshot(\n-                        self.const_unification_table.borrow_mut(),\n+                        &mut inner.const_unification_table,\n                         &snapshot.const_snapshot,\n                     );\n \n@@ -166,7 +160,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for InferenceFudger<'a, 'tcx> {\n                     // variables to their binding anyhow, we know\n                     // that it is unbound, so we can just return\n                     // it.\n-                    debug_assert!(self.infcx.type_variables.borrow_mut().probe(vid).is_unknown());\n+                    debug_assert!(\n+                        self.infcx.inner.borrow_mut().type_variables.probe(vid).is_unknown()\n+                    );\n                     ty\n                 }\n             }"}, {"sha": "6ef92132bc7034f19b0b9ce06d422ff41ebe5170", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -66,7 +66,12 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(box self.fields.trace.clone());\n-        Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().glb_regions(\n+            self.tcx(),\n+            origin,\n+            a,\n+            b,\n+        ))\n     }\n \n     fn consts("}, {"sha": "1b0f399ca33927058263aea7fbada44bb57f2e69", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             return Ok(());\n         }\n \n-        self.borrow_region_constraints().leak_check(\n+        self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n             overly_polymorphic,\n             placeholder_map,"}, {"sha": "df475af1151aaea7abd54da33a63879197ebe1fd", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -56,8 +56,8 @@ where\n     }\n \n     let infcx = this.infcx();\n-    let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-    let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+    let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+    let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n     match (&a.kind, &b.kind) {\n         // If one side is known to be a variable and one is not,\n         // create a variable (`v`) to represent the LUB. Make sure to"}, {"sha": "6a699f803c7b84124084d5edc723694f99688fd3", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -66,7 +66,12 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         debug!(\"{}.regions({:?}, {:?})\", self.tag(), a, b);\n \n         let origin = Subtype(box self.fields.trace.clone());\n-        Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n+        Ok(self.fields.infcx.inner.borrow_mut().unwrap_region_constraints().lub_regions(\n+            self.tcx(),\n+            origin,\n+            a,\n+            b,\n+        ))\n     }\n \n     fn consts("}, {"sha": "be58de996a5dec2cb21626592728798ba1fdbdc8", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 181, "deletions": 155, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -29,7 +29,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n-use std::cell::{Cell, Ref, RefCell, RefMut};\n+use std::cell::{Cell, Ref, RefCell};\n use std::collections::BTreeMap;\n use std::fmt;\n use syntax::ast;\n@@ -105,6 +105,89 @@ impl SuppressRegionErrors {\n     }\n }\n \n+/// This type contains all the things within `InferCtxt` that sit within a\n+/// `RefCell` and are involved with taking/rolling back snapshots. Snapshot\n+/// operations are hot enough that we want only one call to `borrow_mut` per\n+/// call to `start_snapshot` and `rollback_to`.\n+pub struct InferCtxtInner<'tcx> {\n+    /// Cache for projections. This cache is snapshotted along with the infcx.\n+    ///\n+    /// Public so that `traits::project` can use it.\n+    pub projection_cache: traits::ProjectionCache<'tcx>,\n+\n+    /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n+    /// that might instantiate a general type variable have an order,\n+    /// represented by its upper and lower bounds.\n+    type_variables: type_variable::TypeVariableTable<'tcx>,\n+\n+    /// Map from const parameter variable to the kind of const it represents.\n+    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+\n+    /// Map from integral variable to the kind of integer it represents.\n+    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n+\n+    /// Map from floating variable to the kind of float it represents.\n+    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n+\n+    /// Tracks the set of region variables and the constraints between them.\n+    /// This is initially `Some(_)` but when\n+    /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n+    /// -- further attempts to perform unification, etc., may fail if new\n+    /// region constraints would've been added.\n+    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n+\n+    /// A set of constraints that regionck must validate. Each\n+    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// outlive the lifetime 'a\". These constraints derive from\n+    /// instantiated type parameters. So if you had a struct defined\n+    /// like\n+    ///\n+    ///     struct Foo<T:'static> { ... }\n+    ///\n+    /// then in some expression `let x = Foo { ... }` it will\n+    /// instantiate the type parameter `T` with a fresh type `$0`. At\n+    /// the same time, it will record a region obligation of\n+    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// can't generally check these things right away because we have\n+    /// to wait until types are resolved.)\n+    ///\n+    /// These are stored in a map keyed to the id of the innermost\n+    /// enclosing fn body / static initializer expression. This is\n+    /// because the location where the obligation was incurred can be\n+    /// relevant with respect to which sublifetime assumptions are in\n+    /// place. The reason that we store under the fn-id, and not\n+    /// something more fine-grained, is so that it is easier for\n+    /// regionck to be sure that it has found *all* the region\n+    /// obligations (otherwise, it's easy to fail to walk to a\n+    /// particular node-id).\n+    ///\n+    /// Before running `resolve_regions_and_report_errors`, the creator\n+    /// of the inference context is expected to invoke\n+    /// `process_region_obligations` (defined in `self::region_obligations`)\n+    /// for each body-id in this map, which will process the\n+    /// obligations within. This is expected to be done 'late enough'\n+    /// that all type inference variables have been bound and so forth.\n+    pub region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+}\n+\n+impl<'tcx> InferCtxtInner<'tcx> {\n+    fn new() -> InferCtxtInner<'tcx> {\n+        InferCtxtInner {\n+            projection_cache: Default::default(),\n+            type_variables: type_variable::TypeVariableTable::new(),\n+            const_unification_table: ut::UnificationTable::new(),\n+            int_unification_table: ut::UnificationTable::new(),\n+            float_unification_table: ut::UnificationTable::new(),\n+            region_constraints: Some(RegionConstraintCollector::new()),\n+            region_obligations: vec![],\n+        }\n+    }\n+\n+    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n+        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n+    }\n+}\n+\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -114,16 +197,7 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// and for error reporting logic to read arbitrary node types.\n     pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n \n-    /// Cache for projections. This cache is snapshotted along with the\n-    /// infcx.\n-    ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: RefCell<traits::ProjectionCache<'tcx>>,\n-\n-    /// We instantiate `UnificationTable` with `bounds<Ty>` because the\n-    /// types that might instantiate a general type variable have an\n-    /// order, represented by its upper and lower bounds.\n-    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n+    pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n     /// If set, this flag causes us to skip the 'leak check' during\n     /// higher-ranked subtyping operations. This flag is a temporary one used\n@@ -132,22 +206,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// when entering a snapshot.\n     skip_leak_check: Cell<bool>,\n \n-    /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>>,\n-\n-    /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::IntVid>>>,\n-\n-    /// Map from floating variable to the kind of float it represents\n-    float_unification_table: RefCell<ut::UnificationTable<ut::InPlace<ty::FloatVid>>>,\n-\n-    /// Tracks the set of region variables and the constraints between\n-    /// them.  This is initially `Some(_)` but when\n-    /// `resolve_regions_and_report_errors` is invoked, this gets set\n-    /// to `None` -- further attempts to perform unification etc may\n-    /// fail if new region constraints would've been added.\n-    region_constraints: RefCell<Option<RegionConstraintCollector<'tcx>>>,\n-\n     /// Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n \n@@ -189,39 +247,6 @@ pub struct InferCtxt<'a, 'tcx> {\n     /// This flag is true while there is an active snapshot.\n     in_snapshot: Cell<bool>,\n \n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n-    /// outlive the lifetime 'a\". These constraints derive from\n-    /// instantiated type parameters. So if you had a struct defined\n-    /// like\n-    ///\n-    ///     struct Foo<T:'static> { ... }\n-    ///\n-    /// then in some expression `let x = Foo { ... }` it will\n-    /// instantiate the type parameter `T` with a fresh type `$0`. At\n-    /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n-    /// can't generally check these things right away because we have\n-    /// to wait until types are resolved.)\n-    ///\n-    /// These are stored in a map keyed to the id of the innermost\n-    /// enclosing fn body / static initializer expression. This is\n-    /// because the location where the obligation was incurred can be\n-    /// relevant with respect to which sublifetime assumptions are in\n-    /// place. The reason that we store under the fn-id, and not\n-    /// something more fine-grained, is so that it is easier for\n-    /// regionck to be sure that it has found *all* the region\n-    /// obligations (otherwise, it's easy to fail to walk to a\n-    /// particular node-id).\n-    ///\n-    /// Before running `resolve_regions_and_report_errors`, the creator\n-    /// of the inference context is expected to invoke\n-    /// `process_region_obligations` (defined in `self::region_obligations`)\n-    /// for each body-id in this map, which will process the\n-    /// obligations within. This is expected to be done 'late enough'\n-    /// that all type inference variables have been bound and so forth.\n-    pub region_obligations: RefCell<Vec<(hir::HirId, RegionObligation<'tcx>)>>,\n-\n     /// What is the innermost universe we have created? Starts out as\n     /// `UniverseIndex::root()` but grows from there as we enter\n     /// universal quantifiers.\n@@ -543,12 +568,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             f(InferCtxt {\n                 tcx,\n                 in_progress_tables,\n-                projection_cache: Default::default(),\n-                type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-                const_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                int_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                float_unification_table: RefCell::new(ut::UnificationTable::new()),\n-                region_constraints: RefCell::new(Some(RegionConstraintCollector::new())),\n+                inner: RefCell::new(InferCtxtInner::new()),\n                 lexical_region_resolutions: RefCell::new(None),\n                 selection_cache: Default::default(),\n                 evaluation_cache: Default::default(),\n@@ -558,7 +578,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n                 err_count_on_creation: tcx.sess.err_count(),\n                 in_snapshot: Cell::new(false),\n                 skip_leak_check: Cell::new(false),\n-                region_obligations: RefCell::new(vec![]),\n                 universe: Cell::new(ty::UniverseIndex::ROOT),\n             })\n         })\n@@ -616,7 +635,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n         match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.type_variables.borrow().var_diverges(vid),\n+            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n             _ => false,\n         }\n     }\n@@ -630,14 +649,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n         match ty.kind {\n             ty::Infer(ty::IntVar(vid)) => {\n-                if self.int_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedInt\n                 }\n             }\n             ty::Infer(ty::FloatVar(vid)) => {\n-                if self.float_unification_table.borrow_mut().probe_value(vid).is_some() {\n+                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n                     Neither\n                 } else {\n                     UnconstrainedFloat\n@@ -648,28 +667,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n-        let mut type_variables = self.type_variables.borrow_mut();\n-        let mut int_unification_table = self.int_unification_table.borrow_mut();\n-        let mut float_unification_table = self.float_unification_table.borrow_mut();\n+        let mut inner = self.inner.borrow_mut();\n         // FIXME(const_generics): should there be an equivalent function for const variables?\n \n-        type_variables\n+        let mut vars: Vec<Ty<'_>> = inner\n+            .type_variables\n             .unsolved_variables()\n             .into_iter()\n             .map(|t| self.tcx.mk_ty_var(t))\n-            .chain(\n-                (0..int_unification_table.len())\n-                    .map(|i| ty::IntVid { index: i as u32 })\n-                    .filter(|&vid| int_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_int_var(v)),\n-            )\n-            .chain(\n-                (0..float_unification_table.len())\n-                    .map(|i| ty::FloatVid { index: i as u32 })\n-                    .filter(|&vid| float_unification_table.probe_value(vid).is_none())\n-                    .map(|v| self.tcx.mk_float_var(v)),\n-            )\n-            .collect()\n+            .collect();\n+        vars.extend(\n+            (0..inner.int_unification_table.len())\n+                .map(|i| ty::IntVid { index: i as u32 })\n+                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_int_var(v)),\n+        );\n+        vars.extend(\n+            (0..inner.float_unification_table.len())\n+                .map(|i| ty::FloatVid { index: i as u32 })\n+                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_float_var(v)),\n+        );\n+        vars\n     }\n \n     fn combine_fields(\n@@ -719,14 +738,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let in_snapshot = self.in_snapshot.get();\n         self.in_snapshot.set(true);\n \n+        let mut inner = self.inner.borrow_mut();\n         CombinedSnapshot {\n-            projection_cache_snapshot: self.projection_cache.borrow_mut().snapshot(),\n-            type_snapshot: self.type_variables.borrow_mut().snapshot(),\n-            const_snapshot: self.const_unification_table.borrow_mut().snapshot(),\n-            int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n-            float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n-            region_constraints_snapshot: self.borrow_region_constraints().start_snapshot(),\n-            region_obligations_snapshot: self.region_obligations.borrow().len(),\n+            projection_cache_snapshot: inner.projection_cache.snapshot(),\n+            type_snapshot: inner.type_variables.snapshot(),\n+            const_snapshot: inner.const_unification_table.snapshot(),\n+            int_snapshot: inner.int_unification_table.snapshot(),\n+            float_snapshot: inner.float_unification_table.snapshot(),\n+            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n+            region_obligations_snapshot: inner.region_obligations.len(),\n             universe: self.universe(),\n             was_in_snapshot: in_snapshot,\n             was_skip_leak_check: self.skip_leak_check.get(),\n@@ -756,13 +776,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.universe.set(universe);\n         self.skip_leak_check.set(was_skip_leak_check);\n \n-        self.projection_cache.borrow_mut().rollback_to(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().rollback_to(type_snapshot);\n-        self.const_unification_table.borrow_mut().rollback_to(const_snapshot);\n-        self.int_unification_table.borrow_mut().rollback_to(int_snapshot);\n-        self.float_unification_table.borrow_mut().rollback_to(float_snapshot);\n-        self.region_obligations.borrow_mut().truncate(region_obligations_snapshot);\n-        self.borrow_region_constraints().rollback_to(region_constraints_snapshot);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.rollback_to(projection_cache_snapshot);\n+        inner.type_variables.rollback_to(type_snapshot);\n+        inner.const_unification_table.rollback_to(const_snapshot);\n+        inner.int_unification_table.rollback_to(int_snapshot);\n+        inner.float_unification_table.rollback_to(float_snapshot);\n+        inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n+        inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n@@ -784,12 +805,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.in_snapshot.set(was_in_snapshot);\n         self.skip_leak_check.set(was_skip_leak_check);\n \n-        self.projection_cache.borrow_mut().commit(projection_cache_snapshot);\n-        self.type_variables.borrow_mut().commit(type_snapshot);\n-        self.const_unification_table.borrow_mut().commit(const_snapshot);\n-        self.int_unification_table.borrow_mut().commit(int_snapshot);\n-        self.float_unification_table.borrow_mut().commit(float_snapshot);\n-        self.borrow_region_constraints().commit(region_constraints_snapshot);\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.commit(projection_cache_snapshot);\n+        inner.type_variables.commit(type_snapshot);\n+        inner.const_unification_table.commit(const_snapshot);\n+        inner.int_unification_table.commit(int_snapshot);\n+        inner.float_unification_table.commit(float_snapshot);\n+        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -859,12 +881,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         snapshot: &CombinedSnapshot<'a, 'tcx>,\n     ) -> Option<bool> {\n-        self.borrow_region_constraints()\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n             .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n     }\n \n     pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.borrow_region_constraints().add_given(sub, sup);\n+        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n     }\n \n     pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n@@ -900,7 +924,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         b: ty::Region<'tcx>,\n     ) {\n         debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);\n     }\n \n     /// Require that the region `r` be equal to one of the regions in\n@@ -914,7 +938,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n     ) {\n         debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n-        self.borrow_region_constraints().member_constraint(\n+        self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n             opaque_type_def_id,\n             definition_span,\n             hidden_ty,\n@@ -978,7 +1002,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.type_variables.borrow_mut().new_var(self.universe(), diverging, origin)\n+        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n     }\n \n     pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n@@ -990,7 +1014,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: TypeVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> Ty<'tcx> {\n-        let vid = self.type_variables.borrow_mut().new_var(universe, false, origin);\n+        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n         self.tcx.mk_ty_var(vid)\n     }\n \n@@ -1013,29 +1037,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         universe: ty::UniverseIndex,\n     ) -> &'tcx ty::Const<'tcx> {\n         let vid = self\n-            .const_unification_table\n+            .inner\n             .borrow_mut()\n+            .const_unification_table\n             .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n         self.tcx.mk_const_var(vid, ty)\n     }\n \n     pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n+        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n             origin,\n             val: ConstVariableValue::Unknown { universe: self.universe() },\n         })\n     }\n \n     fn next_int_var_id(&self) -> IntVid {\n-        self.int_unification_table.borrow_mut().new_key(None)\n+        self.inner.borrow_mut().int_unification_table.new_key(None)\n     }\n \n     pub fn next_int_var(&self) -> Ty<'tcx> {\n         self.tcx.mk_int_var(self.next_int_var_id())\n     }\n \n     fn next_float_var_id(&self) -> FloatVid {\n-        self.float_unification_table.borrow_mut().new_key(None)\n+        self.inner.borrow_mut().float_unification_table.new_key(None)\n     }\n \n     pub fn next_float_var(&self) -> Ty<'tcx> {\n@@ -1057,7 +1082,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         origin: RegionVariableOrigin,\n         universe: ty::UniverseIndex,\n     ) -> ty::Region<'tcx> {\n-        let region_var = self.borrow_region_constraints().new_region_var(universe, origin);\n+        let region_var =\n+            self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n@@ -1067,12 +1093,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// placeholders, however, it will return the universe which which\n     /// they are associated.\n     fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n-        self.borrow_region_constraints().universe(r)\n+        self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n     }\n \n     /// Number of region variables created so far.\n     pub fn num_region_vars(&self) -> usize {\n-        self.borrow_region_constraints().num_region_vars()\n+        self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n@@ -1105,7 +1131,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 // used in a path such as `Foo::<T, U>::new()` will\n                 // use an inference variable for `C` with `[T, U]`\n                 // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.type_variables.borrow_mut().new_var(\n+                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n                     self.universe(),\n                     false,\n                     TypeVariableOrigin {\n@@ -1125,7 +1151,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     span,\n                 };\n                 let const_var_id =\n-                    self.const_unification_table.borrow_mut().new_key(ConstVarValue {\n+                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n                         origin,\n                         val: ConstVariableValue::Unknown { universe: self.universe() },\n                     });\n@@ -1179,9 +1205,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         suppress: SuppressRegionErrors,\n     ) {\n         assert!(\n-            self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n+            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n+            self.inner.borrow().region_obligations\n         );\n \n         let region_rels = &RegionRelations::new(\n@@ -1191,8 +1217,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             outlives_env.free_region_map(),\n         );\n         let (var_infos, data) = self\n-            .region_constraints\n+            .inner\n             .borrow_mut()\n+            .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n@@ -1224,12 +1251,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// understands. See the NLL module for mode details.\n     pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n         assert!(\n-            self.region_obligations.borrow().is_empty(),\n+            self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n-            self.region_obligations.borrow()\n+            self.inner.borrow().region_obligations\n         );\n \n-        self.borrow_region_constraints().take_and_reset_data()\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n     }\n \n     /// Gives temporary access to the region constraint data.\n@@ -1238,8 +1265,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n     ) -> R {\n-        let region_constraints = self.borrow_region_constraints();\n-        op(region_constraints.data())\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n     }\n \n     /// Takes ownership of the list of variable regions. This implies\n@@ -1249,8 +1276,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// of the set of region variables into the NLL region context.\n     pub fn take_region_var_origins(&self) -> VarInfos {\n         let (var_infos, data) = self\n-            .region_constraints\n+            .inner\n             .borrow_mut()\n+            .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n@@ -1276,7 +1304,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n         use self::type_variable::TypeVariableValue;\n \n-        match self.type_variables.borrow_mut().probe(vid) {\n+        match self.inner.borrow_mut().type_variables.probe(vid) {\n             TypeVariableValue::Known { value } => Ok(value),\n             TypeVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1299,7 +1327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.type_variables.borrow_mut().root_var(var)\n+        self.inner.borrow_mut().type_variables.root_var(var)\n     }\n \n     /// Where possible, replaces type/const variables in\n@@ -1337,7 +1365,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         vid: ty::ConstVid<'tcx>,\n     ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.const_unification_table.borrow_mut().probe_value(vid).val {\n+        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n             ConstVariableValue::Known { value } => Ok(value),\n             ConstVariableValue::Unknown { universe } => Err(universe),\n         }\n@@ -1434,7 +1462,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n \n-        self.borrow_region_constraints().verify_generic_bound(origin, kind, a, bound);\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n     }\n \n     pub fn type_is_copy_modulo_regions(\n@@ -1509,19 +1540,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         InferOk { value, obligations }\n     }\n \n-    pub fn borrow_region_constraints(&self) -> RefMut<'_, RegionConstraintCollector<'tcx>> {\n-        RefMut::map(self.region_constraints.borrow_mut(), |c| {\n-            c.as_mut().expect(\"region constraints already solved\")\n-        })\n-    }\n-\n     /// Clears the selection, evaluation, and projection caches. This is useful when\n     /// repeatedly attempting to select an `Obligation` while changing only\n     /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n-        self.projection_cache.borrow_mut().clear();\n+        self.inner.borrow_mut().projection_cache.clear();\n     }\n \n     fn universe(&self) -> ty::UniverseIndex {\n@@ -1562,27 +1587,27 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // structurally), and we prevent cycles in any case,\n                 // so this recursion should always be of very limited\n                 // depth.\n-                self.infcx\n-                    .type_variables\n-                    .borrow_mut()\n-                    .probe(v)\n-                    .known()\n-                    .map(|t| self.fold_ty(t))\n-                    .unwrap_or(typ)\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.infcx.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n             }\n \n             ty::Infer(ty::IntVar(v)) => self\n                 .infcx\n-                .int_unification_table\n+                .inner\n                 .borrow_mut()\n+                .int_unification_table\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.infcx.tcx))\n                 .unwrap_or(typ),\n \n             ty::Infer(ty::FloatVar(v)) => self\n                 .infcx\n-                .float_unification_table\n+                .inner\n                 .borrow_mut()\n+                .float_unification_table\n                 .probe_value(v)\n                 .map(|v| v.to_type(self.infcx.tcx))\n                 .unwrap_or(typ),\n@@ -1603,7 +1628,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n \n                 // If `inlined_probe` returns a `Known` value its `kind` never\n                 // matches `infer`.\n-                match self.infcx.type_variables.borrow_mut().inlined_probe(v) {\n+                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n                     TypeVariableValue::Unknown { .. } => false,\n                     TypeVariableValue::Known { .. } => true,\n                 }\n@@ -1613,15 +1638,15 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n                 // If inlined_probe_value returns a value it's always a\n                 // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n                 // `ty::Infer(_)`.\n-                self.infcx.int_unification_table.borrow_mut().inlined_probe_value(v).is_some()\n+                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n             }\n \n             ty::FloatVar(v) => {\n                 // If inlined_probe_value returns a value it's always a\n                 // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n                 //\n                 // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.float_unification_table.borrow_mut().probe_value(v).is_some()\n+                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n             }\n \n             _ => unreachable!(),\n@@ -1641,8 +1666,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n             self.infcx\n-                .const_unification_table\n+                .inner\n                 .borrow_mut()\n+                .const_unification_table\n                 .probe_value(*vid)\n                 .val\n                 .known()"}, {"sha": "77e20e6ad8ff2c4cc1ebae0077bd640f056fc616", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -322,7 +322,7 @@ where\n         match value_ty.kind {\n             ty::Infer(ty::TyVar(value_vid)) => {\n                 // Two type variables: just equate them.\n-                self.infcx.type_variables.borrow_mut().equate(vid, value_vid);\n+                self.infcx.inner.borrow_mut().type_variables.equate(vid, value_vid);\n                 return Ok(value_ty);\n             }\n \n@@ -343,7 +343,7 @@ where\n             assert!(!generalized_ty.has_infer_types());\n         }\n \n-        self.infcx.type_variables.borrow_mut().instantiate(vid, generalized_ty);\n+        self.infcx.inner.borrow_mut().type_variables.instantiate(vid, generalized_ty);\n \n         // The generalized values we extract from `canonical_var_values` have\n         // been fully instantiated and hence the set of scopes we have\n@@ -373,7 +373,7 @@ where\n             delegate: &mut self.delegate,\n             first_free_index: ty::INNERMOST,\n             ambient_variance: self.ambient_variance,\n-            for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n+            for_vid_sub_root: self.infcx.inner.borrow_mut().type_variables.sub_root_var(for_vid),\n             universe,\n         };\n \n@@ -870,7 +870,7 @@ where\n             }\n \n             ty::Infer(ty::TyVar(vid)) => {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n+                let variables = &mut self.infcx.inner.borrow_mut().type_variables;\n                 let vid = variables.root_var(vid);\n                 let sub_vid = variables.sub_root_var(vid);\n                 if sub_vid == self.for_vid_sub_root {\n@@ -972,7 +972,7 @@ where\n                 bug!(\"unexpected inference variable encountered in NLL generalization: {:?}\", a);\n             }\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {\n-                let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n+                let variable_table = &mut self.infcx.inner.borrow_mut().const_unification_table;\n                 let var_value = variable_table.probe_value(vid);\n                 match var_value.val.known() {\n                     Some(u) => self.relate(&u, &u),"}, {"sha": "17153ef97241b24da281f7cbc525392590c48971", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -82,7 +82,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ) {\n         debug!(\"register_region_obligation(body_id={:?}, obligation={:?})\", body_id, obligation);\n \n-        self.region_obligations.borrow_mut().push((body_id, obligation));\n+        self.inner.borrow_mut().region_obligations.push((body_id, obligation));\n     }\n \n     pub fn register_region_obligation_with_cause(\n@@ -103,7 +103,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     /// Trait queries just want to pass back type obligations \"as is\"\n     pub fn take_registered_region_obligations(&self) -> Vec<(hir::HirId, RegionObligation<'tcx>)> {\n-        ::std::mem::take(&mut *self.region_obligations.borrow_mut())\n+        ::std::mem::take(&mut self.inner.borrow_mut().region_obligations)\n     }\n \n     /// Process the region obligations that must be proven (during"}, {"sha": "c9acd1cf4a1b319ed40434207b35c6ae0487c581", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -75,9 +75,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for OpportunisticTypeAndRegionResolver<'a, 'tcx>\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReVar(rid) => {\n-                self.infcx.borrow_region_constraints().opportunistic_resolve_var(self.tcx(), rid)\n-            }\n+            ty::ReVar(rid) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .opportunistic_resolve_var(self.tcx(), rid),\n             _ => r,\n         }\n     }\n@@ -120,7 +123,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n                 // Since we called `shallow_resolve` above, this must\n                 // be an (as yet...) unresolved inference variable.\n                 let ty_var_span = if let ty::TyVar(ty_vid) = infer_ty {\n-                    let ty_vars = self.infcx.type_variables.borrow();\n+                    let ty_vars = &self.infcx.inner.borrow().type_variables;\n                     if let TypeVariableOrigin {\n                         kind: TypeVariableOriginKind::TypeParameterDefinition(_, _),\n                         span,"}, {"sha": "ef4903358d5c96ca7fd44f4bb8edeb7d8701de67", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -80,8 +80,8 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         }\n \n         let infcx = self.fields.infcx;\n-        let a = infcx.type_variables.borrow_mut().replace_if_possible(a);\n-        let b = infcx.type_variables.borrow_mut().replace_if_possible(b);\n+        let a = infcx.inner.borrow_mut().type_variables.replace_if_possible(a);\n+        let b = infcx.inner.borrow_mut().type_variables.replace_if_possible(b);\n         match (&a.kind, &b.kind) {\n             (&ty::Infer(TyVar(a_vid)), &ty::Infer(TyVar(b_vid))) => {\n                 // Shouldn't have any LBR here, so we can safely put\n@@ -95,7 +95,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 // have to record in the `type_variables` tracker that\n                 // the two variables are equal modulo subtyping, which\n                 // is important to the occurs check later on.\n-                infcx.type_variables.borrow_mut().sub(a_vid, b_vid);\n+                infcx.inner.borrow_mut().type_variables.sub(a_vid, b_vid);\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n@@ -140,7 +140,12 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n         let origin = SubregionOrigin::Subtype(box self.fields.trace.clone());\n-        self.fields.infcx.borrow_region_constraints().make_subregion(origin, a, b);\n+        self.fields\n+            .infcx\n+            .inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .make_subregion(origin, a, b);\n \n         Ok(a)\n     }"}, {"sha": "e205453a48c535176a9cec03853151f2c41d9127", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::unify::{EqUnifyValue, NoError, UnificationTable, Unif\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n-use std::cell::RefMut;\n use std::cmp;\n use std::marker::PhantomData;\n \n@@ -214,7 +213,7 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n \n pub fn replace_if_possible(\n-    mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n+    table: &mut UnificationTable<InPlace<ty::ConstVid<'tcx>>>,\n     c: &'tcx ty::Const<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = c {"}, {"sha": "1255728de37b14958bb12f1c074b7ca22b9fe2e5", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -199,12 +199,22 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 panic!(\"Unable to fulfill trait {:?} for '{:?}': {:?}\", trait_did, ty, e)\n             });\n \n-            let body_id_map: FxHashMap<_, _> =\n-                infcx.region_obligations.borrow().iter().map(|&(id, _)| (id, vec![])).collect();\n+            let body_id_map: FxHashMap<_, _> = infcx\n+                .inner\n+                .borrow()\n+                .region_obligations\n+                .iter()\n+                .map(|&(id, _)| (id, vec![]))\n+                .collect();\n \n             infcx.process_registered_region_obligations(&body_id_map, None, full_env);\n \n-            let region_data = infcx.borrow_region_constraints().region_constraint_data().clone();\n+            let region_data = infcx\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n+                .region_constraint_data()\n+                .clone();\n \n             let vid_to_region = self.map_vid_to_region(&region_data);\n "}, {"sha": "6c058455b98bdddaef0506903efea512e10159fd", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -454,7 +454,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n     // bounds. It might be the case that we want two distinct caches,\n     // or else another kind of cache entry.\n \n-    let cache_result = infcx.projection_cache.borrow_mut().try_start(cache_key);\n+    let cache_result = infcx.inner.borrow_mut().projection_cache.try_start(cache_key);\n     match cache_result {\n         Ok(()) => {}\n         Err(ProjectionCacheEntry::Ambiguous) => {\n@@ -528,7 +528,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Once we have inferred everything we need to know, we\n             // can ignore the `obligations` from that point on.\n             if infcx.unresolved_type_vars(&ty.value).is_none() {\n-                infcx.projection_cache.borrow_mut().complete_normalized(cache_key, &ty);\n+                infcx.inner.borrow_mut().projection_cache.complete_normalized(cache_key, &ty);\n             // No need to extend `obligations`.\n             } else {\n                 obligations.extend(ty.obligations);\n@@ -590,7 +590,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             };\n \n             let cache_value = prune_cache_value_obligations(infcx, &result);\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, cache_value);\n+            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, cache_value);\n             obligations.extend(result.obligations);\n             Some(result.value)\n         }\n@@ -601,7 +601,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 projected_ty\n             );\n             let result = Normalized { value: projected_ty, obligations: vec![] };\n-            infcx.projection_cache.borrow_mut().insert_ty(cache_key, result.clone());\n+            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, result.clone());\n             // No need to extend `obligations`.\n             Some(result.value)\n         }\n@@ -610,7 +610,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n                 \"opt_normalize_projection_type: \\\n                     too many candidates\"\n             );\n-            infcx.projection_cache.borrow_mut().ambiguous(cache_key);\n+            infcx.inner.borrow_mut().projection_cache.ambiguous(cache_key);\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n@@ -620,7 +620,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n             // Trait`, which when processed will cause the error to be\n             // reported later\n \n-            infcx.projection_cache.borrow_mut().error(cache_key);\n+            infcx.inner.borrow_mut().projection_cache.error(cache_key);\n             let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n             obligations.extend(result.obligations);\n             Some(result.value)"}, {"sha": "c56cde4f4ce44955ad245d2f63f92c218407efb9", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -511,7 +511,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some(key) =\n                             ProjectionCacheKey::from_poly_projection_predicate(self, data)\n                         {\n-                            self.infcx.projection_cache.borrow_mut().complete(key);\n+                            self.infcx.inner.borrow_mut().projection_cache.complete(key);\n                         }\n                         result\n                     }"}, {"sha": "dc6018e80ea7eb9ec002108b21b4b962ac57414c", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7426853ba255940b880f2e7f8026d60b94b42404/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=7426853ba255940b880f2e7f8026d60b94b42404", "patch": "@@ -226,7 +226,9 @@ impl TypeRelation<'tcx> for AnswerSubstitutor<'cx, 'tcx> {\n         let b = match b {\n             &ty::ReVar(vid) => self\n                 .infcx\n-                .borrow_region_constraints()\n+                .inner\n+                .borrow_mut()\n+                .unwrap_region_constraints()\n                 .opportunistic_resolve_var(self.infcx.tcx, vid),\n \n             other => other,"}]}