{"sha": "f629baf96cd0dd741f4490e782a72b2ff40b27fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MjliYWY5NmNkMGRkNzQxZjQ0OTBlNzgyYTcyYjJmZjQwYjI3ZmQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T22:43:45Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T17:14:32Z"}, "message": "Move magic traits queries to rustc::traits::drop.", "tree": {"sha": "95b1f8c21b80f0306aa4c3d3eae6db6fb71aee1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95b1f8c21b80f0306aa4c3d3eae6db6fb71aee1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f629baf96cd0dd741f4490e782a72b2ff40b27fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f629baf96cd0dd741f4490e782a72b2ff40b27fd", "html_url": "https://github.com/rust-lang/rust/commit/f629baf96cd0dd741f4490e782a72b2ff40b27fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f629baf96cd0dd741f4490e782a72b2ff40b27fd/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "html_url": "https://github.com/rust-lang/rust/commit/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f"}], "stats": {"total": 414, "additions": 211, "deletions": 203}, "files": [{"sha": "08c3a77bf3aca5ff78fd5654d97770d3d68848c9", "filename": "src/librustc/traits/drop.rs", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Ftraits%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Ftraits%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fdrop.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -0,0 +1,202 @@\n+//! Miscellaneous type-system utilities that are too small to deserve their own modules.\n+\n+use crate::middle::lang_items;\n+use crate::traits::{self, ObligationCause};\n+use crate::ty::util::NeedsDrop;\n+use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+\n+use rustc_hir as hir;\n+use rustc_span::DUMMY_SP;\n+\n+#[derive(Clone)]\n+pub enum CopyImplementationError<'tcx> {\n+    InfrigingFields(Vec<&'tcx ty::FieldDef>),\n+    NotAnAdt,\n+    HasDestructor,\n+}\n+\n+pub fn can_type_implement_copy(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    self_type: Ty<'tcx>,\n+) -> Result<(), CopyImplementationError<'tcx>> {\n+    // FIXME: (@jroesch) float this code up\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let (adt, substs) = match self_type.kind {\n+            // These types used to have a builtin impl.\n+            // Now libcore provides that impl.\n+            ty::Uint(_)\n+            | ty::Int(_)\n+            | ty::Bool\n+            | ty::Float(_)\n+            | ty::Char\n+            | ty::RawPtr(..)\n+            | ty::Never\n+            | ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n+\n+            ty::Adt(adt, substs) => (adt, substs),\n+\n+            _ => return Err(CopyImplementationError::NotAnAdt),\n+        };\n+\n+        let mut infringing = Vec::new();\n+        for variant in &adt.variants {\n+            for field in &variant.fields {\n+                let ty = field.ty(tcx, substs);\n+                if ty.references_error() {\n+                    continue;\n+                }\n+                let span = tcx.def_span(field.did);\n+                let cause = ObligationCause { span, ..ObligationCause::dummy() };\n+                let ctx = traits::FulfillmentContext::new();\n+                match traits::fully_normalize(&infcx, ctx, cause, param_env, &ty) {\n+                    Ok(ty) => {\n+                        if !infcx.type_is_copy_modulo_regions(param_env, ty, span) {\n+                            infringing.push(field);\n+                        }\n+                    }\n+                    Err(errors) => {\n+                        infcx.report_fulfillment_errors(&errors, None, false);\n+                    }\n+                };\n+            }\n+        }\n+        if !infringing.is_empty() {\n+            return Err(CopyImplementationError::InfrigingFields(infringing));\n+        }\n+        if adt.has_dtor(tcx) {\n+            return Err(CopyImplementationError::HasDestructor);\n+        }\n+\n+        Ok(())\n+    })\n+}\n+\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n+}\n+\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n+}\n+\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n+}\n+\n+fn is_item_raw<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    item: lang_items::LangItem,\n+) -> bool {\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(item, None);\n+    tcx.infer_ctxt().enter(|infcx| {\n+        traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        )\n+    })\n+}\n+\n+fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n+    let (param_env, ty) = query.into_parts();\n+\n+    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n+\n+    assert!(!ty.needs_infer());\n+\n+    NeedsDrop(match ty.kind {\n+        // Fast-path for primitive types\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str => false,\n+\n+        // Foreign types can never have destructors\n+        ty::Foreign(..) => false,\n+\n+        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n+        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n+\n+        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n+        // normalized version of the type, and therefore will definitely\n+        // know whether the type implements Copy (and thus needs no\n+        // cleanup/drop/zeroing) ...\n+        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n+\n+        // ... (issue #22536 continued) but as an optimization, still use\n+        // prior logic of asking for the structural \"may drop\".\n+\n+        // FIXME(#22815): Note that this is a conservative heuristic;\n+        // it may report that the type \"may drop\" when actual type does\n+        // not actually have a destructor associated with it. But since\n+        // the type absolutely did not have the `Copy` bound attached\n+        // (see above), it is sound to treat it as having a destructor.\n+\n+        // User destructors are the only way to have concrete drop types.\n+        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n+\n+        // Can refer to a type which may drop.\n+        // FIXME(eddyb) check this against a ParamEnv.\n+        ty::Dynamic(..)\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Error => true,\n+\n+        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+\n+        // Zero-length arrays never contain anything to drop.\n+        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n+\n+        // Structural recursion.\n+        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n+\n+        ty::Closure(def_id, ref substs) => {\n+            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n+        }\n+\n+        // Pessimistically assume that all generators will require destructors\n+        // as we don't know if a destructor is a noop or not until after the MIR\n+        // state transformation pass\n+        ty::Generator(..) => true,\n+\n+        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n+\n+        // unions don't have destructors because of the child types,\n+        // only if they manually implement `Drop` (handled above).\n+        ty::Adt(def, _) if def.is_union() => false,\n+\n+        ty::Adt(def, substs) => def\n+            .variants\n+            .iter()\n+            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n+    })\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers {\n+        is_copy_raw,\n+        is_sized_raw,\n+        is_freeze_raw,\n+        needs_drop_raw,\n+        ..*providers\n+    };\n+}"}, {"sha": "11473dc2a3a6d1611612f61fa44880abbb25e196", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -7,6 +7,7 @@ pub mod auto_trait;\n mod chalk_fulfill;\n pub mod codegen;\n mod coherence;\n+pub mod drop;\n mod engine;\n pub mod error_reporting;\n mod fulfill;\n@@ -1243,6 +1244,7 @@ impl<'tcx> TraitObligation<'tcx> {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    drop::provide(providers);\n     *providers = ty::query::Providers {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,"}, {"sha": "7cca12308e65f97cf6991798e55a22ff811c17c9", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -3318,7 +3318,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    util::provide(providers);\n     constness::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,"}, {"sha": "aa93f35661a28310777f78721748e589bf743046", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 198, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -2,9 +2,7 @@\n \n use crate::hir::map::DefPathData;\n use crate::ich::NodeIdHashingMode;\n-use crate::middle::lang_items;\n use crate::mir::interpret::{sign_extend, truncate};\n-use crate::traits::{self, ObligationCause};\n use crate::ty::layout::{Integer, IntegerExt};\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n@@ -18,7 +16,7 @@ use rustc_hir::def_id::DefId;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable;\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n use std::{cmp, fmt};\n use syntax::ast;\n use syntax::attr::{self, SignedInt, UnsignedInt};\n@@ -122,13 +120,6 @@ impl IntTypeExt for attr::IntType {\n     }\n }\n \n-#[derive(Clone)]\n-pub enum CopyImplementationError<'tcx> {\n-    InfrigingFields(Vec<&'tcx ty::FieldDef>),\n-    NotAnAdt,\n-    HasDestructor,\n-}\n-\n /// Describes whether a type is representable. For types that are not\n /// representable, 'SelfRecursive' and 'ContainsRecursive' are used to\n /// distinguish between types that are recursive with themselves and types that\n@@ -144,65 +135,6 @@ pub enum Representability {\n     SelfRecursive(Vec<Span>),\n }\n \n-impl<'tcx> ty::ParamEnv<'tcx> {\n-    pub fn can_type_implement_copy(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        self_type: Ty<'tcx>,\n-    ) -> Result<(), CopyImplementationError<'tcx>> {\n-        // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt().enter(|infcx| {\n-            let (adt, substs) = match self_type.kind {\n-                // These types used to have a builtin impl.\n-                // Now libcore provides that impl.\n-                ty::Uint(_)\n-                | ty::Int(_)\n-                | ty::Bool\n-                | ty::Float(_)\n-                | ty::Char\n-                | ty::RawPtr(..)\n-                | ty::Never\n-                | ty::Ref(_, _, hir::Mutability::Not) => return Ok(()),\n-\n-                ty::Adt(adt, substs) => (adt, substs),\n-\n-                _ => return Err(CopyImplementationError::NotAnAdt),\n-            };\n-\n-            let mut infringing = Vec::new();\n-            for variant in &adt.variants {\n-                for field in &variant.fields {\n-                    let ty = field.ty(tcx, substs);\n-                    if ty.references_error() {\n-                        continue;\n-                    }\n-                    let span = tcx.def_span(field.did);\n-                    let cause = ObligationCause { span, ..ObligationCause::dummy() };\n-                    let ctx = traits::FulfillmentContext::new();\n-                    match traits::fully_normalize(&infcx, ctx, cause, self, &ty) {\n-                        Ok(ty) => {\n-                            if !infcx.type_is_copy_modulo_regions(self, ty, span) {\n-                                infringing.push(field);\n-                            }\n-                        }\n-                        Err(errors) => {\n-                            infcx.report_fulfillment_errors(&errors, None, false);\n-                        }\n-                    };\n-                }\n-            }\n-            if !infringing.is_empty() {\n-                return Err(CopyImplementationError::InfrigingFields(infringing));\n-            }\n-            if adt.has_dtor(tcx) {\n-                return Err(CopyImplementationError::HasDestructor);\n-            }\n-\n-            Ok(())\n-        })\n-    }\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Creates a hash of the type `Ty` which will be the same no matter what crate\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n@@ -942,128 +874,9 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n-}\n-\n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n-}\n-\n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n-}\n-\n-fn is_item_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    item: lang_items::LangItem,\n-) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n-}\n-\n #[derive(Clone, HashStable)]\n pub struct NeedsDrop(pub bool);\n \n-fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-    let (param_env, ty) = query.into_parts();\n-\n-    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n-\n-    assert!(!ty.needs_infer());\n-\n-    NeedsDrop(match ty.kind {\n-        // Fast-path for primitive types\n-        ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Bool\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Never\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Char\n-        | ty::GeneratorWitness(..)\n-        | ty::RawPtr(_)\n-        | ty::Ref(..)\n-        | ty::Str => false,\n-\n-        // Foreign types can never have destructors\n-        ty::Foreign(..) => false,\n-\n-        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n-\n-        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking for the structural \"may drop\".\n-\n-        // FIXME(#22815): Note that this is a conservative heuristic;\n-        // it may report that the type \"may drop\" when actual type does\n-        // not actually have a destructor associated with it. But since\n-        // the type absolutely did not have the `Copy` bound attached\n-        // (see above), it is sound to treat it as having a destructor.\n-\n-        // User destructors are the only way to have concrete drop types.\n-        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n-\n-        // Can refer to a type which may drop.\n-        // FIXME(eddyb) check this against a ParamEnv.\n-        ty::Dynamic(..)\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        | ty::Error => true,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-        // Zero-length arrays never contain anything to drop.\n-        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n-\n-        // Structural recursion.\n-        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n-\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n-        }\n-\n-        // Pessimistically assume that all generators will require destructors\n-        // as we don't know if a destructor is a noop or not until after the MIR\n-        // state transformation pass\n-        ty::Generator(..) => true,\n-\n-        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n-\n-        // unions don't have destructors because of the child types,\n-        // only if they manually implement `Drop` (handled above).\n-        ty::Adt(def, _) if def.is_union() => false,\n-\n-        ty::Adt(def, substs) => def\n-            .variants\n-            .iter()\n-            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n-    })\n-}\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -1112,13 +925,3 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         }\n     }\n }\n-\n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    *providers = ty::query::Providers {\n-        is_copy_raw,\n-        is_sized_raw,\n-        is_freeze_raw,\n-        needs_drop_raw,\n-        ..*providers\n-    };\n-}"}, {"sha": "e251e6d6aea789dd85474f7c9ce50f2cb028e40b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -27,6 +27,7 @@ use lint::{EarlyContext, EarlyLintPass, LateLintPass, LintPass};\n use lint::{LateContext, LintArray, LintContext};\n use rustc::lint;\n use rustc::lint::FutureIncompatibleInfo;\n+use rustc::traits::drop::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_feature::Stability;\n@@ -555,7 +556,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n         if ty.is_copy_modulo_regions(cx.tcx, param_env, item.span) {\n             return;\n         }\n-        if param_env.can_type_implement_copy(cx.tcx, ty).is_ok() {\n+        if can_type_implement_copy(cx.tcx, param_env, ty).is_ok() {\n             cx.span_lint(\n                 MISSING_COPY_IMPLEMENTATIONS,\n                 item.span,"}, {"sha": "35ef7ec148fed32c5d212124eff3e0321ce39985", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -6,6 +6,7 @@ use rustc::lint;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability::{DeprecationEntry, Index};\n use rustc::session::Session;\n+use rustc::traits::drop::can_type_implement_copy;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -488,7 +489,7 @@ impl Visitor<'tcx> for Checker<'tcx> {\n                     .emit();\n                 } else {\n                     let param_env = self.tcx.param_env(def_id);\n-                    if !param_env.can_type_implement_copy(self.tcx, ty).is_ok() {\n+                    if !can_type_implement_copy(self.tcx, param_env, ty).is_ok() {\n                         feature_err(\n                             &self.tcx.sess.parse_sess,\n                             sym::untagged_unions,"}, {"sha": "1bb512e350a6163babc2370bcddf893e0d48979e", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629baf96cd0dd741f4490e782a72b2ff40b27fd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=f629baf96cd0dd741f4490e782a72b2ff40b27fd", "patch": "@@ -7,10 +7,10 @@ use rustc::middle::lang_items::UnsizeTraitLangItem;\n use rustc::middle::region;\n \n use rustc::infer;\n+use rustc::traits::drop::{can_type_implement_copy, CopyImplementationError};\n use rustc::traits::predicate_for_trait_def;\n use rustc::traits::{self, ObligationCause, TraitEngine};\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n-use rustc::ty::util::CopyImplementationError;\n use rustc::ty::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n \n@@ -92,7 +92,7 @@ fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: DefId) {\n \n     debug!(\"visit_implementation_of_copy: self_type={:?} (free)\", self_type);\n \n-    match param_env.can_type_implement_copy(tcx, self_type) {\n+    match can_type_implement_copy(tcx, param_env, self_type) {\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir().expect_item(impl_hir_id);"}]}