{"sha": "aa7010df9027c5c346ab32b3a7fefca06365856f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNzAxMGRmOTAyN2M1YzM0NmFiMzJiM2E3ZmVmY2EwNjM2NTg1NmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-24T10:29:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-24T10:29:29Z"}, "message": "Auto merge of #75815 - jyn514:ambiguous-primitives, r=guillaumegomez\n\nReport an ambiguity if both modules and primitives are in scope for intra-doc links\n\nCloses https://github.com/rust-lang/rust/issues/75381\n\n- Add a new `prim@` disambiguator, since both modules and primitives are in the same namespace\n- Refactor `report_ambiguity` into a closure\n\nAdditionally, I noticed that rustdoc would previously allow `[struct@char]` if `char` resolved to a primitive (not if it had a DefId). I fixed that and added a test case.\n\nI also need to update libstd to use `prim@char` instead of `type@char`. If possible I would also like to refactor `ambiguity_error` to use `Disambiguator` instead of its own hand-rolled match - that ran into issues with `prim@` (I updated one and not the other) and it would be better for them to be in sync.", "tree": {"sha": "e5d20d660f37b5489e9ebfa8cf865bf93738b489", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5d20d660f37b5489e9ebfa8cf865bf93738b489"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa7010df9027c5c346ab32b3a7fefca06365856f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa7010df9027c5c346ab32b3a7fefca06365856f", "html_url": "https://github.com/rust-lang/rust/commit/aa7010df9027c5c346ab32b3a7fefca06365856f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa7010df9027c5c346ab32b3a7fefca06365856f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d7456243244141808b39ee8ed32767a7a1dc7d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7456243244141808b39ee8ed32767a7a1dc7d7", "html_url": "https://github.com/rust-lang/rust/commit/9d7456243244141808b39ee8ed32767a7a1dc7d7"}, {"sha": "25cfd57b49b84fda6cd5b87072bc7e9fe0c582ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/25cfd57b49b84fda6cd5b87072bc7e9fe0c582ce", "html_url": "https://github.com/rust-lang/rust/commit/25cfd57b49b84fda6cd5b87072bc7e9fe0c582ce"}], "stats": {"total": 323, "additions": 253, "deletions": 70}, "files": [{"sha": "05690e19d23e4175264c706af83bc7d7cdb9b70c", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -268,8 +268,8 @@ use crate::vec::Vec;\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n ///\n-/// [`str`]: type@str\n-/// [`&str`]: type@str\n+/// [`str`]: prim@str\n+/// [`&str`]: prim@str\n /// [`Deref`]: core::ops::Deref\n /// [`as_str()`]: String::as_str\n #[derive(PartialOrd, Eq, Ord)]\n@@ -296,7 +296,7 @@ pub struct String {\n ///\n /// [`Utf8Error`]: core::str::Utf8Error\n /// [`std::str`]: core::str\n-/// [`&str`]: str\n+/// [`&str`]: prim@str\n /// [`utf8_error`]: Self::utf8_error\n ///\n /// # Examples\n@@ -472,7 +472,7 @@ impl String {\n     ///\n     /// [`from_utf8_unchecked`]: String::from_utf8_unchecked\n     /// [`Vec<u8>`]: crate::vec::Vec\n-    /// [`&str`]: str\n+    /// [`&str`]: prim@str\n     /// [`into_bytes`]: String::into_bytes\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1576,6 +1576,8 @@ impl String {\n     ///\n     /// This will drop any excess capacity.\n     ///\n+    /// [`str`]: prim@str\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1644,7 +1646,7 @@ impl FromUtf8Error {\n     /// on using it.\n     ///\n     /// [`std::str`]: core::str\n-    /// [`&str`]: str\n+    /// [`&str`]: prim@str\n     ///\n     /// # Examples\n     ///"}, {"sha": "ab9afeb25e0cec7d0e6191ac65c33c0361173113", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -476,6 +476,7 @@ Section: Iterators\n /// This struct is created by the [`chars`] method on [`str`].\n /// See its documentation for more.\n ///\n+/// [`char`]: prim@char\n /// [`chars`]: str::chars\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -673,6 +674,7 @@ impl<'a> Chars<'a> {\n /// This struct is created by the [`char_indices`] method on [`str`].\n /// See its documentation for more.\n ///\n+/// [`char`]: prim@char\n /// [`char_indices`]: str::char_indices\n #[derive(Clone, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2270,6 +2272,8 @@ impl str {\n     /// This length is in bytes, not [`char`]s or graphemes. In other words,\n     /// it may not be what a human considers the length of the string.\n     ///\n+    /// [`char`]: prim@char\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -2791,7 +2795,9 @@ impl str {\n     /// assert_eq!(None, chars.next());\n     /// ```\n     ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n+    /// Remember, [`char`]s may not match your intuition about characters:\n+    ///\n+    /// [`char`]: prim@char\n     ///\n     /// ```\n     /// let y = \"y\u0306\";\n@@ -2842,7 +2848,9 @@ impl str {\n     /// assert_eq!(None, char_indices.next());\n     /// ```\n     ///\n-    /// Remember, [`char`]s may not match your human intuition about characters:\n+    /// Remember, [`char`]s may not match your intuition about characters:\n+    ///\n+    /// [`char`]: prim@char\n     ///\n     /// ```\n     /// let yes = \"y\u0306es\";\n@@ -3053,6 +3061,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -3079,6 +3088,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -3104,6 +3114,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -3132,6 +3143,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -3179,6 +3191,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -3225,6 +3238,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3344,6 +3358,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -3383,6 +3398,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3434,6 +3450,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// Equivalent to [`split`], except that the trailing substring\n@@ -3478,6 +3495,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// Equivalent to [`split`], except that the trailing substring is\n@@ -3526,6 +3544,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3578,6 +3597,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3666,6 +3686,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3702,6 +3723,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3743,6 +3765,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -3785,6 +3808,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Iterator behavior\n@@ -4003,6 +4027,7 @@ impl str {\n     /// The [pattern] can be a [`char`], a slice of [`char`]s, or a function\n     /// or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -4050,6 +4075,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n@@ -4094,6 +4120,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -4121,6 +4148,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Examples\n@@ -4147,6 +4175,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n@@ -4195,6 +4224,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Text directionality\n@@ -4231,6 +4261,7 @@ impl str {\n     /// The [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\n     /// function or closure that determines if a character matches.\n     ///\n+    /// [`char`]: prim@char\n     /// [pattern]: self::pattern\n     ///\n     /// # Text directionality"}, {"sha": "84e686c2fef818ae7211a3eb5689600db05eaf52", "filename": "library/std/src/error.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -296,6 +296,8 @@ impl From<String> for Box<dyn Error> {\n impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n     /// Converts a [`str`] into a box of dyn [`Error`] + [`Send`] + [`Sync`].\n     ///\n+    /// [`str`]: prim@str\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -317,6 +319,8 @@ impl<'a> From<&str> for Box<dyn Error + Send + Sync + 'a> {\n impl From<&str> for Box<dyn Error> {\n     /// Converts a [`str`] into a box of dyn [`Error`].\n     ///\n+    /// [`str`]: prim@str\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "717967fb7687fa27ede34e9718bb085fabcf0d90", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -69,7 +69,7 @@ use crate::sys;\n /// extern functions. See the documentation for that function for a\n /// discussion on ensuring the lifetime of the raw pointer.\n ///\n-/// [`&str`]: str\n+/// [`&str`]: prim@str\n /// [slice.as_ptr]: ../primitive.slice.html#method.as_ptr\n /// [slice.len]: ../primitive.slice.html#method.len\n /// [`Deref`]: ops::Deref\n@@ -180,7 +180,7 @@ pub struct CString {\n /// println!(\"string: {}\", my_string_safe());\n /// ```\n ///\n-/// [`&str`]: str\n+/// [`&str`]: prim@str\n #[derive(Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // FIXME:\n@@ -1351,7 +1351,7 @@ impl CStr {\n     /// function will return the corresponding [`&str`] slice. Otherwise,\n     /// it will return an error with details of where UTF-8 validation failed.\n     ///\n-    /// [`&str`]: str\n+    /// [`&str`]: prim@str\n     ///\n     /// # Examples\n     ///\n@@ -1379,6 +1379,7 @@ impl CStr {\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n     ///\n+    /// [`str`]: prim@str\n     /// [`Borrowed`]: Cow::Borrowed\n     /// [`Owned`]: Cow::Owned\n     /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER"}, {"sha": "462b696db40cf8ac6dbad7b6e8ae785ed721e7f2", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -480,7 +480,7 @@ where\n /// ```\n ///\n /// [`read()`]: Read::read\n-/// [`&str`]: str\n+/// [`&str`]: prim@str\n /// [`std::io`]: self\n /// [`File`]: crate::fs::File\n /// [slice]: ../../std/primitive.slice.html"}, {"sha": "1142b74ff0dc4b8a3691766594ad8d205edcea8f", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -172,6 +172,7 @@\n //! [`Vec<T>`]: vec::Vec\n //! [`atomic`]: sync::atomic\n //! [`for`]: ../book/ch03-05-control-flow.html#looping-through-a-collection-with-for\n+//! [`str`]: prim@str\n //! [`mpsc`]: sync::mpsc\n //! [`std::cmp`]: cmp\n //! [`std::slice`]: slice"}, {"sha": "2f49fc8a41552293af6078f04a9d493996fe3bca", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -81,7 +81,7 @@ impl<T> AsyncReceiver<T> {\n }\n ```\n \n-Paths in Rust have three namespaces: type, value, and macro. Items from these namespaces are allowed to overlap. In case of ambiguity, rustdoc will warn about the ambiguity and ask you to disambiguate, which can be done by using a prefix like `struct@`, `enum@`, `type@`, `trait@`, `union@`, `const@`, `static@`, `value@`, `function@`, `mod@`, `fn@`, `module@`, `method@` , `macro@`, or `derive@`:\n+Paths in Rust have three namespaces: type, value, and macro. Items from these namespaces are allowed to overlap. In case of ambiguity, rustdoc will warn about the ambiguity and ask you to disambiguate, which can be done by using a prefix like `struct@`, `enum@`, `type@`, `trait@`, `union@`, `const@`, `static@`, `value@`, `function@`, `mod@`, `fn@`, `module@`, `method@`, `prim@`, `primitive@`, `macro@`, or `derive@`:\n \n ```rust\n /// See also: [`Foo`](struct@Foo)"}, {"sha": "bf091a0a624ddabb9be98d87e3d3066affeb4a7c", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 111, "deletions": 50, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -181,7 +181,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve(\n         &self,\n         path_str: &str,\n-        disambiguator: Option<Disambiguator>,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n@@ -218,18 +217,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         return Ok((res, Some(path_str.to_owned())));\n                     }\n                     Res::Def(DefKind::Mod, _) => {\n-                        // This resolved to a module, but we want primitive types to take precedence instead.\n-                        if matches!(\n-                            disambiguator,\n-                            None | Some(Disambiguator::Namespace(Namespace::TypeNS))\n-                        ) {\n-                            if let Some((path, prim)) = is_primitive(path_str, ns) {\n-                                if extra_fragment.is_some() {\n-                                    return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n-                                }\n-                                return Ok((prim, Some(path.to_owned())));\n-                            }\n-                        }\n                         return Ok((res, extra_fragment.clone()));\n                     }\n                     _ => {\n@@ -713,7 +700,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let resolved_self;\n             let mut path_str;\n             let disambiguator;\n-            let (res, fragment) = {\n+            let (mut res, mut fragment) = {\n                 path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n                     disambiguator = Some(d);\n                     path\n@@ -754,14 +741,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n                 match disambiguator.map(Disambiguator::ns) {\n                     Some(ns @ (ValueNS | TypeNS)) => {\n-                        match self.resolve(\n-                            path_str,\n-                            disambiguator,\n-                            ns,\n-                            &current_item,\n-                            base_node,\n-                            &extra_fragment,\n-                        ) {\n+                        match self.resolve(path_str, ns, &current_item, base_node, &extra_fragment)\n+                        {\n                             Ok(res) => res,\n                             Err(ErrorKind::ResolutionFailure) => {\n                                 resolution_failure(cx, &item, path_str, &dox, link_range);\n@@ -784,7 +765,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 .map(|res| (res, extra_fragment.clone())),\n                             type_ns: match self.resolve(\n                                 path_str,\n-                                disambiguator,\n                                 TypeNS,\n                                 &current_item,\n                                 base_node,\n@@ -802,7 +782,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n-                                disambiguator,\n                                 ValueNS,\n                                 &current_item,\n                                 base_node,\n@@ -848,13 +827,18 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             if is_derive_trait_collision(&candidates) {\n                                 candidates.macro_ns = None;\n                             }\n+                            let candidates =\n+                                candidates.map(|candidate| candidate.map(|(res, _)| res));\n+                            let candidates = [TypeNS, ValueNS, MacroNS]\n+                                .iter()\n+                                .filter_map(|&ns| candidates[ns].map(|res| (res, ns)));\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n                                 path_str,\n                                 &dox,\n                                 link_range,\n-                                candidates.map(|candidate| candidate.map(|(res, _)| res)),\n+                                candidates.collect(),\n                             );\n                             continue;\n                         }\n@@ -870,13 +854,81 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 }\n             };\n \n+            // Check for a primitive which might conflict with a module\n+            // Report the ambiguity and require that the user specify which one they meant.\n+            // FIXME: could there ever be a primitive not in the type namespace?\n+            if matches!(\n+                disambiguator,\n+                None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n+            ) && !matches!(res, Res::PrimTy(_))\n+            {\n+                if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n+                    // `prim@char`\n+                    if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n+                        if fragment.is_some() {\n+                            anchor_failure(\n+                                cx,\n+                                &item,\n+                                path_str,\n+                                &dox,\n+                                link_range,\n+                                AnchorFailure::Primitive,\n+                            );\n+                            continue;\n+                        }\n+                        res = prim;\n+                        fragment = Some(path.to_owned());\n+                    } else {\n+                        // `[char]` when a `char` module is in scope\n+                        let candidates = vec![(res, TypeNS), (prim, TypeNS)];\n+                        ambiguity_error(cx, &item, path_str, &dox, link_range, candidates);\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n+                // The resolved item did not match the disambiguator; give a better error than 'not found'\n+                let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+                report_diagnostic(cx, &msg, &item, &dox, link_range.clone(), |diag, sp| {\n+                    let note = format!(\n+                        \"this link resolved to {} {}, which is not {} {}\",\n+                        resolved.article(),\n+                        resolved.descr(),\n+                        specified.article(),\n+                        specified.descr()\n+                    );\n+                    let suggestion = resolved.display_for(path_str);\n+                    let help_msg =\n+                        format!(\"to link to the {}, use its disambiguator\", resolved.descr());\n+                    diag.note(&note);\n+                    if let Some(sp) = sp {\n+                        diag.span_suggestion(\n+                            sp,\n+                            &help_msg,\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n+                    }\n+                });\n+            };\n             if let Res::PrimTy(_) = res {\n-                item.attrs.links.push((ori_link, None, fragment));\n+                match disambiguator {\n+                    Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n+                        item.attrs.links.push((ori_link, None, fragment))\n+                    }\n+                    Some(other) => {\n+                        report_mismatch(other, Disambiguator::Primitive);\n+                        continue;\n+                    }\n+                }\n             } else {\n                 debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n                 // Disallow e.g. linking to enums with `struct@`\n-                if let Res::Def(kind, id) = res {\n+                if let Res::Def(kind, _) = res {\n                     debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n                     match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n                         | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n@@ -890,22 +942,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         // All of these are valid, so do nothing\n                         => {}\n                         (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-                        (_, Some(Disambiguator::Kind(expected))) => {\n-                            // The resolved item did not match the disambiguator; give a better error than 'not found'\n-                            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-                            report_diagnostic(cx, &msg, &item, &dox, link_range, |diag, sp| {\n-                                // HACK(jynelson): by looking at the source I saw the DefId we pass\n-                                // for `expected.descr()` doesn't matter, since it's not a crate\n-                                let note = format!(\"this link resolved to {} {}, which is not {} {}\", kind.article(), kind.descr(id), expected.article(), expected.descr(id));\n-                                let suggestion = Disambiguator::display_for(kind, path_str);\n-                                let help_msg = format!(\"to link to the {}, use its disambiguator\", kind.descr(id));\n-                                diag.note(&note);\n-                                if let Some(sp) = sp {\n-                                    diag.span_suggestion(sp, &help_msg, suggestion, Applicability::MaybeIncorrect);\n-                                } else {\n-                                    diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n-                                }\n-                            });\n+                        (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                            report_mismatch(specified, Disambiguator::Kind(kind));\n                             continue;\n                         }\n                     }\n@@ -961,14 +999,15 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Disambiguator {\n+    Primitive,\n     Kind(DefKind),\n     Namespace(Namespace),\n }\n \n impl Disambiguator {\n     /// (disambiguator, path_str)\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n-        use Disambiguator::{Kind, Namespace as NS};\n+        use Disambiguator::{Kind, Namespace as NS, Primitive};\n \n         let find_suffix = || {\n             let suffixes = [\n@@ -999,6 +1038,7 @@ impl Disambiguator {\n                 \"type\" => NS(Namespace::TypeNS),\n                 \"value\" => NS(Namespace::ValueNS),\n                 \"macro\" => NS(Namespace::MacroNS),\n+                \"prim\" | \"primitive\" => Primitive,\n                 _ => return find_suffix(),\n             };\n             Ok((d, &rest[1..]))\n@@ -1007,7 +1047,12 @@ impl Disambiguator {\n         }\n     }\n \n-    fn display_for(kind: DefKind, path_str: &str) -> String {\n+    fn display_for(self, path_str: &str) -> String {\n+        let kind = match self {\n+            Disambiguator::Primitive => return format!(\"prim@{}\", path_str),\n+            Disambiguator::Kind(kind) => kind,\n+            Disambiguator::Namespace(_) => panic!(\"display_for cannot be used on namespaces\"),\n+        };\n         if kind == DefKind::Macro(MacroKind::Bang) {\n             return format!(\"{}!\", path_str);\n         } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n@@ -1043,6 +1088,25 @@ impl Disambiguator {\n             Self::Kind(k) => {\n                 k.ns().expect(\"only DefKinds with a valid namespace can be disambiguators\")\n             }\n+            Self::Primitive => TypeNS,\n+        }\n+    }\n+\n+    fn article(self) -> &'static str {\n+        match self {\n+            Self::Namespace(_) => panic!(\"article() doesn't make sense for namespaces\"),\n+            Self::Kind(k) => k.article(),\n+            Self::Primitive => \"a\",\n+        }\n+    }\n+\n+    fn descr(self) -> &'static str {\n+        match self {\n+            Self::Namespace(n) => n.descr(),\n+            // HACK(jynelson): by looking at the source I saw the DefId we pass\n+            // for `expected.descr()` doesn't matter, since it's not a crate\n+            Self::Kind(k) => k.descr(DefId::local(hir::def_id::DefIndex::from_usize(0))),\n+            Self::Primitive => \"builtin type\",\n         }\n     }\n }\n@@ -1183,14 +1247,10 @@ fn ambiguity_error(\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n-    candidates: PerNS<Option<Res>>,\n+    candidates: Vec<(Res, Namespace)>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n \n-    let candidates = [TypeNS, ValueNS, MacroNS]\n-        .iter()\n-        .filter_map(|&ns| candidates[ns].map(|res| (res, ns)))\n-        .collect::<Vec<_>>();\n     match candidates.as_slice() {\n         [(first_def, _), (second_def, _)] => {\n             msg += &format!(\n@@ -1229,6 +1289,7 @@ fn ambiguity_error(\n                     }\n                     _ => {\n                         let type_ = match (res, ns) {\n+                            (Res::PrimTy(_), _) => \"prim\",\n                             (Res::Def(DefKind::Const, _), _) => \"const\",\n                             (Res::Def(DefKind::Static, _), _) => \"static\",\n                             (Res::Def(DefKind::Struct, _), _) => \"struct\","}, {"sha": "34276fbcf2058cf80e3483113f03619ea4090ecc", "filename": "src/test/rustdoc-ui/intra-link-prim-conflict.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -0,0 +1,30 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+\n+/// [char]\n+//~^ ERROR both a module and a builtin type\n+//~| NOTE ambiguous link\n+//~| HELP to link to the module\n+//~| HELP to link to the builtin type\n+\n+/// [type@char]\n+//~^ ERROR both a module and a builtin type\n+//~| NOTE ambiguous link\n+//~| HELP to link to the module\n+//~| HELP to link to the builtin type\n+\n+/// [mod@char] // ok\n+/// [prim@char] // ok\n+\n+/// [struct@char]\n+//~^ ERROR incompatible link\n+//~| HELP use its disambiguator\n+//~| NOTE resolved to a module\n+pub mod char {}\n+\n+pub mod inner {\n+    //! [struct@char]\n+    //~^ ERROR incompatible link\n+    //~| HELP use its disambiguator\n+    //~| NOTE resolved to a builtin type\n+}"}, {"sha": "b28a44266665648d2cc0eda8ed6aac966cdbd291", "filename": "src/test/rustdoc-ui/intra-link-prim-conflict.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -0,0 +1,53 @@\n+error: `char` is both a module and a builtin type\n+  --> $DIR/intra-link-prim-conflict.rs:4:6\n+   |\n+LL | /// [char]\n+   |      ^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-link-prim-conflict.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the module, prefix with the item type\n+   |\n+LL | /// [module@char]\n+   |      ^^^^^^^^^^^\n+help: to link to the builtin type, prefix with the item type\n+   |\n+LL | /// [prim@char]\n+   |      ^^^^^^^^^\n+\n+error: `char` is both a module and a builtin type\n+  --> $DIR/intra-link-prim-conflict.rs:10:6\n+   |\n+LL | /// [type@char]\n+   |      ^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the module, prefix with the item type\n+   |\n+LL | /// [module@char]\n+   |      ^^^^^^^^^^^\n+help: to link to the builtin type, prefix with the item type\n+   |\n+LL | /// [prim@char]\n+   |      ^^^^^^^^^\n+\n+error: incompatible link kind for `char`\n+  --> $DIR/intra-link-prim-conflict.rs:19:6\n+   |\n+LL | /// [struct@char]\n+   |      ^^^^^^^^^^^ help: to link to the module, use its disambiguator: `mod@char`\n+   |\n+   = note: this link resolved to a module, which is not a struct\n+\n+error: incompatible link kind for `char`\n+  --> $DIR/intra-link-prim-conflict.rs:26:10\n+   |\n+LL |     //! [struct@char]\n+   |          ^^^^^^^^^^^ help: to link to the builtin type, use its disambiguator: `prim@char`\n+   |\n+   = note: this link resolved to a builtin type, which is not a struct\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "0a4e57ef643e7824145262785828b4f9216192f0", "filename": "src/test/rustdoc/intra-link-prim-precedence.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa7010df9027c5c346ab32b3a7fefca06365856f/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-prim-precedence.rs?ref=aa7010df9027c5c346ab32b3a7fefca06365856f", "patch": "@@ -1,17 +1,17 @@\n // ignore-tidy-linelength\n #![deny(broken_intra_doc_links)]\n \n-pub mod char {}\n+pub mod char {\n+    /// [char]\n+    // @has intra_link_prim_precedence/char/struct.Inner.html '//a/@href' 'https://doc.rust-lang.org/nightly/std/primitive.char.html'\n+    pub struct Inner;\n+}\n \n-/// See also [type@char]\n+/// See [prim@char]\n // @has intra_link_prim_precedence/struct.MyString.html '//a/@href' 'https://doc.rust-lang.org/nightly/std/primitive.char.html'\n pub struct MyString;\n \n-/// See also [char]\n-// @has intra_link_prim_precedence/struct.MyString2.html '//a/@href' 'https://doc.rust-lang.org/nightly/std/primitive.char.html'\n-pub struct MyString2;\n-\n /// See also [crate::char] and [mod@char]\n-// @has intra_link_prim_precedence/struct.MyString3.html '//*[@href=\"../intra_link_prim_precedence/char/index.html\"]' 'crate::char'\n+// @has intra_link_prim_precedence/struct.MyString2.html '//*[@href=\"../intra_link_prim_precedence/char/index.html\"]' 'crate::char'\n // @has - '//*[@href=\"../intra_link_prim_precedence/char/index.html\"]' 'mod@char'\n-pub struct MyString3;\n+pub struct MyString2;"}]}