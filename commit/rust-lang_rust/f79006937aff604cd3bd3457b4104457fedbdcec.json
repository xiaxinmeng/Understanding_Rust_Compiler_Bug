{"sha": "f79006937aff604cd3bd3457b4104457fedbdcec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OTAwNjkzN2FmZjYwNGNkM2JkMzQ1N2I0MTA0NDU3ZmVkYmRjZWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-17T22:22:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-08-17T22:23:44Z"}, "message": "rustc: Remove tag_paths and all of the associated encoding", "tree": {"sha": "ab16447504f8c151f83d6c55ebe01a92fcc5f983", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab16447504f8c151f83d6c55ebe01a92fcc5f983"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f79006937aff604cd3bd3457b4104457fedbdcec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f79006937aff604cd3bd3457b4104457fedbdcec", "html_url": "https://github.com/rust-lang/rust/commit/f79006937aff604cd3bd3457b4104457fedbdcec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f79006937aff604cd3bd3457b4104457fedbdcec/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea549e7a71964625f1eb24d7432f222c407d9999", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea549e7a71964625f1eb24d7432f222c407d9999", "html_url": "https://github.com/rust-lang/rust/commit/ea549e7a71964625f1eb24d7432f222c407d9999"}], "stats": {"total": 214, "additions": 0, "deletions": 214}, "files": [{"sha": "9f7b95f2bfaf1642b5b527cdddd4870431b6f331", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f79006937aff604cd3bd3457b4104457fedbdcec/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79006937aff604cd3bd3457b4104457fedbdcec/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=f79006937aff604cd3bd3457b4104457fedbdcec", "patch": "@@ -27,7 +27,6 @@ export get_impl_traits;\n export get_class_method;\n export get_impl_method;\n export lookup_def;\n-export lookup_item_name;\n export resolve_path;\n export get_crate_attributes;\n export list_crate_metadata;\n@@ -242,10 +241,6 @@ fn item_name(item: ebml::doc) -> ast::ident {\n     @str::from_bytes(ebml::doc_data(name))\n }\n \n-fn lookup_item_name(data: @~[u8], id: ast::node_id) -> ast::ident {\n-    item_name(lookup_item(id, data))\n-}\n-\n fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n     let fam_ch = item_family(item);"}, {"sha": "926a448180f6f87321092840f9c5485b1999ceef", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/f79006937aff604cd3bd3457b4104457fedbdcec/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79006937aff604cd3bd3457b4104457fedbdcec/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=f79006937aff604cd3bd3457b4104457fedbdcec", "patch": "@@ -73,7 +73,6 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-// Path table encoding\n fn encode_name(ebml_w: ebml::writer, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, *name);\n }\n@@ -82,26 +81,12 @@ fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-/* Encodes the given name, then def_id as tagged strings */\n-fn encode_name_and_def_id(ebml_w: ebml::writer, nm: ident,\n-                          id: node_id) {\n-    encode_name(ebml_w, nm);\n-    encode_def_id(ebml_w, local_def(id));\n-}\n-\n fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                        it: @ast::item) {\n     let rp = ecx.tcx.region_paramd_items.contains_key(it.id);\n     if rp { do ebml_w.wr_tag(tag_region_param) { } }\n }\n \n-fn encode_named_def_id(ebml_w: ebml::writer, name: ident, id: def_id) {\n-    do ebml_w.wr_tag(tag_paths_data_item) {\n-        encode_name(ebml_w, name);\n-        encode_def_id(ebml_w, id);\n-    }\n-}\n-\n fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n@@ -114,32 +99,6 @@ fn encode_mutability(ebml_w: ebml::writer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: ~[variant],\n-                            path: ~[ident], &index: ~[entry<~str>]) {\n-    for variants.each |variant| {\n-        add_to_index(ebml_w, path, index, variant.node.name);\n-        do ebml_w.wr_tag(tag_paths_data_item) {\n-            encode_name(ebml_w, variant.node.name);\n-            encode_def_id(ebml_w, local_def(variant.node.id));\n-        }\n-    }\n-}\n-\n-fn encode_trait_static_method_paths(ebml_w: ebml::writer,\n-                                    methods: ~[trait_method],\n-                                    path: ~[ident],\n-                                    &index: ~[entry<~str>]) {\n-    for methods.each |method| {\n-        let ty_m = trait_method_to_ty_method(method);\n-        if ty_m.self_ty.node != sty_static { again; }\n-        add_to_index(ebml_w, path, index, ty_m.ident);\n-        do ebml_w.wr_tag(tag_paths_data_item) {\n-            encode_name(ebml_w, ty_m.ident);\n-            encode_def_id(ebml_w, local_def(ty_m.id));\n-        }\n-    }\n-}\n-\n fn add_to_index(ebml_w: ebml::writer, path: &[ident], &index: ~[entry<~str>],\n                 name: ident) {\n     let mut full_path = ~[];\n@@ -149,162 +108,12 @@ fn add_to_index(ebml_w: ebml::writer, path: &[ident], &index: ~[entry<~str>],\n                       pos: ebml_w.writer.tell()});\n }\n \n-fn encode_foreign_module_item_paths(ebml_w: ebml::writer, nmod: foreign_mod,\n-                                    path: ~[ident], &index: ~[entry<~str>]) {\n-    for nmod.items.each |nitem| {\n-      add_to_index(ebml_w, path, index, nitem.ident);\n-      do ebml_w.wr_tag(tag_paths_foreign_path) {\n-          encode_name(ebml_w, nitem.ident);\n-          encode_def_id(ebml_w, local_def(nitem.id));\n-      }\n-    }\n-}\n-\n-fn encode_class_item_paths(ebml_w: ebml::writer,\n-                           fields: ~[@ast::struct_field],\n-                           methods: ~[@ast::method],\n-                           path: ~[ident],\n-                           &index: ~[entry<~str>]) {\n-    for fields.each |field| {\n-        match field.node.kind {\n-            ast::named_field(ident, _, visibility) => {\n-                if visibility == private { again; }\n-                let (id, ident) = (field.node.id, ident);\n-                add_to_index(ebml_w, path, index, ident);\n-                encode_named_def_id(ebml_w, ident, local_def(id));\n-            }\n-            ast::unnamed_field => {}\n-        }\n-    }\n-\n-    for methods.each |method| {\n-        if method.vis == private { again; }\n-        let (id, ident) = (method.id, method.ident);\n-        add_to_index(ebml_w, path, index, ident);\n-        encode_named_def_id(ebml_w, ident, local_def(id));\n-    }\n-}\n-\n-fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n-                            module_: _mod, path: ~[ident],\n-                            &index: ~[entry<~str>]) {\n-    for module_.items.each |it| {\n-        if !reachable(ecx, it.id) ||\n-           !ast_util::is_exported(it.ident, module_) { again; }\n-        if !ast_util::is_item_impl(it) {\n-            add_to_index(ebml_w, path, index, it.ident);\n-        }\n-        match it.node {\n-          item_const(_, _) => {\n-            encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n-          }\n-          item_fn(_, tps, _) => {\n-            encode_named_def_id(ebml_w, it.ident, local_def(it.id));\n-          }\n-          item_mod(_mod) => {\n-            do ebml_w.wr_tag(tag_paths_data_mod) {\n-               encode_name_and_def_id(ebml_w, it.ident, it.id);\n-               encode_module_item_paths(ebml_w, ecx, _mod,\n-                                        vec::append_one(path, it.ident),\n-                                        index);\n-            }\n-          }\n-          item_foreign_mod(nmod) => {\n-            do ebml_w.wr_tag(tag_paths_data_mod) {\n-              encode_name_and_def_id(ebml_w, it.ident, it.id);\n-              encode_foreign_module_item_paths(\n-                  ebml_w, nmod,\n-                  vec::append_one(path, it.ident), index);\n-            }\n-          }\n-          item_ty(_, tps) => {\n-            do ebml_w.wr_tag(tag_paths_data_item) {\n-              encode_name_and_def_id(ebml_w, it.ident, it.id);\n-            }\n-          }\n-          item_class(struct_def, _) => {\n-            do ebml_w.wr_tag(tag_paths_data_item) {\n-                encode_name_and_def_id(ebml_w, it.ident, it.id);\n-            }\n-            do ebml_w.wr_tag(tag_paths) {\n-                // We add the same ident twice: for the\n-                // class and for its ctor\n-                add_to_index(ebml_w, path, index, it.ident);\n-\n-                encode_struct_def(ebml_w, struct_def, path, it.ident, index);\n-            }\n-          }\n-          item_enum(enum_definition, _) => {\n-            do ebml_w.wr_tag(tag_paths_data_item) {\n-                  encode_name_and_def_id(ebml_w, it.ident, it.id);\n-              }\n-              encode_enum_variant_paths(ebml_w, enum_definition.variants,\n-                                        path, index);\n-          }\n-          item_trait(_, _, methods) => {\n-            do ebml_w.wr_tag(tag_paths_data_item) {\n-                encode_name_and_def_id(ebml_w, it.ident, it.id);\n-            }\n-            encode_trait_static_method_paths(ebml_w, methods, path, index);\n-          }\n-          item_impl(*) => {}\n-          item_mac(*) => fail ~\"item macros unimplemented\"\n-        }\n-    }\n-}\n-\n-fn encode_struct_def(ebml_w: ebml::writer,\n-                     struct_def: @ast::struct_def,\n-                     path: ~[ast::ident],\n-                     ident: ast::ident,\n-                     &index: ~[entry<~str>]) {\n-    match struct_def.ctor {\n-        none => {\n-            // Nothing to do.\n-        }\n-        some(ctor) => {\n-            encode_named_def_id(ebml_w, ident, local_def(ctor.node.id));\n-        }\n-    }\n-\n-    encode_class_item_paths(ebml_w,\n-                            struct_def.fields,\n-                            struct_def.methods,\n-                            vec::append_one(path, ident),\n-                            index);\n-}\n-\n fn encode_trait_ref(ebml_w: ebml::writer, ecx: @encode_ctxt, t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n     ebml_w.end_tag();\n }\n \n-fn encode_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt, crate: @crate)\n-                  -> ~[entry<~str>] {\n-    let mut index: ~[entry<~str>] = ~[];\n-    let mut path: ~[ident] = ~[];\n-    ebml_w.start_tag(tag_paths);\n-    encode_module_item_paths(ebml_w, ecx, crate.node.module, path, index);\n-    encode_reexport_paths(ebml_w, ecx, index);\n-    ebml_w.end_tag();\n-    return index;\n-}\n-\n-fn encode_reexport_paths(ebml_w: ebml::writer,\n-                         ecx: @encode_ctxt, &index: ~[entry<~str>]) {\n-    for ecx.reexports.each |reexport| {\n-        let (path, def_id) = reexport;\n-        vec::push(index, {val: path, pos: ebml_w.writer.tell()});\n-        // List metadata ignores tag_paths_foreign_path things, but\n-        // other things look at it.\n-        ebml_w.start_tag(tag_paths_foreign_path);\n-        encode_name(ebml_w, @path);\n-        encode_def_id(ebml_w, def_id);\n-        ebml_w.end_tag();\n-    }\n-}\n-\n \n // Item info table encoding\n fn encode_family(ebml_w: ebml::writer, c: char) {\n@@ -517,17 +326,6 @@ fn encode_visibility(ebml_w: ebml::writer, visibility: visibility) {\n     });\n }\n \n-fn encode_region(ebml_w: ebml::writer, region: region) {\n-    match region.node {\n-        re_anon => {\n-            ebml_w.wr_tagged_str(tag_item_trait_method_self_ty, ~\"\");\n-        }\n-        re_named(ident) => {\n-            ebml_w.wr_tagged_str(tag_item_trait_method_self_ty, *ident);\n-        }\n-    }\n-}\n-\n fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n@@ -1277,13 +1075,6 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n     encode_crate_deps(ebml_w, ecx.cstore);\n \n-    // Encode and index the paths.\n-    ebml_w.start_tag(tag_paths);\n-    let paths_index = encode_item_paths(ebml_w, ecx, crate);\n-    let paths_buckets = create_index(paths_index, hash_path);\n-    encode_index(ebml_w, paths_buckets, write_str);\n-    ebml_w.end_tag();\n-\n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     let items_index = encode_info_for_items(ecx, ebml_w, crate);"}]}