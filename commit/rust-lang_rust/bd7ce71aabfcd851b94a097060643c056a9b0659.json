{"sha": "bd7ce71aabfcd851b94a097060643c056a9b0659", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkN2NlNzFhYWJmY2Q4NTFiOTRhMDk3MDYwNjQzYzA1NmE5YjA2NTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-11T07:33:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-11T07:33:31Z"}, "message": "Auto merge of #45807 - tommyip:format_err, r=estebank\n\nMake positional argument error in format! clearer\n\nr? @estebank\n\nFixes #44954", "tree": {"sha": "a751d679606f466bd18724aab68c16b3b730f2cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a751d679606f466bd18724aab68c16b3b730f2cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd7ce71aabfcd851b94a097060643c056a9b0659", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7ce71aabfcd851b94a097060643c056a9b0659", "html_url": "https://github.com/rust-lang/rust/commit/bd7ce71aabfcd851b94a097060643c056a9b0659", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd7ce71aabfcd851b94a097060643c056a9b0659/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c703ff275fd84bd44b6618a8a59e102fee94e635", "url": "https://api.github.com/repos/rust-lang/rust/commits/c703ff275fd84bd44b6618a8a59e102fee94e635", "html_url": "https://github.com/rust-lang/rust/commit/c703ff275fd84bd44b6618a8a59e102fee94e635"}, {"sha": "b577b9aef357398252bfff630d69efabfceb50e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b577b9aef357398252bfff630d69efabfceb50e8", "html_url": "https://github.com/rust-lang/rust/commit/b577b9aef357398252bfff630d69efabfceb50e8"}], "stats": {"total": 149, "additions": 105, "deletions": 44}, "files": [{"sha": "44cdb5e8a3676b23e6ead56ebedbdcf7ff9cf5f5", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=bd7ce71aabfcd851b94a097060643c056a9b0659", "patch": "@@ -73,7 +73,9 @@ pub struct FormatSpec<'a> {\n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Position<'a> {\n-    /// The argument is located at a specific index.\n+    /// The arugment is implied to be located at an index\n+    ArgumentImplicitlyIs(usize),\n+    /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),\n     /// The argument has a name.\n     ArgumentNamed(&'a str),\n@@ -275,7 +277,7 @@ impl<'a> Parser<'a> {\n             None => {\n                 let i = self.curarg;\n                 self.curarg += 1;\n-                ArgumentIs(i)\n+                ArgumentImplicitlyIs(i)\n             }\n         };\n \n@@ -517,7 +519,7 @@ mod tests {\n     fn format_nothing() {\n         same(\"{}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: fmtdflt(),\n                })]);\n     }\n@@ -595,7 +597,7 @@ mod tests {\n     fn format_counts() {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -607,7 +609,7 @@ mod tests {\n                })]);\n         same(\"{:10$.10s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -619,7 +621,7 @@ mod tests {\n                })]);\n         same(\"{:.*s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(1),\n+                   position: ArgumentImplicitlyIs(1),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -631,7 +633,7 @@ mod tests {\n                })]);\n         same(\"{:.10$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -643,7 +645,7 @@ mod tests {\n                })]);\n         same(\"{:a$.b$s}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -658,7 +660,7 @@ mod tests {\n     fn format_flags() {\n         same(\"{:-}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,\n@@ -670,7 +672,7 @@ mod tests {\n                })]);\n         same(\"{:+#}\",\n              &[NextArgument(Argument {\n-                   position: ArgumentIs(0),\n+                   position: ArgumentImplicitlyIs(0),\n                    format: FormatSpec {\n                        fill: None,\n                        align: AlignUnknown,"}, {"sha": "16e200d56f9fbe3c4c584225cb3f823b25c83b9a", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=bd7ce71aabfcd851b94a097060643c056a9b0659", "patch": "@@ -254,7 +254,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                         }\n                     },\n                     // `{:1}` and `{}` are not to be used\n-                    Position::ArgumentIs(_) => {\n+                    Position::ArgumentIs(_) | Position::ArgumentImplicitlyIs(_) => {\n                         span_err!(tcx.sess, span, E0231,\n                                   \"only named substitution \\\n                                    parameters are allowed\");"}, {"sha": "ad5bd39a45341f4bda51a3b9724465eee60dc3cb", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=bd7ce71aabfcd851b94a097060643c056a9b0659", "patch": "@@ -110,6 +110,8 @@ struct Context<'a, 'b: 'a> {\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n     curarg: usize,\n+    /// Keep track of invalid references to positional arguments\n+    invalid_refs: Vec<usize>,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -226,7 +228,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n-                    parse::ArgumentIs(i) => Exact(i),\n+                    parse::ArgumentIs(i) | parse::ArgumentImplicitlyIs(i) => Exact(i),\n                     parse::ArgumentNamed(s) => Named(s.to_string()),\n                 };\n \n@@ -251,23 +253,54 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     fn describe_num_args(&self) -> String {\n         match self.args.len() {\n-            0 => \"no arguments given\".to_string(),\n+            0 => \"no arguments were given\".to_string(),\n             1 => \"there is 1 argument\".to_string(),\n             x => format!(\"there are {} arguments\", x),\n         }\n     }\n \n+    /// Handle invalid references to positional arguments. Output different\n+    /// errors for the case where all arguments are positional and for when\n+    /// there are named arguments or numbered positional arguments in the\n+    /// format string.\n+    fn report_invalid_references(&self, numbered_position_args: bool) {\n+        let mut e;\n+        let mut refs: Vec<String> = self.invalid_refs\n+                                        .iter()\n+                                        .map(|r| r.to_string())\n+                                        .collect();\n+\n+        if self.names.is_empty() && !numbered_position_args {\n+            e = self.ecx.mut_span_err(self.fmtsp,\n+                &format!(\"{} positional argument{} in format string, but {}\",\n+                         self.pieces.len(),\n+                         if self.pieces.len() > 1 { \"s\" } else { \"\" },\n+                         self.describe_num_args()));\n+        } else {\n+            let arg_list = match refs.len() {\n+                1 => format!(\"argument {}\", refs.pop().unwrap()),\n+                _ => format!(\"arguments {head} and {tail}\",\n+                             tail=refs.pop().unwrap(),\n+                             head=refs.join(\", \"))\n+            };\n+\n+            e = self.ecx.mut_span_err(self.fmtsp,\n+                &format!(\"invalid reference to positional {} ({})\",\n+                        arg_list,\n+                        self.describe_num_args()));\n+            e.note(\"positional arguments are zero-based\");\n+        };\n+\n+        e.emit();\n+    }\n+\n     /// Actually verifies and tracks a given format placeholder\n     /// (a.k.a. argument).\n     fn verify_arg_type(&mut self, arg: Position, ty: ArgumentType) {\n         match arg {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n-                    let msg = format!(\"invalid reference to argument `{}` ({})\",\n-                                      arg,\n-                                      self.describe_num_args());\n-\n-                    self.ecx.span_err(self.fmtsp, &msg[..]);\n+                    self.invalid_refs.push(arg);\n                     return;\n                 }\n                 match ty {\n@@ -403,7 +436,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                         }\n                     };\n                     match arg.position {\n-                        parse::ArgumentIs(i) => {\n+                        parse::ArgumentIs(i)\n+                        | parse::ArgumentImplicitlyIs(i) => {\n                             // Map to index in final generated argument array\n                             // in case of multiple types specified\n                             let arg_idx = match arg_index_consumed.get_mut(i) {\n@@ -691,6 +725,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         all_pieces_simple: true,\n         macsp,\n         fmtsp: fmt.span,\n+        invalid_refs: Vec::new(),\n     };\n \n     let fmt_str = &*fmt.node.0.as_str();\n@@ -711,6 +746,18 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         }\n     }\n \n+    let numbered_position_args = pieces.iter().any(|arg: &parse::Piece| {\n+        match *arg {\n+            parse::String(_) => false,\n+            parse::NextArgument(arg) => {\n+                match arg.position {\n+                    parse::Position::ArgumentIs(_) => true,\n+                    _ => false,\n+                }\n+            }\n+        }\n+    });\n+\n     cx.build_index_map();\n \n     let mut arg_index_consumed = vec![0usize; cx.arg_index_map.len()];\n@@ -736,6 +783,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         cx.str_pieces.push(s);\n     }\n \n+    if cx.invalid_refs.len() >= 1 {\n+        cx.report_invalid_references(numbered_position_args);\n+    }\n+\n     // Make sure that all arguments were used and all arguments have types.\n     let num_pos_args = cx.args.len() - cx.names.len();\n     let mut errs = vec![];"}, {"sha": "afe9bc152a36ce5321a5151388be59e7e628b8ff", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=bd7ce71aabfcd851b94a097060643c056a9b0659", "patch": "@@ -11,36 +11,44 @@\n fn main() {\n     // bad arguments to the format! call\n \n-    format!(\"{}\");            //~ ERROR: invalid reference to argument\n+    // bad number of arguments, see #44954 (originally #15780)\n \n-    format!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n-                            //~^ ERROR: argument never used\n-    format!(\"{foo}\");         //~ ERROR: no argument named `foo`\n+    format!(\"{}\");\n+    //~^ ERROR: 1 positional argument in format string, but no arguments were given\n \n-    format!(\"\", 1, 2);                 //~ ERROR: multiple unused formatting arguments\n-    format!(\"{}\", 1, 2);               //~ ERROR: argument never used\n-    format!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n-    format!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n-    format!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n-    format!(\"\", foo=2);                //~ ERROR: named argument never used\n+    format!(\"{1}\", 1);\n+    //~^ ERROR: invalid reference to positional argument 1 (there is 1 argument)\n+    //~^^ ERROR: argument never used\n \n-    format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n-    format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n-\n-    // bad number of arguments, see #15780\n-\n-    format!(\"{0}\");\n-    //~^ ERROR invalid reference to argument `0` (no arguments given)\n+    format!(\"{} {}\");\n+    //~^ ERROR: 2 positional arguments in format string, but no arguments were given\n \n     format!(\"{0} {1}\", 1);\n-    //~^ ERROR invalid reference to argument `1` (there is 1 argument)\n+    //~^ ERROR: invalid reference to positional argument 1 (there is 1 argument)\n \n     format!(\"{0} {1} {2}\", 1, 2);\n-    //~^ ERROR invalid reference to argument `2` (there are 2 arguments)\n-\n-    format!(\"{0} {1}\");\n-    //~^ ERROR invalid reference to argument `0` (no arguments given)\n-    //~^^ ERROR invalid reference to argument `1` (no arguments given)\n+    //~^ ERROR: invalid reference to positional argument 2 (there are 2 arguments)\n+\n+    format!(\"{} {value} {} {}\", 1, value=2);\n+    //~^ ERROR: invalid reference to positional argument 2 (there are 2 arguments)\n+    format!(\"{name} {value} {} {} {} {} {} {}\", 0, name=1, value=2);\n+    //~^ ERROR: invalid reference to positional arguments 3, 4 and 5 (there are 3 arguments)\n+\n+    format!(\"{} {foo} {} {bar} {}\", 1, 2, 3);\n+    //~^ ERROR: there is no argument named `foo`\n+    //~^^ ERROR: there is no argument named `bar`\n+\n+    format!(\"{foo}\");                //~ ERROR: no argument named `foo`\n+    format!(\"\", 1, 2);               //~ ERROR: multiple unused formatting arguments\n+    format!(\"{}\", 1, 2);             //~ ERROR: argument never used\n+    format!(\"{1}\", 1, 2);            //~ ERROR: argument never used\n+    format!(\"{}\", 1, foo=2);         //~ ERROR: named argument never used\n+    format!(\"{foo}\", 1, foo=2);      //~ ERROR: argument never used\n+    format!(\"\", foo=2);              //~ ERROR: named argument never used\n+    format!(\"{} {}\", 1, 2, foo=1, bar=2);  //~ ERROR: multiple unused formatting arguments\n+\n+    format!(\"{foo}\", foo=1, foo=2);  //~ ERROR: duplicate argument\n+    format!(\"\", foo=1, 2);           //~ ERROR: positional arguments cannot follow\n \n     // bad named arguments, #35082\n "}, {"sha": "4dad6d60b402ea2172c52fe359e0cebbe43eedce", "filename": "src/test/ui/cross-crate-macro-backtrace/main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-crate-macro-backtrace%2Fmain.stderr?ref=bd7ce71aabfcd851b94a097060643c056a9b0659", "patch": "@@ -1,4 +1,4 @@\n-error: invalid reference to argument `0` (no arguments given)\n+error: 1 positional argument in format string, but no arguments were given\n   --> $DIR/main.rs:16:5\n    |\n 16 |     myprintln!(\"{}\"); //~ ERROR in this macro"}, {"sha": "3e782294484e795570a7d284e9c876bd0a849b2b", "filename": "src/test/ui/macros/macro-backtrace-println.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bd7ce71aabfcd851b94a097060643c056a9b0659/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-println.stderr?ref=bd7ce71aabfcd851b94a097060643c056a9b0659", "patch": "@@ -1,4 +1,4 @@\n-error: invalid reference to argument `0` (no arguments given)\n+error: 1 positional argument in format string, but no arguments were given\n   --> $DIR/macro-backtrace-println.rs:24:30\n    |\n 24 |     ($fmt:expr) => (myprint!(concat!($fmt, \"/n\")));"}]}