{"sha": "136db2235a754f91f8a0a6bf6d985d77fe97f8db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNmRiMjIzNWE3NTRmOTFmOGEwYTZiZjZkOTg1ZDc3ZmU5N2Y4ZGI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-13T20:56:42Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-15T17:41:45Z"}, "message": "hygiene: `ExpnInfo` -> `ExpnData`\n\nFor naming consistency with everything else in this area", "tree": {"sha": "1f729b931206bea42dfcd2aa6eb12dd060688553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f729b931206bea42dfcd2aa6eb12dd060688553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/136db2235a754f91f8a0a6bf6d985d77fe97f8db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/136db2235a754f91f8a0a6bf6d985d77fe97f8db", "html_url": "https://github.com/rust-lang/rust/commit/136db2235a754f91f8a0a6bf6d985d77fe97f8db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/136db2235a754f91f8a0a6bf6d985d77fe97f8db/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650f19aeae94eff687382859603929cd2dd463bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/650f19aeae94eff687382859603929cd2dd463bc", "html_url": "https://github.com/rust-lang/rust/commit/650f19aeae94eff687382859603929cd2dd463bc"}], "stats": {"total": 336, "additions": 168, "deletions": 168}, "files": [{"sha": "0f6e834ca26df730518044e7c615e0ed91808b86", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -67,7 +67,7 @@ use syntax::errors;\n use syntax::ext::base::SpecialDerives;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n-use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n+use syntax::source_map::{respan, ExpnData, ExpnKind, DesugaringKind, Spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n@@ -704,9 +704,9 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.fresh_expansion(ExpnInfo {\n+        span.fresh_expansion(ExpnData {\n             allow_internal_unstable,\n-            ..ExpnInfo::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n+            ..ExpnData::default(ExpnKind::Desugaring(reason), span, self.sess.edition())\n         })\n     }\n "}, {"sha": "e77faea1e4c5855989ae6bf152c21b0af25510a3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -370,7 +370,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n                 }\n \n                 let mut hasher = StableHasher::new();\n-                expn_id.expn_info().hash_stable(hcx, &mut hasher);\n+                expn_id.expn_data().hash_stable(hcx, &mut hasher);\n                 let sub_hash: Fingerprint = hasher.finish();\n                 let sub_hash = sub_hash.to_smaller_hash();\n                 cache.borrow_mut().insert(expn_id, sub_hash);"}, {"sha": "7003f71c8baa06ae1e02e8f3946b9d4d141d6e80", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -397,7 +397,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n     Opaque,\n });\n \n-impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n+impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     kind,\n     parent -> _,\n     call_site,"}, {"sha": "be73b305e2c50bd56d68f1c8b2cf9a1143e0556c", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -227,10 +227,10 @@ impl EarlyLintPass for LintPassImpl {\n         if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n-                    let expn_info = lint_pass.path.span.ctxt().outer_expn_info();\n-                    let call_site = expn_info.call_site;\n-                    if expn_info.kind.descr() != sym::impl_lint_pass &&\n-                       call_site.ctxt().outer_expn_info().kind.descr() != sym::declare_lint_pass {\n+                    let expn_data = lint_pass.path.span.ctxt().outer_expn_data();\n+                    let call_site = expn_data.call_site;\n+                    if expn_data.kind.descr() != sym::impl_lint_pass &&\n+                       call_site.ctxt().outer_expn_data().kind.descr() != sym::declare_lint_pass {\n                         cx.struct_span_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,"}, {"sha": "2b58627cdea563544c5d24a958ea88dd74a0aa28", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -885,16 +885,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// This is used to test whether a lint should not even begin to figure out whether it should\n /// be reported on the current node.\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let expn_info = span.ctxt().outer_expn_info();\n-    match expn_info.kind {\n+    let expn_data = span.ctxt().outer_expn_data();\n+    match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n         ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if expn_info.def_site.is_dummy() {\n+            if expn_data.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro\n                 return true;\n             }\n-            match sess.source_map().span_to_snippet(expn_info.def_site) {\n+            match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n                 // no snippet = external macro or compiler-builtin expansion\n                 Err(_) => true,\n@@ -906,7 +906,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_info().kind {\n+    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n         return true;\n     }\n     false"}, {"sha": "ba92e851141a655cd929964c0a9d8b29096f39b8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -61,9 +61,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // We want to ignore desugarings here: spans are equivalent even\n             // if one is the result of a desugaring and the other is not.\n             let mut span = error.obligation.cause.span;\n-            let expn_info = span.ctxt().outer_expn_info();\n-            if let ExpnKind::Desugaring(_) = expn_info.kind {\n-                span = expn_info.call_site;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n             }\n \n             error_map.entry(span).or_default().push("}, {"sha": "8bf01970eb592f13464fd43efc6a3f8c6e788ee1", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -23,16 +23,16 @@ use std::mem;\n use syntax::ast::NodeId;\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnInfo};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n const TAG_CLEAR_CROSS_CRATE_CLEAR: u8 = 0;\n const TAG_CLEAR_CROSS_CRATE_SET: u8 = 1;\n \n-const TAG_NO_EXPANSION_INFO: u8 = 0;\n-const TAG_EXPANSION_INFO_SHORTHAND: u8 = 1;\n-const TAG_EXPANSION_INFO_INLINE: u8 = 2;\n+const TAG_NO_EXPN_DATA: u8 = 0;\n+const TAG_EXPN_DATA_SHORTHAND: u8 = 1;\n+const TAG_EXPN_DATA_INLINE: u8 = 2;\n \n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n@@ -58,7 +58,7 @@ pub struct OnDiskCache<'sess> {\n \n     // These two fields caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n-    synthetic_expansion_infos: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n     // A map from dep-node to the position of the cached query result in\n     // `serialized_data`.\n@@ -135,7 +135,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: footer.query_result_index.into_iter().collect(),\n             prev_diagnostics_index: footer.diagnostics_index.into_iter().collect(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(footer.interpret_alloc_index),\n         }\n     }\n@@ -151,7 +151,7 @@ impl<'sess> OnDiskCache<'sess> {\n             current_diagnostics: Default::default(),\n             query_result_index: Default::default(),\n             prev_diagnostics_index: Default::default(),\n-            synthetic_expansion_infos: Default::default(),\n+            synthetic_syntax_contexts: Default::default(),\n             alloc_decoding_state: AllocDecodingState::new(Vec::new()),\n         }\n     }\n@@ -185,7 +185,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encoder,\n                 type_shorthands: Default::default(),\n                 predicate_shorthands: Default::default(),\n-                expn_info_shorthands: Default::default(),\n+                expn_data_shorthands: Default::default(),\n                 interpret_allocs: Default::default(),\n                 interpret_allocs_inverse: Vec::new(),\n                 source_map: CachingSourceMapView::new(tcx.sess.source_map()),\n@@ -383,7 +383,7 @@ impl<'sess> OnDiskCache<'sess> {\n             cnum_map: self.cnum_map.get(),\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_expansion_infos: &self.synthetic_expansion_infos,\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n@@ -440,7 +440,7 @@ struct CacheDecoder<'a, 'tcx> {\n     opaque: opaque::Decoder<'a>,\n     source_map: &'a SourceMap,\n     cnum_map: &'a IndexVec<CrateNum, Option<CrateNum>>,\n-    synthetic_expansion_infos: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n+    synthetic_syntax_contexts: &'a Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n     file_index_to_file: &'a Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     file_index_to_stable_id: &'a FxHashMap<SourceFileIndex, StableSourceFileId>,\n     alloc_decoding_session: AllocDecodingSession<'a>,\n@@ -586,37 +586,37 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         let lo = file_lo.lines[line_lo - 1] + col_lo;\n         let hi = lo + len;\n \n-        let expn_info_tag = u8::decode(self)?;\n+        let expn_data_tag = u8::decode(self)?;\n \n-        // FIXME(mw): This method does not restore `ExpnInfo::parent` or\n+        // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n         // as long as incremental compilation does not kick in before that.\n         let location = || Span::with_root_ctxt(lo, hi);\n-        let recover_from_expn_info = |this: &Self, expn_info, pos| {\n-            let span = location().fresh_expansion(expn_info);\n-            this.synthetic_expansion_infos.borrow_mut().insert(pos, span.ctxt());\n+        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n+            let span = location().fresh_expansion(expn_data);\n+            this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n-        Ok(match expn_info_tag {\n-            TAG_NO_EXPANSION_INFO => {\n+        Ok(match expn_data_tag {\n+            TAG_NO_EXPN_DATA => {\n                 location()\n             }\n-            TAG_EXPANSION_INFO_INLINE => {\n-                let expn_info = Decodable::decode(self)?;\n-                recover_from_expn_info(\n-                    self, expn_info, AbsoluteBytePos::new(self.opaque.position())\n+            TAG_EXPN_DATA_INLINE => {\n+                let expn_data = Decodable::decode(self)?;\n+                recover_from_expn_data(\n+                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n-            TAG_EXPANSION_INFO_SHORTHAND => {\n+            TAG_EXPN_DATA_SHORTHAND => {\n                 let pos = AbsoluteBytePos::decode(self)?;\n-                let cached_ctxt = self.synthetic_expansion_infos.borrow().get(&pos).cloned();\n+                let cached_ctxt = self.synthetic_syntax_contexts.borrow().get(&pos).cloned();\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_info =\n-                        self.with_position(pos.to_usize(), |this| ExpnInfo::decode(this))?;\n-                    recover_from_expn_info(self, expn_info, pos)\n+                    let expn_data =\n+                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, pos)\n                 }\n             }\n             _ => {\n@@ -725,7 +725,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n-    expn_info_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n+    expn_data_shorthands: FxHashMap<ExpnId, AbsoluteBytePos>,\n     interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n     interpret_allocs_inverse: Vec<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n@@ -817,17 +817,17 @@ where\n         len.encode(self)?;\n \n         if span_data.ctxt == SyntaxContext::root() {\n-            TAG_NO_EXPANSION_INFO.encode(self)\n+            TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();\n-            if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n-                TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n+            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n+                TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n                 pos.encode(self)\n             } else {\n-                TAG_EXPANSION_INFO_INLINE.encode(self)?;\n+                TAG_EXPN_DATA_INLINE.encode(self)?;\n                 let pos = AbsoluteBytePos::new(self.position());\n-                self.expn_info_shorthands.insert(expn_id, pos);\n-                expn_info.encode(self)\n+                self.expn_data_shorthands.insert(expn_id, pos);\n+                expn_data.encode(self)\n             }\n         }\n     }"}, {"sha": "eec098426239c4550301a065bc5e3ad0d41aac7b", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -1775,7 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    sess.span_err(ExpnId::from_u32(cookie).expn_info().call_site, &msg)\n+                    sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();"}, {"sha": "90e467713968bd07fdfc31f47ec2239453deebaa", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -517,7 +517,7 @@ impl EarlyLintPass for UnusedParens {\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n                 // an expression in another and used as a fn/method argument (Issue #47775)\n-                if e.span.ctxt().outer_expn_info().call_site.from_expansion() {\n+                if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n                     return;\n                 }\n                 let msg = format!(\"{} argument\", call_kind);"}, {"sha": "2ca8771cda6a1049e2e855b6366de6097813e203", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -17,7 +17,7 @@ use syntax::edition::Edition;\n use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n+use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, is_builtin_attr_name};\n use syntax::feature_gate::GateIssue;\n@@ -97,7 +97,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     }\n \n     fn get_module_scope(&mut self, id: ast::NodeId) -> ExpnId {\n-        let expn_id = ExpnId::fresh(Some(ExpnInfo::default(\n+        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n             ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n         )));\n         let module = self.module_map[&self.definitions.local_def_id(id)];\n@@ -185,8 +185,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let (ext, res) = self.smart_resolve_macro_path(path, kind, parent_scope, force)?;\n \n         let span = invoc.span();\n-        invoc.expansion_data.id.set_expn_info(\n-            ext.expn_info(parent_scope.expansion, span, fast_print_path(path))\n+        invoc.expansion_data.id.set_expn_data(\n+            ext.expn_data(parent_scope.expansion, span, fast_print_path(path))\n         );\n \n         if let Res::Def(_, def_id) = res {\n@@ -302,7 +302,7 @@ impl<'a> Resolver<'a> {\n \n         // Possibly apply the macro helper hack\n         if kind == Some(MacroKind::Bang) && path.len() == 1 &&\n-           path[0].ident.span.ctxt().outer_expn_info().local_inner_macros {\n+           path[0].ident.span.ctxt().outer_expn_data().local_inner_macros {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));\n         }"}, {"sha": "fb1bf4d7160e7e2ed7e576fa808a3d8699ee1e69", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -15,7 +15,7 @@ use crate::tokenstream::{self, TokenStream, TokenTree};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -640,8 +640,8 @@ impl SyntaxExtension {\n         SyntaxExtension::default(SyntaxExtensionKind::NonMacroAttr { mark_used }, edition)\n     }\n \n-    pub fn expn_info(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnInfo {\n-        ExpnInfo {\n+    pub fn expn_data(&self, parent: ExpnId, call_site: Span, descr: Symbol) -> ExpnData {\n+        ExpnData {\n             kind: ExpnKind::Macro(self.macro_kind(), descr),\n             parent,\n             call_site,\n@@ -708,7 +708,7 @@ pub struct ExpansionData {\n \n /// One of these is made during expansion and incrementally updated as we go;\n /// when a macro expansion occurs, the resulting nodes have the `backtrace()\n-/// -> expn_info` of their expansion context stored into their span.\n+/// -> expn_data` of their expansion context stored into their span.\n pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n@@ -757,7 +757,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        self.current_expansion.id.expn_info().call_site\n+        self.current_expansion.id.expn_data().call_site\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n         SyntaxContext::root().apply_mark(self.current_expansion.id)\n@@ -770,13 +770,13 @@ impl<'a> ExtCtxt<'a> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            let expn_info = ctxt.outer_expn_info();\n+            let expn_data = ctxt.outer_expn_data();\n             // Stop going up the backtrace once include! is encountered\n-            if expn_info.is_root() || expn_info.kind.descr() == sym::include {\n+            if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n                 break;\n             }\n-            ctxt = expn_info.call_site.ctxt();\n-            last_macro = Some(expn_info.call_site);\n+            ctxt = expn_data.call_site.ctxt();\n+            last_macro = Some(expn_data.call_site);\n         }\n         last_macro\n     }"}, {"sha": "e7deadbc9a043d0d9c5ee652efe1b8a035872f2e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -5,7 +5,7 @@ use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::proc_macro::collect_derives;\n-use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n+use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n@@ -475,11 +475,11 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.id.expn_info();\n+            let expn_data = self.cx.current_expansion.id.expn_data();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n-            let mut err = self.cx.struct_span_err(info.call_site,\n+            let mut err = self.cx.struct_span_err(expn_data.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                         info.kind.descr()));\n+                         expn_data.kind.descr()));\n             err.help(&format!(\n                 \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                 suggested_limit));\n@@ -796,20 +796,20 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        // Expansion info for all the collected invocations is set upon their resolution,\n+        // Expansion data for all the collected invocations is set upon their resolution,\n         // with exception of the derive container case which is not resolved and can get\n-        // its expansion info immediately.\n-        let expn_info = match &kind {\n-            InvocationKind::DeriveContainer { item, .. } => Some(ExpnInfo {\n+        // its expansion data immediately.\n+        let expn_data = match &kind {\n+            InvocationKind::DeriveContainer { item, .. } => Some(ExpnData {\n                 parent: self.cx.current_expansion.id,\n-                ..ExpnInfo::default(\n+                ..ExpnData::default(\n                     ExpnKind::Macro(MacroKind::Attr, sym::derive),\n                     item.span(), self.cx.parse_sess.edition,\n                 )\n             }),\n             _ => None,\n         };\n-        let expn_id = ExpnId::fresh(expn_info);\n+        let expn_id = ExpnId::fresh(expn_data);\n         self.invocations.push(Invocation {\n             kind,\n             fragment_kind,"}, {"sha": "1619fa6994198efb139dcd6d3c9981b3ce7be439", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -362,7 +362,7 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_info().call_site;\n+        let location = cx.current_expansion.id.expn_data().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n                 SyntaxContext::root()"}, {"sha": "26f78b9c5c78441b9089b2942fe1e8a34196120e", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -87,7 +87,7 @@ impl ParseSess {\n             included_mod_stack: Lock::new(vec![]),\n             source_map,\n             buffered_lints: Lock::new(vec![]),\n-            edition: ExpnId::root().expn_info().edition,\n+            edition: ExpnId::root().expn_data().edition,\n             ambiguous_block_expr_parse: Lock::new(FxHashMap::default()),\n             param_attr_spans: Lock::new(Vec::new()),\n             let_chains_spans: Lock::new(Vec::new()),"}, {"sha": "940687cb5d4e447b6f7d3e4ce75092b02424f2e2", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -8,7 +8,7 @@\n //! information, source code snippets, etc.\n \n pub use syntax_pos::*;\n-pub use syntax_pos::hygiene::{ExpnKind, ExpnInfo};\n+pub use syntax_pos::hygiene::{ExpnKind, ExpnData};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n@@ -29,15 +29,15 @@ mod tests;\n \n /// Returns the span itself if it doesn't come from a macro expansion,\n /// otherwise return the call site span up to the `enclosing_sp` by\n-/// following the `expn_info` chain.\n+/// following the `expn_data` chain.\n pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    let expn_info1 = sp.ctxt().outer_expn_info();\n-    let expn_info2 = enclosing_sp.ctxt().outer_expn_info();\n-    if expn_info1.is_root() ||\n-       !expn_info2.is_root() && expn_info1.call_site == expn_info2.call_site {\n+    let expn_data1 = sp.ctxt().outer_expn_data();\n+    let expn_data2 = enclosing_sp.ctxt().outer_expn_data();\n+    if expn_data1.is_root() ||\n+       !expn_data2.is_root() && expn_data1.call_site == expn_data2.call_site {\n         sp\n     } else {\n-        original_sp(expn_info1.call_site, enclosing_sp)\n+        original_sp(expn_data1.call_site, enclosing_sp)\n     }\n }\n "}, {"sha": "d030ea4a56ebb8b49ca4657a9a5fd6b0029db336", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                    let container_id = cx.current_expansion.id.expn_info().parent;\n+                    let container_id = cx.current_expansion.id.expn_data().parent;\n                     if cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                         !params.iter().any(|param| match param.kind {\n                             ast::GenericParamKind::Type { .. } => true,"}, {"sha": "54027c600b4cd714202ff9a6e39b5e1b6d07bf0b", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -13,7 +13,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut dyn FnMut(Annotatable)) {\n-    cx.resolver.add_derives(cx.current_expansion.id.expn_info().parent, SpecialDerives::EQ);\n+    cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::EQ);\n \n     let inline = cx.meta_word(span, sym::inline);\n     let hidden = cx.meta_list_item_word(span, sym::hidden);"}, {"sha": "91e1e80e4fbfa1347da4ee6a009eefbd76f66f18", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -13,7 +13,7 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   mitem: &MetaItem,\n                                   item: &Annotatable,\n                                   push: &mut dyn FnMut(Annotatable)) {\n-    cx.resolver.add_derives(cx.current_expansion.id.expn_info().parent, SpecialDerives::PARTIAL_EQ);\n+    cx.resolver.add_derives(cx.current_expansion.id.expn_data().parent, SpecialDerives::PARTIAL_EQ);\n \n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different"}, {"sha": "55fb7677038ba6223b38d05e71dc1d0f38384a5c", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -425,7 +425,7 @@ impl<'a> TraitDef<'a> {\n                         return;\n                     }\n                 };\n-                let container_id = cx.current_expansion.id.expn_info().parent;\n+                let container_id = cx.current_expansion.id.expn_data().parent;\n                 let is_always_copy =\n                     cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                     has_no_type_params;"}, {"sha": "dbfd8fe98f38999c582f1d935de57a54fcc85cd0", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax::tokenstream::*;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnInfo, ExpnKind, MacroKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind, MacroKind};\n \n use std::mem;\n \n@@ -43,7 +43,7 @@ pub fn inject(\n ) {\n     if !named_exts.is_empty() {\n         let mut extra_items = Vec::new();\n-        let span = DUMMY_SP.fresh_expansion(ExpnInfo::allow_unstable(\n+        let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n             ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n             [sym::rustc_attrs][..].into(),\n         ));"}, {"sha": "e772eaf834964359b8870fb081390517c48cf262", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -3,7 +3,7 @@ use std::mem;\n use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n+use syntax::source_map::{ExpnData, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n@@ -327,7 +327,7 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n         [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n     ));"}, {"sha": "8ca376341fcdb7b72f6016c6ddbfa93bfe101f83", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -2,7 +2,7 @@ use syntax::{ast, attr};\n use syntax::edition::Edition;\n use syntax::ext::hygiene::MacroKind;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned, respan};\n+use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned, respan};\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n@@ -55,7 +55,7 @@ pub fn inject(\n     // the prelude.\n     let name = names[0];\n \n-    let span = DUMMY_SP.fresh_expansion(ExpnInfo::allow_unstable(\n+    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n         [sym::prelude_import][..].into(),\n     ));"}, {"sha": "4a6ea0ebf85e5b6fc5c0f215c754ee16a06b2419", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -11,7 +11,7 @@ use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnInfo, ExpnKind, dummy_spanned};\n+use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned};\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n@@ -268,7 +268,7 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     //            #![main]\n     //            test::test_main_static(&[..tests]);\n     //        }\n-    let sp = DUMMY_SP.fresh_expansion(ExpnInfo::allow_unstable(\n+    let sp = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n         ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n         [sym::main, sym::test, sym::rustc_attrs][..].into(),\n     ));"}, {"sha": "87d930f897afc45d817c03c478887b308ddf0980", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -13,8 +13,8 @@\n //\n // This explains why `HygieneData`, `SyntaxContext` and `ExpnId` have interfaces\n // with a certain amount of redundancy in them. For example,\n-// `SyntaxContext::outer_expn_info` combines `SyntaxContext::outer` and\n-// `ExpnId::expn_info` so that two `HygieneData` accesses can be performed within\n+// `SyntaxContext::outer_expn_data` combines `SyntaxContext::outer` and\n+// `ExpnId::expn_data` so that two `HygieneData` accesses can be performed within\n // a single `HygieneData::with` call.\n //\n // It also explains why many functions appear in `HygieneData` and again in\n@@ -76,8 +76,8 @@ pub enum Transparency {\n }\n \n impl ExpnId {\n-    pub fn fresh(expn_info: Option<ExpnInfo>) -> Self {\n-        HygieneData::with(|data| data.fresh_expn(expn_info))\n+    pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n+        HygieneData::with(|data| data.fresh_expn(expn_data))\n     }\n \n     /// The ID of the theoretical expansion that generates freshly parsed, unexpanded AST.\n@@ -97,16 +97,16 @@ impl ExpnId {\n     }\n \n     #[inline]\n-    pub fn expn_info(self) -> ExpnInfo {\n-        HygieneData::with(|data| data.expn_info(self).clone())\n+    pub fn expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(self).clone())\n     }\n \n     #[inline]\n-    pub fn set_expn_info(self, info: ExpnInfo) {\n+    pub fn set_expn_data(self, expn_data: ExpnData) {\n         HygieneData::with(|data| {\n-            let old_info = &mut data.expn_data[self.0 as usize];\n-            assert!(old_info.is_none(), \"expansion info is reset for an expansion ID\");\n-            *old_info = Some(info);\n+            let old_expn_data = &mut data.expn_data[self.0 as usize];\n+            assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n+            *old_expn_data = Some(expn_data);\n         })\n     }\n \n@@ -124,9 +124,9 @@ impl ExpnId {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            let expn_info = data.expn_info(self);\n-            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_info.kind {\n-                return expn_info.default_transparency == Transparency::Opaque;\n+            let expn_data = data.expn_data(self);\n+            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_data.kind {\n+                return expn_data.default_transparency == Transparency::Opaque;\n             }\n             false\n         })\n@@ -135,18 +135,18 @@ impl ExpnId {\n \n #[derive(Debug)]\n crate struct HygieneData {\n-    /// Each expansion should have an associated expansion info, but sometimes there's a delay\n-    /// between creation of an expansion ID and obtaining its info (e.g. macros are collected\n+    /// Each expansion should have an associated expansion data, but sometimes there's a delay\n+    /// between creation of an expansion ID and obtaining its data (e.g. macros are collected\n     /// first and then resolved later), so we use an `Option` here.\n-    expn_data: Vec<Option<ExpnInfo>>,\n+    expn_data: Vec<Option<ExpnData>>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n }\n \n impl HygieneData {\n     crate fn new(edition: Edition) -> Self {\n         HygieneData {\n-            expn_data: vec![Some(ExpnInfo::default(ExpnKind::Root, DUMMY_SP, edition))],\n+            expn_data: vec![Some(ExpnData::default(ExpnKind::Root, DUMMY_SP, edition))],\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n                 outer_transparency: Transparency::Opaque,\n@@ -163,22 +163,22 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn fresh_expn(&mut self, expn_info: Option<ExpnInfo>) -> ExpnId {\n-        self.expn_data.push(expn_info);\n+    fn fresh_expn(&mut self, expn_data: Option<ExpnData>) -> ExpnId {\n+        self.expn_data.push(expn_data);\n         ExpnId(self.expn_data.len() as u32 - 1)\n     }\n \n-    fn expn_info(&self, expn_id: ExpnId) -> &ExpnInfo {\n+    fn expn_data(&self, expn_id: ExpnId) -> &ExpnData {\n         self.expn_data[expn_id.0 as usize].as_ref()\n-            .expect(\"no expansion info for an expansion ID\")\n+            .expect(\"no expansion data for an expansion ID\")\n     }\n \n     fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n         while expn_id != ancestor {\n             if expn_id == ExpnId::root() {\n                 return false;\n             }\n-            expn_id = self.expn_info(expn_id).parent;\n+            expn_id = self.expn_data(expn_id).parent;\n         }\n         true\n     }\n@@ -221,7 +221,7 @@ impl HygieneData {\n \n     fn walk_chain(&self, mut span: Span, to: SyntaxContext) -> Span {\n         while span.from_expansion() && span.ctxt() != to {\n-            span = self.expn_info(self.outer_expn(span.ctxt())).call_site;\n+            span = self.expn_data(self.outer_expn(span.ctxt())).call_site;\n         }\n         span\n     }\n@@ -237,7 +237,7 @@ impl HygieneData {\n     fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n         self.apply_mark_with_transparency(\n-            ctxt, expn_id, self.expn_info(expn_id).default_transparency\n+            ctxt, expn_id, self.expn_data(expn_id).default_transparency\n         )\n     }\n \n@@ -248,7 +248,7 @@ impl HygieneData {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n-        let call_site_ctxt = self.expn_info(expn_id).call_site.ctxt();\n+        let call_site_ctxt = self.expn_data(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n@@ -540,20 +540,20 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.outer_expn(self))\n     }\n \n-    /// `ctxt.outer_expn_info()` is equivalent to but faster than\n-    /// `ctxt.outer_expn().expn_info()`.\n+    /// `ctxt.outer_expn_data()` is equivalent to but faster than\n+    /// `ctxt.outer_expn().expn_data()`.\n     #[inline]\n-    pub fn outer_expn_info(self) -> ExpnInfo {\n-        HygieneData::with(|data| data.expn_info(data.outer_expn(self)).clone())\n+    pub fn outer_expn_data(self) -> ExpnData {\n+        HygieneData::with(|data| data.expn_data(data.outer_expn(self)).clone())\n     }\n \n-    /// `ctxt.outer_expn_with_info()` is equivalent to but faster than\n-    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_info()) }`.\n+    /// `ctxt.outer_expn_with_data()` is equivalent to but faster than\n+    /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_data()) }`.\n     #[inline]\n-    pub fn outer_expn_with_info(self) -> (ExpnId, ExpnInfo) {\n+    pub fn outer_expn_with_data(self) -> (ExpnId, ExpnData) {\n         HygieneData::with(|data| {\n             let outer = data.outer_expn(self);\n-            (outer, data.expn_info(outer).clone())\n+            (outer, data.expn_data(outer).clone())\n         })\n     }\n \n@@ -574,9 +574,9 @@ impl Span {\n     /// other compiler-generated code to set per-span properties like allowed unstable features.\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n-    pub fn fresh_expansion(self, expn_info: ExpnInfo) -> Span {\n+    pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n         HygieneData::with(|data| {\n-            let expn_id = data.fresh_expn(Some(expn_info));\n+            let expn_id = data.fresh_expn(Some(expn_data));\n             self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id))\n         })\n     }\n@@ -585,7 +585,7 @@ impl Span {\n /// A subset of properties from both macro definition and macro call available through global data.\n /// Avoid using this if you have access to the original definition or call structures.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub struct ExpnInfo {\n+pub struct ExpnData {\n     // --- The part unique to each expansion.\n     /// The kind of this expansion - macro or compiler desugaring.\n     pub kind: ExpnKind,\n@@ -598,7 +598,7 @@ pub struct ExpnInfo {\n     /// `foo!()` invoked `bar!()` internally, and there was an\n     /// expression inside `bar!`; the call_site of the expression in\n     /// the expansion would point to the `bar!` invocation; that\n-    /// call_site span would have its own ExpnInfo, with the call_site\n+    /// call_site span would have its own ExpnData, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n \n@@ -609,7 +609,7 @@ pub struct ExpnInfo {\n     /// The span of the macro definition (possibly dummy).\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Span,\n-    /// Transparency used by `apply_mark` for the expansion with this expansion info by default.\n+    /// Transparency used by `apply_mark` for the expansion with this expansion data by default.\n     pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n@@ -625,10 +625,10 @@ pub struct ExpnInfo {\n     pub edition: Edition,\n }\n \n-impl ExpnInfo {\n-    /// Constructs an expansion info with default properties.\n-    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnInfo {\n-        ExpnInfo {\n+impl ExpnData {\n+    /// Constructs expansion data with default properties.\n+    pub fn default(kind: ExpnKind, call_site: Span, edition: Edition) -> ExpnData {\n+        ExpnData {\n             kind,\n             parent: ExpnId::root(),\n             call_site,\n@@ -642,10 +642,10 @@ impl ExpnInfo {\n     }\n \n     pub fn allow_unstable(kind: ExpnKind, call_site: Span, edition: Edition,\n-                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnInfo {\n-        ExpnInfo {\n+                          allow_internal_unstable: Lrc<[Symbol]>) -> ExpnData {\n+        ExpnData {\n             allow_internal_unstable: Some(allow_internal_unstable),\n-            ..ExpnInfo::default(kind, call_site, edition)\n+            ..ExpnData::default(kind, call_site, edition)\n         }\n     }\n "}, {"sha": "aa36fe27d8ec4dddd786884a44cf6467cce6bae3", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/136db2235a754f91f8a0a6bf6d985d77fe97f8db/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=136db2235a754f91f8a0a6bf6d985d77fe97f8db", "patch": "@@ -21,7 +21,7 @@ use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n-pub use hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind, MacroKind, DesugaringKind};\n+pub use hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind, MacroKind, DesugaringKind};\n \n mod span_encoding;\n pub use span_encoding::{Span, DUMMY_SP};\n@@ -353,20 +353,20 @@ impl Span {\n     /// Returns the source span -- this is either the supplied span, or the span for\n     /// the macro callsite that expanded to it.\n     pub fn source_callsite(self) -> Span {\n-        let expn_info = self.ctxt().outer_expn_info();\n-        if !expn_info.is_root() { expn_info.call_site.source_callsite() } else { self }\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { expn_data.call_site.source_callsite() } else { self }\n     }\n \n     /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,\n     /// if any.\n     pub fn parent(self) -> Option<Span> {\n-        let expn_info = self.ctxt().outer_expn_info();\n-        if !expn_info.is_root() { Some(expn_info.call_site) } else { None }\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { Some(expn_data.call_site) } else { None }\n     }\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer_expn_info().edition\n+        self.ctxt().outer_expn_data().edition\n     }\n \n     #[inline]\n@@ -382,22 +382,22 @@ impl Span {\n     /// Returns the source callee.\n     ///\n     /// Returns `None` if the supplied span has no expansion trace,\n-    /// else returns the `ExpnInfo` for the macro definition\n+    /// else returns the `ExpnData` for the macro definition\n     /// corresponding to the source callsite.\n-    pub fn source_callee(self) -> Option<ExpnInfo> {\n-        fn source_callee(expn_info: ExpnInfo) -> ExpnInfo {\n-            let next_expn_info = expn_info.call_site.ctxt().outer_expn_info();\n-            if !next_expn_info.is_root() { source_callee(next_expn_info) } else { expn_info }\n+    pub fn source_callee(self) -> Option<ExpnData> {\n+        fn source_callee(expn_data: ExpnData) -> ExpnData {\n+            let next_expn_data = expn_data.call_site.ctxt().outer_expn_data();\n+            if !next_expn_data.is_root() { source_callee(next_expn_data) } else { expn_data }\n         }\n-        let expn_info = self.ctxt().outer_expn_info();\n-        if !expn_info.is_root() { Some(source_callee(expn_info)) } else { None }\n+        let expn_data = self.ctxt().outer_expn_data();\n+        if !expn_data.is_root() { Some(source_callee(expn_data)) } else { None }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self, feature: Symbol) -> bool {\n-        self.ctxt().outer_expn_info().allow_internal_unstable.map_or(false, |features| {\n+        self.ctxt().outer_expn_data().allow_internal_unstable.map_or(false, |features| {\n             features.iter().any(|&f| {\n                 f == feature || f == sym::allow_internal_unstable_backcompat_hack\n             })\n@@ -406,7 +406,7 @@ impl Span {\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_desugaring(&self, kind: DesugaringKind) -> bool {\n-        match self.ctxt().outer_expn_info().kind {\n+        match self.ctxt().outer_expn_data().kind {\n             ExpnKind::Desugaring(k) => k == kind,\n             _ => false,\n         }\n@@ -415,7 +415,7 @@ impl Span {\n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n     pub fn desugaring_kind(&self) -> Option<DesugaringKind> {\n-        match self.ctxt().outer_expn_info().kind {\n+        match self.ctxt().outer_expn_data().kind {\n             ExpnKind::Desugaring(k) => Some(k),\n             _ => None\n         }\n@@ -425,20 +425,20 @@ impl Span {\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n-        self.ctxt().outer_expn_info().allow_internal_unsafe\n+        self.ctxt().outer_expn_data().allow_internal_unsafe\n     }\n \n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n         loop {\n-            let info = self.ctxt().outer_expn_info();\n-            if info.is_root() {\n+            let expn_data = self.ctxt().outer_expn_data();\n+            if expn_data.is_root() {\n                 break;\n             }\n             // Don't print recursive invocations.\n-            if !info.call_site.source_equal(&prev_span) {\n-                let (pre, post) = match info.kind {\n+            if !expn_data.call_site.source_equal(&prev_span) {\n+                let (pre, post) = match expn_data.kind {\n                     ExpnKind::Root => break,\n                     ExpnKind::Desugaring(..) => (\"desugaring of \", \"\"),\n                     ExpnKind::Macro(macro_kind, _) => match macro_kind {\n@@ -448,14 +448,14 @@ impl Span {\n                     }\n                 };\n                 result.push(MacroBacktrace {\n-                    call_site: info.call_site,\n-                    macro_decl_name: format!(\"{}{}{}\", pre, info.kind.descr(), post),\n-                    def_site_span: info.def_site,\n+                    call_site: expn_data.call_site,\n+                    macro_decl_name: format!(\"{}{}{}\", pre, expn_data.kind.descr(), post),\n+                    def_site_span: expn_data.def_site,\n                 });\n             }\n \n             prev_span = self;\n-            self = info.call_site;\n+            self = expn_data.call_site;\n         }\n         result\n     }"}]}