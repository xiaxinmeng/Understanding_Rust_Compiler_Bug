{"sha": "e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NzMxYTkyNmM5YTY0MmNhMWRkZjViNTJiYWY0MGUwYTg4NzNkNTM=", "commit": {"author": {"name": "Cau\u00ea Baasch de Souza", "email": "cauebs@pm.me", "date": "2020-10-08T05:17:32Z"}, "committer": {"name": "Cau\u00ea Baasch de Souza", "email": "cauebs@pm.me", "date": "2020-10-24T17:46:56Z"}, "message": "Add large_types_passed_by_value lint\n\nRefactor trivially_copy_pass_by_ref and the new lint into pass_by_ref_or_value module\n\nUpdate stderr of conf_unknown_key test\n\nRename lint to large_types_passed_by_value\n\nIncrease `pass_by_value_size_limit` default value to 256\n\nImprove rules for `large_types_passed_by_value`\n\nImprove tests for `large_types_passed_by_value`\n\nImprove documentation for `large_types_passed_by_value`\n\nMake minor corrections to pass_by_ref_or_value.rs suggested by clippy itself\n\nFix `large_types_passed_by_value` example and improve docs\n\npass_by_ref_or_value: Tweak check for mut annotation in params\n\nlarge_types_passed_by_value: add tests for pub trait, trait impl and inline attributes", "tree": {"sha": "e44754476bfa54b2653876320268d15282f0b7c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e44754476bfa54b2653876320268d15282f0b7c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "html_url": "https://github.com/rust-lang/rust/commit/e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/comments", "author": {"login": "cauebs", "id": 6764500, "node_id": "MDQ6VXNlcjY3NjQ1MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6764500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cauebs", "html_url": "https://github.com/cauebs", "followers_url": "https://api.github.com/users/cauebs/followers", "following_url": "https://api.github.com/users/cauebs/following{/other_user}", "gists_url": "https://api.github.com/users/cauebs/gists{/gist_id}", "starred_url": "https://api.github.com/users/cauebs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cauebs/subscriptions", "organizations_url": "https://api.github.com/users/cauebs/orgs", "repos_url": "https://api.github.com/users/cauebs/repos", "events_url": "https://api.github.com/users/cauebs/events{/privacy}", "received_events_url": "https://api.github.com/users/cauebs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cauebs", "id": 6764500, "node_id": "MDQ6VXNlcjY3NjQ1MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6764500?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cauebs", "html_url": "https://github.com/cauebs", "followers_url": "https://api.github.com/users/cauebs/followers", "following_url": "https://api.github.com/users/cauebs/following{/other_user}", "gists_url": "https://api.github.com/users/cauebs/gists{/gist_id}", "starred_url": "https://api.github.com/users/cauebs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cauebs/subscriptions", "organizations_url": "https://api.github.com/users/cauebs/orgs", "repos_url": "https://api.github.com/users/cauebs/repos", "events_url": "https://api.github.com/users/cauebs/events{/privacy}", "received_events_url": "https://api.github.com/users/cauebs/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf1c6f9871f430e284b17aa44059e0d0395e28a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1c6f9871f430e284b17aa44059e0d0395e28a6", "html_url": "https://github.com/rust-lang/rust/commit/bf1c6f9871f430e284b17aa44059e0d0395e28a6"}], "stats": {"total": 584, "additions": 394, "deletions": 190}, "files": [{"sha": "22f963981538d8bf8478bf6f5f8a249ed2b87e77", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -1779,6 +1779,7 @@ Released 2018-09-13\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n+[`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n [`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n [`len_zero`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_zero\n [`let_and_return`]: https://rust-lang.github.io/rust-clippy/master/index.html#let_and_return"}, {"sha": "1a950a7c334cc0412f7beeaa68b06b7cbb36f20b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -278,6 +278,7 @@ mod overflow_check_conditional;\n mod panic_in_result_fn;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n+mod pass_by_ref_or_value;\n mod path_buf_push_overwrite;\n mod pattern_type_mismatch;\n mod precedence;\n@@ -311,7 +312,6 @@ mod to_string_in_display;\n mod trait_bounds;\n mod transmute;\n mod transmuting_null;\n-mod trivially_copy_pass_by_ref;\n mod try_err;\n mod types;\n mod unicode;\n@@ -776,6 +776,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &panic_unimplemented::UNIMPLEMENTED,\n         &panic_unimplemented::UNREACHABLE,\n         &partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n+        &pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,\n+        &pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF,\n         &path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n         &pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         &precedence::PRECEDENCE,\n@@ -835,7 +837,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &transmute::USELESS_TRANSMUTE,\n         &transmute::WRONG_TRANSMUTE,\n         &transmuting_null::TRANSMUTING_NULL,\n-        &trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF,\n         &try_err::TRY_ERR,\n         &types::ABSURD_EXTREME_COMPARISONS,\n         &types::BORROWED_BOX,\n@@ -1009,11 +1010,12 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box large_enum_variant::LargeEnumVariant::new(enum_variant_size_threshold));\n     store.register_late_pass(|| box explicit_write::ExplicitWrite);\n     store.register_late_pass(|| box needless_pass_by_value::NeedlessPassByValue);\n-    let trivially_copy_pass_by_ref = trivially_copy_pass_by_ref::TriviallyCopyPassByRef::new(\n+    let pass_by_ref_or_value = pass_by_ref_or_value::PassByRefOrValue::new(\n         conf.trivial_copy_size_limit,\n+        conf.pass_by_value_size_limit,\n         &sess.target,\n     );\n-    store.register_late_pass(move || box trivially_copy_pass_by_ref);\n+    store.register_late_pass(move || box pass_by_ref_or_value);\n     store.register_late_pass(|| box try_err::TryErr);\n     store.register_late_pass(|| box use_self::UseSelf);\n     store.register_late_pass(|| box bytecount::ByteCount);\n@@ -1237,13 +1239,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n         LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n+        LintId::of(&pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE),\n+        LintId::of(&pass_by_ref_or_value::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n         LintId::of(&trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n         LintId::of(&trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n-        LintId::of(&trivially_copy_pass_by_ref::TRIVIALLY_COPY_PASS_BY_REF),\n         LintId::of(&types::CAST_LOSSLESS),\n         LintId::of(&types::CAST_POSSIBLE_TRUNCATION),\n         LintId::of(&types::CAST_POSSIBLE_WRAP),"}, {"sha": "28816c3076ddf5f38f3639e19cf563d01adc59e5", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -0,0 +1,256 @@\n+use std::cmp;\n+\n+use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_ast::attr;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::FnKind;\n+use rustc_hir::{BindingAnnotation, Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node, PatKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::Span;\n+use rustc_target::abi::LayoutOf;\n+use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::Target;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by reference, where\n+    /// the argument type is `Copy` and small enough to be more efficient to always\n+    /// pass by value.\n+    ///\n+    /// **Why is this bad?** In many calling conventions instances of structs will\n+    /// be passed through registers if they fit into two or less general purpose\n+    /// registers.\n+    ///\n+    /// **Known problems:** This lint is target register size dependent, it is\n+    /// limited to 32-bit to try and reduce portability problems between 32 and\n+    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n+    /// will be different.\n+    ///\n+    /// The configuration option `trivial_copy_size_limit` can be set to override\n+    /// this limit for a project.\n+    ///\n+    /// This lint attempts to allow passing arguments by reference if a reference\n+    /// to that argument is returned. This is implemented by comparing the lifetime\n+    /// of the argument and return value for equality. However, this can cause\n+    /// false positives in cases involving multiple lifetimes that are bounded by\n+    /// each other.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// // Bad\n+    /// fn foo(v: &u32) {}\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// // Better\n+    /// fn foo(v: u32) {}\n+    /// ```\n+    pub TRIVIALLY_COPY_PASS_BY_REF,\n+    pedantic,\n+    \"functions taking small copyable arguments by reference\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for functions taking arguments by value, where\n+    /// the argument type is `Copy` and large enough to be worth considering\n+    /// passing by reference. Does not trigger if the function is being exported,\n+    /// because that might induce API breakage, if the parameter is declared as mutable,\n+    /// or if the argument is a `self`.\n+    ///\n+    /// **Why is this bad?** Arguments passed by value might result in an unnecessary\n+    /// shallow copy, taking up more space in the stack and requiring a call to\n+    /// `memcpy`, which which can be expensive.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// #[derive(Clone, Copy)]\n+    /// struct TooLarge([u8; 2048]);\n+    ///\n+    /// // Bad\n+    /// fn foo(v: TooLarge) {}\n+    /// ```\n+    /// ```rust\n+    /// #[derive(Clone, Copy)]\n+    /// struct TooLarge([u8; 2048]);\n+    ///\n+    /// // Good\n+    /// fn foo(v: &TooLarge) {}\n+    /// ```\n+    pub LARGE_TYPES_PASSED_BY_VALUE,\n+    pedantic,\n+    \"functions taking large arguments by value\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct PassByRefOrValue {\n+    ref_min_size: u64,\n+    value_max_size: u64,\n+}\n+\n+impl<'tcx> PassByRefOrValue {\n+    pub fn new(ref_min_size: Option<u64>, value_max_size: u64, target: &Target) -> Self {\n+        let ref_min_size = ref_min_size.unwrap_or_else(|| {\n+            let bit_width = u64::from(target.pointer_width);\n+            // Cap the calculated bit width at 32-bits to reduce\n+            // portability problems between 32 and 64-bit targets\n+            let bit_width = cmp::min(bit_width, 32);\n+            #[allow(clippy::integer_division)]\n+            let byte_width = bit_width / 8;\n+            // Use a limit of 2 times the register byte width\n+            byte_width * 2\n+        });\n+\n+        Self {\n+            ref_min_size,\n+            value_max_size,\n+        }\n+    }\n+\n+    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n+        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n+\n+        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n+        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n+\n+        let fn_body = cx.enclosing_body.map(|id| cx.tcx.hir().body(id));\n+\n+        for (index, (input, &ty)) in decl.inputs.iter().zip(fn_sig.inputs()).enumerate() {\n+            // All spans generated from a proc-macro invocation are the same...\n+            match span {\n+                Some(s) if s == input.span => return,\n+                _ => (),\n+            }\n+\n+            match ty.kind() {\n+                ty::Ref(input_lt, ty, Mutability::Not) => {\n+                    // Use lifetimes to determine if we're returning a reference to the\n+                    // argument. In that case we can't switch to pass-by-value as the\n+                    // argument will not live long enough.\n+                    let output_lts = match *fn_sig.output().kind() {\n+                        ty::Ref(output_lt, _, _) => vec![output_lt],\n+                        ty::Adt(_, substs) => substs.regions().collect(),\n+                        _ => vec![],\n+                    };\n+\n+                    if_chain! {\n+                        if !output_lts.contains(&input_lt);\n+                        if is_copy(cx, ty);\n+                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if size <= self.ref_min_size;\n+                        if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n+                        then {\n+                            let value_type = if is_self_ty(decl_ty) {\n+                                \"self\".into()\n+                            } else {\n+                                snippet(cx, decl_ty.span, \"_\").into()\n+                            };\n+                            span_lint_and_sugg(\n+                                cx,\n+                                TRIVIALLY_COPY_PASS_BY_REF,\n+                                input.span,\n+                                &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.ref_min_size),\n+                                \"consider passing by value instead\",\n+                                value_type,\n+                                Applicability::Unspecified,\n+                            );\n+                        }\n+                    }\n+                },\n+\n+                ty::Adt(_, _) | ty::Array(_, _) | ty::Tuple(_) => {\n+                    // if function has a body and parameter is annotated with mut, ignore\n+                    if let Some(param) = fn_body.and_then(|body| body.params.get(index)) {\n+                        match param.pat.kind {\n+                            PatKind::Binding(BindingAnnotation::Unannotated, _, _, _) => {},\n+                            _ => continue,\n+                        }\n+                    }\n+\n+                    if_chain! {\n+                        if !cx.access_levels.is_exported(hir_id);\n+                        if is_copy(cx, ty);\n+                        if !is_self_ty(input);\n+                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if size > self.value_max_size;\n+                        then {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                LARGE_TYPES_PASSED_BY_VALUE,\n+                                input.span,\n+                                &format!(\"this argument ({} byte) is passed by value, but might be more efficient if passed by reference (limit: {} byte)\", size, self.value_max_size),\n+                                \"consider passing by reference instead\",\n+                                format!(\"&{}\", snippet(cx, input.span, \"_\")),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                },\n+\n+                _ => {},\n+            }\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(PassByRefOrValue => [TRIVIALLY_COPY_PASS_BY_REF, LARGE_TYPES_PASSED_BY_VALUE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n+    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+        if item.span.from_expansion() {\n+            return;\n+        }\n+\n+        if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n+            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n+        }\n+    }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl<'_>,\n+        _body: &'tcx Body<'_>,\n+        span: Span,\n+        hir_id: HirId,\n+    ) {\n+        if span.from_expansion() {\n+            return;\n+        }\n+\n+        match kind {\n+            FnKind::ItemFn(.., header, _, attrs) => {\n+                if header.abi != Abi::Rust {\n+                    return;\n+                }\n+                for a in attrs {\n+                    if let Some(meta_items) = a.meta_item_list() {\n+                        if a.has_name(sym!(proc_macro_derive))\n+                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n+                        {\n+                            return;\n+                        }\n+                    }\n+                }\n+            },\n+            FnKind::Method(..) => (),\n+            FnKind::Closure(..) => return,\n+        }\n+\n+        // Exclude non-inherent impls\n+        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n+            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n+            ItemKind::Trait(..))\n+            {\n+                return;\n+            }\n+        }\n+\n+        self.check_poly_fn(cx, hir_id, decl, Some(span));\n+    }\n+}"}, {"sha": "e90ea0fc200a9ab2177f98a9324eece30132094a", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/bf1c6f9871f430e284b17aa44059e0d0395e28a6/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1c6f9871f430e284b17aa44059e0d0395e28a6/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=bf1c6f9871f430e284b17aa44059e0d0395e28a6", "patch": "@@ -1,183 +0,0 @@\n-use std::cmp;\n-\n-use crate::utils::{is_copy, is_self_ty, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_ast::attr;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::intravisit::FnKind;\n-use rustc_hir::{Body, FnDecl, HirId, ItemKind, MutTy, Mutability, Node};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n-use rustc_target::abi::LayoutOf;\n-use rustc_target::spec::abi::Abi;\n-use rustc_target::spec::Target;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for functions taking arguments by reference, where\n-    /// the argument type is `Copy` and small enough to be more efficient to always\n-    /// pass by value.\n-    ///\n-    /// **Why is this bad?** In many calling conventions instances of structs will\n-    /// be passed through registers if they fit into two or less general purpose\n-    /// registers.\n-    ///\n-    /// **Known problems:** This lint is target register size dependent, it is\n-    /// limited to 32-bit to try and reduce portability problems between 32 and\n-    /// 64-bit, but if you are compiling for 8 or 16-bit targets then the limit\n-    /// will be different.\n-    ///\n-    /// The configuration option `trivial_copy_size_limit` can be set to override\n-    /// this limit for a project.\n-    ///\n-    /// This lint attempts to allow passing arguments by reference if a reference\n-    /// to that argument is returned. This is implemented by comparing the lifetime\n-    /// of the argument and return value for equality. However, this can cause\n-    /// false positives in cases involving multiple lifetimes that are bounded by\n-    /// each other.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// // Bad\n-    /// fn foo(v: &u32) {}\n-    /// ```\n-    ///\n-    /// ```rust\n-    /// // Better\n-    /// fn foo(v: u32) {}\n-    /// ```\n-    pub TRIVIALLY_COPY_PASS_BY_REF,\n-    pedantic,\n-    \"functions taking small copyable arguments by reference\"\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct TriviallyCopyPassByRef {\n-    limit: u64,\n-}\n-\n-impl<'tcx> TriviallyCopyPassByRef {\n-    pub fn new(limit: Option<u64>, target: &Target) -> Self {\n-        let limit = limit.unwrap_or_else(|| {\n-            let bit_width = u64::from(target.pointer_width);\n-            // Cap the calculated bit width at 32-bits to reduce\n-            // portability problems between 32 and 64-bit targets\n-            let bit_width = cmp::min(bit_width, 32);\n-            #[allow(clippy::integer_division)]\n-            let byte_width = bit_width / 8;\n-            // Use a limit of 2 times the register byte width\n-            byte_width * 2\n-        });\n-        Self { limit }\n-    }\n-\n-    fn check_poly_fn(&mut self, cx: &LateContext<'tcx>, hir_id: HirId, decl: &FnDecl<'_>, span: Option<Span>) {\n-        let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n-\n-        let fn_sig = cx.tcx.fn_sig(fn_def_id);\n-        let fn_sig = cx.tcx.erase_late_bound_regions(&fn_sig);\n-\n-        // Use lifetimes to determine if we're returning a reference to the\n-        // argument. In that case we can't switch to pass-by-value as the\n-        // argument will not live long enough.\n-        let output_lts = match *fn_sig.output().kind() {\n-            ty::Ref(output_lt, _, _) => vec![output_lt],\n-            ty::Adt(_, substs) => substs.regions().collect(),\n-            _ => vec![],\n-        };\n-\n-        for (input, &ty) in decl.inputs.iter().zip(fn_sig.inputs()) {\n-            // All spans generated from a proc-macro invocation are the same...\n-            match span {\n-                Some(s) if s == input.span => return,\n-                _ => (),\n-            }\n-\n-            if_chain! {\n-                if let ty::Ref(input_lt, ty, Mutability::Not) = ty.kind();\n-                if !output_lts.contains(&input_lt);\n-                if is_copy(cx, ty);\n-                if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n-                if size <= self.limit;\n-                if let hir::TyKind::Rptr(_, MutTy { ty: ref decl_ty, .. }) = input.kind;\n-                then {\n-                    let value_type = if is_self_ty(decl_ty) {\n-                        \"self\".into()\n-                    } else {\n-                        snippet(cx, decl_ty.span, \"_\").into()\n-                    };\n-                    span_lint_and_sugg(\n-                        cx,\n-                        TRIVIALLY_COPY_PASS_BY_REF,\n-                        input.span,\n-                        &format!(\"this argument ({} byte) is passed by reference, but would be more efficient if passed by value (limit: {} byte)\", size, self.limit),\n-                        \"consider passing by value instead\",\n-                        value_type,\n-                        Applicability::Unspecified,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(TriviallyCopyPassByRef => [TRIVIALLY_COPY_PASS_BY_REF]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TriviallyCopyPassByRef {\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n-        if item.span.from_expansion() {\n-            return;\n-        }\n-\n-        if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.hir_id, &*method_sig.decl, None);\n-        }\n-    }\n-\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        _body: &'tcx Body<'_>,\n-        span: Span,\n-        hir_id: HirId,\n-    ) {\n-        if span.from_expansion() {\n-            return;\n-        }\n-\n-        match kind {\n-            FnKind::ItemFn(.., header, _, attrs) => {\n-                if header.abi != Abi::Rust {\n-                    return;\n-                }\n-                for a in attrs {\n-                    if let Some(meta_items) = a.meta_item_list() {\n-                        if a.has_name(sym!(proc_macro_derive))\n-                            || (a.has_name(sym!(inline)) && attr::list_contains_name(&meta_items, sym!(always)))\n-                        {\n-                            return;\n-                        }\n-                    }\n-                }\n-            },\n-            FnKind::Method(..) => (),\n-            FnKind::Closure(..) => return,\n-        }\n-\n-        // Exclude non-inherent impls\n-        if let Some(Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_node(hir_id)) {\n-            if matches!(item.kind, ItemKind::Impl{ of_trait: Some(_), .. } |\n-                ItemKind::Trait(..))\n-            {\n-                return;\n-            }\n-        }\n-\n-        self.check_poly_fn(cx, hir_id, decl, Some(span));\n-    }\n-}"}, {"sha": "0ac8fff69f05742f241109b52959341813bb2922", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -150,6 +150,8 @@ define_Conf! {\n     (literal_representation_threshold, \"literal_representation_threshold\": u64, 16384),\n     /// Lint: TRIVIALLY_COPY_PASS_BY_REF. The maximum size (in bytes) to consider a `Copy` type for passing by value instead of by reference.\n     (trivial_copy_size_limit, \"trivial_copy_size_limit\": Option<u64>, None),\n+    /// Lint: LARGE_TYPE_PASS_BY_MOVE. The minimum size (in bytes) to consider a type for passing by reference instead of by value.\n+    (pass_by_value_size_limit, \"pass_by_value_size_limit\": u64, 256),\n     /// Lint: TOO_MANY_LINES. The maximum number of lines a function or method can have\n     (too_many_lines_threshold, \"too_many_lines_threshold\": u64, 100),\n     /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS. The maximum allowed size for arrays on the stack"}, {"sha": "f3536f263397f44e0ec360327d4af1143a882d84", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -1061,6 +1061,13 @@ vec![\n         deprecation: None,\n         module: \"large_stack_arrays\",\n     },\n+    Lint {\n+        name: \"large_types_passed_by_value\",\n+        group: \"pedantic\",\n+        desc: \"functions taking large arguments by value\",\n+        deprecation: None,\n+        module: \"pass_by_ref_or_value\",\n+    },\n     Lint {\n         name: \"len_without_is_empty\",\n         group: \"style\",\n@@ -2389,7 +2396,7 @@ vec![\n         group: \"pedantic\",\n         desc: \"functions taking small copyable arguments by reference\",\n         deprecation: None,\n-        module: \"trivially_copy_pass_by_ref\",\n+        module: \"pass_by_ref_or_value\",\n     },\n     Lint {\n         name: \"try_err\","}, {"sha": "a58e7e918e2f85a6301c5f2d062f1fbce0bc892b", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "e4a2e9df4d7ba71d6ad41d0f9faa75d3f7ced853", "filename": "tests/ui/large_types_passed_by_value.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/tests%2Fui%2Flarge_types_passed_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/tests%2Fui%2Flarge_types_passed_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_types_passed_by_value.rs?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -0,0 +1,66 @@\n+// normalize-stderr-test \"\\(\\d+ byte\\)\" -> \"(N byte)\"\n+// normalize-stderr-test \"\\(limit: \\d+ byte\\)\" -> \"(limit: N byte)\"\n+\n+#![warn(clippy::large_types_passed_by_value)]\n+\n+pub struct Large([u8; 2048]);\n+\n+#[derive(Clone, Copy)]\n+pub struct LargeAndCopy([u8; 2048]);\n+\n+pub struct Small([u8; 4]);\n+\n+#[derive(Clone, Copy)]\n+pub struct SmallAndCopy([u8; 4]);\n+\n+fn small(a: Small, b: SmallAndCopy) {}\n+fn not_copy(a: Large) {}\n+fn by_ref(a: &Large, b: &LargeAndCopy) {}\n+fn mutable(mut a: LargeAndCopy) {}\n+fn bad(a: LargeAndCopy) {}\n+pub fn bad_but_pub(a: LargeAndCopy) {}\n+\n+impl LargeAndCopy {\n+    fn self_is_ok(self) {}\n+    fn other_is_not_ok(self, other: LargeAndCopy) {}\n+    fn unless_other_can_change(self, mut other: LargeAndCopy) {}\n+    pub fn or_were_in_public(self, other: LargeAndCopy) {}\n+}\n+\n+trait LargeTypeDevourer {\n+    fn devoure_array(&self, array: [u8; 6666]);\n+    fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy));\n+    fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+}\n+\n+pub trait PubLargeTypeDevourer {\n+    fn devoure_array_in_public(&self, array: [u8; 6666]);\n+}\n+\n+struct S {}\n+impl LargeTypeDevourer for S {\n+    fn devoure_array(&self, array: [u8; 6666]) {\n+        todo!();\n+    }\n+    fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy)) {\n+        todo!();\n+    }\n+    fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy)) {\n+        todo!();\n+    }\n+}\n+\n+#[inline(always)]\n+fn foo_always(x: LargeAndCopy) {\n+    todo!();\n+}\n+#[inline(never)]\n+fn foo_never(x: LargeAndCopy) {\n+    todo!();\n+}\n+#[inline]\n+fn foo(x: LargeAndCopy) {\n+    todo!();\n+}\n+\n+fn main() {}"}, {"sha": "5f42dcfb9b5218e43238f9d3bf26777e8aa630a0", "filename": "tests/ui/large_types_passed_by_value.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/tests%2Fui%2Flarge_types_passed_by_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8731a926c9a642ca1ddf5b52baf40e0a8873d53/tests%2Fui%2Flarge_types_passed_by_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flarge_types_passed_by_value.stderr?ref=e8731a926c9a642ca1ddf5b52baf40e0a8873d53", "patch": "@@ -0,0 +1,52 @@\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:20:11\n+   |\n+LL | fn bad(a: LargeAndCopy) {}\n+   |           ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+   |\n+   = note: `-D clippy::large-types-passed-by-value` implied by `-D warnings`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:25:37\n+   |\n+LL |     fn other_is_not_ok(self, other: LargeAndCopy) {}\n+   |                                     ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:31:36\n+   |\n+LL |     fn devoure_array(&self, array: [u8; 6666]);\n+   |                                    ^^^^^^^^^^ help: consider passing by reference instead: `&[u8; 6666]`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:32:34\n+   |\n+LL |     fn devoure_tuple(&self, tup: (LargeAndCopy, LargeAndCopy));\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider passing by reference instead: `&(LargeAndCopy, LargeAndCopy)`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:33:50\n+   |\n+LL |     fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+   |                                                  ^^^^^^^^^^ help: consider passing by reference instead: `&[u8; 6666]`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:33:67\n+   |\n+LL |     fn devoure_array_and_tuple_wow(&self, array: [u8; 6666], tup: (LargeAndCopy, LargeAndCopy));\n+   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider passing by reference instead: `&(LargeAndCopy, LargeAndCopy)`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:58:17\n+   |\n+LL | fn foo_never(x: LargeAndCopy) {\n+   |                 ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: this argument (N byte) is passed by value, but might be more efficient if passed by reference (limit: N byte)\n+  --> $DIR/large_types_passed_by_value.rs:62:11\n+   |\n+LL | fn foo(x: LargeAndCopy) {\n+   |           ^^^^^^^^^^^^ help: consider passing by reference instead: `&LargeAndCopy`\n+\n+error: aborting due to 8 previous errors\n+"}]}