{"sha": "2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5MzhlNmE0MTE3MmQxYzcxZjVjNThlOWE3MTk1OGYyZDVjMWEyNjI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-08T05:55:09Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-16T10:14:16Z"}, "message": "Add missing doc examples for UnixDatagram", "tree": {"sha": "a6a8b8d0bac4849ab7c4aebd3834b15814ec56b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6a8b8d0bac4849ab7c4aebd3834b15814ec56b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "html_url": "https://github.com/rust-lang/rust/commit/2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2938e6a41172d1c71f5c58e9a71958f2d5c1a262/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a78a33c52a3a4766e170a8dbe0328cbbd03d4f14", "url": "https://api.github.com/repos/rust-lang/rust/commits/a78a33c52a3a4766e170a8dbe0328cbbd03d4f14", "html_url": "https://github.com/rust-lang/rust/commit/a78a33c52a3a4766e170a8dbe0328cbbd03d4f14"}], "stats": {"total": 323, "additions": 285, "deletions": 38}, "files": [{"sha": "e822488c01851a7107c1e30f12313f93e5373e14", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 285, "deletions": 38, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/2938e6a41172d1c71f5c58e9a71958f2d5c1a262/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2938e6a41172d1c71f5c58e9a71958f2d5c1a262/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=2938e6a41172d1c71f5c58e9a71958f2d5c1a262", "patch": "@@ -139,13 +139,25 @@ impl SocketAddr {\n     ///\n     /// # Examples\n     ///\n+    /// A named address:\n+    ///\n     /// ```\n     /// use std::os::unix::net::UnixListener;\n     ///\n-    /// let socket = match UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.is_unnamed(), false);\n     /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.is_unnamed(), true);\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         if let AddressKind::Unnamed = self.address() {\n@@ -159,14 +171,27 @@ impl SocketAddr {\n     ///\n     /// # Examples\n     ///\n+    /// With a pathname:\n+    ///\n     /// ```\n     /// use std::os::unix::net::UnixListener;\n     /// use std::path::Path;\n     ///\n-    /// let socket = match UnixListener::bind(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixListener::bind(\"/tmp/sock\").unwrap();\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n     /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::path::Path;\n+    ///\n+    /// let socket = UnixDatagram::unbound().unwrap();\n+    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// assert_eq!(addr.as_pathname(), None);\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         if let AddressKind::Pathname(path) = self.address() {\n@@ -311,8 +336,8 @@ impl UnixStream {\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket...\");\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n@@ -326,7 +351,7 @@ impl UnixStream {\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -341,7 +366,7 @@ impl UnixStream {\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -355,17 +380,17 @@ impl UnixStream {\n     /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`read()`]: ../../std/io/trait.Read.html#tymethod.read\n-    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../../../std/io/trait.Read.html#tymethod.read\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     /// use std::time::Duration;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -379,17 +404,17 @@ impl UnixStream {\n     /// indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    /// [`read()`]: ../../std/io/trait.Write.html#tymethod.write\n-    /// [`Duration`]: ../../std/time/struct.Duration.html\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`read()`]: ../../../../std/io/trait.Write.html#tymethod.write\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     /// use std::time::Duration;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -405,7 +430,7 @@ impl UnixStream {\n     /// use std::os::unix::net::UnixStream;\n     /// use std::time::Duration;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n@@ -422,7 +447,7 @@ impl UnixStream {\n     /// use std::os::unix::net::UnixStream;\n     /// use std::time::Duration;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n@@ -438,8 +463,8 @@ impl UnixStream {\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n@@ -453,7 +478,7 @@ impl UnixStream {\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// if let Ok(Some(err)) = socket.take_error() {\n     ///     println!(\"Got error: {:?}\", err);\n     /// }\n@@ -469,14 +494,15 @@ impl UnixStream {\n     /// specified portions to immediately return with an appropriate value\n     /// (see the documentation of [`Shutdown`]).\n     ///\n-    /// [`Shutdown`]: ../../std/net/enum.Shutdown.html\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n     ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\").unwrap();\n+    /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n@@ -631,7 +657,7 @@ impl UnixListener {\n     /// is established. When established, the corersponding [`UnixStream`] and\n     /// the remote peer's address will be returned.\n     ///\n-    /// [`UnixStream`]: ../../std/os/unix/net/struct.UnixStream.html\n+    /// [`UnixStream`]: ../../../../std/os/unix/net/struct.UnixStream.html\n     ///\n     /// # Examples\n     ///\n@@ -683,7 +709,7 @@ impl UnixListener {\n     ///\n     /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n     ///\n-    /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n@@ -699,7 +725,7 @@ impl UnixListener {\n     ///\n     /// let listener = UnixListener::bind(\"/path/to/the/socket\").unwrap();\n     ///\n-    /// socket.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n     /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n@@ -713,8 +739,9 @@ impl UnixListener {\n     /// ```no_run\n     /// use std::os::unix::net::UnixListener;\n     ///\n-    /// let socket = match UnixListener::bind(\"/tmp/sock\").unwrap();\n-    /// if let Ok(Some(err)) = socket.take_error() {\n+    /// let listener = UnixListener::bind(\"/tmp/sock\").unwrap();\n+    ///\n+    /// if let Ok(Some(err)) = listener.take_error() {\n     ///     println!(\"Got error: {:?}\", err);\n     /// }\n     /// ```\n@@ -728,7 +755,7 @@ impl UnixListener {\n     /// The iterator will never return [`None`] and will also not yield the\n     /// peer's [`SocketAddr`] structure.\n     ///\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n     /// [`SocketAddr`]: struct.SocketAddr.html\n     ///\n     /// # Examples\n@@ -795,7 +822,7 @@ impl<'a> IntoIterator for &'a UnixListener {\n ///\n /// It will never return [`None`].\n ///\n-/// [`None`]: ../../std/option/enum.Option.html#variant.None\n+/// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n /// [`UnixListener`]: struct.UnixListener.html\n ///\n /// # Examples\n@@ -873,6 +900,20 @@ impl fmt::Debug for UnixDatagram {\n \n impl UnixDatagram {\n     /// Creates a Unix datagram socket bound to the given path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't bind: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n         fn inner(path: &Path) -> io::Result<UnixDatagram> {\n@@ -889,6 +930,20 @@ impl UnixDatagram {\n     }\n \n     /// Creates a Unix Datagram socket which is not bound to any address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::unbound() {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn unbound() -> io::Result<UnixDatagram> {\n         let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n@@ -898,6 +953,20 @@ impl UnixDatagram {\n     /// Create an unnamed pair of connected sockets.\n     ///\n     /// Returns two `UnixDatagrams`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let (sock1, sock2) = match UnixDatagram::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n         let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n@@ -906,8 +975,27 @@ impl UnixDatagram {\n \n     /// Connects the socket to the specified address.\n     ///\n-    /// The `send` method may be used to send data to the specified address.\n-    /// `recv` and `recv_from` will only receive data from that address.\n+    /// The [`send()`] method may be used to send data to the specified address.\n+    /// [`recv()`] and [`recv_from()`] will only receive data from that address.\n+    ///\n+    /// [`send()`]: #method.send\n+    /// [`recv()`]: #method.recv\n+    /// [`recv_from()`]: #method.recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// match sock.connect(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n@@ -924,23 +1012,56 @@ impl UnixDatagram {\n \n     /// Creates a new independently owned handle to the underlying socket.\n     ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// The returned `UnixDatagram` is a reference to the same socket that this\n     /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n+    /// connections and options set on one side will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n         self.0.duplicate().map(UnixDatagram)\n     }\n \n     /// Returns the address of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.local_addr().expect(\"Couldn't get local address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n     }\n \n     /// Returns the address of this socket's peer.\n     ///\n-    /// The `connect` method will connect the socket to a peer.\n+    /// The [`connect()`] method will connect the socket to a peer.\n+    ///\n+    /// [`connect()`]: #method.connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/path/to/the/socket\").unwrap();\n+    ///\n+    /// let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n@@ -950,6 +1071,19 @@ impl UnixDatagram {\n     ///\n     /// On success, returns the number of bytes read and the address from\n     /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// match sock.recv_from(buf.as_mut_slice()) {\n+    ///     Ok((size, sender)) => println!(\"received {} bytes from {:?}\", size, sender),\n+    ///     Err(e) => println!(\"recv_from function failed: {:?}\", e),\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         let mut count = 0;\n@@ -977,6 +1111,16 @@ impl UnixDatagram {\n     /// Receives data from the socket.\n     ///\n     /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::bind(\"/path/to/the/socket\").unwrap();\n+    /// let mut buf = vec![0; 10];\n+    /// sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -985,6 +1129,15 @@ impl UnixDatagram {\n     /// Sends data on the socket to the specified address.\n     ///\n     /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n         fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n@@ -1009,50 +1162,134 @@ impl UnixDatagram {\n     /// will return an error if the socket has not already been connected.\n     ///\n     /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n+    /// sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n     }\n \n     /// Sets the read timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `recv` and `recv_from` calls will\n-    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`recv()`] and [`recv_from()`] calls will\n+    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`recv()`]: #method.recv\n+    /// [`recv_from()`]: #method.recv_from\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n     }\n \n     /// Sets the write timeout for the socket.\n     ///\n-    /// If the provided value is `None`, then `send` and `send_to` calls will\n-    /// block indefinitely. It is an error to pass the zero `Duration` to this\n+    /// If the provided value is [`None`], then [`send()`] and [`send_to()`] calls will\n+    /// block indefinitely. It is an error to pass the zero [`Duration`] to this\n     /// method.\n+    ///\n+    /// [`None`]: ../../../../std/option/enum.Option.html#variant.None\n+    /// [`send()`]: #method.send\n+    /// [`send_to()`]: #method.send_to\n+    /// [`Duration`]: ../../../../std/time/struct.Duration.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n         self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n     }\n \n     /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_read_timeout(Some(Duration::new(1, 0))).expect(\"set_read_timeout function failed\");\n+    /// assert_eq!(sock.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_RCVTIMEO)\n     }\n \n     /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///     .expect(\"set_write_timeout function failed\");\n+    /// assert_eq!(sock.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         self.0.timeout(libc::SO_SNDTIMEO)\n     }\n \n     /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n \n     /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// if let Ok(Some(err)) = sock.take_error() {\n+    ///     println!(\"Got error: {:?}\", err);\n+    /// }\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         self.0.take_error()\n@@ -1062,7 +1299,17 @@ impl UnixDatagram {\n     ///\n     /// This function will cause all pending and future I/O calls on the\n     /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of `Shutdown`).\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// [`Shutdown`]: ../../../../std/net/enum.Shutdown.html\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// let sock = UnixDatagram::unbound().unwrap();\n+    /// sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    /// ```\n     #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n     pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n         self.0.shutdown(how)"}]}