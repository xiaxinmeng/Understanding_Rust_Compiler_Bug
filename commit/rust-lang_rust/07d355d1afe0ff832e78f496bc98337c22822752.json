{"sha": "07d355d1afe0ff832e78f496bc98337c22822752", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZDM1NWQxYWZlMGZmODMyZTc4ZjQ5NmJjOTgzMzdjMjI4MjI3NTI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-24T16:59:41Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-24T16:59:41Z"}, "message": "Add lexer.reader to rustc for tracking position, char conversion, holding keyword tables.", "tree": {"sha": "3b7bb4431b2cd5ad3ec60bf053e81b057fbedf9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b7bb4431b2cd5ad3ec60bf053e81b057fbedf9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07d355d1afe0ff832e78f496bc98337c22822752", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07d355d1afe0ff832e78f496bc98337c22822752", "html_url": "https://github.com/rust-lang/rust/commit/07d355d1afe0ff832e78f496bc98337c22822752", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07d355d1afe0ff832e78f496bc98337c22822752/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47501f16596d2eaac9ce1a27b43b386b8496c66f", "url": "https://api.github.com/repos/rust-lang/rust/commits/47501f16596d2eaac9ce1a27b43b386b8496c66f", "html_url": "https://github.com/rust-lang/rust/commit/47501f16596d2eaac9ce1a27b43b386b8496c66f"}], "stats": {"total": 89, "additions": 89, "deletions": 0}, "files": [{"sha": "caf3cd4857ebc44d9fe11a61f11a4e5e90d507c0", "filename": "src/comp/fe/lexer.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/07d355d1afe0ff832e78f496bc98337c22822752/src%2Fcomp%2Ffe%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07d355d1afe0ff832e78f496bc98337c22822752/src%2Fcomp%2Ffe%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Flexer.rs?ref=07d355d1afe0ff832e78f496bc98337c22822752", "patch": "@@ -1,4 +1,93 @@\n import std._io.stdio_reader;\n+import std._str;\n+import std.map;\n+import std.map.hashmap;\n+\n+fn new_str_hash[V]() -> map.hashmap[str,V] {\n+    let map.hashfn[str] hasher = _str.hash;\n+    let map.eqfn[str] eqer = _str.eq;\n+    ret map.mk_hashmap[str,V](hasher, eqer);\n+}\n+\n+type reader = obj {\n+              fn is_eof() -> bool;\n+              fn peek() -> char;\n+              fn bump();\n+              fn get_pos() -> tup(str,uint,uint);\n+              fn get_keywords() -> hashmap[str,token.token];\n+              fn get_reserved() -> hashmap[str,()];\n+};\n+\n+fn new_reader(stdio_reader rdr, str filename) -> reader\n+{\n+    obj reader(stdio_reader rdr,\n+               str filename,\n+               mutable char c,\n+               mutable uint line,\n+               mutable uint col,\n+               hashmap[str,token.token] keywords,\n+               hashmap[str,()] reserved)\n+        {\n+            fn is_eof() -> bool {\n+                ret c == (-1) as char;\n+            }\n+\n+            fn get_pos() -> tup(str,uint,uint) {\n+                ret tup(filename, line, col);\n+            }\n+\n+            fn peek() -> char {\n+                ret c;\n+            }\n+\n+            fn bump() {\n+                c = rdr.getc() as char;\n+                if (c == '\\n') {\n+                    line += 1u;\n+                    col = 0u;\n+                } else {\n+                    col += 1u;\n+                }\n+            }\n+\n+            fn get_keywords() -> hashmap[str,token.token] {\n+                ret keywords;\n+            }\n+\n+            fn get_reserved() -> hashmap[str,()] {\n+                ret reserved;\n+            }\n+        }\n+\n+    auto keywords = new_str_hash[token.token]();\n+    auto reserved = new_str_hash[()]();\n+\n+    keywords.insert(\"mod\", token.MOD());\n+    keywords.insert(\"use\", token.USE());\n+    keywords.insert(\"meta\", token.META());\n+    keywords.insert(\"auth\", token.AUTH());\n+\n+    keywords.insert(\"syntax\", token.SYNTAX());\n+\n+    keywords.insert(\"if\", token.IF());\n+    keywords.insert(\"else\", token.ELSE());\n+    keywords.insert(\"while\", token.WHILE());\n+    keywords.insert(\"do\", token.DO());\n+    keywords.insert(\"alt\", token.ALT());\n+    keywords.insert(\"case\", token.CASE());\n+\n+    keywords.insert(\"for\", token.FOR());\n+    keywords.insert(\"each\", token.EACH());\n+    keywords.insert(\"put\", token.PUT());\n+    keywords.insert(\"ret\", token.RET());\n+    keywords.insert(\"be\", token.BE());\n+\n+    ret reader(rdr, filename, rdr.getc() as char, 1u, 1u,\n+               keywords, reserved);\n+}\n+\n+\n+\n \n fn in_range(char c, char lo, char hi) -> bool {\n     ret lo <= c && c <= hi;"}]}