{"sha": "a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YWRiMWViZmY1MWRkNGZmMmU3MjRiZjk4MGM5Yjg1ODYxNDJiZWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-07T23:53:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-09T04:20:36Z"}, "message": "find and highlight the `&` or `'_` in `region_name`", "tree": {"sha": "f20994d71db37670c4848505637ef4a2e9312ee4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f20994d71db37670c4848505637ef4a2e9312ee4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "html_url": "https://github.com/rust-lang/rust/commit/a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fd3d7899a444fe110ae9277542b306844ecf0c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd3d7899a444fe110ae9277542b306844ecf0c4", "html_url": "https://github.com/rust-lang/rust/commit/9fd3d7899a444fe110ae9277542b306844ecf0c4"}], "stats": {"total": 322, "additions": 300, "deletions": 22}, "files": [{"sha": "f18846b8574df4ae347fc2f821dc0ae28027dd66", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -402,6 +402,15 @@ pub enum GenericArg {\n     Type(Ty),\n }\n \n+impl GenericArg {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            GenericArg::Lifetime(l) => l.span,\n+            GenericArg::Type(t) => t.span,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct GenericArgs {\n     /// The generic arguments for this path segment."}, {"sha": "16dec2725ff0436d7eac0fac222c6ab591ff19d7", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 277, "deletions": 17, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -10,9 +10,11 @@\n \n use borrow_check::nll::region_infer::RegionInferenceContext;\n use borrow_check::nll::ToRegionVid;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::{Local, Mir};\n-use rustc::ty::{self, RegionVid, TyCtxt};\n+use rustc::ty::subst::{Substs, UnpackedKind};\n+use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_errors::DiagnosticBuilder;\n use syntax::ast::Name;\n@@ -60,7 +62,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.give_name_from_error_region(tcx, mir_def_id, fr, counter, diag)\n             .or_else(|| {\n-                self.give_name_if_anonymous_region_appears_in_arguments(tcx, mir, fr, counter, diag)\n+                self.give_name_if_anonymous_region_appears_in_arguments(\n+                    tcx, mir, mir_def_id, fr, counter, diag,\n+                )\n             })\n             .or_else(|| {\n                 self.give_name_if_anonymous_region_appears_in_upvars(tcx, mir, fr, counter, diag)\n@@ -129,30 +133,48 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         mir: &Mir<'tcx>,\n+        mir_def_id: DefId,\n         fr: RegionVid,\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n         let implicit_inputs = self.universal_regions.defining_ty.implicit_inputs();\n-        let argument_index = self.universal_regions\n+        let argument_index = self\n+            .universal_regions\n             .unnormalized_input_tys\n             .iter()\n             .skip(implicit_inputs)\n             .position(|arg_ty| {\n-                debug!(\"give_name_if_anonymous_region_appears_in_arguments: arg_ty = {:?}\", arg_ty);\n+                debug!(\n+                    \"give_name_if_anonymous_region_appears_in_arguments: arg_ty = {:?}\",\n+                    arg_ty\n+                );\n                 tcx.any_free_region_meets(arg_ty, |r| r.to_region_vid() == fr)\n-            })?\n-            + implicit_inputs;\n+            })?;\n \n         debug!(\n             \"give_name_if_anonymous_region_appears_in_arguments: \\\n              found {:?} in argument {} which has type {:?}\",\n             fr, argument_index, self.universal_regions.unnormalized_input_tys[argument_index],\n         );\n \n+        let arg_ty =\n+            self.universal_regions.unnormalized_input_tys[implicit_inputs + argument_index];\n+        if let Some(region_name) = self.give_name_if_we_can_match_hir_ty_from_argument(\n+            tcx,\n+            mir_def_id,\n+            fr,\n+            arg_ty,\n+            argument_index,\n+            counter,\n+            diag,\n+        ) {\n+            return Some(region_name);\n+        }\n+\n         let region_name = self.synthesize_region_name(counter);\n \n-        let argument_local = Local::new(argument_index + 1);\n+        let argument_local = Local::new(argument_index + implicit_inputs + 1);\n         let argument_span = mir.local_decls[argument_local].source_info.span;\n         diag.span_label(\n             argument_span,\n@@ -162,6 +184,240 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         Some(region_name)\n     }\n \n+    fn give_name_if_we_can_match_hir_ty_from_argument(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        mir_def_id: DefId,\n+        needle_fr: RegionVid,\n+        argument_ty: Ty<'tcx>,\n+        argument_index: usize,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> Option<InternedString> {\n+        let mir_node_id = tcx.hir.as_local_node_id(mir_def_id)?;\n+        let fn_decl = tcx.hir.fn_decl(mir_node_id)?;\n+        let argument_hir_ty: &hir::Ty = &fn_decl.inputs[argument_index];\n+        match argument_hir_ty.node {\n+            // This indicates a variable with no type annotation, like\n+            // `|x|`... in that case, we can't highlight the type but\n+            // must highlight the variable.\n+            hir::TyInfer => None,\n+\n+            _ => self.give_name_if_we_can_match_hir_ty(\n+                tcx,\n+                needle_fr,\n+                argument_ty,\n+                argument_hir_ty,\n+                counter,\n+                diag,\n+            ),\n+        }\n+    }\n+\n+    /// Attempts to highlight the specific part of a type annotation\n+    /// that contains the anonymous reference we want to give a name\n+    /// to. For example, we might produce an annotation like this:\n+    ///\n+    /// ```\n+    ///  | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+    ///  |                - let's call the lifetime of this reference `'1`\n+    /// ```\n+    ///\n+    /// the way this works is that we match up `argument_ty`, which is\n+    /// a `Ty<'tcx>` (the internal form of the type) with\n+    /// `argument_hir_ty`, a `hir::Ty` (the syntax of the type\n+    /// annotation). We are descending through the types stepwise,\n+    /// looking in to find the region `needle_fr` in the internal\n+    /// type.  Once we find that, we can use the span of the `hir::Ty`\n+    /// to add the highlight.\n+    ///\n+    /// This is a somewhat imperfect process, so long the way we also\n+    /// keep track of the **closest** type we've found. If we fail to\n+    /// find the exact `&` or `'_` to highlight, then we may fall back\n+    /// to highlighting that closest type instead.\n+    fn give_name_if_we_can_match_hir_ty(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        needle_fr: RegionVid,\n+        argument_ty: Ty<'tcx>,\n+        argument_hir_ty: &hir::Ty,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+    ) -> Option<InternedString> {\n+        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty)> = &mut Vec::new();\n+\n+        search_stack.push((argument_ty, argument_hir_ty));\n+\n+        let mut closest_match: &hir::Ty = argument_hir_ty;\n+\n+        while let Some((ty, hir_ty)) = search_stack.pop() {\n+            // While we search, also track the closet match.\n+            if tcx.any_free_region_meets(&ty, |r| r.to_region_vid() == needle_fr) {\n+                closest_match = hir_ty;\n+            }\n+\n+            match (&ty.sty, &hir_ty.node) {\n+                // Check if the `argument_ty` is `&'X ..` where `'X`\n+                // is the region we are looking for -- if so, and we have a `&T`\n+                // on the RHS, then we want to highlight the `&` like so:\n+                //\n+                //     &\n+                //     - let's call the lifetime of this reference `'1`\n+                (ty::TyRef(region, referent_ty, _), hir::TyRptr(_lifetime, referent_hir_ty)) => {\n+                    if region.to_region_vid() == needle_fr {\n+                        let region_name = self.synthesize_region_name(counter);\n+\n+                        // Just grab the first character, the `&`.\n+                        let codemap = tcx.sess.codemap();\n+                        let ampersand_span = codemap.start_point(hir_ty.span);\n+\n+                        diag.span_label(\n+                            ampersand_span,\n+                            format!(\n+                                \"let's call the lifetime of this reference `{}`\",\n+                                region_name\n+                            ),\n+                        );\n+\n+                        return Some(region_name);\n+                    }\n+\n+                    // Otherwise, let's descend into the referent types.\n+                    search_stack.push((referent_ty, &referent_hir_ty.ty));\n+                }\n+\n+                // Match up something like `Foo<'1>`\n+                (ty::TyAdt(_adt_def, substs), hir::TyPath(hir::QPath::Resolved(None, path))) => {\n+                    if let Some(last_segment) = path.segments.last() {\n+                        if let Some(name) = self.match_adt_and_segment(\n+                            substs,\n+                            needle_fr,\n+                            last_segment,\n+                            counter,\n+                            diag,\n+                            search_stack,\n+                        ) {\n+                            return Some(name);\n+                        }\n+                    }\n+                }\n+\n+                // The following cases don't have lifetimes, so we\n+                // just worry about trying to match up the rustc type\n+                // with the HIR types:\n+                (ty::TyTuple(elem_tys), hir::TyTup(elem_hir_tys)) => {\n+                    search_stack.extend(elem_tys.iter().cloned().zip(elem_hir_tys));\n+                }\n+\n+                (ty::TySlice(elem_ty), hir::TySlice(elem_hir_ty))\n+                | (ty::TyArray(elem_ty, _), hir::TyArray(elem_hir_ty, _)) => {\n+                    search_stack.push((elem_ty, elem_hir_ty));\n+                }\n+\n+                (ty::TyRawPtr(mut_ty), hir::TyPtr(mut_hir_ty)) => {\n+                    search_stack.push((mut_ty.ty, &mut_hir_ty.ty));\n+                }\n+\n+                _ => {\n+                    // FIXME there are other cases that we could trace\n+                }\n+            }\n+        }\n+\n+        let region_name = self.synthesize_region_name(counter);\n+        diag.span_label(\n+            closest_match.span,\n+            format!(\"lifetime `{}` appears in this type\", region_name),\n+        );\n+\n+        return Some(region_name);\n+    }\n+\n+    /// We've found an enum/struct/union type with the substitutions\n+    /// `substs` and -- in the HIR -- a path type with the final\n+    /// segment `last_segment`. Try to find a `'_` to highlight in\n+    /// the generic args (or, if not, to produce new zipped pairs of\n+    /// types+hir to search through).\n+    fn match_adt_and_segment<'hir>(\n+        &self,\n+        substs: &'tcx Substs<'tcx>,\n+        needle_fr: RegionVid,\n+        last_segment: &'hir hir::PathSegment,\n+        counter: &mut usize,\n+        diag: &mut DiagnosticBuilder<'_>,\n+        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n+    ) -> Option<InternedString> {\n+        // Did the user give explicit arguments? (e.g., `Foo<..>`)\n+        let args = last_segment.args.as_ref()?;\n+        let lifetime = self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n+        match lifetime.name {\n+            hir::LifetimeName::Param(_)\n+            | hir::LifetimeName::Static\n+            | hir::LifetimeName::Underscore => {\n+                let region_name = self.synthesize_region_name(counter);\n+                let ampersand_span = lifetime.span;\n+                diag.span_label(ampersand_span, format!(\"let's call this `{}`\", region_name));\n+                return Some(region_name);\n+            }\n+\n+            hir::LifetimeName::Implicit => {\n+                // In this case, the user left off the lifetime; so\n+                // they wrote something like:\n+                //\n+                // ```\n+                // x: Foo<T>\n+                // ```\n+                //\n+                // where the fully elaborated form is `Foo<'_, '1,\n+                // T>`. We don't consider this a match; instead we let\n+                // the \"fully elaborated\" type fallback above handle\n+                // it.\n+                return None;\n+            }\n+        }\n+    }\n+\n+    /// We've found an enum/struct/union type with the substitutions\n+    /// `substs` and -- in the HIR -- a path with the generic\n+    /// arguments `args`. If `needle_fr` appears in the args, return\n+    /// the `hir::Lifetime` that corresponds to it. If not, push onto\n+    /// `search_stack` the types+hir to search through.\n+    fn try_match_adt_and_generic_args<'hir>(\n+        &self,\n+        substs: &'tcx Substs<'tcx>,\n+        needle_fr: RegionVid,\n+        args: &'hir hir::GenericArgs,\n+        search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty)>,\n+    ) -> Option<&'hir hir::Lifetime> {\n+        for (kind, hir_arg) in substs.iter().zip(&args.args) {\n+            match (kind.unpack(), hir_arg) {\n+                (UnpackedKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n+                    if r.to_region_vid() == needle_fr {\n+                        return Some(lt);\n+                    }\n+                }\n+\n+                (UnpackedKind::Type(ty), hir::GenericArg::Type(hir_ty)) => {\n+                    search_stack.push((ty, hir_ty));\n+                }\n+\n+                (UnpackedKind::Lifetime(_), _) | (UnpackedKind::Type(_), _) => {\n+                    // I *think* that HIR lowering should ensure this\n+                    // doesn't happen, even in erroneous\n+                    // programs. Else we should use delay-span-bug.\n+                    span_bug!(\n+                        hir_arg.span(),\n+                        \"unmatched subst and hir arg: found {:?} vs {:?}\",\n+                        kind,\n+                        hir_arg,\n+                    );\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n     /// Find a closure upvar that contains `fr` and label it with a\n     /// fully elaborated type, returning something like `'1`. Result\n     /// looks like:\n@@ -178,7 +434,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n-        let upvar_index = self.universal_regions\n+        let upvar_index = self\n+            .universal_regions\n             .defining_ty\n             .upvar_tys(tcx)\n             .position(|upvar_ty| {\n@@ -189,15 +446,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 tcx.any_free_region_meets(&upvar_ty, |r| r.to_region_vid() == fr)\n             })?;\n \n+        let upvar_ty = self\n+            .universal_regions\n+            .defining_ty\n+            .upvar_tys(tcx)\n+            .nth(upvar_index);\n+\n         debug!(\n             \"give_name_if_anonymous_region_appears_in_upvars: \\\n              found {:?} in upvar {} which has type {:?}\",\n-            fr,\n-            upvar_index,\n-            self.universal_regions\n-                .defining_ty\n-                .upvar_tys(tcx)\n-                .nth(upvar_index),\n+            fr, upvar_index, upvar_ty,\n         );\n \n         let region_name = self.synthesize_region_name(counter);\n@@ -229,9 +487,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         counter: &mut usize,\n         diag: &mut DiagnosticBuilder<'_>,\n     ) -> Option<InternedString> {\n-        let return_ty = self.universal_regions\n-            .unnormalized_output_ty;\n-        debug!(\"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\", return_ty);\n+        let return_ty = self.universal_regions.unnormalized_output_ty;\n+        debug!(\n+            \"give_name_if_anonymous_region_appears_in_output: return_ty = {:?}\",\n+            return_ty\n+        );\n         if !tcx.any_free_region_meets(&return_ty, |r| r.to_region_vid() == fr) {\n             return None;\n         }"}, {"sha": "8381adaea79de3ef2619bcf9eef415e833a648ef", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -689,6 +689,15 @@ impl CodeMap {\n         self.span_until_char(sp, '{')\n     }\n \n+    /// Returns a new span representing just the start-point of this span\n+    pub fn start_point(&self, sp: Span) -> Span {\n+        let pos = sp.lo().0;\n+        let width = self.find_width_of_character_at_span(sp, false);\n+        let corrected_start_position = pos.checked_add(width).unwrap_or(pos);\n+        let end_point = BytePos(cmp::max(corrected_start_position, sp.lo().0));\n+        sp.with_hi(end_point)\n+    }\n+\n     /// Returns a new span representing just the end-point of this span\n     pub fn end_point(&self, sp: Span) -> Span {\n         let pos = sp.hi().0;"}, {"sha": "5904e98753694a894369ed34ec88fae166766fb8", "filename": "src/test/ui/borrowck/issue-7573.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-7573.nll.stderr?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -11,7 +11,7 @@ LL |     let mut lines_to_use: Vec<&CrateId> = Vec::new();\n    |         ---------------- lifetime `'2` appears in the type of `lines_to_use`\n LL |         //~^ NOTE cannot infer an appropriate lifetime\n LL |     let push_id = |installed_id: &CrateId| {\n-   |                    ------------ lifetime `'1` appears in this argument\n+   |                                  - let's call the lifetime of this reference `'1`\n ...\n LL |         lines_to_use.push(installed_id);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`"}, {"sha": "c8c8ef8215ae28a7a2a9cfdd392a01cba6132735", "filename": "src/test/ui/closure-expected-type/expect-region-supply-region.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fexpect-region-supply-region.nll.stderr?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -38,7 +38,7 @@ error: unsatisfied lifetime constraints\n LL |     let mut f: Option<&u32> = None;\n    |         ----- lifetime `'2` appears in the type of `f`\n LL |     closure_expecting_bound(|x: &u32| {\n-   |                              - lifetime `'1` appears in this argument\n+   |                                 - let's call the lifetime of this reference `'1`\n LL |         f = Some(x); //~ ERROR borrowed data cannot be stored outside of its closure\n    |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`\n \n@@ -49,7 +49,7 @@ LL |     let mut f: Option<&u32> = None;\n    |         ----- lifetime `'2` appears in the type of `f`\n ...\n LL |     closure_expecting_bound(|x: &'x u32| {\n-   |                              - lifetime `'1` appears in this argument\n+   |                                 - let's call the lifetime of this reference `'1`\n ...\n LL |         f = Some(x);\n    |         ^^^^^^^^^^^ free region requires that `'1` must outlive `'2`"}, {"sha": "4c0b3a5d93120efb01a67e854ff0980cdac80b05", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -14,7 +14,7 @@ error: unsatisfied lifetime constraints\n   --> $DIR/static-return-lifetime-infered.rs:17:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         ----- lifetime `'1` appears in this argument\n+   |                         - let's call the lifetime of this reference `'1`\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^ cast requires that `'1` must outlive `'static`\n "}, {"sha": "6385578698cf745b75258d60065ab5effa5bfdd6", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6adb1ebff51dd4ff2e724bf980c9b8586142beb/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=a6adb1ebff51dd4ff2e724bf980c9b8586142beb", "patch": "@@ -26,7 +26,7 @@ error: unsatisfied lifetime constraints\n   --> $DIR/dyn-trait-underscore.rs:18:5\n    |\n LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-   |         ----- lifetime `'1` appears in this argument\n+   |                - let's call the lifetime of this reference `'1`\n LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n    |     ^^^^^^^^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`"}]}