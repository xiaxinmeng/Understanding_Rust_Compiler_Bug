{"sha": "fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "node_id": "C_kwDOAAsO6NoAKGZiOGVjYjk4MzI1OGFhZmRmMGU4YTU2YzU2NWE2MTVlMWUxZGFmYjQ", "commit": {"author": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-10-20T14:39:27Z"}, "committer": {"name": "Philipp Krones", "email": "hello@philkrones.com", "date": "2022-10-20T14:39:27Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "eb0955692c1bd56ac0ffefdbbcdb8bcc2653f104", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb0955692c1bd56ac0ffefdbbcdb8bcc2653f104"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmNRXaEACgkQHKDfKvWd\naKWdUw//bmdgZMcyVQIH7IBQCtuXgnSrCADKyZeuuiAIWa+JrIlkBe1VfFJUsj56\ntQ3hNP5L2A0RiIcTJFNvYUb1RvuNeOVOC52RGNOPuGeXret6eRGvkNoCGfWEEJMh\ndGxlusFmmGon9RcamMW6aaF3+o56zFKUFW0H2PSQ3+K6/HZT090avNVsrxwFfIzr\nVUqQPb09YkEdiLF0syG5m66a/RulkTAAv4W5g0nPUdMFpwslwbarx2zrP0y0Z9jM\nRkN4Ozu22aF8FAYhWtwOVdfAYgwN3teXihU9DYaEVljVokq6EXSbSyQ4BWgWNBxA\nRjZDVcH7U1fMtRYfx7TSLZrhklZ1mo027c2JS3O/9SykoJGY14vr9iSg5/sCahBj\n+oFQ6IujnqOENSh7eDfuX8c4NZmYlwO5bNCX5OZNW3KocZun8M3ZNonqFBDQql0T\nayeHsNmmXB6v+p2a97+URb6Pe3naOXHOjXlxEQsfiaQFKEZAM+2PdWlIrZUK12bp\nYrFjAxiCG7CKzlF82uxbFbb74yzaKxYutCZ0jQZUU1ojBpDeYsY8GjojRkoOUkPb\n6SfbTscJ4ZaTFfwKuRPwSzFPgy8ouUrHg4qkNzK/P2TLr5PXdYSw6p5oYdClYf2f\nKWPjCsgOf9O4JswcwueretCksfjgBDEOUqUmYbiNGzfvukEK4WE=\n=OTUl\n-----END PGP SIGNATURE-----", "payload": "tree eb0955692c1bd56ac0ffefdbbcdb8bcc2653f104\nparent 4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b\nparent 1afc7e227de5453ba98212f82c892522068ea830\nauthor Philipp Krones <hello@philkrones.com> 1666276767 +0200\ncommitter Philipp Krones <hello@philkrones.com> 1666276767 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "html_url": "https://github.com/rust-lang/rust/commit/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b", "html_url": "https://github.com/rust-lang/rust/commit/4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b"}, {"sha": "1afc7e227de5453ba98212f82c892522068ea830", "url": "https://api.github.com/repos/rust-lang/rust/commits/1afc7e227de5453ba98212f82c892522068ea830", "html_url": "https://github.com/rust-lang/rust/commit/1afc7e227de5453ba98212f82c892522068ea830"}], "stats": {"total": 10420, "additions": 6851, "deletions": 3569}, "files": [{"sha": "b992130119713b0408b76341873995a28a5c5e38", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -25,6 +25,7 @@ env:\n   CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n   NO_FMT_TEST: 1\n   CARGO_INCREMENTAL: 0\n+  CARGO_UNSTABLE_SPARSE_REGISTRY: true\n \n jobs:\n   base:"}, {"sha": "6448b2d4068deb480aa9484fb082288e7c8b81ca", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -11,6 +11,7 @@ env:\n   CARGO_TARGET_DIR: '${{ github.workspace }}/target'\n   NO_FMT_TEST: 1\n   CARGO_INCREMENTAL: 0\n+  CARGO_UNSTABLE_SPARSE_REGISTRY: true\n \n defaults:\n   run:"}, {"sha": "14f20212adda5a9dbbd3728d343b9f127d2b44ad", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -15,6 +15,8 @@ on:\n \n env:\n   RUST_BACKTRACE: 1\n+  CARGO_INCREMENTAL: 0\n+  CARGO_UNSTABLE_SPARSE_REGISTRY: true\n \n jobs:\n   clippy_dev:"}, {"sha": "8e7ac644b9f3985424ad1781a0246284ab7abe1a", "filename": "CHANGELOG.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3735,6 +3735,7 @@ Released 2018-09-13\n [`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n [`arithmetic_side_effects`]: https://rust-lang.github.io/rust-clippy/master/index.html#arithmetic_side_effects\n [`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n+[`as_ptr_cast_mut`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_ptr_cast_mut\n [`as_underscore`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_underscore\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n [`assertions_on_result_states`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_result_states\n@@ -3772,6 +3773,7 @@ Released 2018-09-13\n [`cast_enum_constructor`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_constructor\n [`cast_enum_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_truncation\n [`cast_lossless`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless\n+[`cast_nan_to_int`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_nan_to_int\n [`cast_possible_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_truncation\n [`cast_possible_wrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_wrap\n [`cast_precision_loss`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_precision_loss\n@@ -3988,6 +3990,7 @@ Released 2018-09-13\n [`manual_async_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_async_fn\n [`manual_bits`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_bits\n [`manual_clamp`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_clamp\n+[`manual_filter`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter\n [`manual_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_filter_map\n [`manual_find`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find\n [`manual_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_find_map\n@@ -4131,6 +4134,7 @@ Released 2018-09-13\n [`panic_in_result_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_in_result_fn\n [`panic_params`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic_params\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n+[`partial_pub_fields`]: https://rust-lang.github.io/rust-clippy/master/index.html#partial_pub_fields\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`partialeq_to_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_to_none\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n@@ -4312,6 +4316,7 @@ Released 2018-09-13\n [`unstable_as_slice`]: https://rust-lang.github.io/rust-clippy/master/index.html#unstable_as_slice\n [`unused_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_async\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n+[`unused_format_specs`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_format_specs\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n [`unused_peekable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_peekable"}, {"sha": "85f94a74ad91d30629d055e8d3f7b357a3537662", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -29,7 +29,7 @@ All contributors are expected to follow the [Rust Code of Conduct].\n \n ## The Clippy book\n \n-If you're new to Clippy and don't know where to start the [Clippy book] includes\n+If you're new to Clippy and don't know where to start, the [Clippy book] includes\n a [developer guide] and is a good place to start your journey.\n \n [Clippy book]: https://doc.rust-lang.org/nightly/clippy/index.html"}, {"sha": "5223dca073fd7ec24d977db79c6ab9e001eaeca1", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -42,6 +42,7 @@ filetime = \"0.2\"\n rustc-workspace-hack = \"1.0\"\n \n # UI test dependencies\n+clap = { version = \"3.1\", features = [\"derive\"] }\n clippy_utils = { path = \"clippy_utils\" }\n derive-new = \"0.5\"\n if_chain = \"1.0\""}, {"sha": "6fb53236e6f1aee1e6e5355aae584aee07785df5", "filename": "book/src/development/basics.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/book%2Fsrc%2Fdevelopment%2Fbasics.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/book%2Fsrc%2Fdevelopment%2Fbasics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/book%2Fsrc%2Fdevelopment%2Fbasics.md?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -69,7 +69,7 @@ the reference file with:\n cargo dev bless\n ```\n \n-For example, this is necessary, if you fix a typo in an error message of a lint\n+For example, this is necessary if you fix a typo in an error message of a lint,\n or if you modify a test file to add a test case.\n \n > _Note:_ This command may update more files than you intended. In that case\n@@ -101,8 +101,9 @@ cargo dev setup intellij\n cargo dev dogfood\n ```\n \n-More about intellij command usage and reasons\n-[here](https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#intellij-rust)\n+More about [intellij] command usage and reasons.\n+\n+[intellij]: https://github.com/rust-lang/rust-clippy/blob/master/CONTRIBUTING.md#intellij-rust\n \n ## lintcheck\n "}, {"sha": "535c25e69f1bb1df546fbf84ebd8bd2d3984329c", "filename": "clippy_dev/src/serve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_dev%2Fsrc%2Fserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_dev%2Fsrc%2Fserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fserve.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -49,7 +49,7 @@ fn mtime(path: impl AsRef<Path>) -> SystemTime {\n             .into_iter()\n             .flatten()\n             .flatten()\n-            .map(|entry| mtime(&entry.path()))\n+            .map(|entry| mtime(entry.path()))\n             .max()\n             .unwrap_or(SystemTime::UNIX_EPOCH)\n     } else {"}, {"sha": "efdb158c21e9be447bf11c0e8ba8262f48bfd805", "filename": "clippy_dev/src/setup/intellij.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_dev%2Fsrc%2Fsetup%2Fintellij.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_dev%2Fsrc%2Fsetup%2Fintellij.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fintellij.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -36,9 +36,8 @@ impl ClippyProjectInfo {\n }\n \n pub fn setup_rustc_src(rustc_path: &str) {\n-    let rustc_source_dir = match check_and_get_rustc_dir(rustc_path) {\n-        Ok(path) => path,\n-        Err(_) => return,\n+    let Ok(rustc_source_dir) = check_and_get_rustc_dir(rustc_path) else {\n+        return\n     };\n \n     for project in CLIPPY_PROJECTS {\n@@ -172,24 +171,18 @@ pub fn remove_rustc_src() {\n }\n \n fn remove_rustc_src_from_project(project: &ClippyProjectInfo) -> bool {\n-    let mut cargo_content = if let Ok(content) = read_project_file(project.cargo_file) {\n-        content\n-    } else {\n+    let Ok(mut cargo_content) = read_project_file(project.cargo_file) else {\n         return false;\n     };\n-    let section_start = if let Some(section_start) = cargo_content.find(RUSTC_PATH_SECTION) {\n-        section_start\n-    } else {\n+    let Some(section_start) = cargo_content.find(RUSTC_PATH_SECTION) else {\n         println!(\n             \"info: dependencies could not be found in `{}` for {}, skipping file\",\n             project.cargo_file, project.name\n         );\n         return true;\n     };\n \n-    let end_point = if let Some(end_point) = cargo_content.find(DEPENDENCIES_SECTION) {\n-        end_point\n-    } else {\n+    let Some(end_point) = cargo_content.find(DEPENDENCIES_SECTION) else {\n         eprintln!(\n             \"error: the end of the rustc dependencies section could not be found in `{}`\",\n             project.cargo_file"}, {"sha": "e690bc369cd4337203eef2e1c2e6d7ba25834751", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -128,7 +128,7 @@ fn generate_lint_files(\n     for (lint_group, lints) in Lint::by_lint_group(usable_lints.into_iter().chain(internal_lints)) {\n         let content = gen_lint_group_list(&lint_group, lints.iter());\n         process_file(\n-            &format!(\"clippy_lints/src/lib.register_{lint_group}.rs\"),\n+            format!(\"clippy_lints/src/lib.register_{lint_group}.rs\"),\n             update_mode,\n             &content,\n         );\n@@ -869,13 +869,11 @@ fn clippy_lints_src_files() -> impl Iterator<Item = (PathBuf, DirEntry)> {\n macro_rules! match_tokens {\n     ($iter:ident, $($token:ident $({$($fields:tt)*})? $(($capture:ident))?)*) => {\n          {\n-            $($(let $capture =)? if let Some(LintDeclSearchResult {\n+            $(#[allow(clippy::redundant_pattern)] let Some(LintDeclSearchResult {\n                     token_kind: TokenKind::$token $({$($fields)*})?,\n-                    content: _x,\n+                    content: $($capture @)? _,\n                     ..\n-            }) = $iter.next() {\n-                _x\n-            } else {\n+            }) = $iter.next() else {\n                 continue;\n             };)*\n             #[allow(clippy::unused_unit)]"}, {"sha": "1ff976f48f619cd364a5fab44a860f3cb8360706", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -18,7 +18,7 @@ quine-mc_cluskey = \"0.2\"\n regex-syntax = \"0.6\"\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = { version = \"1.0\", optional = true }\n-tempfile = { version = \"3.2\", optional = true }\n+tempfile = { version = \"3.3.0\", optional = true }\n toml = \"0.5\"\n unicode-normalization = \"0.1\"\n unicode-script = { version = \"0.5\", default-features = false }"}, {"sha": "569bf27c3e716e13e3802e7e4cd6fe8bab627135", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -85,8 +85,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n                             );\n                         }\n                     } else {\n-                        let span =\n-                            block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n+                        let span = block.expr.as_ref().map_or_else(|| block.stmts[0].span, |e| e.span);\n                         if span.from_expansion() || expr.span.from_expansion() {\n                             return;\n                         }"}, {"sha": "08164c0b654e2a0daa18737dfc44e0134603dca0", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::eq_expr_value;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{eq_expr_value, get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n@@ -483,7 +483,9 @@ impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n \n fn implements_ord<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+    cx.tcx\n+        .get_diagnostic_item(sym::Ord)\n+        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n }\n \n struct NotSimplificationVisitor<'a, 'tcx> {"}, {"sha": "bb0307e8856d56c7205091e868ada984db7a8388", "filename": "clippy_lints/src/box_default.rs", "status": "modified", "additions": 82, "deletions": 14, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fbox_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fbox_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbox_default.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,12 @@\n-use clippy_utils::{diagnostics::span_lint_and_help, is_default_equivalent, path_def_id};\n-use rustc_hir::{Expr, ExprKind, QPath};\n+use clippy_utils::{\n+    diagnostics::span_lint_and_sugg, get_parent_node, is_default_equivalent, macros::macro_backtrace, match_path,\n+    path_def_id, paths, ty::expr_sig,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_ty, Visitor},\n+    Block, Expr, ExprKind, Local, Node, QPath, TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -15,12 +22,6 @@ declare_clippy_lint! {\n     /// Second, `Box::default()` can be faster\n     /// [in certain cases](https://nnethercote.github.io/perf-book/standard-library-types.html#box).\n     ///\n-    /// ### Known problems\n-    /// The lint may miss some cases (e.g. Box::new(String::from(\"\"))).\n-    /// On the other hand, it will trigger on cases where the `default`\n-    /// code comes from a macro that does something different based on\n-    /// e.g. target operating system.\n-    ///\n     /// ### Example\n     /// ```rust\n     /// let x: Box<String> = Box::new(Default::default());\n@@ -41,21 +42,88 @@ impl LateLintPass<'_> for BoxDefault {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let ExprKind::Call(box_new, [arg]) = expr.kind\n             && let ExprKind::Path(QPath::TypeRelative(ty, seg)) = box_new.kind\n-            && let ExprKind::Call(..) = arg.kind\n+            && let ExprKind::Call(arg_path, ..) = arg.kind\n             && !in_external_macro(cx.sess(), expr.span)\n-            && expr.span.eq_ctxt(arg.span)\n+            && (expr.span.eq_ctxt(arg.span) || is_vec_expn(cx, arg))\n             && seg.ident.name == sym::new\n-            && path_def_id(cx, ty) == cx.tcx.lang_items().owned_box()\n+            && path_def_id(cx, ty).map_or(false, |id| Some(id) == cx.tcx.lang_items().owned_box())\n             && is_default_equivalent(cx, arg)\n         {\n-            span_lint_and_help(\n+            let arg_ty = cx.typeck_results().expr_ty(arg);\n+            span_lint_and_sugg(\n                 cx,\n                 BOX_DEFAULT,\n                 expr.span,\n                 \"`Box::new(_)` of default value\",\n-                None,\n-                \"use `Box::default()` instead\",\n+                \"try\",\n+                if is_plain_default(arg_path) || given_type(cx, expr) {\n+                    \"Box::default()\".into()\n+                } else {\n+                    format!(\"Box::<{arg_ty}>::default()\")\n+                },\n+                Applicability::MachineApplicable\n             );\n         }\n     }\n }\n+\n+fn is_plain_default(arg_path: &Expr<'_>) -> bool {\n+    // we need to match the actual path so we don't match e.g. \"u8::default\"\n+    if let ExprKind::Path(QPath::Resolved(None, path)) = &arg_path.kind {\n+        // avoid generic parameters\n+        match_path(path, &paths::DEFAULT_TRAIT_METHOD) && path.segments.iter().all(|seg| seg.args.is_none())\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_vec_expn(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    macro_backtrace(expr.span)\n+        .next()\n+        .map_or(false, |call| cx.tcx.is_diagnostic_item(sym::vec_macro, call.def_id))\n+}\n+\n+#[derive(Default)]\n+struct InferVisitor(bool);\n+\n+impl<'tcx> Visitor<'tcx> for InferVisitor {\n+    fn visit_ty(&mut self, t: &rustc_hir::Ty<'_>) {\n+        self.0 |= matches!(t.kind, TyKind::Infer);\n+        if !self.0 {\n+            walk_ty(self, t);\n+        }\n+    }\n+}\n+\n+fn given_type(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    match get_parent_node(cx.tcx, expr.hir_id) {\n+        Some(Node::Local(Local { ty: Some(ty), .. })) => {\n+            let mut v = InferVisitor::default();\n+            v.visit_ty(ty);\n+            !v.0\n+        },\n+        Some(\n+            Node::Expr(Expr {\n+                kind: ExprKind::Call(path, args),\n+                ..\n+            }) | Node::Block(Block {\n+                expr:\n+                    Some(Expr {\n+                        kind: ExprKind::Call(path, args),\n+                        ..\n+                    }),\n+                ..\n+            }),\n+        ) => {\n+            if let Some(index) = args.iter().position(|arg| arg.hir_id == expr.hir_id) &&\n+                let Some(sig) = expr_sig(cx, path) &&\n+                let Some(input) = sig.input(index)\n+            {\n+                input.no_bound_vars().is_some()\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n+    }\n+}"}, {"sha": "9409f4844f54b4140217260c97d1f9f09e32f8e4", "filename": "clippy_lints/src/casts/as_ptr_cast_mut.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Fas_ptr_cast_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Fas_ptr_cast_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fas_ptr_cast_mut.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,38 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::{\n+    mir::Mutability,\n+    ty::{self, Ty, TypeAndMut},\n+};\n+\n+use super::AS_PTR_CAST_MUT;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_to: Ty<'_>) {\n+    if let ty::RawPtr(ptrty @ TypeAndMut { mutbl: Mutability::Mut, .. }) = cast_to.kind()\n+        && let ty::RawPtr(TypeAndMut { mutbl: Mutability::Not, .. }) =\n+            cx.typeck_results().node_type(cast_expr.hir_id).kind()\n+        && let ExprKind::MethodCall(method_name, receiver, [], _) = cast_expr.peel_blocks().kind\n+        && method_name.ident.name == rustc_span::sym::as_ptr\n+        && let Some(as_ptr_did) = cx.typeck_results().type_dependent_def_id(cast_expr.peel_blocks().hir_id)\n+        && let as_ptr_sig = cx.tcx.fn_sig(as_ptr_did)\n+        && let Some(first_param_ty) = as_ptr_sig.skip_binder().inputs().iter().next()\n+        && let ty::Ref(_, _, Mutability::Not) = first_param_ty.kind()\n+        && let Some(recv) = snippet_opt(cx, receiver.span)\n+    {\n+        // `as_mut_ptr` might not exist\n+        let applicability = Applicability::MaybeIncorrect;\n+\n+        span_lint_and_sugg(\n+            cx,\n+            AS_PTR_CAST_MUT,\n+            expr.span,\n+            &format!(\"casting the result of `as_ptr` to *{ptrty}\"),\n+            \"replace with\",\n+            format!(\"{recv}.as_mut_ptr()\"),\n+            applicability\n+        );\n+    }\n+}"}, {"sha": "322dc41b3a197dd4301a45c355f193f466d9be61", "filename": "clippy_lints/src/casts/cast_nan_to_int.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_nan_to_int.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,28 @@\n+use super::CAST_NAN_TO_INT;\n+\n+use clippy_utils::consts::{constant, Constant};\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, from_ty: Ty<'_>, to_ty: Ty<'_>) {\n+    if from_ty.is_floating_point() && to_ty.is_integral() && is_known_nan(cx, cast_expr) {\n+        span_lint_and_note(\n+            cx,\n+            CAST_NAN_TO_INT,\n+            expr.span,\n+            &format!(\"casting a known NaN to {to_ty}\"),\n+            None,\n+            \"this always evaluates to 0\",\n+        );\n+    }\n+}\n+\n+fn is_known_nan(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    match constant(cx, cx.typeck_results(), e) {\n+        Some((Constant::F64(n), _)) => n.is_nan(),\n+        Some((Constant::F32(n), _)) => n.is_nan(),\n+        _ => false,\n+    }\n+}"}, {"sha": "b72c4c772f1ce24d655a3d55ddf8d188d28e24f8", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 56, "deletions": 1, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,8 +1,10 @@\n+mod as_ptr_cast_mut;\n mod as_underscore;\n mod borrow_as_ptr;\n mod cast_abs_to_unsigned;\n mod cast_enum_constructor;\n mod cast_lossless;\n+mod cast_nan_to_int;\n mod cast_possible_truncation;\n mod cast_possible_wrap;\n mod cast_precision_loss;\n@@ -569,6 +571,7 @@ declare_clippy_lint! {\n     pedantic,\n     \"borrowing just to cast to a raw pointer\"\n }\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for a raw slice being cast to a slice pointer\n@@ -596,6 +599,54 @@ declare_clippy_lint! {\n     \"casting a slice created from a pointer and length to a slice pointer\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the result of a `&self`-taking `as_ptr` being cast to a mutable pointer\n+    ///\n+    /// ### Why is this bad?\n+    /// Since `as_ptr` takes a `&self`, the pointer won't have write permissions unless interior\n+    /// mutability is used, making it unlikely that having it as a mutable pointer is correct.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let string = String::with_capacity(1);\n+    /// let ptr = string.as_ptr() as *mut u8;\n+    /// unsafe { ptr.write(4) }; // UNDEFINED BEHAVIOUR\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut string = String::with_capacity(1);\n+    /// let ptr = string.as_mut_ptr();\n+    /// unsafe { ptr.write(4) };\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub AS_PTR_CAST_MUT,\n+    nursery,\n+    \"casting the result of the `&self`-taking `as_ptr` to a mutabe pointer\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for a known NaN float being cast to an integer\n+    ///\n+    /// ### Why is this bad?\n+    /// NaNs are cast into zero, so one could simply use this and make the\n+    /// code more readable. The lint could also hint at a programmer error.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let _: (0.0_f32 / 0.0) as u64;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// let _: = 0_u64;\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub CAST_NAN_TO_INT,\n+    suspicious,\n+    \"casting a known floating-point NaN into an integer\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -627,7 +678,9 @@ impl_lint_pass!(Casts => [\n     CAST_ABS_TO_UNSIGNED,\n     AS_UNDERSCORE,\n     BORROW_AS_PTR,\n-    CAST_SLICE_FROM_RAW_PARTS\n+    CAST_SLICE_FROM_RAW_PARTS,\n+    AS_PTR_CAST_MUT,\n+    CAST_NAN_TO_INT,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Casts {\n@@ -653,6 +706,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                 return;\n             }\n             cast_slice_from_raw_parts::check(cx, expr, cast_expr, cast_to, self.msrv);\n+            as_ptr_cast_mut::check(cx, expr, cast_expr, cast_to);\n             fn_to_numeric_cast_any::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast::check(cx, expr, cast_expr, cast_from, cast_to);\n             fn_to_numeric_cast_with_truncation::check(cx, expr, cast_expr, cast_from, cast_to);\n@@ -664,6 +718,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                     cast_precision_loss::check(cx, expr, cast_from, cast_to);\n                     cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n                     cast_abs_to_unsigned::check(cx, expr, cast_expr, cast_from, cast_to, self.msrv);\n+                    cast_nan_to_int::check(cx, expr, cast_expr, cast_from, cast_to);\n                 }\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, self.msrv);\n                 cast_enum_constructor::check(cx, expr, cast_expr, cast_from);"}, {"sha": "c8596987e4d719b158aa879d7f1bc2bf452d4c16", "filename": "clippy_lints/src/casts/unnecessary_cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Funnecessary_cast.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -59,9 +59,6 @@ pub(super) fn check<'tcx>(\n                 lint_unnecessary_cast(cx, expr, literal_str, cast_from, cast_to);\n                 return false;\n             },\n-            LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed) => {\n-                return false;\n-            },\n             LitKind::Int(_, LitIntType::Signed(_) | LitIntType::Unsigned(_))\n             | LitKind::Float(_, LitFloatType::Suffixed(_))\n                 if cast_from.kind() == cast_to.kind() =>"}, {"sha": "0fe973b49a3550235520ab0f87a55139f46fd18f", "filename": "clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, if_sequence, in_constant, is_else_clause, paths, SpanlessEq};\n+use clippy_utils::{if_sequence, in_constant, is_else_clause, SpanlessEq};\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -106,7 +107,10 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n \n                 // Check that the type being compared implements `core::cmp::Ord`\n                 let ty = cx.typeck_results().expr_ty(lhs1);\n-                let is_ord = get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[]));\n+                let is_ord = cx\n+                    .tcx\n+                    .get_diagnostic_item(sym::Ord)\n+                    .map_or(false, |id| implements_trait(cx, ty, id, &[]));\n \n                 if !is_ord {\n                     return;"}, {"sha": "03460689e19ad7a5bdac313b6c2f6eade3fb7b77", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 29, "deletions": 36, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,12 +1,12 @@\n use clippy_utils::diagnostics::span_lint_hir_and_then;\n-use clippy_utils::numeric_literal;\n use clippy_utils::source::snippet_opt;\n+use clippy_utils::{get_parent_node, numeric_literal};\n use if_chain::if_chain;\n use rustc_ast::ast::{LitFloatType, LitIntType, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     intravisit::{walk_expr, walk_stmt, Visitor},\n-    Body, Expr, ExprKind, HirId, Lit, Stmt, StmtKind,\n+    Body, Expr, ExprKind, HirId, ItemKind, Lit, Node, Stmt, StmtKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::{\n@@ -55,22 +55,31 @@ declare_lint_pass!(DefaultNumericFallback => [DEFAULT_NUMERIC_FALLBACK]);\n \n impl<'tcx> LateLintPass<'tcx> for DefaultNumericFallback {\n     fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n-        let mut visitor = NumericFallbackVisitor::new(cx);\n+        let is_parent_const = if let Some(Node::Item(item)) = get_parent_node(cx.tcx, body.id().hir_id) {\n+            matches!(item.kind, ItemKind::Const(..))\n+        } else {\n+            false\n+        };\n+        let mut visitor = NumericFallbackVisitor::new(cx, is_parent_const);\n         visitor.visit_body(body);\n     }\n }\n \n struct NumericFallbackVisitor<'a, 'tcx> {\n     /// Stack manages type bound of exprs. The top element holds current expr type.\n-    ty_bounds: Vec<TyBound<'tcx>>,\n+    ty_bounds: Vec<ExplicitTyBound>,\n \n     cx: &'a LateContext<'tcx>,\n }\n \n impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+    fn new(cx: &'a LateContext<'tcx>, is_parent_const: bool) -> Self {\n         Self {\n-            ty_bounds: vec![TyBound::Nothing],\n+            ty_bounds: vec![if is_parent_const {\n+                ExplicitTyBound(true)\n+            } else {\n+                ExplicitTyBound(false)\n+            }],\n             cx,\n         }\n     }\n@@ -79,10 +88,9 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n     fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>, emit_hir_id: HirId) {\n         if_chain! {\n                 if !in_external_macro(self.cx.sess(), lit.span);\n-                if let Some(ty_bound) = self.ty_bounds.last();\n+                if matches!(self.ty_bounds.last(), Some(ExplicitTyBound(false)));\n                 if matches!(lit.node,\n                             LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));\n-                if !ty_bound.is_numeric();\n                 then {\n                     let (suffix, is_float) = match lit_ty.kind() {\n                         ty::Int(IntTy::I32) => (\"i32\", false),\n@@ -123,7 +131,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n                     for (expr, bound) in iter::zip(*args, fn_sig.skip_binder().inputs()) {\n                         // Push found arg type, then visit arg.\n-                        self.ty_bounds.push(TyBound::Ty(*bound));\n+                        self.ty_bounds.push((*bound).into());\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -135,7 +143,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n                     for (expr, bound) in iter::zip(std::iter::once(*receiver).chain(args.iter()), fn_sig.inputs()) {\n-                        self.ty_bounds.push(TyBound::Ty(*bound));\n+                        self.ty_bounds.push((*bound).into());\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -169,7 +177,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n \n                         // Visit base with no bound.\n                         if let Some(base) = base {\n-                            self.ty_bounds.push(TyBound::Nothing);\n+                            self.ty_bounds.push(ExplicitTyBound(false));\n                             self.visit_expr(base);\n                             self.ty_bounds.pop();\n                         }\n@@ -192,15 +200,10 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n \n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         match stmt.kind {\n-            StmtKind::Local(local) => {\n-                if local.ty.is_some() {\n-                    self.ty_bounds.push(TyBound::Any);\n-                } else {\n-                    self.ty_bounds.push(TyBound::Nothing);\n-                }\n-            },\n+            // we cannot check the exact type since it's a hir::Ty which does not implement `is_numeric`\n+            StmtKind::Local(local) => self.ty_bounds.push(ExplicitTyBound(local.ty.is_some())),\n \n-            _ => self.ty_bounds.push(TyBound::Nothing),\n+            _ => self.ty_bounds.push(ExplicitTyBound(false)),\n         }\n \n         walk_stmt(self, stmt);\n@@ -218,28 +221,18 @@ fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'\n     }\n }\n \n+/// Wrapper around a `bool` to make the meaning of the value clearer\n #[derive(Debug, Clone, Copy)]\n-enum TyBound<'tcx> {\n-    Any,\n-    Ty(Ty<'tcx>),\n-    Nothing,\n-}\n+struct ExplicitTyBound(pub bool);\n \n-impl<'tcx> TyBound<'tcx> {\n-    fn is_numeric(self) -> bool {\n-        match self {\n-            TyBound::Any => true,\n-            TyBound::Ty(t) => t.is_numeric(),\n-            TyBound::Nothing => false,\n-        }\n+impl<'tcx> From<Ty<'tcx>> for ExplicitTyBound {\n+    fn from(v: Ty<'tcx>) -> Self {\n+        Self(v.is_numeric())\n     }\n }\n \n-impl<'tcx> From<Option<Ty<'tcx>>> for TyBound<'tcx> {\n+impl<'tcx> From<Option<Ty<'tcx>>> for ExplicitTyBound {\n     fn from(v: Option<Ty<'tcx>>) -> Self {\n-        match v {\n-            Some(t) => TyBound::Ty(t),\n-            None => TyBound::Nothing,\n-        }\n+        Self(v.map_or(false, Ty::is_numeric))\n     }\n }"}, {"sha": "46a0bfcb9c9c2ff7f2a3c040b7204ac211157438", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 84, "deletions": 15, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n+use clippy_utils::mir::{enclosing_mir, expr_local, local_assignments, used_exactly_once, PossibleBorrowerMap};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n use clippy_utils::ty::{expr_sig, is_copy, peel_mid_ty_refs, ty_sig, variant_of_res};\n@@ -11,13 +12,16 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_ty, Visitor};\n use rustc_hir::{\n-    self as hir, def_id::DefId, BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy,\n-    GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n-    Path, QPath, TraitItem, TraitItemKind, TyKind, UnOp,\n+    self as hir,\n+    def_id::{DefId, LocalDefId},\n+    BindingAnnotation, Body, BodyId, BorrowKind, Closure, Expr, ExprKind, FnRetTy, GenericArg, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n+    TraitItemKind, TyKind, UnOp,\n };\n use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::{Rvalue, StatementKind};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{\n     self, Binder, BoundVariableKind, EarlyBinder, FnSig, GenericArgKind, List, ParamTy, PredicateKind,\n@@ -141,15 +145,15 @@ declare_clippy_lint! {\n     \"dereferencing when the compiler would automatically dereference\"\n }\n \n-impl_lint_pass!(Dereferencing => [\n+impl_lint_pass!(Dereferencing<'_> => [\n     EXPLICIT_DEREF_METHODS,\n     NEEDLESS_BORROW,\n     REF_BINDING_TO_REFERENCE,\n     EXPLICIT_AUTO_DEREF,\n ]);\n \n #[derive(Default)]\n-pub struct Dereferencing {\n+pub struct Dereferencing<'tcx> {\n     state: Option<(State, StateData)>,\n \n     // While parsing a `deref` method call in ufcs form, the path to the function is itself an\n@@ -170,11 +174,16 @@ pub struct Dereferencing {\n     /// e.g. `m!(x) | Foo::Bar(ref x)`\n     ref_locals: FxIndexMap<HirId, Option<RefPat>>,\n \n+    /// Stack of (body owner, `PossibleBorrowerMap`) pairs. Used by\n+    /// `needless_borrow_impl_arg_position` to determine when a borrowed expression can instead\n+    /// be moved.\n+    possible_borrowers: Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n+\n     // `IntoIterator` for arrays requires Rust 1.53.\n     msrv: Option<RustcVersion>,\n }\n \n-impl Dereferencing {\n+impl<'tcx> Dereferencing<'tcx> {\n     #[must_use]\n     pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self {\n@@ -244,7 +253,7 @@ struct RefPat {\n     hir_id: HirId,\n }\n \n-impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n+impl<'tcx> LateLintPass<'tcx> for Dereferencing<'tcx> {\n     #[expect(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n@@ -278,7 +287,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n         match (self.state.take(), kind) {\n             (None, kind) => {\n                 let expr_ty = typeck.expr_ty(expr);\n-                let (position, adjustments) = walk_parents(cx, expr, self.msrv);\n+                let (position, adjustments) = walk_parents(cx, &mut self.possible_borrowers, expr, self.msrv);\n                 match kind {\n                     RefOp::Deref => {\n                         if let Position::FieldAccess {\n@@ -550,6 +559,12 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     }\n \n     fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n+        if self.possible_borrowers.last().map_or(false, |&(local_def_id, _)| {\n+            local_def_id == cx.tcx.hir().body_owner_def_id(body.id())\n+        }) {\n+            self.possible_borrowers.pop();\n+        }\n+\n         if Some(body.id()) == self.current_body {\n             for pat in self.ref_locals.drain(..).filter_map(|(_, x)| x) {\n                 let replacements = pat.replacements;\n@@ -682,6 +697,7 @@ impl Position {\n #[expect(clippy::too_many_lines)]\n fn walk_parents<'tcx>(\n     cx: &LateContext<'tcx>,\n+    possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n     e: &'tcx Expr<'_>,\n     msrv: Option<RustcVersion>,\n ) -> (Position, &'tcx [Adjustment<'tcx>]) {\n@@ -796,7 +812,16 @@ fn walk_parents<'tcx>(\n                             Some(hir_ty) => binding_ty_auto_deref_stability(cx, hir_ty, precedence, ty.bound_vars()),\n                             None => {\n                                 if let ty::Param(param_ty) = ty.skip_binder().kind() {\n-                                    needless_borrow_impl_arg_position(cx, parent, i, *param_ty, e, precedence, msrv)\n+                                    needless_borrow_impl_arg_position(\n+                                        cx,\n+                                        possible_borrowers,\n+                                        parent,\n+                                        i,\n+                                        *param_ty,\n+                                        e,\n+                                        precedence,\n+                                        msrv,\n+                                    )\n                                 } else {\n                                     ty_auto_deref_stability(cx, cx.tcx.erase_late_bound_regions(ty), precedence)\n                                         .position_for_arg()\n@@ -843,7 +868,16 @@ fn walk_parents<'tcx>(\n                     args.iter().position(|arg| arg.hir_id == child_id).map(|i| {\n                         let ty = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n                         if let ty::Param(param_ty) = ty.kind() {\n-                            needless_borrow_impl_arg_position(cx, parent, i + 1, *param_ty, e, precedence, msrv)\n+                            needless_borrow_impl_arg_position(\n+                                cx,\n+                                possible_borrowers,\n+                                parent,\n+                                i + 1,\n+                                *param_ty,\n+                                e,\n+                                precedence,\n+                                msrv,\n+                            )\n                         } else {\n                             ty_auto_deref_stability(\n                                 cx,\n@@ -1017,8 +1051,10 @@ fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n // If the conditions are met, returns `Some(Position::ImplArg(..))`; otherwise, returns `None`.\n //   The \"is copyable\" condition is to avoid the case where removing the `&` means `e` would have to\n // be moved, but it cannot be.\n+#[expect(clippy::too_many_arguments)]\n fn needless_borrow_impl_arg_position<'tcx>(\n     cx: &LateContext<'tcx>,\n+    possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n     parent: &Expr<'tcx>,\n     arg_index: usize,\n     param_ty: ParamTy,\n@@ -1081,10 +1117,13 @@ fn needless_borrow_impl_arg_position<'tcx>(\n     // elements are modified each time `check_referent` is called.\n     let mut substs_with_referent_ty = substs_with_expr_ty.to_vec();\n \n-    let mut check_referent = |referent| {\n+    let mut check_reference_and_referent = |reference, referent| {\n         let referent_ty = cx.typeck_results().expr_ty(referent);\n \n-        if !is_copy(cx, referent_ty) {\n+        if !is_copy(cx, referent_ty)\n+            && (referent_ty.has_significant_drop(cx.tcx, cx.param_env)\n+                || !referent_used_exactly_once(cx, possible_borrowers, reference))\n+        {\n             return false;\n         }\n \n@@ -1125,7 +1164,7 @@ fn needless_borrow_impl_arg_position<'tcx>(\n \n     let mut needless_borrow = false;\n     while let ExprKind::AddrOf(_, _, referent) = expr.kind {\n-        if !check_referent(referent) {\n+        if !check_reference_and_referent(expr, referent) {\n             break;\n         }\n         expr = referent;\n@@ -1153,6 +1192,36 @@ fn has_ref_mut_self_method(cx: &LateContext<'_>, trait_def_id: DefId) -> bool {\n         })\n }\n \n+fn referent_used_exactly_once<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    possible_borrowers: &mut Vec<(LocalDefId, PossibleBorrowerMap<'tcx, 'tcx>)>,\n+    reference: &Expr<'tcx>,\n+) -> bool {\n+    let mir = enclosing_mir(cx.tcx, reference.hir_id);\n+    if let Some(local) = expr_local(cx.tcx, reference)\n+        && let [location] = *local_assignments(mir, local).as_slice()\n+        && let StatementKind::Assign(box (_, Rvalue::Ref(_, _, place))) =\n+            mir.basic_blocks[location.block].statements[location.statement_index].kind\n+        && !place.has_deref()\n+    {\n+        let body_owner_local_def_id = cx.tcx.hir().enclosing_body_owner(reference.hir_id);\n+        if possible_borrowers\n+            .last()\n+            .map_or(true, |&(local_def_id, _)| local_def_id != body_owner_local_def_id)\n+        {\n+            possible_borrowers.push((body_owner_local_def_id, PossibleBorrowerMap::new(cx, mir)));\n+        }\n+        let possible_borrower = &mut possible_borrowers.last_mut().unwrap().1;\n+        // If `only_borrowers` were used here, the `copyable_iterator::warn` test would fail. The reason is\n+        // that `PossibleBorrowerVisitor::visit_terminator` considers `place.local` a possible borrower of\n+        // itself. See the comment in that method for an explanation as to why.\n+        possible_borrower.bounded_borrowers(&[local], &[local, place.local], place.local, location)\n+            && used_exactly_once(mir, place.local).unwrap_or(false)\n+    } else {\n+        false\n+    }\n+}\n+\n // Iteratively replaces `param_ty` with `new_ty` in `substs`, and similarly for each resulting\n // projected type that is a type parameter. Returns `false` if replacing the types would have an\n // effect on the function signature beyond substituting `new_ty` for `param_ty`.\n@@ -1437,8 +1506,8 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data\n     }\n }\n \n-impl Dereferencing {\n-    fn check_local_usage<'tcx>(&mut self, cx: &LateContext<'tcx>, e: &Expr<'tcx>, local: HirId) {\n+impl<'tcx> Dereferencing<'tcx> {\n+    fn check_local_usage(&mut self, cx: &LateContext<'tcx>, e: &Expr<'tcx>, local: HirId) {\n         if let Some(outer_pat) = self.ref_locals.get_mut(&local) {\n             if let Some(pat) = outer_pat {\n                 // Check for auto-deref"}, {"sha": "fad984d05ca95fa04f20cd76446688db9322748c", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -339,10 +339,7 @@ fn check_copy_clone<'tcx>(cx: &LateContext<'tcx>, item: &Item<'_>, trait_ref: &h\n         Some(id) if trait_ref.trait_def_id() == Some(id) => id,\n         _ => return,\n     };\n-    let copy_id = match cx.tcx.lang_items().copy_trait() {\n-        Some(id) => id,\n-        None => return,\n-    };\n+    let Some(copy_id) = cx.tcx.lang_items().copy_trait() else { return };\n     let (ty_adt, ty_subs) = match *ty.kind() {\n         // Unions can't derive clone.\n         ty::Adt(adt, subs) if !adt.is_union() => (adt, subs),"}, {"sha": "6ac85606d9c7cf86827b7f038701fe152887e74b", "filename": "clippy_lints/src/disallowed_methods.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fdisallowed_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_methods.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -94,9 +94,8 @@ impl<'tcx> LateLintPass<'tcx> for DisallowedMethods {\n         } else {\n             path_def_id(cx, expr)\n         };\n-        let def_id = match uncalled_path.or_else(|| fn_def_id(cx, expr)) {\n-            Some(def_id) => def_id,\n-            None => return,\n+        let Some(def_id) = uncalled_path.or_else(|| fn_def_id(cx, expr)) else {\n+            return\n         };\n         let conf = match self.disallowed.get(&def_id) {\n             Some(&index) => &self.conf_disallowed[index],"}, {"sha": "b44e62435881fdca6e8144f6fe788bacf8c745ee", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -65,28 +65,24 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     #[expect(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (cond_expr, then_expr, else_expr) = match higher::If::hir(expr) {\n-            Some(higher::If { cond, then, r#else }) => (cond, then, r#else),\n-            _ => return,\n+        let Some(higher::If { cond: cond_expr, then: then_expr, r#else: else_expr }) = higher::If::hir(expr) else {\n+            return\n         };\n \n-        let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n-            Some(x) => x,\n-            None => return,\n+        let Some((map_ty, contains_expr)) = try_parse_contains(cx, cond_expr) else {\n+            return\n         };\n \n-        let then_search = match find_insert_calls(cx, &contains_expr, then_expr) {\n-            Some(x) => x,\n-            None => return,\n+        let Some(then_search) = find_insert_calls(cx, &contains_expr, then_expr) else {\n+            return\n         };\n \n         let mut app = Applicability::MachineApplicable;\n         let map_str = snippet_with_context(cx, contains_expr.map.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n         let key_str = snippet_with_context(cx, contains_expr.key.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n         let sugg = if let Some(else_expr) = else_expr {\n-            let else_search = match find_insert_calls(cx, &contains_expr, else_expr) {\n-                Some(search) => search,\n-                None => return,\n+            let Some(else_search) = find_insert_calls(cx, &contains_expr, else_expr) else {\n+                return;\n             };\n \n             if then_search.edits.is_empty() && else_search.edits.is_empty() {"}, {"sha": "7b9786d7e570f91b398f2d7ea9e4fa46cb098fdf", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -213,9 +213,8 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, closure_ty: Ty<'tcx>, call_ty: Ty<'tc\n     if !closure_ty.has_late_bound_regions() {\n         return true;\n     }\n-    let substs = match closure_ty.kind() {\n-        ty::Closure(_, substs) => substs,\n-        _ => return false,\n+    let ty::Closure(_, substs) = closure_ty.kind() else {\n+        return false;\n     };\n     let closure_sig = cx.tcx.signature_unclosure(substs.as_closure().sig(), Unsafety::Normal);\n     cx.tcx.erase_late_bound_regions(closure_sig) == cx.tcx.erase_late_bound_regions(call_sig)"}, {"sha": "4c4a1e06cd4348d06181e30c6d3a1b8aedc853a8", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 149, "deletions": 34, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,8 +1,10 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::FormatParamKind::{Implicit, Named, Numbered, Starred};\n-use clippy_utils::macros::{is_format_macro, FormatArgsExpn, FormatParam, FormatParamUsage};\n+use clippy_utils::macros::{\n+    is_format_macro, is_panic, root_macro_call, Count, FormatArg, FormatArgsExpn, FormatParam, FormatParamUsage,\n+};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::implements_trait;\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n use clippy_utils::{is_diag_trait_item, meets_msrv, msrvs};\n use if_chain::if_chain;\n use itertools::Itertools;\n@@ -13,6 +15,8 @@ use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n use rustc_middle::ty::Ty;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::DefId;\n+use rustc_span::edition::Edition::Edition2021;\n use rustc_span::{sym, ExpnData, ExpnKind, Span, Symbol};\n \n declare_clippy_lint! {\n@@ -111,11 +115,47 @@ declare_clippy_lint! {\n     /// nothing will be suggested, e.g. `println!(\"{0}={1}\", var, 1+2)`.\n     #[clippy::version = \"1.65.0\"]\n     pub UNINLINED_FORMAT_ARGS,\n-    pedantic,\n+    style,\n     \"using non-inlined variables in `format!` calls\"\n }\n \n-impl_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, UNINLINED_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects [formatting parameters] that have no effect on the output of\n+    /// `format!()`, `println!()` or similar macros.\n+    ///\n+    /// ### Why is this bad?\n+    /// Shorter format specifiers are easier to read, it may also indicate that\n+    /// an expected formatting operation such as adding padding isn't happening.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// println!(\"{:.}\", 1.0);\n+    ///\n+    /// println!(\"not padded: {:5}\", format_args!(\"...\"));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// println!(\"{}\", 1.0);\n+    ///\n+    /// println!(\"not padded: {}\", format_args!(\"...\"));\n+    /// // OR\n+    /// println!(\"padded: {:5}\", format!(\"...\"));\n+    /// ```\n+    ///\n+    /// [formatting parameters]: https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters\n+    #[clippy::version = \"1.66.0\"]\n+    pub UNUSED_FORMAT_SPECS,\n+    complexity,\n+    \"use of a format specifier that has no effect\"\n+}\n+\n+impl_lint_pass!(FormatArgs => [\n+    FORMAT_IN_FORMAT_ARGS,\n+    TO_STRING_IN_FORMAT_ARGS,\n+    UNINLINED_FORMAT_ARGS,\n+    UNUSED_FORMAT_SPECS,\n+]);\n \n pub struct FormatArgs {\n     msrv: Option<RustcVersion>,\n@@ -130,38 +170,111 @@ impl FormatArgs {\n \n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let Some(format_args) = FormatArgsExpn::parse(cx, expr);\n-            let expr_expn_data = expr.span.ctxt().outer_expn_data();\n-            let outermost_expn_data = outermost_expn_data(expr_expn_data);\n-            if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n-            if is_format_macro(cx, macro_def_id);\n-            if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n-            then {\n-                for arg in &format_args.args {\n-                    if !arg.format.is_default() {\n-                        continue;\n-                    }\n-                    if is_aliased(&format_args, arg.param.value.hir_id) {\n-                        continue;\n-                    }\n-                    check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n-                    check_to_string_in_format_args(cx, name, arg.param.value);\n+        if let Some(format_args) = FormatArgsExpn::parse(cx, expr)\n+            && let expr_expn_data = expr.span.ctxt().outer_expn_data()\n+            && let outermost_expn_data = outermost_expn_data(expr_expn_data)\n+            && let Some(macro_def_id) = outermost_expn_data.macro_def_id\n+            && is_format_macro(cx, macro_def_id)\n+            && let ExpnKind::Macro(_, name) = outermost_expn_data.kind\n+        {\n+            for arg in &format_args.args {\n+                check_unused_format_specifier(cx, arg);\n+                if !arg.format.is_default() {\n+                    continue;\n                 }\n-                if meets_msrv(self.msrv, msrvs::FORMAT_ARGS_CAPTURE) {\n-                    check_uninlined_args(cx, &format_args, outermost_expn_data.call_site);\n+                if is_aliased(&format_args, arg.param.value.hir_id) {\n+                    continue;\n                 }\n+                check_format_in_format_args(cx, outermost_expn_data.call_site, name, arg.param.value);\n+                check_to_string_in_format_args(cx, name, arg.param.value);\n+            }\n+            if meets_msrv(self.msrv, msrvs::FORMAT_ARGS_CAPTURE) {\n+                check_uninlined_args(cx, &format_args, outermost_expn_data.call_site, macro_def_id);\n             }\n         }\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n \n-fn check_uninlined_args(cx: &LateContext<'_>, args: &FormatArgsExpn<'_>, call_site: Span) {\n+fn check_unused_format_specifier(cx: &LateContext<'_>, arg: &FormatArg<'_>) {\n+    let param_ty = cx.typeck_results().expr_ty(arg.param.value).peel_refs();\n+\n+    if let Count::Implied(Some(mut span)) = arg.format.precision\n+        && !span.is_empty()\n+    {\n+        span_lint_and_then(\n+            cx,\n+            UNUSED_FORMAT_SPECS,\n+            span,\n+            \"empty precision specifier has no effect\",\n+            |diag| {\n+                if param_ty.is_floating_point() {\n+                    diag.note(\"a precision specifier is not required to format floats\");\n+                }\n+\n+                if arg.format.is_default() {\n+                    // If there's no other specifiers remove the `:` too\n+                    span = arg.format_span();\n+                }\n+\n+                diag.span_suggestion_verbose(span, \"remove the `.`\", \"\", Applicability::MachineApplicable);\n+            },\n+        );\n+    }\n+\n+    if is_type_diagnostic_item(cx, param_ty, sym::Arguments) && !arg.format.is_default_for_trait() {\n+        span_lint_and_then(\n+            cx,\n+            UNUSED_FORMAT_SPECS,\n+            arg.span,\n+            \"format specifiers have no effect on `format_args!()`\",\n+            |diag| {\n+                let mut suggest_format = |spec, span| {\n+                    let message = format!(\"for the {spec} to apply consider using `format!()`\");\n+\n+                    if let Some(mac_call) = root_macro_call(arg.param.value.span)\n+                        && cx.tcx.is_diagnostic_item(sym::format_args_macro, mac_call.def_id)\n+                        && arg.span.eq_ctxt(mac_call.span)\n+                    {\n+                        diag.span_suggestion(\n+                            cx.sess().source_map().span_until_char(mac_call.span, '!'),\n+                            message,\n+                            \"format\",\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else if let Some(span) = span {\n+                        diag.span_help(span, message);\n+                    }\n+                };\n+\n+                if !arg.format.width.is_implied() {\n+                    suggest_format(\"width\", arg.format.width.span());\n+                }\n+\n+                if !arg.format.precision.is_implied() {\n+                    suggest_format(\"precision\", arg.format.precision.span());\n+                }\n+\n+                diag.span_suggestion_verbose(\n+                    arg.format_span(),\n+                    \"if the current behavior is intentional, remove the format specifiers\",\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            },\n+        );\n+    }\n+}\n+\n+fn check_uninlined_args(cx: &LateContext<'_>, args: &FormatArgsExpn<'_>, call_site: Span, def_id: DefId) {\n     if args.format_string.span.from_expansion() {\n         return;\n     }\n+    if call_site.edition() < Edition2021 && is_panic(cx, def_id) {\n+        // panic! before 2021 edition considers a single string argument as non-format\n+        return;\n+    }\n \n     let mut fixes = Vec::new();\n     // If any of the arguments are referenced by an index number,\n@@ -217,12 +330,7 @@ fn outermost_expn_data(expn_data: ExpnData) -> ExpnData {\n     }\n }\n \n-fn check_format_in_format_args(\n-    cx: &LateContext<'_>,\n-    call_site: Span,\n-    name: Symbol,\n-    arg: &Expr<'_>,\n-) {\n+fn check_format_in_format_args(cx: &LateContext<'_>, call_site: Span, name: Symbol, arg: &Expr<'_>) {\n     let expn_data = arg.span.ctxt().outer_expn_data();\n     if expn_data.call_site.from_expansion() {\n         return;\n@@ -248,7 +356,7 @@ fn check_format_in_format_args(\n fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Expr<'_>) {\n     if_chain! {\n         if !value.span.from_expansion();\n-        if let ExprKind::MethodCall(_, receiver, [], _) = value.kind;\n+        if let ExprKind::MethodCall(_, receiver, [], to_string_span) = value.kind;\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(value.hir_id);\n         if is_diag_trait_item(cx, method_def_id, sym::ToString);\n         let receiver_ty = cx.typeck_results().expr_ty(receiver);\n@@ -264,7 +372,7 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n                 span_lint_and_sugg(\n                     cx,\n                     TO_STRING_IN_FORMAT_ARGS,\n-                    value.span.with_lo(receiver.span.hi()),\n+                    to_string_span.with_lo(receiver.span.hi()),\n                     &format!(\n                         \"`to_string` applied to a type that implements `Display` in `{name}!` args\"\n                     ),\n@@ -295,7 +403,10 @@ fn check_to_string_in_format_args(cx: &LateContext<'_>, name: Symbol, value: &Ex\n \n /// Returns true if `hir_id` is referred to by multiple format params\n fn is_aliased(args: &FormatArgsExpn<'_>, hir_id: HirId) -> bool {\n-    args.params().filter(|param| param.value.hir_id == hir_id).at_most_one().is_err()\n+    args.params()\n+        .filter(|param| param.value.hir_id == hir_id)\n+        .at_most_one()\n+        .is_err()\n }\n \n fn count_needed_derefs<'tcx, I>(mut ty: Ty<'tcx>, mut iter: I) -> (usize, Ty<'tcx>)\n@@ -305,7 +416,11 @@ where\n     let mut n_total = 0;\n     let mut n_needed = 0;\n     loop {\n-        if let Some(Adjustment { kind: Adjust::Deref(overloaded_deref), target }) = iter.next() {\n+        if let Some(Adjustment {\n+            kind: Adjust::Deref(overloaded_deref),\n+            target,\n+        }) = iter.next()\n+        {\n             n_total += 1;\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;"}, {"sha": "95eda4ea88275b2a270bf0648ab96168d9c88140", "filename": "clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 154, "deletions": 22, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,11 +1,19 @@\n-use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_hir as hir;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::macros::span_is_local;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::{meets_msrv, msrvs, path_def_id};\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_path, Visitor};\n+use rustc_hir::{\n+    GenericArg, GenericArgs, HirId, Impl, ImplItemKind, ImplItemRef, Item, ItemKind, PatKind, Path, PathSegment, Ty,\n+    TyKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{kw, sym};\n+use rustc_span::{Span, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -54,28 +62,152 @@ impl FromOverInto {\n impl_lint_pass!(FromOverInto => [FROM_OVER_INTO]);\n \n impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !meets_msrv(self.msrv, msrvs::RE_REBALANCING_COHERENCE) {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if !meets_msrv(self.msrv, msrvs::RE_REBALANCING_COHERENCE) || !span_is_local(item.span) {\n             return;\n         }\n \n-        if_chain! {\n-            if let hir::ItemKind::Impl{ .. } = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n-            if cx.tcx.is_diagnostic_item(sym::Into, impl_trait_ref.def_id);\n-\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    FROM_OVER_INTO,\n-                    cx.tcx.sess.source_map().guess_head_span(item.span),\n-                    \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n-                    None,\n-                    &format!(\"consider to implement `From<{}>` instead\", impl_trait_ref.self_ty()),\n-                );\n-            }\n+        if let ItemKind::Impl(Impl {\n+            of_trait: Some(hir_trait_ref),\n+            self_ty,\n+            items: [impl_item_ref],\n+            ..\n+        }) = item.kind\n+            && let Some(into_trait_seg) = hir_trait_ref.path.segments.last()\n+            // `impl Into<target_ty> for self_ty`\n+            && let Some(GenericArgs { args: [GenericArg::Type(target_ty)], .. }) = into_trait_seg.args\n+            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+            && cx.tcx.is_diagnostic_item(sym::Into, middle_trait_ref.def_id)\n+        {\n+            span_lint_and_then(\n+                cx,\n+                FROM_OVER_INTO,\n+                cx.tcx.sess.source_map().guess_head_span(item.span),\n+                \"an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\",\n+                |diag| {\n+                    // If the target type is likely foreign mention the orphan rules as it's a common source of confusion\n+                    if path_def_id(cx, target_ty.peel_refs()).map_or(true, |id| !id.is_local()) {\n+                        diag.help(\n+                            \"`impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\\n\\\n+                            https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\"\n+                        );\n+                    }\n+\n+                    let message = format!(\"replace the `Into` implentation with `From<{}>`\", middle_trait_ref.self_ty());\n+                    if let Some(suggestions) = convert_to_from(cx, into_trait_seg, target_ty, self_ty, impl_item_ref) {\n+                        diag.multipart_suggestion(message, suggestions, Applicability::MachineApplicable);\n+                    } else {\n+                        diag.help(message);\n+                    }\n+                },\n+            );\n         }\n     }\n \n     extract_msrv_attr!(LateContext);\n }\n+\n+/// Finds the occurences of `Self` and `self`\n+struct SelfFinder<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    /// Occurences of `Self`\n+    upper: Vec<Span>,\n+    /// Occurences of `self`\n+    lower: Vec<Span>,\n+    /// If any of the `self`/`Self` usages were from an expansion, or the body contained a binding\n+    /// already named `val`\n+    invalid: bool,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for SelfFinder<'a, 'tcx> {\n+    type NestedFilter = OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n+        for segment in path.segments {\n+            match segment.ident.name {\n+                kw::SelfLower => self.lower.push(segment.ident.span),\n+                kw::SelfUpper => self.upper.push(segment.ident.span),\n+                _ => continue,\n+            }\n+        }\n+\n+        self.invalid |= path.span.from_expansion();\n+        if !self.invalid {\n+            walk_path(self, path);\n+        }\n+    }\n+\n+    fn visit_name(&mut self, name: Symbol) {\n+        if name == sym::val {\n+            self.invalid = true;\n+        }\n+    }\n+}\n+\n+fn convert_to_from(\n+    cx: &LateContext<'_>,\n+    into_trait_seg: &PathSegment<'_>,\n+    target_ty: &Ty<'_>,\n+    self_ty: &Ty<'_>,\n+    impl_item_ref: &ImplItemRef,\n+) -> Option<Vec<(Span, String)>> {\n+    let impl_item = cx.tcx.hir().impl_item(impl_item_ref.id);\n+    let ImplItemKind::Fn(ref sig, body_id) = impl_item.kind else { return None };\n+    let body = cx.tcx.hir().body(body_id);\n+    let [input] = body.params else { return None };\n+    let PatKind::Binding(.., self_ident, None) = input.pat.kind else { return None };\n+\n+    let from = snippet_opt(cx, self_ty.span)?;\n+    let into = snippet_opt(cx, target_ty.span)?;\n+\n+    let mut suggestions = vec![\n+        // impl Into<T> for U  ->  impl From<T> for U\n+        //      ~~~~                    ~~~~\n+        (into_trait_seg.ident.span, String::from(\"From\")),\n+        // impl Into<T> for U  ->  impl Into<U> for U\n+        //           ~                       ~\n+        (target_ty.span, from.clone()),\n+        // impl Into<T> for U  ->  impl Into<T> for T\n+        //                  ~                       ~\n+        (self_ty.span, into),\n+        // fn into(self) -> T  ->  fn from(self) -> T\n+        //    ~~~~                    ~~~~\n+        (impl_item.ident.span, String::from(\"from\")),\n+        // fn into([mut] self) -> T  ->  fn into([mut] v: T) -> T\n+        //               ~~~~                          ~~~~\n+        (self_ident.span, format!(\"val: {from}\")),\n+        // fn into(self) -> T  ->  fn into(self) -> Self\n+        //                  ~                       ~~~~\n+        (sig.decl.output.span(), String::from(\"Self\")),\n+    ];\n+\n+    let mut finder = SelfFinder {\n+        cx,\n+        upper: Vec::new(),\n+        lower: Vec::new(),\n+        invalid: false,\n+    };\n+    finder.visit_expr(body.value);\n+\n+    if finder.invalid {\n+        return None;\n+    }\n+\n+    // don't try to replace e.g. `Self::default()` with `&[T]::default()`\n+    if !finder.upper.is_empty() && !matches!(self_ty.kind, TyKind::Path(_)) {\n+        return None;\n+    }\n+\n+    for span in finder.upper {\n+        suggestions.push((span, from.clone()));\n+    }\n+    for span in finder.lower {\n+        suggestions.push((span, String::from(\"val\")));\n+    }\n+\n+    Some(suggestions)\n+}"}, {"sha": "3064b6c9d22f808f6593660db86a0f6adf589e2f", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -7,14 +7,14 @@ use rustc_middle::{\n     lint::in_external_macro,\n     ty::{self, Ty},\n };\n-use rustc_span::{sym, Span};\n+use rustc_span::{sym, Span, Symbol};\n \n use clippy_utils::attrs::is_proc_macro;\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_must_use_ty;\n use clippy_utils::visitors::for_each_expr;\n-use clippy_utils::{match_def_path, return_ty, trait_ref_of_method};\n+use clippy_utils::{return_ty, trait_ref_of_method};\n \n use core::ops::ControlFlow;\n \n@@ -181,15 +181,17 @@ fn is_mutable_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, tys: &mut DefIdSet)\n     }\n }\n \n-static KNOWN_WRAPPER_TYS: &[&[&str]] = &[&[\"alloc\", \"rc\", \"Rc\"], &[\"std\", \"sync\", \"Arc\"]];\n+static KNOWN_WRAPPER_TYS: &[Symbol] = &[sym::Rc, sym::Arc];\n \n fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &mut DefIdSet) -> bool {\n     match *ty.kind() {\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n             tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n-                || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did(), path))\n+                || KNOWN_WRAPPER_TYS\n+                    .iter()\n+                    .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n         ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),"}, {"sha": "bd473ac7e51b0e9695f741029dda1bd68380ecdf", "filename": "clippy_lints/src/functions/too_many_lines.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Ftoo_many_lines.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -22,9 +22,8 @@ pub(super) fn check_fn(\n         return;\n     }\n \n-    let code_snippet = match snippet_opt(cx, body.value.span) {\n-        Some(s) => s,\n-        _ => return,\n+    let Some(code_snippet) = snippet_opt(cx, body.value.span) else {\n+        return\n     };\n     let mut line_count: u64 = 0;\n     let mut in_comment = false;"}, {"sha": "29d59c26d92c4a2f697399ff93df5c753bc89152", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -35,7 +35,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.44.0\"]\n     pub IMPLICIT_SATURATING_SUB,\n-    pedantic,\n+    style,\n     \"Perform saturating subtraction instead of implicitly checking lower bound of data type\"\n }\n "}, {"sha": "0ef77e03de9062bb5cc98ea27ec07c3ce94fd050", "filename": "clippy_lints/src/invalid_upcast_comparisons.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_upcast_comparisons.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -145,9 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidUpcastComparisons {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Binary(ref cmp, lhs, rhs) = expr.kind {\n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);\n-            let (rel, normalized_lhs, normalized_rhs) = if let Some(val) = normalized {\n-                val\n-            } else {\n+            let Some((rel, normalized_lhs, normalized_rhs)) = normalized else {\n                 return;\n             };\n "}, {"sha": "8ed7e4bb196cd63fa14aaea0d5db007ff65f3d4a", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -124,9 +124,8 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n             let ty = cx.tcx.type_of(item.def_id);\n-            let (adt, subst) = match ty.kind() {\n-                Adt(adt, subst) => (adt, subst),\n-                _ => panic!(\"already checked whether this is an enum\"),\n+            let Adt(adt, subst) = ty.kind() else {\n+                panic!(\"already checked whether this is an enum\")\n             };\n             if adt.variants().len() <= 1 {\n                 return;"}, {"sha": "b7798b1c1d749ae488a6ed08fee2824f7ca9999f", "filename": "clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_underscore.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::{is_must_use_ty, match_type};\n+use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item, match_type};\n use clippy_utils::{is_must_use_func_call, paths};\n use if_chain::if_chain;\n use rustc_hir::{Local, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{sym, Symbol};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -99,10 +100,9 @@ declare_clippy_lint! {\n \n declare_lint_pass!(LetUnderscore => [LET_UNDERSCORE_MUST_USE, LET_UNDERSCORE_LOCK, LET_UNDERSCORE_DROP]);\n \n-const SYNC_GUARD_PATHS: [&[&str]; 6] = [\n-    &paths::MUTEX_GUARD,\n-    &paths::RWLOCK_READ_GUARD,\n-    &paths::RWLOCK_WRITE_GUARD,\n+const SYNC_GUARD_SYMS: [Symbol; 3] = [sym::MutexGuard, sym::RwLockReadGuard, sym::RwLockWriteGuard];\n+\n+const SYNC_GUARD_PATHS: [&[&str]; 3] = [\n     &paths::PARKING_LOT_MUTEX_GUARD,\n     &paths::PARKING_LOT_RWLOCK_READ_GUARD,\n     &paths::PARKING_LOT_RWLOCK_WRITE_GUARD,\n@@ -121,7 +121,10 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 let init_ty = cx.typeck_results().expr_ty(init);\n                 let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n-                        SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n+                        SYNC_GUARD_SYMS\n+                            .iter()\n+                            .any(|&sym| is_type_diagnostic_item(cx, inner_ty, sym))\n+                            || SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n                     },\n \n                     GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n@@ -134,7 +137,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"non-binding let on a synchronization lock\",\n                         None,\n                         \"consider using an underscore-prefixed named \\\n-                            binding or dropping explicitly with `std::mem::drop`\"\n+                            binding or dropping explicitly with `std::mem::drop`\",\n                     );\n                 } else if init_ty.needs_drop(cx.tcx, cx.param_env) {\n                     span_lint_and_help(\n@@ -144,7 +147,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         \"non-binding `let` on a type that implements `Drop`\",\n                         None,\n                         \"consider using an underscore-prefixed named \\\n-                            binding or dropping explicitly with `std::mem::drop`\"\n+                            binding or dropping explicitly with `std::mem::drop`\",\n                     );\n                 } else if is_must_use_ty(cx, cx.typeck_results().expr_ty(init)) {\n                     span_lint_and_help(\n@@ -153,7 +156,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         local.span,\n                         \"non-binding let on an expression with `#[must_use]` type\",\n                         None,\n-                        \"consider explicitly using expression value\"\n+                        \"consider explicitly using expression value\",\n                     );\n                 } else if is_must_use_func_call(cx, init) {\n                     span_lint_and_help(\n@@ -162,7 +165,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                         local.span,\n                         \"non-binding let on a result of a `#[must_use]` function\",\n                         None,\n-                        \"consider explicitly using function result\"\n+                        \"consider explicitly using function result\",\n                     );\n                 }\n             }"}, {"sha": "f5ad52ba1892a508bdf9e02a7ee09ede16bd4893", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -25,6 +25,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n+    LintId::of(casts::CAST_NAN_TO_INT),\n     LintId::of(casts::CAST_REF_TO_MUT),\n     LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n     LintId::of(casts::CAST_SLICE_FROM_RAW_PARTS),\n@@ -71,6 +72,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(format::USELESS_FORMAT),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n     LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n+    LintId::of(format_args::UNINLINED_FORMAT_ARGS),\n+    LintId::of(format_args::UNUSED_FORMAT_SPECS),\n     LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n     LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n@@ -87,6 +90,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n     LintId::of(if_let_mutex::IF_LET_MUTEX),\n     LintId::of(implicit_saturating_add::IMPLICIT_SATURATING_ADD),\n+    LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n     LintId::of(indexing_slicing::OUT_OF_BOUNDS_INDEXING),\n     LintId::of(infinite_iter::INFINITE_ITER),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n@@ -136,6 +140,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+    LintId::of(matches::MANUAL_FILTER),\n     LintId::of(matches::MANUAL_MAP),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),"}, {"sha": "8be9dc4baf19360a6977a0a7aa118a612e8bde4b", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(double_parens::DOUBLE_PARENS),\n     LintId::of(explicit_write::EXPLICIT_WRITE),\n     LintId::of(format::USELESS_FORMAT),\n+    LintId::of(format_args::UNUSED_FORMAT_SPECS),\n     LintId::of(functions::TOO_MANY_ARGUMENTS),\n     LintId::of(int_plus_one::INT_PLUS_ONE),\n     LintId::of(lifetimes::EXTRA_UNUSED_LIFETIMES),\n@@ -27,6 +28,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(manual_strip::MANUAL_STRIP),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n+    LintId::of(matches::MANUAL_FILTER),\n     LintId::of(matches::MANUAL_UNWRAP_OR),\n     LintId::of(matches::MATCH_AS_REF),\n     LintId::of(matches::MATCH_SINGLE_BINDING),"}, {"sha": "40c94c6e8d33dc8101986d7ba7251433288adaa5", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,20 +3,20 @@\n // Manual edits will be overwritten.\n \n store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n-    LintId::of(utils::internal_lints::CLIPPY_LINTS_INTERNAL),\n-    LintId::of(utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n-    LintId::of(utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n-    LintId::of(utils::internal_lints::DEFAULT_DEPRECATION_REASON),\n-    LintId::of(utils::internal_lints::DEFAULT_LINT),\n-    LintId::of(utils::internal_lints::IF_CHAIN_STYLE),\n-    LintId::of(utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n-    LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::INVALID_PATHS),\n-    LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n-    LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n-    LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n-    LintId::of(utils::internal_lints::PRODUCE_ICE),\n-    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n-    LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n+    LintId::of(utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL),\n+    LintId::of(utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS),\n+    LintId::of(utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS),\n+    LintId::of(utils::internal_lints::if_chain_style::IF_CHAIN_STYLE),\n+    LintId::of(utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL),\n+    LintId::of(utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR),\n+    LintId::of(utils::internal_lints::invalid_paths::INVALID_PATHS),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS),\n+    LintId::of(utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n+    LintId::of(utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL),\n+    LintId::of(utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA),\n+    LintId::of(utils::internal_lints::produce_ice::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH),\n ])"}, {"sha": "8b96dfd5981be495287917f97f691d6da36aec2c", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -4,37 +4,37 @@\n \n store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::CLIPPY_LINTS_INTERNAL,\n+    utils::internal_lints::clippy_lints_internal::CLIPPY_LINTS_INTERNAL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS,\n+    utils::internal_lints::collapsible_calls::COLLAPSIBLE_SPAN_LINT_CALLS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::COMPILER_LINT_FUNCTIONS,\n+    utils::internal_lints::compiler_lint_functions::COMPILER_LINT_FUNCTIONS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::DEFAULT_DEPRECATION_REASON,\n+    utils::internal_lints::if_chain_style::IF_CHAIN_STYLE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::DEFAULT_LINT,\n+    utils::internal_lints::interning_defined_symbol::INTERNING_DEFINED_SYMBOL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::IF_CHAIN_STYLE,\n+    utils::internal_lints::interning_defined_symbol::UNNECESSARY_SYMBOL_STR,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n+    utils::internal_lints::invalid_paths::INVALID_PATHS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    utils::internal_lints::lint_without_lint_pass::DEFAULT_DEPRECATION_REASON,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::INVALID_PATHS,\n+    utils::internal_lints::lint_without_lint_pass::DEFAULT_LINT,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n+    utils::internal_lints::lint_without_lint_pass::INVALID_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    utils::internal_lints::lint_without_lint_pass::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n+    utils::internal_lints::lint_without_lint_pass::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::OUTER_EXPN_EXPN_DATA,\n+    utils::internal_lints::msrv_attr_impl::MISSING_MSRV_ATTR_IMPL,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::PRODUCE_ICE,\n+    utils::internal_lints::outer_expn_data_pass::OUTER_EXPN_EXPN_DATA,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    utils::internal_lints::produce_ice::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n+    utils::internal_lints::unnecessary_def_path::UNNECESSARY_DEF_PATH,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,\n     as_conversions::AS_CONVERSIONS,\n@@ -66,12 +66,14 @@ store.register_lints(&[\n     cargo::NEGATIVE_FEATURE_NAMES,\n     cargo::REDUNDANT_FEATURE_NAMES,\n     cargo::WILDCARD_DEPENDENCIES,\n+    casts::AS_PTR_CAST_MUT,\n     casts::AS_UNDERSCORE,\n     casts::BORROW_AS_PTR,\n     casts::CAST_ABS_TO_UNSIGNED,\n     casts::CAST_ENUM_CONSTRUCTOR,\n     casts::CAST_ENUM_TRUNCATION,\n     casts::CAST_LOSSLESS,\n+    casts::CAST_NAN_TO_INT,\n     casts::CAST_POSSIBLE_TRUNCATION,\n     casts::CAST_POSSIBLE_WRAP,\n     casts::CAST_PRECISION_LOSS,\n@@ -162,6 +164,7 @@ store.register_lints(&[\n     format_args::FORMAT_IN_FORMAT_ARGS,\n     format_args::TO_STRING_IN_FORMAT_ARGS,\n     format_args::UNINLINED_FORMAT_ARGS,\n+    format_args::UNUSED_FORMAT_SPECS,\n     format_impl::PRINT_IN_FORMAT_IMPL,\n     format_impl::RECURSIVE_FORMAT_IMPL,\n     format_push_string::FORMAT_PUSH_STRING,\n@@ -258,6 +261,7 @@ store.register_lints(&[\n     match_result_ok::MATCH_RESULT_OK,\n     matches::COLLAPSIBLE_MATCH,\n     matches::INFALLIBLE_DESTRUCTURING_MATCH,\n+    matches::MANUAL_FILTER,\n     matches::MANUAL_MAP,\n     matches::MANUAL_UNWRAP_OR,\n     matches::MATCH_AS_REF,\n@@ -475,6 +479,7 @@ store.register_lints(&[\n     panic_unimplemented::TODO,\n     panic_unimplemented::UNIMPLEMENTED,\n     panic_unimplemented::UNREACHABLE,\n+    partial_pub_fields::PARTIAL_PUB_FIELDS,\n     partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n     partialeq_to_none::PARTIALEQ_TO_NONE,\n     pass_by_ref_or_value::LARGE_TYPES_PASSED_BY_VALUE,"}, {"sha": "a75bc81b2222c0d9685f4c9eff42b8f51ed077a8", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -4,6 +4,7 @@\n \n store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n+    LintId::of(casts::AS_PTR_CAST_MUT),\n     LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n     LintId::of(copies::BRANCHES_SHARING_CODE),\n     LintId::of(derive::DERIVE_PARTIAL_EQ_WITHOUT_EQ),\n@@ -31,6 +32,8 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n+    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n+    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(unused_peekable::UNUSED_PEEKABLE),\n     LintId::of(unused_rounding::UNUSED_ROUNDING),"}, {"sha": "2ead71a68fabef1db92ae612930e4ebdeca313fb", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -29,12 +29,10 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE_FOR_METHOD_CALLS),\n     LintId::of(excessive_bools::FN_PARAMS_EXCESSIVE_BOOLS),\n     LintId::of(excessive_bools::STRUCT_EXCESSIVE_BOOLS),\n-    LintId::of(format_args::UNINLINED_FORMAT_ARGS),\n     LintId::of(functions::MUST_USE_CANDIDATE),\n     LintId::of(functions::TOO_MANY_LINES),\n     LintId::of(if_not_else::IF_NOT_ELSE),\n     LintId::of(implicit_hasher::IMPLICIT_HASHER),\n-    LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n     LintId::of(inconsistent_struct_constructor::INCONSISTENT_STRUCT_CONSTRUCTOR),\n     LintId::of(infinite_iter::MAYBE_INFINITE_ITER),\n     LintId::of(invalid_upcast_comparisons::INVALID_UPCAST_COMPARISONS),\n@@ -89,8 +87,6 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n-    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n-    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n     LintId::of(types::LINKEDLIST),\n     LintId::of(types::OPTION_OPTION),"}, {"sha": "9edced28408f16a12b666702ad3e74aa25b45e83", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -61,6 +61,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(panic_unimplemented::TODO),\n     LintId::of(panic_unimplemented::UNIMPLEMENTED),\n     LintId::of(panic_unimplemented::UNREACHABLE),\n+    LintId::of(partial_pub_fields::PARTIAL_PUB_FIELDS),\n     LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n     LintId::of(pub_use::PUB_USE),\n     LintId::of(redundant_slicing::DEREF_BY_SLICING),"}, {"sha": "6894d69e928a716b5a07e086d74c3e8938c527ac", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -25,12 +25,14 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(enum_variants::MODULE_INCEPTION),\n     LintId::of(eta_reduction::REDUNDANT_CLOSURE),\n     LintId::of(float_literal::EXCESSIVE_PRECISION),\n+    LintId::of(format_args::UNINLINED_FORMAT_ARGS),\n     LintId::of(from_over_into::FROM_OVER_INTO),\n     LintId::of(from_str_radix_10::FROM_STR_RADIX_10),\n     LintId::of(functions::DOUBLE_MUST_USE),\n     LintId::of(functions::MUST_USE_UNIT),\n     LintId::of(functions::RESULT_UNIT_ERR),\n     LintId::of(implicit_saturating_add::IMPLICIT_SATURATING_ADD),\n+    LintId::of(implicit_saturating_sub::IMPLICIT_SATURATING_SUB),\n     LintId::of(inherent_to_string::INHERENT_TO_STRING),\n     LintId::of(init_numbered_fields::INIT_NUMBERED_FIELDS),\n     LintId::of(len_zero::COMPARISON_TO_EMPTY),"}, {"sha": "b70c4bb73e57d129bbf291c7d6220f428e877a55", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -11,6 +11,7 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n+    LintId::of(casts::CAST_NAN_TO_INT),\n     LintId::of(casts::CAST_SLICE_FROM_RAW_PARTS),\n     LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n     LintId::of(drop_forget_ref::DROP_NON_DROP),"}, {"sha": "b54ecd12313aa4e0704485c5d996f4e1139be9cf", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -38,7 +38,6 @@ extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n-extern crate rustc_mir_dataflow;\n extern crate rustc_parse;\n extern crate rustc_session;\n extern crate rustc_span;\n@@ -325,6 +324,7 @@ mod option_if_let_else;\n mod overflow_check_conditional;\n mod panic_in_result_fn;\n mod panic_unimplemented;\n+mod partial_pub_fields;\n mod partialeq_ne_impl;\n mod partialeq_to_none;\n mod pass_by_ref_or_value;\n@@ -418,7 +418,7 @@ pub fn register_pre_expansion_lints(store: &mut rustc_lint::LintStore, sess: &Se\n \n     let msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\n+            sess.err(format!(\n                 \"error reading Clippy's configuration file. `{s}` is not a valid Rust version\"\n             ));\n             None\n@@ -434,7 +434,7 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n         .and_then(|v| parse_msrv(&v, None, None));\n     let clippy_msrv = conf.msrv.as_ref().and_then(|s| {\n         parse_msrv(s, None, None).or_else(|| {\n-            sess.err(&format!(\n+            sess.err(format!(\n                 \"error reading Clippy's configuration file. `{s}` is not a valid Rust version\"\n             ));\n             None\n@@ -445,7 +445,7 @@ fn read_msrv(conf: &Conf, sess: &Session) -> Option<RustcVersion> {\n         if let Some(clippy_msrv) = clippy_msrv {\n             // if both files have an msrv, let's compare them and emit a warning if they differ\n             if clippy_msrv != cargo_msrv {\n-                sess.warn(&format!(\n+                sess.warn(format!(\n                     \"the MSRV in `clippy.toml` and `Cargo.toml` differ; using `{clippy_msrv}` from `clippy.toml`\"\n                 ));\n             }\n@@ -474,15 +474,15 @@ pub fn read_conf(sess: &Session) -> Conf {\n     let TryConf { conf, errors, warnings } = utils::conf::read(&file_name);\n     // all conf errors are non-fatal, we just use the default conf in case of error\n     for error in errors {\n-        sess.err(&format!(\n+        sess.err(format!(\n             \"error reading Clippy's configuration file `{}`: {}\",\n             file_name.display(),\n             format_error(error)\n         ));\n     }\n \n     for warning in warnings {\n-        sess.struct_warn(&format!(\n+        sess.struct_warn(format!(\n             \"error reading Clippy's configuration file `{}`: {}\",\n             file_name.display(),\n             format_error(warning)\n@@ -529,17 +529,23 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     // all the internal lints\n     #[cfg(feature = \"internal\")]\n     {\n-        store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n-        store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::CollapsibleCalls));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::IfChainStyle));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n-        store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n-        store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::clippy_lints_internal::ClippyLintsInternal));\n+        store.register_early_pass(|| Box::new(utils::internal_lints::produce_ice::ProduceIce));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::collapsible_calls::CollapsibleCalls));\n+        store.register_late_pass(|_| {\n+            Box::new(utils::internal_lints::compiler_lint_functions::CompilerLintFunctions::new())\n+        });\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::if_chain_style::IfChainStyle));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::invalid_paths::InvalidPaths));\n+        store.register_late_pass(|_| {\n+            Box::<utils::internal_lints::interning_defined_symbol::InterningDefinedSymbol>::default()\n+        });\n+        store.register_late_pass(|_| {\n+            Box::<utils::internal_lints::lint_without_lint_pass::LintWithoutLintPass>::default()\n+        });\n+        store.register_late_pass(|_| Box::<utils::internal_lints::unnecessary_def_path::UnnecessaryDefPath>::default());\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::outer_expn_data_pass::OuterExpnDataPass));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::msrv_attr_impl::MsrvAttrImpl));\n     }\n \n     let arithmetic_side_effects_allowed = conf.arithmetic_side_effects_allowed.clone();\n@@ -909,6 +915,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(bool_to_int_with_if::BoolToIntWithIf));\n     store.register_late_pass(|_| Box::new(box_default::BoxDefault));\n     store.register_late_pass(|_| Box::new(implicit_saturating_add::ImplicitSaturatingAdd));\n+    store.register_early_pass(|| Box::new(partial_pub_fields::PartialPubFields));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "13878eda0f1cd59395825864b6f8ffa95ec5b39f", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n                 sub_visitor.visit_fn_decl(decl);\n                 self.nested_elision_site_lts.append(&mut sub_visitor.all_lts());\n             },\n-            TyKind::TraitObject(bounds, ref lt, _) => {\n+            TyKind::TraitObject(bounds, lt, _) => {\n                 if !lt.is_elided() {\n                     self.unelided_trait_object_lifetime = true;\n                 }"}, {"sha": "27ba27202bf7e8b6ec2c764d51c133c434d6593a", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::{multispan_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::has_iter_method;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{contains_name, higher, is_integer_const, match_trait_method, paths, sugg, SpanlessEq};\n+use clippy_utils::{contains_name, higher, is_integer_const, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -263,7 +263,8 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                 match res {\n                     Res::Local(hir_id) => {\n                         let parent_def_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                        let extent = self.cx\n+                        let extent = self\n+                            .cx\n                             .tcx\n                             .region_scope_tree(parent_def_id)\n                             .var_scope(hir_id.local_id)\n@@ -274,11 +275,12 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                                 (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n                             );\n                         } else {\n-                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                            self.indexed_indirectly\n+                                .insert(seqvar.segments[0].ident.name, Some(extent));\n                         }\n-                        return false;  // no need to walk further *on the variable*\n-                    }\n-                    Res::Def(DefKind::Static (_)| DefKind::Const, ..) => {\n+                        return false; // no need to walk further *on the variable*\n+                    },\n+                    Res::Def(DefKind::Static(_) | DefKind::Const, ..) => {\n                         if index_used_directly {\n                             self.indexed_directly.insert(\n                                 seqvar.segments[0].ident.name,\n@@ -287,8 +289,8 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n                         } else {\n                             self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n-                        return false;  // no need to walk further *on the variable*\n-                    }\n+                        return false; // no need to walk further *on the variable*\n+                    },\n                     _ => (),\n                 }\n             }\n@@ -302,17 +304,26 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n         if_chain! {\n             // a range index op\n             if let ExprKind::MethodCall(meth, args_0, [args_1, ..], _) = &expr.kind;\n-            if (meth.ident.name == sym::index && match_trait_method(self.cx, expr, &paths::INDEX))\n-                || (meth.ident.name == sym::index_mut && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n+            if let Some(trait_id) = self\n+                .cx\n+                .typeck_results()\n+                .type_dependent_def_id(expr.hir_id)\n+                .and_then(|def_id| self.cx.tcx.trait_of_item(def_id));\n+            if (meth.ident.name == sym::index && self.cx.tcx.lang_items().index_trait() == Some(trait_id))\n+                || (meth.ident.name == sym::index_mut && self.cx.tcx.lang_items().index_mut_trait() == Some(trait_id));\n             if !self.check(args_1, args_0, expr);\n-            then { return }\n+            then {\n+                return;\n+            }\n         }\n \n         if_chain! {\n             // an index op\n             if let ExprKind::Index(seqexpr, idx) = expr.kind;\n             if !self.check(idx, seqexpr, expr);\n-            then { return }\n+            then {\n+                return;\n+            }\n         }\n \n         if_chain! {"}, {"sha": "55989f8a4465018f3fe9f5bbf3e0d782ece39959", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -331,9 +331,8 @@ fn needs_mutable_borrow(cx: &LateContext<'_>, iter_expr: &IterExpr, loop_expr: &\n     }\n \n     if let Some(e) = get_enclosing_loop_or_multi_call_closure(cx, loop_expr) {\n-        let local_id = match iter_expr.path {\n-            Res::Local(id) => id,\n-            _ => return true,\n+        let Res::Local(local_id) = iter_expr.path else {\n+            return true\n         };\n         let mut v = NestedLoopVisitor {\n             cx,"}, {"sha": "f5617a905ff872992c96cfc9ad9c16b380dbce92", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -35,7 +35,8 @@ struct PathAndSpan {\n     span: Span,\n }\n \n-/// `MacroRefData` includes the name of the macro.\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n #[derive(Debug, Clone)]\n pub struct MacroRefData {\n     name: String,"}, {"sha": "090f9f8ff73cfd40e9825954d4b5c163ae6a6ccc", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::match_function_call;\n-use clippy_utils::paths::FUTURE_FROM_GENERATOR;\n+use clippy_utils::match_function_call_with_def_id;\n use clippy_utils::source::{position_before_rarrow, snippet_block, snippet_opt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -140,9 +139,9 @@ fn future_output_ty<'tcx>(trait_ref: &'tcx TraitRef<'tcx>) -> Option<&'tcx Ty<'t\n         if args.bindings.len() == 1;\n         let binding = &args.bindings[0];\n         if binding.ident.name == sym::Output;\n-        if let TypeBindingKind::Equality{term: Term::Ty(output)} = binding.kind;\n+        if let TypeBindingKind::Equality { term: Term::Ty(output) } = binding.kind;\n         then {\n-            return Some(output)\n+            return Some(output);\n         }\n     }\n \n@@ -175,9 +174,16 @@ fn captures_all_lifetimes(inputs: &[Ty<'_>], output_lifetimes: &[LifetimeName])\n fn desugared_async_block<'tcx>(cx: &LateContext<'tcx>, block: &'tcx Block<'tcx>) -> Option<&'tcx Body<'tcx>> {\n     if_chain! {\n         if let Some(block_expr) = block.expr;\n-        if let Some(args) = match_function_call(cx, block_expr, &FUTURE_FROM_GENERATOR);\n+        if let Some(args) = cx\n+            .tcx\n+            .lang_items()\n+            .from_generator_fn()\n+            .and_then(|def_id| match_function_call_with_def_id(cx, block_expr, def_id));\n         if args.len() == 1;\n-        if let Expr{kind: ExprKind::Closure(&Closure { body, .. }), ..} = args[0];\n+        if let Expr {\n+            kind: ExprKind::Closure(&Closure { body, .. }),\n+            ..\n+        } = args[0];\n         let closure_body = cx.tcx.hir().body(body);\n         if closure_body.generator_kind == Some(GeneratorKind::Async(AsyncGeneratorKind::Block));\n         then {"}, {"sha": "02dc8755dd61c9e86f23bbe209066680d964d5f0", "filename": "clippy_lints/src/manual_clamp.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmanual_clamp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_clamp.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -12,9 +12,9 @@ use std::ops::Deref;\n \n use clippy_utils::{\n     diagnostics::{span_lint_and_then, span_lint_hir_and_then},\n-    eq_expr_value, get_trait_def_id,\n+    eq_expr_value,\n     higher::If,\n-    is_diag_trait_item, is_trait_method, meets_msrv, msrvs, path_res, path_to_local_id, paths, peel_blocks,\n+    is_diag_trait_item, is_trait_method, meets_msrv, msrvs, path_res, path_to_local_id, peel_blocks,\n     peel_blocks_with_stmt,\n     sugg::Sugg,\n     ty::implements_trait,\n@@ -190,7 +190,11 @@ impl TypeClampability {\n     fn is_clampable<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<TypeClampability> {\n         if ty.is_floating_point() {\n             Some(TypeClampability::Float)\n-        } else if get_trait_def_id(cx, &paths::ORD).map_or(false, |id| implements_trait(cx, ty, id, &[])) {\n+        } else if cx\n+            .tcx\n+            .get_diagnostic_item(sym::Ord)\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+        {\n             Some(TypeClampability::Ord)\n         } else {\n             None"}, {"sha": "66ba1f6f9c55007771d75d415ff517bea32bdbe5", "filename": "clippy_lints/src/matches/manual_filter.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_filter.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,153 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::visitors::contains_unsafe_block;\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n+\n+use rustc_hir::LangItem::OptionSome;\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, Pat, PatKind};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+use super::manual_utils::{check_with, SomeExpr};\n+use super::MANUAL_FILTER;\n+\n+// Function called on the <expr> of `[&+]Some((ref | ref mut) x) => <expr>`\n+// Need to check if it's of the form `<expr>=if <cond> {<then_expr>} else {<else_expr>}`\n+// AND that only one `then/else_expr` resolves to `Some(x)` while the other resolves to `None`\n+// return the `cond` expression if so.\n+fn get_cond_expr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'_>,\n+    expr: &'tcx Expr<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<SomeExpr<'tcx>> {\n+    if_chain! {\n+        if let Some(block_expr) = peels_blocks_incl_unsafe_opt(expr);\n+        if let ExprKind::If(cond, then_expr, Some(else_expr)) = block_expr.kind;\n+        if let PatKind::Binding(_,target, ..) = pat.kind;\n+        if let (then_visitor, else_visitor)\n+            = (is_some_expr(cx, target, ctxt, then_expr),\n+                is_some_expr(cx, target, ctxt, else_expr));\n+        if then_visitor != else_visitor; // check that one expr resolves to `Some(x)`, the other to `None`\n+        then {\n+            return Some(SomeExpr {\n+                    expr: peels_blocks_incl_unsafe(cond.peel_drop_temps()),\n+                    needs_unsafe_block: contains_unsafe_block(cx, expr),\n+                    needs_negated: !then_visitor // if the `then_expr` resolves to `None`, need to negate the cond\n+                })\n+            }\n+    };\n+    None\n+}\n+\n+fn peels_blocks_incl_unsafe_opt<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n+    // we don't want to use `peel_blocks` here because we don't care if the block is unsafe, it's\n+    // checked by `contains_unsafe_block`\n+    if let ExprKind::Block(block, None) = expr.kind {\n+        if block.stmts.is_empty() {\n+            return block.expr;\n+        }\n+    };\n+    None\n+}\n+\n+fn peels_blocks_incl_unsafe<'a>(expr: &'a Expr<'a>) -> &'a Expr<'a> {\n+    peels_blocks_incl_unsafe_opt(expr).unwrap_or(expr)\n+}\n+\n+// function called for each <expr> expression:\n+// Some(x) => if <cond> {\n+//    <expr>\n+// } else {\n+//    <expr>\n+// }\n+// Returns true if <expr> resolves to `Some(x)`, `false` otherwise\n+fn is_some_expr<'tcx>(cx: &LateContext<'_>, target: HirId, ctxt: SyntaxContext, expr: &'tcx Expr<'_>) -> bool {\n+    if let Some(inner_expr) = peels_blocks_incl_unsafe_opt(expr) {\n+        // there can be not statements in the block as they would be removed when switching to `.filter`\n+        if let ExprKind::Call(callee, [arg]) = inner_expr.kind {\n+            return ctxt == expr.span.ctxt()\n+                && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome)\n+                && path_to_local_id(arg, target);\n+        }\n+    };\n+    false\n+}\n+\n+// given the closure: `|<pattern>| <expr>`\n+// returns `|&<pattern>| <expr>`\n+fn add_ampersand_if_copy(body_str: String, has_copy_trait: bool) -> String {\n+    if has_copy_trait {\n+        let mut with_ampersand = body_str;\n+        with_ampersand.insert(1, '&');\n+        with_ampersand\n+    } else {\n+        body_str\n+    }\n+}\n+\n+pub(super) fn check_match<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    scrutinee: &'tcx Expr<'_>,\n+    arms: &'tcx [Arm<'_>],\n+    expr: &'tcx Expr<'_>,\n+) {\n+    let ty = cx.typeck_results().expr_ty(expr);\n+    if is_type_diagnostic_item(cx, ty, sym::Option)\n+    && let [first_arm, second_arm] = arms\n+    && first_arm.guard.is_none()\n+    && second_arm.guard.is_none()\n+         {\n+            check(cx, expr, scrutinee, first_arm.pat, first_arm.body, Some(second_arm.pat), second_arm.body);\n+        }\n+}\n+\n+pub(super) fn check_if_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+    then_expr: &'tcx Expr<'_>,\n+    else_expr: &'tcx Expr<'_>,\n+) {\n+    check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n+}\n+\n+fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+) {\n+    if let Some(sugg_info) = check_with(\n+        cx,\n+        expr,\n+        scrutinee,\n+        then_pat,\n+        then_body,\n+        else_pat,\n+        else_body,\n+        get_cond_expr,\n+    ) {\n+        let body_str = add_ampersand_if_copy(sugg_info.body_str, sugg_info.scrutinee_impl_copy);\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_FILTER,\n+            expr.span,\n+            \"manual implementation of `Option::filter`\",\n+            \"try this\",\n+            if sugg_info.needs_brackets {\n+                format!(\n+                    \"{{ {}{}.filter({body_str}) }}\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str\n+                )\n+            } else {\n+                format!(\"{}{}.filter({body_str})\", sugg_info.scrutinee_str, sugg_info.as_ref_str)\n+            },\n+            sugg_info.app,\n+        );\n+    }\n+}"}, {"sha": "aaba239677fffafa163e7e76805b30be9d037d75", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 64, "deletions": 254, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,22 +1,13 @@\n-use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use super::manual_utils::{check_with, SomeExpr};\n+use super::MANUAL_MAP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n-use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n-use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n-    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n-};\n-use rustc_ast::util::parser::PREC_POSTFIX;\n-use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    def::Res, Arm, BindingAnnotation, Block, BlockCheckMode, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path,\n-    QPath, UnsafeSource,\n-};\n-use rustc_lint::LateContext;\n-use rustc_span::{sym, SyntaxContext};\n \n-use super::MANUAL_MAP;\n+use clippy_utils::{is_res_lang_ctor, path_res};\n+\n+use rustc_hir::LangItem::OptionSome;\n+use rustc_hir::{Arm, Block, BlockCheckMode, Expr, ExprKind, Pat, UnsafeSource};\n+use rustc_lint::LateContext;\n+use rustc_span::SyntaxContext;\n \n pub(super) fn check_match<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -43,7 +34,6 @@ pub(super) fn check_if_let<'tcx>(\n     check(cx, expr, let_expr, let_pat, then_expr, None, else_expr);\n }\n \n-#[expect(clippy::too_many_lines)]\n fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -53,254 +43,74 @@ fn check<'tcx>(\n     else_pat: Option<&'tcx Pat<'_>>,\n     else_body: &'tcx Expr<'_>,\n ) {\n-    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n-        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n-    {\n-        return;\n-    }\n-\n-    let expr_ctxt = expr.span.ctxt();\n-    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-        try_parse_pattern(cx, then_pat, expr_ctxt),\n-        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    if let Some(sugg_info) = check_with(\n+        cx,\n+        expr,\n+        scrutinee,\n+        then_pat,\n+        then_body,\n+        else_pat,\n+        else_body,\n+        get_some_expr,\n     ) {\n-        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-            (else_body, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n-            (else_body, pattern, ref_count, false)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n-            (then_body, pattern, ref_count, true)\n-        },\n-        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n-            (then_body, pattern, ref_count, false)\n-        },\n-        _ => return,\n-    };\n-\n-    // Top level or patterns aren't allowed in closures.\n-    if matches!(some_pat.kind, PatKind::Or(_)) {\n-        return;\n-    }\n-\n-    let some_expr = match get_some_expr(cx, some_expr, false, expr_ctxt) {\n-        Some(expr) => expr,\n-        None => return,\n-    };\n-\n-    // These two lints will go back and forth with each other.\n-    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n-        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-    {\n-        return;\n-    }\n-\n-    // `map` won't perform any adjustments.\n-    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n-        return;\n-    }\n-\n-    // Determine which binding mode to use.\n-    let explicit_ref = some_pat.contains_explicit_ref_binding();\n-    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then_some(ty_mutability));\n-\n-    let as_ref_str = match binding_ref {\n-        Some(Mutability::Mut) => \".as_mut()\",\n-        Some(Mutability::Not) => \".as_ref()\",\n-        None => \"\",\n-    };\n-\n-    match can_move_expr_to_closure(cx, some_expr.expr) {\n-        Some(captures) => {\n-            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n-            // TODO: check all the references made in the scrutinee expression. This will require interacting\n-            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n-            if let Some(binding_ref_mutability) = binding_ref {\n-                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n-                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n-                    _ => None,\n-                });\n-                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n-                    match captures.get(l) {\n-                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return,\n-                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n-                            return;\n-                        },\n-                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n-                    }\n-                }\n-            }\n-        },\n-        None => return,\n-    };\n-\n-    let mut app = Applicability::MachineApplicable;\n-\n-    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-    // it's being passed by value.\n-    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-        format!(\"({scrutinee_str})\")\n-    } else {\n-        scrutinee_str.into()\n-    };\n-\n-    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-        if_chain! {\n-            if !some_expr.needs_unsafe_block;\n-            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n-            if func.span.ctxt() == some_expr.expr.span.ctxt();\n-            then {\n-                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+        span_lint_and_sugg(\n+            cx,\n+            MANUAL_MAP,\n+            expr.span,\n+            \"manual implementation of `Option::map`\",\n+            \"try this\",\n+            if sugg_info.needs_brackets {\n+                format!(\n+                    \"{{ {}{}.map({}) }}\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str, sugg_info.body_str\n+                )\n             } else {\n-                if path_to_local_id(some_expr.expr, id)\n-                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                    && binding_ref.is_some()\n-                {\n-                    return;\n-                }\n-\n-                // `ref` and `ref mut` annotations were handled earlier.\n-                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n-                let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-                if some_expr.needs_unsafe_block {\n-                    format!(\"|{annotation}{some_binding}| unsafe {{ {expr_snip} }}\")\n-                } else {\n-                    format!(\"|{annotation}{some_binding}| {expr_snip}\")\n-                }\n-            }\n-        }\n-    } else if !is_wild_none && explicit_ref.is_none() {\n-        // TODO: handle explicit reference annotations.\n-        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n-        let expr_snip = snippet_with_context(cx, some_expr.expr.span, expr_ctxt, \"..\", &mut app).0;\n-        if some_expr.needs_unsafe_block {\n-            format!(\"|{pat_snip}| unsafe {{ {expr_snip} }}\")\n-        } else {\n-            format!(\"|{pat_snip}| {expr_snip}\")\n-        }\n-    } else {\n-        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-        return;\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        MANUAL_MAP,\n-        expr.span,\n-        \"manual implementation of `Option::map`\",\n-        \"try this\",\n-        if else_pat.is_none() && is_else_clause(cx.tcx, expr) {\n-            format!(\"{{ {scrutinee_str}{as_ref_str}.map({body_str}) }}\")\n-        } else {\n-            format!(\"{scrutinee_str}{as_ref_str}.map({body_str})\")\n-        },\n-        app,\n-    );\n-}\n-\n-// Checks whether the expression could be passed as a function, or whether a closure is needed.\n-// Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    match expr.kind {\n-        ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding)\n-                && cx.typeck_results().expr_adjustments(arg).is_empty()\n-                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n-        {\n-            Some(func)\n-        },\n-        _ => None,\n-    }\n-}\n-\n-enum OptionPat<'a> {\n-    Wild,\n-    None,\n-    Some {\n-        // The pattern contained in the `Some` tuple.\n-        pattern: &'a Pat<'a>,\n-        // The number of references before the `Some` tuple.\n-        // e.g. `&&Some(_)` has a ref count of 2.\n-        ref_count: usize,\n-    },\n-}\n-\n-struct SomeExpr<'tcx> {\n-    expr: &'tcx Expr<'tcx>,\n-    needs_unsafe_block: bool,\n-}\n-\n-// Try to parse into a recognized `Option` pattern.\n-// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        pat: &'tcx Pat<'_>,\n-        ref_count: usize,\n-        ctxt: SyntaxContext,\n-    ) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n-            PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n-                Some(OptionPat::None)\n-            },\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n-                Some(OptionPat::Some { pattern, ref_count })\n+                format!(\n+                    \"{}{}.map({})\",\n+                    sugg_info.scrutinee_str, sugg_info.as_ref_str, sugg_info.body_str\n+                )\n             },\n-            _ => None,\n-        }\n+            sugg_info.app,\n+        );\n     }\n-    f(cx, pat, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression.\n fn get_some_expr<'tcx>(\n     cx: &LateContext<'tcx>,\n+    _: &'tcx Pat<'_>,\n     expr: &'tcx Expr<'_>,\n-    needs_unsafe_block: bool,\n     ctxt: SyntaxContext,\n ) -> Option<SomeExpr<'tcx>> {\n-    // TODO: Allow more complex expressions.\n-    match expr.kind {\n-        ExprKind::Call(callee, [arg])\n-            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n-        {\n-            Some(SomeExpr {\n-                expr: arg,\n-                needs_unsafe_block,\n-            })\n-        },\n-        ExprKind::Block(\n-            Block {\n-                stmts: [],\n-                expr: Some(expr),\n-                rules,\n-                ..\n+    fn get_some_expr_internal<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        needs_unsafe_block: bool,\n+        ctxt: SyntaxContext,\n+    ) -> Option<SomeExpr<'tcx>> {\n+        // TODO: Allow more complex expressions.\n+        match expr.kind {\n+            ExprKind::Call(callee, [arg])\n+                if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+            {\n+                Some(SomeExpr::new_no_negated(arg, needs_unsafe_block))\n             },\n-            _,\n-        ) => get_some_expr(\n-            cx,\n-            expr,\n-            needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n-            ctxt,\n-        ),\n-        _ => None,\n+            ExprKind::Block(\n+                Block {\n+                    stmts: [],\n+                    expr: Some(expr),\n+                    rules,\n+                    ..\n+                },\n+                _,\n+            ) => get_some_expr_internal(\n+                cx,\n+                expr,\n+                needs_unsafe_block || *rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided),\n+                ctxt,\n+            ),\n+            _ => None,\n+        }\n     }\n-}\n-\n-// Checks for the `None` value.\n-fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n+    get_some_expr_internal(cx, expr, false, ctxt)\n }"}, {"sha": "5b7644a5383231a988574b5bcffb438838979eb1", "filename": "clippy_lints/src/matches/manual_utils.rs", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_utils.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,277 @@\n+use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n+use clippy_utils::{\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, sugg::Sugg, CaptureKind,\n+};\n+use rustc_ast::util::parser::PREC_POSTFIX;\n+use rustc_errors::Applicability;\n+use rustc_hir::LangItem::{OptionNone, OptionSome};\n+use rustc_hir::{def::Res, BindingAnnotation, Expr, ExprKind, HirId, Mutability, Pat, PatKind, Path, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, SyntaxContext};\n+\n+#[expect(clippy::too_many_arguments)]\n+#[expect(clippy::too_many_lines)]\n+pub(super) fn check_with<'tcx, F>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    scrutinee: &'tcx Expr<'_>,\n+    then_pat: &'tcx Pat<'_>,\n+    then_body: &'tcx Expr<'_>,\n+    else_pat: Option<&'tcx Pat<'_>>,\n+    else_body: &'tcx Expr<'_>,\n+    get_some_expr_fn: F,\n+) -> Option<SuggInfo<'tcx>>\n+where\n+    F: Fn(&LateContext<'tcx>, &'tcx Pat<'_>, &'tcx Expr<'_>, SyntaxContext) -> Option<SomeExpr<'tcx>>,\n+{\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) =\n+        peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::Option)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::Option))\n+    {\n+        return None;\n+    }\n+\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        else_pat.map_or(Some(OptionPat::Wild), |p| try_parse_pattern(cx, p, expr_ctxt)),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_body) => {\n+            (else_body, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_body) => {\n+            (then_body, pattern, ref_count, false)\n+        },\n+        _ => return None,\n+    };\n+\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return None;\n+    }\n+\n+    let Some(some_expr) = get_some_expr_fn(cx, some_pat, some_expr, expr_ctxt) else {\n+        return None;\n+    };\n+\n+    // These two lints will go back and forth with each other.\n+    if cx.typeck_results().expr_ty(some_expr.expr) == cx.tcx.types.unit\n+        && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n+    {\n+        return None;\n+    }\n+\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr.expr).is_empty() {\n+        return None;\n+    }\n+\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then_some(ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    match can_move_expr_to_closure(cx, some_expr.expr) {\n+        Some(captures) => {\n+            // Check if captures the closure will need conflict with borrows made in the scrutinee.\n+            // TODO: check all the references made in the scrutinee expression. This will require interacting\n+            // with the borrow checker. Currently only `<local>[.<field>]*` is checked for.\n+            if let Some(binding_ref_mutability) = binding_ref {\n+                let e = peel_hir_expr_while(scrutinee, |e| match e.kind {\n+                    ExprKind::Field(e, _) | ExprKind::AddrOf(_, _, e) => Some(e),\n+                    _ => None,\n+                });\n+                if let ExprKind::Path(QPath::Resolved(None, Path { res: Res::Local(l), .. })) = e.kind {\n+                    match captures.get(l) {\n+                        Some(CaptureKind::Value | CaptureKind::Ref(Mutability::Mut)) => return None,\n+                        Some(CaptureKind::Ref(Mutability::Not)) if binding_ref_mutability == Mutability::Mut => {\n+                            return None;\n+                        },\n+                        Some(CaptureKind::Ref(Mutability::Not)) | None => (),\n+                    }\n+                }\n+            }\n+        },\n+        None => return None,\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n+\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrutinee).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({scrutinee_str})\")\n+    } else {\n+        scrutinee_str.into()\n+    };\n+\n+    let closure_expr_snip = some_expr.to_snippet_with_context(cx, expr_ctxt, &mut app);\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        if_chain! {\n+            if !some_expr.needs_unsafe_block;\n+            if let Some(func) = can_pass_as_func(cx, id, some_expr.expr);\n+            if func.span.ctxt() == some_expr.expr.span.ctxt();\n+            then {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            } else {\n+                if path_to_local_id(some_expr.expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return None;\n+                }\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::MUT) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n+\n+                if some_expr.needs_unsafe_block {\n+                    format!(\"|{annotation}{some_binding}| unsafe {{ {closure_expr_snip} }}\")\n+                } else {\n+                    format!(\"|{annotation}{some_binding}| {closure_expr_snip}\")\n+                }\n+            }\n+        }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        let pat_snip = snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0;\n+        if some_expr.needs_unsafe_block {\n+            format!(\"|{pat_snip}| unsafe {{ {closure_expr_snip} }}\")\n+        } else {\n+            format!(\"|{pat_snip}| {closure_expr_snip}\")\n+        }\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return None;\n+    };\n+\n+    // relies on the fact that Option<T>: Copy where T: copy\n+    let scrutinee_impl_copy = is_copy(cx, scrutinee_ty);\n+\n+    Some(SuggInfo {\n+        needs_brackets: else_pat.is_none() && is_else_clause(cx.tcx, expr),\n+        scrutinee_impl_copy,\n+        scrutinee_str,\n+        as_ref_str,\n+        body_str,\n+        app,\n+    })\n+}\n+\n+pub struct SuggInfo<'a> {\n+    pub needs_brackets: bool,\n+    pub scrutinee_impl_copy: bool,\n+    pub scrutinee_str: String,\n+    pub as_ref_str: &'a str,\n+    pub body_str: String,\n+    pub app: Applicability,\n+}\n+\n+// Checks whether the expression could be passed as a function, or whether a closure is needed.\n+// Returns the function to be passed to `map` if it exists.\n+fn can_pass_as_func<'tcx>(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+    match expr.kind {\n+        ExprKind::Call(func, [arg])\n+            if path_to_local_id(arg, binding)\n+                && cx.typeck_results().expr_adjustments(arg).is_empty()\n+                && !type_is_unsafe_function(cx, cx.typeck_results().expr_ty(func).peel_refs()) =>\n+        {\n+            Some(func)\n+        },\n+        _ => None,\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub(super) enum OptionPat<'a> {\n+    Wild,\n+    None,\n+    Some {\n+        // The pattern contained in the `Some` tuple.\n+        pattern: &'a Pat<'a>,\n+        // The number of references before the `Some` tuple.\n+        // e.g. `&&Some(_)` has a ref count of 2.\n+        ref_count: usize,\n+    },\n+}\n+\n+pub(super) struct SomeExpr<'tcx> {\n+    pub expr: &'tcx Expr<'tcx>,\n+    pub needs_unsafe_block: bool,\n+    pub needs_negated: bool, // for `manual_filter` lint\n+}\n+\n+impl<'tcx> SomeExpr<'tcx> {\n+    pub fn new_no_negated(expr: &'tcx Expr<'tcx>, needs_unsafe_block: bool) -> Self {\n+        Self {\n+            expr,\n+            needs_unsafe_block,\n+            needs_negated: false,\n+        }\n+    }\n+\n+    pub fn to_snippet_with_context(\n+        &self,\n+        cx: &LateContext<'tcx>,\n+        ctxt: SyntaxContext,\n+        app: &mut Applicability,\n+    ) -> Sugg<'tcx> {\n+        let sugg = Sugg::hir_with_context(cx, self.expr, ctxt, \"..\", app);\n+        if self.needs_negated { !sugg } else { sugg }\n+    }\n+}\n+\n+// Try to parse into a recognized `Option` pattern.\n+// i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n+pub(super) fn try_parse_pattern<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<OptionPat<'tcx>> {\n+    fn f<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        pat: &'tcx Pat<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat.kind {\n+            PatKind::Wild => Some(OptionPat::Wild),\n+            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n+            PatKind::TupleStruct(ref qpath, [pattern], _)\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n+            {\n+                Some(OptionPat::Some { pattern, ref_count })\n+            },\n+            _ => None,\n+        }\n+    }\n+    f(cx, pat, 0, ctxt)\n+}\n+\n+// Checks for the `None` value.\n+fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n+}"}, {"sha": "168c1e4d2e60d4d3da9e94412c674d8539a299a5", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -221,7 +221,6 @@ fn iter_matching_struct_fields<'a>(\n \n #[expect(clippy::similar_names)]\n impl<'a> NormalizedPat<'a> {\n-    #[expect(clippy::too_many_lines)]\n     fn from_pat(cx: &LateContext<'_>, arena: &'a DroplessArena, pat: &'a Pat<'_>) -> Self {\n         match pat.kind {\n             PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n@@ -235,9 +234,8 @@ impl<'a> NormalizedPat<'a> {\n                 Self::Struct(cx.qpath_res(path, pat.hir_id).opt_def_id(), fields)\n             },\n             PatKind::TupleStruct(ref path, pats, wild_idx) => {\n-                let adt = match cx.typeck_results().pat_ty(pat).ty_adt_def() {\n-                    Some(x) => x,\n-                    None => return Self::Wild,\n+                let Some(adt) = cx.typeck_results().pat_ty(pat).ty_adt_def() else {\n+                    return Self::Wild\n                 };\n                 let (var_id, variant) = if adt.is_enum() {\n                     match cx.qpath_res(path, pat.hir_id).opt_def_id() {"}, {"sha": "1bf8d4e96ad49a8056a9208686c5cfd5f9acc3b1", "filename": "clippy_lints/src/matches/match_single_binding.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_single_binding.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -58,6 +58,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         &snippet_body,\n                         &mut applicability,\n                         Some(span),\n+                        true,\n                     );\n \n                     span_lint_and_sugg(\n@@ -90,6 +91,7 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n                         &snippet_body,\n                         &mut applicability,\n                         None,\n+                        true,\n                     );\n                     (expr.span, sugg)\n                 },\n@@ -107,10 +109,14 @@ pub(crate) fn check<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], e\n         },\n         PatKind::Wild => {\n             if ex.can_have_side_effects() {\n-                let indent = \" \".repeat(indent_of(cx, expr.span).unwrap_or(0));\n-                let sugg = format!(\n-                    \"{};\\n{indent}{snippet_body}\",\n-                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability)\n+                let sugg = sugg_with_curlies(\n+                    cx,\n+                    (ex, expr),\n+                    (bind_names, matched_vars),\n+                    &snippet_body,\n+                    &mut applicability,\n+                    None,\n+                    false,\n                 );\n \n                 span_lint_and_sugg(\n@@ -169,6 +175,7 @@ fn sugg_with_curlies<'a>(\n     snippet_body: &str,\n     applicability: &mut Applicability,\n     assignment: Option<Span>,\n+    needs_var_binding: bool,\n ) -> String {\n     let mut indent = \" \".repeat(indent_of(cx, ex.span).unwrap_or(0));\n \n@@ -200,9 +207,15 @@ fn sugg_with_curlies<'a>(\n         s\n     });\n \n-    format!(\n-        \"{cbrace_start}let {} = {};\\n{indent}{assignment_str}{snippet_body}{cbrace_end}\",\n-        snippet_with_applicability(cx, bind_names, \"..\", applicability),\n-        snippet_with_applicability(cx, matched_vars, \"..\", applicability)\n-    )\n+    let scrutinee = if needs_var_binding {\n+        format!(\n+            \"let {} = {}\",\n+            snippet_with_applicability(cx, bind_names, \"..\", applicability),\n+            snippet_with_applicability(cx, matched_vars, \"..\", applicability)\n+        )\n+    } else {\n+        snippet_with_applicability(cx, matched_vars, \"..\", applicability).to_string()\n+    };\n+\n+    format!(\"{cbrace_start}{scrutinee};\\n{indent}{assignment_str}{snippet_body}{cbrace_end}\")\n }"}, {"sha": "7d8171ead89e10787dee90e48d11a7e33b527a6a", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,7 +1,9 @@\n mod collapsible_match;\n mod infallible_destructuring_match;\n+mod manual_filter;\n mod manual_map;\n mod manual_unwrap_or;\n+mod manual_utils;\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n@@ -898,6 +900,34 @@ declare_clippy_lint! {\n     \"reimplementation of `map`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of `match` which could be implemented using `filter`\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the `filter` method is clearer and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// match Some(0) {\n+    ///     Some(x) => if x % 2 == 0 {\n+    ///                     Some(x)\n+    ///                } else {\n+    ///                     None\n+    ///                 },\n+    ///     None => None,\n+    /// };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// Some(0).filter(|&x| x % 2 == 0);\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub MANUAL_FILTER,\n+    complexity,\n+    \"reimplentation of `filter`\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     msrv: Option<RustcVersion>,\n@@ -939,6 +969,7 @@ impl_lint_pass!(Matches => [\n     SIGNIFICANT_DROP_IN_SCRUTINEE,\n     TRY_ERR,\n     MANUAL_MAP,\n+    MANUAL_FILTER,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n@@ -988,6 +1019,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     if !in_constant(cx, expr.hir_id) {\n                         manual_unwrap_or::check(cx, expr, ex, arms);\n                         manual_map::check_match(cx, expr, ex, arms);\n+                        manual_filter::check_match(cx, ex, arms, expr);\n                     }\n \n                     if self.infallible_destructuring_match_linted {\n@@ -1014,6 +1046,14 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                     }\n                     if !in_constant(cx, expr.hir_id) {\n                         manual_map::check_if_let(cx, expr, if_let.let_pat, if_let.let_expr, if_let.if_then, else_expr);\n+                        manual_filter::check_if_let(\n+                            cx,\n+                            expr,\n+                            if_let.let_pat,\n+                            if_let.let_expr,\n+                            if_let.if_then,\n+                            else_expr,\n+                        );\n                     }\n                 }\n                 redundant_pattern_match::check_if_let("}, {"sha": "e5a15b2e1a1d2b454a8a5f488f6dfa1f7aa654fb", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,14 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{expr_block, snippet};\n-use clippy_utils::ty::{implements_trait, match_type, peel_mid_ty_refs};\n-use clippy_utils::{\n-    is_lint_allowed, is_unit_expr, is_wild, paths, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs,\n-};\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, peel_mid_ty_refs};\n+use clippy_utils::{is_lint_allowed, is_unit_expr, is_wild, peel_blocks, peel_hir_pat_refs, peel_n_hir_expr_refs};\n use core::cmp::max;\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n+use rustc_span::sym;\n \n use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n \n@@ -156,10 +155,10 @@ fn pat_in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'a>, pat: &Pat<'_>) ->\n /// Returns `true` if the given type is an enum we know won't be expanded in the future\n fn in_candidate_enum<'a>(cx: &LateContext<'a>, ty: Ty<'_>) -> bool {\n     // list of candidate `Enum`s we know will never get any more members\n-    let candidates = [&paths::COW, &paths::OPTION, &paths::RESULT];\n+    let candidates = [sym::Cow, sym::Option, sym::Result];\n \n     for candidate_ty in candidates {\n-        if match_type(cx, ty, candidate_ty) {\n+        if is_type_diagnostic_item(cx, ty, candidate_ty) {\n             return true;\n         }\n     }"}, {"sha": "8adf9e37059209d24d940d8c193263afda17bcae", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -42,9 +42,8 @@ pub(super) fn check(\n \n fn ty_has_iter_method(cx: &LateContext<'_>, self_ref_ty: Ty<'_>) -> Option<(Symbol, &'static str)> {\n     has_iter_method(cx, self_ref_ty).map(|ty_name| {\n-        let mutbl = match self_ref_ty.kind() {\n-            ty::Ref(_, _, mutbl) => mutbl,\n-            _ => unreachable!(),\n+        let ty::Ref(_, _, mutbl) = self_ref_ty.kind() else {\n+            unreachable!()\n         };\n         let method_name = match mutbl {\n             hir::Mutability::Not => \"iter\","}, {"sha": "b80541b86479a804227b1152718881ad7d2daf58", "filename": "clippy_lints/src/methods/manual_saturating_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_saturating_arithmetic.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -21,21 +21,15 @@ pub fn check(\n         return;\n     }\n \n-    let mm = if let Some(mm) = is_min_or_max(cx, unwrap_arg) {\n-        mm\n-    } else {\n-        return;\n-    };\n+    let Some(mm) = is_min_or_max(cx, unwrap_arg) else { return };\n \n     if ty.is_signed() {\n         use self::{\n             MinMax::{Max, Min},\n             Sign::{Neg, Pos},\n         };\n \n-        let sign = if let Some(sign) = lit_sign(arith_rhs) {\n-            sign\n-        } else {\n+        let Some(sign) = lit_sign(arith_rhs) else {\n             return;\n         };\n "}, {"sha": "fb92779be2a7a54b9e58dd83bacb4d5416d40016", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -102,9 +102,7 @@ use bind_instead_of_map::BindInsteadOfMap;\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{\n-    contains_return, get_trait_def_id, is_trait_method, iter_input_pats, meets_msrv, msrvs, paths, return_ty,\n-};\n+use clippy_utils::{contains_return, is_trait_method, iter_input_pats, meets_msrv, msrvs, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n@@ -3372,15 +3370,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             then {\n                 let first_arg_span = first_arg_ty.span;\n                 let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty().skip_binder();\n+                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+                    .self_ty()\n+                    .skip_binder();\n                 wrong_self_convention::check(\n                     cx,\n                     item.ident.name.as_str(),\n                     self_ty,\n                     first_arg_ty,\n                     first_arg_span,\n                     false,\n-                    true\n+                    true,\n                 );\n             }\n         }\n@@ -3389,7 +3389,9 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n-            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty().skip_binder();\n+            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+                .self_ty()\n+                .skip_binder();\n             if !ret_ty.contains(self_ty);\n \n             then {\n@@ -3846,14 +3848,13 @@ impl SelfKind {\n                 return m == mutability && t == parent_ty;\n             }\n \n-            let trait_path = match mutability {\n-                hir::Mutability::Not => &paths::ASREF_TRAIT,\n-                hir::Mutability::Mut => &paths::ASMUT_TRAIT,\n+            let trait_sym = match mutability {\n+                hir::Mutability::Not => sym::AsRef,\n+                hir::Mutability::Mut => sym::AsMut,\n             };\n \n-            let trait_def_id = match get_trait_def_id(cx, trait_path) {\n-                Some(did) => did,\n-                None => return false,\n+            let Some(trait_def_id) = cx.tcx.get_diagnostic_item(trait_sym) else {\n+                return false\n             };\n             implements_trait(cx, ty, trait_def_id, &[parent_ty.into()])\n         }"}, {"sha": "742483e6b2e5545274adf08081f1db58953eb8c5", "filename": "clippy_lints/src/methods/option_as_ref_deref.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_as_ref_deref.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -32,8 +32,7 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let deref_aliases: [&[&str]; 9] = [\n-        &paths::DEREF_TRAIT_METHOD,\n+    let deref_aliases: [&[&str]; 8] = [\n         &paths::DEREF_MUT_TRAIT_METHOD,\n         &paths::CSTRING_AS_C_STR,\n         &paths::OS_STRING_AS_OS_STR,\n@@ -45,12 +44,14 @@ pub(super) fn check<'tcx>(\n     ];\n \n     let is_deref = match map_arg.kind {\n-        hir::ExprKind::Path(ref expr_qpath) => cx\n-            .qpath_res(expr_qpath, map_arg.hir_id)\n-            .opt_def_id()\n-            .map_or(false, |fun_def_id| {\n-                deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n-            }),\n+        hir::ExprKind::Path(ref expr_qpath) => {\n+            cx.qpath_res(expr_qpath, map_arg.hir_id)\n+                .opt_def_id()\n+                .map_or(false, |fun_def_id| {\n+                    cx.tcx.is_diagnostic_item(sym::deref_method, fun_def_id)\n+                        || deref_aliases.iter().any(|path| match_def_path(cx, fun_def_id, path))\n+                })\n+        },\n         hir::ExprKind::Closure(&hir::Closure { body, .. }) => {\n             let closure_body = cx.tcx.hir().body(body);\n             let closure_expr = peel_blocks(closure_body.value);\n@@ -68,7 +69,8 @@ pub(super) fn check<'tcx>(\n                         if let [ty::adjustment::Adjust::Deref(None), ty::adjustment::Adjust::Borrow(_)] = *adj;\n                         then {\n                             let method_did = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id).unwrap();\n-                            deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n+                            cx.tcx.is_diagnostic_item(sym::deref_method, method_did)\n+                                || deref_aliases.iter().any(|path| match_def_path(cx, method_did, path))\n                         } else {\n                             false\n                         }"}, {"sha": "991d3dd538bf86a7ea572c011cd419fb1aa22999", "filename": "clippy_lints/src/methods/or_fun_call.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_fun_call.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,14 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::eager_or_lazy::switch_to_lazy_eval;\n use clippy_utils::source::{snippet, snippet_with_macro_callsite};\n-use clippy_utils::ty::{implements_trait, match_type};\n-use clippy_utils::{contains_return, is_trait_item, last_path_segment, paths};\n+use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n+use clippy_utils::{contains_return, is_trait_item, last_path_segment};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use std::borrow::Cow;\n \n use super::OR_FUN_CALL;\n@@ -88,11 +88,11 @@ pub(super) fn check<'tcx>(\n         fun_span: Option<Span>,\n     ) {\n         // (path, fn_has_argument, methods, suffix)\n-        const KNOW_TYPES: [(&[&str], bool, &[&str], &str); 4] = [\n-            (&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::HASHMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n-            (&paths::OPTION, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n-            (&paths::RESULT, true, &[\"or\", \"unwrap_or\"], \"else\"),\n+        const KNOW_TYPES: [(Symbol, bool, &[&str], &str); 4] = [\n+            (sym::BTreeEntry, false, &[\"or_insert\"], \"with\"),\n+            (sym::HashMapEntry, false, &[\"or_insert\"], \"with\"),\n+            (sym::Option, false, &[\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"], \"else\"),\n+            (sym::Result, true, &[\"or\", \"unwrap_or\"], \"else\"),\n         ];\n \n         if_chain! {\n@@ -104,7 +104,7 @@ pub(super) fn check<'tcx>(\n             let self_ty = cx.typeck_results().expr_ty(self_expr);\n \n             if let Some(&(_, fn_has_arguments, poss, suffix)) =\n-                KNOW_TYPES.iter().find(|&&i| match_type(cx, self_ty, i.0));\n+                KNOW_TYPES.iter().find(|&&i| is_type_diagnostic_item(cx, self_ty, i.0));\n \n             if poss.contains(&name);\n \n@@ -121,10 +121,9 @@ pub(super) fn check<'tcx>(\n                             macro_expanded_snipped = snippet(cx, snippet_span, \"..\");\n                             match macro_expanded_snipped.strip_prefix(\"$crate::vec::\") {\n                                 Some(stripped) => Cow::from(stripped),\n-                                None => macro_expanded_snipped\n+                                None => macro_expanded_snipped,\n                             }\n-                        }\n-                        else {\n+                        } else {\n                             not_macro_argument_snippet\n                         }\n                     };"}, {"sha": "1acac59144cee8ce926daf8fdabfe5212918dae5", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -289,9 +289,7 @@ fn parse_iter_usage<'tcx>(\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, _, [args @ ..], _) = e.kind {\n-                (name, args)\n-            } else {\n+            let ExprKind::MethodCall(name, _, [args @ ..], _) = e.kind else {\n                 return None;\n             };\n             let did = cx.typeck_results().type_dependent_def_id(e.hir_id)?;"}, {"sha": "4b4f2f47b1d92e3b343a5df372c8d4456a5af84d", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -363,7 +363,7 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n                 && let output_ty = return_ty(cx, item.hir_id())\n                 && let local_def_id = cx.tcx.hir().local_def_id(item.hir_id())\n                 && Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-                    let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, item.hir_id());\n+                    let fn_ctxt = FnCtxt::new(inherited, cx.param_env, item.hir_id());\n                     fn_ctxt.can_coerce(ty, output_ty)\n                 }) {\n                     if has_lifetime(output_ty) && has_lifetime(ty) {"}, {"sha": "27e7f8505eb5b854acfaf7fb6b622273f3d551db", "filename": "clippy_lints/src/misc_early/literal_suffix.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fliteral_suffix.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -6,9 +6,7 @@ use rustc_lint::EarlyContext;\n use super::{SEPARATED_LITERAL_SUFFIX, UNSEPARATED_LITERAL_SUFFIX};\n \n pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &str, sugg_type: &str) {\n-    let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n-        val\n-    } else {\n+    let Some(maybe_last_sep_idx) = lit_snip.len().checked_sub(suffix.len() + 1) else {\n         return; // It's useless so shouldn't lint.\n     };\n     // Do not lint when literal is unsuffixed."}, {"sha": "263ee1e945a255cfdd23977bab7cf9ef84f5e5d6", "filename": "clippy_lints/src/misc_early/mixed_case_hex_literals.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -5,9 +5,7 @@ use rustc_lint::EarlyContext;\n use super::MIXED_CASE_HEX_LITERALS;\n \n pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &str) {\n-    let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n-        val\n-    } else {\n+    let Some(maybe_last_sep_idx) = lit_snip.len().checked_sub(suffix.len() + 1) else {\n         return; // It's useless so shouldn't lint.\n     };\n     if maybe_last_sep_idx <= 2 {"}, {"sha": "9ead43ea4a477060961a8ae1afbd842f527cb71f", "filename": "clippy_lints/src/misc_early/zero_prefixed_literal.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -6,6 +6,7 @@ use rustc_lint::EarlyContext;\n use super::ZERO_PREFIXED_LITERAL;\n \n pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str) {\n+    let trimmed_lit_snip = lit_snip.trim_start_matches(|c| c == '_' || c == '0');\n     span_lint_and_then(\n         cx,\n         ZERO_PREFIXED_LITERAL,\n@@ -15,15 +16,18 @@ pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str) {\n             diag.span_suggestion(\n                 lit.span,\n                 \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n-                lit_snip.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-            diag.span_suggestion(\n-                lit.span,\n-                \"if you mean to use an octal constant, use `0o`\",\n-                format!(\"0o{}\", lit_snip.trim_start_matches(|c| c == '_' || c == '0')),\n+                trimmed_lit_snip.to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n+            // do not advise to use octal form if the literal cannot be expressed in base 8.\n+            if !lit_snip.contains(|c| c == '8' || c == '9') {\n+                diag.span_suggestion(\n+                    lit.span,\n+                    \"if you mean to use an octal constant, use `0o`\",\n+                    format!(\"0o{trimmed_lit_snip}\"),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n         },\n     );\n }"}, {"sha": "9de4b56b77b56c4d858e55a5868a2861065ac042", "filename": "clippy_lints/src/mismatching_type_param_order.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmismatching_type_param_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmismatching_type_param_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmismatching_type_param_order.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -70,9 +70,8 @@ impl<'tcx> LateLintPass<'tcx> for TypeParamMismatch {\n \n                 // find the type that the Impl is for\n                 // only lint on struct/enum/union for now\n-                let defid = match path.res {\n-                    Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, defid) => defid,\n-                    _ => return,\n+                let Res::Def(DefKind::Struct | DefKind::Enum | DefKind::Union, defid) = path.res else {\n+                    return\n                 };\n \n                 // get the names of the generic parameters in the type"}, {"sha": "641dbb7f7a7454f3831677a0c52250d42e5001e1", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -8,6 +8,7 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::is_from_proc_macro;\n+use if_chain::if_chain;\n use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};"}, {"sha": "6752976348f6045ed45e98ad774cf722d43d14ea", "filename": "clippy_lints/src/mixed_read_write_in_expression.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmixed_read_write_in_expression.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -190,10 +190,7 @@ fn check_for_unsequenced_reads(vis: &mut ReadVisitor<'_, '_>) {\n         if parent_id == cur_id {\n             break;\n         }\n-        let parent_node = match map.find(parent_id) {\n-            Some(parent) => parent,\n-            None => break,\n-        };\n+        let Some(parent_node) = map.find(parent_id) else { break };\n \n         let stop_early = match parent_node {\n             Node::Expr(expr) => check_expr(vis, expr),"}, {"sha": "3ef0c6634598474189ba0b5415d733304b2d2671", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -92,10 +92,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "c3b633fd6a038919bfcdea2c9935030b7a9ab45f", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -49,9 +49,8 @@ declare_lint_pass!(NeedlessForEach => [NEEDLESS_FOR_EACH]);\n \n impl<'tcx> LateLintPass<'tcx> for NeedlessForEach {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n-        let expr = match stmt.kind {\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n-            _ => return,\n+        let (StmtKind::Expr(expr) | StmtKind::Semi(expr)) = stmt.kind else {\n+             return\n         };\n \n         if_chain! {"}, {"sha": "5c2b96f5b2ce6287a327567635a64184cc56e1a0", "filename": "clippy_lints/src/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_cmp_op_on_partial_ord.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{self, get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -47,18 +47,16 @@ declare_lint_pass!(NoNegCompOpForPartialOrd => [NEG_CMP_OP_ON_PARTIAL_ORD]);\n impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-\n             if !in_external_macro(cx.sess(), expr.span);\n             if let ExprKind::Unary(UnOp::Not, inner) = expr.kind;\n             if let ExprKind::Binary(ref op, left, _) = inner.kind;\n             if let BinOpKind::Le | BinOpKind::Ge | BinOpKind::Lt | BinOpKind::Gt = op.node;\n \n             then {\n-\n                 let ty = cx.typeck_results().expr_ty(left);\n \n                 let implements_ord = {\n-                    if let Some(id) = get_trait_def_id(cx, &paths::ORD) {\n+                    if let Some(id) = cx.tcx.get_diagnostic_item(sym::Ord) {\n                         implements_trait(cx, ty, id, &[])\n                     } else {\n                         return;\n@@ -81,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for NoNegCompOpForPartialOrd {\n                         \"the use of negated comparison operators on partially ordered \\\n                         types produces code that is hard to read and refactor, please \\\n                         consider using the `partial_cmp` method instead, to make it \\\n-                        clear that the two values could be incomparable\"\n+                        clear that the two values could be incomparable\",\n                     );\n                 }\n             }"}, {"sha": "a6742824bc56aae7855f9c76fc1b79f00b8ca200", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -357,9 +357,8 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n             }\n \n             // Make sure it is a const item.\n-            let item_def_id = match cx.qpath_res(qpath, expr.hir_id) {\n-                Res::Def(DefKind::Const | DefKind::AssocConst, did) => did,\n-                _ => return,\n+            let Res::Def(DefKind::Const | DefKind::AssocConst, item_def_id) = cx.qpath_res(qpath, expr.hir_id) else {\n+                return\n             };\n \n             // Climb up to resolve any field access and explicit referencing."}, {"sha": "2ecb04874842f8aeca17b4c7ba5ba69e2e9c0665", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -55,9 +55,8 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                     if let ExprKind::Lit(_) = param.kind;\n \n                     then {\n-                        let snip = match snippet_opt(cx, param.span) {\n-                            Some(s) => s,\n-                            _ => return,\n+                        let Some(snip) = snippet_opt(cx, param.span) else {\n+                            return\n                         };\n \n                         if !snip.starts_with(\"0o\") {\n@@ -72,16 +71,10 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                     if let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n                     if match_def_path(cx, def_id, &paths::PERMISSIONS_FROM_MODE);\n                     if let ExprKind::Lit(_) = param.kind;\n-\n+                    if let Some(snip) = snippet_opt(cx, param.span);\n+                    if !snip.starts_with(\"0o\");\n                     then {\n-                        let snip = match snippet_opt(cx, param.span) {\n-                            Some(s) => s,\n-                            _ => return,\n-                        };\n-\n-                        if !snip.starts_with(\"0o\") {\n-                            show_error(cx, param);\n-                        }\n+                        show_error(cx, param);\n                     }\n                 }\n             },"}, {"sha": "6c909e5ed73ea6b5faac116b6ca5bb657a3cc21f", "filename": "clippy_lints/src/nonstandard_macro_braces.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnonstandard_macro_braces.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -266,7 +266,7 @@ impl<'de> Deserialize<'de> for MacroMatcher {\n                         .iter()\n                         .find(|b| b.0 == brace)\n                         .map(|(o, c)| ((*o).to_owned(), (*c).to_owned()))\n-                        .ok_or_else(|| de::Error::custom(&format!(\"expected one of `(`, `{{`, `[` found `{brace}`\")))?,\n+                        .ok_or_else(|| de::Error::custom(format!(\"expected one of `(`, `{{`, `[` found `{brace}`\")))?,\n                 })\n             }\n         }"}, {"sha": "24aeb82a37f3107095a9944ca1b5fb9738a0c51b", "filename": "clippy_lints/src/operators/cmp_owned.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foperators%2Fcmp_owned.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::{implements_trait, is_copy};\n-use clippy_utils::{match_any_def_paths, path_def_id, paths};\n+use clippy_utils::{match_def_path, path_def_id, paths};\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n use rustc_lint::LateContext;\n@@ -49,13 +49,15 @@ fn check_op(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool)\n             (arg, arg.span)\n         },\n         ExprKind::Call(path, [arg])\n-            if path_def_id(cx, path)\n-                .and_then(|id| match_any_def_paths(cx, id, &[&paths::FROM_STR_METHOD, &paths::FROM_FROM]))\n-                .map_or(false, |idx| match idx {\n-                    0 => true,\n-                    1 => !is_copy(cx, typeck.expr_ty(expr)),\n-                    _ => false,\n-                }) =>\n+            if path_def_id(cx, path).map_or(false, |id| {\n+                if match_def_path(cx, id, &paths::FROM_STR_METHOD) {\n+                    true\n+                } else if cx.tcx.lang_items().from_fn() == Some(id) {\n+                    !is_copy(cx, typeck.expr_ty(expr))\n+                } else {\n+                    false\n+                }\n+            }) =>\n         {\n             (arg, arg.span)\n         },"}, {"sha": "f60d9d65b1207a345698bde417aa7094ee1deae3", "filename": "clippy_lints/src/partial_pub_fields.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fpartial_pub_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fpartial_pub_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartial_pub_fields.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,81 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_ast::ast::{Item, ItemKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks whether partial fields of a struct are public.\n+    ///\n+    /// Either make all fields of a type public, or make none of them public\n+    ///\n+    /// ### Why is this bad?\n+    /// Most types should either be:\n+    /// * Abstract data types: complex objects with opaque implementation which guard\n+    /// interior invariants and expose intentionally limited API to the outside world.\n+    /// * Data:\u2009relatively simple objects which group a bunch of related attributes together.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// pub struct Color {\n+    ///     pub r: u8,\n+    ///     pub g: u8,\n+    ///     b: u8,\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// pub struct Color {\n+    ///     pub r: u8,\n+    ///     pub g: u8,\n+    ///     pub b: u8,\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.66.0\"]\n+    pub PARTIAL_PUB_FIELDS,\n+    restriction,\n+    \"partial fields of a struct are public\"\n+}\n+declare_lint_pass!(PartialPubFields => [PARTIAL_PUB_FIELDS]);\n+\n+impl EarlyLintPass for PartialPubFields {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        let ItemKind::Struct(ref st, _) = item.kind else {\n+            return;\n+        };\n+\n+        let mut fields = st.fields().iter();\n+        let Some(first_field) = fields.next() else {\n+            // Empty struct.\n+            return;\n+        };\n+        let all_pub = first_field.vis.kind.is_pub();\n+        let all_priv = !all_pub;\n+\n+        let msg = \"mixed usage of pub and non-pub fields\";\n+\n+        for field in fields {\n+            if all_priv && field.vis.kind.is_pub() {\n+                span_lint_and_help(\n+                    cx,\n+                    PARTIAL_PUB_FIELDS,\n+                    field.vis.span,\n+                    msg,\n+                    None,\n+                    \"consider using private field here\",\n+                );\n+                return;\n+            } else if all_pub && !field.vis.kind.is_pub() {\n+                span_lint_and_help(\n+                    cx,\n+                    PARTIAL_PUB_FIELDS,\n+                    field.vis.span,\n+                    msg,\n+                    None,\n+                    \"consider using public field here\",\n+                );\n+                return;\n+            }\n+        }\n+    }\n+}"}, {"sha": "40db315bf272612a86ab6b0b2aeff431e9159de5", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -15,13 +15,17 @@ use rustc_hir::{\n     ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n     TraitItem, TraitItemKind, TyKind, Unsafety,\n };\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Binder, ExistentialPredicate, List, PredicateKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::sym;\n use rustc_span::symbol::Symbol;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use std::fmt;\n use std::iter;\n \n@@ -384,6 +388,17 @@ enum DerefTy<'tcx> {\n     Slice(Option<Span>, Ty<'tcx>),\n }\n impl<'tcx> DerefTy<'tcx> {\n+    fn ty(&self, cx: &LateContext<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            Self::Str => cx.tcx.types.str_,\n+            Self::Path => cx.tcx.mk_adt(\n+                cx.tcx.adt_def(cx.tcx.get_diagnostic_item(sym::Path).unwrap()),\n+                List::empty(),\n+            ),\n+            Self::Slice(_, ty) => cx.tcx.mk_slice(ty),\n+        }\n+    }\n+\n     fn argless_str(&self) -> &'static str {\n         match *self {\n             Self::Str => \"str\",\n@@ -552,9 +567,8 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n             }\n \n             // Check if this is local we care about\n-            let args_idx = match path_to_local(e).and_then(|id| self.bindings.get(&id)) {\n-                Some(&i) => i,\n-                None => return walk_expr(self, e),\n+            let Some(&args_idx) = path_to_local(e).and_then(|id| self.bindings.get(&id)) else {\n+                return walk_expr(self, e);\n             };\n             let args = &self.args[args_idx];\n             let result = &mut self.results[args_idx];\n@@ -582,6 +596,7 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                         let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n                         if expr_sig(self.cx, f).and_then(|sig| sig.input(i)).map_or(true, |ty| {\n                             match *ty.skip_binder().peel_refs().kind() {\n+                                ty::Dynamic(preds, _, _) => !matches_preds(self.cx, args.deref_ty.ty(self.cx), preds),\n                                 ty::Param(_) => true,\n                                 ty::Adt(def, _) => def.did() == args.ty_did,\n                                 _ => false,\n@@ -609,14 +624,15 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                             }\n                         }\n \n-                        let id = if let Some(x) = self.cx.typeck_results().type_dependent_def_id(e.hir_id) {\n-                            x\n-                        } else {\n+                        let Some(id) = self.cx.typeck_results().type_dependent_def_id(e.hir_id) else {\n                             set_skip_flag();\n                             return;\n                         };\n \n                         match *self.cx.tcx.fn_sig(id).skip_binder().inputs()[i].peel_refs().kind() {\n+                            ty::Dynamic(preds, _, _) if !matches_preds(self.cx, args.deref_ty.ty(self.cx), preds) => {\n+                                set_skip_flag();\n+                            },\n                             ty::Param(_) => {\n                                 set_skip_flag();\n                             },\n@@ -668,6 +684,30 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n     v.results\n }\n \n+fn matches_preds<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    preds: &'tcx [Binder<'tcx, ExistentialPredicate<'tcx>>],\n+) -> bool {\n+    let infcx = cx.tcx.infer_ctxt().build();\n+    preds.iter().all(|&p| match cx.tcx.erase_late_bound_regions(p) {\n+        ExistentialPredicate::Trait(p) => infcx\n+            .type_implements_trait(p.def_id, ty, p.substs, cx.param_env)\n+            .must_apply_modulo_regions(),\n+        ExistentialPredicate::Projection(p) => infcx.predicate_must_hold_modulo_regions(&Obligation::new(\n+            ObligationCause::dummy(),\n+            cx.param_env,\n+            cx.tcx.mk_predicate(Binder::bind_with_vars(\n+                PredicateKind::Projection(p.with_self_ty(cx.tcx, ty)),\n+                List::empty(),\n+            )),\n+        )),\n+        ExistentialPredicate::AutoTrait(p) => infcx\n+            .type_implements_trait(p, ty, List::empty(), cx.param_env)\n+            .must_apply_modulo_regions(),\n+    })\n+}\n+\n fn get_rptr_lm<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> Option<(&'tcx Lifetime, Mutability, Span)> {\n     if let TyKind::Rptr(lt, ref m) = ty.kind {\n         Some((lt, m.mutbl, ty.span))"}, {"sha": "72dda67c72b25d09a64aa9c953d668c42342b4da", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -49,15 +49,13 @@ declare_lint_pass!(PtrOffsetWithCast => [PTR_OFFSET_WITH_CAST]);\n impl<'tcx> LateLintPass<'tcx> for PtrOffsetWithCast {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         // Check if the expressions is a ptr.offset or ptr.wrapping_offset method call\n-        let (receiver_expr, arg_expr, method) = match expr_as_ptr_offset_call(cx, expr) {\n-            Some(call_arg) => call_arg,\n-            None => return,\n+        let Some((receiver_expr, arg_expr, method)) = expr_as_ptr_offset_call(cx, expr) else {\n+            return\n         };\n \n         // Check if the argument to the method call is a cast from usize\n-        let cast_lhs_expr = match expr_as_cast_from_usize(cx, arg_expr) {\n-            Some(cast_lhs_expr) => cast_lhs_expr,\n-            None => return,\n+        let Some(cast_lhs_expr) = expr_as_cast_from_usize(cx, arg_expr) else {\n+            return\n         };\n \n         let msg = format!(\"use of `{method}` with a `usize` casted to an `isize`\");"}, {"sha": "aedbe08e3e46e2e340c0263cc7766f4ab9c50c81", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 35, "deletions": 419, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,25 +1,18 @@\n use clippy_utils::diagnostics::{span_lint_hir, span_lint_hir_and_then};\n+use clippy_utils::mir::{visit_local_usage, LocalUsage, PossibleBorrowerMap};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{has_drop, is_copy, is_type_diagnostic_item, walk_ptrs_ty_depth};\n use clippy_utils::{fn_has_unsatisfiable_preds, match_def_path, paths};\n use if_chain::if_chain;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{def_id, Body, FnDecl, HirId};\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::{\n-    self, traversal,\n-    visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n-    Mutability,\n-};\n-use rustc_middle::ty::{self, visit::TypeVisitor, Ty};\n-use rustc_mir_dataflow::{Analysis, AnalysisDomain, CallReturnPlaces, GenKill, GenKillAnalysis, ResultsCursor};\n+use rustc_middle::mir;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n use rustc_span::sym;\n-use std::ops::ControlFlow;\n \n macro_rules! unwrap_or_continue {\n     ($x:expr) => {\n@@ -89,21 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n \n         let mir = cx.tcx.optimized_mir(def_id.to_def_id());\n \n-        let possible_origin = {\n-            let mut vis = PossibleOriginVisitor::new(mir);\n-            vis.visit_body(mir);\n-            vis.into_map(cx)\n-        };\n-        let maybe_storage_live_result = MaybeStorageLive\n-            .into_engine(cx.tcx, mir)\n-            .pass_name(\"redundant_clone\")\n-            .iterate_to_fixpoint()\n-            .into_results_cursor(mir);\n-        let mut possible_borrower = {\n-            let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n-            vis.visit_body(mir);\n-            vis.into_map(cx, maybe_storage_live_result)\n-        };\n+        let mut possible_borrower = PossibleBorrowerMap::new(cx, mir);\n \n         for (bb, bbdata) in mir.basic_blocks.iter_enumerated() {\n             let terminator = bbdata.terminator();\n@@ -374,403 +353,40 @@ struct CloneUsage {\n     /// Whether the clone value is mutated.\n     clone_consumed_or_mutated: bool,\n }\n-fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>, bb: mir::BasicBlock) -> CloneUsage {\n-    struct V {\n-        cloned: mir::Local,\n-        clone: mir::Local,\n-        result: CloneUsage,\n-    }\n-    impl<'tcx> mir::visit::Visitor<'tcx> for V {\n-        fn visit_basic_block_data(&mut self, block: mir::BasicBlock, data: &mir::BasicBlockData<'tcx>) {\n-            let statements = &data.statements;\n-            for (statement_index, statement) in statements.iter().enumerate() {\n-                self.visit_statement(statement, mir::Location { block, statement_index });\n-            }\n-\n-            self.visit_terminator(\n-                data.terminator(),\n-                mir::Location {\n-                    block,\n-                    statement_index: statements.len(),\n-                },\n-            );\n-        }\n-\n-        fn visit_place(&mut self, place: &mir::Place<'tcx>, ctx: PlaceContext, loc: mir::Location) {\n-            let local = place.local;\n-\n-            if local == self.cloned\n-                && !matches!(\n-                    ctx,\n-                    PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n-                )\n-            {\n-                self.result.cloned_used = true;\n-                self.result.cloned_consume_or_mutate_loc = self.result.cloned_consume_or_mutate_loc.or_else(|| {\n-                    matches!(\n-                        ctx,\n-                        PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n-                            | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n-                    )\n-                    .then(|| loc)\n-                });\n-            } else if local == self.clone {\n-                match ctx {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n-                    | PlaceContext::MutatingUse(MutatingUseContext::Borrow) => {\n-                        self.result.clone_consumed_or_mutated = true;\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-\n-    let init = CloneUsage {\n-        cloned_used: false,\n-        cloned_consume_or_mutate_loc: None,\n-        // Consider non-temporary clones consumed.\n-        // TODO: Actually check for mutation of non-temporaries.\n-        clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp,\n-    };\n-    traversal::ReversePostorder::new(mir, bb)\n-        .skip(1)\n-        .fold(init, |usage, (tbb, tdata)| {\n-            // Short-circuit\n-            if (usage.cloned_used && usage.clone_consumed_or_mutated) ||\n-                // Give up on loops\n-                tdata.terminator().successors().any(|s| s == bb)\n-            {\n-                return CloneUsage {\n-                    cloned_used: true,\n-                    clone_consumed_or_mutated: true,\n-                    ..usage\n-                };\n-            }\n-\n-            let mut v = V {\n-                cloned,\n-                clone,\n-                result: usage,\n-            };\n-            v.visit_basic_block_data(tbb, tdata);\n-            v.result\n-        })\n-}\n-\n-/// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n-#[derive(Copy, Clone)]\n-struct MaybeStorageLive;\n-\n-impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n-    type Domain = BitSet<mir::Local>;\n-    const NAME: &'static str = \"maybe_storage_live\";\n-\n-    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n-        // bottom = dead\n-        BitSet::new_empty(body.local_decls.len())\n-    }\n-\n-    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n-        for arg in body.args_iter() {\n-            state.insert(arg);\n-        }\n-    }\n-}\n-\n-impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n-    type Idx = mir::Local;\n-\n-    fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n-        match stmt.kind {\n-            mir::StatementKind::StorageLive(l) => trans.gen(l),\n-            mir::StatementKind::StorageDead(l) => trans.kill(l),\n-            _ => (),\n-        }\n-    }\n-\n-    fn terminator_effect(\n-        &self,\n-        _trans: &mut impl GenKill<Self::Idx>,\n-        _terminator: &mir::Terminator<'tcx>,\n-        _loc: mir::Location,\n-    ) {\n-    }\n-\n-    fn call_return_effect(\n-        &self,\n-        _trans: &mut impl GenKill<Self::Idx>,\n-        _block: mir::BasicBlock,\n-        _return_places: CallReturnPlaces<'_, 'tcx>,\n-    ) {\n-        // Nothing to do when a call returns successfully\n-    }\n-}\n-\n-/// Collects the possible borrowers of each local.\n-/// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n-/// possible borrowers of `a`.\n-struct PossibleBorrowerVisitor<'a, 'tcx> {\n-    possible_borrower: TransitiveRelation,\n-    body: &'a mir::Body<'tcx>,\n-    cx: &'a LateContext<'tcx>,\n-    possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-}\n-\n-impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn new(\n-        cx: &'a LateContext<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n-        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    ) -> Self {\n-        Self {\n-            possible_borrower: TransitiveRelation::default(),\n-            cx,\n-            body,\n-            possible_origin,\n-        }\n-    }\n-\n-    fn into_map(\n-        self,\n-        cx: &LateContext<'tcx>,\n-        maybe_live: ResultsCursor<'tcx, 'tcx, MaybeStorageLive>,\n-    ) -> PossibleBorrowerMap<'a, 'tcx> {\n-        let mut map = FxHashMap::default();\n-        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n-            if is_copy(cx, self.body.local_decls[row].ty) {\n-                continue;\n-            }\n-\n-            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n-            borrowers.remove(mir::Local::from_usize(0));\n-            if !borrowers.is_empty() {\n-                map.insert(row, borrowers);\n-            }\n-        }\n-\n-        let bs = BitSet::new_empty(self.body.local_decls.len());\n-        PossibleBorrowerMap {\n-            map,\n-            maybe_live,\n-            bitset: (bs.clone(), bs),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n-    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n-        let lhs = place.local;\n-        match rvalue {\n-            mir::Rvalue::Ref(_, _, borrowed) => {\n-                self.possible_borrower.add(borrowed.local, lhs);\n-            },\n-            other => {\n-                if ContainsRegion\n-                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n-                    .is_continue()\n-                {\n-                    return;\n-                }\n-                rvalue_locals(other, |rhs| {\n-                    if lhs != rhs {\n-                        self.possible_borrower.add(rhs, lhs);\n-                    }\n-                });\n-            },\n-        }\n-    }\n-\n-    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n-        if let mir::TerminatorKind::Call {\n-            args,\n-            destination: mir::Place { local: dest, .. },\n-            ..\n-        } = &terminator.kind\n-        {\n-            // TODO add doc\n-            // If the call returns something with lifetimes,\n-            // let's conservatively assume the returned value contains lifetime of all the arguments.\n-            // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n-\n-            let mut immutable_borrowers = vec![];\n-            let mut mutable_borrowers = vec![];\n-\n-            for op in args {\n-                match op {\n-                    mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                        if let ty::Ref(_, _, Mutability::Mut) = self.body.local_decls[p.local].ty.kind() {\n-                            mutable_borrowers.push(p.local);\n-                        } else {\n-                            immutable_borrowers.push(p.local);\n-                        }\n-                    },\n-                    mir::Operand::Constant(..) => (),\n-                }\n-            }\n-\n-            let mut mutable_variables: Vec<mir::Local> = mutable_borrowers\n-                .iter()\n-                .filter_map(|r| self.possible_origin.get(r))\n-                .flat_map(HybridBitSet::iter)\n-                .collect();\n-\n-            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n-                mutable_variables.push(*dest);\n-            }\n-\n-            for y in mutable_variables {\n-                for x in &immutable_borrowers {\n-                    self.possible_borrower.add(*x, y);\n-                }\n-                for x in &mutable_borrowers {\n-                    self.possible_borrower.add(*x, y);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Collect possible borrowed for every `&mut` local.\n-/// For example, `_1 = &mut _2` generate _1: {_2,...}\n-/// Known Problems: not sure all borrowed are tracked\n-struct PossibleOriginVisitor<'a, 'tcx> {\n-    possible_origin: TransitiveRelation,\n-    body: &'a mir::Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n-    fn new(body: &'a mir::Body<'tcx>) -> Self {\n-        Self {\n-            possible_origin: TransitiveRelation::default(),\n-            body,\n-        }\n-    }\n-\n-    fn into_map(self, cx: &LateContext<'tcx>) -> FxHashMap<mir::Local, HybridBitSet<mir::Local>> {\n-        let mut map = FxHashMap::default();\n-        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n-            if is_copy(cx, self.body.local_decls[row].ty) {\n-                continue;\n-            }\n-\n-            let mut borrowers = self.possible_origin.reachable_from(row, self.body.local_decls.len());\n-            borrowers.remove(mir::Local::from_usize(0));\n-            if !borrowers.is_empty() {\n-                map.insert(row, borrowers);\n-            }\n-        }\n-        map\n-    }\n-}\n-\n-impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n-    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n-        let lhs = place.local;\n-        match rvalue {\n-            // Only consider `&mut`, which can modify origin place\n-            mir::Rvalue::Ref(_, rustc_middle::mir::BorrowKind::Mut { .. }, borrowed) |\n-            // _2: &mut _;\n-            // _3 = move _2\n-            mir::Rvalue::Use(mir::Operand::Move(borrowed))  |\n-            // _3 = move _2 as &mut _;\n-            mir::Rvalue::Cast(_, mir::Operand::Move(borrowed), _)\n-                => {\n-                self.possible_origin.add(lhs, borrowed.local);\n-            },\n-            _ => {},\n-        }\n-    }\n-}\n-\n-struct ContainsRegion;\n-\n-impl TypeVisitor<'_> for ContainsRegion {\n-    type BreakTy = ();\n-\n-    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<Self::BreakTy> {\n-        ControlFlow::BREAK\n-    }\n-}\n-\n-fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n-    use rustc_middle::mir::Rvalue::{Aggregate, BinaryOp, Cast, CheckedBinaryOp, Repeat, UnaryOp, Use};\n-\n-    let mut visit_op = |op: &mir::Operand<'_>| match op {\n-        mir::Operand::Copy(p) | mir::Operand::Move(p) => visit(p.local),\n-        mir::Operand::Constant(..) => (),\n-    };\n \n-    match rvalue {\n-        Use(op) | Repeat(op, _) | Cast(_, op, _) | UnaryOp(_, op) => visit_op(op),\n-        Aggregate(_, ops) => ops.iter().for_each(visit_op),\n-        BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n-            visit_op(lhs);\n-            visit_op(rhs);\n+fn visit_clone_usage(cloned: mir::Local, clone: mir::Local, mir: &mir::Body<'_>, bb: mir::BasicBlock) -> CloneUsage {\n+    if let Some((\n+        LocalUsage {\n+            local_use_locs: cloned_use_locs,\n+            local_consume_or_mutate_locs: cloned_consume_or_mutate_locs,\n         },\n-        _ => (),\n-    }\n-}\n-\n-/// Result of `PossibleBorrowerVisitor`.\n-struct PossibleBorrowerMap<'a, 'tcx> {\n-    /// Mapping `Local -> its possible borrowers`\n-    map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    maybe_live: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n-    // Caches to avoid allocation of `BitSet` on every query\n-    bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n-}\n-\n-impl PossibleBorrowerMap<'_, '_> {\n-    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n-    fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek_after_primary_effect(at);\n-\n-        self.bitset.0.clear();\n-        let maybe_live = &mut self.maybe_live;\n-        if let Some(bitset) = self.map.get(&borrowed) {\n-            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n-                self.bitset.0.insert(b);\n-            }\n-        } else {\n-            return false;\n-        }\n-\n-        self.bitset.1.clear();\n-        for b in borrowers {\n-            self.bitset.1.insert(*b);\n+        LocalUsage {\n+            local_use_locs: _,\n+            local_consume_or_mutate_locs: clone_consume_or_mutate_locs,\n+        },\n+    )) = visit_local_usage(\n+        &[cloned, clone],\n+        mir,\n+        mir::Location {\n+            block: bb,\n+            statement_index: mir.basic_blocks[bb].statements.len(),\n+        },\n+    )\n+    .map(|mut vec| (vec.remove(0), vec.remove(0)))\n+    {\n+        CloneUsage {\n+            cloned_used: !cloned_use_locs.is_empty(),\n+            cloned_consume_or_mutate_loc: cloned_consume_or_mutate_locs.first().copied(),\n+            // Consider non-temporary clones consumed.\n+            // TODO: Actually check for mutation of non-temporaries.\n+            clone_consumed_or_mutated: mir.local_kind(clone) != mir::LocalKind::Temp\n+                || !clone_consume_or_mutate_locs.is_empty(),\n         }\n-\n-        self.bitset.0 == self.bitset.1\n-    }\n-\n-    fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek_after_primary_effect(at);\n-        self.maybe_live.contains(local)\n-    }\n-}\n-\n-#[derive(Default)]\n-struct TransitiveRelation {\n-    relations: FxHashMap<mir::Local, Vec<mir::Local>>,\n-}\n-impl TransitiveRelation {\n-    fn add(&mut self, a: mir::Local, b: mir::Local) {\n-        self.relations.entry(a).or_default().push(b);\n-    }\n-\n-    fn reachable_from(&self, a: mir::Local, domain_size: usize) -> HybridBitSet<mir::Local> {\n-        let mut seen = HybridBitSet::new_empty(domain_size);\n-        let mut stack = vec![a];\n-        while let Some(u) = stack.pop() {\n-            if let Some(edges) = self.relations.get(&u) {\n-                for &v in edges {\n-                    if seen.insert(v) {\n-                        stack.push(v);\n-                    }\n-                }\n-            }\n+    } else {\n+        CloneUsage {\n+            cloned_used: true,\n+            cloned_consume_or_mutate_loc: None,\n+            clone_consumed_or_mutated: true,\n         }\n-        seen\n     }\n }"}, {"sha": "dead36e3bea8f124d00e128cebc06372a0ee9bcc", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -55,11 +55,11 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n             if matches!(cx.tcx.def_kind(id.def_id), DefKind::Impl)\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n-                  items,\n-                  of_trait,\n-                  self_ty,\n-                  ..\n-                                      }) = &item.kind\n+                    items,\n+                    of_trait,\n+                    self_ty,\n+                    ..\n+                }) = &item.kind\n                 && let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind\n             {\n                 if !map.contains_key(res) {"}, {"sha": "87f966ced0df121b640a5b301809027ed3dd3cb3", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -106,10 +106,7 @@ impl_lint_pass!(Shadow => [SHADOW_SAME, SHADOW_REUSE, SHADOW_UNRELATED]);\n \n impl<'tcx> LateLintPass<'tcx> for Shadow {\n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {\n-        let (id, ident) = match pat.kind {\n-            PatKind::Binding(_, hir_id, ident, _) => (hir_id, ident),\n-            _ => return,\n-        };\n+        let PatKind::Binding(_, id, ident, _) = pat.kind else { return };\n \n         if pat.span.desugaring_kind().is_some() {\n             return;"}, {"sha": "e94c73df0765881146131e6728910aad288bc372", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -6,11 +6,7 @@ use rustc_span::DUMMY_SP;\n \n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n-pub(super) fn is_layout_incompatible<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    from: Ty<'tcx>,\n-    to: Ty<'tcx>,\n-) -> bool {\n+pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n     if let Ok(from) = cx.tcx.try_normalize_erasing_regions(cx.param_env, from)\n         && let Ok(to) = cx.tcx.try_normalize_erasing_regions(cx.param_env, to)\n         && let Ok(from_layout) = cx.tcx.layout_of(cx.param_env.and(from))\n@@ -33,9 +29,7 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n     from_ty: Ty<'tcx>,\n     to_ty: Ty<'tcx>,\n ) -> bool {\n-    use CastKind::{\n-        AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast,\n-    };\n+    use CastKind::{AddrPtrCast, ArrayPtrCast, FnPtrAddrCast, FnPtrPtrCast, PtrAddrCast, PtrPtrCast};\n     matches!(\n         check_cast(cx, e, from_ty, to_ty),\n         Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n@@ -46,20 +40,18 @@ pub(super) fn can_be_expressed_as_pointer_cast<'tcx>(\n /// the cast. In certain cases, including some invalid casts from array references\n /// to pointers, this may cause additional errors to be emitted and/or ICE error\n /// messages. This function will panic if that occurs.\n-fn check_cast<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    e: &'tcx Expr<'_>,\n-    from_ty: Ty<'tcx>,\n-    to_ty: Ty<'tcx>,\n-) -> Option<CastKind> {\n+fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner.def_id;\n \n     Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n+        let fn_ctxt = FnCtxt::new(inherited, cx.param_env, hir_id);\n \n         // If we already have errors, we can't be sure we can pointer cast.\n-        assert!(!fn_ctxt.errors_reported_since_creation(), \"Newly created FnCtxt contained errors\");\n+        assert!(\n+            !fn_ctxt.errors_reported_since_creation(),\n+            \"Newly created FnCtxt contained errors\"\n+        );\n \n         if let Ok(check) = cast::CastCheck::new(\n             &fn_ctxt, e, from_ty, to_ty,"}, {"sha": "fa567b9b2d243661efa259217572da6005efcc9d", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -9,6 +9,7 @@ use rustc_span::symbol::sym;\n use super::RC_BUFFER;\n \n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    let app = Applicability::Unspecified;\n     if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n         if let Some(alternate) = match_buffer_type(cx, qpath) {\n             span_lint_and_sugg(\n@@ -18,23 +19,20 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 \"usage of `Rc<T>` when T is a buffer type\",\n                 \"try\",\n                 format!(\"Rc<{alternate}>\"),\n-                Applicability::MachineApplicable,\n+                app,\n             );\n         } else {\n             let Some(ty) = qpath_generic_tys(qpath).next() else { return false };\n             let Some(id) = path_def_id(cx, ty) else { return false };\n             if !cx.tcx.is_diagnostic_item(sym::Vec, id) {\n                 return false;\n             }\n-            let qpath = match &ty.kind {\n-                TyKind::Path(qpath) => qpath,\n-                _ => return false,\n-            };\n+            let TyKind::Path(qpath) = &ty.kind else { return false };\n             let inner_span = match qpath_generic_tys(qpath).next() {\n                 Some(ty) => ty.span,\n                 None => return false,\n             };\n-            let mut applicability = Applicability::MachineApplicable;\n+            let mut applicability = app;\n             span_lint_and_sugg(\n                 cx,\n                 RC_BUFFER,\n@@ -45,7 +43,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                     \"Rc<[{}]>\",\n                     snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n                 ),\n-                Applicability::MachineApplicable,\n+                app,\n             );\n             return true;\n         }\n@@ -58,22 +56,19 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                 \"usage of `Arc<T>` when T is a buffer type\",\n                 \"try\",\n                 format!(\"Arc<{alternate}>\"),\n-                Applicability::MachineApplicable,\n+                app,\n             );\n         } else if let Some(ty) = qpath_generic_tys(qpath).next() {\n             let Some(id) = path_def_id(cx, ty) else { return false };\n             if !cx.tcx.is_diagnostic_item(sym::Vec, id) {\n                 return false;\n             }\n-            let qpath = match &ty.kind {\n-                TyKind::Path(qpath) => qpath,\n-                _ => return false,\n-            };\n+            let TyKind::Path(qpath) = &ty.kind else { return false };\n             let inner_span = match qpath_generic_tys(qpath).next() {\n                 Some(ty) => ty.span,\n                 None => return false,\n             };\n-            let mut applicability = Applicability::MachineApplicable;\n+            let mut applicability = app;\n             span_lint_and_sugg(\n                 cx,\n                 RC_BUFFER,\n@@ -84,7 +79,7 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n                     \"Arc<[{}]>\",\n                     snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n                 ),\n-                Applicability::MachineApplicable,\n+                app,\n             );\n             return true;\n         }"}, {"sha": "7883353e3fef61ba137464222f5fb621d719db14", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -10,6 +10,7 @@ use rustc_span::symbol::sym;\n use super::{utils, REDUNDANT_ALLOCATION};\n \n pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    let mut applicability = Applicability::MaybeIncorrect;\n     let outer_sym = if Some(def_id) == cx.tcx.lang_items().owned_box() {\n         \"Box\"\n     } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n@@ -21,7 +22,6 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n     };\n \n     if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n-        let mut applicability = Applicability::MaybeIncorrect;\n         let generic_snippet = snippet_with_applicability(cx, span, \"..\", &mut applicability);\n         span_lint_and_then(\n             cx,\n@@ -47,9 +47,8 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         _ => return false,\n     };\n \n-    let inner_qpath = match &ty.kind {\n-        TyKind::Path(inner_qpath) => inner_qpath,\n-        _ => return false,\n+    let TyKind::Path(inner_qpath) = &ty.kind else {\n+        return false\n     };\n     let inner_span = match qpath_generic_tys(inner_qpath).next() {\n         Some(ty) => {\n@@ -64,7 +63,6 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n         None => return false,\n     };\n     if inner_sym == outer_sym {\n-        let mut applicability = Applicability::MaybeIncorrect;\n         let generic_snippet = snippet_with_applicability(cx, inner_span, \"..\", &mut applicability);\n         span_lint_and_then(\n             cx,"}, {"sha": "1307288623f95f3d99e85f572fcc9df379c7856a", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,13 +1,12 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::{get_trait_def_id, paths};\n use if_chain::if_chain;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{Closure, Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_middle::ty::{GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{sym, BytePos, Span};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -80,7 +79,7 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n         let fn_sig = cx.tcx.fn_sig(def_id);\n         let generics = cx.tcx.predicates_of(def_id);\n         let fn_mut_preds = get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().fn_mut_trait());\n-        let ord_preds = get_trait_predicates_for_trait_id(cx, generics, get_trait_def_id(cx, &paths::ORD));\n+        let ord_preds = get_trait_predicates_for_trait_id(cx, generics, cx.tcx.get_diagnostic_item(sym::Ord));\n         let partial_ord_preds =\n             get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().partial_ord_trait());\n         // Trying to call erase_late_bound_regions on fn_sig.inputs() gives the following error\n@@ -99,11 +98,15 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n                         if trait_pred.self_ty() == inp;\n                         if let Some(return_ty_pred) = get_projection_pred(cx, generics, *trait_pred);\n                         then {\n-                            if ord_preds.iter().any(|ord| Some(ord.self_ty()) == return_ty_pred.term.ty()) {\n+                            if ord_preds\n+                                .iter()\n+                                .any(|ord| Some(ord.self_ty()) == return_ty_pred.term.ty())\n+                            {\n                                 args_to_check.push((i, \"Ord\".to_string()));\n-                            } else if partial_ord_preds.iter().any(|pord| {\n-                                pord.self_ty() == return_ty_pred.term.ty().unwrap()\n-                            }) {\n+                            } else if partial_ord_preds\n+                                .iter()\n+                                .any(|pord| pord.self_ty() == return_ty_pred.term.ty().unwrap())\n+                            {\n                                 args_to_check.push((i, \"PartialOrd\".to_string()));\n                             }\n                         }"}, {"sha": "b305dae76084c3e698263f59701c83698ca470db", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -163,9 +163,8 @@ fn unnest_or_patterns(pat: &mut P<Pat>) -> bool {\n             noop_visit_pat(p, self);\n \n             // Don't have an or-pattern? Just quit early on.\n-            let alternatives = match &mut p.kind {\n-                Or(ps) => ps,\n-                _ => return,\n+            let Or(alternatives) = &mut p.kind else {\n+                return\n             };\n \n             // Collapse or-patterns directly nested in or-patterns."}, {"sha": "92053cec59fc8da8254403fadbbae6099812d4b2", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -47,9 +47,8 @@ declare_lint_pass!(UnusedIoAmount => [UNUSED_IO_AMOUNT]);\n \n impl<'tcx> LateLintPass<'tcx> for UnusedIoAmount {\n     fn check_stmt(&mut self, cx: &LateContext<'_>, s: &hir::Stmt<'_>) {\n-        let expr = match s.kind {\n-            hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n-            _ => return,\n+        let (hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr)) = s.kind else {\n+            return\n         };\n \n         match expr.kind {"}, {"sha": "1f69db1cbca40e4145a26752a8294557684e5b14", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -55,9 +55,8 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n \n         match e.kind {\n             ExprKind::Match(_, arms, MatchSource::TryDesugar) => {\n-                let e = match arms[0].body.kind {\n-                    ExprKind::Ret(Some(e)) | ExprKind::Break(_, Some(e)) => e,\n-                    _ => return,\n+                let (ExprKind::Ret(Some(e)) | ExprKind::Break(_, Some(e))) = arms[0].body.kind else {\n+                     return\n                 };\n                 if let ExprKind::Call(_, [arg, ..]) = e.kind {\n                     self.try_desugar_arm.push(arg.hir_id);"}, {"sha": "0c052d86eda409dc1eb4fa3103f8e6b4ea4fdbae", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::{Ident, Symbol};\n+use std::cell::Cell;\n use std::fmt::{Display, Formatter, Write as _};\n \n declare_clippy_lint! {\n@@ -37,15 +38,13 @@ declare_clippy_lint! {\n     ///\n     /// ```rust,ignore\n     /// // ./tests/ui/new_lint.stdout\n-    /// if_chain! {\n-    ///     if let ExprKind::If(ref cond, ref then, None) = item.kind,\n-    ///     if let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.kind,\n-    ///     if let ExprKind::Path(ref path) = left.kind,\n-    ///     if let ExprKind::Lit(ref lit) = right.kind,\n-    ///     if let LitKind::Int(42, _) = lit.node,\n-    ///     then {\n-    ///         // report your lint here\n-    ///     }\n+    /// if ExprKind::If(ref cond, ref then, None) = item.kind\n+    ///     && let ExprKind::Binary(BinOp::Eq, ref left, ref right) = cond.kind\n+    ///     && let ExprKind::Path(ref path) = left.kind\n+    ///     && let ExprKind::Lit(ref lit) = right.kind\n+    ///     && let LitKind::Int(42, _) = lit.node\n+    /// {\n+    ///     // report your lint here\n     /// }\n     /// ```\n     pub LINT_AUTHOR,\n@@ -91,15 +90,16 @@ macro_rules! field {\n     };\n }\n \n-fn prelude() {\n-    println!(\"if_chain! {{\");\n-}\n-\n-fn done() {\n-    println!(\"    then {{\");\n-    println!(\"        // report your lint here\");\n-    println!(\"    }}\");\n-    println!(\"}}\");\n+/// Print a condition of a let chain, `chain!(self, \"let Some(x) = y\")` will print\n+/// `if let Some(x) = y` on the first call and `    && let Some(x) = y` thereafter\n+macro_rules! chain {\n+    ($self:ident, $($t:tt)*) => {\n+        if $self.first.take() {\n+            println!(\"if {}\", format_args!($($t)*));\n+        } else {\n+            println!(\"    && {}\", format_args!($($t)*));\n+        }\n+    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for Author {\n@@ -149,9 +149,10 @@ fn check_item(cx: &LateContext<'_>, hir_id: HirId) {\n \n fn check_node(cx: &LateContext<'_>, hir_id: HirId, f: impl Fn(&PrintVisitor<'_, '_>)) {\n     if has_attr(cx, hir_id) {\n-        prelude();\n         f(&PrintVisitor::new(cx));\n-        done();\n+        println!(\"{{\");\n+        println!(\"    // report your lint here\");\n+        println!(\"}}\");\n     }\n }\n \n@@ -195,15 +196,18 @@ struct PrintVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     /// Fields are the current index that needs to be appended to pattern\n     /// binding names\n-    ids: std::cell::Cell<FxHashMap<&'static str, u32>>,\n+    ids: Cell<FxHashMap<&'static str, u32>>,\n+    /// Currently at the first condition in the if chain\n+    first: Cell<bool>,\n }\n \n #[allow(clippy::unused_self)]\n impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            ids: std::cell::Cell::default(),\n+            ids: Cell::default(),\n+            first: Cell::new(true),\n         }\n     }\n \n@@ -226,20 +230,20 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n     fn option<T: Copy>(&self, option: &Binding<Option<T>>, name: &'static str, f: impl Fn(&Binding<T>)) {\n         match option.value {\n-            None => out!(\"if {option}.is_none();\"),\n+            None => chain!(self, \"{option}.is_none()\"),\n             Some(value) => {\n                 let value = &self.bind(name, value);\n-                out!(\"if let Some({value}) = {option};\");\n+                chain!(self, \"let Some({value}) = {option}\");\n                 f(value);\n             },\n         }\n     }\n \n     fn slice<T>(&self, slice: &Binding<&[T]>, f: impl Fn(&Binding<&T>)) {\n         if slice.value.is_empty() {\n-            out!(\"if {slice}.is_empty();\");\n+            chain!(self, \"{slice}.is_empty()\");\n         } else {\n-            out!(\"if {slice}.len() == {};\", slice.value.len());\n+            chain!(self, \"{slice}.len() == {}\", slice.value.len());\n             for (i, value) in slice.value.iter().enumerate() {\n                 let name = format!(\"{slice}[{i}]\");\n                 f(&Binding { name, value });\n@@ -254,23 +258,23 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     }\n \n     fn ident(&self, ident: &Binding<Ident>) {\n-        out!(\"if {ident}.as_str() == {:?};\", ident.value.as_str());\n+        chain!(self, \"{ident}.as_str() == {:?}\", ident.value.as_str());\n     }\n \n     fn symbol(&self, symbol: &Binding<Symbol>) {\n-        out!(\"if {symbol}.as_str() == {:?};\", symbol.value.as_str());\n+        chain!(self, \"{symbol}.as_str() == {:?}\", symbol.value.as_str());\n     }\n \n     fn qpath(&self, qpath: &Binding<&QPath<'_>>) {\n         if let QPath::LangItem(lang_item, ..) = *qpath.value {\n-            out!(\"if matches!({qpath}, QPath::LangItem(LangItem::{lang_item:?}, _));\");\n+            chain!(self, \"matches!({qpath}, QPath::LangItem(LangItem::{lang_item:?}, _))\");\n         } else {\n-            out!(\"if match_qpath({qpath}, &[{}]);\", path_to_string(qpath.value));\n+            chain!(self, \"match_qpath({qpath}, &[{}])\", path_to_string(qpath.value));\n         }\n     }\n \n     fn lit(&self, lit: &Binding<&Lit>) {\n-        let kind = |kind| out!(\"if let LitKind::{kind} = {lit}.node;\");\n+        let kind = |kind| chain!(self, \"let LitKind::{kind} = {lit}.node\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }\n@@ -298,7 +302,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             LitKind::ByteStr(ref vec) => {\n                 bind!(self, vec);\n                 kind!(\"ByteStr(ref {vec})\");\n-                out!(\"if let [{:?}] = **{vec};\", vec.value);\n+                chain!(self, \"let [{:?}] = **{vec}\", vec.value);\n             },\n             LitKind::Str(s, _) => {\n                 bind!(self, s);\n@@ -311,15 +315,15 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn arm(&self, arm: &Binding<&hir::Arm<'_>>) {\n         self.pat(field!(arm.pat));\n         match arm.value.guard {\n-            None => out!(\"if {arm}.guard.is_none();\"),\n+            None => chain!(self, \"{arm}.guard.is_none()\"),\n             Some(hir::Guard::If(expr)) => {\n                 bind!(self, expr);\n-                out!(\"if let Some(Guard::If({expr})) = {arm}.guard;\");\n+                chain!(self, \"let Some(Guard::If({expr})) = {arm}.guard\");\n                 self.expr(expr);\n             },\n             Some(hir::Guard::IfLet(let_expr)) => {\n                 bind!(self, let_expr);\n-                out!(\"if let Some(Guard::IfLet({let_expr}) = {arm}.guard;\");\n+                chain!(self, \"let Some(Guard::IfLet({let_expr}) = {arm}.guard\");\n                 self.pat(field!(let_expr.pat));\n                 self.expr(field!(let_expr.init));\n             },\n@@ -331,9 +335,10 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n         if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n             bind!(self, condition, body);\n-            out!(\n-                \"if let Some(higher::While {{ condition: {condition}, body: {body} }}) \\\n-                = higher::While::hir({expr});\"\n+            chain!(\n+                self,\n+                \"let Some(higher::While {{ condition: {condition}, body: {body} }}) \\\n+                = higher::While::hir({expr})\"\n             );\n             self.expr(condition);\n             self.expr(body);\n@@ -347,9 +352,10 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n         }) = higher::WhileLet::hir(expr.value)\n         {\n             bind!(self, let_pat, let_expr, if_then);\n-            out!(\n-                \"if let Some(higher::WhileLet {{ let_pat: {let_pat}, let_expr: {let_expr}, if_then: {if_then} }}) \\\n-                = higher::WhileLet::hir({expr});\"\n+            chain!(\n+                self,\n+                \"let Some(higher::WhileLet {{ let_pat: {let_pat}, let_expr: {let_expr}, if_then: {if_then} }}) \\\n+                = higher::WhileLet::hir({expr})\"\n             );\n             self.pat(let_pat);\n             self.expr(let_expr);\n@@ -359,17 +365,18 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n         if let Some(higher::ForLoop { pat, arg, body, .. }) = higher::ForLoop::hir(expr.value) {\n             bind!(self, pat, arg, body);\n-            out!(\n-                \"if let Some(higher::ForLoop {{ pat: {pat}, arg: {arg}, body: {body}, .. }}) \\\n-                = higher::ForLoop::hir({expr});\"\n+            chain!(\n+                self,\n+                \"let Some(higher::ForLoop {{ pat: {pat}, arg: {arg}, body: {body}, .. }}) \\\n+                = higher::ForLoop::hir({expr})\"\n             );\n             self.pat(pat);\n             self.expr(arg);\n             self.expr(body);\n             return;\n         }\n \n-        let kind = |kind| out!(\"if let ExprKind::{kind} = {expr}.kind;\");\n+        let kind = |kind| chain!(self, \"let ExprKind::{kind} = {expr}.kind\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }\n@@ -383,7 +390,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 // if it's a path\n                 if let Some(TyKind::Path(ref qpath)) = let_expr.value.ty.as_ref().map(|ty| &ty.kind) {\n                     bind!(self, qpath);\n-                    out!(\"if let TyKind::Path(ref {qpath}) = {let_expr}.ty.kind;\");\n+                    chain!(self, \"let TyKind::Path(ref {qpath}) = {let_expr}.ty.kind\");\n                     self.qpath(qpath);\n                 }\n                 self.expr(field!(let_expr.init));\n@@ -419,7 +426,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             ExprKind::Binary(op, left, right) => {\n                 bind!(self, op, left, right);\n                 kind!(\"Binary({op}, {left}, {right})\");\n-                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                chain!(self, \"BinOpKind::{:?} == {op}.node\", op.value.node);\n                 self.expr(left);\n                 self.expr(right);\n             },\n@@ -438,7 +445,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"Cast({expr}, {cast_ty})\");\n                 if let TyKind::Path(ref qpath) = cast_ty.value.kind {\n                     bind!(self, qpath);\n-                    out!(\"if let TyKind::Path(ref {qpath}) = {cast_ty}.kind;\");\n+                    chain!(self, \"let TyKind::Path(ref {qpath}) = {cast_ty}.kind\");\n                     self.qpath(qpath);\n                 }\n                 self.expr(expr);\n@@ -485,7 +492,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n                 bind!(self, fn_decl, body_id);\n                 kind!(\"Closure(CaptureBy::{capture_clause:?}, {fn_decl}, {body_id}, _, {movability})\");\n-                out!(\"if let {ret_ty} = {fn_decl}.output;\");\n+                chain!(self, \"let {ret_ty} = {fn_decl}.output\");\n                 self.body(body_id);\n             },\n             ExprKind::Yield(sub, source) => {\n@@ -509,7 +516,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n             ExprKind::AssignOp(op, target, value) => {\n                 bind!(self, op, target, value);\n                 kind!(\"AssignOp({op}, {target}, {value})\");\n-                out!(\"if BinOpKind::{:?} == {op}.node;\", op.value.node);\n+                chain!(self, \"BinOpKind::{:?} == {op}.node\", op.value.node);\n                 self.expr(target);\n                 self.expr(value);\n             },\n@@ -573,10 +580,10 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n                 kind!(\"Repeat({value}, {length})\");\n                 self.expr(value);\n                 match length.value {\n-                    ArrayLen::Infer(..) => out!(\"if let ArrayLen::Infer(..) = length;\"),\n+                    ArrayLen::Infer(..) => chain!(self, \"let ArrayLen::Infer(..) = length\"),\n                     ArrayLen::Body(anon_const) => {\n                         bind!(self, anon_const);\n-                        out!(\"if let ArrayLen::Body({anon_const}) = {length};\");\n+                        chain!(self, \"let ArrayLen::Body({anon_const}) = {length}\");\n                         self.body(field!(anon_const.body));\n                     },\n                 }\n@@ -600,12 +607,12 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     fn body(&self, body_id: &Binding<hir::BodyId>) {\n         let expr = self.cx.tcx.hir().body(body_id.value).value;\n         bind!(self, expr);\n-        out!(\"let {expr} = &cx.tcx.hir().body({body_id}).value;\");\n+        chain!(self, \"{expr} = &cx.tcx.hir().body({body_id}).value\");\n         self.expr(expr);\n     }\n \n     fn pat(&self, pat: &Binding<&hir::Pat<'_>>) {\n-        let kind = |kind| out!(\"if let PatKind::{kind} = {pat}.kind;\");\n+        let kind = |kind| chain!(self, \"let PatKind::{kind} = {pat}.kind\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }\n@@ -688,7 +695,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n     }\n \n     fn stmt(&self, stmt: &Binding<&hir::Stmt<'_>>) {\n-        let kind = |kind| out!(\"if let StmtKind::{kind} = {stmt}.kind;\");\n+        let kind = |kind| chain!(self, \"let StmtKind::{kind} = {stmt}.kind\");\n         macro_rules! kind {\n             ($($t:tt)*) => (kind(format_args!($($t)*)));\n         }"}, {"sha": "71f6c9909ddda5881d6d9e5f181e20154516e879", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 11, "deletions": 1565, "changes": 1576, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,1566 +1,12 @@\n-use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n-use clippy_utils::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::{snippet, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n-    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n-};\n-use if_chain::if_chain;\n-use rustc_ast as ast;\n-use rustc_ast::ast::{Crate, ItemKind, LitKind, ModKind, NodeId};\n-use rustc_ast::visit::FnKind;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_hir::def::{DefKind, Namespace, Res};\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::hir_id::CRATE_HIR_ID;\n-use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n-    TyKind, UnOp,\n-};\n-use rustc_hir_analysis::hir_ty_to_ty;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n-use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n-use rustc_middle::ty::{\n-    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n-};\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{sym, BytePos, Span};\n-\n-use std::borrow::{Borrow, Cow};\n-use std::str;\n-\n-#[cfg(feature = \"internal\")]\n+pub mod clippy_lints_internal;\n+pub mod collapsible_calls;\n+pub mod compiler_lint_functions;\n+pub mod if_chain_style;\n+pub mod interning_defined_symbol;\n+pub mod invalid_paths;\n+pub mod lint_without_lint_pass;\n pub mod metadata_collector;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for various things we like to keep tidy in clippy.\n-    ///\n-    /// ### Why is this bad?\n-    /// We like to pretend we're an example of tidy code.\n-    ///\n-    /// ### Example\n-    /// Wrong ordering of the util::paths constants.\n-    pub CLIPPY_LINTS_INTERNAL,\n-    internal,\n-    \"various things that will negatively affect your clippy experience\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Ensures every lint is associated to a `LintPass`.\n-    ///\n-    /// ### Why is this bad?\n-    /// The compiler only knows lints via a `LintPass`. Without\n-    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n-    /// know the name of the lint.\n-    ///\n-    /// ### Known problems\n-    /// Only checks for lints associated using the\n-    /// `declare_lint_pass!`, `impl_lint_pass!`, and `lint_array!` macros.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_lint! { pub LINT_1, ... }\n-    /// declare_lint! { pub LINT_2, ... }\n-    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n-    /// // ...\n-    /// declare_lint_pass!(Pass => [LINT_1, LINT_2]);\n-    /// // missing FORGOTTEN_LINT\n-    /// ```\n-    pub LINT_WITHOUT_LINT_PASS,\n-    internal,\n-    \"declaring a lint without associating it in a LintPass\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n-    /// variant of the function.\n-    ///\n-    /// ### Why is this bad?\n-    /// The `utils::*` variants also add a link to the Clippy documentation to the\n-    /// warning/error messages.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// cx.span_lint(LINT_NAME, \"message\");\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// utils::span_lint(cx, LINT_NAME, \"message\");\n-    /// ```\n-    pub COMPILER_LINT_FUNCTIONS,\n-    internal,\n-    \"usage of the lint functions of the compiler instead of the utils::* variant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for calls to `cx.outer().expn_data()` and suggests to use\n-    /// the `cx.outer_expn_data()`\n-    ///\n-    /// ### Why is this bad?\n-    /// `cx.outer_expn_data()` is faster and more concise.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// expr.span.ctxt().outer().expn_data()\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// expr.span.ctxt().outer_expn_data()\n-    /// ```\n-    pub OUTER_EXPN_EXPN_DATA,\n-    internal,\n-    \"using `cx.outer_expn().expn_data()` instead of `cx.outer_expn_data()`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Not an actual lint. This lint is only meant for testing our customized internal compiler\n-    /// error message by calling `panic`.\n-    ///\n-    /// ### Why is this bad?\n-    /// ICE in large quantities can damage your teeth\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// \ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\n-    /// ```\n-    pub PRODUCE_ICE,\n-    internal,\n-    \"this message should not appear anywhere as we ICE before and don't emit the lint\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for cases of an auto-generated lint without an updated description,\n-    /// i.e. `default lint description`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Indicates that the lint is not finished.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_lint! { pub COOL_LINT, nursery, \"default lint description\" }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// declare_lint! { pub COOL_LINT, nursery, \"a great new lint\" }\n-    /// ```\n-    pub DEFAULT_LINT,\n-    internal,\n-    \"found 'default lint description' in a lint declaration\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Lints `span_lint_and_then` function calls, where the\n-    /// closure argument has only one statement and that statement is a method\n-    /// call to `span_suggestion`, `span_help`, `span_note` (using the same\n-    /// span), `help` or `note`.\n-    ///\n-    /// These usages of `span_lint_and_then` should be replaced with one of the\n-    /// wrapper functions `span_lint_and_sugg`, span_lint_and_help`, or\n-    /// `span_lint_and_note`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Using the wrapper `span_lint_and_*` functions, is more\n-    /// convenient, readable and less error prone.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_suggestion(\n-    ///         expr.span,\n-    ///         help_msg,\n-    ///         sugg.to_string(),\n-    ///         Applicability::MachineApplicable,\n-    ///     );\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_help(expr.span, help_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.help(help_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.span_note(expr.span, note_msg);\n-    /// });\n-    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n-    ///     diag.note(note_msg);\n-    /// });\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// span_lint_and_sugg(\n-    ///     cx,\n-    ///     TEST_LINT,\n-    ///     expr.span,\n-    ///     lint_msg,\n-    ///     help_msg,\n-    ///     sugg.to_string(),\n-    ///     Applicability::MachineApplicable,\n-    /// );\n-    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg);\n-    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg);\n-    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg);\n-    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, None, note_msg);\n-    /// ```\n-    pub COLLAPSIBLE_SPAN_LINT_CALLS,\n-    internal,\n-    \"found collapsible `span_lint_and_then` calls\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n-    ///\n-    /// ### Why is this bad?\n-    /// The path for an item is subject to change and is less efficient to look up than a\n-    /// diagnostic item or a `LangItem`.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// utils::match_type(cx, ty, &paths::VEC)\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n-    /// ```\n-    pub UNNECESSARY_DEF_PATH,\n-    internal,\n-    \"using a def path when a diagnostic item or a `LangItem` is available\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks the paths module for invalid paths.\n-    ///\n-    /// ### Why is this bad?\n-    /// It indicates a bug in the code.\n-    ///\n-    /// ### Example\n-    /// None.\n-    pub INVALID_PATHS,\n-    internal,\n-    \"invalid path\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's faster and easier to use the symbol constant.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// let _ = sym!(f32);\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// let _ = sym::f32;\n-    /// ```\n-    pub INTERNING_DEFINED_SYMBOL,\n-    internal,\n-    \"interning a symbol that is pre-interned and defined as a constant\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for unnecessary conversion from Symbol to a string.\n-    ///\n-    /// ### Why is this bad?\n-    /// It's faster use symbols directly instead of strings.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// symbol.as_str() == \"clippy\";\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// symbol == sym::clippy;\n-    /// ```\n-    pub UNNECESSARY_SYMBOL_STR,\n-    internal,\n-    \"unnecessary conversion between Symbol and string\"\n-}\n-\n-declare_clippy_lint! {\n-    /// Finds unidiomatic usage of `if_chain!`\n-    pub IF_CHAIN_STYLE,\n-    internal,\n-    \"non-idiomatic `if_chain!` usage\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for invalid `clippy::version` attributes.\n-    ///\n-    /// Valid values are:\n-    /// * \"pre 1.29.0\"\n-    /// * any valid semantic version\n-    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-    internal,\n-    \"found an invalid `clippy::version` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for declared clippy lints without the `clippy::version` attribute.\n-    ///\n-    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-    internal,\n-    \"found clippy lint without `clippy::version` attribute\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n-    ///\n-    pub MISSING_MSRV_ATTR_IMPL,\n-    internal,\n-    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n-}\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n-    /// i.e. `\"default deprecation note\"`.\n-    ///\n-    /// ### Why is this bad?\n-    /// Indicates that the documentation is incomplete.\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// declare_deprecated_lint! {\n-    ///     /// ### What it does\n-    ///     /// Nothing. This lint has been deprecated.\n-    ///     ///\n-    ///     /// ### Deprecation reason\n-    ///     /// TODO\n-    ///     #[clippy::version = \"1.63.0\"]\n-    ///     pub COOL_LINT,\n-    ///     \"default deprecation note\"\n-    /// }\n-    /// ```\n-    ///\n-    /// Use instead:\n-    /// ```rust,ignore\n-    /// declare_deprecated_lint! {\n-    ///     /// ### What it does\n-    ///     /// Nothing. This lint has been deprecated.\n-    ///     ///\n-    ///     /// ### Deprecation reason\n-    ///     /// This lint has been replaced by `cooler_lint`\n-    ///     #[clippy::version = \"1.63.0\"]\n-    ///     pub COOL_LINT,\n-    ///     \"this lint has been replaced by `cooler_lint`\"\n-    /// }\n-    /// ```\n-    pub DEFAULT_DEPRECATION_REASON,\n-    internal,\n-    \"found 'default deprecation note' in a deprecated lint declaration\"\n-}\n-\n-declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n-\n-impl EarlyLintPass for ClippyLintsInternal {\n-    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n-        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n-            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n-                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n-                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n-                        let mut last_name: Option<&str> = None;\n-                        for item in items {\n-                            let name = item.ident.as_str();\n-                            if let Some(last_name) = last_name {\n-                                if *last_name > *name {\n-                                    span_lint(\n-                                        cx,\n-                                        CLIPPY_LINTS_INTERNAL,\n-                                        item.span,\n-                                        \"this constant should be before the previous constant due to lexical \\\n-                                         ordering\",\n-                                    );\n-                                }\n-                            }\n-                            last_name = Some(name);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, Default)]\n-pub struct LintWithoutLintPass {\n-    declared_lints: FxHashMap<Symbol, Span>,\n-    registered_lints: FxHashSet<Symbol>,\n-}\n-\n-impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n-\n-impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n-            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n-        {\n-            return;\n-        }\n-\n-        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n-            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n-            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n-                check_invalid_clippy_version_attribute(cx, item);\n-\n-                let expr = &cx.tcx.hir().body(body_id).value;\n-                let fields;\n-                if is_lint_ref_ty {\n-                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n-                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n-                            fields = struct_fields;\n-                    } else {\n-                        return;\n-                    }\n-                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n-                    fields = struct_fields;\n-                } else {\n-                    return;\n-                }\n-\n-                let field = fields\n-                    .iter()\n-                    .find(|f| f.ident.as_str() == \"desc\")\n-                    .expect(\"lints must have a description field\");\n-\n-                if let ExprKind::Lit(Spanned {\n-                    node: LitKind::Str(ref sym, _),\n-                    ..\n-                }) = field.expr.kind\n-                {\n-                    let sym_str = sym.as_str();\n-                    if is_lint_ref_ty {\n-                        if sym_str == \"default lint description\" {\n-                            span_lint(\n-                                cx,\n-                                DEFAULT_LINT,\n-                                item.span,\n-                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n-                            );\n-                        }\n-\n-                        self.declared_lints.insert(item.ident.name, item.span);\n-                    } else if sym_str == \"default deprecation note\" {\n-                        span_lint(\n-                            cx,\n-                            DEFAULT_DEPRECATION_REASON,\n-                            item.span,\n-                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n-                        );\n-                    }\n-                }\n-            }\n-        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n-            if !matches!(\n-                cx.tcx.item_name(macro_call.def_id).as_str(),\n-                \"impl_lint_pass\" | \"declare_lint_pass\"\n-            ) {\n-                return;\n-            }\n-            if let hir::ItemKind::Impl(hir::Impl {\n-                of_trait: None,\n-                items: impl_item_refs,\n-                ..\n-            }) = item.kind\n-            {\n-                let mut collector = LintCollector {\n-                    output: &mut self.registered_lints,\n-                    cx,\n-                };\n-                let body_id = cx.tcx.hir().body_owned_by(\n-                    cx.tcx.hir().local_def_id(\n-                        impl_item_refs\n-                            .iter()\n-                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n-                            .expect(\"LintPass needs to implement get_lints\")\n-                            .id\n-                            .hir_id(),\n-                    ),\n-                );\n-                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n-            }\n-        }\n-    }\n-\n-    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n-        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n-            return;\n-        }\n-\n-        for (lint_name, &lint_span) in &self.declared_lints {\n-            // When using the `declare_tool_lint!` macro, the original `lint_span`'s\n-            // file points to \"<rustc macros>\".\n-            // `compiletest-rs` thinks that's an error in a different file and\n-            // just ignores it. This causes the test in compile-fail/lint_pass\n-            // not able to capture the error.\n-            // Therefore, we need to climb the macro expansion tree and find the\n-            // actual span that invoked `declare_tool_lint!`:\n-            let lint_span = lint_span.ctxt().outer_expn_data().call_site;\n-\n-            if !self.registered_lints.contains(lint_name) {\n-                span_lint(\n-                    cx,\n-                    LINT_WITHOUT_LINT_PASS,\n-                    lint_span,\n-                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n-    if let TyKind::Rptr(\n-        _,\n-        MutTy {\n-            ty: inner,\n-            mutbl: Mutability::Not,\n-        },\n-    ) = ty.kind\n-    {\n-        if let TyKind::Path(ref path) = inner.kind {\n-            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n-                return match_def_path(cx, def_id, &paths::LINT);\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n-    if let Some(value) = extract_clippy_version_value(cx, item) {\n-        // The `sym!` macro doesn't work as it only expects a single token.\n-        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n-        if value == Symbol::intern(\"pre 1.29.0\") {\n-            return;\n-        }\n-\n-        if RustcVersion::parse(value.as_str()).is_err() {\n-            span_lint_and_help(\n-                cx,\n-                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n-                item.span,\n-                \"this item has an invalid `clippy::version` attribute\",\n-                None,\n-                \"please use a valid semantic version, see `doc/adding_lints.md`\",\n-            );\n-        }\n-    } else {\n-        span_lint_and_help(\n-            cx,\n-            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n-            item.span,\n-            \"this lint is missing the `clippy::version` attribute or version value\",\n-            None,\n-            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n-        );\n-    }\n-}\n-\n-/// This function extracts the version value of a `clippy::version` attribute if the given value has\n-/// one\n-fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n-    let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    attrs.iter().find_map(|attr| {\n-        if_chain! {\n-            // Identify attribute\n-            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n-            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n-            if tool_name.ident.name == sym::clippy;\n-            if attr_name.ident.name == sym::version;\n-            if let Some(version) = attr.value_str();\n-            then {\n-                Some(version)\n-            } else {\n-                None\n-            }\n-        }\n-    })\n-}\n-\n-struct LintCollector<'a, 'tcx> {\n-    output: &'a mut FxHashSet<Symbol>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn visit_path(&mut self, path: &'tcx Path<'_>, _: HirId) {\n-        if path.segments.len() == 1 {\n-            self.output.insert(path.segments[0].ident.name);\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.cx.tcx.hir()\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct CompilerLintFunctions {\n-    map: FxHashMap<&'static str, &'static str>,\n-}\n-\n-impl CompilerLintFunctions {\n-    #[must_use]\n-    pub fn new() -> Self {\n-        let mut map = FxHashMap::default();\n-        map.insert(\"span_lint\", \"utils::span_lint\");\n-        map.insert(\"struct_span_lint\", \"utils::span_lint\");\n-        map.insert(\"lint\", \"utils::span_lint\");\n-        map.insert(\"span_lint_note\", \"utils::span_lint_and_note\");\n-        map.insert(\"span_lint_help\", \"utils::span_lint_and_help\");\n-        Self { map }\n-    }\n-}\n-\n-impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n-            let fn_name = path.ident;\n-            if let Some(sugg) = self.map.get(fn_name.as_str());\n-            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if match_type(cx, ty, &paths::EARLY_CONTEXT)\n-                || match_type(cx, ty, &paths::LATE_CONTEXT);\n-            then {\n-                span_lint_and_help(\n-                    cx,\n-                    COMPILER_LINT_FUNCTIONS,\n-                    path.ident.span,\n-                    \"usage of a compiler lint function\",\n-                    None,\n-                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n-            return;\n-        }\n-\n-        let (method_names, arg_lists, spans) = method_calls(expr, 2);\n-        let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n-        if_chain! {\n-            if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n-            let (self_arg, args)= arg_lists[1];\n-            if args.is_empty();\n-            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n-            if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    OUTER_EXPN_EXPN_DATA,\n-                    spans[1].with_hi(expr.span.hi()),\n-                    \"usage of `outer_expn().expn_data()`\",\n-                    \"try\",\n-                    \"outer_expn_data()\".to_string(),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n-\n-impl EarlyLintPass for ProduceIce {\n-    fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n-        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n-    }\n-}\n-\n-fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n-    match fn_kind {\n-        FnKind::Fn(_, ident, ..) => ident.name.as_str() == \"it_looks_like_you_are_trying_to_kill_clippy\",\n-        FnKind::Closure(..) => false,\n-    }\n-}\n-\n-declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, and_then_args) = expr.kind;\n-            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n-            if and_then_args.len() == 5;\n-            if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n-            let body = cx.tcx.hir().body(body);\n-            let only_expr = peel_blocks_with_stmt(body.value);\n-            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n-            if let ExprKind::Path(..) = recv.kind;\n-            then {\n-                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n-                match ps.ident.as_str() {\n-                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n-                    },\n-                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n-                    },\n-                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n-                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n-                    },\n-                    \"help\" => {\n-                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n-                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n-                    }\n-                    \"note\" => {\n-                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n-                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n-                    }\n-                    _  => (),\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct AndThenSnippets<'a> {\n-    cx: Cow<'a, str>,\n-    lint: Cow<'a, str>,\n-    span: Cow<'a, str>,\n-    msg: Cow<'a, str>,\n-}\n-\n-fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n-    let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n-    let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n-    let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n-    let msg_snippet = snippet(cx, and_then_snippets[3].span, r#\"\"...\"\"#);\n-\n-    AndThenSnippets {\n-        cx: cx_snippet,\n-        lint: lint_snippet,\n-        span: span_snippet,\n-        msg: msg_snippet,\n-    }\n-}\n-\n-struct SpanSuggestionSnippets<'a> {\n-    help: Cow<'a, str>,\n-    sugg: Cow<'a, str>,\n-    applicability: Cow<'a, str>,\n-}\n-\n-fn span_suggestion_snippets<'a, 'hir>(\n-    cx: &LateContext<'_>,\n-    span_call_args: &'hir [Expr<'hir>],\n-) -> SpanSuggestionSnippets<'a> {\n-    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n-    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n-    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n-\n-    SpanSuggestionSnippets {\n-        help: help_snippet,\n-        sugg: sugg_snippet,\n-        applicability: applicability_snippet,\n-    }\n-}\n-\n-fn suggest_suggestion(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n-) {\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_sugg({}, {}, {}, {}, {}, {}, {})\",\n-            and_then_snippets.cx,\n-            and_then_snippets.lint,\n-            and_then_snippets.span,\n-            and_then_snippets.msg,\n-            span_suggestion_snippets.help,\n-            span_suggestion_snippets.sugg,\n-            span_suggestion_snippets.applicability\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn suggest_help(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    help: &str,\n-    with_span: bool,\n-) {\n-    let option_span = if with_span {\n-        format!(\"Some({})\", and_then_snippets.span)\n-    } else {\n-        \"None\".to_string()\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n-            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-fn suggest_note(\n-    cx: &LateContext<'_>,\n-    expr: &Expr<'_>,\n-    and_then_snippets: &AndThenSnippets<'_>,\n-    note: &str,\n-    with_span: bool,\n-) {\n-    let note_span = if with_span {\n-        format!(\"Some({})\", and_then_snippets.span)\n-    } else {\n-        \"None\".to_string()\n-    };\n-\n-    span_lint_and_sugg(\n-        cx,\n-        COLLAPSIBLE_SPAN_LINT_CALLS,\n-        expr.span,\n-        \"this call is collapsible\",\n-        \"collapse into\",\n-        format!(\n-            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n-            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n-        ),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n-\n-#[allow(clippy::too_many_lines)]\n-impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        enum Item {\n-            LangItem(Symbol),\n-            DiagnosticItem(Symbol),\n-        }\n-        static PATHS: &[&[&str]] = &[\n-            &[\"clippy_utils\", \"match_def_path\"],\n-            &[\"clippy_utils\", \"match_trait_method\"],\n-            &[\"clippy_utils\", \"ty\", \"match_type\"],\n-            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n-        ];\n-\n-        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n-            if let ExprKind::Path(path) = &func.kind;\n-            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n-            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n-            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n-            // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, item_arg);\n-            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n-            if let Some(def_id) = def_path_res(cx, &segments[..], None).opt_def_id();\n-            then {\n-                // def_path_res will match field names before anything else, but for this we want to match\n-                // inherent functions first.\n-                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n-                    let method_name = *segments.last().unwrap();\n-                    cx.tcx.def_key(def_id).parent\n-                        .and_then(|parent_idx|\n-                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n-                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n-                                    .find_by_name_and_kind(\n-                                        cx.tcx,\n-                                        Ident::from_str(method_name),\n-                                        AssocKind::Fn,\n-                                        *impl_id,\n-                                    )\n-                                )\n-                        )\n-                        .map_or(def_id, |item| item.def_id)\n-                } else {\n-                    def_id\n-                };\n-\n-                // Check if the target item is a diagnostic item or LangItem.\n-                let (msg, item) = if let Some(item_name)\n-                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n-                {\n-                    (\n-                        \"use of a def path to a diagnostic item\",\n-                        Item::DiagnosticItem(*item_name),\n-                    )\n-                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n-                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n-                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n-                    (\n-                        \"use of a def path to a `LangItem`\",\n-                        Item::LangItem(item_name),\n-                    )\n-                } else {\n-                    return;\n-                };\n-\n-                let has_ctor = match cx.tcx.def_kind(def_id) {\n-                    DefKind::Struct => {\n-                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n-                    }\n-                    DefKind::Variant => {\n-                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n-                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n-                    }\n-                    _ => false,\n-                };\n-\n-                let mut app = Applicability::MachineApplicable;\n-                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n-                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n-                let (sugg, with_note) = match (which_path, item) {\n-                    // match_def_path\n-                    (0, Item::DiagnosticItem(item)) =>\n-                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n-                    (0, Item::LangItem(item)) => (\n-                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n-                        has_ctor\n-                    ),\n-                    // match_trait_method\n-                    (1, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    // match_type\n-                    (2, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    (2, Item::LangItem(item)) =>\n-                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n-                    // is_expr_path_def_path\n-                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n-                        format!(\n-                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n-                        ),\n-                        false,\n-                    ),\n-                    (3, Item::LangItem(item)) if has_ctor => (\n-                        format!(\n-                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n-                        ),\n-                        false,\n-                    ),\n-                    (3, Item::DiagnosticItem(item)) =>\n-                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n-                    (3, Item::LangItem(item)) => (\n-                        format!(\n-                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n-                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n-                        ),\n-                        false,\n-                    ),\n-                    _ => return,\n-                };\n-\n-                span_lint_and_then(\n-                    cx,\n-                    UNNECESSARY_DEF_PATH,\n-                    expr.span,\n-                    msg,\n-                    |diag| {\n-                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n-                        if with_note {\n-                            diag.help(\n-                                \"if this `DefId` came from a constructor expression or pattern then the \\\n-                                    parent `DefId` should be used instead\"\n-                            );\n-                        }\n-                    },\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n-    match peel_hir_expr_refs(expr).0.kind {\n-        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n-            Res::Local(hir_id) => {\n-                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n-                    path_to_matched_type(cx, init)\n-                } else {\n-                    None\n-                }\n-            },\n-            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n-                cx,\n-                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n-                cx.tcx.type_of(def_id),\n-            ),\n-            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n-                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n-                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        },\n-        ExprKind::Array(exprs) => exprs\n-            .iter()\n-            .map(|expr| {\n-                if let ExprKind::Lit(lit) = &expr.kind {\n-                    if let LitKind::Str(sym, _) = lit.node {\n-                        return Some((*sym.as_str()).to_owned());\n-                    }\n-                }\n-\n-                None\n-            })\n-            .collect(),\n-        _ => None,\n-    }\n-}\n-\n-fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n-    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n-        let &alloc = alloc.provenance().values().next()?;\n-        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n-            (alloc.inner(), ty)\n-        } else {\n-            return None;\n-        }\n-    } else {\n-        (alloc, ty)\n-    };\n-\n-    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n-        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n-        && ty.is_str()\n-    {\n-        alloc\n-            .provenance()\n-            .values()\n-            .map(|&alloc| {\n-                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n-                    let alloc = alloc.inner();\n-                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n-                        .ok().map(ToOwned::to_owned)\n-                } else {\n-                    None\n-                }\n-            })\n-            .collect()\n-    } else {\n-        None\n-    }\n-}\n-\n-// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n-// module.  That's all it does and all it needs to do.\n-pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n-    if def_path_res(cx, path, None) != Res::Err {\n-        return true;\n-    }\n-\n-    // Some implementations can't be found by `path_to_res`, particularly inherent\n-    // implementations of native types. Check lang items.\n-    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n-    let lang_items = cx.tcx.lang_items();\n-    // This list isn't complete, but good enough for our current list of paths.\n-    let incoherent_impls = [\n-        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F32),\n-        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F64),\n-        SimplifiedTypeGen::SliceSimplifiedType,\n-        SimplifiedTypeGen::StrSimplifiedType,\n-    ]\n-    .iter()\n-    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n-    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n-        let lang_item_path = cx.get_def_path(*item_def_id);\n-        if path_syms.starts_with(&lang_item_path) {\n-            if let [item] = &path_syms[lang_item_path.len()..] {\n-                if matches!(\n-                    cx.tcx.def_kind(*item_def_id),\n-                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n-                ) {\n-                    for child in cx.tcx.module_children(*item_def_id) {\n-                        if child.ident.name == *item {\n-                            return true;\n-                        }\n-                    }\n-                } else {\n-                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n-                        if cx.tcx.item_name(*child) == *item {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    false\n-}\n-\n-declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n-        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n-        if_chain! {\n-            if mod_name.as_str() == \"paths\";\n-            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n-            let ty = hir_ty_to_ty(cx.tcx, ty);\n-            if let ty::Array(el_ty, _) = &ty.kind();\n-            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n-            if el_ty.is_str();\n-            let body = cx.tcx.hir().body(body_id);\n-            let typeck_results = cx.tcx.typeck_body(body_id);\n-            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n-            let path: Vec<&str> = path.iter().map(|x| {\n-                    if let Constant::Str(s) = x {\n-                        s.as_str()\n-                    } else {\n-                        // We checked the type of the constant above\n-                        unreachable!()\n-                    }\n-                }).collect();\n-            if !check_path(cx, &path[..]);\n-            then {\n-                span_lint(cx, INVALID_PATHS, item.span, \"invalid path\");\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Default)]\n-pub struct InterningDefinedSymbol {\n-    // Maps the symbol value to the constant DefId.\n-    symbol_map: FxHashMap<u32, DefId>,\n-}\n-\n-impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n-\n-impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n-    fn check_crate(&mut self, cx: &LateContext<'_>) {\n-        if !self.symbol_map.is_empty() {\n-            return;\n-        }\n-\n-        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n-            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n-                for item in cx.tcx.module_children(def_id).iter() {\n-                    if_chain! {\n-                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n-                        let ty = cx.tcx.type_of(item_def_id);\n-                        if match_type(cx, ty, &paths::SYMBOL);\n-                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n-                        if let Ok(value) = value.to_u32();\n-                        then {\n-                            self.symbol_map.insert(value, item_def_id);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(func, [arg]) = &expr.kind;\n-            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n-            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n-            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n-            let value = Symbol::intern(&arg).as_u32();\n-            if let Some(&def_id) = self.symbol_map.get(&value);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    INTERNING_DEFINED_SYMBOL,\n-                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n-                    \"interning a defined symbol\",\n-                    \"try\",\n-                    cx.tcx.def_path_str(def_id),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        if let ExprKind::Binary(op, left, right) = expr.kind {\n-            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n-                let data = [\n-                    (left, self.symbol_str_expr(left, cx)),\n-                    (right, self.symbol_str_expr(right, cx)),\n-                ];\n-                match data {\n-                    // both operands are a symbol string\n-                    [(_, Some(left)), (_, Some(right))] => {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            UNNECESSARY_SYMBOL_STR,\n-                            expr.span,\n-                            \"unnecessary `Symbol` to string conversion\",\n-                            \"try\",\n-                            format!(\n-                                \"{} {} {}\",\n-                                left.as_symbol_snippet(cx),\n-                                op.node.as_str(),\n-                                right.as_symbol_snippet(cx),\n-                            ),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    },\n-                    // one of the operands is a symbol string\n-                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n-                        // creating an owned string for comparison\n-                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                UNNECESSARY_SYMBOL_STR,\n-                                expr.span,\n-                                \"unnecessary string allocation\",\n-                                \"try\",\n-                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    },\n-                    // nothing found\n-                    [(_, None), (_, None)] => {},\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl InterningDefinedSymbol {\n-    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n-        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n-        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n-            &paths::SYMBOL_AS_STR,\n-            &paths::SYMBOL_TO_IDENT_STRING,\n-            &paths::TO_STRING_METHOD,\n-        ];\n-        let call = if_chain! {\n-            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n-            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n-            then { e } else { expr }\n-        };\n-        if_chain! {\n-            // is a method call\n-            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n-            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n-            let ty = cx.typeck_results().expr_ty(item);\n-            // ...on either an Ident or a Symbol\n-            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n-                Some(false)\n-            } else if match_type(cx, ty, &paths::IDENT) {\n-                Some(true)\n-            } else {\n-                None\n-            };\n-            // ...which converts it to a string\n-            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n-            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n-            then {\n-                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n-                return Some(SymbolStrExpr::Expr {\n-                    item,\n-                    is_ident,\n-                    is_to_owned,\n-                });\n-            }\n-        }\n-        // is a string constant\n-        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n-            let value = Symbol::intern(&s).as_u32();\n-            // ...which matches a symbol constant\n-            if let Some(&def_id) = self.symbol_map.get(&value) {\n-                return Some(SymbolStrExpr::Const(def_id));\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-enum SymbolStrExpr<'tcx> {\n-    /// a string constant with a corresponding symbol constant\n-    Const(DefId),\n-    /// a \"symbol to string\" expression like `symbol.as_str()`\n-    Expr {\n-        /// part that evaluates to `Symbol` or `Ident`\n-        item: &'tcx Expr<'tcx>,\n-        is_ident: bool,\n-        /// whether an owned `String` is created like `to_ident_string()`\n-        is_to_owned: bool,\n-    },\n-}\n-\n-impl<'tcx> SymbolStrExpr<'tcx> {\n-    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n-    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n-        match *self {\n-            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n-            Self::Expr { item, is_ident, .. } => {\n-                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n-                if is_ident {\n-                    // get `Ident.name`\n-                    snip.to_mut().push_str(\".name\");\n-                }\n-                snip\n-            },\n-        }\n-    }\n-}\n-\n-declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n-\n-impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n-        let (local, after, if_chain_span) = if_chain! {\n-            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n-            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n-            then { (local, after, if_chain_span) } else { return }\n-        };\n-        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n-            span_lint(\n-                cx,\n-                IF_CHAIN_STYLE,\n-                if_chain_local_span(cx, local, if_chain_span),\n-                \"`let` expression should be above the `if_chain!`\",\n-            );\n-        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n-            span_lint(\n-                cx,\n-                IF_CHAIN_STYLE,\n-                if_chain_local_span(cx, local, if_chain_span),\n-                \"`let` expression should be inside `then { .. }`\",\n-            );\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n-            (cond, then, r#else.is_some())\n-        } else {\n-            return;\n-        };\n-        let then_block = match then.kind {\n-            ExprKind::Block(block, _) => block,\n-            _ => return,\n-        };\n-        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n-        if !els {\n-            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n-        }\n-        let if_chain_span = match if_chain_span {\n-            None => return,\n-            Some(span) => span,\n-        };\n-        // check for `if a && b;`\n-        if_chain! {\n-            if let ExprKind::Binary(op, _, _) = cond.kind;\n-            if op.node == BinOpKind::And;\n-            if cx.sess().source_map().is_multiline(cond.span);\n-            then {\n-                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n-            }\n-        }\n-        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n-            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n-        {\n-            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n-        }\n-    }\n-}\n-\n-fn check_nested_if_chains(\n-    cx: &LateContext<'_>,\n-    if_expr: &Expr<'_>,\n-    then_block: &Block<'_>,\n-    if_chain_span: Option<Span>,\n-) {\n-    #[rustfmt::skip]\n-    let (head, tail) = match *then_block {\n-        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n-        Block {\n-            stmts: &[\n-                ref head @ ..,\n-                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n-            ],\n-            ..\n-        } => (head, tail),\n-        _ => return,\n-    };\n-    if_chain! {\n-        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n-        let sm = cx.sess().source_map();\n-        if head\n-            .iter()\n-            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n-        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n-        then {} else { return }\n-    }\n-    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n-        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n-        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n-        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n-        _ => return,\n-    };\n-    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n-        let (span, msg) = match head {\n-            [] => return,\n-            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n-            [a, .., b] => (\n-                a.span.to(b.span),\n-                \"these `let` statements can also be in the `if_chain!`\",\n-            ),\n-        };\n-        diag.span_help(span, msg);\n-    });\n-}\n-\n-fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n-    cx.tcx\n-        .hir()\n-        .parent_iter(hir_id)\n-        .find(|(_, node)| {\n-            #[rustfmt::skip]\n-            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n-        })\n-        .map_or(false, |(id, _)| {\n-            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n-        })\n-}\n-\n-/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n-/// of the `then {..}` portion of an `if_chain!`\n-fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n-    let span = if let [stmt, ..] = stmts {\n-        stmt.span\n-    } else if let Some(expr) = expr {\n-        expr.span\n-    } else {\n-        // empty `then {}`\n-        return true;\n-    };\n-    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n-}\n-\n-/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n-fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n-    let mut span = local.pat.span;\n-    if let Some(init) = local.init {\n-        span = span.to(init.span);\n-    }\n-    span.adjust(if_chain_span.ctxt().outer_expn());\n-    let sm = cx.sess().source_map();\n-    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n-    let span = sm.span_extend_to_next_char(span, ';', false);\n-    Span::new(\n-        span.lo() - BytePos(3),\n-        span.hi() + BytePos(1),\n-        span.ctxt(),\n-        span.parent(),\n-    )\n-}\n-\n-declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n-\n-impl LateLintPass<'_> for MsrvAttrImpl {\n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if_chain! {\n-            if let hir::ItemKind::Impl(hir::Impl {\n-                of_trait: Some(lint_pass_trait_ref),\n-                self_ty,\n-                items,\n-                ..\n-            }) = &item.kind;\n-            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n-            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n-            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n-            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n-            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n-            if self_ty_def.is_struct();\n-            if self_ty_def.all_fields().any(|f| {\n-                cx.tcx\n-                    .type_of(f.did)\n-                    .walk()\n-                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n-                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n-            });\n-            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n-            then {\n-                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n-                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n-                let span = cx.sess().source_map().span_through_char(item.span, '{');\n-                span_lint_and_sugg(\n-                    cx,\n-                    MISSING_MSRV_ATTR_IMPL,\n-                    span,\n-                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n-                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n-                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n+pub mod msrv_attr_impl;\n+pub mod outer_expn_data_pass;\n+pub mod produce_ice;\n+pub mod unnecessary_def_path;"}, {"sha": "da9514dd15eee4c85293c8ea8e0c546c99f5cb0e", "filename": "clippy_lints/src/utils/internal_lints/clippy_lints_internal.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fclippy_lints_internal.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,49 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{Crate, ItemKind, ModKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for various things we like to keep tidy in clippy.\n+    ///\n+    /// ### Why is this bad?\n+    /// We like to pretend we're an example of tidy code.\n+    ///\n+    /// ### Example\n+    /// Wrong ordering of the util::paths constants.\n+    pub CLIPPY_LINTS_INTERNAL,\n+    internal,\n+    \"various things that will negatively affect your clippy experience\"\n+}\n+\n+declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n+\n+impl EarlyLintPass for ClippyLintsInternal {\n+    fn check_crate(&mut self, cx: &EarlyContext<'_>, krate: &Crate) {\n+        if let Some(utils) = krate.items.iter().find(|item| item.ident.name.as_str() == \"utils\") {\n+            if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = utils.kind {\n+                if let Some(paths) = items.iter().find(|item| item.ident.name.as_str() == \"paths\") {\n+                    if let ItemKind::Mod(_, ModKind::Loaded(ref items, ..)) = paths.kind {\n+                        let mut last_name: Option<&str> = None;\n+                        for item in items {\n+                            let name = item.ident.as_str();\n+                            if let Some(last_name) = last_name {\n+                                if *last_name > *name {\n+                                    span_lint(\n+                                        cx,\n+                                        CLIPPY_LINTS_INTERNAL,\n+                                        item.span,\n+                                        \"this constant should be before the previous constant due to lexical \\\n+                                         ordering\",\n+                                    );\n+                                }\n+                            }\n+                            last_name = Some(name);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "d7666b77f6e969d1086f1ba0db9b5dd4f4c5bace", "filename": "clippy_lints/src/utils/internal_lints/collapsible_calls.rs", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcollapsible_calls.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,245 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::{is_expr_path_def_path, is_lint_allowed, peel_blocks_with_stmt, SpanlessEq};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::{Closure, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+use std::borrow::{Borrow, Cow};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Lints `span_lint_and_then` function calls, where the\n+    /// closure argument has only one statement and that statement is a method\n+    /// call to `span_suggestion`, `span_help`, `span_note` (using the same\n+    /// span), `help` or `note`.\n+    ///\n+    /// These usages of `span_lint_and_then` should be replaced with one of the\n+    /// wrapper functions `span_lint_and_sugg`, span_lint_and_help`, or\n+    /// `span_lint_and_note`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Using the wrapper `span_lint_and_*` functions, is more\n+    /// convenient, readable and less error prone.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_suggestion(\n+    ///         expr.span,\n+    ///         help_msg,\n+    ///         sugg.to_string(),\n+    ///         Applicability::MachineApplicable,\n+    ///     );\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_help(expr.span, help_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.help(help_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.span_note(expr.span, note_msg);\n+    /// });\n+    /// span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |diag| {\n+    ///     diag.note(note_msg);\n+    /// });\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// span_lint_and_sugg(\n+    ///     cx,\n+    ///     TEST_LINT,\n+    ///     expr.span,\n+    ///     lint_msg,\n+    ///     help_msg,\n+    ///     sugg.to_string(),\n+    ///     Applicability::MachineApplicable,\n+    /// );\n+    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), help_msg);\n+    /// span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg);\n+    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg);\n+    /// span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, None, note_msg);\n+    /// ```\n+    pub COLLAPSIBLE_SPAN_LINT_CALLS,\n+    internal,\n+    \"found collapsible `span_lint_and_then` calls\"\n+}\n+\n+declare_lint_pass!(CollapsibleCalls => [COLLAPSIBLE_SPAN_LINT_CALLS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, COLLAPSIBLE_SPAN_LINT_CALLS, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::Call(func, and_then_args) = expr.kind;\n+            if is_expr_path_def_path(cx, func, &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"]);\n+            if and_then_args.len() == 5;\n+            if let ExprKind::Closure(&Closure { body, .. }) = &and_then_args[4].kind;\n+            let body = cx.tcx.hir().body(body);\n+            let only_expr = peel_blocks_with_stmt(body.value);\n+            if let ExprKind::MethodCall(ps, recv, span_call_args, _) = &only_expr.kind;\n+            if let ExprKind::Path(..) = recv.kind;\n+            then {\n+                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n+                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n+                match ps.ident.as_str() {\n+                    \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        suggest_suggestion(\n+                            cx,\n+                            expr,\n+                            &and_then_snippets,\n+                            &span_suggestion_snippets(cx, span_call_args),\n+                        );\n+                    },\n+                    \"span_help\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), true);\n+                    },\n+                    \"span_note\" if sle.eq_expr(&and_then_args[2], &span_call_args[0]) => {\n+                        let note_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), true);\n+                    },\n+                    \"help\" => {\n+                        let help_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n+                        suggest_help(cx, expr, &and_then_snippets, help_snippet.borrow(), false);\n+                    },\n+                    \"note\" => {\n+                        let note_snippet = snippet(cx, span_call_args[0].span, r#\"\"...\"\"#);\n+                        suggest_note(cx, expr, &and_then_snippets, note_snippet.borrow(), false);\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct AndThenSnippets<'a> {\n+    cx: Cow<'a, str>,\n+    lint: Cow<'a, str>,\n+    span: Cow<'a, str>,\n+    msg: Cow<'a, str>,\n+}\n+\n+fn get_and_then_snippets<'a, 'hir>(cx: &LateContext<'_>, and_then_snippets: &'hir [Expr<'hir>]) -> AndThenSnippets<'a> {\n+    let cx_snippet = snippet(cx, and_then_snippets[0].span, \"cx\");\n+    let lint_snippet = snippet(cx, and_then_snippets[1].span, \"..\");\n+    let span_snippet = snippet(cx, and_then_snippets[2].span, \"span\");\n+    let msg_snippet = snippet(cx, and_then_snippets[3].span, r#\"\"...\"\"#);\n+\n+    AndThenSnippets {\n+        cx: cx_snippet,\n+        lint: lint_snippet,\n+        span: span_snippet,\n+        msg: msg_snippet,\n+    }\n+}\n+\n+struct SpanSuggestionSnippets<'a> {\n+    help: Cow<'a, str>,\n+    sugg: Cow<'a, str>,\n+    applicability: Cow<'a, str>,\n+}\n+\n+fn span_suggestion_snippets<'a, 'hir>(\n+    cx: &LateContext<'_>,\n+    span_call_args: &'hir [Expr<'hir>],\n+) -> SpanSuggestionSnippets<'a> {\n+    let help_snippet = snippet(cx, span_call_args[1].span, r#\"\"...\"\"#);\n+    let sugg_snippet = snippet(cx, span_call_args[2].span, \"..\");\n+    let applicability_snippet = snippet(cx, span_call_args[3].span, \"Applicability::MachineApplicable\");\n+\n+    SpanSuggestionSnippets {\n+        help: help_snippet,\n+        sugg: sugg_snippet,\n+        applicability: applicability_snippet,\n+    }\n+}\n+\n+fn suggest_suggestion(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    span_suggestion_snippets: &SpanSuggestionSnippets<'_>,\n+) {\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_sugg({}, {}, {}, {}, {}, {}, {})\",\n+            and_then_snippets.cx,\n+            and_then_snippets.lint,\n+            and_then_snippets.span,\n+            and_then_snippets.msg,\n+            span_suggestion_snippets.help,\n+            span_suggestion_snippets.sugg,\n+            span_suggestion_snippets.applicability\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn suggest_help(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    help: &str,\n+    with_span: bool,\n+) {\n+    let option_span = if with_span {\n+        format!(\"Some({})\", and_then_snippets.span)\n+    } else {\n+        \"None\".to_string()\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_help({}, {}, {}, {}, {}, {help})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg, &option_span,\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn suggest_note(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    and_then_snippets: &AndThenSnippets<'_>,\n+    note: &str,\n+    with_span: bool,\n+) {\n+    let note_span = if with_span {\n+        format!(\"Some({})\", and_then_snippets.span)\n+    } else {\n+        \"None\".to_string()\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        COLLAPSIBLE_SPAN_LINT_CALLS,\n+        expr.span,\n+        \"this call is collapsible\",\n+        \"collapse into\",\n+        format!(\n+            \"span_lint_and_note({}, {}, {}, {}, {note_span}, {note})\",\n+            and_then_snippets.cx, and_then_snippets.lint, and_then_snippets.span, and_then_snippets.msg,\n+        ),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "cacd05262a2151093552d0cfde6329911e3710b6", "filename": "clippy_lints/src/utils/internal_lints/compiler_lint_functions.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fcompiler_lint_functions.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,77 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{is_lint_allowed, paths};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `cx.span_lint*` and suggests to use the `utils::*`\n+    /// variant of the function.\n+    ///\n+    /// ### Why is this bad?\n+    /// The `utils::*` variants also add a link to the Clippy documentation to the\n+    /// warning/error messages.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// cx.span_lint(LINT_NAME, \"message\");\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// utils::span_lint(cx, LINT_NAME, \"message\");\n+    /// ```\n+    pub COMPILER_LINT_FUNCTIONS,\n+    internal,\n+    \"usage of the lint functions of the compiler instead of the utils::* variant\"\n+}\n+\n+impl_lint_pass!(CompilerLintFunctions => [COMPILER_LINT_FUNCTIONS]);\n+\n+#[derive(Clone, Default)]\n+pub struct CompilerLintFunctions {\n+    map: FxHashMap<&'static str, &'static str>,\n+}\n+\n+impl CompilerLintFunctions {\n+    #[must_use]\n+    pub fn new() -> Self {\n+        let mut map = FxHashMap::default();\n+        map.insert(\"span_lint\", \"utils::span_lint\");\n+        map.insert(\"struct_span_lint\", \"utils::span_lint\");\n+        map.insert(\"lint\", \"utils::span_lint\");\n+        map.insert(\"span_lint_note\", \"utils::span_lint_and_note\");\n+        map.insert(\"span_lint_help\", \"utils::span_lint_and_help\");\n+        Self { map }\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for CompilerLintFunctions {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if is_lint_allowed(cx, COMPILER_LINT_FUNCTIONS, expr.hir_id) {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, self_arg, _, _) = &expr.kind;\n+            let fn_name = path.ident;\n+            if let Some(sugg) = self.map.get(fn_name.as_str());\n+            let ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+            if match_type(cx, ty, &paths::EARLY_CONTEXT) || match_type(cx, ty, &paths::LATE_CONTEXT);\n+            then {\n+                span_lint_and_help(\n+                    cx,\n+                    COMPILER_LINT_FUNCTIONS,\n+                    path.ident.span,\n+                    \"usage of a compiler lint function\",\n+                    None,\n+                    &format!(\"please use the Clippy variant of this function: `{sugg}`\"),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "883a5c08e5c11b1f86ec1c84e3a627a27ffc1aad", "filename": "clippy_lints/src/utils/internal_lints/if_chain_style.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fif_chain_style.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,164 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n+use clippy_utils::{higher, is_else_clause, is_expn_of};\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_hir::{BinOpKind, Block, Expr, ExprKind, HirId, Local, Node, Stmt, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::{BytePos, Span};\n+\n+declare_clippy_lint! {\n+    /// Finds unidiomatic usage of `if_chain!`\n+    pub IF_CHAIN_STYLE,\n+    internal,\n+    \"non-idiomatic `if_chain!` usage\"\n+}\n+\n+declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n+        let (local, after, if_chain_span) = if_chain! {\n+            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n+            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n+            then { (local, after, if_chain_span) } else { return }\n+        };\n+        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be above the `if_chain!`\",\n+            );\n+        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be inside `then { .. }`\",\n+            );\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let (cond, then, els) = if let Some(higher::IfOrIfLet { cond, r#else, then }) = higher::IfOrIfLet::hir(expr) {\n+            (cond, then, r#else.is_some())\n+        } else {\n+            return;\n+        };\n+        let ExprKind::Block(then_block, _) = then.kind else { return };\n+        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n+        if !els {\n+            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n+        }\n+        let Some(if_chain_span) = if_chain_span else { return };\n+        // check for `if a && b;`\n+        if_chain! {\n+            if let ExprKind::Binary(op, _, _) = cond.kind;\n+            if op.node == BinOpKind::And;\n+            if cx.sess().source_map().is_multiline(cond.span);\n+            then {\n+                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n+            }\n+        }\n+        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n+            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n+        {\n+            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\");\n+        }\n+    }\n+}\n+\n+fn check_nested_if_chains(\n+    cx: &LateContext<'_>,\n+    if_expr: &Expr<'_>,\n+    then_block: &Block<'_>,\n+    if_chain_span: Option<Span>,\n+) {\n+    #[rustfmt::skip]\n+    let (head, tail) = match *then_block {\n+        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n+        Block {\n+            stmts: &[\n+                ref head @ ..,\n+                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n+            ],\n+            ..\n+        } => (head, tail),\n+        _ => return,\n+    };\n+    if_chain! {\n+        if let Some(higher::IfOrIfLet { r#else: None, .. }) = higher::IfOrIfLet::hir(tail);\n+        let sm = cx.sess().source_map();\n+        if head\n+            .iter()\n+            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n+        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n+        then {\n+        } else {\n+            return;\n+        }\n+    }\n+    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n+        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n+        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n+        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n+        _ => return,\n+    };\n+    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n+        let (span, msg) = match head {\n+            [] => return,\n+            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n+            [a, .., b] => (\n+                a.span.to(b.span),\n+                \"these `let` statements can also be in the `if_chain!`\",\n+            ),\n+        };\n+        diag.span_help(span, msg);\n+    });\n+}\n+\n+fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n+    cx.tcx\n+        .hir()\n+        .parent_iter(hir_id)\n+        .find(|(_, node)| {\n+            #[rustfmt::skip]\n+            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n+        })\n+        .map_or(false, |(id, _)| {\n+            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n+        })\n+}\n+\n+/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n+/// of the `then {..}` portion of an `if_chain!`\n+fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n+    let span = if let [stmt, ..] = stmts {\n+        stmt.span\n+    } else if let Some(expr) = expr {\n+        expr.span\n+    } else {\n+        // empty `then {}`\n+        return true;\n+    };\n+    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n+}\n+\n+/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n+fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n+    let mut span = local.pat.span;\n+    if let Some(init) = local.init {\n+        span = span.to(init.span);\n+    }\n+    span.adjust(if_chain_span.ctxt().outer_expn());\n+    let sm = cx.sess().source_map();\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n+    let span = sm.span_extend_to_next_char(span, ';', false);\n+    Span::new(\n+        span.lo() - BytePos(3),\n+        span.hi() + BytePos(1),\n+        span.ctxt(),\n+        span.parent(),\n+    )\n+}"}, {"sha": "096b601572b4db5dcce28ff090f39b8e1d4eadf6", "filename": "clippy_lints/src/utils/internal_lints/interning_defined_symbol.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finterning_defined_symbol.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,239 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{def_path_res, is_expn_of, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::ConstValue;\n+use rustc_middle::ty::{self};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::Symbol;\n+\n+use std::borrow::Cow;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for interning symbols that have already been pre-interned and defined as constants.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's faster and easier to use the symbol constant.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let _ = sym!(f32);\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// let _ = sym::f32;\n+    /// ```\n+    pub INTERNING_DEFINED_SYMBOL,\n+    internal,\n+    \"interning a symbol that is pre-interned and defined as a constant\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary conversion from Symbol to a string.\n+    ///\n+    /// ### Why is this bad?\n+    /// It's faster use symbols directly instead of strings.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// symbol.as_str() == \"clippy\";\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// symbol == sym::clippy;\n+    /// ```\n+    pub UNNECESSARY_SYMBOL_STR,\n+    internal,\n+    \"unnecessary conversion between Symbol and string\"\n+}\n+\n+#[derive(Default)]\n+pub struct InterningDefinedSymbol {\n+    // Maps the symbol value to the constant DefId.\n+    symbol_map: FxHashMap<u32, DefId>,\n+}\n+\n+impl_lint_pass!(InterningDefinedSymbol => [INTERNING_DEFINED_SYMBOL, UNNECESSARY_SYMBOL_STR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InterningDefinedSymbol {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        if !self.symbol_map.is_empty() {\n+            return;\n+        }\n+\n+        for &module in &[&paths::KW_MODULE, &paths::SYM_MODULE] {\n+            if let Some(def_id) = def_path_res(cx, module, None).opt_def_id() {\n+                for item in cx.tcx.module_children(def_id).iter() {\n+                    if_chain! {\n+                        if let Res::Def(DefKind::Const, item_def_id) = item.res;\n+                        let ty = cx.tcx.type_of(item_def_id);\n+                        if match_type(cx, ty, &paths::SYMBOL);\n+                        if let Ok(ConstValue::Scalar(value)) = cx.tcx.const_eval_poly(item_def_id);\n+                        if let Ok(value) = value.to_u32();\n+                        then {\n+                            self.symbol_map.insert(value, item_def_id);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::Call(func, [arg]) = &expr.kind;\n+            if let ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(func).kind();\n+            if match_def_path(cx, *def_id, &paths::SYMBOL_INTERN);\n+            if let Some(Constant::Str(arg)) = constant_simple(cx, cx.typeck_results(), arg);\n+            let value = Symbol::intern(&arg).as_u32();\n+            if let Some(&def_id) = self.symbol_map.get(&value);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    INTERNING_DEFINED_SYMBOL,\n+                    is_expn_of(expr.span, \"sym\").unwrap_or(expr.span),\n+                    \"interning a defined symbol\",\n+                    \"try\",\n+                    cx.tcx.def_path_str(def_id),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if let ExprKind::Binary(op, left, right) = expr.kind {\n+            if matches!(op.node, BinOpKind::Eq | BinOpKind::Ne) {\n+                let data = [\n+                    (left, self.symbol_str_expr(left, cx)),\n+                    (right, self.symbol_str_expr(right, cx)),\n+                ];\n+                match data {\n+                    // both operands are a symbol string\n+                    [(_, Some(left)), (_, Some(right))] => {\n+                        span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_SYMBOL_STR,\n+                            expr.span,\n+                            \"unnecessary `Symbol` to string conversion\",\n+                            \"try\",\n+                            format!(\n+                                \"{} {} {}\",\n+                                left.as_symbol_snippet(cx),\n+                                op.node.as_str(),\n+                                right.as_symbol_snippet(cx),\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    },\n+                    // one of the operands is a symbol string\n+                    [(expr, Some(symbol)), _] | [_, (expr, Some(symbol))] => {\n+                        // creating an owned string for comparison\n+                        if matches!(symbol, SymbolStrExpr::Expr { is_to_owned: true, .. }) {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_SYMBOL_STR,\n+                                expr.span,\n+                                \"unnecessary string allocation\",\n+                                \"try\",\n+                                format!(\"{}.as_str()\", symbol.as_symbol_snippet(cx)),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    },\n+                    // nothing found\n+                    [(_, None), (_, None)] => {},\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl InterningDefinedSymbol {\n+    fn symbol_str_expr<'tcx>(&self, expr: &'tcx Expr<'tcx>, cx: &LateContext<'tcx>) -> Option<SymbolStrExpr<'tcx>> {\n+        static IDENT_STR_PATHS: &[&[&str]] = &[&paths::IDENT_AS_STR, &paths::TO_STRING_METHOD];\n+        static SYMBOL_STR_PATHS: &[&[&str]] = &[\n+            &paths::SYMBOL_AS_STR,\n+            &paths::SYMBOL_TO_IDENT_STRING,\n+            &paths::TO_STRING_METHOD,\n+        ];\n+        let call = if_chain! {\n+            if let ExprKind::AddrOf(_, _, e) = expr.kind;\n+            if let ExprKind::Unary(UnOp::Deref, e) = e.kind;\n+            then { e } else { expr }\n+        };\n+        if_chain! {\n+            // is a method call\n+            if let ExprKind::MethodCall(_, item, [], _) = call.kind;\n+            if let Some(did) = cx.typeck_results().type_dependent_def_id(call.hir_id);\n+            let ty = cx.typeck_results().expr_ty(item);\n+            // ...on either an Ident or a Symbol\n+            if let Some(is_ident) = if match_type(cx, ty, &paths::SYMBOL) {\n+                Some(false)\n+            } else if match_type(cx, ty, &paths::IDENT) {\n+                Some(true)\n+            } else {\n+                None\n+            };\n+            // ...which converts it to a string\n+            let paths = if is_ident { IDENT_STR_PATHS } else { SYMBOL_STR_PATHS };\n+            if let Some(path) = paths.iter().find(|path| match_def_path(cx, did, path));\n+            then {\n+                let is_to_owned = path.last().unwrap().ends_with(\"string\");\n+                return Some(SymbolStrExpr::Expr {\n+                    item,\n+                    is_ident,\n+                    is_to_owned,\n+                });\n+            }\n+        }\n+        // is a string constant\n+        if let Some(Constant::Str(s)) = constant_simple(cx, cx.typeck_results(), expr) {\n+            let value = Symbol::intern(&s).as_u32();\n+            // ...which matches a symbol constant\n+            if let Some(&def_id) = self.symbol_map.get(&value) {\n+                return Some(SymbolStrExpr::Const(def_id));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+enum SymbolStrExpr<'tcx> {\n+    /// a string constant with a corresponding symbol constant\n+    Const(DefId),\n+    /// a \"symbol to string\" expression like `symbol.as_str()`\n+    Expr {\n+        /// part that evaluates to `Symbol` or `Ident`\n+        item: &'tcx Expr<'tcx>,\n+        is_ident: bool,\n+        /// whether an owned `String` is created like `to_ident_string()`\n+        is_to_owned: bool,\n+    },\n+}\n+\n+impl<'tcx> SymbolStrExpr<'tcx> {\n+    /// Returns a snippet that evaluates to a `Symbol` and is const if possible\n+    fn as_symbol_snippet(&self, cx: &LateContext<'_>) -> Cow<'tcx, str> {\n+        match *self {\n+            Self::Const(def_id) => cx.tcx.def_path_str(def_id).into(),\n+            Self::Expr { item, is_ident, .. } => {\n+                let mut snip = snippet(cx, item.span.source_callsite(), \"..\");\n+                if is_ident {\n+                    // get `Ident.name`\n+                    snip.to_mut().push_str(\".name\");\n+                }\n+                snip\n+            },\n+        }\n+    }\n+}"}, {"sha": "25532dd4e2681e6455921480339e937b536e3e92", "filename": "clippy_lints/src/utils/internal_lints/invalid_paths.rs", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Finvalid_paths.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,108 @@\n+use clippy_utils::consts::{constant_simple, Constant};\n+use clippy_utils::def_path_res;\n+use clippy_utils::diagnostics::span_lint;\n+use if_chain::if_chain;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::Item;\n+use rustc_hir_analysis::hir_ty_to_ty;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, FloatTy};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks the paths module for invalid paths.\n+    ///\n+    /// ### Why is this bad?\n+    /// It indicates a bug in the code.\n+    ///\n+    /// ### Example\n+    /// None.\n+    pub INVALID_PATHS,\n+    internal,\n+    \"invalid path\"\n+}\n+\n+declare_lint_pass!(InvalidPaths => [INVALID_PATHS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for InvalidPaths {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        let local_def_id = &cx.tcx.parent_module(item.hir_id());\n+        let mod_name = &cx.tcx.item_name(local_def_id.to_def_id());\n+        if_chain! {\n+            if mod_name.as_str() == \"paths\";\n+            if let hir::ItemKind::Const(ty, body_id) = item.kind;\n+            let ty = hir_ty_to_ty(cx.tcx, ty);\n+            if let ty::Array(el_ty, _) = &ty.kind();\n+            if let ty::Ref(_, el_ty, _) = &el_ty.kind();\n+            if el_ty.is_str();\n+            let body = cx.tcx.hir().body(body_id);\n+            let typeck_results = cx.tcx.typeck_body(body_id);\n+            if let Some(Constant::Vec(path)) = constant_simple(cx, typeck_results, body.value);\n+            let path: Vec<&str> = path\n+                .iter()\n+                .map(|x| {\n+                    if let Constant::Str(s) = x {\n+                        s.as_str()\n+                    } else {\n+                        // We checked the type of the constant above\n+                        unreachable!()\n+                    }\n+                })\n+                .collect();\n+            if !check_path(cx, &path[..]);\n+            then {\n+                span_lint(cx, INVALID_PATHS, item.span, \"invalid path\");\n+            }\n+        }\n+    }\n+}\n+\n+// This is not a complete resolver for paths. It works on all the paths currently used in the paths\n+// module.  That's all it does and all it needs to do.\n+pub fn check_path(cx: &LateContext<'_>, path: &[&str]) -> bool {\n+    if def_path_res(cx, path, None) != Res::Err {\n+        return true;\n+    }\n+\n+    // Some implementations can't be found by `path_to_res`, particularly inherent\n+    // implementations of native types. Check lang items.\n+    let path_syms: Vec<_> = path.iter().map(|p| Symbol::intern(p)).collect();\n+    let lang_items = cx.tcx.lang_items();\n+    // This list isn't complete, but good enough for our current list of paths.\n+    let incoherent_impls = [\n+        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F32),\n+        SimplifiedTypeGen::FloatSimplifiedType(FloatTy::F64),\n+        SimplifiedTypeGen::SliceSimplifiedType,\n+        SimplifiedTypeGen::StrSimplifiedType,\n+    ]\n+    .iter()\n+    .flat_map(|&ty| cx.tcx.incoherent_impls(ty));\n+    for item_def_id in lang_items.items().iter().flatten().chain(incoherent_impls) {\n+        let lang_item_path = cx.get_def_path(*item_def_id);\n+        if path_syms.starts_with(&lang_item_path) {\n+            if let [item] = &path_syms[lang_item_path.len()..] {\n+                if matches!(\n+                    cx.tcx.def_kind(*item_def_id),\n+                    DefKind::Mod | DefKind::Enum | DefKind::Trait\n+                ) {\n+                    for child in cx.tcx.module_children(*item_def_id) {\n+                        if child.ident.name == *item {\n+                            return true;\n+                        }\n+                    }\n+                } else {\n+                    for child in cx.tcx.associated_item_def_ids(*item_def_id) {\n+                        if cx.tcx.item_name(*child) == *item {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "0dac64376b06539109482966d66918fb66f7efab", "filename": "clippy_lints/src/utils/internal_lints/lint_without_lint_pass.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Flint_without_lint_pass.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,342 @@\n+use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use clippy_utils::macros::root_macro_call_first_node;\n+use clippy_utils::{is_lint_allowed, match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast as ast;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::hir_id::CRATE_HIR_ID;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{ExprKind, HirId, Item, MutTy, Mutability, Path, TyKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter;\n+use rustc_semver::RustcVersion;\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::source_map::Spanned;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::{sym, Span};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Ensures every lint is associated to a `LintPass`.\n+    ///\n+    /// ### Why is this bad?\n+    /// The compiler only knows lints via a `LintPass`. Without\n+    /// putting a lint to a `LintPass::get_lints()`'s return, the compiler will not\n+    /// know the name of the lint.\n+    ///\n+    /// ### Known problems\n+    /// Only checks for lints associated using the\n+    /// `declare_lint_pass!`, `impl_lint_pass!`, and `lint_array!` macros.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_lint! { pub LINT_1, ... }\n+    /// declare_lint! { pub LINT_2, ... }\n+    /// declare_lint! { pub FORGOTTEN_LINT, ... }\n+    /// // ...\n+    /// declare_lint_pass!(Pass => [LINT_1, LINT_2]);\n+    /// // missing FORGOTTEN_LINT\n+    /// ```\n+    pub LINT_WITHOUT_LINT_PASS,\n+    internal,\n+    \"declaring a lint without associating it in a LintPass\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated lint without an updated description,\n+    /// i.e. `default lint description`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the lint is not finished.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_lint! { pub COOL_LINT, nursery, \"default lint description\" }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_lint! { pub COOL_LINT, nursery, \"a great new lint\" }\n+    /// ```\n+    pub DEFAULT_LINT,\n+    internal,\n+    \"found 'default lint description' in a lint declaration\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for invalid `clippy::version` attributes.\n+    ///\n+    /// Valid values are:\n+    /// * \"pre 1.29.0\"\n+    /// * any valid semantic version\n+    pub INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found an invalid `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for declared clippy lints without the `clippy::version` attribute.\n+    ///\n+    pub MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+    internal,\n+    \"found clippy lint without `clippy::version` attribute\"\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for cases of an auto-generated deprecated lint without an updated reason,\n+    /// i.e. `\"default deprecation note\"`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Indicates that the documentation is incomplete.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// TODO\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"default deprecation note\"\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// declare_deprecated_lint! {\n+    ///     /// ### What it does\n+    ///     /// Nothing. This lint has been deprecated.\n+    ///     ///\n+    ///     /// ### Deprecation reason\n+    ///     /// This lint has been replaced by `cooler_lint`\n+    ///     #[clippy::version = \"1.63.0\"]\n+    ///     pub COOL_LINT,\n+    ///     \"this lint has been replaced by `cooler_lint`\"\n+    /// }\n+    /// ```\n+    pub DEFAULT_DEPRECATION_REASON,\n+    internal,\n+    \"found 'default deprecation note' in a deprecated lint declaration\"\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct LintWithoutLintPass {\n+    declared_lints: FxHashMap<Symbol, Span>,\n+    registered_lints: FxHashSet<Symbol>,\n+}\n+\n+impl_lint_pass!(LintWithoutLintPass => [DEFAULT_LINT, LINT_WITHOUT_LINT_PASS, INVALID_CLIPPY_VERSION_ATTRIBUTE, MISSING_CLIPPY_VERSION_ATTRIBUTE, DEFAULT_DEPRECATION_REASON]);\n+\n+impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n+        if is_lint_allowed(cx, DEFAULT_LINT, item.hir_id())\n+            || is_lint_allowed(cx, DEFAULT_DEPRECATION_REASON, item.hir_id())\n+        {\n+            return;\n+        }\n+\n+        if let hir::ItemKind::Static(ty, Mutability::Not, body_id) = item.kind {\n+            let is_lint_ref_ty = is_lint_ref_type(cx, ty);\n+            if is_deprecated_lint(cx, ty) || is_lint_ref_ty {\n+                check_invalid_clippy_version_attribute(cx, item);\n+\n+                let expr = &cx.tcx.hir().body(body_id).value;\n+                let fields;\n+                if is_lint_ref_ty {\n+                    if let ExprKind::AddrOf(_, _, inner_exp) = expr.kind\n+                        && let ExprKind::Struct(_, struct_fields, _) = inner_exp.kind {\n+                            fields = struct_fields;\n+                    } else {\n+                        return;\n+                    }\n+                } else if let ExprKind::Struct(_, struct_fields, _) = expr.kind {\n+                    fields = struct_fields;\n+                } else {\n+                    return;\n+                }\n+\n+                let field = fields\n+                    .iter()\n+                    .find(|f| f.ident.as_str() == \"desc\")\n+                    .expect(\"lints must have a description field\");\n+\n+                if let ExprKind::Lit(Spanned {\n+                    node: LitKind::Str(ref sym, _),\n+                    ..\n+                }) = field.expr.kind\n+                {\n+                    let sym_str = sym.as_str();\n+                    if is_lint_ref_ty {\n+                        if sym_str == \"default lint description\" {\n+                            span_lint(\n+                                cx,\n+                                DEFAULT_LINT,\n+                                item.span,\n+                                &format!(\"the lint `{}` has the default lint description\", item.ident.name),\n+                            );\n+                        }\n+\n+                        self.declared_lints.insert(item.ident.name, item.span);\n+                    } else if sym_str == \"default deprecation note\" {\n+                        span_lint(\n+                            cx,\n+                            DEFAULT_DEPRECATION_REASON,\n+                            item.span,\n+                            &format!(\"the lint `{}` has the default deprecation reason\", item.ident.name),\n+                        );\n+                    }\n+                }\n+            }\n+        } else if let Some(macro_call) = root_macro_call_first_node(cx, item) {\n+            if !matches!(\n+                cx.tcx.item_name(macro_call.def_id).as_str(),\n+                \"impl_lint_pass\" | \"declare_lint_pass\"\n+            ) {\n+                return;\n+            }\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: None,\n+                items: impl_item_refs,\n+                ..\n+            }) = item.kind\n+            {\n+                let mut collector = LintCollector {\n+                    output: &mut self.registered_lints,\n+                    cx,\n+                };\n+                let body_id = cx.tcx.hir().body_owned_by(\n+                    cx.tcx.hir().local_def_id(\n+                        impl_item_refs\n+                            .iter()\n+                            .find(|iiref| iiref.ident.as_str() == \"get_lints\")\n+                            .expect(\"LintPass needs to implement get_lints\")\n+                            .id\n+                            .hir_id(),\n+                    ),\n+                );\n+                collector.visit_expr(cx.tcx.hir().body(body_id).value);\n+            }\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        if is_lint_allowed(cx, LINT_WITHOUT_LINT_PASS, CRATE_HIR_ID) {\n+            return;\n+        }\n+\n+        for (lint_name, &lint_span) in &self.declared_lints {\n+            // When using the `declare_tool_lint!` macro, the original `lint_span`'s\n+            // file points to \"<rustc macros>\".\n+            // `compiletest-rs` thinks that's an error in a different file and\n+            // just ignores it. This causes the test in compile-fail/lint_pass\n+            // not able to capture the error.\n+            // Therefore, we need to climb the macro expansion tree and find the\n+            // actual span that invoked `declare_tool_lint!`:\n+            let lint_span = lint_span.ctxt().outer_expn_data().call_site;\n+\n+            if !self.registered_lints.contains(lint_name) {\n+                span_lint(\n+                    cx,\n+                    LINT_WITHOUT_LINT_PASS,\n+                    lint_span,\n+                    &format!(\"the lint `{lint_name}` is not added to any `LintPass`\"),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n+    if let TyKind::Rptr(\n+        _,\n+        MutTy {\n+            ty: inner,\n+            mutbl: Mutability::Not,\n+        },\n+    ) = ty.kind\n+    {\n+        if let TyKind::Path(ref path) = inner.kind {\n+            if let Res::Def(DefKind::Struct, def_id) = cx.qpath_res(path, inner.hir_id) {\n+                return match_def_path(cx, def_id, &paths::LINT);\n+            }\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn check_invalid_clippy_version_attribute(cx: &LateContext<'_>, item: &'_ Item<'_>) {\n+    if let Some(value) = extract_clippy_version_value(cx, item) {\n+        // The `sym!` macro doesn't work as it only expects a single token.\n+        // It's better to keep it this way and have a direct `Symbol::intern` call here.\n+        if value == Symbol::intern(\"pre 1.29.0\") {\n+            return;\n+        }\n+\n+        if RustcVersion::parse(value.as_str()).is_err() {\n+            span_lint_and_help(\n+                cx,\n+                INVALID_CLIPPY_VERSION_ATTRIBUTE,\n+                item.span,\n+                \"this item has an invalid `clippy::version` attribute\",\n+                None,\n+                \"please use a valid semantic version, see `doc/adding_lints.md`\",\n+            );\n+        }\n+    } else {\n+        span_lint_and_help(\n+            cx,\n+            MISSING_CLIPPY_VERSION_ATTRIBUTE,\n+            item.span,\n+            \"this lint is missing the `clippy::version` attribute or version value\",\n+            None,\n+            \"please use a `clippy::version` attribute, see `doc/adding_lints.md`\",\n+        );\n+    }\n+}\n+\n+/// This function extracts the version value of a `clippy::version` attribute if the given value has\n+/// one\n+pub(super) fn extract_clippy_version_value(cx: &LateContext<'_>, item: &'_ Item<'_>) -> Option<Symbol> {\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    attrs.iter().find_map(|attr| {\n+        if_chain! {\n+            // Identify attribute\n+            if let ast::AttrKind::Normal(ref attr_kind) = &attr.kind;\n+            if let [tool_name, attr_name] = &attr_kind.item.path.segments[..];\n+            if tool_name.ident.name == sym::clippy;\n+            if attr_name.ident.name == sym::version;\n+            if let Some(version) = attr.value_str();\n+            then { Some(version) } else { None }\n+        }\n+    })\n+}\n+\n+struct LintCollector<'a, 'tcx> {\n+    output: &'a mut FxHashSet<Symbol>,\n+    cx: &'a LateContext<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn visit_path(&mut self, path: &'tcx Path<'_>, _: HirId) {\n+        if path.segments.len() == 1 {\n+            self.output.insert(path.segments[0].ident.name);\n+        }\n+    }\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n+}"}, {"sha": "d06a616e4b30b2d8ee796e9cc5fe5d967d99f6d3", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -8,7 +8,7 @@\n //! a simple mistake)\n \n use crate::renamed_lints::RENAMED_LINTS;\n-use crate::utils::internal_lints::{extract_clippy_version_value, is_lint_ref_type};\n+use crate::utils::internal_lints::lint_without_lint_pass::{extract_clippy_version_value, is_lint_ref_type};\n \n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::{match_type, walk_ptrs_ty_depth};\n@@ -532,7 +532,11 @@ fn parse_config_field_doc(doc_comment: &str) -> Option<(Vec<String>, String)> {\n \n             // Extract lints\n             doc_comment.make_ascii_lowercase();\n-            let lints: Vec<String> = doc_comment.split_off(DOC_START.len()).split(\", \").map(str::to_string).collect();\n+            let lints: Vec<String> = doc_comment\n+                .split_off(DOC_START.len())\n+                .split(\", \")\n+                .map(str::to_string)\n+                .collect();\n \n             // Format documentation correctly\n             // split off leading `.` from lint name list and indent for correct formatting"}, {"sha": "1e994e3f2b1713b1c2cef1502479177d8f7566e0", "filename": "clippy_lints/src/utils/internal_lints/msrv_attr_impl.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmsrv_attr_impl.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,63 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir_analysis::hir_ty_to_ty;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::{self, subst::GenericArgKind};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Check that the `extract_msrv_attr!` macro is used, when a lint has a MSRV.\n+    ///\n+    pub MISSING_MSRV_ATTR_IMPL,\n+    internal,\n+    \"checking if all necessary steps were taken when adding a MSRV to a lint\"\n+}\n+\n+declare_lint_pass!(MsrvAttrImpl => [MISSING_MSRV_ATTR_IMPL]);\n+\n+impl LateLintPass<'_> for MsrvAttrImpl {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if_chain! {\n+            if let hir::ItemKind::Impl(hir::Impl {\n+                of_trait: Some(lint_pass_trait_ref),\n+                self_ty,\n+                items,\n+                ..\n+            }) = &item.kind;\n+            if let Some(lint_pass_trait_def_id) = lint_pass_trait_ref.trait_def_id();\n+            let is_late_pass = match_def_path(cx, lint_pass_trait_def_id, &paths::LATE_LINT_PASS);\n+            if is_late_pass || match_def_path(cx, lint_pass_trait_def_id, &paths::EARLY_LINT_PASS);\n+            let self_ty = hir_ty_to_ty(cx.tcx, self_ty);\n+            if let ty::Adt(self_ty_def, _) = self_ty.kind();\n+            if self_ty_def.is_struct();\n+            if self_ty_def.all_fields().any(|f| {\n+                cx.tcx\n+                    .type_of(f.did)\n+                    .walk()\n+                    .filter(|t| matches!(t.unpack(), GenericArgKind::Type(_)))\n+                    .any(|t| match_type(cx, t.expect_ty(), &paths::RUSTC_VERSION))\n+            });\n+            if !items.iter().any(|item| item.ident.name == sym!(enter_lint_attrs));\n+            then {\n+                let context = if is_late_pass { \"LateContext\" } else { \"EarlyContext\" };\n+                let lint_pass = if is_late_pass { \"LateLintPass\" } else { \"EarlyLintPass\" };\n+                let span = cx.sess().source_map().span_through_char(item.span, '{');\n+                span_lint_and_sugg(\n+                    cx,\n+                    MISSING_MSRV_ATTR_IMPL,\n+                    span,\n+                    &format!(\"`extract_msrv_attr!` macro missing from `{lint_pass}` implementation\"),\n+                    &format!(\"add `extract_msrv_attr!({context})` to the `{lint_pass}` implementation\"),\n+                    format!(\"{}\\n    extract_msrv_attr!({context});\", snippet(cx, span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "2b13fad80665c73ae93e82fd7d1d8115e6c95d1e", "filename": "clippy_lints/src/utils/internal_lints/outer_expn_data_pass.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fouter_expn_data_pass.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,62 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::match_type;\n+use clippy_utils::{is_lint_allowed, method_calls, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::symbol::Symbol;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for calls to `cx.outer().expn_data()` and suggests to use\n+    /// the `cx.outer_expn_data()`\n+    ///\n+    /// ### Why is this bad?\n+    /// `cx.outer_expn_data()` is faster and more concise.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// expr.span.ctxt().outer().expn_data()\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// expr.span.ctxt().outer_expn_data()\n+    /// ```\n+    pub OUTER_EXPN_EXPN_DATA,\n+    internal,\n+    \"using `cx.outer_expn().expn_data()` instead of `cx.outer_expn_data()`\"\n+}\n+\n+declare_lint_pass!(OuterExpnDataPass => [OUTER_EXPN_EXPN_DATA]);\n+\n+impl<'tcx> LateLintPass<'tcx> for OuterExpnDataPass {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, OUTER_EXPN_EXPN_DATA, expr.hir_id) {\n+            return;\n+        }\n+\n+        let (method_names, arg_lists, spans) = method_calls(expr, 2);\n+        let method_names: Vec<&str> = method_names.iter().map(Symbol::as_str).collect();\n+        if_chain! {\n+            if let [\"expn_data\", \"outer_expn\"] = method_names.as_slice();\n+            let (self_arg, args) = arg_lists[1];\n+            if args.is_empty();\n+            let self_ty = cx.typeck_results().expr_ty(self_arg).peel_refs();\n+            if match_type(cx, self_ty, &paths::SYNTAX_CONTEXT);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    OUTER_EXPN_EXPN_DATA,\n+                    spans[1].with_hi(expr.span.hi()),\n+                    \"usage of `outer_expn().expn_data()`\",\n+                    \"try\",\n+                    \"outer_expn_data()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "5899b94e16ba241e078300d5760ca6537a525ec3", "filename": "clippy_lints/src/utils/internal_lints/produce_ice.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fproduce_ice.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,37 @@\n+use rustc_ast::ast::NodeId;\n+use rustc_ast::visit::FnKind;\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Not an actual lint. This lint is only meant for testing our customized internal compiler\n+    /// error message by calling `panic`.\n+    ///\n+    /// ### Why is this bad?\n+    /// ICE in large quantities can damage your teeth\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// \ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\ud83c\udf66\n+    /// ```\n+    pub PRODUCE_ICE,\n+    internal,\n+    \"this message should not appear anywhere as we ICE before and don't emit the lint\"\n+}\n+\n+declare_lint_pass!(ProduceIce => [PRODUCE_ICE]);\n+\n+impl EarlyLintPass for ProduceIce {\n+    fn check_fn(&mut self, _: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n+        assert!(!is_trigger_fn(fn_kind), \"Would you like some help with that?\");\n+    }\n+}\n+\n+fn is_trigger_fn(fn_kind: FnKind<'_>) -> bool {\n+    match fn_kind {\n+        FnKind::Fn(_, ident, ..) => ident.name.as_str() == \"it_looks_like_you_are_trying_to_kill_clippy\",\n+        FnKind::Closure(..) => false,\n+    }\n+}"}, {"sha": "4cf76f53625510fd7989b0a6aa450c202df14c0c", "filename": "clippy_lints/src/utils/internal_lints/unnecessary_def_path.rs", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Funnecessary_def_path.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,343 @@\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{def_path_res, is_lint_allowed, match_any_def_paths, peel_hir_expr_refs};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Namespace, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Expr, ExprKind, Local, Mutability, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{self, AssocKind, DefIdTree, Ty};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::Span;\n+\n+use std::str;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n+    ///\n+    /// ### Why is this bad?\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// utils::match_type(cx, ty, &paths::VEC)\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n+    /// ```\n+    pub UNNECESSARY_DEF_PATH,\n+    internal,\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n+}\n+\n+impl_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n+\n+#[derive(Default)]\n+pub struct UnnecessaryDefPath {\n+    array_def_ids: FxHashSet<(DefId, Span)>,\n+    linted_def_ids: FxHashSet<DefId>,\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n+            return;\n+        }\n+\n+        match expr.kind {\n+            ExprKind::Call(func, args) => self.check_call(cx, func, args, expr.span),\n+            ExprKind::Array(elements) => self.check_array(cx, elements, expr.span),\n+            _ => {},\n+        }\n+    }\n+\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(def_id, span) in &self.array_def_ids {\n+            if self.linted_def_ids.contains(&def_id) {\n+                continue;\n+            }\n+\n+            let (msg, sugg) = if let Some(sym) = cx.tcx.get_diagnostic_name(def_id) {\n+                (\"diagnostic item\", format!(\"sym::{sym}\"))\n+            } else if let Some(sym) = get_lang_item_name(cx, def_id) {\n+                (\"language item\", format!(\"LangItem::{sym}\"))\n+            } else {\n+                continue;\n+            };\n+\n+            span_lint_and_help(\n+                cx,\n+                UNNECESSARY_DEF_PATH,\n+                span,\n+                &format!(\"hardcoded path to a {msg}\"),\n+                None,\n+                &format!(\"convert all references to use `{sugg}`\"),\n+            );\n+        }\n+    }\n+}\n+\n+impl UnnecessaryDefPath {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_call(&mut self, cx: &LateContext<'_>, func: &Expr<'_>, args: &[Expr<'_>], span: Span) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if_chain! {\n+            if let [cx_arg, def_arg, args @ ..] = args;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n+            // Extract the path to the matched type\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = inherent_def_path_res(cx, &segments[..]);\n+            then {\n+                // Check if the target item is a diagnostic item or LangItem.\n+                #[rustfmt::skip]\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(item_name) = get_lang_item_name(cx, def_id) {\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    },\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    },\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"),\n+                        has_ctor,\n+                    ),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor,\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) => {\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false)\n+                    },\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) => (\n+                        format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"),\n+                        false,\n+                    ),\n+                    (2, Item::LangItem(item)) => (\n+                        format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"),\n+                        false,\n+                    ),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) => (\n+                        format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(cx, UNNECESSARY_DEF_PATH, span, msg, |diag| {\n+                    diag.span_suggestion(span, \"try\", sugg, app);\n+                    if with_note {\n+                        diag.help(\n+                            \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\",\n+                        );\n+                    }\n+                });\n+\n+                self.linted_def_ids.insert(def_id);\n+            }\n+        }\n+    }\n+\n+    fn check_array(&mut self, cx: &LateContext<'_>, elements: &[Expr<'_>], span: Span) {\n+        let Some(path) = path_from_array(elements) else { return };\n+\n+        if let Some(def_id) = inherent_def_path_res(cx, &path.iter().map(AsRef::as_ref).collect::<Vec<_>>()) {\n+            self.array_def_ids.insert((def_id, span));\n+        }\n+    }\n+}\n+\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+            Res::Local(hir_id) => {\n+                let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n+                }\n+            },\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n+            },\n+            _ => None,\n+        },\n+        ExprKind::Array(exprs) => path_from_array(exprs),\n+        _ => None,\n+    }\n+}\n+\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n+\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n+}\n+\n+fn path_from_array(exprs: &[Expr<'_>]) -> Option<Vec<String>> {\n+    exprs\n+        .iter()\n+        .map(|expr| {\n+            if let ExprKind::Lit(lit) = &expr.kind {\n+                if let LitKind::Str(sym, _) = lit.node {\n+                    return Some((*sym.as_str()).to_owned());\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect()\n+}\n+\n+// def_path_res will match field names before anything else, but for this we want to match\n+// inherent functions first.\n+fn inherent_def_path_res(cx: &LateContext<'_>, segments: &[&str]) -> Option<DefId> {\n+    def_path_res(cx, segments, None).opt_def_id().map(|def_id| {\n+        if cx.tcx.def_kind(def_id) == DefKind::Field {\n+            let method_name = *segments.last().unwrap();\n+            cx.tcx\n+                .def_key(def_id)\n+                .parent\n+                .and_then(|parent_idx| {\n+                    cx.tcx\n+                        .inherent_impls(DefId {\n+                            index: parent_idx,\n+                            krate: def_id.krate,\n+                        })\n+                        .iter()\n+                        .find_map(|impl_id| {\n+                            cx.tcx.associated_items(*impl_id).find_by_name_and_kind(\n+                                cx.tcx,\n+                                Ident::from_str(method_name),\n+                                AssocKind::Fn,\n+                                *impl_id,\n+                            )\n+                        })\n+                })\n+                .map_or(def_id, |item| item.def_id)\n+        } else {\n+            def_id\n+        }\n+    })\n+}\n+\n+fn get_lang_item_name(cx: &LateContext<'_>, def_id: DefId) -> Option<Symbol> {\n+    if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+        let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"], Some(Namespace::TypeNS)).def_id();\n+        let item_name = cx\n+            .tcx\n+            .adt_def(lang_items)\n+            .variants()\n+            .iter()\n+            .nth(lang_item)\n+            .unwrap()\n+            .name;\n+        Some(item_name)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "cd8575c90e86caaad333ab8f76ecce98d82b3ae8", "filename": "clippy_utils/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fattrs.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -136,7 +136,7 @@ pub fn get_unique_inner_attr(sess: &Session, attrs: &[ast::Attribute], name: &'s\n                     .emit();\n             },\n             ast::AttrStyle::Outer => {\n-                sess.span_err(attr.span, &format!(\"`{name}` cannot be an outer attribute\"));\n+                sess.span_err(attr.span, format!(\"`{name}` cannot be an outer attribute\"));\n             },\n         }\n     }"}, {"sha": "07e4ef6a2fef3c4c8f6ed67d9ad1cb80205cc36e", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -136,17 +136,49 @@ impl Constant {\n             (&Self::F64(l), &Self::F64(r)) => l.partial_cmp(&r),\n             (&Self::F32(l), &Self::F32(r)) => l.partial_cmp(&r),\n             (&Self::Bool(ref l), &Self::Bool(ref r)) => Some(l.cmp(r)),\n-            (&Self::Tuple(ref l), &Self::Tuple(ref r)) | (&Self::Vec(ref l), &Self::Vec(ref r)) => iter::zip(l, r)\n-                .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n-                .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n-                .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+            (&Self::Tuple(ref l), &Self::Tuple(ref r)) if l.len() == r.len() => match *cmp_type.kind() {\n+                ty::Tuple(tys) if tys.len() == l.len() => l\n+                    .iter()\n+                    .zip(r)\n+                    .zip(tys)\n+                    .map(|((li, ri), cmp_type)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                    .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                    .unwrap_or_else(|| Some(l.len().cmp(&r.len()))),\n+                _ => None,\n+            },\n+            (&Self::Vec(ref l), &Self::Vec(ref r)) => {\n+                let cmp_type = match *cmp_type.kind() {\n+                    ty::Array(ty, _) | ty::Slice(ty) => ty,\n+                    _ => return None,\n+                };\n+                iter::zip(l, r)\n+                    .map(|(li, ri)| Self::partial_cmp(tcx, cmp_type, li, ri))\n+                    .find(|r| r.map_or(true, |o| o != Ordering::Equal))\n+                    .unwrap_or_else(|| Some(l.len().cmp(&r.len())))\n+            },\n             (&Self::Repeat(ref lv, ref ls), &Self::Repeat(ref rv, ref rs)) => {\n-                match Self::partial_cmp(tcx, cmp_type, lv, rv) {\n+                match Self::partial_cmp(\n+                    tcx,\n+                    match *cmp_type.kind() {\n+                        ty::Array(ty, _) => ty,\n+                        _ => return None,\n+                    },\n+                    lv,\n+                    rv,\n+                ) {\n                     Some(Equal) => Some(ls.cmp(rs)),\n                     x => x,\n                 }\n             },\n-            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(tcx, cmp_type, lb, rb),\n+            (&Self::Ref(ref lb), &Self::Ref(ref rb)) => Self::partial_cmp(\n+                tcx,\n+                match *cmp_type.kind() {\n+                    ty::Ref(_, ty, _) => ty,\n+                    _ => return None,\n+                },\n+                lb,\n+                rb,\n+            ),\n             // TODO: are there any useful inter-type orderings?\n             _ => None,\n         }"}, {"sha": "95b3e651e2b539db6d3ba8f27426df10ae759636", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -120,7 +120,7 @@ fn expr_eagerness<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> EagernessS\n                             .expr_ty(e)\n                             .has_significant_drop(self.cx.tcx, self.cx.param_env)\n                         {\n-                            self.eagerness = Lazy;\n+                            self.eagerness = ForceNoChange;\n                             return;\n                         }\n                     },"}, {"sha": "14b1b6eacc6e1994db4fe440c3a89afa2bcfa323", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -25,10 +25,12 @@ extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n extern crate rustc_hir_analysis;\n+extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_middle;\n+extern crate rustc_mir_dataflow;\n extern crate rustc_parse_format;\n extern crate rustc_session;\n extern crate rustc_span;\n@@ -48,6 +50,7 @@ pub mod eager_or_lazy;\n pub mod higher;\n mod hir_utils;\n pub mod macros;\n+pub mod mir;\n pub mod msrvs;\n pub mod numeric_literal;\n pub mod paths;\n@@ -122,7 +125,7 @@ pub fn parse_msrv(msrv: &str, sess: Option<&Session>, span: Option<Span>) -> Opt\n         return Some(version);\n     } else if let Some(sess) = sess {\n         if let Some(span) = span {\n-            sess.span_err(span, &format!(\"`{msrv}` is not a valid Rust version\"));\n+            sess.span_err(span, format!(\"`{msrv}` is not a valid Rust version\"));\n         }\n     }\n     None\n@@ -815,13 +818,37 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n                 false\n             }\n         },\n-        ExprKind::Call(repl_func, _) => is_default_equivalent_call(cx, repl_func),\n+        ExprKind::Call(repl_func, []) => is_default_equivalent_call(cx, repl_func),\n+        ExprKind::Call(from_func, [ref arg]) => is_default_equivalent_from(cx, from_func, arg),\n         ExprKind::Path(qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, e.hir_id), OptionNone),\n         ExprKind::AddrOf(rustc_hir::BorrowKind::Ref, _, expr) => matches!(expr.kind, ExprKind::Array([])),\n         _ => false,\n     }\n }\n \n+fn is_default_equivalent_from(cx: &LateContext<'_>, from_func: &Expr<'_>, arg: &Expr<'_>) -> bool {\n+    if let ExprKind::Path(QPath::TypeRelative(ty, seg)) = from_func.kind &&\n+        seg.ident.name == sym::from\n+    {\n+        match arg.kind {\n+            ExprKind::Lit(hir::Lit {\n+                node: LitKind::Str(ref sym, _),\n+                ..\n+            }) => return sym.is_empty() && is_path_diagnostic_item(cx, ty, sym::String),\n+            ExprKind::Array([]) => return is_path_diagnostic_item(cx, ty, sym::Vec),\n+            ExprKind::Repeat(_, ArrayLen::Body(len)) => {\n+                if let ExprKind::Lit(ref const_lit) = cx.tcx.hir().body(len.body).value.kind &&\n+                    let LitKind::Int(v, _) = const_lit.node\n+                {\n+                        return v == 0 && is_path_diagnostic_item(cx, ty, sym::Vec);\n+                }\n+            }\n+            _ => (),\n+        }\n+    }\n+    false\n+}\n+\n /// Checks if the top level expression can be moved into a closure as is.\n /// Currently checks for:\n /// * Break/Continue outside the given loop HIR ids.\n@@ -1739,6 +1766,7 @@ pub fn any_parent_is_automatically_derived(tcx: TyCtxt<'_>, node: HirId) -> bool\n /// ```rust,ignore\n /// if let Some(args) = match_function_call(cx, cmp_max_call, &paths::CMP_MAX);\n /// ```\n+/// This function is deprecated. Use [`match_function_call_with_def_id`].\n pub fn match_function_call<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx Expr<'_>,\n@@ -1756,6 +1784,22 @@ pub fn match_function_call<'tcx>(\n     None\n }\n \n+pub fn match_function_call_with_def_id<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    fun_def_id: DefId,\n+) -> Option<&'tcx [Expr<'tcx>]> {\n+    if_chain! {\n+        if let ExprKind::Call(fun, args) = expr.kind;\n+        if let ExprKind::Path(ref qpath) = fun.kind;\n+        if cx.qpath_res(qpath, fun.hir_id).opt_def_id() == Some(fun_def_id);\n+        then {\n+            return Some(args);\n+        }\n+    };\n+    None\n+}\n+\n /// Checks if the given `DefId` matches any of the paths. Returns the index of matching path, if\n /// any.\n ///"}, {"sha": "9a682fbe604ff7b3891a4f88c20e3cdaff38d52d", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 37, "deletions": 6, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -627,7 +627,7 @@ pub enum Count<'tcx> {\n     /// `FormatParamKind::Numbered`.\n     Param(FormatParam<'tcx>),\n     /// Not specified.\n-    Implied,\n+    Implied(Option<Span>),\n }\n \n impl<'tcx> Count<'tcx> {\n@@ -638,8 +638,10 @@ impl<'tcx> Count<'tcx> {\n         inner: Option<rpf::InnerSpan>,\n         values: &FormatArgsValues<'tcx>,\n     ) -> Option<Self> {\n+        let span = inner.map(|inner| span_from_inner(values.format_string_span, inner));\n+\n         Some(match count {\n-            rpf::Count::CountIs(val) => Self::Is(val, span_from_inner(values.format_string_span, inner?)),\n+            rpf::Count::CountIs(val) => Self::Is(val, span?),\n             rpf::Count::CountIsName(name, _) => Self::Param(FormatParam::new(\n                 FormatParamKind::Named(Symbol::intern(name)),\n                 usage,\n@@ -661,12 +663,12 @@ impl<'tcx> Count<'tcx> {\n                 inner?,\n                 values,\n             )?),\n-            rpf::Count::CountImplied => Self::Implied,\n+            rpf::Count::CountImplied => Self::Implied(span),\n         })\n     }\n \n     pub fn is_implied(self) -> bool {\n-        matches!(self, Count::Implied)\n+        matches!(self, Count::Implied(_))\n     }\n \n     pub fn param(self) -> Option<FormatParam<'tcx>> {\n@@ -675,6 +677,14 @@ impl<'tcx> Count<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    pub fn span(self) -> Option<Span> {\n+        match self {\n+            Count::Is(_, span) => Some(span),\n+            Count::Param(param) => Some(param.span),\n+            Count::Implied(span) => span,\n+        }\n+    }\n }\n \n /// Specification for the formatting of an argument in the format string. See\n@@ -738,8 +748,13 @@ impl<'tcx> FormatSpec<'tcx> {\n     /// Returns true if this format spec is unchanged from the default. e.g. returns true for `{}`,\n     /// `{foo}` and `{2}`, but false for `{:?}`, `{foo:5}` and `{3:.5}`\n     pub fn is_default(&self) -> bool {\n-        self.r#trait == sym::Display\n-            && self.width.is_implied()\n+        self.r#trait == sym::Display && self.is_default_for_trait()\n+    }\n+\n+    /// Has no other formatting specifiers than setting the format trait. returns true for `{}`,\n+    /// `{foo}`, `{:?}`, but false for `{foo:5}`, `{3:.5?}`\n+    pub fn is_default_for_trait(&self) -> bool {\n+        self.width.is_implied()\n             && self.precision.is_implied()\n             && self.align == Alignment::AlignUnknown\n             && self.flags == 0\n@@ -757,6 +772,22 @@ pub struct FormatArg<'tcx> {\n     pub span: Span,\n }\n \n+impl<'tcx> FormatArg<'tcx> {\n+    /// Span of the `:` and format specifiers\n+    ///\n+    /// ```ignore\n+    /// format!(\"{:.}\"), format!(\"{foo:.}\")\n+    ///           ^^                  ^^\n+    /// ```\n+    pub fn format_span(&self) -> Span {\n+        let base = self.span.data();\n+\n+        // `base.hi` is `{...}|`, subtract 1 byte (the length of '}') so that it points before the closing\n+        // brace `{...|}`\n+        Span::new(self.param.span.hi(), base.hi - BytePos(1), base.ctxt, base.parent)\n+    }\n+}\n+\n /// A parsed `format_args!` expansion.\n #[derive(Debug)]\n pub struct FormatArgsExpn<'tcx> {"}, {"sha": "d262b335d99d3adf782a59eaa02f88c84db50908", "filename": "clippy_utils/src/mir/maybe_storage_live.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fmaybe_storage_live.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fmaybe_storage_live.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fmaybe_storage_live.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,52 @@\n+use rustc_index::bit_set::BitSet;\n+use rustc_middle::mir;\n+use rustc_mir_dataflow::{AnalysisDomain, CallReturnPlaces, GenKill, GenKillAnalysis};\n+\n+/// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n+#[derive(Copy, Clone)]\n+pub(super) struct MaybeStorageLive;\n+\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n+    type Domain = BitSet<mir::Local>;\n+    const NAME: &'static str = \"maybe_storage_live\";\n+\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        // bottom = dead\n+        BitSet::new_empty(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut Self::Domain) {\n+        for arg in body.args_iter() {\n+            state.insert(arg);\n+        }\n+    }\n+}\n+\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    type Idx = mir::Local;\n+\n+    fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n+        match stmt.kind {\n+            mir::StatementKind::StorageLive(l) => trans.gen(l),\n+            mir::StatementKind::StorageDead(l) => trans.kill(l),\n+            _ => (),\n+        }\n+    }\n+\n+    fn terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _loc: mir::Location,\n+    ) {\n+    }\n+\n+    fn call_return_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _return_places: CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+        // Nothing to do when a call returns successfully\n+    }\n+}"}, {"sha": "c8aa6f3e595df4123462e752e771ade784227713", "filename": "clippy_utils/src/mir/mod.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fmod.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,165 @@\n+use rustc_hir::{Expr, HirId};\n+use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    traversal, Body, InlineAsmOperand, Local, Location, Place, StatementKind, TerminatorKind, START_BLOCK,\n+};\n+use rustc_middle::ty::TyCtxt;\n+\n+mod maybe_storage_live;\n+\n+mod possible_borrower;\n+pub use possible_borrower::PossibleBorrowerMap;\n+\n+mod possible_origin;\n+\n+mod transitive_relation;\n+\n+#[derive(Clone, Debug, Default)]\n+pub struct LocalUsage {\n+    /// The locations where the local is used, if any.\n+    pub local_use_locs: Vec<Location>,\n+    /// The locations where the local is consumed or mutated, if any.\n+    pub local_consume_or_mutate_locs: Vec<Location>,\n+}\n+\n+pub fn visit_local_usage(locals: &[Local], mir: &Body<'_>, location: Location) -> Option<Vec<LocalUsage>> {\n+    let init = vec![\n+        LocalUsage {\n+            local_use_locs: Vec::new(),\n+            local_consume_or_mutate_locs: Vec::new(),\n+        };\n+        locals.len()\n+    ];\n+\n+    traversal::ReversePostorder::new(mir, location.block).try_fold(init, |usage, (tbb, tdata)| {\n+        // Give up on loops\n+        if tdata.terminator().successors().any(|s| s == location.block) {\n+            return None;\n+        }\n+\n+        let mut v = V {\n+            locals,\n+            location,\n+            results: usage,\n+        };\n+        v.visit_basic_block_data(tbb, tdata);\n+        Some(v.results)\n+    })\n+}\n+\n+struct V<'a> {\n+    locals: &'a [Local],\n+    location: Location,\n+    results: Vec<LocalUsage>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for V<'a> {\n+    fn visit_place(&mut self, place: &Place<'tcx>, ctx: PlaceContext, loc: Location) {\n+        if loc.block == self.location.block && loc.statement_index <= self.location.statement_index {\n+            return;\n+        }\n+\n+        let local = place.local;\n+\n+        for (i, self_local) in self.locals.iter().enumerate() {\n+            if local == *self_local {\n+                if !matches!(\n+                    ctx,\n+                    PlaceContext::MutatingUse(MutatingUseContext::Drop) | PlaceContext::NonUse(_)\n+                ) {\n+                    self.results[i].local_use_locs.push(loc);\n+                }\n+                if matches!(\n+                    ctx,\n+                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Move)\n+                        | PlaceContext::MutatingUse(MutatingUseContext::Borrow)\n+                ) {\n+                    self.results[i].local_consume_or_mutate_locs.push(loc);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// Convenience wrapper around `visit_local_usage`.\n+pub fn used_exactly_once(mir: &rustc_middle::mir::Body<'_>, local: rustc_middle::mir::Local) -> Option<bool> {\n+    visit_local_usage(\n+        &[local],\n+        mir,\n+        Location {\n+            block: START_BLOCK,\n+            statement_index: 0,\n+        },\n+    )\n+    .map(|mut vec| {\n+        let LocalUsage { local_use_locs, .. } = vec.remove(0);\n+        local_use_locs\n+            .into_iter()\n+            .filter(|location| !is_local_assignment(mir, local, *location))\n+            .count()\n+            == 1\n+    })\n+}\n+\n+/// Returns the `mir::Body` containing the node associated with `hir_id`.\n+#[allow(clippy::module_name_repetitions)]\n+pub fn enclosing_mir(tcx: TyCtxt<'_>, hir_id: HirId) -> &Body<'_> {\n+    let body_owner_local_def_id = tcx.hir().enclosing_body_owner(hir_id);\n+    tcx.optimized_mir(body_owner_local_def_id.to_def_id())\n+}\n+\n+/// Tries to determine the `Local` corresponding to `expr`, if any.\n+/// This function is expensive and should be used sparingly.\n+pub fn expr_local(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> Option<Local> {\n+    let mir = enclosing_mir(tcx, expr.hir_id);\n+    mir.local_decls.iter_enumerated().find_map(|(local, local_decl)| {\n+        if local_decl.source_info.span == expr.span {\n+            Some(local)\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+/// Returns a vector of `mir::Location` where `local` is assigned. Each statement referred to has\n+/// kind `StatementKind::Assign`.\n+pub fn local_assignments(mir: &Body<'_>, local: Local) -> Vec<Location> {\n+    let mut locations = Vec::new();\n+    for (block, data) in mir.basic_blocks.iter_enumerated() {\n+        for statement_index in 0..=data.statements.len() {\n+            let location = Location { block, statement_index };\n+            if is_local_assignment(mir, local, location) {\n+                locations.push(location);\n+            }\n+        }\n+    }\n+    locations\n+}\n+\n+// `is_local_assignment` is based on `is_place_assignment`:\n+// https://github.com/rust-lang/rust/blob/b7413511dc85ec01ef4b91785f86614589ac6103/compiler/rustc_middle/src/mir/visit.rs#L1350\n+fn is_local_assignment(mir: &Body<'_>, local: Local, location: Location) -> bool {\n+    let Location { block, statement_index } = location;\n+    let basic_block = &mir.basic_blocks[block];\n+    if statement_index < basic_block.statements.len() {\n+        let statement = &basic_block.statements[statement_index];\n+        if let StatementKind::Assign(box (place, _)) = statement.kind {\n+            place.as_local() == Some(local)\n+        } else {\n+            false\n+        }\n+    } else {\n+        let terminator = basic_block.terminator();\n+        match &terminator.kind {\n+            TerminatorKind::Call { destination, .. } => destination.as_local() == Some(local),\n+            TerminatorKind::InlineAsm { operands, .. } => operands.iter().any(|operand| {\n+                if let InlineAsmOperand::Out { place: Some(place), .. } = operand {\n+                    place.as_local() == Some(local)\n+                } else {\n+                    false\n+                }\n+            }),\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "25717bf3d2fee5329bffe8128ed66a95acdf3904", "filename": "clippy_utils/src/mir/possible_borrower.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,241 @@\n+use super::{\n+    maybe_storage_live::MaybeStorageLive, possible_origin::PossibleOriginVisitor,\n+    transitive_relation::TransitiveRelation,\n+};\n+use crate::ty::is_copy;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::{BitSet, HybridBitSet};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::{self, visit::Visitor as _, Mutability};\n+use rustc_middle::ty::{self, visit::TypeVisitor};\n+use rustc_mir_dataflow::{Analysis, ResultsCursor};\n+use std::ops::ControlFlow;\n+\n+/// Collects the possible borrowers of each local.\n+/// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n+/// possible borrowers of `a`.\n+#[allow(clippy::module_name_repetitions)]\n+struct PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    possible_borrower: TransitiveRelation,\n+    body: &'b mir::Body<'tcx>,\n+    cx: &'a LateContext<'tcx>,\n+    possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+}\n+\n+impl<'a, 'b, 'tcx> PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    fn new(\n+        cx: &'a LateContext<'tcx>,\n+        body: &'b mir::Body<'tcx>,\n+        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    ) -> Self {\n+        Self {\n+            possible_borrower: TransitiveRelation::default(),\n+            cx,\n+            body,\n+            possible_origin,\n+        }\n+    }\n+\n+    fn into_map(\n+        self,\n+        cx: &'a LateContext<'tcx>,\n+        maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n+    ) -> PossibleBorrowerMap<'b, 'tcx> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n+            if !borrowers.is_empty() {\n+                map.insert(row, borrowers);\n+            }\n+        }\n+\n+        let bs = BitSet::new_empty(self.body.local_decls.len());\n+        PossibleBorrowerMap {\n+            map,\n+            maybe_live,\n+            bitset: (bs.clone(), bs),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            mir::Rvalue::Ref(_, _, borrowed) => {\n+                self.possible_borrower.add(borrowed.local, lhs);\n+            },\n+            other => {\n+                if ContainsRegion\n+                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n+                    .is_continue()\n+                {\n+                    return;\n+                }\n+                rvalue_locals(other, |rhs| {\n+                    if lhs != rhs {\n+                        self.possible_borrower.add(rhs, lhs);\n+                    }\n+                });\n+            },\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n+        if let mir::TerminatorKind::Call {\n+            args,\n+            destination: mir::Place { local: dest, .. },\n+            ..\n+        } = &terminator.kind\n+        {\n+            // TODO add doc\n+            // If the call returns something with lifetimes,\n+            // let's conservatively assume the returned value contains lifetime of all the arguments.\n+            // For example, given `let y: Foo<'a> = foo(x)`, `y` is considered to be a possible borrower of `x`.\n+\n+            let mut immutable_borrowers = vec![];\n+            let mut mutable_borrowers = vec![];\n+\n+            for op in args {\n+                match op {\n+                    mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n+                        if let ty::Ref(_, _, Mutability::Mut) = self.body.local_decls[p.local].ty.kind() {\n+                            mutable_borrowers.push(p.local);\n+                        } else {\n+                            immutable_borrowers.push(p.local);\n+                        }\n+                    },\n+                    mir::Operand::Constant(..) => (),\n+                }\n+            }\n+\n+            let mut mutable_variables: Vec<mir::Local> = mutable_borrowers\n+                .iter()\n+                .filter_map(|r| self.possible_origin.get(r))\n+                .flat_map(HybridBitSet::iter)\n+                .collect();\n+\n+            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+                mutable_variables.push(*dest);\n+            }\n+\n+            for y in mutable_variables {\n+                for x in &immutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+                for x in &mutable_borrowers {\n+                    self.possible_borrower.add(*x, y);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct ContainsRegion;\n+\n+impl TypeVisitor<'_> for ContainsRegion {\n+    type BreakTy = ();\n+\n+    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<Self::BreakTy> {\n+        ControlFlow::BREAK\n+    }\n+}\n+\n+fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n+    use rustc_middle::mir::Rvalue::{Aggregate, BinaryOp, Cast, CheckedBinaryOp, Repeat, UnaryOp, Use};\n+\n+    let mut visit_op = |op: &mir::Operand<'_>| match op {\n+        mir::Operand::Copy(p) | mir::Operand::Move(p) => visit(p.local),\n+        mir::Operand::Constant(..) => (),\n+    };\n+\n+    match rvalue {\n+        Use(op) | Repeat(op, _) | Cast(_, op, _) | UnaryOp(_, op) => visit_op(op),\n+        Aggregate(_, ops) => ops.iter().for_each(visit_op),\n+        BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n+            visit_op(lhs);\n+            visit_op(rhs);\n+        },\n+        _ => (),\n+    }\n+}\n+\n+/// Result of `PossibleBorrowerVisitor`.\n+#[allow(clippy::module_name_repetitions)]\n+pub struct PossibleBorrowerMap<'b, 'tcx> {\n+    /// Mapping `Local -> its possible borrowers`\n+    pub map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n+    // Caches to avoid allocation of `BitSet` on every query\n+    pub bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n+}\n+\n+impl<'a, 'b, 'tcx> PossibleBorrowerMap<'b, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'tcx>, mir: &'b mir::Body<'tcx>) -> Self {\n+        let possible_origin = {\n+            let mut vis = PossibleOriginVisitor::new(mir);\n+            vis.visit_body(mir);\n+            vis.into_map(cx)\n+        };\n+        let maybe_storage_live_result = MaybeStorageLive\n+            .into_engine(cx.tcx, mir)\n+            .pass_name(\"redundant_clone\")\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(mir);\n+        let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n+        vis.visit_body(mir);\n+        vis.into_map(cx, maybe_storage_live_result)\n+    }\n+\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n+    pub fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n+        self.bounded_borrowers(borrowers, borrowers, borrowed, at)\n+    }\n+\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` includes at least `below`\n+    /// but no more than `above`.\n+    pub fn bounded_borrowers(\n+        &mut self,\n+        below: &[mir::Local],\n+        above: &[mir::Local],\n+        borrowed: mir::Local,\n+        at: mir::Location,\n+    ) -> bool {\n+        self.maybe_live.seek_after_primary_effect(at);\n+\n+        self.bitset.0.clear();\n+        let maybe_live = &mut self.maybe_live;\n+        if let Some(bitset) = self.map.get(&borrowed) {\n+            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n+                self.bitset.0.insert(b);\n+            }\n+        } else {\n+            return false;\n+        }\n+\n+        self.bitset.1.clear();\n+        for b in below {\n+            self.bitset.1.insert(*b);\n+        }\n+\n+        if !self.bitset.0.superset(&self.bitset.1) {\n+            return false;\n+        }\n+\n+        for b in above {\n+            self.bitset.0.remove(*b);\n+        }\n+\n+        self.bitset.0.is_empty()\n+    }\n+\n+    pub fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {\n+        self.maybe_live.seek_after_primary_effect(at);\n+        self.maybe_live.contains(local)\n+    }\n+}"}, {"sha": "8e7513d740ab397e3172f23bf31bbfec264009eb", "filename": "clippy_utils/src/mir/possible_origin.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fpossible_origin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Fpossible_origin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fpossible_origin.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,59 @@\n+use super::transitive_relation::TransitiveRelation;\n+use crate::ty::is_copy;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::HybridBitSet;\n+use rustc_lint::LateContext;\n+use rustc_middle::mir;\n+\n+/// Collect possible borrowed for every `&mut` local.\n+/// For example, `_1 = &mut _2` generate _1: {_2,...}\n+/// Known Problems: not sure all borrowed are tracked\n+#[allow(clippy::module_name_repetitions)]\n+pub(super) struct PossibleOriginVisitor<'a, 'tcx> {\n+    possible_origin: TransitiveRelation,\n+    body: &'a mir::Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n+    pub fn new(body: &'a mir::Body<'tcx>) -> Self {\n+        Self {\n+            possible_origin: TransitiveRelation::default(),\n+            body,\n+        }\n+    }\n+\n+    pub fn into_map(self, cx: &LateContext<'tcx>) -> FxHashMap<mir::Local, HybridBitSet<mir::Local>> {\n+        let mut map = FxHashMap::default();\n+        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n+            if is_copy(cx, self.body.local_decls[row].ty) {\n+                continue;\n+            }\n+\n+            let mut borrowers = self.possible_origin.reachable_from(row, self.body.local_decls.len());\n+            borrowers.remove(mir::Local::from_usize(0));\n+            if !borrowers.is_empty() {\n+                map.insert(row, borrowers);\n+            }\n+        }\n+        map\n+    }\n+}\n+\n+impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n+    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n+        let lhs = place.local;\n+        match rvalue {\n+            // Only consider `&mut`, which can modify origin place\n+            mir::Rvalue::Ref(_, rustc_middle::mir::BorrowKind::Mut { .. }, borrowed) |\n+            // _2: &mut _;\n+            // _3 = move _2\n+            mir::Rvalue::Use(mir::Operand::Move(borrowed))  |\n+            // _3 = move _2 as &mut _;\n+            mir::Rvalue::Cast(_, mir::Operand::Move(borrowed), _)\n+                => {\n+                self.possible_origin.add(lhs, borrowed.local);\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "7fe2960739fa252d0843cb7b9604198bdd442d41", "filename": "clippy_utils/src/mir/transitive_relation.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fmir%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Ftransitive_relation.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,29 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_index::bit_set::HybridBitSet;\n+use rustc_middle::mir;\n+\n+#[derive(Default)]\n+pub(super) struct TransitiveRelation {\n+    relations: FxHashMap<mir::Local, Vec<mir::Local>>,\n+}\n+\n+impl TransitiveRelation {\n+    pub fn add(&mut self, a: mir::Local, b: mir::Local) {\n+        self.relations.entry(a).or_default().push(b);\n+    }\n+\n+    pub fn reachable_from(&self, a: mir::Local, domain_size: usize) -> HybridBitSet<mir::Local> {\n+        let mut seen = HybridBitSet::new_empty(domain_size);\n+        let mut stack = vec![a];\n+        while let Some(u) = stack.pop() {\n+            if let Some(edges) = self.relations.get(&u) {\n+                for &v in edges {\n+                    if seen.insert(v) {\n+                        stack.push(v);\n+                    }\n+                }\n+            }\n+        }\n+        seen\n+    }\n+}"}, {"sha": "c5dcd7b31f58e7126b48d236669b5252d8b5ce03", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -69,12 +69,13 @@ impl<'a> NumericLiteral<'a> {\n \n     #[must_use]\n     pub fn new(lit: &'a str, suffix: Option<&'a str>, float: bool) -> Self {\n+        let unsigned_lit = lit.trim_start_matches('-');\n         // Determine delimiter for radix prefix, if present, and radix.\n-        let radix = if lit.starts_with(\"0x\") {\n+        let radix = if unsigned_lit.starts_with(\"0x\") {\n             Radix::Hexadecimal\n-        } else if lit.starts_with(\"0b\") {\n+        } else if unsigned_lit.starts_with(\"0b\") {\n             Radix::Binary\n-        } else if lit.starts_with(\"0o\") {\n+        } else if unsigned_lit.starts_with(\"0o\") {\n             Radix::Octal\n         } else {\n             Radix::Decimal"}, {"sha": "bc851473430454d8b1dc0f4bdf7dece213606e4c", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -16,56 +16,40 @@ pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n #[cfg(feature = \"internal\")]\n pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n-pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n-pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];\n pub const BTREEMAP_CONTAINS_KEY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"contains_key\"];\n-pub const BTREEMAP_ENTRY: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"entry\", \"Entry\"];\n pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\", \"BTreeMap\", \"insert\"];\n pub const BTREESET_ITER: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"set\", \"BTreeSet\", \"iter\"];\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n-pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CORE_ITER_COLLECT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"collect\"];\n pub const CORE_ITER_CLONED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"cloned\"];\n pub const CORE_ITER_COPIED: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"copied\"];\n pub const CORE_ITER_FILTER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"filter\"];\n-pub const CORE_ITER_INTO_ITER: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"IntoIterator\", \"into_iter\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"alloc\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n-/// Preferably use the diagnostic item `sym::deref_method` where possible\n-pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_LINT_PASS: [&str; 3] = [\"rustc_lint\", \"passes\", \"EarlyLintPass\"];\n pub const EXIT: [&str; 3] = [\"std\", \"process\", \"exit\"];\n pub const F32_EPSILON: [&str; 4] = [\"core\", \"f32\", \"<impl f32>\", \"EPSILON\"];\n pub const F64_EPSILON: [&str; 4] = [\"core\", \"f64\", \"<impl f64>\", \"EPSILON\"];\n-pub const FILE: [&str; 3] = [\"std\", \"fs\", \"File\"];\n-pub const FILE_TYPE: [&str; 3] = [\"std\", \"fs\", \"FileType\"];\n-pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_ITERATOR_METHOD: [&str; 6] = [\"core\", \"iter\", \"traits\", \"collect\", \"FromIterator\", \"from_iter\"];\n pub const FROM_STR_METHOD: [&str; 5] = [\"core\", \"str\", \"traits\", \"FromStr\", \"from_str\"];\n-pub const FUTURE_FROM_GENERATOR: [&str; 3] = [\"core\", \"future\", \"from_generator\"];\n #[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const FUTURES_IO_ASYNCREADEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncReadExt\"];\n #[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const FUTURES_IO_ASYNCWRITEEXT: [&str; 3] = [\"futures_util\", \"io\", \"AsyncWriteExt\"];\n pub const HASHMAP_CONTAINS_KEY: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"contains_key\"];\n-pub const HASHMAP_ENTRY: [&str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"Entry\"];\n pub const HASHMAP_INSERT: [&str; 6] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\", \"insert\"];\n pub const HASHSET_ITER: [&str; 6] = [\"std\", \"collections\", \"hash\", \"set\", \"HashSet\", \"iter\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT: [&str; 3] = [\"rustc_span\", \"symbol\", \"Ident\"];\n #[cfg(feature = \"internal\")]\n pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n-pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n-pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n-pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n #[cfg(feature = \"internal\")]\n pub const KW_MODULE: [&str; 3] = [\"rustc_span\", \"symbol\", \"kw\"];\n@@ -76,13 +60,7 @@ pub const LATE_LINT_PASS: [&str; 3] = [\"rustc_lint\", \"passes\", \"LateLintPass\"];\n #[cfg(feature = \"internal\")]\n pub const LINT: [&str; 2] = [\"rustc_lint_defs\", \"Lint\"];\n pub const MEM_SWAP: [&str; 3] = [\"core\", \"mem\", \"swap\"];\n-pub const MUTEX_GUARD: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"MutexGuard\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n-/// Preferably use the diagnostic item `sym::Option` where possible\n-pub const OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-pub const OPTION_NONE: [&str; 4] = [\"core\", \"option\", \"Option\", \"None\"];\n-pub const OPTION_SOME: [&str; 4] = [\"core\", \"option\", \"Option\", \"Some\"];\n-pub const ORD: [&str; 3] = [\"core\", \"cmp\", \"Ord\"];\n pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\", \"as_os_str\"];\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARKING_LOT_MUTEX_GUARD: [&str; 3] = [\"lock_api\", \"mutex\", \"MutexGuard\"];\n@@ -95,8 +73,6 @@ pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n #[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];\n pub const POLL: [&str; 4] = [\"core\", \"task\", \"poll\", \"Poll\"];\n-pub const POLL_PENDING: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Pending\"];\n-pub const POLL_READY: [&str; 5] = [\"core\", \"task\", \"poll\", \"Poll\", \"Ready\"];\n pub const PTR_COPY: [&str; 3] = [\"core\", \"intrinsics\", \"copy\"];\n pub const PTR_COPY_NONOVERLAPPING: [&str; 3] = [\"core\", \"intrinsics\", \"copy_nonoverlapping\"];\n pub const PTR_EQ: [&str; 3] = [\"core\", \"ptr\", \"eq\"];\n@@ -119,26 +95,14 @@ pub const RANGE_ARGUMENT_TRAIT: [&str; 3] = [\"core\", \"ops\", \"RangeBounds\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const REFCELL_REF: [&str; 3] = [\"core\", \"cell\", \"Ref\"];\n pub const REFCELL_REFMUT: [&str; 3] = [\"core\", \"cell\", \"RefMut\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_BYTES_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"bytes\", \"RegexSet\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_NEW: [&str; 4] = [\"regex\", \"re_unicode\", \"Regex\", \"new\"];\n-#[expect(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const REGEX_SET_NEW: [&str; 5] = [\"regex\", \"re_set\", \"unicode\", \"RegexSet\", \"new\"];\n-/// Preferably use the diagnostic item `sym::Result` where possible\n-pub const RESULT: [&str; 3] = [\"core\", \"result\", \"Result\"];\n-pub const RESULT_ERR: [&str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n-pub const RESULT_OK: [&str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n #[cfg(feature = \"internal\")]\n pub const RUSTC_VERSION: [&str; 2] = [\"rustc_semver\", \"RustcVersion\"];\n-pub const RWLOCK_READ_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockReadGuard\"];\n-pub const RWLOCK_WRITE_GUARD: [&str; 4] = [\"std\", \"sync\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const SERDE_DESERIALIZE: [&str; 3] = [\"serde\", \"de\", \"Deserialize\"];\n pub const SERDE_DE_VISITOR: [&str; 3] = [\"serde\", \"de\", \"Visitor\"];\n pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts\"];"}, {"sha": "01c2b11f65b08324a0dc5635776852e7ca9038b2", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,7 +1,9 @@\n //! Contains utility functions to generate suggestions.\n #![deny(clippy::missing_docs_in_private_items)]\n \n-use crate::source::{snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite};\n+use crate::source::{\n+    snippet, snippet_opt, snippet_with_applicability, snippet_with_context, snippet_with_macro_callsite,\n+};\n use crate::ty::expr_sig;\n use crate::{get_parent_expr_for_hir, higher};\n use rustc_ast::util::parser::AssocOp;\n@@ -110,7 +112,7 @@ impl<'a> Sugg<'a> {\n         if expr.span.ctxt() == ctxt {\n             Self::hir_from_snippet(expr, |span| snippet(cx, span, default))\n         } else {\n-            let snip = snippet_with_applicability(cx, expr.span, default, applicability);\n+            let (snip, _) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n             Sugg::NonParen(snip)\n         }\n     }"}, {"sha": "95b20d7f02427a9e4c5a6f319f3e90307cfd8724", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -345,7 +345,7 @@ impl Crate {\n                 clippy_args.push(opt);\n             }\n         } else {\n-            clippy_args.extend(&[\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n+            clippy_args.extend([\"-Wclippy::pedantic\", \"-Wclippy::cargo\"])\n         }\n \n         if lint_filter.is_empty() {\n@@ -457,15 +457,11 @@ fn build_clippy() {\n /// Read a `lintcheck_crates.toml` file\n fn read_crates(toml_path: &Path) -> (Vec<CrateSource>, RecursiveOptions) {\n     let toml_content: String =\n-        std::fs::read_to_string(&toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n+        std::fs::read_to_string(toml_path).unwrap_or_else(|_| panic!(\"Failed to read {}\", toml_path.display()));\n     let crate_list: SourceList =\n         toml::from_str(&toml_content).unwrap_or_else(|e| panic!(\"Failed to parse {}: \\n{}\", toml_path.display(), e));\n     // parse the hashmap of the toml file into a list of crates\n-    let tomlcrates: Vec<TomlCrate> = crate_list\n-        .crates\n-        .into_iter()\n-        .map(|(_cratename, tomlcrate)| tomlcrate)\n-        .collect();\n+    let tomlcrates: Vec<TomlCrate> = crate_list.crates.into_values().collect();\n \n     // flatten TomlCrates into CrateSources (one TomlCrates may represent several versions of a crate =>\n     // multiple Cratesources)\n@@ -602,10 +598,10 @@ fn main() {\n     ) {\n         let shared_target_dir = \"target/lintcheck/shared_target_dir\";\n         // if we get an Err here, the shared target dir probably does simply not exist\n-        if let Ok(metadata) = std::fs::metadata(&shared_target_dir) {\n+        if let Ok(metadata) = std::fs::metadata(shared_target_dir) {\n             if metadata.is_dir() {\n                 println!(\"Clippy is newer than lint check logs, clearing lintcheck shared target dir...\");\n-                std::fs::remove_dir_all(&shared_target_dir)\n+                std::fs::remove_dir_all(shared_target_dir)\n                     .expect(\"failed to remove target/lintcheck/shared_target_dir\");\n             }\n         }\n@@ -779,7 +775,7 @@ fn read_stats_from_file(file_path: &Path) -> HashMap<String, usize> {\n fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, usize>, lint_filter: &Vec<String>) {\n     let same_in_both_hashmaps = old_stats\n         .iter()\n-        .filter(|(old_key, old_val)| new_stats.get::<&String>(&old_key) == Some(old_val))\n+        .filter(|(old_key, old_val)| new_stats.get::<&String>(old_key) == Some(old_val))\n         .map(|(k, v)| (k.to_string(), *v))\n         .collect::<Vec<(String, usize)>>();\n \n@@ -797,24 +793,24 @@ fn print_stats(old_stats: HashMap<String, usize>, new_stats: HashMap<&String, us\n     // list all new counts  (key is in new stats but not in old stats)\n     new_stats_deduped\n         .iter()\n-        .filter(|(new_key, _)| old_stats_deduped.get::<str>(&new_key).is_none())\n+        .filter(|(new_key, _)| old_stats_deduped.get::<str>(new_key).is_none())\n         .for_each(|(new_key, new_value)| {\n             println!(\"{} 0 => {}\", new_key, new_value);\n         });\n \n     // list all changed counts (key is in both maps but value differs)\n     new_stats_deduped\n         .iter()\n-        .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(&new_key).is_some())\n+        .filter(|(new_key, _new_val)| old_stats_deduped.get::<str>(new_key).is_some())\n         .for_each(|(new_key, new_val)| {\n-            let old_val = old_stats_deduped.get::<str>(&new_key).unwrap();\n+            let old_val = old_stats_deduped.get::<str>(new_key).unwrap();\n             println!(\"{} {} => {}\", new_key, old_val, new_val);\n         });\n \n     // list all gone counts (key is in old status but not in new stats)\n     old_stats_deduped\n         .iter()\n-        .filter(|(old_key, _)| new_stats_deduped.get::<&String>(&old_key).is_none())\n+        .filter(|(old_key, _)| new_stats_deduped.get::<&String>(old_key).is_none())\n         .filter(|(old_key, _)| lint_filter.is_empty() || lint_filter.contains(old_key))\n         .for_each(|(old_key, old_value)| {\n             println!(\"{} {} => 0\", old_key, old_value);\n@@ -832,12 +828,12 @@ fn create_dirs(krate_download_dir: &Path, extract_dir: &Path) {\n             panic!(\"cannot create lintcheck target dir\");\n         }\n     });\n-    std::fs::create_dir(&krate_download_dir).unwrap_or_else(|err| {\n+    std::fs::create_dir(krate_download_dir).unwrap_or_else(|err| {\n         if err.kind() != ErrorKind::AlreadyExists {\n             panic!(\"cannot create crate download dir\");\n         }\n     });\n-    std::fs::create_dir(&extract_dir).unwrap_or_else(|err| {\n+    std::fs::create_dir(extract_dir).unwrap_or_else(|err| {\n         if err.kind() != ErrorKind::AlreadyExists {\n             panic!(\"cannot create crate extraction dir\");\n         }\n@@ -863,7 +859,7 @@ fn lintcheck_test() {\n         \"lintcheck/test_sources.toml\",\n     ];\n     let status = std::process::Command::new(\"cargo\")\n-        .args(&args)\n+        .args(args)\n         .current_dir(\"..\") // repo root\n         .status();\n     //.output();"}, {"sha": "0a9fb1ecd840c5d586fe184b01b71aaa0cab8262", "filename": "src/docs.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -28,6 +28,7 @@ docs! {\n     \"approx_constant\",\n     \"arithmetic_side_effects\",\n     \"as_conversions\",\n+    \"as_ptr_cast_mut\",\n     \"as_underscore\",\n     \"assertions_on_constants\",\n     \"assertions_on_result_states\",\n@@ -60,6 +61,7 @@ docs! {\n     \"cast_enum_constructor\",\n     \"cast_enum_truncation\",\n     \"cast_lossless\",\n+    \"cast_nan_to_int\",\n     \"cast_possible_truncation\",\n     \"cast_possible_wrap\",\n     \"cast_precision_loss\",\n@@ -257,6 +259,7 @@ docs! {\n     \"manual_async_fn\",\n     \"manual_bits\",\n     \"manual_clamp\",\n+    \"manual_filter\",\n     \"manual_filter_map\",\n     \"manual_find\",\n     \"manual_find_map\",\n@@ -391,6 +394,7 @@ docs! {\n     \"panic\",\n     \"panic_in_result_fn\",\n     \"panicking_unwrap\",\n+    \"partial_pub_fields\",\n     \"partialeq_ne_impl\",\n     \"partialeq_to_none\",\n     \"path_buf_push_overwrite\",\n@@ -553,6 +557,7 @@ docs! {\n     \"unseparated_literal_suffix\",\n     \"unsound_collection_transmute\",\n     \"unused_async\",\n+    \"unused_format_specs\",\n     \"unused_io_amount\",\n     \"unused_peekable\",\n     \"unused_rounding\","}, {"sha": "228dde996bb2f41f5985bc3ebe984fcc25031af4", "filename": "src/docs/as_ptr_cast_mut.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fas_ptr_cast_mut.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fas_ptr_cast_mut.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fas_ptr_cast_mut.txt?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,19 @@\n+### What it does\n+Checks for the result of a `&self`-taking `as_ptr` being cast to a mutable pointer\n+\n+### Why is this bad?\n+Since `as_ptr` takes a `&self`, the pointer won't have write permissions unless interior\n+mutability is used, making it unlikely that having it as a mutable pointer is correct.\n+\n+### Example\n+```\n+let string = String::with_capacity(1);\n+let ptr = string.as_ptr() as *mut u8;\n+unsafe { ptr.write(4) }; // UNDEFINED BEHAVIOUR\n+```\n+Use instead:\n+```\n+let mut string = String::with_capacity(1);\n+let ptr = string.as_mut_ptr();\n+unsafe { ptr.write(4) };\n+```\n\\ No newline at end of file"}, {"sha": "1c670c7733377f04f3dcaefdd4158b7ff59332f2", "filename": "src/docs/box_default.txt", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fbox_default.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fbox_default.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fbox_default.txt?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -7,12 +7,6 @@ First, it's more complex, involving two calls instead of one.\n Second, `Box::default()` can be faster\n [in certain cases](https://nnethercote.github.io/perf-book/standard-library-types.html#box).\n \n-### Known problems\n-The lint may miss some cases (e.g. Box::new(String::from(\"\"))).\n-On the other hand, it will trigger on cases where the `default`\n-code comes from a macro that does something different based on\n-e.g. target operating system.\n-\n ### Example\n ```\n let x: Box<String> = Box::new(Default::default());"}, {"sha": "122f5da0c921883aed797ca3880a4c71daf5f867", "filename": "src/docs/cast_nan_to_int.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fcast_nan_to_int.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fcast_nan_to_int.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fcast_nan_to_int.txt?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,15 @@\n+### What it does\n+Checks for a known NaN float being cast to an integer\n+\n+### Why is this bad?\n+NaNs are cast into zero, so one could simply use this and make the\n+code more readable. The lint could also hint at a programmer error.\n+\n+### Example\n+```\n+let _: (0.0_f32 / 0.0) as u64;\n+```\n+Use instead:\n+```\n+let _: = 0_u64;\n+```\n\\ No newline at end of file"}, {"sha": "19a4d9319d94b700d1e88671e4e8f9f6ae6c20ef", "filename": "src/docs/manual_filter.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fmanual_filter.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fmanual_filter.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fmanual_filter.txt?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,21 @@\n+### What it does\n+Checks for usages of `match` which could be implemented using `filter`\n+\n+### Why is this bad?\n+Using the `filter` method is clearer and more concise.\n+\n+### Example\n+```\n+match Some(0) {\n+    Some(x) => if x % 2 == 0 {\n+                    Some(x)\n+               } else {\n+                    None\n+                },\n+    None => None,\n+};\n+```\n+Use instead:\n+```\n+Some(0).filter(|&x| x % 2 == 0);\n+```\n\\ No newline at end of file"}, {"sha": "b529adf1547de3fb465c03a63cda7640301c36a8", "filename": "src/docs/partial_pub_fields.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fpartial_pub_fields.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Fpartial_pub_fields.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Fpartial_pub_fields.txt?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,27 @@\n+### What it does\n+Checks whether partial fields of a struct are public.\n+\n+Either make all fields of a type public, or make none of them public\n+\n+### Why is this bad?\n+Most types should either be:\n+* Abstract data types: complex objects with opaque implementation which guard\n+interior invariants and expose intentionally limited API to the outside world.\n+* Data:\u2009relatively simple objects which group a bunch of related attributes together.\n+\n+### Example\n+```\n+pub struct Color {\n+    pub r: u8,\n+    pub g: u8,\n+    b: u8,\n+}\n+```\n+Use instead:\n+```\n+pub struct Color {\n+    pub r: u8,\n+    pub g: u8,\n+    pub b: u8,\n+}\n+```\n\\ No newline at end of file"}, {"sha": "77be3a2fb170d1d81e7818e074b59e4dbcab936a", "filename": "src/docs/unused_format_specs.txt", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Funused_format_specs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/src%2Fdocs%2Funused_format_specs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdocs%2Funused_format_specs.txt?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,24 @@\n+### What it does\n+Detects [formatting parameters] that have no effect on the output of\n+`format!()`, `println!()` or similar macros.\n+\n+### Why is this bad?\n+Shorter format specifiers are easier to read, it may also indicate that\n+an expected formatting operation such as adding padding isn't happening.\n+\n+### Example\n+```\n+println!(\"{:.}\", 1.0);\n+\n+println!(\"not padded: {:5}\", format_args!(\"...\"));\n+```\n+Use instead:\n+```\n+println!(\"{}\", 1.0);\n+\n+println!(\"not padded: {}\", format_args!(\"...\"));\n+// OR\n+println!(\"padded: {:5}\", format!(\"...\"));\n+```\n+\n+[formatting parameters]: https://doc.rust-lang.org/std/fmt/index.html#formatting-parameters\n\\ No newline at end of file"}, {"sha": "c10ee969c014620b996dafa32d94367d10db825a", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -283,7 +283,7 @@ fn run_ui_cargo() {\n                 env::set_current_dir(&src_path)?;\n \n                 let cargo_toml_path = case.path().join(\"Cargo.toml\");\n-                let cargo_content = fs::read(&cargo_toml_path)?;\n+                let cargo_content = fs::read(cargo_toml_path)?;\n                 let cargo_parsed: toml::Value = toml::from_str(\n                     std::str::from_utf8(&cargo_content).expect(\"`Cargo.toml` is not a valid utf-8 file!\"),\n                 )"}, {"sha": "07c5941013c1af5d6b89a661100c9b2a42e01801", "filename": "tests/ui-internal/custom_ice_message.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Fcustom_ice_message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Fcustom_ice_message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcustom_ice_message.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints.rs\n+thread 'rustc' panicked at 'Would you like some help with that?', clippy_lints/src/utils/internal_lints/produce_ice.rs:28:9\n note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n \n error: internal compiler error: unexpected panic"}, {"sha": "9a9790a4bae51ec7c99447c4a4ddfa46f1080e77", "filename": "tests/ui-internal/invalid_paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Finvalid_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Finvalid_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finvalid_paths.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n+#![allow(clippy::missing_clippy_version_attribute, clippy::unnecessary_def_path)]\n \n mod paths {\n     // Good path"}, {"sha": "cbbb4652306415b7256435bcdc5f83256c47c6b4", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -28,17 +28,17 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n \n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n \n fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n     let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n     let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n \n-    #[allow(unused)]\n+    #[allow(unused, clippy::unnecessary_def_path)]\n     let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n     let _ = is_type_diagnostic_item(cx, ty, sym::Rc);\n "}, {"sha": "f17fed6c6530410cc139dfe34c4dfa85d155917d", "filename": "tests/ui-internal/unnecessary_def_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -28,17 +28,17 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::Ty;\n \n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-#[allow(unused)]\n+#[allow(unused, clippy::unnecessary_def_path)]\n const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n \n fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n     let _ = match_type(cx, ty, &OPTION);\n     let _ = match_type(cx, ty, RESULT);\n     let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n \n-    #[allow(unused)]\n+    #[allow(unused, clippy::unnecessary_def_path)]\n     let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n     let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n "}, {"sha": "b5ff3a5420561a8d7f473e843d26d73e77c9ede4", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,16 @@\n+#![feature(rustc_private)]\n+#![allow(unused)]\n+#![warn(clippy::unnecessary_def_path)]\n+\n+extern crate rustc_hir;\n+\n+use rustc_hir::LangItem;\n+\n+fn main() {\n+    const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+    const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+    const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+\n+    // Don't lint, not yet a diagnostic or language item\n+    const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n+}"}, {"sha": "af46d87bf676e42816316dcf94aef37abb063059", "filename": "tests/ui-internal/unnecessary_def_path_hardcoded_path.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path_hardcoded_path.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,27 @@\n+error: hardcoded path to a language item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:11:40\n+   |\n+LL |     const DEREF_MUT_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"DerefMut\"];\n+   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `LangItem::DerefMut`\n+   = note: `-D clippy::unnecessary-def-path` implied by `-D warnings`\n+\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:12:43\n+   |\n+LL |     const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::deref_method`\n+\n+error: hardcoded path to a diagnostic item\n+  --> $DIR/unnecessary_def_path_hardcoded_path.rs:10:36\n+   |\n+LL |     const DEREF_TRAIT: [&str; 4] = [\"core\", \"ops\", \"deref\", \"Deref\"];\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: convert all references to use `sym::Deref`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "0d1d9258433b215589e77f03437e3578f3631c2f", "filename": "tests/ui/as_ptr_cast_mut.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fas_ptr_cast_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fas_ptr_cast_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fas_ptr_cast_mut.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,37 @@\n+#![allow(unused)]\n+#![warn(clippy::as_ptr_cast_mut)]\n+#![allow(clippy::wrong_self_convention)]\n+\n+struct MutPtrWrapper(Vec<u8>);\n+impl MutPtrWrapper {\n+    fn as_ptr(&mut self) -> *const u8 {\n+        self.0.as_mut_ptr() as *const u8\n+    }\n+}\n+\n+struct Covariant<T>(*const T);\n+impl<T> Covariant<T> {\n+    fn as_ptr(self) -> *const T {\n+        self.0\n+    }\n+}\n+\n+fn main() {\n+    let mut string = String::new();\n+    let _ = string.as_ptr() as *mut u8;\n+    let _: *mut i8 = string.as_ptr() as *mut _;\n+    let _ = string.as_ptr() as *const i8;\n+    let _ = string.as_mut_ptr();\n+    let _ = string.as_mut_ptr() as *mut u8;\n+    let _ = string.as_mut_ptr() as *const u8;\n+\n+    let nn = std::ptr::NonNull::new(4 as *mut u8).unwrap();\n+    let _ = nn.as_ptr() as *mut u8;\n+\n+    let mut wrap = MutPtrWrapper(Vec::new());\n+    let _ = wrap.as_ptr() as *mut u8;\n+\n+    let mut local = 4;\n+    let ref_with_write_perm = Covariant(std::ptr::addr_of_mut!(local) as *const _);\n+    let _ = ref_with_write_perm.as_ptr() as *mut u8;\n+}"}, {"sha": "2189c3d2f8556d702b708d94f64957390d18369a", "filename": "tests/ui/as_ptr_cast_mut.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fas_ptr_cast_mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fas_ptr_cast_mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fas_ptr_cast_mut.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,16 @@\n+error: casting the result of `as_ptr` to *mut u8\n+  --> $DIR/as_ptr_cast_mut.rs:21:13\n+   |\n+LL |     let _ = string.as_ptr() as *mut u8;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `string.as_mut_ptr()`\n+   |\n+   = note: `-D clippy::as-ptr-cast-mut` implied by `-D warnings`\n+\n+error: casting the result of `as_ptr` to *mut i8\n+  --> $DIR/as_ptr_cast_mut.rs:22:22\n+   |\n+LL |     let _: *mut i8 = string.as_ptr() as *mut _;\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with: `string.as_mut_ptr()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "27ad538f24d8ce4ca06a41032ed0e701e70f4eb1", "filename": "tests/ui/author.stdout", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,14 +1,12 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Cast(expr, cast_ty) = init.kind;\n-    if let TyKind::Path(ref qpath) = cast_ty.kind;\n-    if match_qpath(qpath, &[\"char\"]);\n-    if let ExprKind::Lit(ref lit) = expr.kind;\n-    if let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"x\";\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Cast(expr, cast_ty) = init.kind\n+    && let TyKind::Path(ref qpath) = cast_ty.kind\n+    && match_qpath(qpath, &[\"char\"])\n+    && let ExprKind::Lit(ref lit) = expr.kind\n+    && let LitKind::Int(69, LitIntType::Unsuffixed) = lit.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind\n+    && name.as_str() == \"x\"\n+{\n+    // report your lint here\n }"}, {"sha": "9de0550d81d0051654cab991cee3a6b240eaeb34", "filename": "tests/ui/author/blocks.stdout", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fblocks.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fblocks.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fblocks.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,64 +1,58 @@\n-if_chain! {\n-    if let ExprKind::Block(block, None) = expr.kind;\n-    if block.stmts.len() == 3;\n-    if let StmtKind::Local(local) = block.stmts[0].kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Lit(ref lit) = init.kind;\n-    if let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"x\";\n-    if let StmtKind::Local(local1) = block.stmts[1].kind;\n-    if let Some(init1) = local1.init;\n-    if let ExprKind::Lit(ref lit1) = init1.kind;\n-    if let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local1.pat.kind;\n-    if name1.as_str() == \"_t\";\n-    if let StmtKind::Semi(e) = block.stmts[2].kind;\n-    if let ExprKind::Unary(UnOp::Neg, inner) = e.kind;\n-    if let ExprKind::Path(ref qpath) = inner.kind;\n-    if match_qpath(qpath, &[\"x\"]);\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Block(block, None) = expr.kind\n+    && block.stmts.len() == 3\n+    && let StmtKind::Local(local) = block.stmts[0].kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Lit(ref lit) = init.kind\n+    && let LitKind::Int(42, LitIntType::Signed(IntTy::I32)) = lit.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind\n+    && name.as_str() == \"x\"\n+    && let StmtKind::Local(local1) = block.stmts[1].kind\n+    && let Some(init1) = local1.init\n+    && let ExprKind::Lit(ref lit1) = init1.kind\n+    && let LitKind::Float(_, LitFloatType::Suffixed(FloatTy::F32)) = lit1.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local1.pat.kind\n+    && name1.as_str() == \"_t\"\n+    && let StmtKind::Semi(e) = block.stmts[2].kind\n+    && let ExprKind::Unary(UnOp::Neg, inner) = e.kind\n+    && let ExprKind::Path(ref qpath) = inner.kind\n+    && match_qpath(qpath, &[\"x\"])\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::Block(block, None) = expr.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(local) = block.stmts[0].kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Call(func, args) = init.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if match_qpath(qpath, &[\"String\", \"new\"]);\n-    if args.is_empty();\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind;\n-    if name.as_str() == \"expr\";\n-    if let Some(trailing_expr) = block.expr;\n-    if let ExprKind::Call(func1, args1) = trailing_expr.kind;\n-    if let ExprKind::Path(ref qpath1) = func1.kind;\n-    if match_qpath(qpath1, &[\"drop\"]);\n-    if args1.len() == 1;\n-    if let ExprKind::Path(ref qpath2) = args1[0].kind;\n-    if match_qpath(qpath2, &[\"expr\"]);\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Block(block, None) = expr.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Local(local) = block.stmts[0].kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Call(func, args) = init.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && match_qpath(qpath, &[\"String\", \"new\"])\n+    && args.is_empty()\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local.pat.kind\n+    && name.as_str() == \"expr\"\n+    && let Some(trailing_expr) = block.expr\n+    && let ExprKind::Call(func1, args1) = trailing_expr.kind\n+    && let ExprKind::Path(ref qpath1) = func1.kind\n+    && match_qpath(qpath1, &[\"drop\"])\n+    && args1.len() == 1\n+    && let ExprKind::Path(ref qpath2) = args1[0].kind\n+    && match_qpath(qpath2, &[\"expr\"])\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kind;\n-    if let FnRetTy::DefaultReturn(_) = fn_decl.output;\n-    let expr1 = &cx.tcx.hir().body(body_id).value;\n-    if let ExprKind::Call(func, args) = expr1.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _));\n-    if args.len() == 1;\n-    if let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind;\n-    if let FnRetTy::DefaultReturn(_) = fn_decl1.output;\n-    let expr2 = &cx.tcx.hir().body(body_id1).value;\n-    if let ExprKind::Block(block, None) = expr2.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Closure(CaptureBy::Value, fn_decl, body_id, _, None) = expr.kind\n+    && let FnRetTy::DefaultReturn(_) = fn_decl.output\n+    && expr1 = &cx.tcx.hir().body(body_id).value\n+    && let ExprKind::Call(func, args) = expr1.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::FromGenerator, _))\n+    && args.len() == 1\n+    && let ExprKind::Closure(CaptureBy::Value, fn_decl1, body_id1, _, Some(Movability::Static)) = args[0].kind\n+    && let FnRetTy::DefaultReturn(_) = fn_decl1.output\n+    && expr2 = &cx.tcx.hir().body(body_id1).value\n+    && let ExprKind::Block(block, None) = expr2.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }"}, {"sha": "f040f6330a64d8687bb53fb592b7342387e6c857", "filename": "tests/ui/author/call.stdout", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fcall.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fcall.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fcall.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,16 +1,14 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Call(func, args) = init.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if match_qpath(qpath, &[\"{{root}}\", \"std\", \"cmp\", \"min\"]);\n-    if args.len() == 2;\n-    if let ExprKind::Lit(ref lit) = args[0].kind;\n-    if let LitKind::Int(3, LitIntType::Unsuffixed) = lit.node;\n-    if let ExprKind::Lit(ref lit1) = args[1].kind;\n-    if let LitKind::Int(4, LitIntType::Unsuffixed) = lit1.node;\n-    if let PatKind::Wild = local.pat.kind;\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Call(func, args) = init.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && match_qpath(qpath, &[\"{{root}}\", \"std\", \"cmp\", \"min\"])\n+    && args.len() == 2\n+    && let ExprKind::Lit(ref lit) = args[0].kind\n+    && let LitKind::Int(3, LitIntType::Unsuffixed) = lit.node\n+    && let ExprKind::Lit(ref lit1) = args[1].kind\n+    && let LitKind::Int(4, LitIntType::Unsuffixed) = lit1.node\n+    && let PatKind::Wild = local.pat.kind\n+{\n+    // report your lint here\n }"}, {"sha": "5d79618820d80595dd9db6a50bfebb3c42d7df90", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 44, "deletions": 48, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,50 +1,46 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::If(cond, then, Some(else_expr)) = init.kind;\n-    if let ExprKind::DropTemps(expr) = cond.kind;\n-    if let ExprKind::Lit(ref lit) = expr.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Block(block, None) = then.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Binary(op, left, right) = e.kind;\n-    if BinOpKind::Eq == op.node;\n-    if let ExprKind::Lit(ref lit1) = left.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Lit(ref lit2) = right.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit2.node;\n-    if block.expr.is_none();\n-    if let ExprKind::Block(block1, None) = else_expr.kind;\n-    if block1.stmts.len() == 1;\n-    if let StmtKind::Semi(e1) = block1.stmts[0].kind;\n-    if let ExprKind::Binary(op1, left1, right1) = e1.kind;\n-    if BinOpKind::Eq == op1.node;\n-    if let ExprKind::Lit(ref lit3) = left1.kind;\n-    if let LitKind::Int(2, LitIntType::Unsuffixed) = lit3.node;\n-    if let ExprKind::Lit(ref lit4) = right1.kind;\n-    if let LitKind::Int(2, LitIntType::Unsuffixed) = lit4.node;\n-    if block1.expr.is_none();\n-    if let PatKind::Wild = local.pat.kind;\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::If(cond, then, Some(else_expr)) = init.kind\n+    && let ExprKind::DropTemps(expr) = cond.kind\n+    && let ExprKind::Lit(ref lit) = expr.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Block(block, None) = then.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Binary(op, left, right) = e.kind\n+    && BinOpKind::Eq == op.node\n+    && let ExprKind::Lit(ref lit1) = left.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Lit(ref lit2) = right.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit2.node\n+    && block.expr.is_none()\n+    && let ExprKind::Block(block1, None) = else_expr.kind\n+    && block1.stmts.len() == 1\n+    && let StmtKind::Semi(e1) = block1.stmts[0].kind\n+    && let ExprKind::Binary(op1, left1, right1) = e1.kind\n+    && BinOpKind::Eq == op1.node\n+    && let ExprKind::Lit(ref lit3) = left1.kind\n+    && let LitKind::Int(2, LitIntType::Unsuffixed) = lit3.node\n+    && let ExprKind::Lit(ref lit4) = right1.kind\n+    && let LitKind::Int(2, LitIntType::Unsuffixed) = lit4.node\n+    && block1.expr.is_none()\n+    && let PatKind::Wild = local.pat.kind\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::If(cond, then, Some(else_expr)) = expr.kind;\n-    if let ExprKind::Let(let_expr) = cond.kind;\n-    if let PatKind::Lit(lit_expr) = let_expr.pat.kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Path(ref qpath) = let_expr.init.kind;\n-    if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, None) = then.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    if let ExprKind::Block(block1, None) = else_expr.kind;\n-    if block1.stmts.is_empty();\n-    if block1.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::If(cond, then, Some(else_expr)) = expr.kind\n+    && let ExprKind::Let(let_expr) = cond.kind\n+    && let PatKind::Lit(lit_expr) = let_expr.pat.kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Path(ref qpath) = let_expr.init.kind\n+    && match_qpath(qpath, &[\"a\"])\n+    && let ExprKind::Block(block, None) = then.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+    && let ExprKind::Block(block1, None) = else_expr.kind\n+    && block1.stmts.is_empty()\n+    && block1.expr.is_none()\n+{\n+    // report your lint here\n }"}, {"sha": "32a3127b85a3e3f50546165e796ef8864f0c160e", "filename": "tests/ui/author/issue_3849.stdout", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fissue_3849.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fissue_3849.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fissue_3849.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,14 +1,12 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Call(func, args) = init.kind;\n-    if let ExprKind::Path(ref qpath) = func.kind;\n-    if match_qpath(qpath, &[\"std\", \"mem\", \"transmute\"]);\n-    if args.len() == 1;\n-    if let ExprKind::Path(ref qpath1) = args[0].kind;\n-    if match_qpath(qpath1, &[\"ZPTR\"]);\n-    if let PatKind::Wild = local.pat.kind;\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Call(func, args) = init.kind\n+    && let ExprKind::Path(ref qpath) = func.kind\n+    && match_qpath(qpath, &[\"std\", \"mem\", \"transmute\"])\n+    && args.len() == 1\n+    && let ExprKind::Path(ref qpath1) = args[0].kind\n+    && match_qpath(qpath1, &[\"ZPTR\"])\n+    && let PatKind::Wild = local.pat.kind\n+{\n+    // report your lint here\n }"}, {"sha": "94a6436ed5479a0fe90f3ec26147199f229c8db3", "filename": "tests/ui/author/loop.stdout", "status": "modified", "additions": 95, "deletions": 107, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Floop.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Floop.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Floop.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,113 +1,101 @@\n-if_chain! {\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = pat.kind;\n-    if name.as_str() == \"y\";\n-    if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    if fields[0].ident.as_str() == \"start\";\n-    if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.as_str() == \"end\";\n-    if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n-    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(local) = block.stmts[0].kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Path(ref qpath1) = init.kind;\n-    if match_qpath(qpath1, &[\"y\"]);\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n-    if name1.as_str() == \"z\";\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr)\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = pat.kind\n+    && name.as_str() == \"y\"\n+    && let ExprKind::Struct(qpath, fields, None) = arg.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::Range, _))\n+    && fields.len() == 2\n+    && fields[0].ident.as_str() == \"start\"\n+    && let ExprKind::Lit(ref lit) = fields[0].expr.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    && fields[1].ident.as_str() == \"end\"\n+    && let ExprKind::Lit(ref lit1) = fields[1].expr.kind\n+    && let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Local(local) = block.stmts[0].kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Path(ref qpath1) = init.kind\n+    && match_qpath(qpath1, &[\"y\"])\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind\n+    && name1.as_str() == \"z\"\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Wild = pat.kind;\n-    if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    if fields[0].ident.as_str() == \"start\";\n-    if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.as_str() == \"end\";\n-    if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n-    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr)\n+    && let PatKind::Wild = pat.kind\n+    && let ExprKind::Struct(qpath, fields, None) = arg.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::Range, _))\n+    && fields.len() == 2\n+    && fields[0].ident.as_str() == \"start\"\n+    && let ExprKind::Lit(ref lit) = fields[0].expr.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    && fields[1].ident.as_str() == \"end\"\n+    && let ExprKind::Lit(ref lit1) = fields[1].expr.kind\n+    && let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr);\n-    if let PatKind::Wild = pat.kind;\n-    if let ExprKind::Struct(qpath, fields, None) = arg.kind;\n-    if matches!(qpath, QPath::LangItem(LangItem::Range, _));\n-    if fields.len() == 2;\n-    if fields[0].ident.as_str() == \"start\";\n-    if let ExprKind::Lit(ref lit) = fields[0].expr.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node;\n-    if fields[1].ident.as_str() == \"end\";\n-    if let ExprKind::Lit(ref lit1) = fields[1].expr.kind;\n-    if let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if let Some(label) = destination.label;\n-    if label.ident.as_str() == \"'label\";\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::ForLoop { pat: pat, arg: arg, body: body, .. }) = higher::ForLoop::hir(expr)\n+    && let PatKind::Wild = pat.kind\n+    && let ExprKind::Struct(qpath, fields, None) = arg.kind\n+    && matches!(qpath, QPath::LangItem(LangItem::Range, _))\n+    && fields.len() == 2\n+    && fields[0].ident.as_str() == \"start\"\n+    && let ExprKind::Lit(ref lit) = fields[0].expr.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit.node\n+    && fields[1].ident.as_str() == \"end\"\n+    && let ExprKind::Lit(ref lit1) = fields[1].expr.kind\n+    && let LitKind::Int(10, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && let Some(label) = destination.label\n+    && label.ident.as_str() == \"'label\"\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::While { condition: condition, body: body }) = higher::While::hir(expr);\n-    if let ExprKind::Path(ref qpath) = condition.kind;\n-    if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, None) = body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::While { condition: condition, body: body }) = higher::While::hir(expr)\n+    && let ExprKind::Path(ref qpath) = condition.kind\n+    && match_qpath(qpath, &[\"a\"])\n+    && let ExprKind::Block(block, None) = body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let Some(higher::WhileLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then }) = higher::WhileLet::hir(expr);\n-    if let PatKind::Lit(lit_expr) = let_pat.kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Path(ref qpath) = let_expr.kind;\n-    if match_qpath(qpath, &[\"a\"]);\n-    if let ExprKind::Block(block, None) = if_then.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = block.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let Some(higher::WhileLet { let_pat: let_pat, let_expr: let_expr, if_then: if_then }) = higher::WhileLet::hir(expr)\n+    && let PatKind::Lit(lit_expr) = let_pat.kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Path(ref qpath) = let_expr.kind\n+    && match_qpath(qpath, &[\"a\"])\n+    && let ExprKind::Block(block, None) = if_then.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Semi(e) = block.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::Loop(body, None, LoopSource::Loop, _) = expr.kind;\n-    if body.stmts.len() == 1;\n-    if let StmtKind::Semi(e) = body.stmts[0].kind;\n-    if let ExprKind::Break(destination, None) = e.kind;\n-    if destination.label.is_none();\n-    if body.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Loop(body, None, LoopSource::Loop, _) = expr.kind\n+    && body.stmts.len() == 1\n+    && let StmtKind::Semi(e) = body.stmts[0].kind\n+    && let ExprKind::Break(destination, None) = e.kind\n+    && destination.label.is_none()\n+    && body.expr.is_none()\n+{\n+    // report your lint here\n }"}, {"sha": "88e2ca656a4f60a5ae8cd9f3392d5b5e6179bdfe", "filename": "tests/ui/author/matches.stdout", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fmatches.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fmatches.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fmatches.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,38 +1,36 @@\n-if_chain! {\n-    if let StmtKind::Local(local) = stmt.kind;\n-    if let Some(init) = local.init;\n-    if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = init.kind;\n-    if let ExprKind::Lit(ref lit) = scrutinee.kind;\n-    if let LitKind::Int(42, LitIntType::Unsuffixed) = lit.node;\n-    if arms.len() == 3;\n-    if let PatKind::Lit(lit_expr) = arms[0].pat.kind;\n-    if let ExprKind::Lit(ref lit1) = lit_expr.kind;\n-    if let LitKind::Int(16, LitIntType::Unsuffixed) = lit1.node;\n-    if arms[0].guard.is_none();\n-    if let ExprKind::Lit(ref lit2) = arms[0].body.kind;\n-    if let LitKind::Int(5, LitIntType::Unsuffixed) = lit2.node;\n-    if let PatKind::Lit(lit_expr1) = arms[1].pat.kind;\n-    if let ExprKind::Lit(ref lit3) = lit_expr1.kind;\n-    if let LitKind::Int(17, LitIntType::Unsuffixed) = lit3.node;\n-    if arms[1].guard.is_none();\n-    if let ExprKind::Block(block, None) = arms[1].body.kind;\n-    if block.stmts.len() == 1;\n-    if let StmtKind::Local(local1) = block.stmts[0].kind;\n-    if let Some(init1) = local1.init;\n-    if let ExprKind::Lit(ref lit4) = init1.kind;\n-    if let LitKind::Int(3, LitIntType::Unsuffixed) = lit4.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local1.pat.kind;\n-    if name.as_str() == \"x\";\n-    if let Some(trailing_expr) = block.expr;\n-    if let ExprKind::Path(ref qpath) = trailing_expr.kind;\n-    if match_qpath(qpath, &[\"x\"]);\n-    if let PatKind::Wild = arms[2].pat.kind;\n-    if arms[2].guard.is_none();\n-    if let ExprKind::Lit(ref lit5) = arms[2].body.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node;\n-    if let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind;\n-    if name1.as_str() == \"a\";\n-    then {\n-        // report your lint here\n-    }\n+if let StmtKind::Local(local) = stmt.kind\n+    && let Some(init) = local.init\n+    && let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = init.kind\n+    && let ExprKind::Lit(ref lit) = scrutinee.kind\n+    && let LitKind::Int(42, LitIntType::Unsuffixed) = lit.node\n+    && arms.len() == 3\n+    && let PatKind::Lit(lit_expr) = arms[0].pat.kind\n+    && let ExprKind::Lit(ref lit1) = lit_expr.kind\n+    && let LitKind::Int(16, LitIntType::Unsuffixed) = lit1.node\n+    && arms[0].guard.is_none()\n+    && let ExprKind::Lit(ref lit2) = arms[0].body.kind\n+    && let LitKind::Int(5, LitIntType::Unsuffixed) = lit2.node\n+    && let PatKind::Lit(lit_expr1) = arms[1].pat.kind\n+    && let ExprKind::Lit(ref lit3) = lit_expr1.kind\n+    && let LitKind::Int(17, LitIntType::Unsuffixed) = lit3.node\n+    && arms[1].guard.is_none()\n+    && let ExprKind::Block(block, None) = arms[1].body.kind\n+    && block.stmts.len() == 1\n+    && let StmtKind::Local(local1) = block.stmts[0].kind\n+    && let Some(init1) = local1.init\n+    && let ExprKind::Lit(ref lit4) = init1.kind\n+    && let LitKind::Int(3, LitIntType::Unsuffixed) = lit4.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name, None) = local1.pat.kind\n+    && name.as_str() == \"x\"\n+    && let Some(trailing_expr) = block.expr\n+    && let ExprKind::Path(ref qpath) = trailing_expr.kind\n+    && match_qpath(qpath, &[\"x\"])\n+    && let PatKind::Wild = arms[2].pat.kind\n+    && arms[2].guard.is_none()\n+    && let ExprKind::Lit(ref lit5) = arms[2].body.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit5.node\n+    && let PatKind::Binding(BindingAnnotation::NONE, _, name1, None) = local.pat.kind\n+    && name1.as_str() == \"a\"\n+{\n+    // report your lint here\n }"}, {"sha": "c2a369610cc1b7cf0bf5635faed84c5999ebf3ed", "filename": "tests/ui/author/repeat.stdout", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Frepeat.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Frepeat.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Frepeat.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,12 +1,10 @@\n-if_chain! {\n-    if let ExprKind::Repeat(value, length) = expr.kind;\n-    if let ExprKind::Lit(ref lit) = value.kind;\n-    if let LitKind::Int(1, LitIntType::Unsigned(UintTy::U8)) = lit.node;\n-    if let ArrayLen::Body(anon_const) = length;\n-    let expr1 = &cx.tcx.hir().body(anon_const.body).value;\n-    if let ExprKind::Lit(ref lit1) = expr1.kind;\n-    if let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node;\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Repeat(value, length) = expr.kind\n+    && let ExprKind::Lit(ref lit) = value.kind\n+    && let LitKind::Int(1, LitIntType::Unsigned(UintTy::U8)) = lit.node\n+    && let ArrayLen::Body(anon_const) = length\n+    && expr1 = &cx.tcx.hir().body(anon_const.body).value\n+    && let ExprKind::Lit(ref lit1) = expr1.kind\n+    && let LitKind::Int(5, LitIntType::Unsuffixed) = lit1.node\n+{\n+    // report your lint here\n }"}, {"sha": "0b332d5e7d0e1e2c9b8b9cdb0fe41898dbe6b6d9", "filename": "tests/ui/author/struct.stdout", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fstruct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fauthor%2Fstruct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fstruct.stdout?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,64 +1,56 @@\n-if_chain! {\n-    if let ExprKind::Struct(qpath, fields, None) = expr.kind;\n-    if match_qpath(qpath, &[\"Test\"]);\n-    if fields.len() == 1;\n-    if fields[0].ident.as_str() == \"field\";\n-    if let ExprKind::If(cond, then, Some(else_expr)) = fields[0].expr.kind;\n-    if let ExprKind::DropTemps(expr1) = cond.kind;\n-    if let ExprKind::Lit(ref lit) = expr1.kind;\n-    if let LitKind::Bool(true) = lit.node;\n-    if let ExprKind::Block(block, None) = then.kind;\n-    if block.stmts.is_empty();\n-    if let Some(trailing_expr) = block.expr;\n-    if let ExprKind::Lit(ref lit1) = trailing_expr.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node;\n-    if let ExprKind::Block(block1, None) = else_expr.kind;\n-    if block1.stmts.is_empty();\n-    if let Some(trailing_expr1) = block1.expr;\n-    if let ExprKind::Lit(ref lit2) = trailing_expr1.kind;\n-    if let LitKind::Int(0, LitIntType::Unsuffixed) = lit2.node;\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::Struct(qpath, fields, None) = expr.kind\n+    && match_qpath(qpath, &[\"Test\"])\n+    && fields.len() == 1\n+    && fields[0].ident.as_str() == \"field\"\n+    && let ExprKind::If(cond, then, Some(else_expr)) = fields[0].expr.kind\n+    && let ExprKind::DropTemps(expr1) = cond.kind\n+    && let ExprKind::Lit(ref lit) = expr1.kind\n+    && let LitKind::Bool(true) = lit.node\n+    && let ExprKind::Block(block, None) = then.kind\n+    && block.stmts.is_empty()\n+    && let Some(trailing_expr) = block.expr\n+    && let ExprKind::Lit(ref lit1) = trailing_expr.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit1.node\n+    && let ExprKind::Block(block1, None) = else_expr.kind\n+    && block1.stmts.is_empty()\n+    && let Some(trailing_expr1) = block1.expr\n+    && let ExprKind::Lit(ref lit2) = trailing_expr1.kind\n+    && let LitKind::Int(0, LitIntType::Unsuffixed) = lit2.node\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let PatKind::Struct(ref qpath, fields, false) = arm.pat.kind;\n-    if match_qpath(qpath, &[\"Test\"]);\n-    if fields.len() == 1;\n-    if fields[0].ident.as_str() == \"field\";\n-    if let PatKind::Lit(lit_expr) = fields[0].pat.kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n-    if arm.guard.is_none();\n-    if let ExprKind::Block(block, None) = arm.body.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let PatKind::Struct(ref qpath, fields, false) = arm.pat.kind\n+    && match_qpath(qpath, &[\"Test\"])\n+    && fields.len() == 1\n+    && fields[0].ident.as_str() == \"field\"\n+    && let PatKind::Lit(lit_expr) = fields[0].pat.kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node\n+    && arm.guard.is_none()\n+    && let ExprKind::Block(block, None) = arm.body.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let PatKind::TupleStruct(ref qpath, fields, None) = arm.pat.kind;\n-    if match_qpath(qpath, &[\"TestTuple\"]);\n-    if fields.len() == 1;\n-    if let PatKind::Lit(lit_expr) = fields[0].kind;\n-    if let ExprKind::Lit(ref lit) = lit_expr.kind;\n-    if let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node;\n-    if arm.guard.is_none();\n-    if let ExprKind::Block(block, None) = arm.body.kind;\n-    if block.stmts.is_empty();\n-    if block.expr.is_none();\n-    then {\n-        // report your lint here\n-    }\n+if let PatKind::TupleStruct(ref qpath, fields, None) = arm.pat.kind\n+    && match_qpath(qpath, &[\"TestTuple\"])\n+    && fields.len() == 1\n+    && let PatKind::Lit(lit_expr) = fields[0].kind\n+    && let ExprKind::Lit(ref lit) = lit_expr.kind\n+    && let LitKind::Int(1, LitIntType::Unsuffixed) = lit.node\n+    && arm.guard.is_none()\n+    && let ExprKind::Block(block, None) = arm.body.kind\n+    && block.stmts.is_empty()\n+    && block.expr.is_none()\n+{\n+    // report your lint here\n }\n-if_chain! {\n-    if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind;\n-    if method_name.ident.as_str() == \"test\";\n-    if let ExprKind::Path(ref qpath) = receiver.kind;\n-    if match_qpath(qpath, &[\"test_method_call\"]);\n-    if args.is_empty();\n-    then {\n-        // report your lint here\n-    }\n+if let ExprKind::MethodCall(method_name, receiver, args, _) = expr.kind\n+    && method_name.ident.as_str() == \"test\"\n+    && let ExprKind::Path(ref qpath) = receiver.kind\n+    && match_qpath(qpath, &[\"test_method_call\"])\n+    && args.is_empty()\n+{\n+    // report your lint here\n }"}, {"sha": "7fbb272ce5a3ec105f64ecb2c088b84755fb7587", "filename": "tests/ui/box_default.fixed", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_default.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,43 @@\n+// run-rustfix\n+#![warn(clippy::box_default)]\n+\n+#[derive(Default)]\n+struct ImplementsDefault;\n+\n+struct OwnDefault;\n+\n+impl OwnDefault {\n+    fn default() -> Self {\n+        Self\n+    }\n+}\n+\n+macro_rules! outer {\n+    ($e: expr) => {\n+        $e\n+    };\n+}\n+\n+fn main() {\n+    let _string: Box<String> = Box::default();\n+    let _byte = Box::<u8>::default();\n+    let _vec = Box::<std::vec::Vec<u8>>::default();\n+    let _impl = Box::<ImplementsDefault>::default();\n+    let _impl2 = Box::<ImplementsDefault>::default();\n+    let _impl3: Box<ImplementsDefault> = Box::default();\n+    let _own = Box::new(OwnDefault::default()); // should not lint\n+    let _in_macro = outer!(Box::<std::string::String>::default());\n+    let _string_default = outer!(Box::<std::string::String>::default());\n+    let _vec2: Box<Vec<ImplementsDefault>> = Box::default();\n+    let _vec3: Box<Vec<bool>> = Box::default();\n+    let _vec4: Box<_> = Box::<std::vec::Vec<bool>>::default();\n+    let _more = ret_ty_fn();\n+    call_ty_fn(Box::default());\n+}\n+\n+fn ret_ty_fn() -> Box<bool> {\n+    Box::<bool>::default()\n+}\n+\n+#[allow(clippy::boxed_local)]\n+fn call_ty_fn(_b: Box<u8>) {}"}, {"sha": "64c4f3887af7d0f11c3fcc34654bf0b528a6714c", "filename": "tests/ui/box_default.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_default.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n #![warn(clippy::box_default)]\n \n #[derive(Default)]\n@@ -26,6 +27,17 @@ fn main() {\n     let _impl3: Box<ImplementsDefault> = Box::new(Default::default());\n     let _own = Box::new(OwnDefault::default()); // should not lint\n     let _in_macro = outer!(Box::new(String::new()));\n-    // false negative: default is from different expansion\n+    let _string_default = outer!(Box::new(String::from(\"\")));\n     let _vec2: Box<Vec<ImplementsDefault>> = Box::new(vec![]);\n+    let _vec3: Box<Vec<bool>> = Box::new(Vec::from([]));\n+    let _vec4: Box<_> = Box::new(Vec::from([false; 0]));\n+    let _more = ret_ty_fn();\n+    call_ty_fn(Box::new(u8::default()));\n }\n+\n+fn ret_ty_fn() -> Box<bool> {\n+    Box::new(bool::default())\n+}\n+\n+#[allow(clippy::boxed_local)]\n+fn call_ty_fn(_b: Box<u8>) {}"}, {"sha": "313255fc950eed54f1dfa222e8e416d944f46ae5", "filename": "tests/ui/box_default.stderr", "status": "modified", "additions": 50, "deletions": 27, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_default.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,59 +1,82 @@\n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:21:32\n+  --> $DIR/box_default.rs:22:32\n    |\n LL |     let _string: Box<String> = Box::new(Default::default());\n-   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n    |\n-   = help: use `Box::default()` instead\n    = note: `-D clippy::box-default` implied by `-D warnings`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:22:17\n+  --> $DIR/box_default.rs:23:17\n    |\n LL |     let _byte = Box::new(u8::default());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: use `Box::default()` instead\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<u8>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:23:16\n+  --> $DIR/box_default.rs:24:16\n    |\n LL |     let _vec = Box::new(Vec::<u8>::new());\n-   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: use `Box::default()` instead\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<std::vec::Vec<u8>>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:24:17\n+  --> $DIR/box_default.rs:25:17\n    |\n LL |     let _impl = Box::new(ImplementsDefault::default());\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: use `Box::default()` instead\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<ImplementsDefault>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:25:18\n+  --> $DIR/box_default.rs:26:18\n    |\n LL |     let _impl2 = Box::new(<ImplementsDefault as Default>::default());\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: use `Box::default()` instead\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<ImplementsDefault>::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:26:42\n+  --> $DIR/box_default.rs:27:42\n    |\n LL |     let _impl3: Box<ImplementsDefault> = Box::new(Default::default());\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: use `Box::default()` instead\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n \n error: `Box::new(_)` of default value\n-  --> $DIR/box_default.rs:28:28\n+  --> $DIR/box_default.rs:29:28\n    |\n LL |     let _in_macro = outer!(Box::new(String::new()));\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<std::string::String>::default()`\n+\n+error: `Box::new(_)` of default value\n+  --> $DIR/box_default.rs:30:34\n+   |\n+LL |     let _string_default = outer!(Box::new(String::from(\"\")));\n+   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<std::string::String>::default()`\n+\n+error: `Box::new(_)` of default value\n+  --> $DIR/box_default.rs:31:46\n+   |\n+LL |     let _vec2: Box<Vec<ImplementsDefault>> = Box::new(vec![]);\n+   |                                              ^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n+\n+error: `Box::new(_)` of default value\n+  --> $DIR/box_default.rs:32:33\n+   |\n+LL |     let _vec3: Box<Vec<bool>> = Box::new(Vec::from([]));\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n+\n+error: `Box::new(_)` of default value\n+  --> $DIR/box_default.rs:33:25\n+   |\n+LL |     let _vec4: Box<_> = Box::new(Vec::from([false; 0]));\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<std::vec::Vec<bool>>::default()`\n+\n+error: `Box::new(_)` of default value\n+  --> $DIR/box_default.rs:35:16\n+   |\n+LL |     call_ty_fn(Box::new(u8::default()));\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::default()`\n+\n+error: `Box::new(_)` of default value\n+  --> $DIR/box_default.rs:39:5\n    |\n-   = help: use `Box::default()` instead\n+LL |     Box::new(bool::default())\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Box::<bool>::default()`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 13 previous errors\n "}, {"sha": "4326abc9a5410526b0a272b1ad43fcc8e4582462", "filename": "tests/ui/box_default_no_std.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default_no_std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fbox_default_no_std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbox_default_no_std.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,33 @@\n+#![feature(lang_items, start, libc)]\n+#![warn(clippy::box_default)]\n+#![no_std]\n+\n+pub struct NotBox<T> {\n+    _value: T,\n+}\n+\n+impl<T> NotBox<T> {\n+    pub fn new(value: T) -> Self {\n+        Self { _value: value }\n+    }\n+}\n+\n+impl<T: Default> Default for NotBox<T> {\n+    fn default() -> Self {\n+        Self::new(T::default())\n+    }\n+}\n+\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    let _p = NotBox::new(isize::default());\n+    0\n+}\n+\n+#[panic_handler]\n+fn panic(_info: &core::panic::PanicInfo) -> ! {\n+    loop {}\n+}\n+\n+#[lang = \"eh_personality\"]\n+extern \"C\" fn eh_personality() {}"}, {"sha": "287c5aa216bd3341245baa0f54606bce2a2df3ed", "filename": "tests/ui/cast_nan_to_int.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fcast_nan_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fcast_nan_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_nan_to_int.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,18 @@\n+#![warn(clippy::cast_nan_to_int)]\n+#![allow(clippy::eq_op)]\n+\n+fn main() {\n+    let _ = (0.0_f32 / -0.0) as usize;\n+    let _ = (f64::INFINITY * -0.0) as usize;\n+    let _ = (0.0 * f32::INFINITY) as usize;\n+\n+    let _ = (f64::INFINITY + f64::NEG_INFINITY) as usize;\n+    let _ = (f32::INFINITY - f32::INFINITY) as usize;\n+    let _ = (f32::INFINITY / f32::NEG_INFINITY) as usize;\n+\n+    // those won't be linted:\n+    let _ = (1.0_f32 / 0.0) as usize;\n+    let _ = (f32::INFINITY * f32::NEG_INFINITY) as usize;\n+    let _ = (f32::INFINITY - f32::NEG_INFINITY) as usize;\n+    let _ = (f64::INFINITY - 0.0) as usize;\n+}"}, {"sha": "3539be75a19db09d19bba2f96a637fe11c5c0b1c", "filename": "tests/ui/cast_nan_to_int.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fcast_nan_to_int.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fcast_nan_to_int.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_nan_to_int.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,51 @@\n+error: casting a known NaN to usize\n+  --> $DIR/cast_nan_to_int.rs:5:13\n+   |\n+LL |     let _ = (0.0_f32 / -0.0) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this always evaluates to 0\n+   = note: `-D clippy::cast-nan-to-int` implied by `-D warnings`\n+\n+error: casting a known NaN to usize\n+  --> $DIR/cast_nan_to_int.rs:6:13\n+   |\n+LL |     let _ = (f64::INFINITY * -0.0) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this always evaluates to 0\n+\n+error: casting a known NaN to usize\n+  --> $DIR/cast_nan_to_int.rs:7:13\n+   |\n+LL |     let _ = (0.0 * f32::INFINITY) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this always evaluates to 0\n+\n+error: casting a known NaN to usize\n+  --> $DIR/cast_nan_to_int.rs:9:13\n+   |\n+LL |     let _ = (f64::INFINITY + f64::NEG_INFINITY) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this always evaluates to 0\n+\n+error: casting a known NaN to usize\n+  --> $DIR/cast_nan_to_int.rs:10:13\n+   |\n+LL |     let _ = (f32::INFINITY - f32::INFINITY) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this always evaluates to 0\n+\n+error: casting a known NaN to usize\n+  --> $DIR/cast_nan_to_int.rs:11:13\n+   |\n+LL |     let _ = (f32::INFINITY / f32::NEG_INFINITY) as usize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this always evaluates to 0\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "a765882b5d8180802c8b82b4410848feca161eda", "filename": "tests/ui/crashes/ice-9625.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fcrashes%2Fice-9625.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fcrashes%2Fice-9625.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-9625.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let x = &1;\n+    let _ = &1 < x && x < &10;\n+}"}, {"sha": "a370ccc76962e9802fed7b14ecc2be8abba88aaa", "filename": "tests/ui/default_numeric_fallback_f64.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -33,6 +33,7 @@ mod basic_expr {\n         let x: [f64; 3] = [1., 2., 3.];\n         let x: (f64, f64) = if true { (1., 2.) } else { (3., 4.) };\n         let x: _ = 1.;\n+        const X: f32 = 1.;\n     }\n }\n \n@@ -59,6 +60,14 @@ mod nested_local {\n             // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n             2.\n         };\n+\n+        const X: f32 = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.0_f64;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        };\n     }\n }\n "}, {"sha": "2476fe95141dece897a260b54d29ace5e612c9c5", "filename": "tests/ui/default_numeric_fallback_f64.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -33,6 +33,7 @@ mod basic_expr {\n         let x: [f64; 3] = [1., 2., 3.];\n         let x: (f64, f64) = if true { (1., 2.) } else { (3., 4.) };\n         let x: _ = 1.;\n+        const X: f32 = 1.;\n     }\n }\n \n@@ -59,6 +60,14 @@ mod nested_local {\n             // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n             2.\n         };\n+\n+        const X: f32 = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1.;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1.\n+        };\n     }\n }\n "}, {"sha": "5df2f642388dc562e0c807babcd6ada427d09be8", "filename": "tests/ui/default_numeric_fallback_f64.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -61,79 +61,85 @@ LL |             _ => 1.,\n    |                  ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:43:21\n+  --> $DIR/default_numeric_fallback_f64.rs:44:21\n    |\n LL |             let y = 1.;\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:51:21\n+  --> $DIR/default_numeric_fallback_f64.rs:52:21\n    |\n LL |             let y = 1.;\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:57:21\n+  --> $DIR/default_numeric_fallback_f64.rs:58:21\n    |\n LL |             let y = 1.;\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:69:9\n+  --> $DIR/default_numeric_fallback_f64.rs:66:21\n+   |\n+LL |             let y = 1.;\n+   |                     ^^ help: consider adding suffix: `1.0_f64`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_f64.rs:78:9\n    |\n LL |         1.\n    |         ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:75:27\n+  --> $DIR/default_numeric_fallback_f64.rs:84:27\n    |\n LL |         let f = || -> _ { 1. };\n    |                           ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:79:29\n+  --> $DIR/default_numeric_fallback_f64.rs:88:29\n    |\n LL |         let f = || -> f64 { 1. };\n    |                             ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:93:21\n+  --> $DIR/default_numeric_fallback_f64.rs:102:21\n    |\n LL |         generic_arg(1.);\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:96:32\n+  --> $DIR/default_numeric_fallback_f64.rs:105:32\n    |\n LL |         let x: _ = generic_arg(1.);\n    |                                ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:114:28\n+  --> $DIR/default_numeric_fallback_f64.rs:123:28\n    |\n LL |         GenericStruct { x: 1. };\n    |                            ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:117:36\n+  --> $DIR/default_numeric_fallback_f64.rs:126:36\n    |\n LL |         let _ = GenericStruct { x: 1. };\n    |                                    ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:135:24\n+  --> $DIR/default_numeric_fallback_f64.rs:144:24\n    |\n LL |         GenericEnum::X(1.);\n    |                        ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:155:23\n+  --> $DIR/default_numeric_fallback_f64.rs:164:23\n    |\n LL |         s.generic_arg(1.);\n    |                       ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:162:21\n+  --> $DIR/default_numeric_fallback_f64.rs:171:21\n    |\n LL |             let x = 22.;\n    |                     ^^^ help: consider adding suffix: `22.0_f64`\n@@ -143,5 +149,5 @@ LL |         internal_macro!();\n    |\n    = note: this error originates in the macro `internal_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "3f4994f0453b1ef153fea0355d2a1130f9adafdc", "filename": "tests/ui/default_numeric_fallback_i32.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -33,6 +33,8 @@ mod basic_expr {\n         let x: [i32; 3] = [1, 2, 3];\n         let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n         let x: _ = 1;\n+        let x: u64 = 1;\n+        const CONST_X: i8 = 1;\n     }\n }\n \n@@ -59,6 +61,14 @@ mod nested_local {\n             // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n             2\n         };\n+\n+        const CONST_X: i32 = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1_i32;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        };\n     }\n }\n "}, {"sha": "2df0e09787f9055d0f5034471acd9ec6b3c3c4ca", "filename": "tests/ui/default_numeric_fallback_i32.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -33,6 +33,8 @@ mod basic_expr {\n         let x: [i32; 3] = [1, 2, 3];\n         let x: (i32, i32) = if true { (1, 2) } else { (3, 4) };\n         let x: _ = 1;\n+        let x: u64 = 1;\n+        const CONST_X: i8 = 1;\n     }\n }\n \n@@ -59,6 +61,14 @@ mod nested_local {\n             // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n             2\n         };\n+\n+        const CONST_X: i32 = {\n+            // Should lint this because this literal is not bound to any types.\n+            let y = 1;\n+\n+            // Should NOT lint this because this literal is bound to `_` of outer `Local`.\n+            1\n+        };\n     }\n }\n "}, {"sha": "6f219c3fc2b0e8a62afe16ed15ad820088d6272a", "filename": "tests/ui/default_numeric_fallback_i32.stderr", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -73,79 +73,85 @@ LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:43:21\n+  --> $DIR/default_numeric_fallback_i32.rs:45:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:51:21\n+  --> $DIR/default_numeric_fallback_i32.rs:53:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:57:21\n+  --> $DIR/default_numeric_fallback_i32.rs:59:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:69:9\n+  --> $DIR/default_numeric_fallback_i32.rs:67:21\n+   |\n+LL |             let y = 1;\n+   |                     ^ help: consider adding suffix: `1_i32`\n+\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback_i32.rs:79:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:75:27\n+  --> $DIR/default_numeric_fallback_i32.rs:85:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:79:29\n+  --> $DIR/default_numeric_fallback_i32.rs:89:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:93:21\n+  --> $DIR/default_numeric_fallback_i32.rs:103:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:96:32\n+  --> $DIR/default_numeric_fallback_i32.rs:106:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:114:28\n+  --> $DIR/default_numeric_fallback_i32.rs:124:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:117:36\n+  --> $DIR/default_numeric_fallback_i32.rs:127:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:135:24\n+  --> $DIR/default_numeric_fallback_i32.rs:145:24\n    |\n LL |         GenericEnum::X(1);\n    |                        ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:155:23\n+  --> $DIR/default_numeric_fallback_i32.rs:165:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:162:21\n+  --> $DIR/default_numeric_fallback_i32.rs:172:21\n    |\n LL |             let x = 22;\n    |                     ^^ help: consider adding suffix: `22_i32`\n@@ -155,5 +161,5 @@ LL |         internal_macro!();\n    |\n    = note: this error originates in the macro `internal_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 26 previous errors\n "}, {"sha": "c629c0e535377ebf1b2e05ccd96c2a62fb8923dc", "filename": "tests/ui/derive.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,7 +1,6 @@\n #![allow(dead_code)]\n #![warn(clippy::expl_impl_clone_on_copy)]\n \n-\n #[derive(Copy)]\n struct Qux;\n "}, {"sha": "d37f7fa73319679e97a2c61f67cfae6cd3eee762", "filename": "tests/ui/derive.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fderive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fderive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderive.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,5 @@\n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:8:1\n+  --> $DIR/derive.rs:7:1\n    |\n LL | / impl Clone for Qux {\n LL | |     fn clone(&self) -> Self {\n@@ -9,7 +9,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:8:1\n+  --> $DIR/derive.rs:7:1\n    |\n LL | / impl Clone for Qux {\n LL | |     fn clone(&self) -> Self {\n@@ -20,7 +20,7 @@ LL | | }\n    = note: `-D clippy::expl-impl-clone-on-copy` implied by `-D warnings`\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:32:1\n+  --> $DIR/derive.rs:31:1\n    |\n LL | / impl<'a> Clone for Lt<'a> {\n LL | |     fn clone(&self) -> Self {\n@@ -30,7 +30,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:32:1\n+  --> $DIR/derive.rs:31:1\n    |\n LL | / impl<'a> Clone for Lt<'a> {\n LL | |     fn clone(&self) -> Self {\n@@ -40,7 +40,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:43:1\n+  --> $DIR/derive.rs:42:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -50,7 +50,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:43:1\n+  --> $DIR/derive.rs:42:1\n    |\n LL | / impl Clone for BigArray {\n LL | |     fn clone(&self) -> Self {\n@@ -60,7 +60,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:54:1\n+  --> $DIR/derive.rs:53:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -70,7 +70,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:54:1\n+  --> $DIR/derive.rs:53:1\n    |\n LL | / impl Clone for FnPtr {\n LL | |     fn clone(&self) -> Self {\n@@ -80,7 +80,7 @@ LL | | }\n    | |_^\n \n error: you are implementing `Clone` explicitly on a `Copy` type\n-  --> $DIR/derive.rs:74:1\n+  --> $DIR/derive.rs:73:1\n    |\n LL | / impl<T: Clone> Clone for Generic2<T> {\n LL | |     fn clone(&self) -> Self {\n@@ -90,7 +90,7 @@ LL | | }\n    | |_^\n    |\n note: consider deriving `Clone` or removing `Copy`\n-  --> $DIR/derive.rs:74:1\n+  --> $DIR/derive.rs:73:1\n    |\n LL | / impl<T: Clone> Clone for Generic2<T> {\n LL | |     fn clone(&self) -> Self {"}, {"sha": "018f875d60bfa24ec5fd1a625b84d7cb9c457e66", "filename": "tests/ui/expect_tool_lint_rfc_2383.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexpect_tool_lint_rfc_2383.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -22,9 +22,9 @@ mod rustc_ok {\n \n         #[expect(illegal_floating_point_literal_pattern)]\n         match x {\n-            5.0 => {}\n-            6.0 => {}\n-            _ => {}\n+            5.0 => {},\n+            6.0 => {},\n+            _ => {},\n         }\n     }\n }\n@@ -38,9 +38,9 @@ mod rustc_warn {\n \n         #[expect(illegal_floating_point_literal_pattern)]\n         match x {\n-            5 => {}\n-            6 => {}\n-            _ => {}\n+            5 => {},\n+            6 => {},\n+            _ => {},\n         }\n     }\n }"}, {"sha": "825e122be5a5f3d97b628c38833d1340235a63d4", "filename": "tests/ui/format_args.fixed", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fformat_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fformat_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,6 +3,7 @@\n #![allow(unused)]\n #![allow(\n     clippy::assertions_on_constants,\n+    clippy::double_parens,\n     clippy::eq_op,\n     clippy::print_literal,\n     clippy::uninlined_format_args\n@@ -114,6 +115,8 @@ fn main() {\n     println!(\"error: something failed at {}\", my_other_macro!());\n     // https://github.com/rust-lang/rust-clippy/issues/7903\n     println!(\"{foo}{foo:?}\", foo = \"foo\".to_string());\n+    print!(\"{}\", (Location::caller()));\n+    print!(\"{}\", ((Location::caller())));\n }\n \n fn issue8643(vendor_id: usize, product_id: usize, name: &str) {"}, {"sha": "a41e53389e52a7b9f84a37f914217c4baa07d6c5", "filename": "tests/ui/format_args.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,6 +3,7 @@\n #![allow(unused)]\n #![allow(\n     clippy::assertions_on_constants,\n+    clippy::double_parens,\n     clippy::eq_op,\n     clippy::print_literal,\n     clippy::uninlined_format_args\n@@ -114,6 +115,8 @@ fn main() {\n     println!(\"error: something failed at {}\", my_other_macro!());\n     // https://github.com/rust-lang/rust-clippy/issues/7903\n     println!(\"{foo}{foo:?}\", foo = \"foo\".to_string());\n+    print!(\"{}\", (Location::caller().to_string()));\n+    print!(\"{}\", ((Location::caller()).to_string()));\n }\n \n fn issue8643(vendor_id: usize, product_id: usize, name: &str) {"}, {"sha": "f1832b970198a42cac9fa311b2ae00810818723d", "filename": "tests/ui/format_args.stderr", "status": "modified", "additions": 36, "deletions": 24, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fformat_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fformat_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_args.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,142 +1,154 @@\n error: `to_string` applied to a type that implements `Display` in `format!` args\n-  --> $DIR/format_args.rs:76:72\n+  --> $DIR/format_args.rs:77:72\n    |\n LL |     let _ = format!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                        ^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::to-string-in-format-args` implied by `-D warnings`\n \n error: `to_string` applied to a type that implements `Display` in `write!` args\n-  --> $DIR/format_args.rs:80:27\n+  --> $DIR/format_args.rs:81:27\n    |\n LL |         Location::caller().to_string()\n    |                           ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `writeln!` args\n-  --> $DIR/format_args.rs:85:27\n+  --> $DIR/format_args.rs:86:27\n    |\n LL |         Location::caller().to_string()\n    |                           ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `print!` args\n-  --> $DIR/format_args.rs:87:63\n+  --> $DIR/format_args.rs:88:63\n    |\n LL |     print!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                               ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:88:65\n+  --> $DIR/format_args.rs:89:65\n    |\n LL |     println!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                 ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `eprint!` args\n-  --> $DIR/format_args.rs:89:64\n+  --> $DIR/format_args.rs:90:64\n    |\n LL |     eprint!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `eprintln!` args\n-  --> $DIR/format_args.rs:90:66\n+  --> $DIR/format_args.rs:91:66\n    |\n LL |     eprintln!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                  ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `format_args!` args\n-  --> $DIR/format_args.rs:91:77\n+  --> $DIR/format_args.rs:92:77\n    |\n LL |     let _ = format_args!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                                             ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert!` args\n-  --> $DIR/format_args.rs:92:70\n+  --> $DIR/format_args.rs:93:70\n    |\n LL |     assert!(true, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                      ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert_eq!` args\n-  --> $DIR/format_args.rs:93:73\n+  --> $DIR/format_args.rs:94:73\n    |\n LL |     assert_eq!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                         ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `assert_ne!` args\n-  --> $DIR/format_args.rs:94:73\n+  --> $DIR/format_args.rs:95:73\n    |\n LL |     assert_ne!(0, 0, \"error: something failed at {}\", Location::caller().to_string());\n    |                                                                         ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `panic!` args\n-  --> $DIR/format_args.rs:95:63\n+  --> $DIR/format_args.rs:96:63\n    |\n LL |     panic!(\"error: something failed at {}\", Location::caller().to_string());\n    |                                                               ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:96:20\n+  --> $DIR/format_args.rs:97:20\n    |\n LL |     println!(\"{}\", X(1).to_string());\n    |                    ^^^^^^^^^^^^^^^^ help: use this: `*X(1)`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:97:20\n+  --> $DIR/format_args.rs:98:20\n    |\n LL |     println!(\"{}\", Y(&X(1)).to_string());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: use this: `***Y(&X(1))`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:98:24\n+  --> $DIR/format_args.rs:99:24\n    |\n LL |     println!(\"{}\", Z(1).to_string());\n    |                        ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:99:20\n+  --> $DIR/format_args.rs:100:20\n    |\n LL |     println!(\"{}\", x.to_string());\n    |                    ^^^^^^^^^^^^^ help: use this: `**x`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:100:20\n+  --> $DIR/format_args.rs:101:20\n    |\n LL |     println!(\"{}\", x_ref.to_string());\n    |                    ^^^^^^^^^^^^^^^^^ help: use this: `***x_ref`\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:102:39\n+  --> $DIR/format_args.rs:103:39\n    |\n LL |     println!(\"{foo}{bar}\", foo = \"foo\".to_string(), bar = \"bar\");\n    |                                       ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:103:52\n+  --> $DIR/format_args.rs:104:52\n    |\n LL |     println!(\"{foo}{bar}\", foo = \"foo\", bar = \"bar\".to_string());\n    |                                                    ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:104:39\n+  --> $DIR/format_args.rs:105:39\n    |\n LL |     println!(\"{foo}{bar}\", bar = \"bar\".to_string(), foo = \"foo\");\n    |                                       ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:105:52\n+  --> $DIR/format_args.rs:106:52\n    |\n LL |     println!(\"{foo}{bar}\", bar = \"bar\", foo = \"foo\".to_string());\n    |                                                    ^^^^^^^^^^^^ help: remove this\n \n+error: `to_string` applied to a type that implements `Display` in `print!` args\n+  --> $DIR/format_args.rs:118:37\n+   |\n+LL |     print!(\"{}\", (Location::caller().to_string()));\n+   |                                     ^^^^^^^^^^^^ help: remove this\n+\n+error: `to_string` applied to a type that implements `Display` in `print!` args\n+  --> $DIR/format_args.rs:119:39\n+   |\n+LL |     print!(\"{}\", ((Location::caller()).to_string()));\n+   |                                       ^^^^^^^^^^^^ help: remove this\n+\n error: `to_string` applied to a type that implements `Display` in `format!` args\n-  --> $DIR/format_args.rs:144:38\n+  --> $DIR/format_args.rs:147:38\n    |\n LL |         let x = format!(\"{} {}\", a, b.to_string());\n    |                                      ^^^^^^^^^^^^ help: remove this\n \n error: `to_string` applied to a type that implements `Display` in `println!` args\n-  --> $DIR/format_args.rs:158:24\n+  --> $DIR/format_args.rs:161:24\n    |\n LL |         println!(\"{}\", original[..10].to_string());\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use this: `&original[..10]`\n \n-error: aborting due to 23 previous errors\n+error: aborting due to 25 previous errors\n "}, {"sha": "e66dc43b0473edcb17a13b2120552039b48675ef", "filename": "tests/ui/from_over_into.fixed", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+\n+#![warn(clippy::from_over_into)]\n+#![allow(unused)]\n+\n+// this should throw an error\n+struct StringWrapper(String);\n+\n+impl From<String> for StringWrapper {\n+    fn from(val: String) -> Self {\n+        StringWrapper(val)\n+    }\n+}\n+\n+struct SelfType(String);\n+\n+impl From<String> for SelfType {\n+    fn from(val: String) -> Self {\n+        SelfType(String::new())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct X;\n+\n+impl X {\n+    const FOO: &'static str = \"a\";\n+}\n+\n+struct SelfKeywords;\n+\n+impl From<X> for SelfKeywords {\n+    fn from(val: X) -> Self {\n+        let _ = X::default();\n+        let _ = X::FOO;\n+        let _: X = val;\n+\n+        SelfKeywords\n+    }\n+}\n+\n+struct ExplicitPaths(bool);\n+\n+impl core::convert::From<crate::ExplicitPaths> for bool {\n+    fn from(mut val: crate::ExplicitPaths) -> Self {\n+        let in_closure = || val.0;\n+\n+        val.0 = false;\n+        val.0\n+    }\n+}\n+\n+// this is fine\n+struct A(String);\n+\n+impl From<String> for A {\n+    fn from(s: String) -> A {\n+        A(s)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "74c7be6af79e1a5f8df29ca037a8b026406f1a9d", "filename": "tests/ui/from_over_into.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,4 +1,7 @@\n+// run-rustfix\n+\n #![warn(clippy::from_over_into)]\n+#![allow(unused)]\n \n // this should throw an error\n struct StringWrapper(String);\n@@ -9,6 +12,44 @@ impl Into<StringWrapper> for String {\n     }\n }\n \n+struct SelfType(String);\n+\n+impl Into<SelfType> for String {\n+    fn into(self) -> SelfType {\n+        SelfType(Self::new())\n+    }\n+}\n+\n+#[derive(Default)]\n+struct X;\n+\n+impl X {\n+    const FOO: &'static str = \"a\";\n+}\n+\n+struct SelfKeywords;\n+\n+impl Into<SelfKeywords> for X {\n+    fn into(self) -> SelfKeywords {\n+        let _ = Self::default();\n+        let _ = Self::FOO;\n+        let _: Self = self;\n+\n+        SelfKeywords\n+    }\n+}\n+\n+struct ExplicitPaths(bool);\n+\n+impl core::convert::Into<bool> for crate::ExplicitPaths {\n+    fn into(mut self) -> bool {\n+        let in_closure = || self.0;\n+\n+        self.0 = false;\n+        self.0\n+    }\n+}\n+\n // this is fine\n struct A(String);\n "}, {"sha": "6cf83e258071c9ad7810354cfa482141b3eadc1b", "filename": "tests/ui/from_over_into.stderr", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,11 +1,62 @@\n error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n-  --> $DIR/from_over_into.rs:6:1\n+  --> $DIR/from_over_into.rs:9:1\n    |\n LL | impl Into<StringWrapper> for String {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider to implement `From<std::string::String>` instead\n    = note: `-D clippy::from-over-into` implied by `-D warnings`\n+help: replace the `Into` implentation with `From<std::string::String>`\n+   |\n+LL ~ impl From<String> for StringWrapper {\n+LL ~     fn from(val: String) -> Self {\n+LL ~         StringWrapper(val)\n+   |\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:17:1\n+   |\n+LL | impl Into<SelfType> for String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace the `Into` implentation with `From<std::string::String>`\n+   |\n+LL ~ impl From<String> for SelfType {\n+LL ~     fn from(val: String) -> Self {\n+LL ~         SelfType(String::new())\n+   |\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:32:1\n+   |\n+LL | impl Into<SelfKeywords> for X {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: replace the `Into` implentation with `From<X>`\n+   |\n+LL ~ impl From<X> for SelfKeywords {\n+LL ~     fn from(val: X) -> Self {\n+LL ~         let _ = X::default();\n+LL ~         let _ = X::FOO;\n+LL ~         let _: X = val;\n+   |\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into.rs:44:1\n+   |\n+LL | impl core::convert::Into<bool> for crate::ExplicitPaths {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n+           https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n+help: replace the `Into` implentation with `From<ExplicitPaths>`\n+   |\n+LL ~ impl core::convert::From<crate::ExplicitPaths> for bool {\n+LL ~     fn from(mut val: crate::ExplicitPaths) -> Self {\n+LL ~         let in_closure = || val.0;\n+LL | \n+LL ~         val.0 = false;\n+LL ~         val.0\n+   |\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n "}, {"sha": "3b280b7488ae7c8b1bc79b7215407c9cc8e35492", "filename": "tests/ui/from_over_into_unfixable.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into_unfixable.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,35 @@\n+#![warn(clippy::from_over_into)]\n+\n+struct InMacro(String);\n+\n+macro_rules! in_macro {\n+    ($e:ident) => {\n+        $e\n+    };\n+}\n+\n+impl Into<InMacro> for String {\n+    fn into(self) -> InMacro {\n+        InMacro(in_macro!(self))\n+    }\n+}\n+\n+struct WeirdUpperSelf;\n+\n+impl Into<WeirdUpperSelf> for &'static [u8] {\n+    fn into(self) -> WeirdUpperSelf {\n+        let _ = Self::default();\n+        WeirdUpperSelf\n+    }\n+}\n+\n+struct ContainsVal;\n+\n+impl Into<u8> for ContainsVal {\n+    fn into(self) -> u8 {\n+        let val = 1;\n+        val + 1\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6f6ce351921be1138cff9de30e36625f2c091ef4", "filename": "tests/ui/from_over_into_unfixable.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ffrom_over_into_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffrom_over_into_unfixable.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,29 @@\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into_unfixable.rs:11:1\n+   |\n+LL | impl Into<InMacro> for String {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: replace the `Into` implentation with `From<std::string::String>`\n+   = note: `-D clippy::from-over-into` implied by `-D warnings`\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into_unfixable.rs:19:1\n+   |\n+LL | impl Into<WeirdUpperSelf> for &'static [u8] {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: replace the `Into` implentation with `From<&'static [u8]>`\n+\n+error: an implementation of `From` is preferred since it gives you `Into<_>` for free where the reverse isn't true\n+  --> $DIR/from_over_into_unfixable.rs:28:1\n+   |\n+LL | impl Into<u8> for ContainsVal {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: `impl From<Local> for Foreign` is allowed by the orphan rules, for more information see\n+           https://doc.rust-lang.org/reference/items/implementations.html#trait-implementation-coherence\n+   = help: replace the `Into` implentation with `From<ContainsVal>`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "93df81b1a7ff0355fa99bb2cf9bdef5d6a11c83d", "filename": "tests/ui/implicit_saturating_sub.fixed", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fimplicit_saturating_sub.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fimplicit_saturating_sub.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -2,6 +2,21 @@\n #![allow(unused_assignments, unused_mut, clippy::assign_op_pattern)]\n #![warn(clippy::implicit_saturating_sub)]\n \n+use std::cmp::PartialEq;\n+use std::ops::SubAssign;\n+// Mock type\n+struct Mock;\n+\n+impl PartialEq<u32> for Mock {\n+    fn eq(&self, _: &u32) -> bool {\n+        true\n+    }\n+}\n+\n+impl SubAssign<u32> for Mock {\n+    fn sub_assign(&mut self, _: u32) {}\n+}\n+\n fn main() {\n     // Tests for unsigned integers\n \n@@ -165,4 +180,39 @@ fn main() {\n     } else {\n         println!(\"side effect\");\n     }\n+\n+    // Extended tests\n+    let mut m = Mock;\n+    let mut u_32 = 3000;\n+    let a = 200;\n+    let mut _b = 8;\n+\n+    if m != 0 {\n+        m -= 1;\n+    }\n+\n+    if a > 0 {\n+        _b -= 1;\n+    }\n+\n+    if 0 > a {\n+        _b -= 1;\n+    }\n+\n+    if u_32 > 0 {\n+        u_32 -= 1;\n+    } else {\n+        println!(\"don't lint this\");\n+    }\n+\n+    if u_32 > 0 {\n+        println!(\"don't lint this\");\n+        u_32 -= 1;\n+    }\n+\n+    if u_32 > 42 {\n+        println!(\"brace yourself!\");\n+    } else if u_32 > 0 {\n+        u_32 -= 1;\n+    }\n }"}, {"sha": "8340bc8264d5884814037184d1b1cd41cf1cc12a", "filename": "tests/ui/implicit_saturating_sub.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -2,6 +2,21 @@\n #![allow(unused_assignments, unused_mut, clippy::assign_op_pattern)]\n #![warn(clippy::implicit_saturating_sub)]\n \n+use std::cmp::PartialEq;\n+use std::ops::SubAssign;\n+// Mock type\n+struct Mock;\n+\n+impl PartialEq<u32> for Mock {\n+    fn eq(&self, _: &u32) -> bool {\n+        true\n+    }\n+}\n+\n+impl SubAssign<u32> for Mock {\n+    fn sub_assign(&mut self, _: u32) {}\n+}\n+\n fn main() {\n     // Tests for unsigned integers\n \n@@ -211,4 +226,39 @@ fn main() {\n     } else {\n         println!(\"side effect\");\n     }\n+\n+    // Extended tests\n+    let mut m = Mock;\n+    let mut u_32 = 3000;\n+    let a = 200;\n+    let mut _b = 8;\n+\n+    if m != 0 {\n+        m -= 1;\n+    }\n+\n+    if a > 0 {\n+        _b -= 1;\n+    }\n+\n+    if 0 > a {\n+        _b -= 1;\n+    }\n+\n+    if u_32 > 0 {\n+        u_32 -= 1;\n+    } else {\n+        println!(\"don't lint this\");\n+    }\n+\n+    if u_32 > 0 {\n+        println!(\"don't lint this\");\n+        u_32 -= 1;\n+    }\n+\n+    if u_32 > 42 {\n+        println!(\"brace yourself!\");\n+    } else if u_32 > 0 {\n+        u_32 -= 1;\n+    }\n }"}, {"sha": "5e589d931e431a145b5fd48fdcd87fbee6c4c83c", "filename": "tests/ui/implicit_saturating_sub.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fimplicit_saturating_sub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fimplicit_saturating_sub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,5 @@\n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:13:5\n+  --> $DIR/implicit_saturating_sub.rs:28:5\n    |\n LL | /     if u_8 > 0 {\n LL | |         u_8 = u_8 - 1;\n@@ -9,175 +9,175 @@ LL | |     }\n    = note: `-D clippy::implicit-saturating-sub` implied by `-D warnings`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:20:13\n+  --> $DIR/implicit_saturating_sub.rs:35:13\n    |\n LL | /             if u_8 > 0 {\n LL | |                 u_8 -= 1;\n LL | |             }\n    | |_____________^ help: try: `u_8 = u_8.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:34:5\n+  --> $DIR/implicit_saturating_sub.rs:49:5\n    |\n LL | /     if u_16 > 0 {\n LL | |         u_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_16 = u_16.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:44:5\n+  --> $DIR/implicit_saturating_sub.rs:59:5\n    |\n LL | /     if u_32 != 0 {\n LL | |         u_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_32 = u_32.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:65:5\n+  --> $DIR/implicit_saturating_sub.rs:80:5\n    |\n LL | /     if u_64 > 0 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:70:5\n+  --> $DIR/implicit_saturating_sub.rs:85:5\n    |\n LL | /     if 0 < u_64 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:75:5\n+  --> $DIR/implicit_saturating_sub.rs:90:5\n    |\n LL | /     if 0 != u_64 {\n LL | |         u_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `u_64 = u_64.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:96:5\n+  --> $DIR/implicit_saturating_sub.rs:111:5\n    |\n LL | /     if u_usize > 0 {\n LL | |         u_usize -= 1;\n LL | |     }\n    | |_____^ help: try: `u_usize = u_usize.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:108:5\n+  --> $DIR/implicit_saturating_sub.rs:123:5\n    |\n LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:113:5\n+  --> $DIR/implicit_saturating_sub.rs:128:5\n    |\n LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:118:5\n+  --> $DIR/implicit_saturating_sub.rs:133:5\n    |\n LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:123:5\n+  --> $DIR/implicit_saturating_sub.rs:138:5\n    |\n LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:133:5\n+  --> $DIR/implicit_saturating_sub.rs:148:5\n    |\n LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:138:5\n+  --> $DIR/implicit_saturating_sub.rs:153:5\n    |\n LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:143:5\n+  --> $DIR/implicit_saturating_sub.rs:158:5\n    |\n LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:148:5\n+  --> $DIR/implicit_saturating_sub.rs:163:5\n    |\n LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:158:5\n+  --> $DIR/implicit_saturating_sub.rs:173:5\n    |\n LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:163:5\n+  --> $DIR/implicit_saturating_sub.rs:178:5\n    |\n LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:168:5\n+  --> $DIR/implicit_saturating_sub.rs:183:5\n    |\n LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:173:5\n+  --> $DIR/implicit_saturating_sub.rs:188:5\n    |\n LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:183:5\n+  --> $DIR/implicit_saturating_sub.rs:198:5\n    |\n LL | /     if i64::MIN < i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:188:5\n+  --> $DIR/implicit_saturating_sub.rs:203:5\n    |\n LL | /     if i64::MIN != i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`\n \n error: implicitly performing saturating subtraction\n-  --> $DIR/implicit_saturating_sub.rs:193:5\n+  --> $DIR/implicit_saturating_sub.rs:208:5\n    |\n LL | /     if i64::MIN < i_64 {\n LL | |         i_64 -= 1;"}, {"sha": "1a646e49ce3ae421eeec82866e98c927853e4b3a", "filename": "tests/ui/literals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fliterals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fliterals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliterals.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -40,3 +40,10 @@ fn main() {\n     let ok26 = 0x6_A0_BF;\n     let ok27 = 0b1_0010_0101;\n }\n+\n+fn issue9651() {\n+    // lint but octal form is not possible here\n+    let _ = 08;\n+    let _ = 09;\n+    let _ = 089;\n+}"}, {"sha": "603d47bacca80a0a2188b650042621ed55b0a502", "filename": "tests/ui/literals.stderr", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fliterals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fliterals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fliterals.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -135,5 +135,38 @@ error: digits of hex or binary literal not grouped by four\n LL |     let fail25 = 0b01_100_101;\n    |                  ^^^^^^^^^^^^ help: consider: `0b0110_0101`\n \n-error: aborting due to 18 previous errors\n+error: this is a decimal constant\n+  --> $DIR/literals.rs:46:13\n+   |\n+LL |     let _ = 08;\n+   |             ^^\n+   |\n+help: if you mean to use a decimal constant, remove the `0` to avoid confusion\n+   |\n+LL |     let _ = 8;\n+   |             ~\n+\n+error: this is a decimal constant\n+  --> $DIR/literals.rs:47:13\n+   |\n+LL |     let _ = 09;\n+   |             ^^\n+   |\n+help: if you mean to use a decimal constant, remove the `0` to avoid confusion\n+   |\n+LL |     let _ = 9;\n+   |             ~\n+\n+error: this is a decimal constant\n+  --> $DIR/literals.rs:48:13\n+   |\n+LL |     let _ = 089;\n+   |             ^^^\n+   |\n+help: if you mean to use a decimal constant, remove the `0` to avoid confusion\n+   |\n+LL |     let _ = 89;\n+   |             ~~\n+\n+error: aborting due to 21 previous errors\n "}, {"sha": "c9a819ba535449a1b8d90b2324204f74b318a585", "filename": "tests/ui/manual_assert.edition2018.fixed", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,6 @@\n // revisions: edition2018 edition2021\n-// [edition2018] edition:2018\n-// [edition2021] edition:2021\n+//[edition2018] edition:2018\n+//[edition2021] edition:2021\n // run-rustfix\n \n #![warn(clippy::manual_assert)]\n@@ -29,7 +29,9 @@ fn main() {\n         panic!(\"qaqaq{:?}\", a);\n     }\n     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n-    assert!(a.is_empty(), \"qwqwq\");\n+    if !a.is_empty() {\n+        panic!(\"qwqwq\");\n+    }\n     if a.len() == 3 {\n         println!(\"qwq\");\n         println!(\"qwq\");\n@@ -44,21 +46,32 @@ fn main() {\n         println!(\"qwq\");\n     }\n     let b = vec![1, 2, 3];\n-    assert!(!b.is_empty(), \"panic1\");\n-    assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n-    assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n-    assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n-    assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n+    if b.is_empty() {\n+        panic!(\"panic1\");\n+    }\n+    if b.is_empty() && a.is_empty() {\n+        panic!(\"panic2\");\n+    }\n+    if a.is_empty() && !b.is_empty() {\n+        panic!(\"panic3\");\n+    }\n+    if b.is_empty() || a.is_empty() {\n+        panic!(\"panic4\");\n+    }\n+    if a.is_empty() || !b.is_empty() {\n+        panic!(\"panic5\");\n+    }\n     assert!(!a.is_empty(), \"with expansion {}\", one!());\n }\n \n fn issue7730(a: u8) {\n     // Suggestion should preserve comment\n-    // comment\n-/* this is a\n+    if a > 2 {\n+        // comment\n+        /* this is a\n         multiline\n         comment */\n-/// Doc comment\n-// comment after `panic!`\n-assert!(!(a > 2), \"panic with comment\");\n+        /// Doc comment\n+        panic!(\"panic with comment\") // comment after `panic!`\n+    }\n }"}, {"sha": "c4e6bcd92fc1320a6805b218efdce46d84c41848", "filename": "tests/ui/manual_assert.edition2018.stderr", "status": "modified", "additions": 1, "deletions": 96, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2018.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -12,84 +12,6 @@ help: try instead\n LL |     assert!(a.is_empty(), \"qaqaq{:?}\", a);\n    |\n \n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:34:5\n-   |\n-LL | /     if !a.is_empty() {\n-LL | |         panic!(\"qwqwq\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(a.is_empty(), \"qwqwq\");\n-   |\n-\n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:51:5\n-   |\n-LL | /     if b.is_empty() {\n-LL | |         panic!(\"panic1\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!b.is_empty(), \"panic1\");\n-   |\n-\n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:54:5\n-   |\n-LL | /     if b.is_empty() && a.is_empty() {\n-LL | |         panic!(\"panic2\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(b.is_empty() && a.is_empty()), \"panic2\");\n-   |\n-\n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:57:5\n-   |\n-LL | /     if a.is_empty() && !b.is_empty() {\n-LL | |         panic!(\"panic3\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(a.is_empty() && !b.is_empty()), \"panic3\");\n-   |\n-\n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:60:5\n-   |\n-LL | /     if b.is_empty() || a.is_empty() {\n-LL | |         panic!(\"panic4\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(b.is_empty() || a.is_empty()), \"panic4\");\n-   |\n-\n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:63:5\n-   |\n-LL | /     if a.is_empty() || !b.is_empty() {\n-LL | |         panic!(\"panic5\");\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(a.is_empty() || !b.is_empty()), \"panic5\");\n-   |\n-\n error: only a `panic!` in `if`-then statement\n   --> $DIR/manual_assert.rs:66:5\n    |\n@@ -103,22 +25,5 @@ help: try instead\n LL |     assert!(!a.is_empty(), \"with expansion {}\", one!());\n    |\n \n-error: only a `panic!` in `if`-then statement\n-  --> $DIR/manual_assert.rs:73:5\n-   |\n-LL | /     if a > 2 {\n-LL | |         // comment\n-LL | |         /* this is a\n-LL | |         multiline\n-...  |\n-LL | |         panic!(\"panic with comment\") // comment after `panic!`\n-LL | |     }\n-   | |_____^\n-   |\n-help: try instead\n-   |\n-LL |     assert!(!(a > 2), \"panic with comment\");\n-   |\n-\n-error: aborting due to 9 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "2f62de51cadcd948a98c0b75668aa2f13c6b4a92", "filename": "tests/ui/manual_assert.edition2021.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.edition2021.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.edition2021.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.edition2021.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,6 @@\n // revisions: edition2018 edition2021\n-// [edition2018] edition:2018\n-// [edition2021] edition:2021\n+//[edition2018] edition:2018\n+//[edition2021] edition:2021\n // run-rustfix\n \n #![warn(clippy::manual_assert)]"}, {"sha": "6a4cc2468d4193815b6b43299db873b95d8fb33d", "filename": "tests/ui/manual_assert.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_assert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_assert.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,6 @@\n // revisions: edition2018 edition2021\n-// [edition2018] edition:2018\n-// [edition2021] edition:2021\n+//[edition2018] edition:2018\n+//[edition2021] edition:2021\n // run-rustfix\n \n #![warn(clippy::manual_assert)]"}, {"sha": "3553291b87df6731aca2e71f905ed63eef21cda7", "filename": "tests/ui/manual_filter.fixed", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_filter.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_filter.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,119 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_filter)]\n+#![allow(unused_variables, dead_code)]\n+\n+fn main() {\n+    Some(0).filter(|&x| x <= 0);\n+\n+    Some(1).filter(|&x| x <= 0);\n+\n+    Some(2).filter(|&x| x <= 0);\n+\n+    Some(3).filter(|&x| x > 0);\n+\n+    let y = Some(4);\n+    y.filter(|&x| x <= 0);\n+\n+    Some(5).filter(|&x| x > 0);\n+\n+    Some(6).as_ref().filter(|&x| x > &0);\n+\n+    let external_cond = true;\n+    Some(String::new()).filter(|x| external_cond);\n+\n+    Some(7).filter(|&x| external_cond);\n+\n+    Some(8).filter(|&x| x != 0);\n+\n+    Some(9).filter(|&x| x > 10 && x < 100);\n+\n+    const fn f1() {\n+        // Don't lint, `.filter` is not const\n+        match Some(10) {\n+            Some(x) => {\n+                if x > 10 && x < 100 {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            },\n+            None => None,\n+        };\n+    }\n+\n+    #[allow(clippy::blocks_in_if_conditions)]\n+    Some(11).filter(|&x| {\n+                println!(\"foo\");\n+                x > 10 && x < 100\n+            });\n+\n+    match Some(12) {\n+        // Don't Lint, statement is lost by `.filter`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(13) {\n+        // Don't Lint, because of `None => Some(1)`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => Some(1),\n+    };\n+\n+    unsafe fn f(x: u32) -> bool {\n+        true\n+    }\n+    let _ = Some(14).filter(|&x| unsafe { f(x) });\n+    let _ = Some(15).filter(|&x| unsafe { f(x) });\n+\n+    #[allow(clippy::redundant_pattern_matching)]\n+    if let Some(_) = Some(16) {\n+        Some(16)\n+    } else { Some(16).filter(|&x| x % 2 == 0) };\n+\n+    match Some((17, 17)) {\n+        // Not linted for now could be\n+        Some((x, y)) => {\n+            if y != x {\n+                Some((x, y))\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    struct NamedTuple {\n+        pub x: u8,\n+        pub y: (i32, u32),\n+    }\n+\n+    match Some(NamedTuple {\n+        // Not linted for now could be\n+        x: 17,\n+        y: (18, 19),\n+    }) {\n+        Some(NamedTuple { x, y }) => {\n+            if y.1 != x as u32 {\n+                Some(NamedTuple { x, y })\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+}"}, {"sha": "aa9f90f752b1790b1cb3ef52d6052d12221503c6", "filename": "tests/ui/manual_filter.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,243 @@\n+// run-rustfix\n+\n+#![warn(clippy::manual_filter)]\n+#![allow(unused_variables, dead_code)]\n+\n+fn main() {\n+    match Some(0) {\n+        None => None,\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+    };\n+\n+    match Some(1) {\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(2) {\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(3) {\n+        Some(x) => {\n+            if x > 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    let y = Some(4);\n+    match y {\n+        // Some(4)\n+        None => None,\n+        Some(x) => {\n+            if x > 0 {\n+                None\n+            } else {\n+                Some(x)\n+            }\n+        },\n+    };\n+\n+    match Some(5) {\n+        Some(x) => {\n+            if x > 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(6) {\n+        Some(ref x) => {\n+            if x > &0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    let external_cond = true;\n+    match Some(String::new()) {\n+        Some(x) => {\n+            if external_cond {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    if let Some(x) = Some(7) {\n+        if external_cond { Some(x) } else { None }\n+    } else {\n+        None\n+    };\n+\n+    match &Some(8) {\n+        &Some(x) => {\n+            if x != 0 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    };\n+\n+    match Some(9) {\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    const fn f1() {\n+        // Don't lint, `.filter` is not const\n+        match Some(10) {\n+            Some(x) => {\n+                if x > 10 && x < 100 {\n+                    Some(x)\n+                } else {\n+                    None\n+                }\n+            },\n+            None => None,\n+        };\n+    }\n+\n+    #[allow(clippy::blocks_in_if_conditions)]\n+    match Some(11) {\n+        // Lint, statement is preserved by `.filter`\n+        Some(x) => {\n+            if {\n+                println!(\"foo\");\n+                x > 10 && x < 100\n+            } {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(12) {\n+        // Don't Lint, statement is lost by `.filter`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    match Some(13) {\n+        // Don't Lint, because of `None => Some(1)`\n+        Some(x) => {\n+            if x > 10 && x < 100 {\n+                println!(\"foo\");\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => Some(1),\n+    };\n+\n+    unsafe fn f(x: u32) -> bool {\n+        true\n+    }\n+    let _ = match Some(14) {\n+        Some(x) => {\n+            if unsafe { f(x) } {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+    let _ = match Some(15) {\n+        Some(x) => unsafe {\n+            if f(x) { Some(x) } else { None }\n+        },\n+        None => None,\n+    };\n+\n+    #[allow(clippy::redundant_pattern_matching)]\n+    if let Some(_) = Some(16) {\n+        Some(16)\n+    } else if let Some(x) = Some(16) {\n+        // Lint starting from here\n+        if x % 2 == 0 { Some(x) } else { None }\n+    } else {\n+        None\n+    };\n+\n+    match Some((17, 17)) {\n+        // Not linted for now could be\n+        Some((x, y)) => {\n+            if y != x {\n+                Some((x, y))\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    struct NamedTuple {\n+        pub x: u8,\n+        pub y: (i32, u32),\n+    }\n+\n+    match Some(NamedTuple {\n+        // Not linted for now could be\n+        x: 17,\n+        y: (18, 19),\n+    }) {\n+        Some(NamedTuple { x, y }) => {\n+            if y.1 != x as u32 {\n+                Some(NamedTuple { x, y })\n+            } else {\n+                None\n+            }\n+        },\n+        None => None,\n+    };\n+}"}, {"sha": "53dea9229306bb2dc2ac21f4eedc46ed8e735e19", "filename": "tests/ui/manual_filter.stderr", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_filter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmanual_filter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_filter.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,191 @@\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:7:5\n+   |\n+LL | /     match Some(0) {\n+LL | |         None => None,\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+...  |\n+LL | |         },\n+LL | |     };\n+   | |_____^ help: try this: `Some(0).filter(|&x| x <= 0)`\n+   |\n+   = note: `-D clippy::manual-filter` implied by `-D warnings`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:18:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 None\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(1).filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:29:5\n+   |\n+LL | /     match Some(2) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 None\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(2).filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:40:5\n+   |\n+LL | /     match Some(3) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(3).filter(|&x| x > 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:52:5\n+   |\n+LL | /     match y {\n+LL | |         // Some(4)\n+LL | |         None => None,\n+LL | |         Some(x) => {\n+...  |\n+LL | |         },\n+LL | |     };\n+   | |_____^ help: try this: `y.filter(|&x| x <= 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:64:5\n+   |\n+LL | /     match Some(5) {\n+LL | |         Some(x) => {\n+LL | |             if x > 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(5).filter(|&x| x > 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:75:5\n+   |\n+LL | /     match Some(6) {\n+LL | |         Some(ref x) => {\n+LL | |             if x > &0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(6).as_ref().filter(|&x| x > &0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:87:5\n+   |\n+LL | /     match Some(String::new()) {\n+LL | |         Some(x) => {\n+LL | |             if external_cond {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(String::new()).filter(|x| external_cond)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:98:5\n+   |\n+LL | /     if let Some(x) = Some(7) {\n+LL | |         if external_cond { Some(x) } else { None }\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `Some(7).filter(|&x| external_cond)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:104:5\n+   |\n+LL | /     match &Some(8) {\n+LL | |         &Some(x) => {\n+LL | |             if x != 0 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         _ => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(8).filter(|&x| x != 0)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:115:5\n+   |\n+LL | /     match Some(9) {\n+LL | |         Some(x) => {\n+LL | |             if x > 10 && x < 100 {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(9).filter(|&x| x > 10 && x < 100)`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:141:5\n+   |\n+LL | /     match Some(11) {\n+LL | |         // Lint, statement is preserved by `.filter`\n+LL | |         Some(x) => {\n+LL | |             if {\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL ~     Some(11).filter(|&x| {\n+LL +                 println!(\"foo\");\n+LL +                 x > 10 && x < 100\n+LL ~             });\n+   |\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:185:13\n+   |\n+LL |       let _ = match Some(14) {\n+   |  _____________^\n+LL | |         Some(x) => {\n+LL | |             if unsafe { f(x) } {\n+LL | |                 Some(x)\n+...  |\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(14).filter(|&x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:195:13\n+   |\n+LL |       let _ = match Some(15) {\n+   |  _____________^\n+LL | |         Some(x) => unsafe {\n+LL | |             if f(x) { Some(x) } else { None }\n+LL | |         },\n+LL | |         None => None,\n+LL | |     };\n+   | |_____^ help: try this: `Some(15).filter(|&x| unsafe { f(x) })`\n+\n+error: manual implementation of `Option::filter`\n+  --> $DIR/manual_filter.rs:205:12\n+   |\n+LL |       } else if let Some(x) = Some(16) {\n+   |  ____________^\n+LL | |         // Lint starting from here\n+LL | |         if x % 2 == 0 { Some(x) } else { None }\n+LL | |     } else {\n+LL | |         None\n+LL | |     };\n+   | |_____^ help: try this: `{ Some(16).filter(|&x| x % 2 == 0) }`\n+\n+error: aborting due to 15 previous errors\n+"}, {"sha": "b4097fa96045e8bba47501bc2714557a1f55ba39", "filename": "tests/ui/match_overlapping_arm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_overlapping_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_overlapping_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,4 @@\n #![feature(exclusive_range_pattern)]\n-\n #![warn(clippy::match_overlapping_arm)]\n #![allow(clippy::redundant_pattern_matching)]\n #![allow(clippy::if_same_then_else, clippy::equatable_if_let)]"}, {"sha": "b98d4799e42cad2c4370b4635f408cdc43bcb646", "filename": "tests/ui/match_overlapping_arm.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_overlapping_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_overlapping_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,96 +1,96 @@\n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:13:9\n+  --> $DIR/match_overlapping_arm.rs:12:9\n    |\n LL |         0..=10 => println!(\"0..=10\"),\n    |         ^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:14:9\n+  --> $DIR/match_overlapping_arm.rs:13:9\n    |\n LL |         0..=11 => println!(\"0..=11\"),\n    |         ^^^^^^\n    = note: `-D clippy::match-overlapping-arm` implied by `-D warnings`\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:19:9\n+  --> $DIR/match_overlapping_arm.rs:18:9\n    |\n LL |         0..=5 => println!(\"0..=5\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:21:9\n+  --> $DIR/match_overlapping_arm.rs:20:9\n    |\n LL |         FOO..=11 => println!(\"FOO..=11\"),\n    |         ^^^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:56:9\n+  --> $DIR/match_overlapping_arm.rs:55:9\n    |\n LL |         0..11 => println!(\"0..11\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:57:9\n+  --> $DIR/match_overlapping_arm.rs:56:9\n    |\n LL |         0..=11 => println!(\"0..=11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:81:9\n+  --> $DIR/match_overlapping_arm.rs:80:9\n    |\n LL |         0..=10 => println!(\"0..=10\"),\n    |         ^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:80:9\n+  --> $DIR/match_overlapping_arm.rs:79:9\n    |\n LL |         5..14 => println!(\"5..14\"),\n    |         ^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:86:9\n+  --> $DIR/match_overlapping_arm.rs:85:9\n    |\n LL |         0..7 => println!(\"0..7\"),\n    |         ^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:87:9\n+  --> $DIR/match_overlapping_arm.rs:86:9\n    |\n LL |         0..=10 => println!(\"0..=10\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:98:9\n+  --> $DIR/match_overlapping_arm.rs:97:9\n    |\n LL |         ..=23 => println!(\"..=23\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:99:9\n+  --> $DIR/match_overlapping_arm.rs:98:9\n    |\n LL |         ..26 => println!(\"..26\"),\n    |         ^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:107:9\n+  --> $DIR/match_overlapping_arm.rs:106:9\n    |\n LL |         21..=30 => (),\n    |         ^^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:108:9\n+  --> $DIR/match_overlapping_arm.rs:107:9\n    |\n LL |         21..=40 => (),\n    |         ^^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:121:9\n+  --> $DIR/match_overlapping_arm.rs:120:9\n    |\n LL |         0..=0x0000_0000_0000_00ff => (),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:122:9\n+  --> $DIR/match_overlapping_arm.rs:121:9\n    |\n LL |         0..=0x0000_0000_0000_ffff => (),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a6e315e4773a27907382516d8e37efe5d3d8476b", "filename": "tests/ui/match_single_binding.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_single_binding.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_single_binding.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -124,3 +124,12 @@ fn issue_8723() {\n \n     let _ = val;\n }\n+\n+#[allow(dead_code)]\n+fn issue_9575() {\n+    fn side_effects() {}\n+    let _ = || {\n+        side_effects();\n+        println!(\"Needs curlies\");\n+    };\n+}"}, {"sha": "cecbd703e56698cd9292ea24de374cffa03b3e47", "filename": "tests/ui/match_single_binding.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_single_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_single_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -140,3 +140,11 @@ fn issue_8723() {\n \n     let _ = val;\n }\n+\n+#[allow(dead_code)]\n+fn issue_9575() {\n+    fn side_effects() {}\n+    let _ = || match side_effects() {\n+        _ => println!(\"Needs curlies\"),\n+    };\n+}"}, {"sha": "2b9ec7ee7026e4a31f6fdfa7c4f06d06825acde3", "filename": "tests/ui/match_single_binding.stderr", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_single_binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_single_binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_single_binding.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -196,5 +196,22 @@ LL +         suf\n LL ~     };\n    |\n \n-error: aborting due to 13 previous errors\n+error: this match could be replaced by its scrutinee and body\n+  --> $DIR/match_single_binding.rs:147:16\n+   |\n+LL |       let _ = || match side_effects() {\n+   |  ________________^\n+LL | |         _ => println!(\"Needs curlies\"),\n+LL | |     };\n+   | |_____^\n+   |\n+help: consider using the scrutinee and body instead\n+   |\n+LL ~     let _ = || {\n+LL +         side_effects();\n+LL +         println!(\"Needs curlies\");\n+LL ~     };\n+   |\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "525533bf07bb08958a977db61f19770c2ad2c58a", "filename": "tests/ui/match_wild_err_arm.edition2021.stderr", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b/tests%2Fui%2Fmatch_wild_err_arm.edition2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b/tests%2Fui%2Fmatch_wild_err_arm.edition2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wild_err_arm.edition2021.stderr?ref=4f50e6f41ec8b55a6dc52066dc15fa5d17b8e39b", "patch": "@@ -1,35 +0,0 @@\n-error: `Err(_)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:14:9\n-   |\n-LL |         Err(_) => panic!(\"err\"),\n-   |         ^^^^^^\n-   |\n-   = note: match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\n-   = note: `-D clippy::match-wild-err-arm` implied by `-D warnings`\n-\n-error: `Err(_)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:20:9\n-   |\n-LL |         Err(_) => panic!(),\n-   |         ^^^^^^\n-   |\n-   = note: match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\n-\n-error: `Err(_)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:26:9\n-   |\n-LL |         Err(_) => {\n-   |         ^^^^^^\n-   |\n-   = note: match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\n-\n-error: `Err(_e)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:34:9\n-   |\n-LL |         Err(_e) => panic!(),\n-   |         ^^^^^^^\n-   |\n-   = note: match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\n-\n-error: aborting due to 4 previous errors\n-"}, {"sha": "823be65efe065703b8481ced833636d15b245373", "filename": "tests/ui/match_wild_err_arm.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_wild_err_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_wild_err_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wild_err_arm.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,3 @@\n-// revisions: edition2018 edition2021\n-// [edition2018] edition:2018\n-// [edition2021] edition:2021\n #![feature(exclusive_range_pattern)]\n #![allow(clippy::match_same_arms)]\n #![warn(clippy::match_wild_err_arm)]"}, {"sha": "b016d682698c834a25a1c8dfd6fdfae1771a2fa4", "filename": "tests/ui/match_wild_err_arm.stderr", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_wild_err_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fmatch_wild_err_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_wild_err_arm.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,5 @@\n error: `Err(_)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:14:9\n+  --> $DIR/match_wild_err_arm.rs:11:9\n    |\n LL |         Err(_) => panic!(\"err\"),\n    |         ^^^^^^\n@@ -8,23 +8,23 @@ LL |         Err(_) => panic!(\"err\"),\n    = note: `-D clippy::match-wild-err-arm` implied by `-D warnings`\n \n error: `Err(_)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:20:9\n+  --> $DIR/match_wild_err_arm.rs:17:9\n    |\n LL |         Err(_) => panic!(),\n    |         ^^^^^^\n    |\n    = note: match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\n \n error: `Err(_)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:26:9\n+  --> $DIR/match_wild_err_arm.rs:23:9\n    |\n LL |         Err(_) => {\n    |         ^^^^^^\n    |\n    = note: match each error separately or use the error output, or use `.expect(msg)` if the error case is unreachable\n \n error: `Err(_e)` matches all errors\n-  --> $DIR/match_wild_err_arm.rs:34:9\n+  --> $DIR/match_wild_err_arm.rs:31:9\n    |\n LL |         Err(_e) => panic!(),\n    |         ^^^^^^^", "previous_filename": "tests/ui/match_wild_err_arm.edition2018.stderr"}, {"sha": "340e89d2db1d2c25d97f14fd242ede26de1bb2eb", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,7 +3,11 @@\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables)]\n-#[allow(clippy::uninlined_format_args, clippy::unnecessary_mut_passed)]\n+#[allow(\n+    clippy::uninlined_format_args,\n+    clippy::unnecessary_mut_passed,\n+    clippy::unnecessary_to_owned\n+)]\n fn main() {\n     let a = 5;\n     let ref_a = &a;\n@@ -134,6 +138,7 @@ fn main() {\n     multiple_constraints([[\"\"]]);\n     multiple_constraints_normalizes_to_same(X, X);\n     let _ = Some(\"\").unwrap_or(\"\");\n+    let _ = std::fs::write(\"x\", \"\".to_string());\n \n     only_sized(&\"\"); // Don't lint. `Sized` is only bound\n     let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n@@ -276,8 +281,9 @@ mod copyable_iterator {\n     fn dont_warn(mut x: Iter) {\n         takes_iter(&mut x);\n     }\n+    #[allow(unused_mut)]\n     fn warn(mut x: &mut Iter) {\n-        takes_iter(&mut x)\n+        takes_iter(x)\n     }\n }\n \n@@ -327,3 +333,55 @@ fn issue9383() {\n         ManuallyDrop::drop(&mut ocean.coral);\n     }\n }\n+\n+#[allow(dead_code)]\n+fn closure_test() {\n+    let env = \"env\".to_owned();\n+    let arg = \"arg\".to_owned();\n+    let f = |arg| {\n+        let loc = \"loc\".to_owned();\n+        let _ = std::fs::write(\"x\", &env); // Don't lint. In environment\n+        let _ = std::fs::write(\"x\", arg);\n+        let _ = std::fs::write(\"x\", loc);\n+    };\n+    let _ = std::fs::write(\"x\", &env); // Don't lint. Borrowed by `f`\n+    f(arg);\n+}\n+\n+#[allow(dead_code)]\n+mod significant_drop {\n+    #[derive(Debug)]\n+    struct X;\n+\n+    #[derive(Debug)]\n+    struct Y;\n+\n+    impl Drop for Y {\n+        fn drop(&mut self) {}\n+    }\n+\n+    fn foo(x: X, y: Y) {\n+        debug(x);\n+        debug(&y); // Don't lint. Has significant drop\n+    }\n+\n+    fn debug(_: impl std::fmt::Debug) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_exactly_once {\n+    fn foo(x: String) {\n+        use_x(x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_more_than_once {\n+    fn foo(x: String) {\n+        use_x(&x);\n+        use_x_again(&x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+    fn use_x_again(_: impl AsRef<str>) {}\n+}"}, {"sha": "c93711ac8e28490feb37a078d14f66da07e904a7", "filename": "tests/ui/needless_borrow.rs", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,7 +3,11 @@\n \n #[warn(clippy::all, clippy::needless_borrow)]\n #[allow(unused_variables)]\n-#[allow(clippy::uninlined_format_args, clippy::unnecessary_mut_passed)]\n+#[allow(\n+    clippy::uninlined_format_args,\n+    clippy::unnecessary_mut_passed,\n+    clippy::unnecessary_to_owned\n+)]\n fn main() {\n     let a = 5;\n     let ref_a = &a;\n@@ -134,6 +138,7 @@ fn main() {\n     multiple_constraints(&[[\"\"]]);\n     multiple_constraints_normalizes_to_same(&X, X);\n     let _ = Some(\"\").unwrap_or(&\"\");\n+    let _ = std::fs::write(\"x\", &\"\".to_string());\n \n     only_sized(&\"\"); // Don't lint. `Sized` is only bound\n     let _ = std::any::Any::type_id(&\"\"); // Don't lint. `Any` is only bound\n@@ -276,6 +281,7 @@ mod copyable_iterator {\n     fn dont_warn(mut x: Iter) {\n         takes_iter(&mut x);\n     }\n+    #[allow(unused_mut)]\n     fn warn(mut x: &mut Iter) {\n         takes_iter(&mut x)\n     }\n@@ -327,3 +333,55 @@ fn issue9383() {\n         ManuallyDrop::drop(&mut ocean.coral);\n     }\n }\n+\n+#[allow(dead_code)]\n+fn closure_test() {\n+    let env = \"env\".to_owned();\n+    let arg = \"arg\".to_owned();\n+    let f = |arg| {\n+        let loc = \"loc\".to_owned();\n+        let _ = std::fs::write(\"x\", &env); // Don't lint. In environment\n+        let _ = std::fs::write(\"x\", &arg);\n+        let _ = std::fs::write(\"x\", &loc);\n+    };\n+    let _ = std::fs::write(\"x\", &env); // Don't lint. Borrowed by `f`\n+    f(arg);\n+}\n+\n+#[allow(dead_code)]\n+mod significant_drop {\n+    #[derive(Debug)]\n+    struct X;\n+\n+    #[derive(Debug)]\n+    struct Y;\n+\n+    impl Drop for Y {\n+        fn drop(&mut self) {}\n+    }\n+\n+    fn foo(x: X, y: Y) {\n+        debug(&x);\n+        debug(&y); // Don't lint. Has significant drop\n+    }\n+\n+    fn debug(_: impl std::fmt::Debug) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_exactly_once {\n+    fn foo(x: String) {\n+        use_x(&x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+}\n+\n+#[allow(dead_code)]\n+mod used_more_than_once {\n+    fn foo(x: String) {\n+        use_x(&x);\n+        use_x_again(&x);\n+    }\n+    fn use_x(_: impl AsRef<str>) {}\n+    fn use_x_again(_: impl AsRef<str>) {}\n+}"}, {"sha": "8b593268bec2112b82b70c268d4c5d1ffafa9127", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 66, "deletions": 30, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,178 +1,214 @@\n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:11:15\n+  --> $DIR/needless_borrow.rs:15:15\n    |\n LL |     let _ = x(&&a); // warn\n    |               ^^^ help: change this to: `&a`\n    |\n    = note: `-D clippy::needless-borrow` implied by `-D warnings`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:15:13\n+  --> $DIR/needless_borrow.rs:19:13\n    |\n LL |     mut_ref(&mut &mut b); // warn\n    |             ^^^^^^^^^^^ help: change this to: `&mut b`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:27:13\n+  --> $DIR/needless_borrow.rs:31:13\n    |\n LL |             &&a\n    |             ^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:29:15\n+  --> $DIR/needless_borrow.rs:33:15\n    |\n LL |         46 => &&a,\n    |               ^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:35:27\n+  --> $DIR/needless_borrow.rs:39:27\n    |\n LL |                     break &ref_a;\n    |                           ^^^^^^ help: change this to: `ref_a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:42:15\n+  --> $DIR/needless_borrow.rs:46:15\n    |\n LL |     let _ = x(&&&a);\n    |               ^^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:43:15\n+  --> $DIR/needless_borrow.rs:47:15\n    |\n LL |     let _ = x(&mut &&a);\n    |               ^^^^^^^^ help: change this to: `&a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:44:15\n+  --> $DIR/needless_borrow.rs:48:15\n    |\n LL |     let _ = x(&&&mut b);\n    |               ^^^^^^^^ help: change this to: `&mut b`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:45:15\n+  --> $DIR/needless_borrow.rs:49:15\n    |\n LL |     let _ = x(&&ref_a);\n    |               ^^^^^^^ help: change this to: `ref_a`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:48:11\n+  --> $DIR/needless_borrow.rs:52:11\n    |\n LL |         x(&b);\n    |           ^^ help: change this to: `b`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:55:13\n+  --> $DIR/needless_borrow.rs:59:13\n    |\n LL |     mut_ref(&mut x);\n    |             ^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:56:13\n+  --> $DIR/needless_borrow.rs:60:13\n    |\n LL |     mut_ref(&mut &mut x);\n    |             ^^^^^^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:57:23\n+  --> $DIR/needless_borrow.rs:61:23\n    |\n LL |     let y: &mut i32 = &mut x;\n    |                       ^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:58:23\n+  --> $DIR/needless_borrow.rs:62:23\n    |\n LL |     let y: &mut i32 = &mut &mut x;\n    |                       ^^^^^^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:67:14\n+  --> $DIR/needless_borrow.rs:71:14\n    |\n LL |         0 => &mut x,\n    |              ^^^^^^ help: change this to: `x`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:73:14\n+  --> $DIR/needless_borrow.rs:77:14\n    |\n LL |         0 => &mut x,\n    |              ^^^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:85:13\n+  --> $DIR/needless_borrow.rs:89:13\n    |\n LL |     let _ = (&x).0;\n    |             ^^^^ help: change this to: `x`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:87:22\n+  --> $DIR/needless_borrow.rs:91:22\n    |\n LL |     let _ = unsafe { (&*x).0 };\n    |                      ^^^^^ help: change this to: `(*x)`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:97:5\n+  --> $DIR/needless_borrow.rs:101:5\n    |\n LL |     (&&()).foo();\n    |     ^^^^^^ help: change this to: `(&())`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:106:5\n+  --> $DIR/needless_borrow.rs:110:5\n    |\n LL |     (&&5).foo();\n    |     ^^^^^ help: change this to: `(&5)`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:131:51\n+  --> $DIR/needless_borrow.rs:135:51\n    |\n LL |     let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n    |                                                   ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:132:44\n+  --> $DIR/needless_borrow.rs:136:44\n    |\n LL |     let _ = std::path::Path::new(\".\").join(&&\".\");\n    |                                            ^^^^^ help: change this to: `\".\"`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:133:23\n+  --> $DIR/needless_borrow.rs:137:23\n    |\n LL |     deref_target_is_x(&X);\n    |                       ^^ help: change this to: `X`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:134:26\n+  --> $DIR/needless_borrow.rs:138:26\n    |\n LL |     multiple_constraints(&[[\"\"]]);\n    |                          ^^^^^^^ help: change this to: `[[\"\"]]`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:135:45\n+  --> $DIR/needless_borrow.rs:139:45\n    |\n LL |     multiple_constraints_normalizes_to_same(&X, X);\n    |                                             ^^ help: change this to: `X`\n \n error: this expression creates a reference which is immediately dereferenced by the compiler\n-  --> $DIR/needless_borrow.rs:136:32\n+  --> $DIR/needless_borrow.rs:140:32\n    |\n LL |     let _ = Some(\"\").unwrap_or(&\"\");\n    |                                ^^^ help: change this to: `\"\"`\n \n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:141:33\n+   |\n+LL |     let _ = std::fs::write(\"x\", &\"\".to_string());\n+   |                                 ^^^^^^^^^^^^^^^ help: change this to: `\"\".to_string()`\n+\n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:187:13\n+  --> $DIR/needless_borrow.rs:192:13\n    |\n LL |             (&self.f)()\n    |             ^^^^^^^^^ help: change this to: `(self.f)`\n \n error: this expression borrows a value the compiler would automatically borrow\n-  --> $DIR/needless_borrow.rs:196:13\n+  --> $DIR/needless_borrow.rs:201:13\n    |\n LL |             (&mut self.f)()\n    |             ^^^^^^^^^^^^^ help: change this to: `(self.f)`\n \n error: the borrowed expression implements the required traits\n-  --> $DIR/needless_borrow.rs:298:55\n+  --> $DIR/needless_borrow.rs:286:20\n+   |\n+LL |         takes_iter(&mut x)\n+   |                    ^^^^^^ help: change this to: `x`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:304:55\n    |\n LL |         let _ = std::process::Command::new(\"ls\").args(&[\"-a\", \"-l\"]).status().unwrap();\n    |                                                       ^^^^^^^^^^^^^ help: change this to: `[\"-a\", \"-l\"]`\n \n-error: aborting due to 29 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:344:37\n+   |\n+LL |         let _ = std::fs::write(\"x\", &arg);\n+   |                                     ^^^^ help: change this to: `arg`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:345:37\n+   |\n+LL |         let _ = std::fs::write(\"x\", &loc);\n+   |                                     ^^^^ help: change this to: `loc`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:364:15\n+   |\n+LL |         debug(&x);\n+   |               ^^ help: change this to: `x`\n+\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:374:15\n+   |\n+LL |         use_x(&x);\n+   |               ^^ help: change this to: `x`\n+\n+error: aborting due to 35 previous errors\n "}, {"sha": "23b1aa8bebd53749cf05d23ce27ff7a4195b42d1", "filename": "tests/ui/or_fun_call.fixed", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2For_fun_call.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2For_fun_call.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -225,4 +225,15 @@ mod issue8239 {\n     }\n }\n \n+mod issue9608 {\n+    fn sig_drop() {\n+        enum X {\n+            X(std::fs::File),\n+            Y(u32),\n+        }\n+\n+        let _ = None.unwrap_or(X::Y(0));\n+    }\n+}\n+\n fn main() {}"}, {"sha": "039998f22dd7147b9caf5134f1fcb5e139b11d1d", "filename": "tests/ui/or_fun_call.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2For_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2For_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_fun_call.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -225,4 +225,15 @@ mod issue8239 {\n     }\n }\n \n+mod issue9608 {\n+    fn sig_drop() {\n+        enum X {\n+            X(std::fs::File),\n+            Y(u32),\n+        }\n+\n+        let _ = None.unwrap_or(X::Y(0));\n+    }\n+}\n+\n fn main() {}"}, {"sha": "668545da8441952687a8a510735f6cdbd43b855f", "filename": "tests/ui/partial_pub_fields.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fpartial_pub_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fpartial_pub_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartial_pub_fields.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,40 @@\n+#![allow(unused)]\n+#![warn(clippy::partial_pub_fields)]\n+\n+fn main() {\n+    use std::collections::HashMap;\n+\n+    #[derive(Default)]\n+    pub struct FileSet {\n+        files: HashMap<String, u32>,\n+        pub paths: HashMap<u32, String>,\n+    }\n+\n+    pub struct Color {\n+        pub r: u8,\n+        pub g: u8,\n+        b: u8,\n+    }\n+\n+    pub struct Point(i32, pub i32);\n+\n+    pub struct Visibility {\n+        r#pub: bool,\n+        pub pos: u32,\n+    }\n+\n+    // Don't lint on empty structs;\n+    pub struct Empty1;\n+    pub struct Empty2();\n+    pub struct Empty3 {};\n+\n+    // Don't lint on structs with one field.\n+    pub struct Single1(i32);\n+    pub struct Single2(pub i32);\n+    pub struct Single3 {\n+        v1: i32,\n+    }\n+    pub struct Single4 {\n+        pub v1: i32,\n+    }\n+}"}, {"sha": "84cfc1a91940dcc9e69c0ac3945eb793867b5fd7", "filename": "tests/ui/partial_pub_fields.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fpartial_pub_fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fpartial_pub_fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpartial_pub_fields.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,35 @@\n+error: mixed usage of pub and non-pub fields\n+  --> $DIR/partial_pub_fields.rs:10:9\n+   |\n+LL |         pub paths: HashMap<u32, String>,\n+   |         ^^^\n+   |\n+   = help: consider using private field here\n+   = note: `-D clippy::partial-pub-fields` implied by `-D warnings`\n+\n+error: mixed usage of pub and non-pub fields\n+  --> $DIR/partial_pub_fields.rs:16:9\n+   |\n+LL |         b: u8,\n+   |         ^\n+   |\n+   = help: consider using public field here\n+\n+error: mixed usage of pub and non-pub fields\n+  --> $DIR/partial_pub_fields.rs:19:27\n+   |\n+LL |     pub struct Point(i32, pub i32);\n+   |                           ^^^\n+   |\n+   = help: consider using private field here\n+\n+error: mixed usage of pub and non-pub fields\n+  --> $DIR/partial_pub_fields.rs:23:9\n+   |\n+LL |         pub pos: u32,\n+   |         ^^^\n+   |\n+   = help: consider using private field here\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "5f54101ca15ad176b070974d1be290bc9aaf0374", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -3,7 +3,7 @@\n #![warn(clippy::ptr_arg)]\n \n use std::borrow::Cow;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n \n fn do_vec(x: &Vec<i64>) {\n     //Nothing here\n@@ -207,3 +207,31 @@ fn cow_conditional_to_mut(a: &mut Cow<str>) {\n         a.to_mut().push_str(\"foo\");\n     }\n }\n+\n+// Issue #9542\n+fn dyn_trait_ok(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+    trait T {}\n+    impl<U> T for Vec<U> {}\n+    impl T for String {}\n+    impl T for PathBuf {}\n+    fn takes_dyn(_: &mut dyn T) {}\n+\n+    takes_dyn(a);\n+    takes_dyn(b);\n+    takes_dyn(c);\n+}\n+\n+fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+    trait T {}\n+    impl<U> T for Vec<U> {}\n+    impl<U> T for [U] {}\n+    impl T for String {}\n+    impl T for str {}\n+    impl T for PathBuf {}\n+    impl T for Path {}\n+    fn takes_dyn(_: &mut dyn T) {}\n+\n+    takes_dyn(a);\n+    takes_dyn(b);\n+    takes_dyn(c);\n+}"}, {"sha": "6b4de98ce88c6d567f0553562356a78599670590", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -162,5 +162,23 @@ error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a sl\n LL | fn mut_vec_slice_methods(v: &mut Vec<u32>) {\n    |                             ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n \n-error: aborting due to 17 previous errors\n+error: writing `&mut Vec` instead of `&mut [_]` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:224:17\n+   |\n+LL | fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+   |                 ^^^^^^^^^^^^^ help: change this to: `&mut [u32]`\n+\n+error: writing `&mut String` instead of `&mut str` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:224:35\n+   |\n+LL | fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+   |                                   ^^^^^^^^^^^ help: change this to: `&mut str`\n+\n+error: writing `&mut PathBuf` instead of `&mut Path` involves a new object where a slice will do\n+  --> $DIR/ptr_arg.rs:224:51\n+   |\n+LL | fn dyn_trait(a: &mut Vec<u32>, b: &mut String, c: &mut PathBuf) {\n+   |                                                   ^^^^^^^^^^^^ help: change this to: `&mut Path`\n+\n+error: aborting due to 20 previous errors\n "}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "106274479751d7439a50bc2411b9106317447f3b", "filename": "tests/ui/uninlined_format_args.fixed", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -150,6 +150,19 @@ fn tester(fn_arg: i32) {\n \n     println!(with_span!(\"{0} {1}\" \"{1} {0}\"), local_i32, local_f64);\n     println!(\"{}\", with_span!(span val));\n+\n+    if local_i32 > 0 {\n+        panic!(\"p1 {local_i32}\");\n+    }\n+    if local_i32 > 0 {\n+        panic!(\"p2 {local_i32}\");\n+    }\n+    if local_i32 > 0 {\n+        panic!(\"p3 {local_i32}\");\n+    }\n+    if local_i32 > 0 {\n+        panic!(\"p4 {local_i32}\");\n+    }\n }\n \n fn main() {"}, {"sha": "8e495ebd083a55e6eacae4ba91dbc7859c5d2ec6", "filename": "tests/ui/uninlined_format_args.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -150,6 +150,19 @@ fn tester(fn_arg: i32) {\n \n     println!(with_span!(\"{0} {1}\" \"{1} {0}\"), local_i32, local_f64);\n     println!(\"{}\", with_span!(span val));\n+\n+    if local_i32 > 0 {\n+        panic!(\"p1 {}\", local_i32);\n+    }\n+    if local_i32 > 0 {\n+        panic!(\"p2 {0}\", local_i32);\n+    }\n+    if local_i32 > 0 {\n+        panic!(\"p3 {local_i32}\", local_i32 = local_i32);\n+    }\n+    if local_i32 > 0 {\n+        panic!(\"p4 {local_i32}\");\n+    }\n }\n \n fn main() {"}, {"sha": "2ce3b7fa960c6159e3c3a237d43220aa195f1516", "filename": "tests/ui/uninlined_format_args.stderr", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -828,7 +828,43 @@ LL +     println!(\"{val}\");\n    |\n \n error: variables can be used directly in the `format!` string\n-  --> $DIR/uninlined_format_args.rs:168:5\n+  --> $DIR/uninlined_format_args.rs:155:9\n+   |\n+LL |         panic!(\"p1 {}\", local_i32);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL -         panic!(\"p1 {}\", local_i32);\n+LL +         panic!(\"p1 {local_i32}\");\n+   |\n+\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args.rs:158:9\n+   |\n+LL |         panic!(\"p2 {0}\", local_i32);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL -         panic!(\"p2 {0}\", local_i32);\n+LL +         panic!(\"p2 {local_i32}\");\n+   |\n+\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args.rs:161:9\n+   |\n+LL |         panic!(\"p3 {local_i32}\", local_i32 = local_i32);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL -         panic!(\"p3 {local_i32}\", local_i32 = local_i32);\n+LL +         panic!(\"p3 {local_i32}\");\n+   |\n+\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args.rs:181:5\n    |\n LL |     println!(\"expand='{}'\", local_i32);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -839,5 +875,5 @@ LL -     println!(\"expand='{}'\", local_i32);\n LL +     println!(\"expand='{local_i32}'\");\n    |\n \n-error: aborting due to 70 previous errors\n+error: aborting due to 73 previous errors\n "}, {"sha": "96cc0877960ec00c627a896f5eb54cafc633f2c1", "filename": "tests/ui/uninlined_format_args_panic.edition2018.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2018.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2018.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args_panic.edition2018.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,29 @@\n+// revisions: edition2018 edition2021\n+//[edition2018] edition:2018\n+//[edition2021] edition:2021\n+// run-rustfix\n+\n+#![warn(clippy::uninlined_format_args)]\n+\n+fn main() {\n+    let var = 1;\n+\n+    println!(\"val='{var}'\");\n+\n+    if var > 0 {\n+        panic!(\"p1 {}\", var);\n+    }\n+    if var > 0 {\n+        panic!(\"p2 {0}\", var);\n+    }\n+    if var > 0 {\n+        panic!(\"p3 {var}\", var = var);\n+    }\n+\n+    #[allow(non_fmt_panics)]\n+    {\n+        if var > 0 {\n+            panic!(\"p4 {var}\");\n+        }\n+    }\n+}"}, {"sha": "2c8061259229a83f8f82609b7800cb12c226fabe", "filename": "tests/ui/uninlined_format_args_panic.edition2018.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args_panic.edition2018.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,15 @@\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args_panic.rs:11:5\n+   |\n+LL |     println!(\"val='{}'\", var);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::uninlined-format-args` implied by `-D warnings`\n+help: change this to\n+   |\n+LL -     println!(\"val='{}'\", var);\n+LL +     println!(\"val='{var}'\");\n+   |\n+\n+error: aborting due to previous error\n+"}, {"sha": "faf8ca4d3a797aa2e989571786cd8c317a2e6652", "filename": "tests/ui/uninlined_format_args_panic.edition2021.fixed", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2021.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2021.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args_panic.edition2021.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,29 @@\n+// revisions: edition2018 edition2021\n+//[edition2018] edition:2018\n+//[edition2021] edition:2021\n+// run-rustfix\n+\n+#![warn(clippy::uninlined_format_args)]\n+\n+fn main() {\n+    let var = 1;\n+\n+    println!(\"val='{var}'\");\n+\n+    if var > 0 {\n+        panic!(\"p1 {var}\");\n+    }\n+    if var > 0 {\n+        panic!(\"p2 {var}\");\n+    }\n+    if var > 0 {\n+        panic!(\"p3 {var}\");\n+    }\n+\n+    #[allow(non_fmt_panics)]\n+    {\n+        if var > 0 {\n+            panic!(\"p4 {var}\");\n+        }\n+    }\n+}"}, {"sha": "0f09c45f41324b94da38117a4d885deabe904c0f", "filename": "tests/ui/uninlined_format_args_panic.edition2021.stderr", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2021.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.edition2021.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args_panic.edition2021.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,51 @@\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args_panic.rs:11:5\n+   |\n+LL |     println!(\"val='{}'\", var);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::uninlined-format-args` implied by `-D warnings`\n+help: change this to\n+   |\n+LL -     println!(\"val='{}'\", var);\n+LL +     println!(\"val='{var}'\");\n+   |\n+\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args_panic.rs:14:9\n+   |\n+LL |         panic!(\"p1 {}\", var);\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL -         panic!(\"p1 {}\", var);\n+LL +         panic!(\"p1 {var}\");\n+   |\n+\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args_panic.rs:17:9\n+   |\n+LL |         panic!(\"p2 {0}\", var);\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL -         panic!(\"p2 {0}\", var);\n+LL +         panic!(\"p2 {var}\");\n+   |\n+\n+error: variables can be used directly in the `format!` string\n+  --> $DIR/uninlined_format_args_panic.rs:20:9\n+   |\n+LL |         panic!(\"p3 {var}\", var = var);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: change this to\n+   |\n+LL -         panic!(\"p3 {var}\", var = var);\n+LL +         panic!(\"p3 {var}\");\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "6421c5bbed2f5a05a6b5523d8560f36a374ca6c3", "filename": "tests/ui/uninlined_format_args_panic.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funinlined_format_args_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinlined_format_args_panic.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,29 @@\n+// revisions: edition2018 edition2021\n+//[edition2018] edition:2018\n+//[edition2021] edition:2021\n+// run-rustfix\n+\n+#![warn(clippy::uninlined_format_args)]\n+\n+fn main() {\n+    let var = 1;\n+\n+    println!(\"val='{}'\", var);\n+\n+    if var > 0 {\n+        panic!(\"p1 {}\", var);\n+    }\n+    if var > 0 {\n+        panic!(\"p2 {0}\", var);\n+    }\n+    if var > 0 {\n+        panic!(\"p3 {var}\", var = var);\n+    }\n+\n+    #[allow(non_fmt_panics)]\n+    {\n+        if var > 0 {\n+            panic!(\"p4 {var}\");\n+        }\n+    }\n+}"}, {"sha": "ec8c6abfab91e725891f268967c59dabcb101e13", "filename": "tests/ui/unnecessary_cast.fixed", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_cast.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_cast.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -111,4 +111,8 @@ mod fixable {\n \n         let _num = foo();\n     }\n+\n+    fn issue_9603() {\n+        let _: f32 = -0x400 as f32;\n+    }\n }"}, {"sha": "5213cdc269bd4c5a9aec63cb2c5ff31a87e4ccf9", "filename": "tests/ui/unnecessary_cast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_cast.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -111,4 +111,8 @@ mod fixable {\n \n         let _num = foo() as f32;\n     }\n+\n+    fn issue_9603() {\n+        let _: f32 = -0x400 as f32;\n+    }\n }"}, {"sha": "fe09aad06bc84d792c10d99a04e8fdd37f05bdbd", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::ptr_arg)]\n+#![allow(clippy::needless_borrow, clippy::ptr_arg)]\n #![warn(clippy::unnecessary_to_owned)]\n #![feature(custom_inner_attributes)]\n "}, {"sha": "3de6d0903c0f1d0e083fa5de7fc89cfc331fe1a1", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(clippy::ptr_arg)]\n+#![allow(clippy::needless_borrow, clippy::ptr_arg)]\n #![warn(clippy::unnecessary_to_owned)]\n #![feature(custom_inner_attributes)]\n "}, {"sha": "2930722b42d9d4f39d33deb8119a3659b11df891", "filename": "tests/ui/unused_format_specs.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.fixed?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::unused_format_specs)]\n+#![allow(unused)]\n+\n+fn main() {\n+    let f = 1.0f64;\n+    println!(\"{}\", 1.0);\n+    println!(\"{f} {f:?}\");\n+\n+    println!(\"{}\", 1);\n+}\n+\n+fn should_not_lint() {\n+    let f = 1.0f64;\n+    println!(\"{:.1}\", 1.0);\n+    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n+}"}, {"sha": "ee192a000d4b55e6fd4d1a8c8ba72238cc626a4f", "filename": "tests/ui/unused_format_specs.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::unused_format_specs)]\n+#![allow(unused)]\n+\n+fn main() {\n+    let f = 1.0f64;\n+    println!(\"{:.}\", 1.0);\n+    println!(\"{f:.} {f:.?}\");\n+\n+    println!(\"{:.}\", 1);\n+}\n+\n+fn should_not_lint() {\n+    let f = 1.0f64;\n+    println!(\"{:.1}\", 1.0);\n+    println!(\"{f:.w$} {f:.*?}\", 3, w = 2);\n+}"}, {"sha": "7231c17e74c19cd9de5c4c36d6c227594917f147", "filename": "tests/ui/unused_format_specs.stderr", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,54 @@\n+error: empty precision specifier has no effect\n+  --> $DIR/unused_format_specs.rs:8:17\n+   |\n+LL |     println!(\"{:.}\", 1.0);\n+   |                 ^\n+   |\n+   = note: a precision specifier is not required to format floats\n+   = note: `-D clippy::unused-format-specs` implied by `-D warnings`\n+help: remove the `.`\n+   |\n+LL -     println!(\"{:.}\", 1.0);\n+LL +     println!(\"{}\", 1.0);\n+   |\n+\n+error: empty precision specifier has no effect\n+  --> $DIR/unused_format_specs.rs:9:18\n+   |\n+LL |     println!(\"{f:.} {f:.?}\");\n+   |                  ^\n+   |\n+   = note: a precision specifier is not required to format floats\n+help: remove the `.`\n+   |\n+LL -     println!(\"{f:.} {f:.?}\");\n+LL +     println!(\"{f} {f:.?}\");\n+   |\n+\n+error: empty precision specifier has no effect\n+  --> $DIR/unused_format_specs.rs:9:24\n+   |\n+LL |     println!(\"{f:.} {f:.?}\");\n+   |                        ^\n+   |\n+   = note: a precision specifier is not required to format floats\n+help: remove the `.`\n+   |\n+LL -     println!(\"{f:.} {f:.?}\");\n+LL +     println!(\"{f:.} {f:?}\");\n+   |\n+\n+error: empty precision specifier has no effect\n+  --> $DIR/unused_format_specs.rs:11:17\n+   |\n+LL |     println!(\"{:.}\", 1);\n+   |                 ^\n+   |\n+help: remove the `.`\n+   |\n+LL -     println!(\"{:.}\", 1);\n+LL +     println!(\"{}\", 1);\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "78601a3483d347428d5f2fededb5b42cb6a5d5ef", "filename": "tests/ui/unused_format_specs_unfixable.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs_unfixable.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,30 @@\n+#![warn(clippy::unused_format_specs)]\n+#![allow(unused)]\n+\n+macro_rules! format_args_from_macro {\n+    () => {\n+        format_args!(\"from macro\")\n+    };\n+}\n+\n+fn main() {\n+    // prints `.`, not `     .`\n+    println!(\"{:5}.\", format_args!(\"\"));\n+    //prints `abcde`, not `abc`\n+    println!(\"{:.3}\", format_args!(\"abcde\"));\n+\n+    println!(\"{:5}.\", format_args_from_macro!());\n+\n+    let args = format_args!(\"\");\n+    println!(\"{args:5}\");\n+}\n+\n+fn should_not_lint() {\n+    println!(\"{}\", format_args!(\"\"));\n+    // Technically the same as `{}`, but the `format_args` docs specifically mention that you can use\n+    // debug formatting so allow it\n+    println!(\"{:?}\", format_args!(\"\"));\n+\n+    let args = format_args!(\"\");\n+    println!(\"{args}\");\n+}"}, {"sha": "9f1890282e6ac91f4e140e413de3e9ced145958f", "filename": "tests/ui/unused_format_specs_unfixable.stderr", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fui%2Funused_format_specs_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_format_specs_unfixable.stderr?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -0,0 +1,69 @@\n+error: format specifiers have no effect on `format_args!()`\n+  --> $DIR/unused_format_specs_unfixable.rs:12:15\n+   |\n+LL |     println!(\"{:5}.\", format_args!(\"\"));\n+   |               ^^^^\n+   |\n+   = note: `-D clippy::unused-format-specs` implied by `-D warnings`\n+help: for the width to apply consider using `format!()`\n+   |\n+LL |     println!(\"{:5}.\", format!(\"\"));\n+   |                       ~~~~~~\n+help: if the current behavior is intentional, remove the format specifiers\n+   |\n+LL -     println!(\"{:5}.\", format_args!(\"\"));\n+LL +     println!(\"{}.\", format_args!(\"\"));\n+   |\n+\n+error: format specifiers have no effect on `format_args!()`\n+  --> $DIR/unused_format_specs_unfixable.rs:14:15\n+   |\n+LL |     println!(\"{:.3}\", format_args!(\"abcde\"));\n+   |               ^^^^^\n+   |\n+help: for the precision to apply consider using `format!()`\n+   |\n+LL |     println!(\"{:.3}\", format!(\"abcde\"));\n+   |                       ~~~~~~\n+help: if the current behavior is intentional, remove the format specifiers\n+   |\n+LL -     println!(\"{:.3}\", format_args!(\"abcde\"));\n+LL +     println!(\"{}\", format_args!(\"abcde\"));\n+   |\n+\n+error: format specifiers have no effect on `format_args!()`\n+  --> $DIR/unused_format_specs_unfixable.rs:16:15\n+   |\n+LL |     println!(\"{:5}.\", format_args_from_macro!());\n+   |               ^^^^\n+   |\n+help: for the width to apply consider using `format!()`\n+  --> $DIR/unused_format_specs_unfixable.rs:16:17\n+   |\n+LL |     println!(\"{:5}.\", format_args_from_macro!());\n+   |                 ^\n+help: if the current behavior is intentional, remove the format specifiers\n+   |\n+LL -     println!(\"{:5}.\", format_args_from_macro!());\n+LL +     println!(\"{}.\", format_args_from_macro!());\n+   |\n+\n+error: format specifiers have no effect on `format_args!()`\n+  --> $DIR/unused_format_specs_unfixable.rs:19:15\n+   |\n+LL |     println!(\"{args:5}\");\n+   |               ^^^^^^^^\n+   |\n+help: for the width to apply consider using `format!()`\n+  --> $DIR/unused_format_specs_unfixable.rs:19:21\n+   |\n+LL |     println!(\"{args:5}\");\n+   |                     ^\n+help: if the current behavior is intentional, remove the format specifiers\n+   |\n+LL -     println!(\"{args:5}\");\n+LL +     println!(\"{args}\");\n+   |\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "a6d8d0307ce536900c51a6986b034afc2690fa74", "filename": "tests/versioncheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fversioncheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/tests%2Fversioncheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fversioncheck.rs?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -48,7 +48,7 @@ fn check_that_clippy_has_the_same_major_version_as_rustc() {\n     // `RUSTC_REAL` if Clippy is build in the Rust repo with `./x.py`.\n     let rustc = std::env::var(\"RUSTC_REAL\").unwrap_or_else(|_| \"rustc\".to_string());\n     let rustc_version = String::from_utf8(\n-        std::process::Command::new(&rustc)\n+        std::process::Command::new(rustc)\n             .arg(\"--version\")\n             .output()\n             .expect(\"failed to run `rustc --version`\")"}, {"sha": "e46ad2c6e0eec7bdf576d4cc05dc630244a6e0a8", "filename": "util/gh-pages/index.html", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/util%2Fgh-pages%2Findex.html", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/util%2Fgh-pages%2Findex.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Findex.html?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -442,6 +442,12 @@ <h1>Clippy Lints</h1>\n                                         All\n                                     </label>\n                                 </li>\n+                                <li class=\"checkbox\">\n+                                    <label ng-click=\"resetGroupsToDefault()\">\n+                                        <input type=\"checkbox\" class=\"invisible\" />\n+                                        Default\n+                                    </label>\n+                                </li>\n                                 <li class=\"checkbox\">\n                                     <label ng-click=\"toggleGroups(false)\">\n                                         <input type=\"checkbox\" class=\"invisible\" />"}, {"sha": "1c16ecd6b0b1f13bb23cfa04696f93d0a1e87416", "filename": "util/gh-pages/script.js", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/util%2Fgh-pages%2Fscript.js", "raw_url": "https://github.com/rust-lang/rust/raw/fb8ecb983258aafdf0e8a56c565a615e1e1dafb4/util%2Fgh-pages%2Fscript.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fgh-pages%2Fscript.js?ref=fb8ecb983258aafdf0e8a56c565a615e1e1dafb4", "patch": "@@ -114,7 +114,7 @@\n                 return $scope.levels[lint.level];\n             };\n \n-            var GROUPS_FILTER_DEFAULT = {\n+            const GROUPS_FILTER_DEFAULT = {\n                 cargo: true,\n                 complexity: true,\n                 correctness: true,\n@@ -125,8 +125,12 @@\n                 restriction: true,\n                 style: true,\n                 suspicious: true,\n+            }\n+\n+            $scope.groups = {\n+                ...GROUPS_FILTER_DEFAULT\n             };\n-            $scope.groups = GROUPS_FILTER_DEFAULT;\n+\n             const THEMES_DEFAULT = {\n                 light: \"Light\",\n                 rust: \"Rust\",\n@@ -164,6 +168,13 @@\n                 }\n             };\n \n+            $scope.resetGroupsToDefault = function () {\n+                const groups = $scope.groups;\n+                for (const [key, value] of Object.entries(GROUPS_FILTER_DEFAULT)) {\n+                    groups[key] = value;\n+                }\n+            };\n+\n             $scope.selectedValuesCount = function (obj) {\n                 return Object.values(obj).filter(x => x).length;\n             }"}]}