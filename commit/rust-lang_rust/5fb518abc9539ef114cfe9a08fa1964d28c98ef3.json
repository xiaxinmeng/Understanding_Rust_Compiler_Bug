{"sha": "5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmYjUxOGFiYzk1MzllZjExNGNmZTlhMDhmYTE5NjRkMjhjOThlZjM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T10:17:51Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-15T12:10:07Z"}, "message": "Fix assignments to immutable fields throughout the code", "tree": {"sha": "f950c000c80a49f3957961ceea0a5fd094c2b6b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f950c000c80a49f3957961ceea0a5fd094c2b6b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "html_url": "https://github.com/rust-lang/rust/commit/5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "180db08470390ed2c350d01ae09be1e47f6135be", "url": "https://api.github.com/repos/rust-lang/rust/commits/180db08470390ed2c350d01ae09be1e47f6135be", "html_url": "https://github.com/rust-lang/rust/commit/180db08470390ed2c350d01ae09be1e47f6135be"}], "stats": {"total": 109, "additions": 55, "deletions": 54}, "files": [{"sha": "ed385dcad753a3c2810bf235854d74d493b7de85", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -672,21 +672,21 @@ fn hash_path(&str s) -> uint {\n \n fn create_index[T](&vec[tup(T, uint)] index, fn(&T) -> uint hash_fn)\n         -> vec[vec[tup(T, uint)]] {\n-    let vec[vec[tup(T, uint)]] buckets = [];\n+    let vec[mutable vec[tup(T, uint)]] buckets = vec::empty_mut();\n     for each (uint i in uint::range(0u, 256u)) {\n-        let vec[tup(T, uint)] bucket = [];\n-        buckets += [bucket];\n+        buckets += [mutable []];\n     }\n \n     for (tup(T, uint) elt in index) {\n         auto h = hash_fn(elt._0);\n         buckets.(h % 256u) += [elt];\n     }\n \n-    ret buckets;\n+    ret vec::freeze(buckets);\n }\n \n-fn encode_index[T](&ebml::writer ebml_w, &vec[vec[tup(T, uint)]] buckets,\n+fn encode_index[T](&ebml::writer ebml_w,\n+                   &vec[vec[tup(T, uint)]] buckets,\n                    fn(&io::writer, &T) write_fn) {\n     auto writer = io::new_writer_(ebml_w.writer);\n "}, {"sha": "41feac5251eb7b5184a8dc7e5a7e4f8b9274ad02", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -80,7 +80,8 @@ tag mod_index_entry {\n type mod_index = hashmap[ident,list[mod_index_entry]];\n \n type indexed_mod = rec(option::t[ast::_mod] m, \n-                       mod_index index, vec[def] glob_imports,\n+                       mod_index index,\n+                       mutable vec[def] glob_imports,\n                        hashmap[str,import_state] glob_imported_names);\n /* native modules can't contain tags, and we don't store their ASTs because we\n    only need to look at them to determine exports, which they can't control.*/\n@@ -141,7 +142,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n     // Register the top-level mod \n     e.mod_map.insert(-1, @rec(m=some(c.node.module),\n                               index=index_mod(c.node.module),\n-                              glob_imports=vec::empty[def](),\n+                              mutable glob_imports=vec::empty[def](),\n                               glob_imported_names\n                               =new_str_hash[import_state]()));\n \n@@ -160,7 +161,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n             case (ast::item_mod(_, ?md, ?defid)) {\n                 e.mod_map.insert(defid._1, \n                                  @rec(m=some(md), index=index_mod(md),\n-                                      glob_imports=vec::empty[def](),\n+                                      mutable glob_imports=vec::empty[def](),\n                                       glob_imported_names\n                                       =new_str_hash[import_state]()));\n                 e.ast_map.insert(defid, i);\n@@ -169,7 +170,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n                 e.mod_map.insert(defid._1, \n                                  @rec(m=none[ast::_mod], \n                                       index=index_nmod(nmd),\n-                                      glob_imports=vec::empty[def](),\n+                                      mutable glob_imports=vec::empty[def](),\n                                       glob_imported_names\n                                       =new_str_hash[import_state]()));\n                 e.ast_map.insert(defid, i);\n@@ -850,7 +851,7 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp,\n \n         auto matches = vec::filter_map[def, def]\n             (bind l_i_m_r(e, _, sp, id, ns, dr), \n-             info.glob_imports);\n+             {info.glob_imports});\n         if (vec::len(matches) == 0u) {\n             ret none[def];\n         } else if (vec::len(matches) == 1u){"}, {"sha": "03e9d83c53ec33fde0fd2c553f1815fb902ce03e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -5995,12 +5995,12 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n }\n \n fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n-    be trans_expr_out(cx, e, return);\n+    ret trans_expr_out(cx, e, return);\n }\n \n fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n     -> result {\n-    *cx = rec(sp=e.span with *cx);\n+    // FIXME Fill in cx.sp\n     alt (e.node) {\n         case (ast::expr_lit(?lit, ?ann)) {\n             ret res(cx, trans_lit(cx.fcx.lcx.ccx, *lit, ann));\n@@ -6059,7 +6059,6 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n         }\n \n         case (ast::expr_block(?blk, ?ann)) {\n-            *cx = rec(sp=blk.span with *cx);\n             auto sub_cx = new_scope_block_ctxt(cx, \"block-expr body\");\n             auto next_cx = new_sub_block_ctxt(cx, \"next\");\n             auto sub = with_out_method(bind trans_block(sub_cx, blk, _),\n@@ -6072,7 +6071,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n         case (ast::expr_move(?dst, ?src, _)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n-            *(lhs_res.res.bcx) = rec(sp=src.span with *(lhs_res.res.bcx));\n+            // FIXME Fill in lhs_res.res.bcx.sp\n             auto rhs_res = trans_lval(lhs_res.res.bcx, src);\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n             // FIXME: calculate copy init-ness in typestate.\n@@ -6084,7 +6083,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n         case (ast::expr_assign(?dst, ?src, _)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n-            *(lhs_res.res.bcx) = rec(sp=src.span with *(lhs_res.res.bcx));\n+            // FIXME Fill in lhs_res.res.bcx.sp\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n             // FIXME: calculate copy init-ness in typestate.\n@@ -6097,7 +6096,7 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output)\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n-            *(lhs_res.res.bcx) = rec(sp=src.span with *(lhs_res.res.bcx));\n+            // FIXME Fill in lhs_res.res.bcx.sp\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             if (ty::type_is_sequence(cx.fcx.lcx.ccx.tcx, t)) {\n                 alt (op) {\n@@ -7182,7 +7181,7 @@ fn zero_alloca(&@block_ctxt cx, ValueRef llptr, ty::t t) -> result {\n  }\n \n fn trans_stmt(&@block_ctxt cx, &ast::stmt s) -> result {\n-    *cx = rec(sp=s.span with *cx);\n+    // FIXME Fill in cx.sp\n     auto bcx = cx;\n     alt (s.node) {\n         case (ast::stmt_expr(?e,_)) {\n@@ -7352,7 +7351,7 @@ fn alloc_local(&@block_ctxt cx, &@ast::local_ local) -> result {\n fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n     auto bcx = cx;\n     for each (@ast::local_ local in block_locals(b)) {\n-        *bcx = rec(sp=local_rhs_span(local, cx.sp) with *bcx);\n+        // FIXME Update bcx.sp\n         bcx = alloc_local(bcx, local).bcx;\n     }\n     auto r = res(bcx, C_nil());"}, {"sha": "df715da7c0fd78adf4d4df92ca1656237a33aba4", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -255,7 +255,7 @@ type constr_map = @std::map::hashmap[def_id, constraint];\n type fn_info  = rec(constr_map constrs, uint num_constraints, controlflow cf);\n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mutable vec[ts_ann];\n+type node_ann_table = @mutable vec[mutable ts_ann];\n \n /* mapping from function name to fn_info map */\n type fn_info_map = @std::map::hashmap[def_id, fn_info];\n@@ -485,7 +485,7 @@ fn num_constraints(fn_info m) -> uint {\n }\n \n fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n-    let vec[ts_ann] na = [];\n+    let vec[mutable ts_ann] na = vec::empty_mut();\n     ret rec(tcx=cx, node_anns=@mutable na, fm=@new_def_hash[fn_info]());\n }\n "}, {"sha": "0ebc3541ef992dfaaa8b3f550f0b91fb1ead42ce", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -114,17 +114,17 @@ fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     auto enclosing = fcx.enclosing;\n     auto nv   = num_constraints(enclosing);\n-    auto post = @empty_poststate(nv);\n+    auto post = @mutable empty_poststate(nv);\n \n-    fn do_one_(fn_ctxt fcx, &@stmt s, @poststate post) -> () {\n+    fn do_one_(fn_ctxt fcx, &@stmt s, @mutable poststate post) -> () {\n         check_states_stmt(fcx, *s);\n         *post = stmt_poststate(fcx.ccx, *s);\n     }\n \n     auto do_one = bind do_one_(fcx, _, post);\n  \n     vec::map[@stmt, ()](do_one, f.body.node.stmts);\n-    fn do_inner_(fn_ctxt fcx, &@expr e, @poststate post) -> () {\n+    fn do_inner_(fn_ctxt fcx, &@expr e, @mutable poststate post) -> () {\n         check_states_expr(fcx, e);\n         *post = expr_poststate(fcx.ccx, e);\n     }\n@@ -135,7 +135,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     /* Finally, check that the return value is initialized */\n     let aux::constr_ ret_c = rec(id=fcx.id, c=aux::ninit(fcx.name));\n     if (f.proto == ast::proto_fn\n-        && ! promises(fcx, *post, ret_c)\n+        && ! promises(fcx, {*post}, ret_c)\n         && ! type_is_nil(fcx.ccx.tcx,\n                          ret_ty_of_fn(fcx.ccx.tcx, a))\n         && cf == return) {\n@@ -149,7 +149,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n         // check that this really always fails\n         // the fcx.id bit means \"returns\" for a returning fn,\n         // \"diverges\" for a non-returning fn\n-        if (! promises(fcx, *post, ret_c)) {\n+        if (! promises(fcx, {*post}, ret_c)) {\n             fcx.ccx.tcx.sess.span_err(f.body.span,\n               \"In non-returning function \" + fcx.name +\n               \", some control paths may return to the caller\");"}, {"sha": "e009c1b17e1a3e4d3693025a6c12da995a149af8", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -78,7 +78,7 @@ fn tok_str(token t) -> str {\n     }\n }\n \n-fn buf_str(vec[token] toks, vec[int] szs,\n+fn buf_str(vec[mutable token] toks, vec[mutable int] szs,\n            uint left, uint right, uint lim) -> str {\n     auto n = vec::len(toks);\n     assert n == vec::len(szs);\n@@ -112,9 +112,9 @@ fn mk_printer(io::writer out, uint linewidth) -> printer {\n \n     log #fmt(\"mk_printer %u\", linewidth);\n \n-    let vec[token] token = vec::init_elt[token](EOF, n);\n-    let vec[int] size = vec::init_elt[int](0, n);\n-    let vec[uint] scan_stack = vec::init_elt[uint](0u, n);\n+    let vec[mutable token] token = vec::init_elt_mut(EOF, n);\n+    let vec[mutable int] size = vec::init_elt_mut(0, n);\n+    let vec[mutable uint] scan_stack = vec::init_elt_mut(0u, n);\n     let vec[print_stack_elt] print_stack = [];\n \n     ret printer(out,\n@@ -220,8 +220,8 @@ obj printer(io::writer out,\n \n             mutable uint left,         // index of left side of input stream\n             mutable uint right,        // index of right side of input stream\n-            mutable vec[token] token,  // ring-buffer stream goes through\n-            mutable vec[int] size,     // ring-buffer of calculated sizes\n+            mutable vec[mutable token] token,// ring-buffr stream goes through\n+            mutable vec[mutable int] size,  // ring-buffer of calculated sizes\n             mutable int left_total,    // running size of stream \"...left\"\n             mutable int right_total,   // running size of stream \"...right\"\n \n@@ -231,7 +231,7 @@ obj printer(io::writer out,\n             // on top of it. Stuff is flushed off the bottom as it becomes\n             // irrelevant due to the primary ring-buffer advancing.\n \n-            mutable vec[uint] scan_stack,\n+            mutable vec[mutable uint] scan_stack,\n             mutable bool scan_stack_empty, // top==bottom disambiguator\n             mutable uint top,              // index of top of scan_stack\n             mutable uint bottom,           // index of bottom of scan_stack"}, {"sha": "060b435215d2edc058941599f3becf0abd5df620", "filename": "src/lib/deque.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -27,26 +27,27 @@ fn create[T]() -> t[T] {\n      * Grow is only called on full elts, so nelts is also len(elts), unlike\n      * elsewhere.\n      */\n-    fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-        assert (nelts == vec::len[cell[T]](elts));\n+    fn grow[T](uint nelts, uint lo, vec[mutable cell[T]] elts)\n+        -> vec[mutable cell[T]] {\n+        assert (nelts == vec::len(elts));\n \n         // FIXME: Making the vector argument an alias is a workaround for\n         // issue #375\n         fn fill[T](uint i, uint nelts, uint lo,\n-                   &vec[cell[T]] old) -> cell[T] {\n+                   &vec[mutable cell[T]] old) -> cell[T] {\n             ret if (i < nelts) {\n                 old.((lo + i) % nelts)\n             } else {\n-                option::none[T]\n+                option::none\n             };\n         }\n \n         let uint nalloc = uint::next_power_of_two(nelts + 1u);\n         let vec::init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n-        ret vec::init_fn[cell[T]](copy_op, nalloc);\n+        ret vec::init_fn_mut[cell[T]](copy_op, nalloc);\n     }\n \n-    fn get[T](vec[cell[T]] elts, uint i) -> T {\n+    fn get[T](vec[mutable cell[T]] elts, uint i) -> T {\n         ret alt (elts.(i)) {\n             case (option::some(?t)) { t }\n             case (_) { fail }\n@@ -56,7 +57,7 @@ fn create[T]() -> t[T] {\n     obj deque[T](mutable uint nelts,\n                  mutable uint lo,\n                  mutable uint hi,\n-                 mutable vec[cell[T]] elts)\n+                 mutable vec[mutable cell[T]] elts)\n         {\n             fn size() -> uint { ret nelts; }\n \n@@ -130,8 +131,8 @@ fn create[T]() -> t[T] {\n             }\n \n         }\n-    let vec[cell[T]] v = vec::init_elt[cell[T]](option::none[T],\n-                                                initial_capacity);\n+    let vec[mutable cell[T]] v = vec::init_elt_mut(option::none,\n+                                                   initial_capacity);\n \n     ret deque[T](0u, 0u, 0u, v);\n }"}, {"sha": "4afeb6c8431e5a8e0b136cecac92104eee9328f6", "filename": "src/lib/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -385,14 +385,14 @@ fn freeze[T](vec[mutable T] v) -> vec[T] {\n }\n \n // Swaps two elements in a vector\n-fn swap[T](&vec[T] v, uint a, uint b) {\n+fn swap[T](&vec[mutable T] v, uint a, uint b) {\n     let T t = v.(a);\n     v.(a) = v.(b);\n     v.(b) = t;\n }\n \n // In place vector reversal\n-fn reverse[T](&vec[T] v) -> () {\n+fn reverse[T](&vec[mutable T] v) -> () {\n     let uint i = 0u;\n     auto ln = len[T](v);\n "}, {"sha": "a808c9fea4eab3ce69e8dd2db4a0a9b10efae3f0", "filename": "src/test/bench/shootout/fannkuchredux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffannkuchredux.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -12,9 +12,9 @@ fn fannkuch(int n) -> int {\n   }\n   auto perm1init_ = perm1init; // Rustboot workaround\n \n-  auto perm = vec::init_elt(0, n as uint);\n-  auto perm1 = vec::init_fn(perm1init_, n as uint);\n-  auto count = vec::init_elt(0, n as uint);\n+  auto perm = vec::init_elt_mut(0, n as uint);\n+  auto perm1 = vec::init_fn_mut(perm1init_, n as uint);\n+  auto count = vec::init_elt_mut(0, n as uint);\n \n   auto f = 0;\n   auto i = 0;"}, {"sha": "1aecc108bb8fda93d0f8160afa80123d341245b7", "filename": "src/test/run-pass/vec-reverse.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Ftest%2Frun-pass%2Fvec-reverse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fb518abc9539ef114cfe9a08fa1964d28c98ef3/src%2Ftest%2Frun-pass%2Fvec-reverse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-reverse.rs?ref=5fb518abc9539ef114cfe9a08fa1964d28c98ef3", "patch": "@@ -2,28 +2,28 @@ use std;\n import std::vec;\n \n fn main() {\n-  let vec[int] v = [10, 20];\n+  let vec[mutable int] v = [mutable 10, 20];\n \n   assert v.(0) == 10;\n   assert v.(1) == 20;\n \n-  vec::reverse[int](v);\n+  vec::reverse(v);\n \n   assert v.(0) == 20;\n   assert v.(1) == 10;\n \n-  auto v2 = vec::reversed[int](v);\n+  auto v2 = vec::reversed[int]([10, 20]);\n \n-  assert v2.(0) == 10;\n-  assert v2.(1) == 20;\n+  assert v2.(0) == 20;\n+  assert v2.(1) == 10;\n \n   v.(0) = 30;\n \n-  assert v2.(0) == 10;\n+  assert v2.(0) == 20;\n \n   // Make sure they work with 0-length vectors too.\n-  let vec[int] v3 = [];\n-  auto v4 = vec::reversed[int](v3);\n+  auto v4 = vec::reversed[int]([]);\n \n+  let vec[mutable int] v3 = vec::empty_mut();\n   vec::reverse[int](v3);\n }"}]}