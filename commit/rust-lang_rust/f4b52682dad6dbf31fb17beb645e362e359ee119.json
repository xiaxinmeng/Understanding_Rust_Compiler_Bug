{"sha": "f4b52682dad6dbf31fb17beb645e362e359ee119", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YjUyNjgyZGFkNmRiZjMxZmIxN2JlYjY0NWUzNjJlMzU5ZWUxMTk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:39:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-15T18:39:44Z"}, "message": "internal: unindent some tests", "tree": {"sha": "b611d5d9359f343e0ef3a97a502ccee7c8a66d95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b611d5d9359f343e0ef3a97a502ccee7c8a66d95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4b52682dad6dbf31fb17beb645e362e359ee119", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4b52682dad6dbf31fb17beb645e362e359ee119", "html_url": "https://github.com/rust-lang/rust/commit/f4b52682dad6dbf31fb17beb645e362e359ee119", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4b52682dad6dbf31fb17beb645e362e359ee119/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b737b894cb8974361881d98d7d0a6f75839ca345", "url": "https://api.github.com/repos/rust-lang/rust/commits/b737b894cb8974361881d98d7d0a6f75839ca345", "html_url": "https://github.com/rust-lang/rust/commit/b737b894cb8974361881d98d7d0a6f75839ca345"}], "stats": {"total": 507, "additions": 252, "deletions": 255}, "files": [{"sha": "2687c6a44c39336bc5638ec136d6703ed41aa572", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 252, "deletions": 255, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/f4b52682dad6dbf31fb17beb645e362e359ee119/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4b52682dad6dbf31fb17beb645e362e359ee119/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=f4b52682dad6dbf31fb17beb645e362e359ee119", "patch": "@@ -175,16 +175,17 @@ fn test() {\n fn infer_basics() {\n     check_infer(\n         r#\"\n-        fn test(a: u32, b: isize, c: !, d: &str) {\n-            a;\n-            b;\n-            c;\n-            d;\n-            1usize;\n-            1isize;\n-            \"test\";\n-            1.0f32;\n-        }\"#,\n+fn test(a: u32, b: isize, c: !, d: &str) {\n+    a;\n+    b;\n+    c;\n+    d;\n+    1usize;\n+    1isize;\n+    \"test\";\n+    1.0f32;\n+}\n+\"#,\n         expect![[r#\"\n             8..9 'a': u32\n             16..17 'b': isize\n@@ -207,15 +208,15 @@ fn infer_basics() {\n fn infer_let() {\n     check_infer(\n         r#\"\n-        fn test() {\n-            let a = 1isize;\n-            let b: usize = 1;\n-            let c = b;\n-            let d: u32;\n-            let e;\n-            let f: i32 = e;\n-        }\n-        \"#,\n+fn test() {\n+    let a = 1isize;\n+    let b: usize = 1;\n+    let c = b;\n+    let d: u32;\n+    let e;\n+    let f: i32 = e;\n+}\n+\"#,\n         expect![[r#\"\n             10..117 '{     ...= e; }': ()\n             20..21 'a': isize\n@@ -236,17 +237,17 @@ fn infer_let() {\n fn infer_paths() {\n     check_infer(\n         r#\"\n-        fn a() -> u32 { 1 }\n+fn a() -> u32 { 1 }\n \n-        mod b {\n-            fn c() -> u32 { 1 }\n-        }\n+mod b {\n+    fn c() -> u32 { 1 }\n+}\n \n-        fn test() {\n-            a();\n-            b::c();\n-        }\n-        \"#,\n+fn test() {\n+    a();\n+    b::c();\n+}\n+\"#,\n         expect![[r#\"\n             14..19 '{ 1 }': u32\n             16..17 '1': u32\n@@ -265,17 +266,17 @@ fn infer_paths() {\n fn infer_path_type() {\n     check_infer(\n         r#\"\n-        struct S;\n+struct S;\n \n-        impl S {\n-            fn foo() -> i32 { 1 }\n-        }\n+impl S {\n+    fn foo() -> i32 { 1 }\n+}\n \n-        fn test() {\n-            S::foo();\n-            <S>::foo();\n-        }\n-        \"#,\n+fn test() {\n+    S::foo();\n+    <S>::foo();\n+}\n+\"#,\n         expect![[r#\"\n             40..45 '{ 1 }': i32\n             42..43 '1': i32\n@@ -292,21 +293,21 @@ fn infer_path_type() {\n fn infer_struct() {\n     check_infer(\n         r#\"\n-        struct A {\n-            b: B,\n-            c: C,\n-        }\n-        struct B;\n-        struct C(usize);\n+struct A {\n+    b: B,\n+    c: C,\n+}\n+struct B;\n+struct C(usize);\n \n-        fn test() {\n-            let c = C(1);\n-            B;\n-            let a: A = A { b: B, c: C(1) };\n-            a.b;\n-            a.c;\n-        }\n-        \"#,\n+fn test() {\n+    let c = C(1);\n+    B;\n+    let a: A = A { b: B, c: C(1) };\n+    a.b;\n+    a.c;\n+}\n+\"#,\n         expect![[r#\"\n             71..153 '{     ...a.c; }': ()\n             81..82 'c': C\n@@ -332,14 +333,15 @@ fn infer_struct() {\n fn infer_enum() {\n     check_infer(\n         r#\"\n-        enum E {\n-            V1 { field: u32 },\n-            V2\n-        }\n-        fn test() {\n-            E::V1 { field: 1 };\n-            E::V2;\n-        }\"#,\n+enum E {\n+    V1 { field: u32 },\n+    V2\n+}\n+fn test() {\n+    E::V1 { field: 1 };\n+    E::V2;\n+}\n+\"#,\n         expect![[r#\"\n             51..89 '{     ...:V2; }': ()\n             57..75 'E::V1 ...d: 1 }': E\n@@ -353,23 +355,23 @@ fn infer_enum() {\n fn infer_union() {\n     check_infer(\n         r#\"\n-        union MyUnion {\n-            foo: u32,\n-            bar: f32,\n-        }\n+union MyUnion {\n+    foo: u32,\n+    bar: f32,\n+}\n \n-        fn test() {\n-            let u = MyUnion { foo: 0 };\n-            unsafe { baz(u); }\n-            let u = MyUnion { bar: 0.0 };\n-            unsafe { baz(u); }\n-        }\n+fn test() {\n+    let u = MyUnion { foo: 0 };\n+    unsafe { baz(u); }\n+    let u = MyUnion { bar: 0.0 };\n+    unsafe { baz(u); }\n+}\n \n-        unsafe fn baz(u: MyUnion) {\n-            let inner = u.foo;\n-            let inner = u.bar;\n-        }\n-        \"#,\n+unsafe fn baz(u: MyUnion) {\n+    let inner = u.foo;\n+    let inner = u.bar;\n+}\n+\"#,\n         expect![[r#\"\n             57..172 '{     ...); } }': ()\n             67..68 'u': MyUnion\n@@ -404,19 +406,19 @@ fn infer_union() {\n fn infer_refs() {\n     check_infer(\n         r#\"\n-        fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n-            a;\n-            *a;\n-            &a;\n-            &mut a;\n-            b;\n-            *b;\n-            &b;\n-            c;\n-            *c;\n-            d;\n-            *d;\n-        }\n+fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n+    a;\n+    *a;\n+    &a;\n+    &mut a;\n+    b;\n+    *b;\n+    &b;\n+    c;\n+    *c;\n+    d;\n+    *d;\n+}\n         \"#,\n         expect![[r#\"\n             8..9 'a': &u32\n@@ -450,11 +452,11 @@ fn infer_refs() {\n fn infer_raw_ref() {\n     check_infer(\n         r#\"\n-        fn test(a: i32) {\n-            &raw mut a;\n-            &raw const a;\n-        }\n-        \"#,\n+fn test(a: i32) {\n+    &raw mut a;\n+    &raw const a;\n+}\n+\"#,\n         expect![[r#\"\n             8..9 'a': i32\n             16..53 '{     ...t a; }': ()\n@@ -524,26 +526,26 @@ h\";\n fn infer_unary_op() {\n     check_infer(\n         r#\"\n-        enum SomeType {}\n-\n-        fn test(x: SomeType) {\n-            let b = false;\n-            let c = !b;\n-            let a = 100;\n-            let d: i128 = -a;\n-            let e = -100;\n-            let f = !!!true;\n-            let g = !42;\n-            let h = !10u32;\n-            let j = !a;\n-            -3.14;\n-            !3;\n-            -x;\n-            !x;\n-            -\"hello\";\n-            !\"hello\";\n-        }\n-        \"#,\n+enum SomeType {}\n+\n+fn test(x: SomeType) {\n+    let b = false;\n+    let c = !b;\n+    let a = 100;\n+    let d: i128 = -a;\n+    let e = -100;\n+    let f = !!!true;\n+    let g = !42;\n+    let h = !10u32;\n+    let j = !a;\n+    -3.14;\n+    !3;\n+    -x;\n+    !x;\n+    -\"hello\";\n+    !\"hello\";\n+}\n+\"#,\n         expect![[r#\"\n             26..27 'x': SomeType\n             39..271 '{     ...lo\"; }': ()\n@@ -594,19 +596,19 @@ fn infer_unary_op() {\n fn infer_backwards() {\n     check_infer(\n         r#\"\n-        fn takes_u32(x: u32) {}\n+fn takes_u32(x: u32) {}\n \n-        struct S { i32_field: i32 }\n+struct S { i32_field: i32 }\n \n-        fn test() -> &mut &f64 {\n-            let a = unknown_function();\n-            takes_u32(a);\n-            let b = unknown_function();\n-            S { i32_field: b };\n-            let c = unknown_function();\n-            &mut &c\n-        }\n-        \"#,\n+fn test() -> &mut &f64 {\n+    let a = unknown_function();\n+    takes_u32(a);\n+    let b = unknown_function();\n+    S { i32_field: b };\n+    let c = unknown_function();\n+    &mut &c\n+}\n+\"#,\n         expect![[r#\"\n             13..14 'x': u32\n             21..23 '{}': ()\n@@ -636,23 +638,23 @@ fn infer_backwards() {\n fn infer_self() {\n     check_infer(\n         r#\"\n-        struct S;\n+struct S;\n \n-        impl S {\n-            fn test(&self) {\n-                self;\n-            }\n-            fn test2(self: &Self) {\n-                self;\n-            }\n-            fn test3() -> Self {\n-                S {}\n-            }\n-            fn test4() -> Self {\n-                Self {}\n-            }\n-        }\n-        \"#,\n+impl S {\n+    fn test(&self) {\n+        self;\n+    }\n+    fn test2(self: &Self) {\n+        self;\n+    }\n+    fn test3() -> Self {\n+        S {}\n+    }\n+    fn test4() -> Self {\n+        Self {}\n+    }\n+}\n+\"#,\n         expect![[r#\"\n             33..37 'self': &S\n             39..60 '{     ...     }': ()\n@@ -672,30 +674,30 @@ fn infer_self() {\n fn infer_self_as_path() {\n     check_infer(\n         r#\"\n-        struct S1;\n-        struct S2(isize);\n-        enum E {\n-            V1,\n-            V2(u32),\n-        }\n+struct S1;\n+struct S2(isize);\n+enum E {\n+    V1,\n+    V2(u32),\n+}\n \n-        impl S1 {\n-            fn test() {\n-                Self;\n-            }\n-        }\n-        impl S2 {\n-            fn test() {\n-                Self(1);\n-            }\n-        }\n-        impl E {\n-            fn test() {\n-                Self::V1;\n-                Self::V2(1);\n-            }\n-        }\n-        \"#,\n+impl S1 {\n+    fn test() {\n+        Self;\n+    }\n+}\n+impl S2 {\n+    fn test() {\n+        Self(1);\n+    }\n+}\n+impl E {\n+    fn test() {\n+        Self::V1;\n+        Self::V2(1);\n+    }\n+}\n+\"#,\n         expect![[r#\"\n             86..107 '{     ...     }': ()\n             96..100 'Self': S1\n@@ -716,26 +718,26 @@ fn infer_self_as_path() {\n fn infer_binary_op() {\n     check_infer(\n         r#\"\n-        fn f(x: bool) -> i32 {\n-            0i32\n-        }\n+fn f(x: bool) -> i32 {\n+    0i32\n+}\n \n-        fn test() -> bool {\n-            let x = a && b;\n-            let y = true || false;\n-            let z = x == y;\n-            let t = x != y;\n-            let minus_forty: isize = -40isize;\n-            let h = minus_forty <= CONST_2;\n-            let c = f(z || y) + 5;\n-            let d = b;\n-            let g = minus_forty ^= i;\n-            let ten: usize = 10;\n-            let ten_is_eleven = ten == some_num;\n-\n-            ten < 3\n-        }\n-        \"#,\n+fn test() -> bool {\n+    let x = a && b;\n+    let y = true || false;\n+    let z = x == y;\n+    let t = x != y;\n+    let minus_forty: isize = -40isize;\n+    let h = minus_forty <= CONST_2;\n+    let c = f(z || y) + 5;\n+    let d = b;\n+    let g = minus_forty ^= i;\n+    let ten: usize = 10;\n+    let ten_is_eleven = ten == some_num;\n+\n+    ten < 3\n+}\n+\"#,\n         expect![[r#\"\n             5..6 'x': bool\n             21..33 '{     0i32 }': i32\n@@ -795,11 +797,11 @@ fn infer_binary_op() {\n fn infer_shift_op() {\n     check_infer(\n         r#\"\n-        fn test() {\n-            1u32 << 5u8;\n-            1u32 >> 5u8;\n-        }\n-        \"#,\n+fn test() {\n+    1u32 << 5u8;\n+    1u32 >> 5u8;\n+}\n+\"#,\n         expect![[r#\"\n             10..47 '{     ...5u8; }': ()\n             16..20 '1u32': u32\n@@ -816,29 +818,29 @@ fn infer_shift_op() {\n fn infer_field_autoderef() {\n     check_infer(\n         r#\"\n-        struct A {\n-            b: B,\n-        }\n-        struct B;\n-\n-        fn test1(a: A) {\n-            let a1 = a;\n-            a1.b;\n-            let a2 = &a;\n-            a2.b;\n-            let a3 = &mut a;\n-            a3.b;\n-            let a4 = &&&&&&&a;\n-            a4.b;\n-            let a5 = &mut &&mut &&mut a;\n-            a5.b;\n-        }\n+struct A {\n+    b: B,\n+}\n+struct B;\n \n-        fn test2(a1: *const A, a2: *mut A) {\n-            a1.b;\n-            a2.b;\n-        }\n-        \"#,\n+fn test1(a: A) {\n+    let a1 = a;\n+    a1.b;\n+    let a2 = &a;\n+    a2.b;\n+    let a3 = &mut a;\n+    a3.b;\n+    let a4 = &&&&&&&a;\n+    a4.b;\n+    let a5 = &mut &&mut &&mut a;\n+    a5.b;\n+}\n+\n+fn test2(a1: *const A, a2: *mut A) {\n+    a1.b;\n+    a2.b;\n+}\n+\"#,\n         expect![[r#\"\n             43..44 'a': A\n             49..212 '{     ...5.b; }': ()\n@@ -891,58 +893,53 @@ fn infer_field_autoderef() {\n fn infer_argument_autoderef() {\n     check_infer(\n         r#\"\n-        #[lang = \"deref\"]\n-        pub trait Deref {\n-            type Target;\n-            fn deref(&self) -> &Self::Target;\n-        }\n-\n-        struct A<T>(T);\n+//- minicore: deref\n+use core::ops::Deref;\n+struct A<T>(T);\n \n-        impl<T> A<T> {\n-            fn foo(&self) -> &T {\n-                &self.0\n-            }\n-        }\n+impl<T> A<T> {\n+    fn foo(&self) -> &T {\n+        &self.0\n+    }\n+}\n \n-        struct B<T>(T);\n+struct B<T>(T);\n \n-        impl<T> Deref for B<T> {\n-            type Target = T;\n-            fn deref(&self) -> &Self::Target {\n-                &self.0\n-            }\n-        }\n+impl<T> Deref for B<T> {\n+    type Target = T;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n \n-        fn test() {\n-            let t = A::foo(&&B(B(A(42))));\n-        }\n-        \"#,\n+fn test() {\n+    let t = A::foo(&&B(B(A(42))));\n+}\n+\"#,\n         expect![[r#\"\n-            67..71 'self': &Self\n-            138..142 'self': &A<T>\n-            150..173 '{     ...     }': &T\n-            160..167 '&self.0': &T\n-            161..165 'self': &A<T>\n-            161..167 'self.0': T\n-            254..258 'self': &B<T>\n-            277..300 '{     ...     }': &T\n-            287..294 '&self.0': &T\n-            288..292 'self': &B<T>\n-            288..294 'self.0': T\n-            314..352 '{     ...))); }': ()\n-            324..325 't': &i32\n-            328..334 'A::foo': fn foo<i32>(&A<i32>) -> &i32\n-            328..349 'A::foo...42))))': &i32\n-            335..348 '&&B(B(A(42)))': &&B<B<A<i32>>>\n-            336..348 '&B(B(A(42)))': &B<B<A<i32>>>\n-            337..338 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n-            337..348 'B(B(A(42)))': B<B<A<i32>>>\n-            339..340 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n-            339..347 'B(A(42))': B<A<i32>>\n-            341..342 'A': A<i32>(i32) -> A<i32>\n-            341..346 'A(42)': A<i32>\n-            343..345 '42': i32\n+            66..70 'self': &A<T>\n+            78..101 '{     ...     }': &T\n+            88..95 '&self.0': &T\n+            89..93 'self': &A<T>\n+            89..95 'self.0': T\n+            182..186 'self': &B<T>\n+            205..228 '{     ...     }': &T\n+            215..222 '&self.0': &T\n+            216..220 'self': &B<T>\n+            216..222 'self.0': T\n+            242..280 '{     ...))); }': ()\n+            252..253 't': &i32\n+            256..262 'A::foo': fn foo<i32>(&A<i32>) -> &i32\n+            256..277 'A::foo...42))))': &i32\n+            263..276 '&&B(B(A(42)))': &&B<B<A<i32>>>\n+            264..276 '&B(B(A(42)))': &B<B<A<i32>>>\n+            265..266 'B': B<B<A<i32>>>(B<A<i32>>) -> B<B<A<i32>>>\n+            265..276 'B(B(A(42)))': B<B<A<i32>>>\n+            267..268 'B': B<A<i32>>(A<i32>) -> B<A<i32>>\n+            267..275 'B(A(42))': B<A<i32>>\n+            269..270 'A': A<i32>(i32) -> A<i32>\n+            269..274 'A(42)': A<i32>\n+            271..273 '42': i32\n         \"#]],\n     );\n }"}]}