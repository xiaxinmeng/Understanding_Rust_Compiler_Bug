{"sha": "06b034ae8b418beab7d0767a9a8d29023558d701", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YjAzNGFlOGI0MThiZWFiN2QwNzY3YTlhOGQyOTAyMzU1OGQ3MDE=", "commit": {"author": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-05-16T17:02:42Z"}, "committer": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-07-13T18:54:47Z"}, "message": "format: remove all implicit ref handling outside of libfmt_macros\n\nformat: beautifully get rid of ArgumentNext and CountIsNextParam\n\nNow that CountIsNextParam and ArgumentNext are resolved during parse,\nthe need for handling them outside of libfmt_macros is obviated.\n\nNote: *one* instance of implicit reference handling still remains, and\nthat's for implementing `all_args_simple`. It's trivial enough though,\nso in this case it may be tolerable.", "tree": {"sha": "deeae34e65e8aef561d7d04b9873c134ca9b24bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deeae34e65e8aef561d7d04b9873c134ca9b24bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06b034ae8b418beab7d0767a9a8d29023558d701", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXho6lAAoJEHg5bO9pIxDssPcP/2uV9nnVKDBuhpfuTrcrQEkv\n7I8vVBWc/5Z47nBf3Qn1dqUTSQbpyhXmGVy+jwIP+7WE3ezSj+YEitnKw1V5GWI4\nWtDM3+J3G97h1ZTXBU1y2gcHnNwdbE/mu7z5W0KUDBXorM4x8ZUkbKmPHrh2NNR8\npTbxhXdLFhUUBIWRIWlxbf8yC6SxjcGpwfGaCyjAKS0pmJZ7h0UQraCiyGXgY0ud\nIpx6qbq94ZTUMaaazfaCMNPcMfFqVXtMaaN3wops47IqZQsx9xX3dqN6DHsxoRFM\nDjcXhw3jG94kwOt+BjDjuWm6yt8cmb6JDixYkJi0ABggA7MkYq+r1jEjRwqBs2z3\nf81j2/y2XMq2yHoiTwWw6UHUMUT1XQ9WaAUBcj4JwbkBvDQ9SYiUUdFsHX/zE2an\n4ws3i90DTmeY1Qg3BgqIdOi2edIQxPzbW9Gb2iqnY6/MoZIshu+NkZsDEC6l0Tww\nW38/dJlHHJfigkDdjERiJpZQfD9/9qkYEbojTExGmxOOGBIpTIrfq9mcMVQMzwpx\npysTUJyd9C466m9PIzt4eDFbs5HMkzFuvHEsKfUZgabmpEcvIjltkNSyTcXmx03b\nyuHD6b9ekQBR9QoFrLh30Zi0NNfDBDjY34mYhDGT0LPjlKASYNk1cHmGiEmJpALJ\nTlOoHowlRbNT/E34KHJy\n=Xdf+\n-----END PGP SIGNATURE-----", "payload": "tree deeae34e65e8aef561d7d04b9873c134ca9b24bd\nparent 71949f3b0dfdacbddc0c012accefbb8e8ec759d4\nauthor Wang Xuerui <idontknw.wang@gmail.com> 1463418162 +0800\ncommitter Wang Xuerui <idontknw.wang@gmail.com> 1468436087 +0800\n\nformat: remove all implicit ref handling outside of libfmt_macros\n\nformat: beautifully get rid of ArgumentNext and CountIsNextParam\n\nNow that CountIsNextParam and ArgumentNext are resolved during parse,\nthe need for handling them outside of libfmt_macros is obviated.\n\nNote: *one* instance of implicit reference handling still remains, and\nthat's for implementing `all_args_simple`. It's trivial enough though,\nso in this case it may be tolerable.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06b034ae8b418beab7d0767a9a8d29023558d701", "html_url": "https://github.com/rust-lang/rust/commit/06b034ae8b418beab7d0767a9a8d29023558d701", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06b034ae8b418beab7d0767a9a8d29023558d701/comments", "author": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71949f3b0dfdacbddc0c012accefbb8e8ec759d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/71949f3b0dfdacbddc0c012accefbb8e8ec759d4", "html_url": "https://github.com/rust-lang/rust/commit/71949f3b0dfdacbddc0c012accefbb8e8ec759d4"}], "stats": {"total": 90, "additions": 36, "deletions": 54}, "files": [{"sha": "e7d401f0929fe1910ec87bc256cbe1d3715d49e1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 23, "deletions": 36, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/06b034ae8b418beab7d0767a9a8d29023558d701/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b034ae8b418beab7d0767a9a8d29023558d701/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=06b034ae8b418beab7d0767a9a8d29023558d701", "patch": "@@ -80,8 +80,6 @@ pub struct FormatSpec<'a> {\n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n pub enum Position<'a> {\n-    /// The argument will be in the next position. This is the default.\n-    ArgumentNext,\n     /// The argument is located at a specific index.\n     ArgumentIs(usize),\n     /// The argument has a name.\n@@ -127,8 +125,6 @@ pub enum Count<'a> {\n     CountIsName(&'a str),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n-    /// The count is specified by the next parameter.\n-    CountIsNextParam,\n     /// The count is implied and cannot be explicitly specified.\n     CountImplied,\n }\n@@ -262,37 +258,18 @@ impl<'a> Parser<'a> {\n     /// Parses an Argument structure, or what's contained within braces inside\n     /// the format string\n     fn argument(&mut self) -> Argument<'a> {\n-        let mut pos = self.position();\n-        let mut format = self.format();\n-\n-        // Resolve CountIsNextParam's into absolute references.\n-        // Current argument's position must be known so this is done after\n-        // format parsing.\n-        // Curiously, currently {:.*} for named arguments is implemented,\n-        // and it consumes a positional arg slot just like a positional {:.*}\n-        // does. The current behavior is reproduced to prevent any\n-        // incompatibilities.\n-        match format.precision {\n-            CountIsNextParam => {\n-                // eat the current implicit arg\n-                let i = self.curarg;\n-                self.curarg += 1;\n-                format.precision = CountIsParam(i);\n-            }\n-            _ => {}\n-        }\n+        let pos = self.position();\n+        let format = self.format();\n \n-        // Resolve ArgumentNext's into absolute references.\n-        // This must come after count resolution because we may consume one\n-        // more arg if precision is CountIsNextParam.\n-        match pos {\n-            ArgumentNext => {\n+        // Resolve position after parsing format spec.\n+        let pos = match pos {\n+            Some(position) => position,\n+            None => {\n                 let i = self.curarg;\n                 self.curarg += 1;\n-                pos = ArgumentIs(i);\n+                ArgumentIs(i)\n             }\n-            _ => {}\n-        }\n+        };\n \n         Argument {\n             position: pos,\n@@ -302,13 +279,19 @@ impl<'a> Parser<'a> {\n \n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n-    fn position(&mut self) -> Position<'a> {\n+    /// Returns `Some(parsed_position)` if the position is not implicitly\n+    /// consuming a macro argument, `None` if it's the case.\n+    fn position(&mut self) -> Option<Position<'a>> {\n         if let Some(i) = self.integer() {\n-            ArgumentIs(i)\n+            Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => ArgumentNamed(self.word()),\n-                _ => ArgumentNext,\n+                Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+\n+                // This is an `ArgumentNext`.\n+                // Record the fact and do the resolution after parsing the\n+                // format spec, to make things like `{:.*}` work.\n+                _ => None,\n             }\n         }\n     }\n@@ -375,7 +358,11 @@ impl<'a> Parser<'a> {\n         }\n         if self.consume('.') {\n             if self.consume('*') {\n-                spec.precision = CountIsNextParam;\n+                // Resolve `CountIsNextParam`.\n+                // We can do this immediately as `position` is resolved later.\n+                let i = self.curarg;\n+                self.curarg += 1;\n+                spec.precision = CountIsParam(i);\n             } else {\n                 spec.precision = self.count();\n             }"}, {"sha": "fc1d2236f3feaa07c63c5e99e424500bc5704b53", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06b034ae8b418beab7d0767a9a8d29023558d701/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b034ae8b418beab7d0767a9a8d29023558d701/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=06b034ae8b418beab7d0767a9a8d29023558d701", "patch": "@@ -881,7 +881,7 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n-                        Position::ArgumentIs(_) | Position::ArgumentNext => {\n+                        Position::ArgumentIs(_) => {\n                             span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");"}, {"sha": "c0150e5ce1d95c1eee0ae579c2abdb8548f84db1", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06b034ae8b418beab7d0767a9a8d29023558d701/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06b034ae8b418beab7d0767a9a8d29023558d701/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=06b034ae8b418beab7d0767a9a8d29023558d701", "patch": "@@ -68,8 +68,10 @@ struct Context<'a, 'b:'a> {\n \n     name_positions: HashMap<String, usize>,\n \n-    /// Updated as arguments are consumed\n-    next_arg: usize,\n+    /// Current position of the implicit positional arg pointer, as if it\n+    /// still existed in this phase of processing.\n+    /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n+    curarg: usize,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -159,11 +161,6 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // argument second, if it's an implicit positional parameter\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n-                    parse::ArgumentNext => {\n-                        let i = self.next_arg;\n-                        self.next_arg += 1;\n-                        Exact(i)\n-                    }\n                     parse::ArgumentIs(i) => Exact(i),\n                     parse::ArgumentNamed(s) => Named(s.to_string()),\n                 };\n@@ -183,11 +180,6 @@ impl<'a, 'b> Context<'a, 'b> {\n             parse::CountIsName(s) => {\n                 self.verify_arg_type(Named(s.to_string()), Unsigned);\n             }\n-            parse::CountIsNextParam => {\n-                let next_arg = self.next_arg;\n-                self.verify_arg_type(Exact(next_arg), Unsigned);\n-                self.next_arg += 1;\n-            }\n         }\n     }\n \n@@ -309,7 +301,6 @@ impl<'a, 'b> Context<'a, 'b> {\n                 count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n             parse::CountImplied => count(\"Implied\", None),\n-            parse::CountIsNextParam => count(\"NextParam\", None),\n             parse::CountIsName(n) => {\n                 let i = match self.name_positions.get(n) {\n                     Some(&i) => i,\n@@ -355,8 +346,6 @@ impl<'a, 'b> Context<'a, 'b> {\n                         }\n                     };\n                     match arg.position {\n-                        // These two have a direct mapping\n-                        parse::ArgumentNext => pos(\"Next\", None),\n                         parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n \n                         // Named arguments are converted to positional arguments\n@@ -373,7 +362,13 @@ impl<'a, 'b> Context<'a, 'b> {\n                 };\n \n                 let simple_arg = parse::Argument {\n-                    position: parse::ArgumentNext,\n+                    position: {\n+                        // We don't have ArgumentNext any more, so we have to\n+                        // track the current argument ourselves.\n+                        let i = self.curarg;\n+                        self.curarg += 1;\n+                        parse::ArgumentIs(i)\n+                    },\n                     format: parse::FormatSpec {\n                         fill: arg.format.fill,\n                         align: parse::AlignUnknown,\n@@ -640,7 +635,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_positions: HashMap::new(),\n         name_types: HashMap::new(),\n         name_ordering: name_ordering,\n-        next_arg: 0,\n+        curarg: 0,\n         literal: String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),"}]}