{"sha": "a2318651d4d2c6280a5047544cbf4180119ba966", "node_id": "C_kwDOAAsO6NoAKGEyMzE4NjUxZDRkMmM2MjgwYTUwNDc1NDRjYmY0MTgwMTE5YmE5NjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-30T23:47:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-30T23:47:51Z"}, "message": "Auto merge of #99959 - cuviper:niche-size, r=eddyb\n\nFix the size of niche enums with ZST alignment\n\nFor enums with an aligned ZST variant, like `[T; 0]`, the niche layout\nwas not computing a sufficient size to be consistent with alignment. Now\nwe pad that size up to the alignment, and also make sure to only use the\nniche variant's ABI when the size and alignment still match.\n\nFixes #99836\nr? `@eddyb`", "tree": {"sha": "43144d29701ef870ba8d3b0b5abe197aa73e463c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43144d29701ef870ba8d3b0b5abe197aa73e463c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2318651d4d2c6280a5047544cbf4180119ba966", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2318651d4d2c6280a5047544cbf4180119ba966", "html_url": "https://github.com/rust-lang/rust/commit/a2318651d4d2c6280a5047544cbf4180119ba966", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2318651d4d2c6280a5047544cbf4180119ba966/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f4bcadb46006bc484dad85616b484f93879ca4e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4bcadb46006bc484dad85616b484f93879ca4e", "html_url": "https://github.com/rust-lang/rust/commit/0f4bcadb46006bc484dad85616b484f93879ca4e"}, {"sha": "1e7e74557285c6307c5cf78c88b0a3356d8b7498", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e7e74557285c6307c5cf78c88b0a3356d8b7498", "html_url": "https://github.com/rust-lang/rust/commit/1e7e74557285c6307c5cf78c88b0a3356d8b7498"}], "stats": {"total": 479, "additions": 477, "deletions": 2}, "files": [{"sha": "833edd228050052fb2e480bec2cbc124631070df", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2318651d4d2c6280a5047544cbf4180119ba966/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2318651d4d2c6280a5047544cbf4180119ba966/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=a2318651d4d2c6280a5047544cbf4180119ba966", "patch": "@@ -1231,11 +1231,15 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                 .collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                             let offset = st[i].fields().offset(field_index) + niche.offset;\n-                            let size = st[i].size();\n+\n+                            // Align the total size to the largest alignment.\n+                            let size = st[i].size().align_to(align.abi);\n \n                             let abi = if st.iter().all(|v| v.abi().is_uninhabited()) {\n                                 Abi::Uninhabited\n-                            } else {\n+                            } else if align == st[i].align() && size == st[i].size() {\n+                                // When the total alignment and size match, we can use the\n+                                // same ABI as the scalar variant with the reserved niche.\n                                 match st[i].abi() {\n                                     Abi::Scalar(_) => Abi::Scalar(niche_scalar),\n                                     Abi::ScalarPair(first, second) => {\n@@ -1249,6 +1253,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                                     }\n                                     _ => Abi::Aggregate { sized: true },\n                                 }\n+                            } else {\n+                                Abi::Aggregate { sized: true }\n                             };\n \n                             let largest_niche = Niche::from_scalar(dl, offset, niche_scalar);"}, {"sha": "23bbbfbfc58814a4a1c298e3193931c287825528", "filename": "src/test/ui/layout/zero-sized-array-enum-niche.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a2318651d4d2c6280a5047544cbf4180119ba966/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2318651d4d2c6280a5047544cbf4180119ba966/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.rs?ref=a2318651d4d2c6280a5047544cbf4180119ba966", "patch": "@@ -0,0 +1,45 @@\n+// normalize-stderr-test \"pref: Align\\([1-8] bytes\\)\" -> \"pref: $$PREF_ALIGN\"\n+#![feature(rustc_attrs)]\n+#![crate_type = \"lib\"]\n+\n+// Various tests around the behavior of zero-sized arrays and\n+// enum niches, especially that they have coherent size and alignment.\n+\n+// The original problem in #99836 came from ndarray's `TryFrom` for\n+// `SliceInfo<[SliceInfoElem; 0], Din, Dout>`, where that returns\n+// `Result<Self, ShapeError>` ~= `Result<AlignedZST, TypeWithNiche>`.\n+// This is a close enough approximation:\n+#[rustc_layout(debug)]\n+type AlignedResult = Result<[u32; 0], bool>; //~ ERROR: layout_of\n+// The bug gave that size 1 with align 4, but the size should also be 4.\n+// It was also using the bool niche for the enum tag, which is fine, but\n+// after the fix, layout decides to use a direct tagged repr instead.\n+\n+// Here's another case with multiple ZST alignments, where we should\n+// get the maximal alignment and matching size.\n+#[rustc_layout(debug)]\n+enum MultipleAlignments { //~ ERROR: layout_of\n+    Align2([u16; 0]),\n+    Align4([u32; 0]),\n+    Niche(bool),\n+}\n+\n+// Tagged repr is clever enough to grow tags to fill any padding, e.g.:\n+// 1.   `T_FF` (one byte of Tag, one byte of padding, two bytes of align=2 Field)\n+//   -> `TTFF` (Tag has expanded to two bytes, i.e. like `#[repr(u16)]`)\n+// 2.    `TFF` (one byte of Tag, two bytes of align=1 Field)\n+//   -> Tag has no room to expand!\n+//   (this outcome can be forced onto 1. by wrapping Field in `Packed<...>`)\n+#[repr(packed)]\n+struct Packed<T>(T);\n+\n+#[rustc_layout(debug)]\n+type NicheLosesToTagged = Result<[u32; 0], Packed<std::num::NonZeroU16>>; //~ ERROR: layout_of\n+// Should get tag_encoding: Direct, size == align == 4.\n+\n+#[repr(u16)]\n+enum U16IsZero { _Zero = 0 }\n+\n+#[rustc_layout(debug)]\n+type NicheWinsOverTagged = Result<[u32; 0], Packed<U16IsZero>>; //~ ERROR: layout_of\n+// Should get tag_encoding: Niche, size == align == 4."}, {"sha": "0dbecbe412b8d5e34fee47b1682cb341ff833a8f", "filename": "src/test/ui/layout/zero-sized-array-enum-niche.stderr", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/rust-lang/rust/blob/a2318651d4d2c6280a5047544cbf4180119ba966/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a2318651d4d2c6280a5047544cbf4180119ba966/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr?ref=a2318651d4d2c6280a5047544cbf4180119ba966", "patch": "@@ -0,0 +1,424 @@\n+error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(4 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(4 bytes),\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size(1 bytes),\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(2 bytes),\n+                   },\n+               ],\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size(4 bytes),\n+       }\n+  --> $DIR/zero-sized-array-enum-niche.rs:13:1\n+   |\n+LL | type AlignedResult = Result<[u32; 0], bool>;\n+   | ^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(MultipleAlignments) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=2,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(2 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(2 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(2 bytes),\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(4 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(4 bytes),\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 2,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size(1 bytes),\n+                               value: Int(\n+                                   I8,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=1,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(2 bytes),\n+                   },\n+               ],\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=2,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size(4 bytes),\n+       }\n+  --> $DIR/zero-sized-array-enum-niche.rs:21:1\n+   |\n+LL | enum MultipleAlignments {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Direct,\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(4 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(4 bytes),\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size(1 bytes),\n+                               value: Int(\n+                                   I16,\n+                                   false,\n+                               ),\n+                               valid_range: 1..=65535,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(3 bytes),\n+                   },\n+               ],\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size(4 bytes),\n+       }\n+  --> $DIR/zero-sized-array-enum-niche.rs:37:1\n+   |\n+LL | type NicheLosesToTagged = Result<[u32; 0], Packed<std::num::NonZeroU16>>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n+           variants: Multiple {\n+               tag: Initialized {\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               tag_encoding: Niche {\n+                   dataful_variant: 1,\n+                   niche_variants: 0..=0,\n+                   niche_start: 1,\n+               },\n+               tag_field: 0,\n+               variants: [\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(0 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: None,\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(0 bytes),\n+                   },\n+                   Layout {\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(0 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n+                       variants: Single {\n+                           index: 1,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n+                       largest_niche: Some(\n+                           Niche {\n+                               offset: Size(0 bytes),\n+                               value: Int(\n+                                   I16,\n+                                   false,\n+                               ),\n+                               valid_range: 0..=0,\n+                           },\n+                       ),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       size: Size(2 bytes),\n+                   },\n+               ],\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           size: Size(4 bytes),\n+       }\n+  --> $DIR/zero-sized-array-enum-niche.rs:44:1\n+   |\n+LL | type NicheWinsOverTagged = Result<[u32; 0], Packed<U16IsZero>>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}]}