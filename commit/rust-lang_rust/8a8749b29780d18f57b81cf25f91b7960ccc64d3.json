{"sha": "8a8749b29780d18f57b81cf25f91b7960ccc64d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhODc0OWIyOTc4MGQxOGY1N2I4MWNmMjVmOTFiNzk2MGNjYzY0ZDM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-10-29T18:01:31Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-12-03T13:55:20Z"}, "message": "rustc_codegen_llvm: rewrite debuginfo::get_function_signature to use FnAbi.", "tree": {"sha": "cf1377ddc35ca4bf02549883d8a55b780c5600e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf1377ddc35ca4bf02549883d8a55b780c5600e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a8749b29780d18f57b81cf25f91b7960ccc64d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8749b29780d18f57b81cf25f91b7960ccc64d3", "html_url": "https://github.com/rust-lang/rust/commit/8a8749b29780d18f57b81cf25f91b7960ccc64d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a8749b29780d18f57b81cf25f91b7960ccc64d3/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "902433b5bf4f42714ed8d5b6bbf0d574d83a4f0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/902433b5bf4f42714ed8d5b6bbf0d574d83a4f0f", "html_url": "https://github.com/rust-lang/rust/commit/902433b5bf4f42714ed8d5b6bbf0d574d83a4f0f"}], "stats": {"total": 45, "additions": 12, "deletions": 33}, "files": [{"sha": "c2359a2fe6d94c184cee24d26d69f0193d5d3f1c", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8a8749b29780d18f57b81cf25f91b7960ccc64d3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a8749b29780d18f57b81cf25f91b7960ccc64d3/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=8a8749b29780d18f57b81cf25f91b7960ccc64d3", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::ty::subst::{SubstsRef, GenericArgKind};\n \n-use crate::abi::{Abi, FnAbi};\n+use crate::abi::FnAbi;\n use crate::common::CodegenCx;\n use crate::builder::Builder;\n use crate::value::Value;\n@@ -308,13 +308,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         let file_metadata = file_metadata(self, &loc.file.name, def_id.krate);\n \n         let function_type_metadata = unsafe {\n-            // FIXME(eddyb) avoid this `Instance::fn_sig` call, by\n-            // rewriting `get_function_signature` to use `fn_abi` instead.\n-            let sig = self.tcx().normalize_erasing_late_bound_regions(\n-                ty::ParamEnv::reveal_all(),\n-                &instance.fn_sig(self.tcx()),\n-            );\n-            let fn_signature = get_function_signature(self, sig);\n+            let fn_signature = get_function_signature(self, fn_abi);\n             llvm::LLVMRustDIBuilderCreateSubroutineType(DIB(self), file_metadata, fn_signature)\n         };\n \n@@ -396,28 +390,22 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n         return Some(fn_debug_context);\n \n-        // FIXME(eddyb) rewrite this to be based on `FnAbi` instead of `FnSig`.\n         fn get_function_signature<'ll, 'tcx>(\n             cx: &CodegenCx<'ll, 'tcx>,\n-            sig: ty::FnSig<'tcx>,\n+            fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n         ) -> &'ll DIArray {\n             if cx.sess().opts.debuginfo == DebugInfo::Limited {\n                 return create_DIArray(DIB(cx), &[]);\n             }\n \n-            let mut signature = Vec::with_capacity(sig.inputs().len() + 1);\n+            let mut signature = Vec::with_capacity(fn_abi.args.len() + 1);\n \n             // Return type -- llvm::DIBuilder wants this at index 0\n-            signature.push(match sig.output().kind {\n-                ty::Tuple(ref tys) if tys.is_empty() => None,\n-                _ => Some(type_metadata(cx, sig.output(), syntax_pos::DUMMY_SP))\n-            });\n-\n-            let inputs = if sig.abi == Abi::RustCall {\n-                &sig.inputs()[..sig.inputs().len() - 1]\n+            signature.push(if fn_abi.ret.is_ignore() {\n+                None\n             } else {\n-                sig.inputs()\n-            };\n+                Some(type_metadata(cx, fn_abi.ret.layout.ty, syntax_pos::DUMMY_SP))\n+            });\n \n             // Arguments types\n             if cx.sess().target.target.options.is_like_msvc {\n@@ -431,7 +419,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                 // and a function `fn bar(x: [(); 7])` as `fn bar(x: *const ())`.\n                 // This transformed type is wrong, but these function types are\n                 // already inaccurate due to ABI adjustments (see #42800).\n-                signature.extend(inputs.iter().map(|&t| {\n+                signature.extend(fn_abi.args.iter().map(|arg| {\n+                    let t = arg.layout.ty;\n                     let t = match t.kind {\n                         ty::Array(ct, _)\n                             if (ct == cx.tcx.types.u8) || cx.layout_of(ct).is_zst() => {\n@@ -442,21 +431,11 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n                 }));\n             } else {\n-                signature.extend(inputs.iter().map(|t| {\n-                    Some(type_metadata(cx, t, syntax_pos::DUMMY_SP))\n+                signature.extend(fn_abi.args.iter().map(|arg| {\n+                    Some(type_metadata(cx, arg.layout.ty, syntax_pos::DUMMY_SP))\n                 }));\n             }\n \n-            if sig.abi == Abi::RustCall && !sig.inputs().is_empty() {\n-                if let ty::Tuple(args) = sig.inputs()[sig.inputs().len() - 1].kind {\n-                    signature.extend(\n-                        args.iter().map(|argument_type| {\n-                            Some(type_metadata(cx, argument_type.expect_ty(), syntax_pos::DUMMY_SP))\n-                        })\n-                    );\n-                }\n-            }\n-\n             create_DIArray(DIB(cx), &signature[..])\n         }\n "}]}