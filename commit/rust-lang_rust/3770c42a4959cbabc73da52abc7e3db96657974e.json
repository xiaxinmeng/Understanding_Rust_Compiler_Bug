{"sha": "3770c42a4959cbabc73da52abc7e3db96657974e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NzBjNDJhNDk1OWNiYWJjNzNkYTUyYWJjN2UzZGI5NjY1Nzk3NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-19T01:41:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-19T01:41:43Z"}, "message": "auto merge of #15025 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "f16e89715388b6ac30e01c68bee674dafefa8a26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f16e89715388b6ac30e01c68bee674dafefa8a26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3770c42a4959cbabc73da52abc7e3db96657974e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3770c42a4959cbabc73da52abc7e3db96657974e", "html_url": "https://github.com/rust-lang/rust/commit/3770c42a4959cbabc73da52abc7e3db96657974e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3770c42a4959cbabc73da52abc7e3db96657974e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dcc9554599750e237119756e03a62fd0a9d8970", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dcc9554599750e237119756e03a62fd0a9d8970", "html_url": "https://github.com/rust-lang/rust/commit/0dcc9554599750e237119756e03a62fd0a9d8970"}, {"sha": "2c3bf8836f6f0cd18d8ac4f7189615f7f4098f5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c3bf8836f6f0cd18d8ac4f7189615f7f4098f5d", "html_url": "https://github.com/rust-lang/rust/commit/2c3bf8836f6f0cd18d8ac4f7189615f7f4098f5d"}], "stats": {"total": 3447, "additions": 2148, "deletions": 1299}, "files": [{"sha": "62a4ca6055ad6fda8faf767b93b5736dcdfb7013", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1 +1 @@\n-Subproject commit 7b97b8468f0614072cf3299fa8c51e85f609316f\n+Subproject commit 62a4ca6055ad6fda8faf767b93b5736dcdfb7013"}, {"sha": "ce3c2d7de8095aab75c5ac3a78177508379a53b7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1269,7 +1269,7 @@ fn make_out_name(config: &Config, testfile: &Path, extension: &str) -> Path {\n \n fn aux_output_dir_name(config: &Config, testfile: &Path) -> Path {\n     let mut f = output_base_name(config, testfile);\n-    match f.filename().map(|s| Vec::from_slice(s).append(bytes!(\".libaux\"))) {\n+    match f.filename().map(|s| Vec::from_slice(s).append(b\".libaux\")) {\n         Some(v) => f.set_filename(v),\n         None => ()\n     }\n@@ -1490,7 +1490,7 @@ fn append_suffix_to_stem(p: &Path, suffix: &str) -> Path {\n         (*p).clone()\n     } else {\n         let stem = p.filestem().unwrap();\n-        p.with_filename(Vec::from_slice(stem).append(bytes!(\"-\")).append(suffix.as_bytes()))\n+        p.with_filename(Vec::from_slice(stem).append(b\"-\").append(suffix.as_bytes()))\n     }\n }\n "}, {"sha": "84fd140a23af4b44fcc22be6fe0ec3aabb78c673", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -76,7 +76,7 @@ character.\n ~~~\n use std::str;\n \n-let x = bytes!(72u8,\"ello \",0xF0,0x90,0x80,\"World!\");\n+let x = b\"Hello \\xF0\\x90\\x80World!\";\n let y = str::from_utf8_lossy(x);\n ~~~\n "}, {"sha": "7e5e5b2e67a43be2c92e2f6d9c78d02b38d3db32", "filename": "src/doc/rust.md", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -378,6 +378,19 @@ the characters `U+0022` (double-quote) (except when followed by at least as\n many `U+0023` (`#`) characters as were used to start the raw string literal) or\n `U+005C` (`\\`) do not have any special meaning.\n \n+Examples for byte string literals:\n+\n+~~~~\n+b\"foo\"; br\"foo\";                     // foo\n+b\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n+\n+b\"foo #\\\"# bar\";\n+br##\"foo #\"# bar\"##;                 // foo #\"# bar\n+\n+b\"\\x52\"; b\"R\"; br\"R\";                // R\n+b\"\\\\x52\"; br\"\\x52\";                  // \\x52\n+~~~~\n+\n #### Number literals\n \n ~~~~ {.ebnf .gram}"}, {"sha": "ceda4bf6fe253cf69f8d2db4eb2bf390fef2730d", "filename": "src/etc/2014-06-rewrite-bytes-macros.py", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2F2014-06-rewrite-bytes-macros.py", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2F2014-06-rewrite-bytes-macros.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2F2014-06-rewrite-bytes-macros.py?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,138 @@\n+#!/bin/env python\n+#\n+# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import subprocess\n+import re\n+\n+\n+def main():\n+    if len(sys.argv) <= 1:\n+        print('Usage: %s [ --apply ] filename1.rs filename2.rs ...'\n+              % sys.argv[0])\n+    elif sys.argv[1] == '--apply':\n+        for filename in sys.argv[2:]:\n+            patch(filename)\n+    else:\n+        for filename in sys.argv[1:]:\n+            diff(filename)\n+\n+\n+def patch(filename):\n+    source = read(filename)\n+    rewritten = rewrite_bytes_macros(source)\n+    if rewritten is not None and rewritten != source:\n+        write(filename, rewritten)\n+\n+\n+def diff(filename):\n+    rewritten = rewrite_bytes_macros(read(filename))\n+    if rewritten is not None:\n+        p = subprocess.Popen(['diff', '-u', filename, '-'],\n+                             stdin=subprocess.PIPE)\n+        p.stdin.write(rewritten)\n+        p.stdin.close()\n+        p.wait()\n+\n+\n+def read(filename):\n+    with open(filename, 'rb') as f:\n+        return f.read()\n+\n+\n+def write(filename, content):\n+    with open(filename, 'wb') as f:\n+        f.write(content)\n+\n+\n+def rewrite_bytes_macros(source):\n+    rewritten, num_occurrences = BYTES_MACRO_RE.subn(rewrite_one_macro, source)\n+    if num_occurrences > 0:\n+        return rewritten\n+\n+\n+BYTES_MACRO_RE = re.compile(br'bytes!\\(  (?P<args>  [^)]*  )  \\)', re.VERBOSE)\n+\n+\n+def rewrite_one_macro(match):\n+    try:\n+        bytes = parse_bytes(split_args(match.group('args')))\n+        return b'b\"' + b''.join(map(escape, bytes)) + b'\"'\n+    except SkipThisRewrite:\n+        print('Skipped: %s' % match.group(0).decode('utf8', 'replace'))\n+        return match.group(0)\n+\n+\n+class SkipThisRewrite(Exception):\n+    pass\n+\n+\n+def split_args(args):\n+    previous = b''\n+    for arg in args.split(b','):\n+        if previous:\n+            arg = previous + b',' + arg\n+        if arg.count(b'\"') % 2 == 0:\n+            yield arg\n+            previous = b''\n+        else:\n+            previous = arg\n+    if previous:\n+        yield previous\n+\n+\n+def parse_bytes(args):\n+    for arg in args:\n+        arg = arg.strip()\n+        if (arg.startswith(b'\"') and arg.endswith(b'\"')) or (\n+                arg.startswith(b\"'\") and arg.endswith(b\"'\")):\n+            # Escaped newline means something different in Rust and Python.\n+            if b'\\\\\\n' in arg:\n+                raise SkipThisRewrite\n+            for byte in eval(b'u' + arg).encode('utf8'):\n+                yield ord(byte)\n+        else:\n+            if arg.endswith(b'u8'):\n+                arg = arg[:-2]\n+            # Assume that all Rust integer literals\n+            # are valid Python integer literals\n+            value = int(eval(arg))\n+            assert value <= 0xFF\n+            yield value\n+\n+\n+def escape(byte):\n+    c = chr(byte)\n+    escaped = {\n+        b'\\0': br'\\0',\n+        b'\\t': br'\\t',\n+        b'\\n': br'\\n',\n+        b'\\r': br'\\r',\n+        b'\\'': b'\\\\\\'',\n+        b'\\\\': br'\\\\',\n+    }.get(c)\n+    if escaped is not None:\n+        return escaped\n+    elif b' ' <= c <= b'~':\n+        return chr(byte)\n+    else:\n+        return ('\\\\x%02X' % byte).encode('ascii')\n+\n+\n+if str is not bytes:\n+    # Python 3.x\n+    ord = lambda x: x\n+    chr = lambda x: bytes([x])\n+\n+\n+if __name__ == '__main__':\n+    main()"}, {"sha": "c6b9b314da5c4581d2d3f2fdaa17054612f10d73", "filename": "src/etc/vim/autoload/rust.vim", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fautoload%2Frust.vim?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,225 @@\n+\" Author: Kevin Ballard\n+\" Description: Helper functions for Rust commands/mappings\n+\" Last Modified: May 27, 2014\n+\n+\" Jump {{{1\n+\n+function! rust#Jump(mode, function) range\n+\tlet cnt = v:count1\n+\tnormal! m'\n+\tif a:mode ==# 'v'\n+\t\tnorm! gv\n+\tendif\n+\tlet foldenable = &foldenable\n+\tset nofoldenable\n+\twhile cnt > 0\n+\t\texecute \"call <SID>Jump_\" . a:function . \"()\"\n+\t\tlet cnt = cnt - 1\n+\tendwhile\n+\tlet &foldenable = foldenable\n+endfunction\n+\n+function! s:Jump_Back()\n+\tcall search('{', 'b')\n+\tkeepjumps normal! w99[{\n+endfunction\n+\n+function! s:Jump_Forward()\n+\tnormal! j0\n+\tcall search('{', 'b')\n+\tkeepjumps normal! w99[{%\n+\tcall search('{')\n+endfunction\n+\n+\" Run {{{1\n+\n+function! rust#Run(bang, args)\n+\tif a:bang\n+\t\tlet idx = index(a:args, '--')\n+\t\tif idx != -1\n+\t\t\tlet rustc_args = idx == 0 ? [] : a:args[:idx-1]\n+\t\t\tlet args = a:args[idx+1:]\n+\t\telse\n+\t\t\tlet rustc_args = a:args\n+\t\t\tlet args = []\n+\t\tendif\n+\telse\n+\t\tlet rustc_args = []\n+\t\tlet args = a:args\n+\tendif\n+\n+\tlet b:rust_last_rustc_args = rustc_args\n+\tlet b:rust_last_args = args\n+\n+\tcall s:WithPath(function(\"s:Run\"), rustc_args, args)\n+endfunction\n+\n+function! s:Run(path, rustc_args, args)\n+\ttry\n+\t\tlet exepath = tempname()\n+\t\tif has('win32')\n+\t\t\tlet exepath .= '.exe'\n+\t\tendif\n+\n+\t\tlet rustc_args = [a:path, '-o', exepath] + a:rustc_args\n+\n+\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n+\n+\t\tlet output = system(shellescape(rustc) . \" \" . join(map(rustc_args, 'shellescape(v:val)')))\n+\t\tif output != ''\n+\t\t\techohl WarningMsg\n+\t\t\techo output\n+\t\t\techohl None\n+\t\tendif\n+\t\tif !v:shell_error\n+\t\t\texe '!' . shellescape(exepath) . \" \" . join(map(a:args, 'shellescape(v:val)'))\n+\t\tendif\n+\tfinally\n+\t\tif exists(\"exepath\")\n+\t\t\tsilent! call delete(exepath)\n+\t\tendif\n+\tendtry\n+endfunction\n+\n+\" Expand {{{1\n+\n+function! rust#Expand(bang, args)\n+\tif a:bang && !empty(a:args)\n+\t\tlet pretty = a:args[0]\n+\t\tlet args = a:args[1:]\n+\telse\n+\t\tlet pretty = \"expanded\"\n+\t\tlet args = a:args\n+\tendif\n+\tcall s:WithPath(function(\"s:Expand\"), pretty, args)\n+endfunction\n+\n+function! s:Expand(path, pretty, args)\n+\ttry\n+\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n+\n+\t\tlet args = [a:path, '--pretty', a:pretty] + a:args\n+\t\tlet output = system(shellescape(rustc) . \" \" . join(map(args, \"shellescape(v:val)\")))\n+\t\tif v:shell_error\n+\t\t\techohl WarningMsg\n+\t\t\techo output\n+\t\t\techohl None\n+\t\telse\n+\t\t\tnew\n+\t\t\tsilent put =output\n+\t\t\t1\n+\t\t\td\n+\t\t\tsetl filetype=rust\n+\t\t\tsetl buftype=nofile\n+\t\t\tsetl bufhidden=hide\n+\t\t\tsetl noswapfile\n+\t\tendif\n+\tendtry\n+endfunction\n+\n+function! rust#CompleteExpand(lead, line, pos)\n+\tif a:line[: a:pos-1] =~ '^RustExpand!\\s*\\S*$'\n+\t\t\" first argument and it has a !\n+\t\tlet list = [\"normal\", \"expanded\", \"typed\", \"expanded,identified\", \"flowgraph=\"]\n+\t\tif !empty(a:lead)\n+\t\t\tcall filter(list, \"v:val[:len(a:lead)-1] == a:lead\")\n+\t\tendif\n+\t\treturn list\n+\tendif\n+\n+\treturn glob(escape(a:lead, \"*?[\") . '*', 0, 1)\n+endfunction\n+\n+\" Emit {{{1\n+\n+function! rust#Emit(type, args)\n+\tcall s:WithPath(function(\"s:Emit\"), a:type, a:args)\n+endfunction\n+\n+function! s:Emit(path, type, args)\n+\ttry\n+\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n+\n+\t\tlet args = [a:path, '--emit', a:type, '-o', '-'] + a:args\n+\t\tlet output = system(shellescape(rustc) . \" \" . join(map(args, \"shellescape(v:val)\")))\n+\t\tif v:shell_error\n+\t\t\techohl WarningMsg\n+\t\t\techo output\n+\t\t\techohl None\n+\t\telse\n+\t\t\tnew\n+\t\t\tsilent put =output\n+\t\t\t1\n+\t\t\td\n+\t\t\tif a:type == \"ir\"\n+\t\t\t\tsetl filetype=llvm\n+\t\t\telseif a:type == \"asm\"\n+\t\t\t\tsetl filetype=asm\n+\t\t\tendif\n+\t\t\tsetl buftype=nofile\n+\t\t\tsetl bufhidden=hide\n+\t\t\tsetl noswapfile\n+\t\tendif\n+\tendtry\n+endfunction\n+\n+\" Utility functions {{{1\n+\n+function! s:WithPath(func, ...)\n+\ttry\n+\t\tlet save_write = &write\n+\t\tset write\n+\t\tlet path = expand('%')\n+\t\tlet pathisempty = empty(path)\n+\t\tif pathisempty || !save_write\n+\t\t\t\" use a temporary file named 'unnamed.rs' inside a temporary\n+\t\t\t\" directory. This produces better error messages\n+\t\t\tlet tmpdir = tempname()\n+\t\t\tcall mkdir(tmpdir)\n+\n+\t\t\tlet save_cwd = getcwd()\n+\t\t\tsilent exe 'lcd' tmpdir\n+\n+\t\t\tlet path = 'unnamed.rs'\n+\n+\t\t\tlet save_mod = &mod\n+\t\t\tset nomod\n+\n+\t\t\tsilent exe 'keepalt write! ' . path\n+\t\t\tif pathisempty\n+\t\t\t\tsilent keepalt 0file\n+\t\t\tendif\n+\t\telse\n+\t\t\tupdate\n+\t\tendif\n+\n+\t\tcall call(a:func, [path] + a:000)\n+\tfinally\n+\t\tif exists(\"save_mod\")   | let &mod = save_mod          | endif\n+\t\tif exists(\"save_write\") | let &write = save_write      | endif\n+\t\tif exists(\"save_cwd\")   | silent exe 'lcd' save_cwd    | endif\n+\t\tif exists(\"tmpdir\")     | silent call s:RmDir(tmpdir)  | endif\n+\tendtry\n+endfunction\n+\n+function! rust#AppendCmdLine(text)\n+\tcall setcmdpos(getcmdpos())\n+\tlet cmd = getcmdline() . a:text\n+\treturn cmd\n+endfunction\n+\n+function! s:RmDir(path)\n+\t\" sanity check; make sure it's not empty, /, or $HOME\n+\tif empty(a:path)\n+\t\techoerr 'Attempted to delete empty path'\n+\t\treturn 0\n+\telseif a:path == '/' || a:path == $HOME\n+\t\techoerr 'Attempted to delete protected path: ' . a:path\n+\t\treturn 0\n+\tendif\n+\tsilent exe \"!rm -rf \" . shellescape(a:path)\n+endfunction\n+\n+\" }}}1\n+\n+\" vim: set noet sw=4 ts=4:"}, {"sha": "96ed69db635294c1b572f7b270d57b8c24809456", "filename": "src/etc/vim/doc/rust.txt", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fdoc%2Frust.txt?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,150 @@\n+*rust.txt*      Filetype plugin for Rust\n+\n+==============================================================================\n+CONTENTS                                                                *rust*\n+\n+1. Introduction                                                   |rust-intro|\n+2. Settings                                                    |rust-settings|\n+3. Commands                                                    |rust-commands|\n+4. Mappings                                                    |rust-mappings|\n+\n+==============================================================================\n+INTRODUCTION                                                      *rust-intro*\n+\n+This plugin provides syntax and supporting functionality for the Rust\n+filetype.\n+\n+==============================================================================\n+SETTINGS                                                       *rust-settings*\n+\n+This plugin has a few variables you can define in your vimrc that change the\n+behavior of the plugin.\n+\n+                                                                *g:rustc_path*\n+g:rustc_path~\n+\tSet this option to the path to rustc for use in the |:RustRun| and\n+\t|:RustExpand| commands. If unset, \"rustc\" will be located in $PATH: >\n+\t    let g:rustc_path = $HOME.\"/bin/rustc\"\n+<\n+\n+                                                  *g:rustc_makeprg_no_percent*\n+g:rustc_makeprg_no_percent~\n+\tSet this option to 1 to have 'makeprg' default to \"rustc\" instead of\n+\t\"rustc %\": >\n+\t    let g:rustc_makeprg_no_percent = 1\n+<\n+\n+                                                              *g:rust_conceal*\n+g:rust_conceal~\n+\tSet this option to turn on the basic |conceal| support: >\n+\t    let g:rust_conceal = 1\n+<\n+\n+                                                     *g:rust_conceal_mod_path*\n+g:rust_conceal_mod_path~\n+\tSet this option to turn on |conceal| for the path connecting token\n+\t\"::\": >\n+\t    let g:rust_conceal_mod_path = 1\n+<\n+\n+                                                          *g:rust_conceal_pub*\n+g:rust_conceal_pub~\n+\tSet this option to turn on |conceal| for the \"pub\" token: >\n+\t    let g:rust_conceal_pub = 1\n+<\n+\n+                                                  *g:rust_bang_comment_leader*\n+g:rust_bang_comment_leader~\n+\tSet this option to 1 to preserve the leader on multi-line doc comments\n+\tusing the /*! syntax: >\n+\t    let g:rust_bang_comment_leader = 1\n+<\n+\n+                                                 *g:ftplugin_rust_source_path*\n+g:ftplugin_rust_source_path~\n+\tSet this option to a path that should be prepended to 'path' for Rust\n+\tsource files: >\n+\t    let g:ftplugin_rust_source_path = $HOME.'/dev/rust'\n+<\n+\n+==============================================================================\n+COMMANDS                                                       *rust-commands*\n+\n+:RustRun  [args]                                                    *:RustRun*\n+:RustRun! [rustc-args] [--] [args]\n+\t\tCompiles and runs the current file. If it has unsaved changes,\n+\t\tit will be saved first using |:update|. If the current file is\n+\t\tan unnamed buffer, it will be written to a temporary file\n+\t\tfirst. The compiled binary is always placed in a temporary\n+\t\tdirectory, but is run from the current directory.\n+\n+\t\tThe arguments given to |:RustRun| will be passed to the\n+\t\tcompiled binary.\n+\n+\t\tIf ! is specified, the arguments are passed to rustc instead.\n+\t\tA \"--\" argument will separate the rustc arguments from the\n+\t\targuments passed to the binary.\n+\n+\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n+\t\tOtherwise it is assumed rustc can be found in $PATH.\n+\n+:RustExpand  [args]                                              *:RustExpand*\n+:RustExpand! [TYPE] [args]\n+\t\tExpands the current file using --pretty and displays the\n+\t\tresults in a new split. If the current file has unsaved\n+\t\tchanges, it will be saved first using |:update|. If the\n+\t\tcurrent file is an unnamed buffer, it will be written to a\n+\t\ttemporary file first.\n+\n+\t\tThe arguments given to |:RustExpand| will be passed to rustc.\n+\t\tThis is largely intended for specifying various --cfg\n+\t\tconfigurations.\n+\n+\t\tIf ! is specified, the first argument is the expansion type to\n+\t\tpass to rustc --pretty. Otherwise it will default to\n+\t\t\"expanded\".\n+\n+\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n+\t\tOtherwise it is assumed rustc can be found in $PATH.\n+\n+:RustEmitIr [args]                                               *:RustEmitIr*\n+\t\tCompiles the current file to LLVM IR and displays the results\n+\t\tin a new split. If the current file has unsaved changes, it\n+\t\twill be saved first using |:update|. If the current file is an\n+\t\tunnamed buffer, it will be written to a temporary file first.\n+\n+\t\tThe arguments given to |:RustEmitIr| will be passed to rustc.\n+\n+\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n+\t\tOtherwise it is assumed rustc can be found in $PATH.\n+\n+:RustEmitAsm [args]                                             *:RustEmitAsm*\n+\t\tCompiles the current file to assembly and displays the results\n+\t\tin a new split. If the current file has unsaved changes, it\n+\t\twill be saved first using |:update|. If the current file is an\n+\t\tunnamed buffer, it will be written to a temporary file first.\n+\n+\t\tThe arguments given to |:RustEmitAsm| will be passed to rustc.\n+\n+\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n+\t\tOtherwise it is assumed rustc can be found in $PATH.\n+\n+==============================================================================\n+MAPPINGS                                                       *rust-mappings*\n+\n+This plugin defines mappings for |[[| and |]]| to support hanging indents.\n+\n+It also has a few other mappings:\n+\n+\t\t\t\t\t\t\t*rust_<D-r>*\n+<D-r>\t\t\tExecutes |:RustRun| with no arguments.\n+\t\t\tNote: This binding is only available in MacVim.\n+\n+\t\t\t\t\t\t\t*rust_<D-R>*\n+<D-R>\t\t\tPopulates the command line with |:RustRun|! using the\n+\t\t\targuments given to the last invocation, but does not\n+\t\t\texecute it.\n+\t\t\tNote: This binding is only available in MacVim.\n+\n+==============================================================================\n+ vim:tw=78:sw=4:noet:ts=8:ft=help:norl:"}, {"sha": "65f9f4105ad8fda5c8d58657f5832072102e47d5", "filename": "src/etc/vim/ftplugin/rust.vim", "status": "modified", "additions": 58, "deletions": 37, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1,13 +1,19 @@\n-\" Vim syntax file\n \" Language:     Rust\n+\" Description:  Vim syntax file for Rust\n \" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  2014 Feb 27\n+\" Maintainer:   Kevin Ballard <kevin@sb.org>\n+\" Last Change:  May 27, 2014\n \n if exists(\"b:did_ftplugin\")\n \tfinish\n endif\n let b:did_ftplugin = 1\n \n+let s:save_cpo = &cpo\n+set cpo&vim\n+\n+\" Variables {{{1\n+\n \" The rust source code at present seems to typically omit a leader on /*!\n \" comments, so we'll use that as our default, but make it easy to switch.\n \" This does not affect indentation at all (I tested it with and without\n@@ -42,22 +48,59 @@ if exists(\"g:loaded_delimitMate\")\n \tlet b:delimitMate_excluded_regions = delimitMate#Get(\"excluded_regions\") . ',rustLifetimeCandidate,rustGenericLifetimeCandidate'\n endif\n \n+\" Motion Commands {{{1\n+\n \" Bind motion commands to support hanging indents\n-nnoremap <silent> <buffer> [[ :call <SID>Rust_Jump('n', 'Back')<CR>\n-nnoremap <silent> <buffer> ]] :call <SID>Rust_Jump('n', 'Forward')<CR>\n-xnoremap <silent> <buffer> [[ :call <SID>Rust_Jump('v', 'Back')<CR>\n-xnoremap <silent> <buffer> ]] :call <SID>Rust_Jump('v', 'Forward')<CR>\n-onoremap <silent> <buffer> [[ :call <SID>Rust_Jump('o', 'Back')<CR>\n-onoremap <silent> <buffer> ]] :call <SID>Rust_Jump('o', 'Forward')<CR>\n+nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>\n+nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>\n+xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>\n+xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>\n+onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>\n+onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>\n+\n+\" Commands {{{1\n+\n+\" See |:RustRun| for docs\n+command! -nargs=* -complete=file -bang -bar -buffer RustRun call rust#Run(<bang>0, [<f-args>])\n+\n+\" See |:RustExpand| for docs\n+command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -bar -buffer RustExpand call rust#Expand(<bang>0, [<f-args>])\n+\n+\" See |:RustEmitIr| for docs\n+command! -nargs=* -bar -buffer RustEmitIr call rust#Emit(\"ir\", [<f-args>])\n+\n+\" See |:RustEmitAsm| for docs\n+command! -nargs=* -bar -buffer RustEmitAsm call rust#Emit(\"asm\", [<f-args>])\n+\n+\" Mappings {{{1\n+\n+\" Bind \u2318R in MacVim to :RustRun\n+nnoremap <silent> <buffer> <D-r> :RustRun<CR>\n+\" Bind \u2318\u21e7R in MacVim to :RustRun! pre-filled with the last args\n+nnoremap <buffer> <D-R> :RustRun! <C-r>=join(b:rust_last_rustc_args)<CR><C-\\>erust#AppendCmdLine(' -- ' . join(b:rust_last_args))<CR>\n+\n+if !exists(\"b:rust_last_rustc_args\") || !exists(\"b:rust_last_args\")\n+\tlet b:rust_last_rustc_args = []\n+\tlet b:rust_last_args = []\n+endif\n+\n+\" Cleanup {{{1\n \n let b:undo_ftplugin = \"\n \t\t\\setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<\n \t\t\\|if exists('b:rust_original_delimitMate_excluded_regions')\n \t\t  \\|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions\n \t\t  \\|unlet b:rust_original_delimitMate_excluded_regions\n-\t\t\\|elseif exists('b:delimitMate_excluded_regions')\n-\t\t  \\|unlet b:delimitMate_excluded_regions\n+\t\t\\|else\n+\t\t  \\|unlet! b:delimitMate_excluded_regions\n \t\t\\|endif\n+\t\t\\|unlet! b:rust_last_rustc_args b:rust_last_args\n+\t\t\\|delcommand RustRun\n+\t\t\\|delcommand RustExpand\n+\t\t\\|delcommand RustEmitIr\n+\t\t\\|delcommand RustEmitAsm\n+\t\t\\|nunmap <buffer> <D-r>\n+\t\t\\|nunmap <buffer> <D-R>\n \t\t\\|nunmap <buffer> [[\n \t\t\\|nunmap <buffer> ]]\n \t\t\\|xunmap <buffer> [[\n@@ -66,31 +109,9 @@ let b:undo_ftplugin = \"\n \t\t\\|ounmap <buffer> ]]\n \t\t\\\"\n \n-if exists('*<SID>Rust_Jump') | finish | endif\n+\" }}}1\n \n-function! <SID>Rust_Jump(mode, function) range\n-\tlet cnt = v:count1\n-\tnormal! m'\n-\tif a:mode ==# 'v'\n-\t\tnorm! gv\n-\tendif\n-\tlet foldenable = &foldenable\n-\tset nofoldenable\n-\twhile cnt > 0\n-\t\texecute \"call <SID>Rust_Jump_\" . a:function . \"()\"\n-\t\tlet cnt = cnt - 1\n-\tendwhile\n-\tlet &foldenable = foldenable\n-endfunction\n-\n-function! <SID>Rust_Jump_Back()\n-\tcall search('{', 'b')\n-\tkeepjumps normal! w99[{\n-endfunction\n-\n-function! <SID>Rust_Jump_Forward()\n-\tnormal! j0\n-\tcall search('{', 'b')\n-\tkeepjumps normal! w99[{%\n-\tcall search('{')\n-endfunction\n+let &cpo = s:save_cpo\n+unlet s:save_cpo\n+\n+\" vim: set noet sw=4 ts=4:"}, {"sha": "a0488cdb05ab47c42f02f59e379370db671441f2", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -145,11 +145,13 @@ syn match     rustOperator     display \"&&\\|||\"\n syn match     rustMacro       '\\w\\(\\w\\)*!' contains=rustAssert,rustFail\n syn match     rustMacro       '#\\w\\(\\w\\)*' contains=rustAssert,rustFail\n \n-syn match     rustSpecialError display contained /\\\\./\n-syn match     rustSpecial     display contained /\\\\\\([nrt0\\\\'\"]\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)/\n+syn match     rustEscapeError   display contained /\\\\./\n+syn match     rustEscape        display contained /\\\\\\([nrt0\\\\'\"]\\|x\\x\\{2}\\)/\n+syn match     rustEscapeUnicode display contained /\\\\\\(u\\x\\{4}\\|U\\x\\{8}\\)/\n syn match     rustStringContinuation display contained /\\\\\\n\\s*/\n-syn region    rustString      start=+\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustSpecial,rustSpecialError,rustStringContinuation,@Spell\n-syn region    rustString      start='r\\z(#*\\)\"' end='\"\\z1' contains=@Spell\n+syn region    rustString      start=+b\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeError,rustStringContinuation\n+syn region    rustString      start=+\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell\n+syn region    rustString      start='b\\?r\\z(#*\\)\"' end='\"\\z1' contains=@Spell\n \n syn region    rustAttribute   start=\"#!\\?\\[\" end=\"\\]\" contains=rustString,rustDeriving\n syn region    rustDeriving    start=\"deriving(\" end=\")\" contained contains=rustTrait\n@@ -177,7 +179,11 @@ syn region rustGenericLifetimeCandidate display start=/\\%(<\\|,\\s*\\)\\@<='/ end=/[\n \n \"rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting\n syn match     rustLifetime    display \"\\'\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\"\n-syn match   rustCharacter   /'\\([^'\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)\\)'/ contains=rustSpecial,rustSpecialError\n+syn match   rustCharacterInvalid   display contained /b\\?'\\zs[\\n\\r\\t']\\ze'/\n+\" The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).\n+syn match   rustCharacterInvalidUnicode   display contained /b'\\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\\ze'/\n+syn match   rustCharacter   /b'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\)\\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode\n+syn match   rustCharacter   /'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)\\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid\n \n syn region rustCommentLine                                        start=\"//\"                      end=\"$\"   contains=rustTodo,@Spell\n syn region rustCommentLineDoc                                     start=\"//\\%(//\\@!\\|!\\)\"         end=\"$\"   contains=rustTodo,@Spell\n@@ -215,10 +221,13 @@ hi def link rustIdentifierPrime rustIdentifier\n hi def link rustTrait           rustType\n \n hi def link rustSigil         StorageClass\n-hi def link rustSpecial       Special\n-hi def link rustSpecialError  Error\n+hi def link rustEscape        Special\n+hi def link rustEscapeUnicode rustEscape\n+hi def link rustEscapeError   Error\n hi def link rustStringContinuation Special\n hi def link rustString        String\n+hi def link rustCharacterInvalid Error\n+hi def link rustCharacterInvalidUnicode rustCharacterInvalid\n hi def link rustCharacter     Character\n hi def link rustNumber        Number\n hi def link rustBoolean       Boolean"}, {"sha": "b4d0057778a1a395255300163a03192be6a6c743", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -132,7 +132,7 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n mod imp {\n     use core::option::{None, Option};\n     use core::ptr::{RawPtr, mut_null, null};\n-    use core::num::Bitwise;\n+    use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n \n     #[link(name = \"jemalloc\", kind = \"static\")]"}, {"sha": "1360b412c23704dfdbeebecc7240dd1caeace739", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -15,8 +15,6 @@\n \n use core::prelude::*;\n \n-use core::num::Bitwise;\n-\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n /// A specialized Set implementation to use enum types.\n pub struct EnumSet<E> {"}, {"sha": "a0c0c9f97357816edc7470a674a78e1fb82ba6fb", "filename": "src/libcollections/hash/mod.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhash%2Fmod.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -98,46 +98,30 @@ pub trait Writer {\n \n //////////////////////////////////////////////////////////////////////////////\n \n-fn id<T>(t: T) -> T { t }\n-\n-macro_rules! impl_hash(\n-    ( $($ty:ident, $uty:ident, $f:path;)* ) => (\n-        $(\n-            impl<S: Writer> Hash<S> for $ty {\n-                #[inline]\n-                fn hash(&self, state: &mut S) {\n-                    let a: [u8, ..::core::$ty::BYTES] = unsafe {\n-                        mem::transmute($f(*self as $uty) as $ty)\n-                    };\n-                    state.write(a.as_slice())\n-                }\n+macro_rules! impl_hash {\n+    ($ty:ident, $uty:ident) => {\n+        impl<S: Writer> Hash<S> for $ty {\n+            #[inline]\n+            fn hash(&self, state: &mut S) {\n+                let a: [u8, ..::core::$ty::BYTES] = unsafe {\n+                    mem::transmute((*self as $uty).to_le() as $ty)\n+                };\n+                state.write(a.as_slice())\n             }\n-        )*\n-    )\n-)\n-\n-impl_hash!(\n-    u8, u8, id;\n-    u16, u16, mem::to_le16;\n-    u32, u32, mem::to_le32;\n-    u64, u64, mem::to_le64;\n-    i8, u8, id;\n-    i16, u16, mem::to_le16;\n-    i32, u32, mem::to_le32;\n-    i64, u64, mem::to_le64;\n-)\n-\n-#[cfg(target_word_size = \"32\")]\n-impl_hash!(\n-    uint, u32, mem::to_le32;\n-    int, u32, mem::to_le32;\n-)\n+        }\n+    }\n+}\n \n-#[cfg(target_word_size = \"64\")]\n-impl_hash!(\n-    uint, u64, mem::to_le64;\n-    int, u64, mem::to_le64;\n-)\n+impl_hash!(u8, u8)\n+impl_hash!(u16, u16)\n+impl_hash!(u32, u32)\n+impl_hash!(u64, u64)\n+impl_hash!(uint, uint)\n+impl_hash!(i8, u8)\n+impl_hash!(i16, u16)\n+impl_hash!(i32, u32)\n+impl_hash!(i64, u64)\n+impl_hash!(int, uint)\n \n impl<S: Writer> Hash<S> for bool {\n     #[inline]"}, {"sha": "f9826fcd2287ff8e37d39bc2a86a7c93b043a9ff", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1957,30 +1957,30 @@ mod tests {\n \n     #[test]\n     fn test_starts_with() {\n-        assert!(bytes!(\"foobar\").starts_with(bytes!(\"foo\")));\n-        assert!(!bytes!(\"foobar\").starts_with(bytes!(\"oob\")));\n-        assert!(!bytes!(\"foobar\").starts_with(bytes!(\"bar\")));\n-        assert!(!bytes!(\"foo\").starts_with(bytes!(\"foobar\")));\n-        assert!(!bytes!(\"bar\").starts_with(bytes!(\"foobar\")));\n-        assert!(bytes!(\"foobar\").starts_with(bytes!(\"foobar\")));\n+        assert!(b\"foobar\".starts_with(b\"foo\"));\n+        assert!(!b\"foobar\".starts_with(b\"oob\"));\n+        assert!(!b\"foobar\".starts_with(b\"bar\"));\n+        assert!(!b\"foo\".starts_with(b\"foobar\"));\n+        assert!(!b\"bar\".starts_with(b\"foobar\"));\n+        assert!(b\"foobar\".starts_with(b\"foobar\"));\n         let empty: &[u8] = [];\n         assert!(empty.starts_with(empty));\n-        assert!(!empty.starts_with(bytes!(\"foo\")));\n-        assert!(bytes!(\"foobar\").starts_with(empty));\n+        assert!(!empty.starts_with(b\"foo\"));\n+        assert!(b\"foobar\".starts_with(empty));\n     }\n \n     #[test]\n     fn test_ends_with() {\n-        assert!(bytes!(\"foobar\").ends_with(bytes!(\"bar\")));\n-        assert!(!bytes!(\"foobar\").ends_with(bytes!(\"oba\")));\n-        assert!(!bytes!(\"foobar\").ends_with(bytes!(\"foo\")));\n-        assert!(!bytes!(\"foo\").ends_with(bytes!(\"foobar\")));\n-        assert!(!bytes!(\"bar\").ends_with(bytes!(\"foobar\")));\n-        assert!(bytes!(\"foobar\").ends_with(bytes!(\"foobar\")));\n+        assert!(b\"foobar\".ends_with(b\"bar\"));\n+        assert!(!b\"foobar\".ends_with(b\"oba\"));\n+        assert!(!b\"foobar\".ends_with(b\"foo\"));\n+        assert!(!b\"foo\".ends_with(b\"foobar\"));\n+        assert!(!b\"bar\".ends_with(b\"foobar\"));\n+        assert!(b\"foobar\".ends_with(b\"foobar\"));\n         let empty: &[u8] = [];\n         assert!(empty.ends_with(empty));\n-        assert!(!empty.ends_with(bytes!(\"foo\")));\n-        assert!(bytes!(\"foobar\").ends_with(empty));\n+        assert!(!empty.ends_with(b\"foo\"));\n+        assert!(b\"foobar\".ends_with(empty));\n     }\n \n     #[test]"}, {"sha": "642e7cfc9a36f44be39d5e27ca1177583f6d1df1", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -382,7 +382,7 @@ static TAG_CONT_U8: u8 = 128u8;\n /// # Example\n ///\n /// ```rust\n-/// let input = bytes!(\"Hello \", 0xF0, 0x90, 0x80, \"World\");\n+/// let input = b\"Hello \\xF0\\x90\\x80World\";\n /// let output = std::str::from_utf8_lossy(input);\n /// assert_eq!(output.as_slice(), \"Hello \\uFFFDWorld\");\n /// ```\n@@ -391,7 +391,7 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         return Slice(unsafe { mem::transmute(v) })\n     }\n \n-    static REPLACEMENT: &'static [u8] = bytes!(0xEF, 0xBF, 0xBD); // U+FFFD in UTF-8\n+    static REPLACEMENT: &'static [u8] = b\"\\xEF\\xBF\\xBD\"; // U+FFFD in UTF-8\n     let mut i = 0;\n     let total = v.len();\n     fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n@@ -994,7 +994,7 @@ mod tests {\n     fn test_into_bytes() {\n         let data = \"asdf\".to_string();\n         let buf = data.into_bytes();\n-        assert_eq!(bytes!(\"asdf\"), buf.as_slice());\n+        assert_eq!(b\"asdf\", buf.as_slice());\n     }\n \n     #[test]\n@@ -2050,58 +2050,58 @@ mod tests {\n \n     #[test]\n     fn test_str_from_utf8() {\n-        let xs = bytes!(\"hello\");\n+        let xs = b\"hello\";\n         assert_eq!(from_utf8(xs), Some(\"hello\"));\n \n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n         assert_eq!(from_utf8(xs), Some(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n-        let xs = bytes!(\"hello\", 0xff);\n+        let xs = b\"hello\\xFF\";\n         assert_eq!(from_utf8(xs), None);\n     }\n \n     #[test]\n     fn test_str_from_utf8_owned() {\n-        let xs = Vec::from_slice(bytes!(\"hello\"));\n+        let xs = Vec::from_slice(b\"hello\");\n         assert_eq!(from_utf8_owned(xs), Ok(\"hello\".to_string()));\n \n-        let xs = Vec::from_slice(bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        let xs = Vec::from_slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes());\n         assert_eq!(from_utf8_owned(xs), Ok(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_string()));\n \n-        let xs = Vec::from_slice(bytes!(\"hello\", 0xff));\n+        let xs = Vec::from_slice(b\"hello\\xFF\");\n         assert_eq!(from_utf8_owned(xs),\n-                   Err(Vec::from_slice(bytes!(\"hello\", 0xff))));\n+                   Err(Vec::from_slice(b\"hello\\xFF\")));\n     }\n \n     #[test]\n     fn test_str_from_utf8_lossy() {\n-        let xs = bytes!(\"hello\");\n+        let xs = b\"hello\";\n         assert_eq!(from_utf8_lossy(xs), Slice(\"hello\"));\n \n-        let xs = bytes!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n         assert_eq!(from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n-        let xs = bytes!(\"Hello\", 0xC2, \" There\", 0xFF, \" Goodbye\");\n+        let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD There\\uFFFD Goodbye\".to_string()));\n \n-        let xs = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        let xs = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"Hello\\uFFFD\\uFFFD There\\uFFFD Goodbye\".to_string()));\n \n-        let xs = bytes!(0xF5, \"foo\", 0xF5, 0x80, \"bar\");\n+        let xs = b\"\\xF5foo\\xF5\\x80bar\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFD\\uFFFDbar\".to_string()));\n \n-        let xs = bytes!(0xF1, \"foo\", 0xF1, 0x80, \"bar\", 0xF1, 0x80, 0x80, \"baz\");\n+        let xs = b\"\\xF1foo\\xF1\\x80bar\\xF1\\x80\\x80baz\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFDbaz\".to_string()));\n \n-        let xs = bytes!(0xF4, \"foo\", 0xF4, 0x80, \"bar\", 0xF4, 0xBF, \"baz\");\n+        let xs = b\"\\xF4foo\\xF4\\x80bar\\xF4\\xBFbaz\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFDfoo\\uFFFDbar\\uFFFD\\uFFFDbaz\".to_string()));\n \n-        let xs = bytes!(0xF0, 0x80, 0x80, 0x80, \"foo\", 0xF0, 0x90, 0x80, 0x80, \"bar\");\n+        let xs = b\"\\xF0\\x80\\x80\\x80foo\\xF0\\x90\\x80\\x80bar\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFD\\uFFFD\\\n                                                foo\\U00010000bar\".to_string()));\n \n         // surrogates\n-        let xs = bytes!(0xED, 0xA0, 0x80, \"foo\", 0xED, 0xBF, 0xBF, \"bar\");\n+        let xs = b\"\\xED\\xA0\\x80foo\\xED\\xBF\\xBFbar\";\n         assert_eq!(from_utf8_lossy(xs), Owned(\"\\uFFFD\\uFFFD\\uFFFDfoo\\\n                                                \\uFFFD\\uFFFD\\uFFFDbar\".to_string()));\n     }\n@@ -2298,8 +2298,8 @@ mod bench {\n     #[bench]\n     fn is_utf8_100_ascii(b: &mut Bencher) {\n \n-        let s = bytes!(\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                        Lorem ipsum dolor sit amet, consectetur. \");\n+        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                  Lorem ipsum dolor sit amet, consectetur. \";\n \n         assert_eq!(100, s.len());\n         b.iter(|| {\n@@ -2309,7 +2309,7 @@ mod bench {\n \n     #[bench]\n     fn is_utf8_100_multibyte(b: &mut Bencher) {\n-        let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n+        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n         assert_eq!(100, s.len());\n         b.iter(|| {\n             is_utf8(s)\n@@ -2318,8 +2318,8 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_ascii(b: &mut Bencher) {\n-        let s = bytes!(\"Hello there, the quick brown fox jumped over the lazy dog! \\\n-                        Lorem ipsum dolor sit amet, consectetur. \");\n+        let s = b\"Hello there, the quick brown fox jumped over the lazy dog! \\\n+                  Lorem ipsum dolor sit amet, consectetur. \";\n \n         assert_eq!(100, s.len());\n         b.iter(|| {\n@@ -2329,7 +2329,7 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_100_multibyte(b: &mut Bencher) {\n-        let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n+        let s = \"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\".as_bytes();\n         assert_eq!(100, s.len());\n         b.iter(|| {\n             let _ = from_utf8_lossy(s);\n@@ -2338,7 +2338,7 @@ mod bench {\n \n     #[bench]\n     fn from_utf8_lossy_invalid(b: &mut Bencher) {\n-        let s = bytes!(\"Hello\", 0xC0, 0x80, \" There\", 0xE6, 0x83, \" Goodbye\");\n+        let s = b\"Hello\\xC0\\x80 There\\xE6\\x83 Goodbye\";\n         b.iter(|| {\n             let _ = from_utf8_lossy(s);\n         });"}, {"sha": "5280ac0d64fb22c10eec5f9bd6ebae6235e90a9f", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 74, "deletions": 140, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -13,9 +13,9 @@\n //! This module contains functions for querying the size and alignment of\n //! types, initializing and manipulating memory.\n \n-use ptr;\n use intrinsics;\n-use intrinsics::{bswap16, bswap32, bswap64};\n+use num::Int;\n+use ptr;\n \n pub use intrinsics::transmute;\n \n@@ -172,153 +172,89 @@ pub unsafe fn move_val_init<T>(dst: &mut T, src: T) {\n /// Convert an u16 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] pub fn to_le16(x: u16) -> u16 { x }\n-\n-/// Convert an u16 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n-\n-/// Convert an u32 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_le32(x: u32) -> u32 { x }\n+#[inline]\n+#[deprecated = \"use `Int::to_le` instead\"]\n+pub fn to_le16(x: u16) -> u16 { x.to_le() }\n \n /// Convert an u32 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n-\n-/// Convert an u64 to little endian from the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_le64(x: u64) -> u64 { x }\n+#[inline]\n+#[deprecated = \"use `Int::to_le` instead\"]\n+pub fn to_le32(x: u32) -> u32 { x.to_le() }\n \n /// Convert an u64 to little endian from the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n-\n-\n-/// Convert an u16 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[inline]\n+#[deprecated = \"use `Int::to_le` instead\"]\n+pub fn to_le64(x: u64) -> u64 { x.to_le() }\n \n /// Convert an u16 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_be16(x: u16) -> u16 { x }\n-\n-/// Convert an u32 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[inline]\n+#[deprecated = \"use `Int::to_be` instead\"]\n+pub fn to_be16(x: u16) -> u16 { x.to_be() }\n \n /// Convert an u32 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_be32(x: u32) -> u32 { x }\n-\n-/// Convert an u64 to big endian from the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn to_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[inline]\n+#[deprecated = \"use `Int::to_be` instead\"]\n+pub fn to_be32(x: u32) -> u32 { x.to_be() }\n \n /// Convert an u64 to big endian from the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn to_be64(x: u64) -> u64 { x }\n-\n-\n-/// Convert an u16 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_le16(x: u16) -> u16 { x }\n+#[inline]\n+#[deprecated = \"use `Int::to_be` instead\"]\n+pub fn to_be64(x: u64) -> u64 { x.to_be() }\n \n /// Convert an u16 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_le16(x: u16) -> u16 { unsafe { bswap16(x) } }\n-\n-/// Convert an u32 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_le32(x: u32) -> u32 { x }\n+#[inline]\n+#[deprecated = \"use `Int::from_le` instead\"]\n+pub fn from_le16(x: u16) -> u16 { Int::from_le(x) }\n \n /// Convert an u32 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_le32(x: u32) -> u32 { unsafe { bswap32(x) } }\n-\n-/// Convert an u64 from little endian to the target's endianness.\n-///\n-/// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_le64(x: u64) -> u64 { x }\n+#[inline]\n+#[deprecated = \"use `Int::from_le` instead\"]\n+pub fn from_le32(x: u32) -> u32 { Int::from_le(x) }\n \n /// Convert an u64 from little endian to the target's endianness.\n ///\n /// On little endian, this is a no-op.  On big endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_le64(x: u64) -> u64 { unsafe { bswap64(x) } }\n-\n-\n-/// Convert an u16 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_be16(x: u16) -> u16 { unsafe { bswap16(x) } }\n+#[inline]\n+#[deprecated = \"use `Int::from_le` instead\"]\n+pub fn from_le64(x: u64) -> u64 { Int::from_le(x) }\n \n /// Convert an u16 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_be16(x: u16) -> u16 { x }\n-\n-/// Convert an u32 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_be32(x: u32) -> u32 { unsafe { bswap32(x) } }\n+#[inline]\n+#[deprecated = \"use `Int::from_be` instead\"]\n+pub fn from_be16(x: u16) -> u16 { Int::from_be(x) }\n \n /// Convert an u32 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_be32(x: u32) -> u32 { x }\n-\n-/// Convert an u64 from big endian to the target's endianness.\n-///\n-/// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"little\")] #[inline] #[stable]\n-pub fn from_be64(x: u64) -> u64 { unsafe { bswap64(x) } }\n+#[inline]\n+#[deprecated = \"use `Int::from_be` instead\"]\n+pub fn from_be32(x: u32) -> u32 { Int::from_be(x) }\n \n /// Convert an u64 from big endian to the target's endianness.\n ///\n /// On big endian, this is a no-op.  On little endian, the bytes are swapped.\n-#[cfg(target_endian = \"big\")] #[inline] #[stable]\n-pub fn from_be64(x: u64) -> u64 { x }\n+#[inline]\n+#[deprecated = \"use `Int::from_be` instead\"]\n+pub fn from_be64(x: u64) -> u64 { Int::from_be(x) }\n \n-/**\n- * Swap the values at two mutable locations of the same type, without\n- * deinitialising or copying either one.\n- */\n+/// Swap the values at two mutable locations of the same type, without\n+/// deinitialising or copying either one.\n #[inline]\n #[stable]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n@@ -337,42 +273,40 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n     }\n }\n \n-/**\n- * Replace the value at a mutable location with a new one, returning the old\n- * value, without deinitialising or copying either one.\n- *\n- * This is primarily used for transferring and swapping ownership of a value\n- * in a mutable location. For example, this function allows consumption of\n- * one field of a struct by replacing it with another value. The normal approach\n- * doesn't always work:\n- *\n- * ```rust,ignore\n- * struct Buffer<T> { buf: Vec<T> }\n- *\n- * impl<T> Buffer<T> {\n- *     fn get_and_reset(&mut self) -> Vec<T> {\n- *         // error: cannot move out of dereference of `&mut`-pointer\n- *         let buf = self.buf;\n- *         self.buf = Vec::new();\n- *         buf\n- *     }\n- * }\n- * ```\n- *\n- * Note that `T` does not necessarily implement `Clone`, so it can't even\n- * clone and reset `self.buf`. But `replace` can be used to disassociate\n- * the original value of `self.buf` from `self`, allowing it to be returned:\n- *\n- * ```rust\n- * # struct Buffer<T> { buf: Vec<T> }\n- * impl<T> Buffer<T> {\n- *     fn get_and_reset(&mut self) -> Vec<T> {\n- *         use std::mem::replace;\n- *         replace(&mut self.buf, Vec::new())\n- *     }\n- * }\n- * ```\n- */\n+/// Replace the value at a mutable location with a new one, returning the old\n+/// value, without deinitialising or copying either one.\n+///\n+/// This is primarily used for transferring and swapping ownership of a value\n+/// in a mutable location. For example, this function allows consumption of\n+/// one field of a struct by replacing it with another value. The normal approach\n+/// doesn't always work:\n+///\n+/// ```rust,ignore\n+/// struct Buffer<T> { buf: Vec<T> }\n+///\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         // error: cannot move out of dereference of `&mut`-pointer\n+///         let buf = self.buf;\n+///         self.buf = Vec::new();\n+///         buf\n+///     }\n+/// }\n+/// ```\n+///\n+/// Note that `T` does not necessarily implement `Clone`, so it can't even\n+/// clone and reset `self.buf`. But `replace` can be used to disassociate\n+/// the original value of `self.buf` from `self`, allowing it to be returned:\n+///\n+/// ```rust\n+/// # struct Buffer<T> { buf: Vec<T> }\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         use std::mem::replace;\n+///         replace(&mut self.buf, Vec::new())\n+///     }\n+/// }\n+/// ```\n #[inline]\n #[stable]\n pub fn replace<T>(dest: &mut T, mut src: T) -> T {"}, {"sha": "79734324706b26e08dcffc1cb16bcdf061791763", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -35,7 +35,6 @@ mod tests {\n \n     use int;\n     use num;\n-    use num::Bitwise;\n     use num::CheckedDiv;\n \n     #[test]\n@@ -90,7 +89,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitwise() {\n+    fn test_bitwise_operators() {\n         assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n         assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n         assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n@@ -99,45 +98,74 @@ mod tests {\n         assert!(-(0b11 as $T) - (1 as $T) == (0b11 as $T).not());\n     }\n \n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n     #[test]\n     fn test_count_ones() {\n-        assert!((0b0101100 as $T).count_ones() == 3);\n-        assert!((0b0100001 as $T).count_ones() == 2);\n-        assert!((0b1111001 as $T).count_ones() == 5);\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n-        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n-        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n-        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n     }\n \n     #[test]\n     fn test_swap_bytes() {\n-        let n: $T = 0b0101100; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b0100001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b1111001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n \n         // Swapping these should make no difference\n-        let n: $T = 0;   assert_eq!(n.swap_bytes(), n);\n-        let n: $T = -1;  assert_eq!(n.swap_bytes(), n);\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n     }\n \n     #[test]\n-    fn test_rotate() {\n-        let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n-        let n: $T = 0b0100001; assert_eq!(n.rotate_left(3).rotate_left(2).rotate_right(5),  n);\n-        let n: $T = 0b1111001; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+    fn test_le() {\n+        assert_eq!(Int::from_le(A.to_le()), A);\n+        assert_eq!(Int::from_le(B.to_le()), B);\n+        assert_eq!(Int::from_le(C.to_le()), C);\n+        assert_eq!(Int::from_le(_0), _0);\n+        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!(_0.to_le(), _0);\n+        assert_eq!(_1.to_le(), _1);\n+    }\n \n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        let n: $T = 0;   assert_eq!(n.rotate_left(124), n);\n-        let n: $T = -1;  assert_eq!(n.rotate_left(124), n);\n-        let n: $T = 0;   assert_eq!(n.rotate_right(124), n);\n-        let n: $T = -1;  assert_eq!(n.rotate_right(124), n);\n+    #[test]\n+    fn test_be() {\n+        assert_eq!(Int::from_be(A.to_be()), A);\n+        assert_eq!(Int::from_be(B.to_be()), B);\n+        assert_eq!(Int::from_be(C.to_be()), C);\n+        assert_eq!(Int::from_be(_0), _0);\n+        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!(_0.to_be(), _0);\n+        assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]"}, {"sha": "573470c29bcf46af6cd25c4d4d3afed74c2c403f", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 194, "deletions": 118, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -376,217 +376,293 @@ bounded_impl!(i64, i64::MIN, i64::MAX)\n bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)\n \n-/// Numbers with a fixed binary representation.\n-pub trait Bitwise: Bounded\n-                 + Not<Self>\n-                 + BitAnd<Self,Self>\n-                 + BitOr<Self,Self>\n-                 + BitXor<Self,Self>\n-                 + Shl<Self,Self>\n-                 + Shr<Self,Self> {\n-    /// Returns the number of ones in the binary representation of the number.\n+/// Specifies the available operations common to all of Rust's core numeric primitives.\n+/// These may not always make sense from a purely mathematical point of view, but\n+/// may be useful for systems programming.\n+pub trait Primitive: Copy\n+                   + Clone\n+                   + Num\n+                   + NumCast\n+                   + PartialOrd\n+                   + Bounded {}\n+\n+trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+\n+/// A primitive signed or unsigned integer equipped with various bitwise\n+/// operators, bit counting methods, and endian conversion functions.\n+pub trait Int: Primitive\n+             + CheckedAdd\n+             + CheckedSub\n+             + CheckedMul\n+             + CheckedDiv\n+             + Bounded\n+             + Not<Self>\n+             + BitAnd<Self,Self>\n+             + BitOr<Self,Self>\n+             + BitXor<Self,Self>\n+             + Shl<Self,Self>\n+             + Shr<Self,Self> {\n+    /// Returns the number of ones in the binary representation of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b01001100u8;\n+    ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n-    fn count_ones(&self) -> Self;\n+    fn count_ones(self) -> Self;\n \n-    /// Returns the number of zeros in the binary representation of the number.\n+    /// Returns the number of zeros in the binary representation of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b01001100u8;\n+    ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n     #[inline]\n-    fn count_zeros(&self) -> Self {\n-        (!*self).count_ones()\n+    fn count_zeros(self) -> Self {\n+        (!self).count_ones()\n     }\n \n     /// Returns the number of leading zeros in the in the binary representation\n-    /// of the number.\n+    /// of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b0101000u16;\n+    ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n-    fn leading_zeros(&self) -> Self;\n+    fn leading_zeros(self) -> Self;\n \n     /// Returns the number of trailing zeros in the in the binary representation\n-    /// of the number.\n+    /// of the integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n-    ///\n     /// let n = 0b0101000u16;\n+    ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n-    fn trailing_zeros(&self) -> Self;\n+    fn trailing_zeros(self) -> Self;\n \n-    /// Reverses the byte order of a binary number.\n+    /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n+    /// the truncated bits to the end of the resulting integer.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0x3456789ABCDEF012u64;\n+    ///\n+    /// assert_eq!(n.rotate_left(12), m);\n+    /// ```\n+    fn rotate_left(self, n: uint) -> Self;\n+\n+    /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n+    /// the truncated bits to the beginning of the resulting integer.\n     ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let n = 0x0123456789ABCDEFu64;\n+    /// let m = 0xDEF0123456789ABCu64;\n+    ///\n+    /// assert_eq!(n.rotate_right(12), m);\n+    /// ```\n+    fn rotate_right(self, n: uint) -> Self;\n+\n+    /// Reverses the byte order of the integer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n     /// let n = 0x0123456789ABCDEFu64;\n     /// let m = 0xEFCDAB8967452301u64;\n+    ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n-    fn swap_bytes(&self) -> Self;\n+    fn swap_bytes(self) -> Self;\n \n-    /// Shifts the bits to the left by a specified amount amount, `r`, wrapping\n-    /// the truncated bits to the end of the resulting value.\n+    /// Convert a integer from big endian to the target's endianness.\n+    ///\n+    /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"big\") {\n+    ///     assert_eq!(Int::from_be(n), n)\n+    /// } else {\n+    ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn from_be(x: Self) -> Self {\n+        if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n+    }\n+\n+    /// Convert a integer from little endian to the target's endianness.\n+    ///\n+    /// On little endian this is a no-op. On big endian the bytes are swapped.\n     ///\n+    /// # Example\n+    ///\n+    /// ```rust\n     /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0x3456789ABCDEF012u64;\n-    /// assert_eq!(n.rotate_left(12), m);\n+    ///\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(Int::from_le(n), n)\n+    /// } else {\n+    ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n+    /// }\n     /// ```\n-    fn rotate_left(&self, r: uint) -> Self;\n+    #[inline]\n+    fn from_le(x: Self) -> Self {\n+        if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n+    }\n \n-    /// Shifts the bits to the right by a specified amount amount, `r`, wrapping\n-    /// the truncated bits to the beginning of the resulting value.\n+    /// Convert the integer to big endian from the target's endianness.\n+    ///\n+    /// On big endian this is a no-op. On little endian the bytes are swapped.\n     ///\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::num::Bitwise;\n+    /// let n = 0x0123456789ABCDEFu64;\n+    ///\n+    /// if cfg!(target_endian = \"big\") {\n+    ///     assert_eq!(n.to_be(), n)\n+    /// } else {\n+    ///     assert_eq!(n.to_be(), n.swap_bytes())\n+    /// }\n+    /// ```\n+    #[inline]\n+    fn to_be(self) -> Self { // or not to be?\n+        if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n+    }\n+\n+    /// Convert the integer to little endian from the target's endianness.\n     ///\n+    /// On little endian this is a no-op. On big endian the bytes are swapped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n     /// let n = 0x0123456789ABCDEFu64;\n-    /// let m = 0xDEF0123456789ABCu64;\n-    /// assert_eq!(n.rotate_right(12), m);\n+    ///\n+    /// if cfg!(target_endian = \"little\") {\n+    ///     assert_eq!(n.to_le(), n)\n+    /// } else {\n+    ///     assert_eq!(n.to_le(), n.swap_bytes())\n+    /// }\n     /// ```\n-    fn rotate_right(&self, r: uint) -> Self;\n+    #[inline]\n+    fn to_le(self) -> Self {\n+        if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n+    }\n }\n \n-/// Swapping a single byte does nothing. This is unsafe to be consistent with\n-/// the other `bswap` intrinsics.\n-#[inline]\n-unsafe fn bswap8(x: u8) -> u8 { x }\n-\n-macro_rules! bitwise_impl(\n-    ($t:ty, $bits:expr, $co:ident, $lz:ident, $tz:ident, $bs:path) => {\n-        impl Bitwise for $t {\n+macro_rules! int_impl {\n+    ($T:ty, $BITS:expr, $ctpop:path, $ctlz:path, $cttz:path, $bswap:path) => {\n+        impl Int for $T {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { intrinsics::$co(*self) } }\n+            fn count_ones(self) -> $T { unsafe { $ctpop(self) } }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { intrinsics::$lz(*self) } }\n+            fn leading_zeros(self) -> $T { unsafe { $ctlz(self) } }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { intrinsics::$tz(*self) } }\n+            fn trailing_zeros(self) -> $T { unsafe { $cttz(self) } }\n \n             #[inline]\n-            fn swap_bytes(&self) -> $t { unsafe { $bs(*self) } }\n+            fn rotate_left(self, n: uint) -> $T {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self << n) | (self >> ($BITS - n))\n+            }\n \n             #[inline]\n-            fn rotate_left(&self, r: uint) -> $t {\n-                // Protect against undefined behaviour for overlong bit shifts\n-                let r = r % $bits;\n-                (*self << r) | (*self >> ($bits - r))\n+            fn rotate_right(self, n: uint) -> $T {\n+                // Protect against undefined behaviour for over-long bit shifts\n+                let n = n % $BITS;\n+                (self >> n) | (self << ($BITS - n))\n             }\n \n             #[inline]\n-            fn rotate_right(&self, r: uint) -> $t {\n-                // Protect against undefined behaviour for overlong bit shifts\n-                let r = r % $bits;\n-                (*self >> r) | (*self << ($bits - r))\n-            }\n+            fn swap_bytes(self) -> $T { unsafe { $bswap(self) } }\n         }\n     }\n-)\n+}\n+\n+/// Swapping a single byte is a no-op. This is marked as `unsafe` for\n+/// consistency with the other `bswap` intrinsics.\n+unsafe fn bswap8(x: u8) -> u8 { x }\n+\n+int_impl!(u8, 8,\n+    intrinsics::ctpop8,\n+    intrinsics::ctlz8,\n+    intrinsics::cttz8,\n+    bswap8)\n+\n+int_impl!(u16, 16,\n+    intrinsics::ctpop16,\n+    intrinsics::ctlz16,\n+    intrinsics::cttz16,\n+    intrinsics::bswap16)\n+\n+int_impl!(u32, 32,\n+    intrinsics::ctpop32,\n+    intrinsics::ctlz32,\n+    intrinsics::cttz32,\n+    intrinsics::bswap32)\n \n-macro_rules! bitwise_cast_impl(\n-    ($t:ty, $t_cast:ty, $bits:expr,  $co:ident, $lz:ident, $tz:ident, $bs:path) => {\n-        impl Bitwise for $t {\n+int_impl!(u64, 64,\n+    intrinsics::ctpop64,\n+    intrinsics::ctlz64,\n+    intrinsics::cttz64,\n+    intrinsics::bswap64)\n+\n+macro_rules! int_cast_impl {\n+    ($T:ty, $U:ty) => {\n+        impl Int for $T {\n             #[inline]\n-            fn count_ones(&self) -> $t { unsafe { intrinsics::$co(*self as $t_cast) as $t } }\n+            fn count_ones(self) -> $T { (self as $U).count_ones() as $T }\n \n             #[inline]\n-            fn leading_zeros(&self) -> $t { unsafe { intrinsics::$lz(*self as $t_cast) as $t } }\n+            fn leading_zeros(self) -> $T { (self as $U).leading_zeros() as $T }\n \n             #[inline]\n-            fn trailing_zeros(&self) -> $t { unsafe { intrinsics::$tz(*self as $t_cast) as $t } }\n+            fn trailing_zeros(self) -> $T { (self as $U).trailing_zeros() as $T }\n \n             #[inline]\n-            fn swap_bytes(&self) -> $t { unsafe { $bs(*self as $t_cast) as $t } }\n+            fn rotate_left(self, n: uint) -> $T { (self as $U).rotate_left(n) as $T }\n \n             #[inline]\n-            fn rotate_left(&self, r: uint) -> $t {\n-                // cast to prevent the sign bit from being corrupted\n-                (*self as $t_cast).rotate_left(r) as $t\n-            }\n+            fn rotate_right(self, n: uint) -> $T { (self as $U).rotate_right(n) as $T }\n \n             #[inline]\n-            fn rotate_right(&self, r: uint) -> $t {\n-                // cast to prevent the sign bit from being corrupted\n-                (*self as $t_cast).rotate_right(r) as $t\n-            }\n+            fn swap_bytes(self) -> $T { (self as $U).swap_bytes() as $T }\n         }\n     }\n-)\n-\n-#[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(uint, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n-#[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(uint, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n-\n-bitwise_impl!(u8, 8, ctpop8, ctlz8, cttz8, bswap8)\n-bitwise_impl!(u16, 16, ctpop16, ctlz16, cttz16, intrinsics::bswap16)\n-bitwise_impl!(u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n-bitwise_impl!(u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n-\n-#[cfg(target_word_size = \"32\")]\n-bitwise_cast_impl!(int, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n-#[cfg(target_word_size = \"64\")]\n-bitwise_cast_impl!(int, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n-\n-bitwise_cast_impl!(i8, u8, 8, ctpop8, ctlz8, cttz8, bswap8)\n-bitwise_cast_impl!(i16, u16, 16, ctpop16, ctlz16, cttz16, intrinsics::bswap16)\n-bitwise_cast_impl!(i32, u32, 32, ctpop32, ctlz32, cttz32, intrinsics::bswap32)\n-bitwise_cast_impl!(i64, u64, 64, ctpop64, ctlz64, cttz64, intrinsics::bswap64)\n-\n-/// Specifies the available operations common to all of Rust's core numeric primitives.\n-/// These may not always make sense from a purely mathematical point of view, but\n-/// may be useful for systems programming.\n-pub trait Primitive: Copy\n-                   + Clone\n-                   + Num\n-                   + NumCast\n-                   + PartialOrd\n-                   + Bounded {}\n-\n-trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+}\n \n-/// A collection of traits relevant to primitive signed and unsigned integers\n-pub trait Int: Primitive\n-             + Bitwise\n-             + CheckedAdd\n-             + CheckedSub\n-             + CheckedMul\n-             + CheckedDiv {}\n+int_cast_impl!(i8, u8)\n+int_cast_impl!(i16, u16)\n+int_cast_impl!(i32, u32)\n+int_cast_impl!(i64, u64)\n \n-trait_impl!(Int for uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+#[cfg(target_word_size = \"32\")] int_cast_impl!(uint, u32)\n+#[cfg(target_word_size = \"64\")] int_cast_impl!(uint, u64)\n+#[cfg(target_word_size = \"32\")] int_cast_impl!(int, u32)\n+#[cfg(target_word_size = \"64\")] int_cast_impl!(int, u64)\n \n /// Returns the smallest power of 2 greater than or equal to `n`.\n #[inline]"}, {"sha": "be1f960bcc3dffc50a8e0e1028d6bb94c82822df", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 53, "deletions": 25, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -26,7 +26,6 @@ mod tests {\n \n     use num;\n     use num::CheckedDiv;\n-    use num::Bitwise;\n \n     #[test]\n     fn test_overflows() {\n@@ -41,7 +40,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bitwise() {\n+    fn test_bitwise_operators() {\n         assert!(0b1110 as $T == (0b1100 as $T).bitor(&(0b1010 as $T)));\n         assert!(0b1000 as $T == (0b1100 as $T).bitand(&(0b1010 as $T)));\n         assert!(0b0110 as $T == (0b1100 as $T).bitxor(&(0b1010 as $T)));\n@@ -50,45 +49,74 @@ mod tests {\n         assert!(MAX - (0b1011 as $T) == (0b1011 as $T).not());\n     }\n \n+    static A: $T = 0b0101100;\n+    static B: $T = 0b0100001;\n+    static C: $T = 0b1111001;\n+\n+    static _0: $T = 0;\n+    static _1: $T = !0;\n+\n     #[test]\n     fn test_count_ones() {\n-        assert!((0b0101100 as $T).count_ones() == 3);\n-        assert!((0b0100001 as $T).count_ones() == 2);\n-        assert!((0b1111001 as $T).count_ones() == 5);\n+        assert!(A.count_ones() == 3);\n+        assert!(B.count_ones() == 2);\n+        assert!(C.count_ones() == 5);\n     }\n \n     #[test]\n     fn test_count_zeros() {\n-        assert!((0b0101100 as $T).count_zeros() == BITS as $T - 3);\n-        assert!((0b0100001 as $T).count_zeros() == BITS as $T - 2);\n-        assert!((0b1111001 as $T).count_zeros() == BITS as $T - 5);\n+        assert!(A.count_zeros() == BITS as $T - 3);\n+        assert!(B.count_zeros() == BITS as $T - 2);\n+        assert!(C.count_zeros() == BITS as $T - 5);\n+    }\n+\n+    #[test]\n+    fn test_rotate() {\n+        assert_eq!(A.rotate_left(6).rotate_right(2).rotate_right(4), A);\n+        assert_eq!(B.rotate_left(3).rotate_left(2).rotate_right(5), B);\n+        assert_eq!(C.rotate_left(6).rotate_right(2).rotate_right(4), C);\n+\n+        // Rotating these should make no difference\n+        //\n+        // We test using 124 bits because to ensure that overlong bit shifts do\n+        // not cause undefined behaviour. See #10183.\n+        assert_eq!(_0.rotate_left(124), _0);\n+        assert_eq!(_1.rotate_left(124), _1);\n+        assert_eq!(_0.rotate_right(124), _0);\n+        assert_eq!(_1.rotate_right(124), _1);\n     }\n \n     #[test]\n     fn test_swap_bytes() {\n-        let n: $T = 0b0101100; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b0100001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n-        let n: $T = 0b1111001; assert_eq!(n.swap_bytes().swap_bytes(), n);\n+        assert_eq!(A.swap_bytes().swap_bytes(), A);\n+        assert_eq!(B.swap_bytes().swap_bytes(), B);\n+        assert_eq!(C.swap_bytes().swap_bytes(), C);\n \n         // Swapping these should make no difference\n-        let n: $T = 0;   assert_eq!(n.swap_bytes(), n);\n-        let n: $T = MAX; assert_eq!(n.swap_bytes(), n);\n+        assert_eq!(_0.swap_bytes(), _0);\n+        assert_eq!(_1.swap_bytes(), _1);\n     }\n \n     #[test]\n-    fn test_rotate() {\n-        let n: $T = 0b0101100; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n-        let n: $T = 0b0100001; assert_eq!(n.rotate_left(3).rotate_left(2).rotate_right(5),  n);\n-        let n: $T = 0b1111001; assert_eq!(n.rotate_left(6).rotate_right(2).rotate_right(4), n);\n+    fn test_le() {\n+        assert_eq!(Int::from_le(A.to_le()), A);\n+        assert_eq!(Int::from_le(B.to_le()), B);\n+        assert_eq!(Int::from_le(C.to_le()), C);\n+        assert_eq!(Int::from_le(_0), _0);\n+        assert_eq!(Int::from_le(_1), _1);\n+        assert_eq!(_0.to_le(), _0);\n+        assert_eq!(_1.to_le(), _1);\n+    }\n \n-        // Rotating these should make no difference\n-        //\n-        // We test using 124 bits because to ensure that overlong bit shifts do\n-        // not cause undefined behaviour. See #10183.\n-        let n: $T = 0;   assert_eq!(n.rotate_left(124), n);\n-        let n: $T = MAX; assert_eq!(n.rotate_left(124), n);\n-        let n: $T = 0;   assert_eq!(n.rotate_right(124), n);\n-        let n: $T = MAX; assert_eq!(n.rotate_right(124), n);\n+    #[test]\n+    fn test_be() {\n+        assert_eq!(Int::from_be(A.to_be()), A);\n+        assert_eq!(Int::from_be(B.to_be()), B);\n+        assert_eq!(Int::from_be(C.to_be()), C);\n+        assert_eq!(Int::from_be(_0), _0);\n+        assert_eq!(Int::from_be(_1), _1);\n+        assert_eq!(_0.to_be(), _0);\n+        assert_eq!(_1.to_be(), _1);\n     }\n \n     #[test]"}, {"sha": "4744d92436f2b75829dde916f5e8b7a52c6ce20d", "filename": "src/libdebug/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibdebug%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibdebug%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibdebug%2Frepr.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -75,13 +75,13 @@ macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n         let s = self.to_str();\n         writer.write(s.as_bytes()).and_then(|()| {\n-            writer.write(bytes!($suffix))\n+            writer.write($suffix)\n         })\n     }\n }))\n \n-num_repr!(f32, \"f32\")\n-num_repr!(f64, \"f64\")\n+num_repr!(f32, b\"f32\")\n+num_repr!(f64, b\"f64\")\n \n // New implementation using reflect::MovePtr\n "}, {"sha": "ee25d19e324cc8e474ff5ff21057325113e5a326", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -159,16 +159,19 @@\n //!\n //! # Using a scheduler pool\n //!\n+//! This library adds a `GreenTaskBuilder` trait that extends the methods\n+//! available on `std::task::TaskBuilder` to allow spawning a green task,\n+//! possibly pinned to a particular scheduler thread:\n+//!\n //! ```rust\n-//! use std::rt::task::TaskOpts;\n-//! use green::{SchedPool, PoolConfig};\n-//! use green::sched::{PinnedTask, TaskFromFriend};\n+//! use std::task::TaskBuilder;\n+//! use green::{SchedPool, PoolConfig, GreenTaskBuilder};\n //!\n //! let config = PoolConfig::new();\n //! let mut pool = SchedPool::new(config);\n //!\n //! // Spawn tasks into the pool of schedulers\n-//! pool.spawn(TaskOpts::new(), proc() {\n+//! TaskBuilder::new().green(&mut pool).spawn(proc() {\n //!     // this code is running inside the pool of schedulers\n //!\n //!     spawn(proc() {\n@@ -181,12 +184,9 @@\n //! let mut handle = pool.spawn_sched();\n //!\n //! // Pin a task to the spawned scheduler\n-//! let task = pool.task(TaskOpts::new(), proc() { /* ... */ });\n-//! handle.send(PinnedTask(task));\n-//!\n-//! // Schedule a task on this new scheduler\n-//! let task = pool.task(TaskOpts::new(), proc() { /* ... */ });\n-//! handle.send(TaskFromFriend(task));\n+//! TaskBuilder::new().green_pinned(&mut pool, &mut handle).spawn(proc() {\n+//!     /* ... */\n+//! });\n //!\n //! // Handles keep schedulers alive, so be sure to drop all handles before\n //! // destroying the sched pool\n@@ -209,6 +209,8 @@\n // NB this does *not* include globs, please keep it that way.\n #![feature(macro_rules, phase)]\n #![allow(visible_private_types)]\n+#![allow(deprecated)]\n+#![feature(default_type_params)]\n \n #[cfg(test)] #[phase(plugin, link)] extern crate log;\n #[cfg(test)] extern crate rustuv;\n@@ -224,8 +226,9 @@ use std::rt::task::TaskOpts;\n use std::rt;\n use std::sync::atomics::{SeqCst, AtomicUint, INIT_ATOMIC_UINT};\n use std::sync::deque;\n+use std::task::{TaskBuilder, Spawner};\n \n-use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, NewNeighbor};\n+use sched::{Shutdown, Scheduler, SchedHandle, TaskFromFriend, PinnedTask, NewNeighbor};\n use sleeper_list::SleeperList;\n use stack::StackPool;\n use task::GreenTask;\n@@ -444,6 +447,7 @@ impl SchedPool {\n     /// This is useful to create a task which can then be sent to a specific\n     /// scheduler created by `spawn_sched` (and possibly pin it to that\n     /// scheduler).\n+    #[deprecated = \"use the green and green_pinned methods of GreenTaskBuilder instead\"]\n     pub fn task(&mut self, opts: TaskOpts, f: proc():Send) -> Box<GreenTask> {\n         GreenTask::configure(&mut self.stack_pool, opts, f)\n     }\n@@ -454,6 +458,7 @@ impl SchedPool {\n     /// New tasks are spawned in a round-robin fashion to the schedulers in this\n     /// pool, but tasks can certainly migrate among schedulers once they're in\n     /// the pool.\n+    #[deprecated = \"use the green and green_pinned methods of GreenTaskBuilder instead\"]\n     pub fn spawn(&mut self, opts: TaskOpts, f: proc():Send) {\n         let task = self.task(opts, f);\n \n@@ -563,3 +568,54 @@ impl Drop for SchedPool {\n         }\n     }\n }\n+\n+/// A spawner for green tasks\n+pub struct GreenSpawner<'a>{\n+    pool: &'a mut SchedPool,\n+    handle: Option<&'a mut SchedHandle>\n+}\n+\n+impl<'a> Spawner for GreenSpawner<'a> {\n+    #[inline]\n+    fn spawn(self, opts: TaskOpts, f: proc():Send) {\n+        let GreenSpawner { pool, handle } = self;\n+        match handle {\n+            None    => pool.spawn(opts, f),\n+            Some(h) => h.send(PinnedTask(pool.task(opts, f)))\n+        }\n+    }\n+}\n+\n+/// An extension trait adding `green` configuration methods to `TaskBuilder`.\n+pub trait GreenTaskBuilder {\n+    fn green<'a>(self, &'a mut SchedPool) -> TaskBuilder<GreenSpawner<'a>>;\n+    fn green_pinned<'a>(self, &'a mut SchedPool, &'a mut SchedHandle)\n+                        -> TaskBuilder<GreenSpawner<'a>>;\n+}\n+\n+impl<S: Spawner> GreenTaskBuilder for TaskBuilder<S> {\n+    fn green<'a>(self, pool: &'a mut SchedPool) -> TaskBuilder<GreenSpawner<'a>> {\n+        self.spawner(GreenSpawner {pool: pool, handle: None})\n+    }\n+\n+    fn green_pinned<'a>(self, pool: &'a mut SchedPool, handle: &'a mut SchedHandle)\n+                        -> TaskBuilder<GreenSpawner<'a>> {\n+        self.spawner(GreenSpawner {pool: pool, handle: Some(handle)})\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use std::task::TaskBuilder;\n+    use super::{SchedPool, PoolConfig, GreenTaskBuilder};\n+\n+    #[test]\n+    fn test_green_builder() {\n+        let mut pool = SchedPool::new(PoolConfig::new());\n+        let res = TaskBuilder::new().green(&mut pool).try(proc() {\n+            \"Success!\".to_string()\n+        });\n+        assert_eq!(res.ok().unwrap(), \"Success!\".to_string());\n+        pool.shutdown();\n+    }\n+}"}, {"sha": "edf2becc777608584821035107beb20f7f764454", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -360,7 +360,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n         }).map(|path| root.join(path).to_c_str()).collect()\n     }\n \n@@ -529,7 +529,7 @@ mod tests {\n         let mut reader = FileDesc::new(reader, true);\n         let mut writer = FileDesc::new(writer, true);\n \n-        writer.inner_write(bytes!(\"test\")).ok().unwrap();\n+        writer.inner_write(b\"test\").ok().unwrap();\n         let mut buf = [0u8, ..4];\n         match reader.inner_read(buf) {\n             Ok(4) => {\n@@ -552,7 +552,7 @@ mod tests {\n             assert!(!f.is_null());\n             let mut file = CFile::new(f);\n \n-            file.write(bytes!(\"test\")).ok().unwrap();\n+            file.write(b\"test\").ok().unwrap();\n             let mut buf = [0u8, ..4];\n             let _ = file.seek(0, SeekSet).ok().unwrap();\n             match file.read(buf) {"}, {"sha": "cd9abc70a4ee8cd09690be4ff6a45d276021e39a", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -351,7 +351,7 @@ pub fn readdir(p: &CString) -> IoResult<Vec<CString>> {\n         let root = Path::new(root);\n \n         dirs.move_iter().filter(|path| {\n-            path.as_vec() != bytes!(\".\") && path.as_vec() != bytes!(\"..\")\n+            path.as_vec() != b\".\" && path.as_vec() != b\"..\"\n         }).map(|path| root.join(path).to_c_str()).collect()\n     }\n "}, {"sha": "5dfae8d9efe649b5221b176dad416371c3504952", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -27,10 +27,10 @@ use super::util;\n #[cfg(unix)]    pub type sock_t = super::file::fd_t;\n \n pub fn htons(u: u16) -> u16 {\n-    mem::to_be16(u)\n+    u.to_be()\n }\n pub fn ntohs(u: u16) -> u16 {\n-    mem::from_be16(u)\n+    Int::from_be(u)\n }\n \n enum InAddr {\n@@ -46,7 +46,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n                      (c as u32 <<  8) |\n                      (d as u32 <<  0);\n             InAddr(libc::in_addr {\n-                s_addr: mem::from_be32(ip)\n+                s_addr: Int::from_be(ip)\n             })\n         }\n         rtio::Ipv6Addr(a, b, c, d, e, f, g, h) => {\n@@ -180,7 +180,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let storage: &libc::sockaddr_in = unsafe {\n                 mem::transmute(storage)\n             };\n-            let ip = mem::to_be32(storage.sin_addr.s_addr as u32);\n+            let ip = (storage.sin_addr.s_addr as u32).to_be();\n             let a = (ip >> 24) as u8;\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;"}, {"sha": "40b99c5bbdb1d0bb08d4d948cf5c46e1024a959e", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -32,10 +32,13 @@\n //! ```rust\n //! extern crate native;\n //!\n+//! use std::task::TaskBuilder;\n+//! use native::NativeTaskBuilder;\n+//!\n //! fn main() {\n //!     // We're not sure whether this main function is run in 1:1 or M:N mode.\n //!\n-//!     native::task::spawn(proc() {\n+//!     TaskBuilder::new().native().spawn(proc() {\n //!         // this code is guaranteed to be run on a native thread\n //!     });\n //! }\n@@ -50,7 +53,8 @@\n        html_root_url = \"http://doc.rust-lang.org/\")]\n #![deny(unused_result, unused_must_use)]\n #![allow(non_camel_case_types)]\n-#![feature(macro_rules)]\n+#![allow(deprecated)]\n+#![feature(default_type_params)]\n \n // NB this crate explicitly does *not* allow glob imports, please seriously\n //    consider whether they're needed before adding that feature here (the\n@@ -65,6 +69,8 @@ use std::os;\n use std::rt;\n use std::str;\n \n+pub use task::NativeTaskBuilder;\n+\n pub mod io;\n pub mod task;\n "}, {"sha": "88e581a47913674ae1e926e3c0a001a562f30e45", "filename": "src/libnative/task.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -27,6 +27,7 @@ use std::rt;\n \n use io;\n use task;\n+use std::task::{TaskBuilder, Spawner};\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n pub fn new(stack_bounds: (uint, uint)) -> Box<Task> {\n@@ -48,12 +49,14 @@ fn ops() -> Box<Ops> {\n }\n \n /// Spawns a function with the default configuration\n+#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n pub fn spawn(f: proc():Send) {\n     spawn_opts(TaskOpts { name: None, stack_size: None, on_exit: None }, f)\n }\n \n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n+#[deprecated = \"use the native method of NativeTaskBuilder instead\"]\n pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     let TaskOpts { name, stack_size, on_exit } = opts;\n \n@@ -95,6 +98,26 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n     })\n }\n \n+/// A spawner for native tasks\n+pub struct NativeSpawner;\n+\n+impl Spawner for NativeSpawner {\n+    fn spawn(self, opts: TaskOpts, f: proc():Send) {\n+        spawn_opts(opts, f)\n+    }\n+}\n+\n+/// An extension trait adding a `native` configuration method to `TaskBuilder`.\n+pub trait NativeTaskBuilder {\n+    fn native(self) -> TaskBuilder<NativeSpawner>;\n+}\n+\n+impl<S: Spawner> NativeTaskBuilder for TaskBuilder<S> {\n+    fn native(self) -> TaskBuilder<NativeSpawner> {\n+        self.spawner(NativeSpawner)\n+    }\n+}\n+\n // This structure is the glue between channels and the 1:1 scheduling mode. This\n // structure is allocated once per task.\n struct Ops {\n@@ -259,7 +282,8 @@ mod tests {\n     use std::rt::local::Local;\n     use std::rt::task::{Task, TaskOpts};\n     use std::task;\n-    use super::{spawn, spawn_opts, Ops};\n+    use std::task::TaskBuilder;\n+    use super::{spawn, spawn_opts, Ops, NativeTaskBuilder};\n \n     #[test]\n     fn smoke() {\n@@ -347,4 +371,12 @@ mod tests {\n         });\n         rx.recv();\n     }\n+\n+    #[test]\n+    fn test_native_builder() {\n+        let res = TaskBuilder::new().native().try(proc() {\n+            \"Success!\".to_string()\n+        });\n+        assert_eq!(res.ok().unwrap(), \"Success!\".to_string());\n+    }\n }"}, {"sha": "e9153f89e04ee8d12aad9b6c5e6a00e161b3a9b7", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -23,7 +23,7 @@ use std::{cmp, fmt};\n use std::default::Default;\n use std::from_str::FromStr;\n use std::num::CheckedDiv;\n-use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n+use std::num::{ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use std::string::String;\n use std::{uint, i64, u64};"}, {"sha": "048e44cd55d78098ee98da8dfebaf3ee1ab05fcd", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -292,9 +292,9 @@ pub struct AsciiGenerator<'a, R> {\n impl<'a, R: Rng> Iterator<char> for AsciiGenerator<'a, R> {\n     fn next(&mut self) -> Option<char> {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] =\n-            bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n-                    abcdefghijklmnopqrstuvwxyz\\\n-                    0123456789\");\n+            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+              abcdefghijklmnopqrstuvwxyz\\\n+              0123456789\";\n         Some(*self.rng.choose(GEN_ASCII_STR_CHARSET).unwrap() as char)\n     }\n }"}, {"sha": "f55fd78762c5dbaa093a1e5efc3af153846c79b5", "filename": "src/librustc/driver/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fmod.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -366,22 +366,19 @@ fn monitor(f: proc():Send) {\n     #[cfg(not(rtopt))]\n     static STACK_SIZE: uint = 20000000; // 20MB\n \n-    let mut task_builder = TaskBuilder::new().named(\"rustc\");\n+    let (tx, rx) = channel();\n+    let w = io::ChanWriter::new(tx);\n+    let mut r = io::ChanReader::new(rx);\n+\n+    let mut task = TaskBuilder::new().named(\"rustc\").stderr(box w);\n \n     // FIXME: Hacks on hacks. If the env is trying to override the stack size\n     // then *don't* set it explicitly.\n     if os::getenv(\"RUST_MIN_STACK\").is_none() {\n-        task_builder.opts.stack_size = Some(STACK_SIZE);\n+        task = task.stack_size(STACK_SIZE);\n     }\n \n-    let (tx, rx) = channel();\n-    let w = io::ChanWriter::new(tx);\n-    let mut r = io::ChanReader::new(rx);\n-\n-    match task_builder.try(proc() {\n-        io::stdio::set_stderr(box w);\n-        f()\n-    }) {\n+    match task.try(f) {\n         Ok(()) => { /* fallthrough */ }\n         Err(value) => {\n             // Task failed without emitting a fatal diagnostic"}, {"sha": "c15148f75df2242b9c5915ac113f1ac5d14ec811", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -214,7 +214,7 @@ pub fn rust_path() -> Vec<Path> {\n         env_rust_path.push(cwd.clone());\n     }\n     loop {\n-        if { let f = cwd.filename(); f.is_none() || f.unwrap() == bytes!(\"..\") } {\n+        if { let f = cwd.filename(); f.is_none() || f.unwrap() == b\"..\" } {\n             break\n         }\n         cwd.set_filename(\".rust\");"}, {"sha": "b61596908e60a5f93ea3307e463e44bd7fe42e98", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -25,6 +25,7 @@ use middle::dataflow::DataFlowContext;\n use middle::dataflow::BitwiseOperator;\n use middle::dataflow::DataFlowOperator;\n use euv = middle::expr_use_visitor;\n+use mc = middle::mem_categorization;\n use middle::ty;\n use syntax::ast;\n use syntax::ast_util;\n@@ -160,6 +161,22 @@ pub struct AssignDataFlowOperator;\n \n pub type AssignDataFlow<'a> = DataFlowContext<'a, AssignDataFlowOperator>;\n \n+fn loan_path_is_precise(loan_path: &LoanPath) -> bool {\n+    match *loan_path {\n+        LpVar(_) | LpUpvar(_) => {\n+            true\n+        }\n+        LpExtend(_, _, LpInterior(mc::InteriorElement(_))) => {\n+            // Paths involving element accesses do not refer to a unique\n+            // location, as there is no accurate tracking of the indices.\n+            false\n+        }\n+        LpExtend(ref lp_base, _, _) => {\n+            loan_path_is_precise(&**lp_base)\n+        }\n+    }\n+}\n+\n impl MoveData {\n     pub fn new() -> MoveData {\n         MoveData {\n@@ -500,10 +517,17 @@ impl MoveData {\n                   path: MovePathIndex,\n                   kill_id: ast::NodeId,\n                   dfcx_moves: &mut MoveDataFlow) {\n-        self.each_applicable_move(path, |move_index| {\n-            dfcx_moves.add_kill(kill_id, move_index.get());\n-            true\n-        });\n+        // We can only perform kills for paths that refer to a unique location,\n+        // since otherwise we may kill a move from one location with an\n+        // assignment referring to another location.\n+\n+        let loan_path = self.path_loan_path(path);\n+        if loan_path_is_precise(&*loan_path) {\n+            self.each_applicable_move(path, |move_index| {\n+                dfcx_moves.add_kill(kill_id, move_index.get());\n+                true\n+            });\n+        }\n     }\n }\n "}, {"sha": "8cd840582ba999d13ac96e350562ba79be6a214e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -701,17 +701,12 @@ impl<'a> Liveness<'a> {\n                 if self.loop_scope.len() == 0 {\n                     self.ir.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n-                    // FIXME(#5275): this shouldn't have to be a method...\n-                    self.last_loop_scope()\n+                    *self.loop_scope.last().unwrap()\n                 }\n             }\n         }\n     }\n \n-    fn last_loop_scope(&self) -> NodeId {\n-        *self.loop_scope.last().unwrap()\n-    }\n-\n     #[allow(unused_must_use)]\n     fn ln_str(&self, ln: LiveNode) -> String {\n         let mut wr = io::MemWriter::new();"}, {"sha": "ffd29ffeb8fb42797b013d5430aea9bc402d6226", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 12, "deletions": 42, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -518,8 +518,7 @@ fn enter_default<'a, 'b>(\n                  dm: &DefMap,\n                  m: &'a [Match<'a, 'b>],\n                  col: uint,\n-                 val: ValueRef,\n-                 chk: &FailureHandler)\n+                 val: ValueRef)\n                  -> Vec<Match<'a, 'b>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n@@ -529,35 +528,13 @@ fn enter_default<'a, 'b>(\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    let matches = enter_match(bcx, dm, m, col, val, |p| {\n+    enter_match(bcx, dm, m, col, val, |p| {\n         match p.node {\n           ast::PatWild | ast::PatWildMulti => Some(Vec::new()),\n           ast::PatIdent(_, _, None) if pat_is_binding(dm, &*p) => Some(Vec::new()),\n           _ => None\n         }\n-    });\n-\n-    // Ok, now, this is pretty subtle. A \"default\" match is a match\n-    // that needs to be considered if none of the actual checks on the\n-    // value being considered succeed. The subtlety lies in that sometimes\n-    // identifier/wildcard matches are *not* default matches. Consider:\n-    // \"match x { _ if something => foo, true => bar, false => baz }\".\n-    // There is a wildcard match, but it is *not* a default case. The boolean\n-    // case on the value being considered is exhaustive. If the case is\n-    // exhaustive, then there are no defaults.\n-    //\n-    // We detect whether the case is exhaustive in the following\n-    // somewhat kludgy way: if the last wildcard/binding match has a\n-    // guard, then by non-redundancy, we know that there aren't any\n-    // non guarded matches, and thus by exhaustiveness, we know that\n-    // we don't need any default cases. If the check *isn't* nonexhaustive\n-    // (because chk is Some), then we need the defaults anyways.\n-    let is_exhaustive = match matches.last() {\n-        Some(m) if m.data.arm.guard.is_some() && chk.is_infallible() => true,\n-        _ => false\n-    };\n-\n-    if is_exhaustive { Vec::new() } else { matches }\n+    })\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n@@ -1448,15 +1425,12 @@ fn compile_submatch<'a, 'b>(\n            m.repr(bcx.tcx()),\n            vec_map_to_str(vals, |v| bcx.val_to_str(*v)));\n     let _indenter = indenter();\n-\n-    /*\n-      For an empty match, a fall-through case must exist\n-     */\n-    assert!((m.len() > 0u || chk.is_fallible()));\n     let _icx = push_ctxt(\"match::compile_submatch\");\n     let mut bcx = bcx;\n     if m.len() == 0u {\n-        Br(bcx, chk.handle_fail());\n+        if chk.is_fallible() {\n+            Br(bcx, chk.handle_fail());\n+        }\n         return;\n     }\n     if m[0].pats.len() == 0u {\n@@ -1658,7 +1632,7 @@ fn compile_submatch_continue<'a, 'b>(\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n-    let defaults = enter_default(else_cx, dm, m, col, val, chk);\n+    let defaults = enter_default(else_cx, dm, m, col, val);\n     let exhaustive = chk.is_infallible() && defaults.len() == 0u;\n     let len = opts.len();\n \n@@ -1947,18 +1921,14 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n \n     // `compile_submatch` works one column of arm patterns a time and\n     // then peels that column off. So as we progress, it may become\n-    // impossible to know whether we have a genuine default arm, i.e.\n+    // impossible to tell whether we have a genuine default arm, i.e.\n     // `_ => foo` or not. Sometimes it is important to know that in order\n     // to decide whether moving on to the next condition or falling back\n     // to the default arm.\n-    let has_default = arms.len() > 0 && {\n-        let ref pats = arms.last().unwrap().pats;\n-\n-        pats.len() == 1\n-        && match pats.last().unwrap().node {\n-            ast::PatWild => true, _ => false\n-        }\n-    };\n+    let has_default = arms.last().map_or(false, |arm| {\n+        arm.pats.len() == 1\n+        && arm.pats.last().unwrap().node == ast::PatWild\n+    });\n \n     compile_submatch(bcx, matches.as_slice(), [discr_datum.val], &chk, has_default);\n "}, {"sha": "e4b28dc7aa7c2607272577259f702b870d1826fe", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -46,7 +46,6 @@\n #![allow(unsigned_negate)]\n \n use libc::c_ulonglong;\n-use std::num::{Bitwise};\n use std::rc::Rc;\n \n use lib::llvm::{ValueRef, True, IntEQ, IntNE};"}, {"sha": "783fdfa4aaec911145cb432fbb8c4fae5f278f74", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1411,7 +1411,7 @@ fn compile_unit_metadata(cx: &CrateContext) {\n                 match abs_path.path_relative_from(work_dir) {\n                     Some(ref p) if p.is_relative() => {\n                             // prepend \"./\" if necessary\n-                            let dotdot = bytes!(\"..\");\n+                            let dotdot = b\"..\";\n                             let prefix = &[dotdot[0], ::std::path::SEP_BYTE];\n                             let mut path_bytes = Vec::from_slice(p.as_vec());\n "}, {"sha": "599b45aafe20d1a488532372cf33fbf47292dc45", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1463,7 +1463,7 @@ fn trans_overloaded_call<'a>(\n     // Evaluate and tuple the arguments.\n     let tuple_type = ty::mk_tup(bcx.tcx(),\n                                 args.iter()\n-                                    .map(|e| expr_ty(bcx, &**e))\n+                                    .map(|e| ty::expr_ty_adjusted(bcx.tcx(), &**e))\n                                     .collect());\n     let repr = adt::represent_type(bcx.ccx(), tuple_type);\n     let numbered_fields: Vec<(uint, Gc<ast::Expr>)> ="}, {"sha": "0304a1d690ef5ef620a9b7842073fad19cc722d5", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -63,7 +63,7 @@ r##\"<!DOCTYPE html>\n             <div class=\"search-container\">\n                 <input class=\"search-input\" name=\"search\"\n                        autocomplete=\"off\"\n-                       placeholder=\"Search documentation...\"\n+                       placeholder=\"Click or press 's' to search, '?' for more options...\"\n                        type=\"search\">\n             </div>\n         </form>"}, {"sha": "76e604ecfa287569dc0adfc75d23a3860c6695ae", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -602,7 +602,7 @@ fn mkdir(path: &Path) -> io::IoResult<()> {\n // FIXME (#9639): The closure should deal with &[u8] instead of &str\n fn clean_srcpath(src: &[u8], f: |&str|) {\n     let p = Path::new(src);\n-    if p.as_vec() != bytes!(\".\") {\n+    if p.as_vec() != b\".\" {\n         for c in p.str_components().map(|x|x.unwrap()) {\n             if \"..\" == c {\n                 f(\"up\");\n@@ -714,7 +714,7 @@ impl<'a> SourceCollector<'a> {\n         });\n \n         cur.push(Vec::from_slice(p.filename().expect(\"source has no filename\"))\n-                 .append(bytes!(\".html\")));\n+                 .append(b\".html\"));\n         let mut w = BufferedWriter::new(try!(File::create(&cur)));\n \n         let title = format!(\"{} -- source\", cur.filename_display());"}, {"sha": "09ae2b31f6368d2c16d7bdc9d82cb148d98daf4c", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -123,8 +123,8 @@ mod imp {\n             let saved_value = take();\n \n             let expected = vec![\n-                Vec::from_slice(bytes!(\"happy\")),\n-                Vec::from_slice(bytes!(\"today?\")),\n+                Vec::from_slice(b\"happy\"),\n+                Vec::from_slice(b\"today?\"),\n             ];\n \n             put(expected.clone());"}, {"sha": "4a7ac97beed8d6f1060add48110e87b6a37ac58d", "filename": "src/librustrt/c_str.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustrt%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustrt%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fc_str.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -463,7 +463,7 @@ mod tests {\n     #[test]\n     fn test_str_multistring_parsing() {\n         unsafe {\n-            let input = bytes!(\"zero\", \"\\x00\", \"one\", \"\\x00\", \"\\x00\");\n+            let input = b\"zero\\0one\\0\\0\";\n             let ptr = input.as_ptr();\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n@@ -505,7 +505,7 @@ mod tests {\n             }\n         });\n \n-        let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n+        let _ = b\"hello\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n@@ -516,7 +516,7 @@ mod tests {\n             }\n         });\n \n-        let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n+        let _ = b\"foo\\xFF\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*buf.offset(0), 'f' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'o' as libc::c_char);\n@@ -595,22 +595,22 @@ mod tests {\n     #[test]\n     fn test_as_bytes() {\n         let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(\"hello\", 0));\n+        assert_eq!(c_str.as_bytes(), b\"hello\\0\");\n         let c_str = \"\".to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(0));\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n-        assert_eq!(c_str.as_bytes(), bytes!(\"foo\", 0xff, 0));\n+        assert_eq!(c_str.as_bytes(), b\"\\0\");\n+        let c_str = b\"foo\\xFF\".to_c_str();\n+        assert_eq!(c_str.as_bytes(), b\"foo\\xFF\\0\");\n     }\n \n     #[test]\n     fn test_as_bytes_no_nul() {\n         let c_str = \"hello\".to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), bytes!(\"hello\"));\n+        assert_eq!(c_str.as_bytes_no_nul(), b\"hello\");\n         let c_str = \"\".to_c_str();\n         let exp: &[u8] = [];\n         assert_eq!(c_str.as_bytes_no_nul(), exp);\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n-        assert_eq!(c_str.as_bytes_no_nul(), bytes!(\"foo\", 0xff));\n+        let c_str = b\"foo\\xFF\".to_c_str();\n+        assert_eq!(c_str.as_bytes_no_nul(), b\"foo\\xFF\");\n     }\n \n     #[test]\n@@ -633,7 +633,7 @@ mod tests {\n         assert_eq!(c_str.as_str(), Some(\"hello\"));\n         let c_str = \"\".to_c_str();\n         assert_eq!(c_str.as_str(), Some(\"\"));\n-        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n+        let c_str = b\"foo\\xFF\".to_c_str();\n         assert_eq!(c_str.as_str(), None);\n     }\n "}, {"sha": "82693acb1e9dc9573698ad23540aec33b5ec76e1", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -30,8 +30,8 @@ use uvll;\n /// Generic functions related to dealing with sockaddr things\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub fn htons(u: u16) -> u16 { mem::to_be16(u) }\n-pub fn ntohs(u: u16) -> u16 { mem::from_be16(u) }\n+pub fn htons(u: u16) -> u16 { u.to_be() }\n+pub fn ntohs(u: u16) -> u16 { Int::from_be(u) }\n \n pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n                         len: uint) -> rtio::SocketAddr {\n@@ -41,7 +41,7 @@ pub fn sockaddr_to_addr(storage: &libc::sockaddr_storage,\n             let storage: &libc::sockaddr_in = unsafe {\n                 mem::transmute(storage)\n             };\n-            let ip = mem::to_be32(storage.sin_addr.s_addr as u32);\n+            let ip = (storage.sin_addr.s_addr as u32).to_be();\n             let a = (ip >> 24) as u8;\n             let b = (ip >> 16) as u8;\n             let c = (ip >>  8) as u8;\n@@ -89,7 +89,8 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr) -> (libc::sockaddr_storage, uint) {\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n                 (*storage).sin_addr = libc::in_addr {\n-                    s_addr: mem::from_be32(ip)\n+                    s_addr: Int::from_be(ip),\n+\n                 };\n                 mem::size_of::<libc::sockaddr_in>()\n             }"}, {"sha": "5c4da38989f11316b8a1ad2820b500528773b78b", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -42,13 +42,13 @@ pub static URL_SAFE: Config =\n pub static MIME: Config =\n     Config {char_set: Standard, pad: true, line_length: Some(76)};\n \n-static STANDARD_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n-                                             \"abcdefghijklmnopqrstuvwxyz\",\n-                                             \"0123456789+/\");\n+static STANDARD_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                        abcdefghijklmnopqrstuvwxyz\\\n+                                        0123456789+/\";\n \n-static URLSAFE_CHARS: &'static[u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n-                                            \"abcdefghijklmnopqrstuvwxyz\",\n-                                            \"0123456789-_\");\n+static URLSAFE_CHARS: &'static[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n+                                       abcdefghijklmnopqrstuvwxyz\\\n+                                       0123456789-_\";\n \n /// A trait for converting a value to base64 encoding.\n pub trait ToBase64 {\n@@ -193,7 +193,7 @@ impl<'a> FromBase64 for &'a str {\n      * use serialize::base64::{ToBase64, FromBase64, STANDARD};\n      *\n      * fn main () {\n-     *     let hello_str = bytes!(\"Hello, World\").to_base64(STANDARD);\n+     *     let hello_str = b\"Hello, World\".to_base64(STANDARD);\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.as_slice().from_base64();\n      *     if res.is_ok() {"}, {"sha": "12c5a3493c17bcd1091f4f8fff583eb8f18ae508", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -154,8 +154,6 @@ pub mod reader {\n     }\n \n     pub fn vuint_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n-        use std::mem::from_be32;\n-\n         if data.len() - start < 4 {\n             return vuint_at_slow(data, start);\n         }\n@@ -185,7 +183,7 @@ pub mod reader {\n \n         unsafe {\n             let ptr = data.as_ptr().offset(start as int) as *u32;\n-            let val = from_be32(*ptr);\n+            let val = Int::from_be(*ptr);\n \n             let i = (val >> 28u) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];"}, {"sha": "44d0606185345be24ff6eea88a2fd849ec48c85e", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -19,7 +19,7 @@ pub trait ToHex {\n     fn to_hex(&self) -> String;\n }\n \n-static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n+static CHARS: &'static[u8] = b\"0123456789abcdef\";\n \n impl<'a> ToHex for &'a [u8] {\n     /**"}, {"sha": "4f355502eb88d3a9d5b742f2e91942722bbc5cdc", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -535,7 +535,7 @@ mod test {\n \n     #[test]\n     fn test_read_line() {\n-        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n+        let in_buf = MemReader::new(Vec::from_slice(b\"a\\nb\\nc\"));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         assert_eq!(reader.read_line(), Ok(\"a\\n\".to_string()));\n         assert_eq!(reader.read_line(), Ok(\"b\\n\".to_string()));\n@@ -545,7 +545,7 @@ mod test {\n \n     #[test]\n     fn test_lines() {\n-        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n+        let in_buf = MemReader::new(Vec::from_slice(b\"a\\nb\\nc\"));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(\"a\\n\".to_string())));"}, {"sha": "a801dd0e7cb35cd39cf7966862ad3185859c1960", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -35,7 +35,7 @@ let path = Path::new(\"foo.txt\");\n \n // create the file, whether it exists or not\n let mut file = File::create(&path);\n-file.write(bytes!(\"foobar\"));\n+file.write(b\"foobar\");\n # drop(file);\n \n // open the file in read-only mode\n@@ -186,7 +186,7 @@ impl File {\n     /// use std::io::File;\n     ///\n     /// let mut f = File::create(&Path::new(\"foo.txt\"));\n-    /// f.write(bytes!(\"This is a sample file\"));\n+    /// f.write(b\"This is a sample file\");\n     /// # drop(f);\n     /// # ::std::io::fs::unlink(&Path::new(\"foo.txt\"));\n     /// ```\n@@ -1141,7 +1141,7 @@ mod test {\n     iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n-        check!(File::create(file).write(bytes!(\"foo\")));\n+        check!(File::create(file).write(b\"foo\"));\n         assert!(file.exists());\n         check!(unlink(file));\n         assert!(!file.exists());\n@@ -1253,7 +1253,7 @@ mod test {\n         let canary = d2.join(\"do_not_delete\");\n         check!(mkdir_recursive(&dtt, io::UserRWX));\n         check!(mkdir_recursive(&d2, io::UserRWX));\n-        check!(File::create(&canary).write(bytes!(\"foo\")));\n+        check!(File::create(&canary).write(b\"foo\"));\n         check!(symlink(&d2, &dt.join(\"d2\")));\n         check!(rmdir_recursive(&d1));\n \n@@ -1314,10 +1314,10 @@ mod test {\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n \n-        check!(File::create(&input).write(bytes!(\"hello\")));\n+        check!(File::create(&input).write(b\"hello\"));\n         check!(copy(&input, &out));\n         let contents = check!(File::open(&out).read_to_end());\n-        assert_eq!(contents.as_slice(), bytes!(\"hello\"));\n+        assert_eq!(contents.as_slice(), b\"hello\");\n \n         assert_eq!(check!(input.stat()).perm, check!(out.stat()).perm);\n     })\n@@ -1342,7 +1342,7 @@ mod test {\n         check!(copy(&input, &output));\n \n         assert_eq!(check!(File::open(&output).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foo\"))));\n+                   (Vec::from_slice(b\"foo\")));\n     })\n \n     iotest!(fn copy_file_src_dir() {\n@@ -1383,7 +1383,7 @@ mod test {\n         }\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foobar\"))));\n+                   (Vec::from_slice(b\"foobar\")));\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n@@ -1418,7 +1418,7 @@ mod test {\n         assert_eq!(check!(stat(&out)).size, check!(stat(&input)).size);\n         assert_eq!(check!(stat(&out)).size, check!(input.stat()).size);\n         assert_eq!(check!(File::open(&out).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foobar\"))));\n+                   (Vec::from_slice(b\"foobar\")));\n \n         // can't link to yourself\n         match link(&input, &input) {\n@@ -1456,7 +1456,7 @@ mod test {\n         let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n         check!(file.fsync());\n         check!(file.datasync());\n-        check!(file.write(bytes!(\"foo\")));\n+        check!(file.write(b\"foo\"));\n         check!(file.fsync());\n         check!(file.datasync());\n         drop(file);\n@@ -1467,29 +1467,29 @@ mod test {\n         let path = tmpdir.join(\"in.txt\");\n \n         let mut file = check!(File::open_mode(&path, io::Open, io::ReadWrite));\n-        check!(file.write(bytes!(\"foo\")));\n+        check!(file.write(b\"foo\"));\n         check!(file.fsync());\n \n         // Do some simple things with truncation\n         assert_eq!(check!(file.stat()).size, 3);\n         check!(file.truncate(10));\n         assert_eq!(check!(file.stat()).size, 10);\n-        check!(file.write(bytes!(\"bar\")));\n+        check!(file.write(b\"bar\"));\n         check!(file.fsync());\n         assert_eq!(check!(file.stat()).size, 10);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"foobar\", 0, 0, 0, 0))));\n+                   (Vec::from_slice(b\"foobar\\0\\0\\0\\0\")));\n \n         // Truncate to a smaller length, don't seek, and then write something.\n         // Ensure that the intermediate zeroes are all filled in (we're seeked\n         // past the end of the file).\n         check!(file.truncate(2));\n         assert_eq!(check!(file.stat()).size, 2);\n-        check!(file.write(bytes!(\"wut\")));\n+        check!(file.write(b\"wut\"));\n         check!(file.fsync());\n         assert_eq!(check!(file.stat()).size, 9);\n         assert_eq!(check!(File::open(&path).read_to_end()),\n-                   (Vec::from_slice(bytes!(\"fo\", 0, 0, 0, 0, \"wut\"))));\n+                   (Vec::from_slice(b\"fo\\0\\0\\0\\0wut\")));\n         drop(file);\n     })\n "}, {"sha": "5eca5361835e36e7295f5d5f66f6ffde1df300c8", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -474,7 +474,7 @@ mod test {\n \n     #[test]\n     fn test_read_char() {\n-        let b = bytes!(\"Vi\u1ec7t\");\n+        let b = b\"Vi\\xE1\\xBB\\x87t\";\n         let mut r = BufReader::new(b);\n         assert_eq!(r.read_char(), Ok('V'));\n         assert_eq!(r.read_char(), Ok('i'));\n@@ -485,7 +485,7 @@ mod test {\n \n     #[test]\n     fn test_read_bad_char() {\n-        let b = bytes!(0x80);\n+        let b = b\"\\x80\";\n         let mut r = BufReader::new(b);\n         assert!(r.read_char().is_err());\n     }"}, {"sha": "d9755cdce1a4fbf1099fac36b541f4fef3f9ca57", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -50,7 +50,7 @@ Some examples of obvious things you might want to do\n     use std::io::File;\n \n     let mut file = File::create(&Path::new(\"message.txt\"));\n-    file.write(bytes!(\"hello, file!\\n\"));\n+    file.write(b\"hello, file!\\n\");\n     # drop(file);\n     # ::std::io::fs::unlink(&Path::new(\"message.txt\"));\n     ```\n@@ -90,7 +90,7 @@ Some examples of obvious things you might want to do\n     # // just stop it running (#11576)\n     # if false {\n     let mut socket = TcpStream::connect(\"127.0.0.1\", 8080).unwrap();\n-    socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));\n+    socket.write(b\"GET / HTTP/1.0\\n\\n\");\n     let response = socket.read_to_end();\n     # }\n     ```\n@@ -151,7 +151,7 @@ while still providing feedback about errors. The basic strategy:\n   to be 'unwrapped' before use.\n \n These features combine in the API to allow for expressions like\n-`File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\"))`\n+`File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\")`\n without having to worry about whether \"diary.txt\" exists or whether\n the write succeeds. As written, if either `new` or `write_line`\n encounters an error then the result of the entire expression will\n@@ -163,7 +163,7 @@ If you wanted to handle the error though you might write:\n # #![allow(unused_must_use)]\n use std::io::File;\n \n-match File::create(&Path::new(\"diary.txt\")).write(bytes!(\"Met a girl.\\n\")) {\n+match File::create(&Path::new(\"diary.txt\")).write(b\"Met a girl.\\n\") {\n     Ok(()) => (), // succeeded\n     Err(e) => println!(\"failed to write to my diary: {}\", e),\n }\n@@ -1839,55 +1839,55 @@ mod tests {\n \n     #[test]\n     fn test_read_at_least() {\n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([GoodBehavior(uint::MAX)]));\n         let mut buf = [0u8, ..5];\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_exact(5).unwrap().len() == 5); // read_exact uses read_at_least\n         assert!(r.read_at_least(0, buf).is_ok());\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n                                                     BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n         assert!(r.read_at_least(1, buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(uint::MAX)]));\n         assert_eq!(r.read_at_least(1, buf).unwrap_err().kind, NoProgress);\n \n-        let mut r = MemReader::new(Vec::from_slice(bytes!(\"hello, world!\")));\n+        let mut r = MemReader::new(Vec::from_slice(b\"hello, world!\"));\n         assert_eq!(r.read_at_least(5, buf).unwrap(), 5);\n         assert_eq!(r.read_at_least(6, buf).unwrap_err().kind, InvalidInput);\n     }\n \n     #[test]\n     fn test_push_at_least() {\n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([GoodBehavior(uint::MAX)]));\n         let mut buf = Vec::new();\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(0, 5, &mut buf).is_ok());\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(1), GoodBehavior(1),\n                                                     BadBehavior(50), GoodBehavior(uint::MAX)]));\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n         assert!(r.push_at_least(1, 5, &mut buf).unwrap() >= 1);\n \n-        let mut r = BadReader::new(MemReader::new(Vec::from_slice(bytes!(\"hello, world!\"))),\n+        let mut r = BadReader::new(MemReader::new(Vec::from_slice(b\"hello, world!\")),\n                                    Vec::from_slice([BadBehavior(uint::MAX)]));\n         assert_eq!(r.push_at_least(1, 5, &mut buf).unwrap_err().kind, NoProgress);\n \n-        let mut r = MemReader::new(Vec::from_slice(bytes!(\"hello, world!\")));\n+        let mut r = MemReader::new(Vec::from_slice(b\"hello, world!\"));\n         assert_eq!(r.push_at_least(5, 1, &mut buf).unwrap_err().kind, InvalidInput);\n     }\n }"}, {"sha": "a968f41a91563ce9c7d7a66bf7a551fa9db94f13", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -52,7 +52,7 @@ impl PipeStream {\n     ///\n     /// fn main() {\n     ///     let mut pipe = PipeStream::open(libc::STDERR_FILENO);\n-    ///     pipe.write(bytes!(\"Hello, stderr!\"));\n+    ///     pipe.write(b\"Hello, stderr!\");\n     /// }\n     /// ```\n     pub fn open(fd: libc::c_int) -> IoResult<PipeStream> {"}, {"sha": "e5a64f785ce9640643911ef9c55fb8a76f44b77c", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -22,7 +22,7 @@ about the stream or terminal to which it is attached.\n use std::io;\n \n let mut out = io::stdout();\n-out.write(bytes!(\"Hello, world!\"));\n+out.write(b\"Hello, world!\");\n ```\n \n */"}, {"sha": "7301f9b08e9dcef30ede009c9db3b77d84adec98", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -22,7 +22,7 @@ use string::String;\n \n pub use core::num::{Num, div_rem, Zero, zero, One, one};\n pub use core::num::{Signed, abs, abs_sub, signum};\n-pub use core::num::{Unsigned, pow, Bounded, Bitwise};\n+pub use core::num::{Unsigned, pow, Bounded};\n pub use core::num::{Primitive, Int, Saturating};\n pub use core::num::{CheckedAdd, CheckedSub, CheckedMul, CheckedDiv};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};"}, {"sha": "e55dc165895164a5d07dd29f7137d1c82d878a37", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -219,7 +219,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 let dot = '.' as u8;\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => name,\n-                    Some(1) if name == bytes!(\"..\") => name,\n+                    Some(1) if name == b\"..\" => name,\n                     Some(pos) => name.slice_to(pos)\n                 }\n             })\n@@ -242,7 +242,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 let dot = '.' as u8;\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n-                    Some(1) if name == bytes!(\"..\") => None,\n+                    Some(1) if name == b\"..\" => None,\n                     Some(pos) => Some(name.slice_from(pos+1))\n                 }\n             }"}, {"sha": "d98cfb7d8eece0c35396db2b1a5dd2cb48614a6e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 128, "deletions": 137, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -142,7 +142,7 @@ impl GenericPathUnsafe for Path {\n     unsafe fn set_filename_unchecked<T: BytesContainer>(&mut self, filename: T) {\n         let filename = filename.container_as_bytes();\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr.as_slice() => {\n+            None if b\"..\" == self.repr.as_slice() => {\n                 let mut v = Vec::with_capacity(3 + filename.len());\n                 v.push_all(dot_dot_static);\n                 v.push(SEP_BYTE);\n@@ -153,7 +153,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -202,34 +202,34 @@ impl GenericPath for Path {\n \n     fn dirname<'a>(&'a self) -> &'a [u8] {\n         match self.sepidx {\n-            None if bytes!(\"..\") == self.repr.as_slice() => self.repr.as_slice(),\n+            None if b\"..\" == self.repr.as_slice() => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => self.repr.slice_to(1),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => self.repr.as_slice(),\n             Some(idx) => self.repr.slice_to(idx)\n         }\n     }\n \n     fn filename<'a>(&'a self) -> Option<&'a [u8]> {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr.as_slice() ||\n-                bytes!(\"..\") == self.repr.as_slice() => None,\n+            None if b\".\" == self.repr.as_slice() ||\n+                b\"..\" == self.repr.as_slice() => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => None,\n+            Some(idx) if self.repr.slice_from(idx+1) == b\"..\" => None,\n             Some(0) if self.repr.slice_from(1).is_empty() => None,\n             Some(idx) => Some(self.repr.slice_from(idx+1))\n         }\n     }\n \n     fn pop(&mut self) -> bool {\n         match self.sepidx {\n-            None if bytes!(\".\") == self.repr.as_slice() => false,\n+            None if b\".\" == self.repr.as_slice() => false,\n             None => {\n                 self.repr = vec!['.' as u8];\n                 self.sepidx = None;\n                 true\n             }\n-            Some(0) if bytes!(\"/\") == self.repr.as_slice() => false,\n+            Some(0) if b\"/\" == self.repr.as_slice() => false,\n             Some(idx) => {\n                 if idx == 0 {\n                     self.repr.truncate(idx+1);\n@@ -261,19 +261,19 @@ impl GenericPath for Path {\n         } else {\n             let mut ita = self.components();\n             let mut itb = other.components();\n-            if bytes!(\".\") == self.repr.as_slice() {\n+            if b\".\" == self.repr.as_slice() {\n                 return match itb.next() {\n                     None => true,\n-                    Some(b) => b != bytes!(\"..\")\n+                    Some(b) => b != b\"..\"\n                 };\n             }\n             loop {\n                 match (ita.next(), itb.next()) {\n                     (None, _) => break,\n                     (Some(a), Some(b)) if a == b => { continue },\n-                    (Some(a), _) if a == bytes!(\"..\") => {\n+                    (Some(a), _) if a == b\"..\" => {\n                         // if ita contains only .. components, it's an ancestor\n-                        return ita.all(|x| x == bytes!(\"..\"));\n+                        return ita.all(|x| x == b\"..\");\n                     }\n                     _ => return false\n                 }\n@@ -303,8 +303,8 @@ impl GenericPath for Path {\n                     }\n                     (None, _) => comps.push(dot_dot_static),\n                     (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                    (Some(a), Some(b)) if b == bytes!(\".\") => comps.push(a),\n-                    (Some(_), Some(b)) if b == bytes!(\"..\") => return None,\n+                    (Some(a), Some(b)) if b == b\".\" => comps.push(a),\n+                    (Some(_), Some(b)) if b == b\"..\" => return None,\n                     (Some(a), Some(_)) => {\n                         comps.push(dot_dot_static);\n                         for _ in itb {\n@@ -425,16 +425,16 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     let mut changed = false;\n     for comp in v.split(is_sep_byte) {\n         if comp.is_empty() { changed = true }\n-        else if comp == bytes!(\".\") { changed = true }\n-        else if comp == bytes!(\"..\") {\n+        else if comp == b\".\" { changed = true }\n+        else if comp == b\"..\" {\n             if is_abs && comps.is_empty() { changed = true }\n             else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n             else { comps.pop().unwrap(); changed = true }\n         } else { comps.push(comp) }\n     }\n     if changed {\n         if comps.is_empty() && !is_abs {\n-            if v == bytes!(\".\") {\n+            if v == b\".\" {\n                 return None;\n             }\n             comps.push(dot_static);\n@@ -445,8 +445,8 @@ fn normalize_helper<'a>(v: &'a [u8], is_abs: bool) -> Option<Vec<&'a [u8]>> {\n     }\n }\n \n-static dot_static: &'static [u8] = bytes!(\".\");\n-static dot_dot_static: &'static [u8] = bytes!(\"..\");\n+static dot_static: &'static [u8] = b\".\";\n+static dot_dot_static: &'static [u8] = b\"..\";\n \n #[cfg(test)]\n mod tests {\n@@ -470,24 +470,15 @@ mod tests {\n         )\n     )\n \n-    macro_rules! b(\n-        ($($arg:expr),+) => (\n-            {\n-                static the_bytes: &'static [u8] = bytes!($($arg),+);\n-                the_bytes\n-            }\n-        )\n-    )\n-\n     #[test]\n     fn test_paths() {\n         let empty: &[u8] = [];\n-        t!(v: Path::new(empty), b!(\".\"));\n-        t!(v: Path::new(b!(\"/\")), b!(\"/\"));\n-        t!(v: Path::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n-        t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n-        t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n-        let p = Path::new(b!(\"a/b/c\", 0xff));\n+        t!(v: Path::new(empty), b\".\");\n+        t!(v: Path::new(b\"/\"), b\"/\");\n+        t!(v: Path::new(b\"a/b/c\"), b\"a/b/c\");\n+        t!(v: Path::new(b\"a/b/c\\xFF\"), b\"a/b/c\\xFF\");\n+        t!(v: Path::new(b\"\\xFF/../foo\\x80\"), b\"foo\\x80\");\n+        let p = Path::new(b\"a/b/c\\xFF\");\n         assert!(p.as_str() == None);\n \n         t!(s: Path::new(\"\"), \".\");\n@@ -513,18 +504,18 @@ mod tests {\n         t!(s: Path::new(\"foo/../../..\"), \"../..\");\n         t!(s: Path::new(\"foo/../../bar\"), \"../bar\");\n \n-        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec().as_slice(), b!(\"foo/bar\"));\n-        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec().as_slice(),\n-                   b!(\"/bar\"));\n+        assert_eq!(Path::new(b\"foo/bar\").into_vec().as_slice(), b\"foo/bar\");\n+        assert_eq!(Path::new(b\"/foo/../../bar\").into_vec().as_slice(),\n+                   b\"/bar\");\n \n-        let p = Path::new(b!(\"foo/bar\", 0x80));\n+        let p = Path::new(b\"foo/bar\\x80\");\n         assert!(p.as_str() == None);\n     }\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b!(\"foo/bar\", 0)) == None);\n-        t!(v: Path::new_opt(b!(\"foo/bar\")).unwrap(), b!(\"foo/bar\"));\n+        assert!(Path::new_opt(b\"foo/bar\\0\") == None);\n+        t!(v: Path::new_opt(b\"foo/bar\").unwrap(), b\"foo/bar\");\n         assert!(Path::new_opt(\"foo/bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo/bar\").unwrap(), \"foo/bar\");\n     }\n@@ -533,17 +524,17 @@ mod tests {\n     fn test_null_byte() {\n         use task;\n         let result = task::try(proc() {\n-            Path::new(b!(\"foo/bar\", 0))\n+            Path::new(b\"foo/bar\\0\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").set_filename(b!(\"f\", 0, \"o\"))\n+            Path::new(\"test\").set_filename(b\"f\\0o\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").push(b!(\"f\", 0, \"o\"));\n+            Path::new(\"test\").push(b\"f\\0o\");\n         });\n         assert!(result.is_err());\n     }\n@@ -559,11 +550,11 @@ mod tests {\n             )\n         )\n         t!(\"foo\", display, \"foo\");\n-        t!(b!(\"foo\", 0x80), display, \"foo\\uFFFD\");\n-        t!(b!(\"foo\", 0xff, \"bar\"), display, \"foo\\uFFFDbar\");\n-        t!(b!(\"foo\", 0xff, \"/bar\"), filename_display, \"bar\");\n-        t!(b!(\"foo/\", 0xff, \"bar\"), filename_display, \"\\uFFFDbar\");\n-        t!(b!(\"/\"), filename_display, \"\");\n+        t!(b\"foo\\x80\", display, \"foo\\uFFFD\");\n+        t!(b\"foo\\xFFbar\", display, \"foo\\uFFFDbar\");\n+        t!(b\"foo\\xFF/bar\", filename_display, \"bar\");\n+        t!(b\"foo/\\xFFbar\", filename_display, \"\\uFFFDbar\");\n+        t!(b\"/\", filename_display, \"\");\n \n         macro_rules! t(\n             ($path:expr, $exp:expr) => (\n@@ -583,11 +574,11 @@ mod tests {\n         )\n \n         t!(\"foo\", \"foo\");\n-        t!(b!(\"foo\", 0x80), \"foo\\uFFFD\");\n-        t!(b!(\"foo\", 0xff, \"bar\"), \"foo\\uFFFDbar\");\n-        t!(b!(\"foo\", 0xff, \"/bar\"), \"bar\", filename);\n-        t!(b!(\"foo/\", 0xff, \"bar\"), \"\\uFFFDbar\", filename);\n-        t!(b!(\"/\"), \"\", filename);\n+        t!(b\"foo\\x80\", \"foo\\uFFFD\");\n+        t!(b\"foo\\xFFbar\", \"foo\\uFFFDbar\");\n+        t!(b\"foo\\xFF/bar\", \"bar\", filename);\n+        t!(b\"foo/\\xFFbar\", \"\\uFFFDbar\", filename);\n+        t!(b\"/\", \"\", filename);\n     }\n \n     #[test]\n@@ -604,13 +595,13 @@ mod tests {\n             )\n         )\n \n-        t!(b!(\"foo\"), \"foo\", \"foo\");\n-        t!(b!(\"foo/bar\"), \"foo/bar\", \"bar\");\n-        t!(b!(\"/\"), \"/\", \"\");\n-        t!(b!(\"foo\", 0xff), \"foo\\uFFFD\", \"foo\\uFFFD\");\n-        t!(b!(\"foo\", 0xff, \"/bar\"), \"foo\\uFFFD/bar\", \"bar\");\n-        t!(b!(\"foo/\", 0xff, \"bar\"), \"foo/\\uFFFDbar\", \"\\uFFFDbar\");\n-        t!(b!(0xff, \"foo/bar\", 0xff), \"\\uFFFDfoo/bar\\uFFFD\", \"bar\\uFFFD\");\n+        t!(b\"foo\", \"foo\", \"foo\");\n+        t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n+        t!(b\"/\", \"/\", \"\");\n+        t!(b\"foo\\xFF\", \"foo\\uFFFD\", \"foo\\uFFFD\");\n+        t!(b\"foo\\xFF/bar\", \"foo\\uFFFD/bar\", \"bar\");\n+        t!(b\"foo/\\xFFbar\", \"foo/\\uFFFDbar\", \"\\uFFFDbar\");\n+        t!(b\"\\xFFfoo/bar\\xFF\", \"\\uFFFDfoo/bar\\uFFFD\", \"bar\\uFFFD\");\n     }\n \n     #[test]\n@@ -638,9 +629,9 @@ mod tests {\n             );\n         )\n \n-        t!(v: b!(\"a/b/c\"), filename, Some(b!(\"c\")));\n-        t!(v: b!(\"a/b/c\", 0xff), filename, Some(b!(\"c\", 0xff)));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), filename, Some(b!(\"c\")));\n+        t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n+        t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n+        t!(v: b\"a/b\\xFF/c\", filename, Some(b\"c\"));\n         t!(s: \"a/b/c\", filename, Some(\"c\"), opt);\n         t!(s: \"/a/b/c\", filename, Some(\"c\"), opt);\n         t!(s: \"a\", filename, Some(\"a\"), opt);\n@@ -650,9 +641,9 @@ mod tests {\n         t!(s: \"..\", filename, None, opt);\n         t!(s: \"../..\", filename, None, opt);\n \n-        t!(v: b!(\"a/b/c\"), dirname, b!(\"a/b\"));\n-        t!(v: b!(\"a/b/c\", 0xff), dirname, b!(\"a/b\"));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), dirname, b!(\"a/b\", 0xff));\n+        t!(v: b\"a/b/c\", dirname, b\"a/b\");\n+        t!(v: b\"a/b/c\\xFF\", dirname, b\"a/b\");\n+        t!(v: b\"a/b\\xFF/c\", dirname, b\"a/b\\xFF\");\n         t!(s: \"a/b/c\", dirname, \"a/b\");\n         t!(s: \"/a/b/c\", dirname, \"/a/b\");\n         t!(s: \"a\", dirname, \".\");\n@@ -662,9 +653,9 @@ mod tests {\n         t!(s: \"..\", dirname, \"..\");\n         t!(s: \"../..\", dirname, \"../..\");\n \n-        t!(v: b!(\"hi/there.txt\"), filestem, Some(b!(\"there\")));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), filestem, Some(b!(\"there\", 0x80)));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), filestem, Some(b!(\"there\")));\n+        t!(v: b\"hi/there.txt\", filestem, Some(b\"there\"));\n+        t!(v: b\"hi/there\\x80.txt\", filestem, Some(b\"there\\x80\"));\n+        t!(v: b\"hi/there.t\\x80xt\", filestem, Some(b\"there\"));\n         t!(s: \"hi/there.txt\", filestem, Some(\"there\"), opt);\n         t!(s: \"hi/there\", filestem, Some(\"there\"), opt);\n         t!(s: \"there.txt\", filestem, Some(\"there\"), opt);\n@@ -678,11 +669,11 @@ mod tests {\n         t!(s: \"..\", filestem, None, opt);\n         t!(s: \"../..\", filestem, None, opt);\n \n-        t!(v: b!(\"hi/there.txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), extension, Some(b!(\"t\", 0x80, \"xt\")));\n-        t!(v: b!(\"hi/there\"), extension, None);\n-        t!(v: b!(\"hi/there\", 0x80), extension, None);\n+        t!(v: b\"hi/there.txt\", extension, Some(b\"txt\"));\n+        t!(v: b\"hi/there\\x80.txt\", extension, Some(b\"txt\"));\n+        t!(v: b\"hi/there.t\\x80xt\", extension, Some(b\"t\\x80xt\"));\n+        t!(v: b\"hi/there\", extension, None);\n+        t!(v: b\"hi/there\\x80\", extension, None);\n         t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n         t!(s: \"hi/there\", extension, None, opt);\n         t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n@@ -762,9 +753,9 @@ mod tests {\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"/e\"), b!(\"f\")], b!(\"/e/f\"));\n-        t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n+        t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n+        t!(v: b\"a/b/c\", [b\"d\", b\"/e\", b\"f\"], b\"/e/f\");\n+        t!(v: b\"a/b/c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n@@ -778,25 +769,25 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             );\n-            (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n+            (b: $path:expr, $left:expr, $right:expr) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert!(p.as_vec() == b!($($left),+));\n+                    assert!(p.as_vec() == $left);\n                     assert!(result == $right);\n                 }\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [\"a/b\"], true);\n-        t!(v: [\"a\"], [\".\"], true);\n-        t!(v: [\".\"], [\".\"], false);\n-        t!(v: [\"/a\"], [\"/\"], true);\n-        t!(v: [\"/\"], [\"/\"], false);\n-        t!(v: [\"a/b/c\", 0x80], [\"a/b\"], true);\n-        t!(v: [\"a/b\", 0x80, \"/c\"], [\"a/b\", 0x80], true);\n-        t!(v: [0xff], [\".\"], true);\n-        t!(v: [\"/\", 0xff], [\"/\"], true);\n+        t!(b: b\"a/b/c\", b\"a/b\", true);\n+        t!(b: b\"a\", b\".\", true);\n+        t!(b: b\".\", b\".\", false);\n+        t!(b: b\"/a\", b\"/\", true);\n+        t!(b: b\"/\", b\"/\", false);\n+        t!(b: b\"a/b/c\\x80\", b\"a/b\", true);\n+        t!(b: b\"a/b\\x80/c\", b\"a/b\\x80\", true);\n+        t!(b: b\"\\xFF\", b\".\", true);\n+        t!(b: b\"/\\xFF\", b\"/\", true);\n         t!(s: \"a/b/c\", \"a/b\", true);\n         t!(s: \"a\", \".\", true);\n         t!(s: \".\", \".\", false);\n@@ -806,15 +797,15 @@ mod tests {\n \n     #[test]\n     fn test_root_path() {\n-        assert!(Path::new(b!(\"a/b/c\")).root_path() == None);\n-        assert!(Path::new(b!(\"/a/b/c\")).root_path() == Some(Path::new(\"/\")));\n+        assert!(Path::new(b\"a/b/c\").root_path() == None);\n+        assert!(Path::new(b\"/a/b/c\").root_path() == Some(Path::new(\"/\")));\n     }\n \n     #[test]\n     fn test_join() {\n-        t!(v: Path::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n-        t!(v: Path::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n-        t!(v: Path::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n+        t!(v: Path::new(b\"a/b/c\").join(b\"..\"), b\"a/b\");\n+        t!(v: Path::new(b\"/a/b/c\").join(b\"d\"), b\"/a/b/c/d\");\n+        t!(v: Path::new(b\"a/\\x80/c\").join(b\"\\xFF\"), b\"a/\\x80/c/\\xFF\");\n         t!(s: Path::new(\"a/b/c\").join(\"..\"), \"a/b\");\n         t!(s: Path::new(\"/a/b/c\").join(\"d\"), \"/a/b/c/d\");\n         t!(s: Path::new(\"a/b\").join(\"c/d\"), \"a/b/c/d\");\n@@ -867,18 +858,18 @@ mod tests {\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\", \"f\"], \"/e/f\");\n         t!(s: \"a/b/c\", [\"d\".to_string(), \"e\".to_string()], \"a/b/c/d/e\");\n-        t!(v: b!(\"a/b/c\"), [b!(\"d\"), b!(\"e\")], b!(\"a/b/c/d/e\"));\n-        t!(v: b!(\"a/b/c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))], b!(\"a/b/c/d/e\"));\n+        t!(v: b\"a/b/c\", [b\"d\", b\"e\"], b\"a/b/c/d/e\");\n+        t!(v: b\"a/b/c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")], b\"a/b/c/d/e\");\n     }\n \n     #[test]\n     fn test_with_helpers() {\n         let empty: &[u8] = [];\n \n-        t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n-        t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n-        t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n-              b!(\"/\", 0xff, \"/\", 0xcd));\n+        t!(v: Path::new(b\"a/b/c\").with_filename(b\"d\"), b\"a/b/d\");\n+        t!(v: Path::new(b\"a/b/c\\xFF\").with_filename(b\"\\x80\"), b\"a/b/\\x80\");\n+        t!(v: Path::new(b\"/\\xFF/foo\").with_filename(b\"\\xCD\"),\n+              b\"/\\xFF/\\xCD\");\n         t!(s: Path::new(\"a/b/c\").with_filename(\"d\"), \"a/b/d\");\n         t!(s: Path::new(\".\").with_filename(\"foo\"), \"foo\");\n         t!(s: Path::new(\"/a/b/c\").with_filename(\"d\"), \"/a/b/d\");\n@@ -899,13 +890,13 @@ mod tests {\n         t!(s: Path::new(\"..\").with_filename(\"\"), \"..\");\n         t!(s: Path::new(\"../..\").with_filename(\"\"), \"../..\");\n \n-        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n-              b!(\"hi/there\", 0x80, \".exe\"));\n-        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n-              b!(\"hi/there.\", 0xff));\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n-              b!(\"hi/there\", 0x80, \".\", 0xff));\n-        t!(v: Path::new(b!(\"hi/there.\", 0xff)).with_extension(empty), b!(\"hi/there\"));\n+        t!(v: Path::new(b\"hi/there\\x80.txt\").with_extension(b\"exe\"),\n+              b\"hi/there\\x80.exe\");\n+        t!(v: Path::new(b\"hi/there.txt\\x80\").with_extension(b\"\\xFF\"),\n+              b\"hi/there.\\xFF\");\n+        t!(v: Path::new(b\"hi/there\\x80\").with_extension(b\"\\xFF\"),\n+              b\"hi/there\\x80.\\xFF\");\n+        t!(v: Path::new(b\"hi/there.\\xFF\").with_extension(empty), b\"hi/there\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\"exe\"), \"hi/there.exe\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\"\"), \"hi/there\");\n         t!(s: Path::new(\"hi/there.txt\").with_extension(\".\"), \"hi/there..\");\n@@ -947,17 +938,17 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a/b/c\"), set_filename, with_filename, b!(\"d\"));\n-        t!(v: b!(\"/\"), set_filename, with_filename, b!(\"foo\"));\n-        t!(v: b!(0x80), set_filename, with_filename, b!(0xff));\n+        t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n+        t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n+        t!(v: b\"\\x80\", set_filename, with_filename, b\"\\xFF\");\n         t!(s: \"a/b/c\", set_filename, with_filename, \"d\");\n         t!(s: \"/\", set_filename, with_filename, \"foo\");\n         t!(s: \".\", set_filename, with_filename, \"foo\");\n         t!(s: \"a/b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b!(\"hi/there.txt\"), set_extension, with_extension, b!(\"exe\"));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), set_extension, with_extension, b!(\"exe\", 0xff));\n+        t!(v: b\"hi/there.txt\", set_extension, with_extension, b\"exe\");\n+        t!(v: b\"hi/there.t\\x80xt\", set_extension, with_extension, b\"exe\\xFF\");\n         t!(s: \"hi/there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi/there.\", set_extension, with_extension, \"txt\");\n         t!(s: \"hi/there\", set_extension, with_extension, \"txt\");\n@@ -1001,10 +992,10 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"a/b/c\")), Some(b!(\"c\")), b!(\"a/b\"), Some(b!(\"c\")), None);\n-        t!(v: Path::new(b!(\"a/b/\", 0xff)), Some(b!(0xff)), b!(\"a/b\"), Some(b!(0xff)), None);\n-        t!(v: Path::new(b!(\"hi/there.\", 0xff)), Some(b!(\"there.\", 0xff)), b!(\"hi\"),\n-              Some(b!(\"there\")), Some(b!(0xff)));\n+        t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n+        t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n+        t!(v: Path::new(b\"hi/there.\\xFF\"), Some(b\"there.\\xFF\"), b\"hi\",\n+              Some(b\"there\"), Some(b\"\\xFF\"));\n         t!(s: Path::new(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n         t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n         t!(s: Path::new(\"/\"), None, Some(\"/\"), None, None);\n@@ -1018,16 +1009,16 @@ mod tests {\n         t!(s: Path::new(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n         t!(s: Path::new(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n               Some(\".\"), Some(\"there\"));\n-        t!(s: Path::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n-        t!(s: Path::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: Path::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: Path::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n+        t!(s: Path::new(b\"a/b/\\xFF\"), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b\"a/b/\\xFF.txt\"), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::new(b\"a/b/c.\\x80\"), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(b\"\\xFF/b\"), Some(\"b\"), None, Some(\"b\"), None);\n     }\n \n     #[test]\n     fn test_dir_path() {\n-        t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n-        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n+        t!(v: Path::new(b\"hi/there\\x80\").dir_path(), b\"hi\");\n+        t!(v: Path::new(b\"hi\\xFF/there\").dir_path(), b\"hi\\xFF\");\n         t!(s: Path::new(\"hi/there\").dir_path(), \"hi\");\n         t!(s: Path::new(\"hi\").dir_path(), \".\");\n         t!(s: Path::new(\"/hi\").dir_path(), \"/\");\n@@ -1125,9 +1116,9 @@ mod tests {\n         t!(s: \"/a/b/c\", \"d/e/f\", false);\n         t!(s: \"a/b/c\", \"a/b\", false);\n         t!(s: \"a/b/c\", \"b\", false);\n-        t!(v: b!(\"a/b/c\"), b!(\"b/c\"), true);\n-        t!(v: b!(\"a/b/\", 0xff), b!(0xff), true);\n-        t!(v: b!(\"a/b/\", 0xff), b!(\"b/\", 0xff), true);\n+        t!(v: b\"a/b/c\", b\"b/c\", true);\n+        t!(v: b\"a/b/\\xFF\", b\"\\xFF\", true);\n+        t!(v: b\"a/b/\\xFF\", b\"b/\\xFF\", true);\n     }\n \n     #[test]\n@@ -1192,11 +1183,11 @@ mod tests {\n                             comps, exps);\n                 }\n             );\n-            (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n+            (b: $arg:expr, [$($exp:expr),*]) => (\n                 {\n-                    let path = Path::new(b!($($arg),+));\n+                    let path = Path::new($arg);\n                     let comps = path.components().collect::<Vec<&[u8]>>();\n-                    let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n+                    let exp: &[&[u8]] = [$($exp),*];\n                     assert_eq!(comps.as_slice(), exp);\n                     let comps = path.components().rev().collect::<Vec<&[u8]>>();\n                     let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&[u8]>>();\n@@ -1205,9 +1196,9 @@ mod tests {\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [[\"a\"], [\"b\"], [\"c\"]]);\n-        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [[0xff], [\"a\"], [0x80]]);\n-        t!(v: [\"../../foo\", 0xcd, \"bar\"], [[\"..\"], [\"..\"], [\"foo\", 0xcd, \"bar\"]]);\n+        t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n+        t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n+        t!(b: b\"../../foo\\xCDbar\", [b\"..\", b\"..\", b\"foo\\xCDbar\"]);\n         t!(s: \"a/b/c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a/b/d\", [\"a\", \"b\", \"d\"]);\n         t!(s: \"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n@@ -1224,9 +1215,9 @@ mod tests {\n     #[test]\n     fn test_str_components() {\n         macro_rules! t(\n-            (v: [$($arg:expr),+], $exp:expr) => (\n+            (b: $arg:expr, $exp:expr) => (\n                 {\n-                    let path = Path::new(b!($($arg),+));\n+                    let path = Path::new($arg);\n                     let comps = path.str_components().collect::<Vec<Option<&str>>>();\n                     let exp: &[Option<&str>] = $exp;\n                     assert_eq!(comps.as_slice(), exp);\n@@ -1237,9 +1228,9 @@ mod tests {\n             )\n         )\n \n-        t!(v: [\"a/b/c\"], [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n-        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [None, Some(\"a\"), None]);\n-        t!(v: [\"../../foo\", 0xcd, \"bar\"], [Some(\"..\"), Some(\"..\"), None]);\n+        t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n+        t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);\n+        t!(b: b\"../../foo\\xCDbar\", [Some(\"..\"), Some(\"..\"), None]);\n         // str_components is a wrapper around components, so no need to do\n         // the full set of tests\n     }"}, {"sha": "4d6f8d0888f3e489575ac0fcd9a916d1a2c326fb", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 43, "deletions": 64, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1123,15 +1123,6 @@ mod tests {\n         )\n     )\n \n-    macro_rules! b(\n-        ($($arg:expr),+) => (\n-            {\n-                static the_bytes: &'static [u8] = bytes!($($arg),+);\n-                the_bytes\n-            }\n-        )\n-    )\n-\n     #[test]\n     fn test_parse_prefix() {\n         macro_rules! t(\n@@ -1196,9 +1187,9 @@ mod tests {\n     #[test]\n     fn test_paths() {\n         let empty: &[u8] = [];\n-        t!(v: Path::new(empty), b!(\".\"));\n-        t!(v: Path::new(b!(\"\\\\\")), b!(\"\\\\\"));\n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), b!(\"a\\\\b\\\\c\"));\n+        t!(v: Path::new(empty), b\".\");\n+        t!(v: Path::new(b\"\\\\\"), b\"\\\\\");\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), b\"a\\\\b\\\\c\");\n \n         t!(s: Path::new(\"\"), \".\");\n         t!(s: Path::new(\"\\\\\"), \"\\\\\");\n@@ -1230,8 +1221,8 @@ mod tests {\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\..\"), \"..\\\\..\");\n         t!(s: Path::new(\"foo\\\\..\\\\..\\\\bar\"), \"..\\\\bar\");\n \n-        assert_eq!(Path::new(b!(\"foo\\\\bar\")).into_vec().as_slice(), b!(\"foo\\\\bar\"));\n-        assert_eq!(Path::new(b!(\"\\\\foo\\\\..\\\\..\\\\bar\")).into_vec().as_slice(), b!(\"\\\\bar\"));\n+        assert_eq!(Path::new(b\"foo\\\\bar\").into_vec().as_slice(), b\"foo\\\\bar\");\n+        assert_eq!(Path::new(b\"\\\\foo\\\\..\\\\..\\\\bar\").into_vec().as_slice(), b\"\\\\bar\");\n \n         t!(s: Path::new(\"\\\\\\\\a\"), \"\\\\a\");\n         t!(s: Path::new(\"\\\\\\\\a\\\\\"), \"\\\\a\");\n@@ -1284,9 +1275,9 @@ mod tests {\n \n     #[test]\n     fn test_opt_paths() {\n-        assert!(Path::new_opt(b!(\"foo\\\\bar\", 0)) == None);\n-        assert!(Path::new_opt(b!(\"foo\\\\bar\", 0x80)) == None);\n-        t!(v: Path::new_opt(b!(\"foo\\\\bar\")).unwrap(), b!(\"foo\\\\bar\"));\n+        assert!(Path::new_opt(b\"foo\\\\bar\\0\") == None);\n+        assert!(Path::new_opt(b\"foo\\\\bar\\x80\") == None);\n+        t!(v: Path::new_opt(b\"foo\\\\bar\").unwrap(), b\"foo\\\\bar\");\n         assert!(Path::new_opt(\"foo\\\\bar\\0\") == None);\n         t!(s: Path::new_opt(\"foo\\\\bar\").unwrap(), \"foo\\\\bar\");\n     }\n@@ -1295,38 +1286,38 @@ mod tests {\n     fn test_null_byte() {\n         use task;\n         let result = task::try(proc() {\n-            Path::new(b!(\"foo/bar\", 0))\n+            Path::new(b\"foo/bar\\0\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").set_filename(b!(\"f\", 0, \"o\"))\n+            Path::new(\"test\").set_filename(b\"f\\0o\")\n         });\n         assert!(result.is_err());\n \n         let result = task::try(proc() {\n-            Path::new(\"test\").push(b!(\"f\", 0, \"o\"));\n+            Path::new(\"test\").push(b\"f\\0o\");\n         });\n         assert!(result.is_err());\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_not_utf8_fail() {\n-        Path::new(b!(\"hello\", 0x80, \".txt\"));\n+        Path::new(b\"hello\\x80.txt\");\n     }\n \n     #[test]\n     fn test_display_str() {\n         let path = Path::new(\"foo\");\n         assert_eq!(path.display().to_str(), \"foo\".to_string());\n-        let path = Path::new(b!(\"\\\\\"));\n+        let path = Path::new(b\"\\\\\");\n         assert_eq!(path.filename_display().to_str(), \"\".to_string());\n \n         let path = Path::new(\"foo\");\n         let mo = path.display().as_maybe_owned();\n         assert_eq!(mo.as_slice(), \"foo\");\n-        let path = Path::new(b!(\"\\\\\"));\n+        let path = Path::new(b\"\\\\\");\n         let mo = path.filename_display().as_maybe_owned();\n         assert_eq!(mo.as_slice(), \"\");\n     }\n@@ -1377,7 +1368,7 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), filename, Some(b!(\"c\")));\n+        t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"\\\\a\\\\b\\\\c\", filename_str, \"c\");\n         t!(s: \"a\", filename_str, \"a\");\n@@ -1410,7 +1401,7 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\\", filename_str, None, opt);\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", filename_str, \"b\");\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), dirname, b!(\"a\\\\b\"));\n+        t!(v: b\"a\\\\b\\\\c\", dirname, b\"a\\\\b\");\n         t!(s: \"a\\\\b\\\\c\", dirname_str, \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", dirname_str, \"\\\\a\\\\b\");\n         t!(s: \"a\", dirname_str, \".\");\n@@ -1441,7 +1432,7 @@ mod tests {\n         t!(s: \"\\\\\\\\.\\\\foo\", dirname_str, \"\\\\\\\\.\\\\foo\");\n         t!(s: \"\\\\\\\\?\\\\a\\\\b\\\\\", dirname_str, \"\\\\\\\\?\\\\a\");\n \n-        t!(v: b!(\"hi\\\\there.txt\"), filestem, Some(b!(\"there\")));\n+        t!(v: b\"hi\\\\there.txt\", filestem, Some(b\"there\"));\n         t!(s: \"hi\\\\there.txt\", filestem_str, \"there\");\n         t!(s: \"hi\\\\there\", filestem_str, \"there\");\n         t!(s: \"there.txt\", filestem_str, \"there\");\n@@ -1456,8 +1447,8 @@ mod tests {\n         t!(s: \"..\\\\..\", filestem_str, None, opt);\n         // filestem is based on filename, so we don't need the full set of prefix tests\n \n-        t!(v: b!(\"hi\\\\there.txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi\\\\there\"), extension, None);\n+        t!(v: b\"hi\\\\there.txt\", extension, Some(b\"txt\"));\n+        t!(v: b\"hi\\\\there\", extension, None);\n         t!(s: \"hi\\\\there.txt\", extension_str, Some(\"txt\"), opt);\n         t!(s: \"hi\\\\there\", extension_str, None, opt);\n         t!(s: \"there.txt\", extension_str, Some(\"txt\"), opt);\n@@ -1583,10 +1574,10 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"\\\\e\"), b!(\"f\")], b!(\"\\\\e\\\\f\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n-           b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"\\\\e\", b\"f\"], b\"\\\\e\\\\f\");\n+        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+           b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n     #[test]\n@@ -1604,11 +1595,11 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             );\n-            (v: [$($path:expr),+], [$($left:expr),+], $right:expr) => (\n+            (b: $path:expr, $left:expr, $right:expr) => (\n                 {\n-                    let mut p = Path::new(b!($($path),+));\n+                    let mut p = Path::new($path);\n                     let result = p.pop();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n+                    assert_eq!(p.as_vec(), $left);\n                     assert!(result == $right);\n                 }\n             )\n@@ -1619,11 +1610,11 @@ mod tests {\n         t!(s: \".\", \".\", false);\n         t!(s: \"\\\\a\", \"\\\\\", true);\n         t!(s: \"\\\\\", \"\\\\\", false);\n-        t!(v: [\"a\\\\b\\\\c\"], [\"a\\\\b\"], true);\n-        t!(v: [\"a\"], [\".\"], true);\n-        t!(v: [\".\"], [\".\"], false);\n-        t!(v: [\"\\\\a\"], [\"\\\\\"], true);\n-        t!(v: [\"\\\\\"], [\"\\\\\"], false);\n+        t!(b: b\"a\\\\b\\\\c\", b\"a\\\\b\", true);\n+        t!(b: b\"a\", b\".\", true);\n+        t!(b: b\".\", b\".\", false);\n+        t!(b: b\"\\\\a\", b\"\\\\\", true);\n+        t!(b: b\"\\\\\", b\"\\\\\", false);\n \n         t!(s: \"C:\\\\a\\\\b\", \"C:\\\\a\", true);\n         t!(s: \"C:\\\\a\", \"C:\\\\\", true);\n@@ -1672,8 +1663,8 @@ mod tests {\n         t!(s: Path::new(\"a\\\\b\").join(\"\\\\c\\\\d\"), \"\\\\c\\\\d\");\n         t!(s: Path::new(\".\").join(\"a\\\\b\"), \"a\\\\b\");\n         t!(s: Path::new(\"\\\\\").join(\"a\\\\b\"), \"\\\\a\\\\b\");\n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")).join(b!(\"..\")), b!(\"a\\\\b\"));\n-        t!(v: Path::new(b!(\"\\\\a\\\\b\\\\c\")).join(b!(\"d\")), b!(\"\\\\a\\\\b\\\\c\\\\d\"));\n+        t!(v: Path::new(b\"a\\\\b\\\\c\").join(b\"..\"), b\"a\\\\b\");\n+        t!(v: Path::new(b\"\\\\a\\\\b\\\\c\").join(b\"d\"), b\"\\\\a\\\\b\\\\c\\\\d\");\n         // full join testing is covered under test_push_path, so no need for\n         // the full set of prefix tests\n     }\n@@ -1724,9 +1715,9 @@ mod tests {\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\", \"f\"], \"\\\\e\\\\f\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\".to_string(), \"e\".to_string()], \"a\\\\b\\\\c\\\\d\\\\e\");\n-        t!(v: b!(\"a\\\\b\\\\c\"), [b!(\"d\"), b!(\"e\")], b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n-        t!(v: b!(\"a\\\\b\\\\c\"), [Vec::from_slice(b!(\"d\")), Vec::from_slice(b!(\"e\"))],\n-           b!(\"a\\\\b\\\\c\\\\d\\\\e\"));\n+        t!(v: b\"a\\\\b\\\\c\", [b\"d\", b\"e\"], b\"a\\\\b\\\\c\\\\d\\\\e\");\n+        t!(v: b\"a\\\\b\\\\c\", [Vec::from_slice(b\"d\"), Vec::from_slice(b\"e\")],\n+           b\"a\\\\b\\\\c\\\\d\\\\e\");\n     }\n \n     #[test]\n@@ -1839,15 +1830,15 @@ mod tests {\n             )\n         )\n \n-        t!(v: b!(\"a\\\\b\\\\c\"), set_filename, with_filename, b!(\"d\"));\n-        t!(v: b!(\"\\\\\"), set_filename, with_filename, b!(\"foo\"));\n+        t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n+        t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n         t!(s: \"a\\\\b\\\\c\", set_filename, with_filename, \"d\");\n         t!(s: \"\\\\\", set_filename, with_filename, \"foo\");\n         t!(s: \".\", set_filename, with_filename, \"foo\");\n         t!(s: \"a\\\\b\", set_filename, with_filename, \"\");\n         t!(s: \"a\", set_filename, with_filename, \"\");\n \n-        t!(v: b!(\"hi\\\\there.txt\"), set_extension, with_extension, b!(\"exe\"));\n+        t!(v: b\"hi\\\\there.txt\", set_extension, with_extension, b\"exe\");\n         t!(s: \"hi\\\\there.txt\", set_extension, with_extension, \"exe\");\n         t!(s: \"hi\\\\there.\", set_extension, with_extension, \"txt\");\n         t!(s: \"hi\\\\there\", set_extension, with_extension, \"txt\");\n@@ -1894,7 +1885,7 @@ mod tests {\n             )\n         )\n \n-        t!(v: Path::new(b!(\"a\\\\b\\\\c\")), Some(b!(\"c\")), b!(\"a\\\\b\"), Some(b!(\"c\")), None);\n+        t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n         t!(s: Path::new(\".\"), None, Some(\".\"), None, None);\n         t!(s: Path::new(\"\\\\\"), None, Some(\"\\\\\"), None, None);\n@@ -2250,21 +2241,9 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             );\n-            (v: [$($arg:expr),+], $exp:expr) => (\n-                {\n-                    let path = Path::new(b!($($arg),+));\n-                    let comps = path.str_components().map(|x|x.unwrap()).collect::<Vec<&str>>();\n-                    let exp: &[&str] = $exp;\n-                    assert_eq!(comps.as_slice(), exp);\n-                    let comps = path.str_components().rev().map(|x|x.unwrap())\n-                                .collect::<Vec<&str>>();\n-                    let exp = exp.iter().rev().map(|&x|x).collect::<Vec<&str>>();\n-                    assert_eq!(comps, exp);\n-                }\n-            )\n         )\n \n-        t!(v: [\"a\\\\b\\\\c\"], [\"a\", \"b\", \"c\"]);\n+        t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\d\", [\"a\", \"b\", \"d\"]);\n         t!(s: \"a\\\\b\\\\cd\", [\"a\", \"b\", \"cd\"]);\n@@ -2320,8 +2299,8 @@ mod tests {\n             )\n         )\n \n-        t!(s: \"a\\\\b\\\\c\", [b!(\"a\"), b!(\"b\"), b!(\"c\")]);\n-        t!(s: \".\", [b!(\".\")]);\n+        t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n+        t!(s: \".\", [b\".\"]);\n         // since this is really a wrapper around str_components, those tests suffice\n     }\n "}, {"sha": "0ead8fa6c0c839b082c97dbaf6aa6dc9bae5b247", "filename": "src/libstd/task.rs", "status": "modified", "additions": 460, "deletions": 381, "changes": 841, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -8,238 +8,294 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Utilities for managing and scheduling tasks\n- *\n- * An executing Rust program consists of a collection of tasks, each with their\n- * own stack, and sole ownership of their allocated heap data. Tasks communicate\n- * with each other using channels (see `std::comm` for more info about how\n- * communication works).\n- *\n- * Failure in one task does not propagate to any others (not to parent, not to\n- * child).  Failure propagation is instead handled by using the channel send()\n- * and recv() methods which will fail if the other end has hung up already.\n- *\n- * Task Scheduling:\n- *\n- * By default, every task is created with the same \"flavor\" as the calling task.\n- * This flavor refers to the scheduling mode, with two possibilities currently\n- * being 1:1 and M:N modes. Green (M:N) tasks are cooperatively scheduled and\n- * native (1:1) tasks are scheduled by the OS kernel.\n- *\n- * # Example\n- *\n- * ```rust\n- * spawn(proc() {\n- *     println!(\"Hello, World!\");\n- * })\n- * ```\n- */\n+//! Utilities for managing and scheduling tasks\n+//!\n+//! An executing Rust program consists of a collection of lightweight tasks,\n+//! each with their own stack. Tasks communicate with each other using channels\n+//! (see `std::comm`) or other forms of synchronization (see `std::sync`) that\n+//! ensure data-race freedom.\n+//!\n+//! Failure in one task does immediately propagate to any others (not to parent,\n+//! not to child). Failure propagation is instead handled as part of task\n+//! synchronization. For example, the channel `send()` and `recv()` methods will\n+//! fail if the other end has hung up already.\n+//!\n+//! # Basic task scheduling\n+//!\n+//! By default, every task is created with the same \"flavor\" as the calling task.\n+//! This flavor refers to the scheduling mode, with two possibilities currently\n+//! being 1:1 and M:N modes. Green (M:N) tasks are cooperatively scheduled and\n+//! native (1:1) tasks are scheduled by the OS kernel.\n+//!\n+//! ## Example\n+//!\n+//! ```rust\n+//! spawn(proc() {\n+//!     println!(\"Hello, World!\");\n+//! })\n+//! ```\n+//!\n+//! # Advanced task scheduling\n+//!\n+//! Task spawning can also be configured to use a particular scheduler, to\n+//! redirect the new task's output, or to yield a `future` representing the\n+//! task's final result. The configuration is established using the\n+//! `TaskBuilder` API:\n+//!\n+//! ## Example\n+//!\n+//! ```rust\n+//! extern crate green;\n+//! extern crate native;\n+//!\n+//! use std::task::TaskBuilder;\n+//! use green::{SchedPool, PoolConfig, GreenTaskBuilder};\n+//! use native::NativeTaskBuilder;\n+//!\n+//! # fn main() {\n+//! // Create a green scheduler pool with the default configuration\n+//! let mut pool = SchedPool::new(PoolConfig::new());\n+//!\n+//! // Spawn a task in the green pool\n+//! let mut fut_green = TaskBuilder::new().green(&mut pool).try_future(proc() {\n+//!     /* ... */\n+//! });\n+//!\n+//! // Spawn a native task\n+//! let mut fut_native = TaskBuilder::new().native().try_future(proc() {\n+//!     /* ... */\n+//! });\n+//!\n+//! // Wait for both tasks to finish, recording their outcome\n+//! let res_green  = fut_green.unwrap();\n+//! let res_native = fut_native.unwrap();\n+//!\n+//! // Shut down the green scheduler pool\n+//! pool.shutdown();\n+//! # }\n+//! ```\n \n use any::Any;\n-use comm::{Sender, Receiver, channel};\n+use comm::channel;\n use io::{Writer, stdio};\n use kinds::{Send, marker};\n use option::{None, Some, Option};\n use owned::Box;\n-use result::{Result, Ok, Err};\n+use result::Result;\n use rt::local::Local;\n use rt::task;\n use rt::task::Task;\n use str::{Str, SendStr, IntoMaybeOwned};\n+use sync::Future;\n \n-#[cfg(test)] use any::AnyRefExt;\n-#[cfg(test)] use owned::AnyOwnExt;\n-#[cfg(test)] use result;\n-#[cfg(test)] use str::StrAllocating;\n-#[cfg(test)] use string::String;\n-\n-/// Task configuration options\n-pub struct TaskOpts {\n-    /// Enable lifecycle notifications on the given channel\n-    pub notify_chan: Option<Sender<task::Result>>,\n-    /// A name for the task-to-be, for identification in failure messages\n-    pub name: Option<SendStr>,\n-    /// The size of the stack for the spawned task\n-    pub stack_size: Option<uint>,\n-    /// Task-local stdout\n-    pub stdout: Option<Box<Writer + Send>>,\n-    /// Task-local stderr\n-    pub stderr: Option<Box<Writer + Send>>,\n+/// A means of spawning a task\n+pub trait Spawner {\n+    /// Spawn a task, given low-level task options.\n+    fn spawn(self, opts: task::TaskOpts, f: proc():Send);\n }\n \n-/**\n- * The task builder type.\n- *\n- * Provides detailed control over the properties and behavior of new tasks.\n- */\n+/// The default task spawner, which spawns siblings to the current task.\n+pub struct SiblingSpawner;\n+\n+impl Spawner for SiblingSpawner {\n+    fn spawn(self, opts: task::TaskOpts, f: proc():Send) {\n+        // bind tb to provide type annotation\n+        let tb: Option<Box<Task>> = Local::try_take();\n+        match tb {\n+            Some(t) => t.spawn_sibling(opts, f),\n+            None => fail!(\"need a local task to spawn a sibling task\"),\n+        };\n+    }\n+}\n+\n+/// The task builder type.\n+///\n+/// Provides detailed control over the properties and behavior of new tasks.\n+\n // NB: Builders are designed to be single-use because they do stateful\n // things that get weird when reusing - e.g. if you create a result future\n // it only applies to a single task, so then you have to maintain Some\n // potentially tricky state to ensure that everything behaves correctly\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n-pub struct TaskBuilder {\n-    /// Options to spawn the new task with\n-    pub opts: TaskOpts,\n-    gen_body: Option<proc(v: proc(): Send): Send -> proc(): Send>,\n+pub struct TaskBuilder<S = SiblingSpawner> {\n+    // A name for the task-to-be, for identification in failure messages\n+    name: Option<SendStr>,\n+    // The size of the stack for the spawned task\n+    stack_size: Option<uint>,\n+    // Task-local stdout\n+    stdout: Option<Box<Writer + Send>>,\n+    // Task-local stderr\n+    stderr: Option<Box<Writer + Send>>,\n+    // The mechanics of actually spawning the task (i.e.: green or native)\n+    spawner: S,\n+    // Optionally wrap the eventual task body\n+    gen_body: Option<proc(v: proc():Send):Send -> proc():Send>,\n     nocopy: marker::NoCopy,\n }\n \n-impl TaskBuilder {\n-     /// Generate the base configuration for spawning a task, off of which more\n-     /// configuration methods can be chained.\n-    pub fn new() -> TaskBuilder {\n+impl TaskBuilder<SiblingSpawner> {\n+    /// Generate the base configuration for spawning a task, off of which more\n+    /// configuration methods can be chained.\n+    pub fn new() -> TaskBuilder<SiblingSpawner> {\n         TaskBuilder {\n-            opts: TaskOpts::new(),\n+            name: None,\n+            stack_size: None,\n+            stdout: None,\n+            stderr: None,\n+            spawner: SiblingSpawner,\n             gen_body: None,\n             nocopy: marker::NoCopy,\n         }\n     }\n+}\n \n-    /// Get a future representing the exit status of the task.\n-    ///\n-    /// Taking the value of the future will block until the child task\n-    /// terminates. The future result return value will be created *before* the task is\n-    /// spawned; as such, do not invoke .get() on it directly;\n-    /// rather, store it in an outer variable/list for later use.\n-    ///\n-    /// # Failure\n-    /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> Receiver<task::Result> {\n-        // FIXME (#3725): Once linked failure and notification are\n-        // handled in the library, I can imagine implementing this by just\n-        // registering an arbitrary number of task::on_exit handlers and\n-        // sending out messages.\n-\n-        if self.opts.notify_chan.is_some() {\n-            fail!(\"Can't set multiple future_results for one task!\");\n-        }\n-\n-        // Construct the future and give it to the caller.\n-        let (tx, rx) = channel();\n+impl<S: Spawner> TaskBuilder<S> {\n+    /// Name the task-to-be. Currently the name is used for identification\n+    /// only in failure messages.\n+    pub fn named<T: IntoMaybeOwned<'static>>(mut self, name: T) -> TaskBuilder<S> {\n+        self.name = Some(name.into_maybe_owned());\n+        self\n+    }\n \n-        // Reconfigure self to use a notify channel.\n-        self.opts.notify_chan = Some(tx);\n+    /// Set the size of the stack for the new task.\n+    pub fn stack_size(mut self, size: uint) -> TaskBuilder<S> {\n+        self.stack_size = Some(size);\n+        self\n+    }\n \n-        rx\n+    /// Redirect task-local stdout.\n+    pub fn stdout(mut self, stdout: Box<Writer + Send>) -> TaskBuilder<S> {\n+        self.stdout = Some(stdout);\n+        self\n     }\n \n-    /// Name the task-to-be. Currently the name is used for identification\n-    /// only in failure messages.\n-    pub fn named<S: IntoMaybeOwned<'static>>(mut self, name: S) -> TaskBuilder {\n-        self.opts.name = Some(name.into_maybe_owned());\n+    /// Redirect task-local stderr.\n+    pub fn stderr(mut self, stderr: Box<Writer + Send>) -> TaskBuilder<S> {\n+        self.stderr = Some(stderr);\n         self\n     }\n \n-    /**\n-     * Add a wrapper to the body of the spawned task.\n-     *\n-     * Before the task is spawned it is passed through a 'body generator'\n-     * function that may perform local setup operations as well as wrap\n-     * the task body in remote setup operations. With this the behavior\n-     * of tasks can be extended in simple ways.\n-     *\n-     * This function augments the current body generator with a new body\n-     * generator by applying the task body which results from the\n-     * existing body generator to the new body generator.\n-     */\n-    pub fn with_wrapper(mut self,\n-                        wrapper: proc(v: proc(): Send): Send -> proc(): Send)\n-        -> TaskBuilder\n-    {\n+    /// Set the spawning mechanism for the task.\n+    ///\n+    /// The `TaskBuilder` API configures a task to be spawned, but defers to the\n+    /// \"spawner\" to actually create and spawn the task. The `spawner` method\n+    /// should not be called directly by `TaskBuiler` clients. It is intended\n+    /// for use by downstream crates (like `native` and `green`) that implement\n+    /// tasks. These downstream crates then add extension methods to the\n+    /// builder, like `.native()` and `.green(pool)`, that actually set the\n+    /// spawner.\n+    pub fn spawner<T: Spawner>(self, spawner: T) -> TaskBuilder<T> {\n+        // repackage the entire TaskBuilder since its type is changing.\n+        let TaskBuilder {\n+            name, stack_size, stdout, stderr, spawner: _, gen_body, nocopy\n+        } = self;\n+        TaskBuilder {\n+            name: name,\n+            stack_size: stack_size,\n+            stdout: stdout,\n+            stderr: stderr,\n+            spawner: spawner,\n+            gen_body: gen_body,\n+            nocopy: nocopy,\n+        }\n+    }\n+\n+    /// Add a wrapper to the body of the spawned task.\n+    ///\n+    /// Before the task is spawned it is passed through a 'body generator'\n+    /// function that may perform local setup operations as well as wrap\n+    /// the task body in remote setup operations. With this the behavior\n+    /// of tasks can be extended in simple ways.\n+    ///\n+    /// This function augments the current body generator with a new body\n+    /// generator by applying the task body which results from the\n+    /// existing body generator to the new body generator.\n+    #[deprecated = \"this function will be removed soon\"]\n+    pub fn with_wrapper(mut self, wrapper: proc(v: proc():Send):Send -> proc():Send)\n+                        -> TaskBuilder<S> {\n         self.gen_body = match self.gen_body.take() {\n             Some(prev) => Some(proc(body) { wrapper(prev(body)) }),\n             None => Some(wrapper)\n         };\n         self\n     }\n \n-    /**\n-     * Creates and executes a new child task\n-     *\n-     * Sets up a new task with its own call stack and schedules it to run\n-     * the provided unique closure. The task has the properties and behavior\n-     * specified by the task_builder.\n-     */\n-    pub fn spawn(mut self, f: proc(): Send) {\n-        let gen_body = self.gen_body.take();\n-        let f = match gen_body {\n+    // Where spawning actually happens (whether yielding a future or not)\n+    fn spawn_internal(self, f: proc():Send,\n+                      on_exit: Option<proc(Result<(), Box<Any + Send>>):Send>) {\n+        let TaskBuilder {\n+            name, stack_size, stdout, stderr, spawner, mut gen_body, nocopy: _\n+        } = self;\n+        let f = match gen_body.take() {\n             Some(gen) => gen(f),\n             None => f\n         };\n-        let t: Box<Task> = match Local::try_take() {\n-            Some(t) => t,\n-            None => fail!(\"need a local task to spawn a new task\"),\n-        };\n-        let TaskOpts { notify_chan, name, stack_size, stdout, stderr } = self.opts;\n-\n         let opts = task::TaskOpts {\n-            on_exit: notify_chan.map(|c| proc(r) c.send(r)),\n+            on_exit: on_exit,\n             name: name,\n             stack_size: stack_size,\n         };\n         if stdout.is_some() || stderr.is_some() {\n-            t.spawn_sibling(opts, proc() {\n+            spawner.spawn(opts, proc() {\n                 let _ = stdout.map(stdio::set_stdout);\n                 let _ = stderr.map(stdio::set_stderr);\n                 f();\n-            });\n+            })\n         } else {\n-            t.spawn_sibling(opts, f);\n+            spawner.spawn(opts, f)\n         }\n     }\n \n-    /**\n-     * Execute a function in another task and return either the return value\n-     * of the function or result::err.\n-     *\n-     * # Return value\n-     *\n-     * If the function executed successfully then try returns result::ok\n-     * containing the value returned by the function. If the function fails\n-     * then try returns result::err containing nil.\n-     *\n-     * # Failure\n-     * Fails if a future_result was already set for this task.\n-     */\n-    pub fn try<T: Send>(mut self, f: proc(): Send -> T)\n-               -> Result<T, Box<Any + Send>> {\n-        let (tx, rx) = channel();\n-\n-        let result = self.future_result();\n-\n-        self.spawn(proc() {\n-            tx.send(f());\n-        });\n-\n-        match result.recv() {\n-            Ok(())     => Ok(rx.recv()),\n-            Err(cause) => Err(cause)\n-        }\n+    /// Creates and executes a new child task.\n+    ///\n+    /// Sets up a new task with its own call stack and schedules it to run\n+    /// the provided proc. The task has the properties and behavior\n+    /// specified by the `TaskBuilder`.\n+    pub fn spawn(self, f: proc():Send) {\n+        self.spawn_internal(f, None)\n     }\n-}\n-\n-/* Task construction */\n \n-impl TaskOpts {\n-    pub fn new() -> TaskOpts {\n-        /*!\n-         * The default task options\n-         */\n+    /// Execute a proc in a newly-spawned task and return a future representing\n+    /// the task's result. The task has the properties and behavior\n+    /// specified by the `TaskBuilder`.\n+    ///\n+    /// Taking the value of the future will block until the child task\n+    /// terminates.\n+    ///\n+    /// # Return value\n+    ///\n+    /// If the child task executes successfully (without failing) then the\n+    /// future returns `result::Ok` containing the value returned by the\n+    /// function. If the child task fails then the future returns `result::Err`\n+    /// containing the argument to `fail!(...)` as an `Any` trait object.\n+    pub fn try_future<T:Send>(self, f: proc():Send -> T)\n+                              -> Future<Result<T, Box<Any + Send>>> {\n+        // currently, the on_exit proc provided by librustrt only works for unit\n+        // results, so we use an additional side-channel to communicate the\n+        // result.\n+\n+        let (tx_done, rx_done) = channel(); // signal that task has exited\n+        let (tx_retv, rx_retv) = channel(); // return value from task\n+\n+        let on_exit = proc(res) { tx_done.send(res) };\n+        self.spawn_internal(proc() { tx_retv.send(f()) },\n+                            Some(on_exit));\n+\n+        Future::from_fn(proc() {\n+            rx_done.recv().map(|_| rx_retv.recv())\n+        })\n+    }\n \n-        TaskOpts {\n-            notify_chan: None,\n-            name: None,\n-            stack_size: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n+    /// Execute a function in a newly-spawnedtask and block until the task\n+    /// completes or fails. Equivalent to `.try_future(f).unwrap()`.\n+    pub fn try<T:Send>(self, f: proc():Send -> T) -> Result<T, Box<Any + Send>> {\n+        self.try_future(f).unwrap()\n     }\n }\n \n-/* Spawn convenience functions */\n+/* Convenience functions */\n \n /// Creates and executes a new child task\n ///\n@@ -251,14 +307,22 @@ pub fn spawn(f: proc(): Send) {\n     TaskBuilder::new().spawn(f)\n }\n \n-/// Execute a function in another task and return either the return value of\n-/// the function or an error if the task failed\n+/// Execute a function in a newly-spawned task and return either the return\n+/// value of the function or an error if the task failed.\n ///\n-/// This is equivalent to TaskBuilder::new().try\n+/// This is equivalent to `TaskBuilder::new().try`.\n pub fn try<T: Send>(f: proc(): Send -> T) -> Result<T, Box<Any + Send>> {\n     TaskBuilder::new().try(f)\n }\n \n+/// Execute a function in another task and return a future representing the\n+/// task's result.\n+///\n+/// This is equivalent to `TaskBuilder::new().try_future`.\n+pub fn try_future<T:Send>(f: proc():Send -> T) -> Future<Result<T, Box<Any + Send>>> {\n+    TaskBuilder::new().try_future(f)\n+}\n+\n \n /* Lifecycle functions */\n \n@@ -273,276 +337,291 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     }\n }\n \n+/// Yield control to the task scheduler.\n pub fn deschedule() {\n-    //! Yield control to the task scheduler\n-\n     use rt::local::Local;\n \n     // FIXME(#7544): Optimize this, since we know we won't block.\n     let task: Box<Task> = Local::take();\n     task.yield_now();\n }\n \n+/// True if the running task is currently failing (e.g. will return `true` inside a\n+/// destructor that is run while unwinding the stack after a call to `fail!()`).\n pub fn failing() -> bool {\n-    //! True if the running task has failed\n     use rt::task::Task;\n     Local::borrow(None::<Task>).unwinder.unwinding()\n }\n \n-// The following 8 tests test the following 2^3 combinations:\n-// {un,}linked {un,}supervised failure propagation {up,down}wards.\n-\n-// !!! These tests are dangerous. If Something is buggy, they will hang, !!!\n-// !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n-\n-#[test]\n-fn test_unnamed_task() {\n-    spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.is_none());\n+#[cfg(test)]\n+mod test {\n+    use any::{Any, AnyRefExt};\n+    use owned::AnyOwnExt;\n+    use result;\n+    use result::{Ok, Err};\n+    use str::StrAllocating;\n+    use string::String;\n+    use std::io::{ChanReader, ChanWriter};\n+    use prelude::*;\n+    use super::*;\n+\n+    // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n+    // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n+\n+    #[test]\n+    fn test_unnamed_task() {\n+        spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.is_none());\n+            })\n         })\n-    })\n-}\n+    }\n \n-#[test]\n-fn test_owned_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.unwrap() == \"ada lovelace\");\n+    #[test]\n+    fn test_owned_named_task() {\n+        TaskBuilder::new().named(\"ada lovelace\".to_string()).spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.unwrap() == \"ada lovelace\");\n+            })\n         })\n-    })\n-}\n+    }\n \n-#[test]\n-fn test_static_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\").spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.unwrap() == \"ada lovelace\");\n+    #[test]\n+    fn test_static_named_task() {\n+        TaskBuilder::new().named(\"ada lovelace\").spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.unwrap() == \"ada lovelace\");\n+            })\n         })\n-    })\n-}\n+    }\n \n-#[test]\n-fn test_send_named_task() {\n-    TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n-        with_task_name(|name| {\n-            assert!(name.unwrap() == \"ada lovelace\");\n+    #[test]\n+    fn test_send_named_task() {\n+        TaskBuilder::new().named(\"ada lovelace\".into_maybe_owned()).spawn(proc() {\n+            with_task_name(|name| {\n+                assert!(name.unwrap() == \"ada lovelace\");\n+            })\n         })\n-    })\n-}\n-\n-#[test]\n-fn test_run_basic() {\n-    let (tx, rx) = channel();\n-    TaskBuilder::new().spawn(proc() {\n-        tx.send(());\n-    });\n-    rx.recv();\n-}\n+    }\n \n-#[test]\n-fn test_with_wrapper() {\n-    let (tx, rx) = channel();\n-    TaskBuilder::new().with_wrapper(proc(body) {\n-        let result: proc(): Send = proc() {\n-            body();\n+    #[test]\n+    fn test_run_basic() {\n+        let (tx, rx) = channel();\n+        TaskBuilder::new().spawn(proc() {\n             tx.send(());\n-        };\n-        result\n-    }).spawn(proc() { });\n-    rx.recv();\n-}\n+        });\n+        rx.recv();\n+    }\n \n-#[test]\n-fn test_future_result() {\n-    let mut builder = TaskBuilder::new();\n-    let result = builder.future_result();\n-    builder.spawn(proc() {});\n-    assert!(result.recv().is_ok());\n-\n-    let mut builder = TaskBuilder::new();\n-    let result = builder.future_result();\n-    builder.spawn(proc() {\n-        fail!();\n-    });\n-    assert!(result.recv().is_err());\n-}\n+    #[test]\n+    fn test_with_wrapper() {\n+        let (tx, rx) = channel();\n+        TaskBuilder::new().with_wrapper(proc(body) {\n+            let result: proc():Send = proc() {\n+                body();\n+                tx.send(());\n+            };\n+            result\n+        }).spawn(proc() { });\n+        rx.recv();\n+    }\n \n-#[test] #[should_fail]\n-fn test_back_to_the_future_result() {\n-    let mut builder = TaskBuilder::new();\n-    builder.future_result();\n-    builder.future_result();\n-}\n+    #[test]\n+    fn test_try_future() {\n+        let result = TaskBuilder::new().try_future(proc() {});\n+        assert!(result.unwrap().is_ok());\n \n-#[test]\n-fn test_try_success() {\n-    match try(proc() {\n-        \"Success!\".to_string()\n-    }).as_ref().map(|s| s.as_slice()) {\n-        result::Ok(\"Success!\") => (),\n-        _ => fail!()\n+        let result = TaskBuilder::new().try_future(proc() -> () {\n+            fail!();\n+        });\n+        assert!(result.unwrap().is_err());\n     }\n-}\n \n-#[test]\n-fn test_try_fail() {\n-    match try(proc() {\n-        fail!()\n-    }) {\n-        result::Err(_) => (),\n-        result::Ok(()) => fail!()\n+    #[test]\n+    fn test_try_success() {\n+        match try(proc() {\n+            \"Success!\".to_string()\n+        }).as_ref().map(|s| s.as_slice()) {\n+            result::Ok(\"Success!\") => (),\n+            _ => fail!()\n+        }\n     }\n-}\n \n-#[test]\n-fn test_spawn_sched() {\n-    use clone::Clone;\n+    #[test]\n+    fn test_try_fail() {\n+        match try(proc() {\n+            fail!()\n+        }) {\n+            result::Err(_) => (),\n+            result::Ok(()) => fail!()\n+        }\n+    }\n \n-    let (tx, rx) = channel();\n+    #[test]\n+    fn test_spawn_sched() {\n+        use clone::Clone;\n \n-    fn f(i: int, tx: Sender<()>) {\n-        let tx = tx.clone();\n-        spawn(proc() {\n-            if i == 0 {\n-                tx.send(());\n-            } else {\n-                f(i - 1, tx);\n-            }\n-        });\n+        let (tx, rx) = channel();\n \n+        fn f(i: int, tx: Sender<()>) {\n+            let tx = tx.clone();\n+            spawn(proc() {\n+                if i == 0 {\n+                    tx.send(());\n+                } else {\n+                    f(i - 1, tx);\n+                }\n+            });\n+\n+        }\n+        f(10, tx);\n+        rx.recv();\n     }\n-    f(10, tx);\n-    rx.recv();\n-}\n \n-#[test]\n-fn test_spawn_sched_childs_on_default_sched() {\n-    let (tx, rx) = channel();\n+    #[test]\n+    fn test_spawn_sched_childs_on_default_sched() {\n+        let (tx, rx) = channel();\n \n-    spawn(proc() {\n         spawn(proc() {\n-            tx.send(());\n+            spawn(proc() {\n+                tx.send(());\n+            });\n         });\n-    });\n \n-    rx.recv();\n-}\n+        rx.recv();\n+    }\n \n-#[cfg(test)]\n-fn avoid_copying_the_body(spawnfn: |v: proc(): Send|) {\n-    let (tx, rx) = channel::<uint>();\n+    fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n+        let (tx, rx) = channel::<uint>();\n \n-    let x = box 1;\n-    let x_in_parent = (&*x) as *int as uint;\n+        let x = box 1;\n+        let x_in_parent = (&*x) as *int as uint;\n \n-    spawnfn(proc() {\n-        let x_in_child = (&*x) as *int as uint;\n-        tx.send(x_in_child);\n-    });\n+        spawnfn(proc() {\n+            let x_in_child = (&*x) as *int as uint;\n+            tx.send(x_in_child);\n+        });\n \n-    let x_in_child = rx.recv();\n-    assert_eq!(x_in_parent, x_in_child);\n-}\n+        let x_in_child = rx.recv();\n+        assert_eq!(x_in_parent, x_in_child);\n+    }\n \n-#[test]\n-fn test_avoid_copying_the_body_spawn() {\n-    avoid_copying_the_body(spawn);\n-}\n+    #[test]\n+    fn test_avoid_copying_the_body_spawn() {\n+        avoid_copying_the_body(spawn);\n+    }\n \n-#[test]\n-fn test_avoid_copying_the_body_task_spawn() {\n-    avoid_copying_the_body(|f| {\n-        let builder = TaskBuilder::new();\n-        builder.spawn(proc() {\n-            f();\n-        });\n-    })\n-}\n+    #[test]\n+    fn test_avoid_copying_the_body_task_spawn() {\n+        avoid_copying_the_body(|f| {\n+            let builder = TaskBuilder::new();\n+            builder.spawn(proc() {\n+                f();\n+            });\n+        })\n+    }\n \n-#[test]\n-fn test_avoid_copying_the_body_try() {\n-    avoid_copying_the_body(|f| {\n-        let _ = try(proc() {\n-            f()\n-        });\n-    })\n-}\n+    #[test]\n+    fn test_avoid_copying_the_body_try() {\n+        avoid_copying_the_body(|f| {\n+            let _ = try(proc() {\n+                f()\n+            });\n+        })\n+    }\n \n-#[test]\n-fn test_child_doesnt_ref_parent() {\n-    // If the child refcounts the parent task, this will stack overflow when\n-    // climbing the task tree to dereference each ancestor. (See #1789)\n-    // (well, it would if the constant were 8000+ - I lowered it to be more\n-    // valgrind-friendly. try this at home, instead..!)\n-    static generations: uint = 16;\n-    fn child_no(x: uint) -> proc(): Send {\n-        return proc() {\n-            if x < generations {\n-                TaskBuilder::new().spawn(child_no(x+1));\n+    #[test]\n+    fn test_child_doesnt_ref_parent() {\n+        // If the child refcounts the parent task, this will stack overflow when\n+        // climbing the task tree to dereference each ancestor. (See #1789)\n+        // (well, it would if the constant were 8000+ - I lowered it to be more\n+        // valgrind-friendly. try this at home, instead..!)\n+        static generations: uint = 16;\n+        fn child_no(x: uint) -> proc(): Send {\n+            return proc() {\n+                if x < generations {\n+                    TaskBuilder::new().spawn(child_no(x+1));\n+                }\n             }\n         }\n+        TaskBuilder::new().spawn(child_no(0));\n     }\n-    TaskBuilder::new().spawn(child_no(0));\n-}\n \n-#[test]\n-fn test_simple_newsched_spawn() {\n-    spawn(proc()())\n-}\n+    #[test]\n+    fn test_simple_newsched_spawn() {\n+        spawn(proc()())\n+    }\n \n-#[test]\n-fn test_try_fail_message_static_str() {\n-    match try(proc() {\n-        fail!(\"static string\");\n-    }) {\n-        Err(e) => {\n-            type T = &'static str;\n-            assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), \"static string\");\n+    #[test]\n+    fn test_try_fail_message_static_str() {\n+        match try(proc() {\n+            fail!(\"static string\");\n+        }) {\n+            Err(e) => {\n+                type T = &'static str;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.move::<T>().unwrap(), \"static string\");\n+            }\n+            Ok(()) => fail!()\n         }\n-        Ok(()) => fail!()\n     }\n-}\n \n-#[test]\n-fn test_try_fail_message_owned_str() {\n-    match try(proc() {\n-        fail!(\"owned string\".to_string());\n-    }) {\n-        Err(e) => {\n-            type T = String;\n-            assert!(e.is::<T>());\n-            assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_string());\n+    #[test]\n+    fn test_try_fail_message_owned_str() {\n+        match try(proc() {\n+            fail!(\"owned string\".to_string());\n+        }) {\n+            Err(e) => {\n+                type T = String;\n+                assert!(e.is::<T>());\n+                assert_eq!(*e.move::<T>().unwrap(), \"owned string\".to_string());\n+            }\n+            Ok(()) => fail!()\n         }\n-        Ok(()) => fail!()\n     }\n-}\n \n-#[test]\n-fn test_try_fail_message_any() {\n-    match try(proc() {\n-        fail!(box 413u16 as Box<Any + Send>);\n-    }) {\n-        Err(e) => {\n-            type T = Box<Any + Send>;\n-            assert!(e.is::<T>());\n-            let any = e.move::<T>().unwrap();\n-            assert!(any.is::<u16>());\n-            assert_eq!(*any.move::<u16>().unwrap(), 413u16);\n+    #[test]\n+    fn test_try_fail_message_any() {\n+        match try(proc() {\n+            fail!(box 413u16 as Box<Any + Send>);\n+        }) {\n+            Err(e) => {\n+                type T = Box<Any + Send>;\n+                assert!(e.is::<T>());\n+                let any = e.move::<T>().unwrap();\n+                assert!(any.is::<u16>());\n+                assert_eq!(*any.move::<u16>().unwrap(), 413u16);\n+            }\n+            Ok(()) => fail!()\n         }\n-        Ok(()) => fail!()\n     }\n-}\n \n-#[test]\n-fn test_try_fail_message_unit_struct() {\n-    struct Juju;\n+    #[test]\n+    fn test_try_fail_message_unit_struct() {\n+        struct Juju;\n+\n+        match try(proc() {\n+            fail!(Juju)\n+        }) {\n+            Err(ref e) if e.is::<Juju>() => {}\n+            Err(_) | Ok(()) => fail!()\n+        }\n+    }\n+\n+    #[test]\n+    fn test_stdout() {\n+        let (tx, rx) = channel();\n+        let mut reader = ChanReader::new(rx);\n+        let stdout = ChanWriter::new(tx);\n+\n+        TaskBuilder::new().stdout(box stdout as Box<Writer + Send>).try(proc() {\n+            print!(\"Hello, world!\");\n+        }).unwrap();\n \n-    match try(proc() {\n-        fail!(Juju)\n-    }) {\n-        Err(ref e) if e.is::<Juju>() => {}\n-        Err(_) | Ok(()) => fail!()\n+        let output = reader.read_to_str().unwrap();\n+        assert_eq!(output, \"Hello, world!\".to_string());\n     }\n+\n+    // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due\n+    // to the test harness apparently interfering with stderr configuration.\n }"}, {"sha": "1fe8e8fc0db346d935ce45ad723744374484be83", "filename": "src/libsync/lock.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibsync%2Flock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibsync%2Flock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flock.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -459,7 +459,7 @@ mod tests {\n     use std::prelude::*;\n     use std::comm::Empty;\n     use std::task;\n-    use std::task::TaskBuilder;\n+    use std::task::try_future;\n \n     use Arc;\n     use super::{Mutex, Barrier, RWLock};\n@@ -629,17 +629,15 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in range(0, 5) {\n             let arc3 = arc.clone();\n-            let mut builder = TaskBuilder::new();\n-            children.push(builder.future_result());\n-            builder.spawn(proc() {\n+            children.push(try_future(proc() {\n                 let lock = arc3.read();\n                 assert!(*lock >= 0);\n-            });\n+            }));\n         }\n \n         // Wait for children to pass their asserts\n         for r in children.mut_iter() {\n-            assert!(r.recv().is_ok());\n+            assert!(r.get_ref().is_ok());\n         }\n \n         // Wait for writer to finish"}, {"sha": "ce13fa2a7c6eee50d99055d4bde4cb4806eee1f3", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -19,6 +19,14 @@ use ext::build::AstBuilder;\n \n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                          -> Box<base::MacResult> {\n+    cx.span_warn(sp, \"`bytes!` is deprecated, use `b\\\"foo\\\"` literals instead\");\n+    cx.parse_sess.span_diagnostic.span_note(sp,\n+        \"see http://doc.rust-lang.org/rust.html#byte-and-byte-string-literals \\\n+         for documentation\");\n+    cx.parse_sess.span_diagnostic.span_note(sp,\n+        \"see https://github.com/rust-lang/rust/blob/master/src/etc/2014-06-rewrite-bytes-macros.py \\\n+         for an automated migration\");\n+\n     // Gather all argument expressions\n     let exprs = match get_exprs_from_tts(cx, sp, tts) {\n         None => return DummyResult::expr(sp),"}, {"sha": "1a7063c495199b6676c0a4db69b42dfeadddb2c7", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -106,7 +106,7 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n         *dst = (*src).clone();\n     }\n \n-    for c in cap.iter().map(|&x| x) {\n+    for &c in cap.iter() {\n         let cur = c as char;\n         let mut old_state = state;\n         match state {\n@@ -575,25 +575,25 @@ mod test {\n \n     #[test]\n     fn test_basic_setabf() {\n-        let s = bytes!(\"\\\\E[48;5;%p1%dm\");\n+        let s = b\"\\\\E[48;5;%p1%dm\";\n         assert_eq!(expand(s, [Number(1)], &mut Variables::new()).unwrap(),\n-                   bytes!(\"\\\\E[48;5;1m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[48;5;1m\".bytes().collect());\n     }\n \n     #[test]\n     fn test_multiple_int_constants() {\n-        assert_eq!(expand(bytes!(\"%{1}%{2}%d%d\"), [], &mut Variables::new()).unwrap(),\n-                   bytes!(\"21\").iter().map(|x| *x).collect());\n+        assert_eq!(expand(b\"%{1}%{2}%d%d\", [], &mut Variables::new()).unwrap(),\n+                   \"21\".bytes().collect());\n     }\n \n     #[test]\n     fn test_op_i() {\n         let mut vars = Variables::new();\n-        assert_eq!(expand(bytes!(\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\"),\n+        assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n                           [Number(1),Number(2),Number(3)], &mut vars),\n-                   Ok(bytes!(\"123233\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%d%p2%d%i%p1%d%p2%d\"), [], &mut vars),\n-                   Ok(bytes!(\"0011\").iter().map(|x| *x).collect()));\n+                   Ok(\"123233\".bytes().collect()));\n+        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", [], &mut vars),\n+                   Ok(\"0011\".bytes().collect()));\n     }\n \n     #[test]\n@@ -610,7 +610,7 @@ mod test {\n             } else {\n                 Number(97)\n             };\n-            let res = expand(bytes!(\"%p1\").iter().map(|x| *x).collect::<Vec<_>>()\n+            let res = expand(\"%p1\".bytes().collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                              [p],\n                              vars);\n@@ -622,13 +622,13 @@ mod test {\n             let res = expand(cap.as_bytes(), [], vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 0 stack entries\", *cap);\n-            let res = expand(bytes!(\"%{1}\").iter().map(|x| *x).collect::<Vec<_>>()\n+            let res = expand(\"%{1}\".bytes().collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                               [],\n                               vars);\n             assert!(res.is_err(),\n                     \"Binop {} succeeded incorrectly with 1 stack entry\", *cap);\n-            let res = expand(bytes!(\"%{1}%{2}\").iter().map(|x| *x).collect::<Vec<_>>()\n+            let res = expand(\"%{1}%{2}\".bytes().collect::<Vec<_>>()\n                              .append(cap.as_bytes()).as_slice(),\n                              [],\n                              vars);\n@@ -639,7 +639,7 @@ mod test {\n \n     #[test]\n     fn test_push_bad_param() {\n-        assert!(expand(bytes!(\"%pa\"), [], &mut Variables::new()).is_err());\n+        assert!(expand(b\"%pa\", [], &mut Variables::new()).is_err());\n     }\n \n     #[test]\n@@ -664,39 +664,37 @@ mod test {\n     #[test]\n     fn test_conditionals() {\n         let mut vars = Variables::new();\n-        let s = bytes!(\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\");\n+        let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n         let res = expand(s, [Number(1)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   bytes!(\"\\\\E[31m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[31m\".bytes().collect());\n         let res = expand(s, [Number(8)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   bytes!(\"\\\\E[90m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[90m\".bytes().collect());\n         let res = expand(s, [Number(42)], &mut vars);\n         assert!(res.is_ok(), res.unwrap_err());\n         assert_eq!(res.unwrap(),\n-                   bytes!(\"\\\\E[38;5;42m\").iter().map(|x| *x).collect());\n+                   \"\\\\E[38;5;42m\".bytes().collect());\n     }\n \n     #[test]\n     fn test_format() {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n-        assert_eq!(expand(bytes!(\"%p1%s%p2%2s%p3%2s%p4%.2s\"),\n+        assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n                           [String(\"foo\".to_string()),\n                            String(\"foo\".to_string()),\n                            String(\"f\".to_string()),\n                            String(\"foo\".to_string())], vars),\n-                   Ok(bytes!(\"foofoo ffo\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%:-4.2s\"), [String(\"foo\".to_string())], vars),\n-                   Ok(bytes!(\"fo  \").iter().map(|x| *x).collect()));\n-\n-        assert_eq!(expand(bytes!(\"%p1%d%p1%.3d%p1%5d%p1%:+d\"), [Number(1)], vars),\n-                   Ok(bytes!(\"1001    1+1\").iter().map(|x| *x).collect()));\n-        assert_eq!(expand(bytes!(\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\"), [Number(15), Number(27)], vars),\n-                   Ok(bytes!(\"17017  001b0X001B\").iter()\n-                                                 .map(|x| *x)\n-                                                 .collect()));\n+                   Ok(\"foofoo ffo\".bytes().collect()));\n+        assert_eq!(expand(b\"%p1%:-4.2s\", [String(\"foo\".to_string())], vars),\n+                   Ok(\"fo  \".bytes().collect()));\n+\n+        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", [Number(1)], vars),\n+                   Ok(\"1001    1+1\".bytes().collect()));\n+        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\", [Number(15), Number(27)], vars),\n+                   Ok(\"17017  001b0X001B\".bytes().collect()));\n     }\n }"}, {"sha": "916342b67434e01348b66be7ef97016935e43624", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -315,10 +315,10 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n /// Create a dummy TermInfo struct for msys terminals\n pub fn msys_terminfo() -> Box<TermInfo> {\n     let mut strings = HashMap::new();\n-    strings.insert(\"sgr0\".to_string(), Vec::from_slice(bytes!(\"\\x1b[0m\")));\n-    strings.insert(\"bold\".to_string(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n-    strings.insert(\"setaf\".to_string(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n-    strings.insert(\"setab\".to_string(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n+    strings.insert(\"sgr0\".to_string(), Vec::from_slice(b\"\\x1B[0m\"));\n+    strings.insert(\"bold\".to_string(), Vec::from_slice(b\"\\x1B[1m\"));\n+    strings.insert(\"setaf\".to_string(), Vec::from_slice(b\"\\x1B[3%p1%dm\"));\n+    strings.insert(\"setab\".to_string(), Vec::from_slice(b\"\\x1B[4%p1%dm\"));\n     box TermInfo {\n         names: vec!(\"cygwin\".to_string()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),"}, {"sha": "112ffd7c1a4a480899e26bbc345a25845d2f23b5", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1049,14 +1049,13 @@ pub fn run_test(opts: &TestOpts,\n             if nocapture {\n                 drop((stdout, stderr));\n             } else {\n-                task.opts.stdout = Some(box stdout as Box<Writer + Send>);\n-                task.opts.stderr = Some(box stderr as Box<Writer + Send>);\n+                task = task.stdout(box stdout as Box<Writer + Send>);\n+                task = task.stderr(box stderr as Box<Writer + Send>);\n             }\n-            let result_future = task.future_result();\n-            task.spawn(testfn);\n+            let result_future = task.try_future(testfn);\n \n             let stdout = reader.read_to_end().unwrap().move_iter().collect();\n-            let task_result = result_future.recv();\n+            let task_result = result_future.unwrap();\n             let test_result = calc_result(&desc, task_result.is_ok());\n             monitor_ch.send((desc.clone(), test_result, stdout));\n         })"}, {"sha": "b68b435da4bb0a7d427504083e4586d6fa4a5fce", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -209,8 +209,6 @@ impl Uuid {\n     /// * `d3` A 16-bit word\n     /// * `d4` Array of 8 octets\n     pub fn from_fields(d1: u32, d2: u16, d3: u16, d4: &[u8]) -> Uuid {\n-        use std::mem::{to_be16, to_be32};\n-\n         // First construct a temporary field-based struct\n         let mut fields = UuidFields {\n                 data1: 0,\n@@ -219,9 +217,9 @@ impl Uuid {\n                 data4: [0, ..8]\n         };\n \n-        fields.data1 = to_be32(d1);\n-        fields.data2 = to_be16(d2);\n-        fields.data3 = to_be16(d3);\n+        fields.data1 = d1.to_be();\n+        fields.data2 = d2.to_be();\n+        fields.data3 = d3.to_be();\n         slice::bytes::copy_memory(fields.data4, d4);\n \n         unsafe {\n@@ -335,16 +333,15 @@ impl Uuid {\n     ///\n     /// Example: `550e8400-e29b-41d4-a716-446655440000`\n     pub fn to_hyphenated_str(&self) -> String {\n-        use std::mem::{to_be16, to_be32};\n         // Convert to field-based struct as it matches groups in output.\n         // Ensure fields are in network byte order, as per RFC.\n         let mut uf: UuidFields;\n         unsafe {\n             uf = transmute_copy(&self.bytes);\n         }\n-        uf.data1 = to_be32(uf.data1);\n-        uf.data2 = to_be16(uf.data2);\n-        uf.data3 = to_be16(uf.data3);\n+        uf.data1 = uf.data1.to_be();\n+        uf.data2 = uf.data2.to_be();\n+        uf.data3 = uf.data3.to_be();\n         let s = format!(\"{:08x}-{:04x}-{:04x}-{:02x}{:02x}-\\\n                          {:02x}{:02x}{:02x}{:02x}{:02x}{:02x}\",\n             uf.data1,"}, {"sha": "e46c99cf4f0dd9c943ab85acb4381d33e87d165c", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -1,3 +1,11 @@\n+S 2014-06-18 d6736a1\n+  freebsd-x86_64 c1479bb3dc0ae3d8ba9193ff2caf92c805a95c51\n+  linux-i386 bb1543b21235a51e81460b9419e112396ccf1d20\n+  linux-x86_64 08df93f138bc6c9d083d28bb71384fcebf0380c1\n+  macos-i386 d6c0039ad7cbd5959e69c980ecf822e5097bac2c\n+  macos-x86_64 ee54924aa4103d35cf490da004d3cc4e48ca8fb0\n+  winnt-i386 943c99971e82847abe272df58bb7656ac3b91430\n+\n S 2014-06-14 2c6caad\n   freebsd-x86_64 0152ba43f238014f0aede7c29f1c684c21077b0b\n   linux-i386 2eb1897c25abe0d5978ff03171ca943e92666046"}, {"sha": "14155d54d73ccbdf6e5afc84e0f172f213f6fe53", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -24,7 +24,6 @@ extern crate debug;\n use std::comm;\n use std::os;\n use std::task;\n-use std::task::TaskBuilder;\n use std::uint;\n \n fn move_out<T>(_x: T) {}\n@@ -64,22 +63,20 @@ fn run(args: &[String]) {\n     let mut worker_results = Vec::new();\n     for _ in range(0u, workers) {\n         let to_child = to_child.clone();\n-        let mut builder = TaskBuilder::new();\n-        worker_results.push(builder.future_result());\n-        builder.spawn(proc() {\n+        worker_results.push(task::try_future(proc() {\n             for _ in range(0u, size / workers) {\n                 //println!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //println!(\"worker {:?} exiting\", i);\n-        });\n+        }));\n     }\n     task::spawn(proc() {\n         server(&from_parent, &to_parent);\n     });\n \n-    for r in worker_results.iter() {\n-        r.recv();\n+    for r in worker_results.move_iter() {\n+        r.unwrap();\n     }\n \n     //println!(\"sending stop message\");"}, {"sha": "7ec2796b230a7a309ab13bd9f07794d3f6d86a2d", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -19,7 +19,6 @@ extern crate debug;\n \n use std::os;\n use std::task;\n-use std::task::TaskBuilder;\n use std::uint;\n \n fn move_out<T>(_x: T) {}\n@@ -58,38 +57,34 @@ fn run(args: &[String]) {\n     let mut worker_results = Vec::new();\n     let from_parent = if workers == 1 {\n         let (to_child, from_parent) = channel();\n-        let mut builder = TaskBuilder::new();\n-        worker_results.push(builder.future_result());\n-        builder.spawn(proc() {\n+        worker_results.push(task::try_future(proc() {\n             for _ in range(0u, size / workers) {\n                 //println!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //println!(\"worker {:?} exiting\", i);\n-        });\n+        }));\n         from_parent\n     } else {\n         let (to_child, from_parent) = channel();\n         for _ in range(0u, workers) {\n             let to_child = to_child.clone();\n-            let mut builder = TaskBuilder::new();\n-            worker_results.push(builder.future_result());\n-            builder.spawn(proc() {\n+            worker_results.push(task::try_future(proc() {\n                 for _ in range(0u, size / workers) {\n                     //println!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                     to_child.send(bytes(num_bytes));\n                 }\n                 //println!(\"worker {:?} exiting\", i);\n-            });\n+            }));\n         }\n         from_parent\n     };\n     task::spawn(proc() {\n         server(&from_parent, &to_parent);\n     });\n \n-    for r in worker_results.iter() {\n-        r.recv();\n+    for r in worker_results.move_iter() {\n+        r.unwrap();\n     }\n \n     //println!(\"sending stop message\");"}, {"sha": "57a6d0e7c523d860210f5ae230400b91e5d89c7a", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -24,7 +24,6 @@ extern crate time;\n use std::os;\n use std::result::{Ok, Err};\n use std::task;\n-use std::task::TaskBuilder;\n use std::uint;\n \n fn fib(n: int) -> int {\n@@ -79,14 +78,12 @@ fn stress_task(id: int) {\n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n     for i in range(0, num_tasks) {\n-        let mut builder = TaskBuilder::new();\n-        results.push(builder.future_result());\n-        builder.spawn(proc() {\n+        results.push(task::try_future(proc() {\n             stress_task(i);\n-        });\n+        }));\n     }\n-    for r in results.iter() {\n-        r.recv();\n+    for r in results.move_iter() {\n+        r.unwrap();\n     }\n }\n "}, {"sha": "af51157bba564d53482206d65e5b99ec46d32418", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -16,7 +16,6 @@\n use std::io;\n use std::io::stdio::StdReader;\n use std::io::BufferedReader;\n-use std::num::Bitwise;\n use std::os;\n \n // Computes a single solution to a given 9x9 sudoku"}, {"sha": "c7fb646f585b9fb5c9705154bf559c17955463f1", "filename": "src/test/compile-fail/borrowck-array-double-move.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-array-double-move.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let mut a = [box 0, box 1];\n+    drop(a[0]);\n+    a[1] = box 2;\n+    drop(a[0]); //~ ERROR use of moved value: `a[..]`\n+}\n+\n+fn main() {\n+    f();\n+}\n+"}, {"sha": "5f8352d1e5229525c003c8dac7504029aecc208a", "filename": "src/test/compile-fail/macros-nonfatal-errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-nonfatal-errors.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -22,7 +22,8 @@ enum CantDeriveThose {}\n fn main() {\n     doesnt_exist!(); //~ ERROR\n \n-    bytes!(invalid); //~ ERROR\n+    bytes!(invalid); //~ ERROR non-literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n \n     asm!(invalid); //~ ERROR\n "}, {"sha": "d03696cbbbcc482f92eaecace20738dd0c464367", "filename": "src/test/compile-fail/syntax-extension-bytes-non-ascii-char-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-ascii-char-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-ascii-char-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-ascii-char-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!('\u03bb'); //~ ERROR non-ascii char literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "3a2e104818fd202435c4a5531872b20fc1db54a3", "filename": "src/test/compile-fail/syntax-extension-bytes-non-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-non-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(foo); //~ ERROR non-literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "8e7c6147758ca9354e544d1879e1182943b5279c", "filename": "src/test/compile-fail/syntax-extension-bytes-too-large-integer-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-integer-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-integer-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-integer-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(1024); //~ ERROR too large integer literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "1a9aa3753eec7747827309818eaa9894d5236a27", "filename": "src/test/compile-fail/syntax-extension-bytes-too-large-u8-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-u8-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-u8-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-large-u8-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(1024u8); //~ ERROR too large u8 literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "c2d4973594371e326bae074757d8482345971b03", "filename": "src/test/compile-fail/syntax-extension-bytes-too-small-integer-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-integer-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-integer-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-integer-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(-1024); //~ ERROR non-literal in bytes\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "ac33ffb60e294f11ba9df9373f58e980fd045125", "filename": "src/test/compile-fail/syntax-extension-bytes-too-small-u8-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-u8-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-u8-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-too-small-u8-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(-1024u8); //~ ERROR non-literal in bytes\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "f6b3659354c5ba4ef231e571588ca0a57d2b679c", "filename": "src/test/compile-fail/syntax-extension-bytes-unsupported-literal.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsyntax-extension-bytes-unsupported-literal.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let vec = bytes!(45f64); //~ ERROR unsupported literal in bytes!\n+    //~^ WARN `bytes!` is deprecated\n }"}, {"sha": "16c7dcc34ff60706f2ae58597838be7013df75b5", "filename": "src/test/debuginfo/issue14411.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fdebuginfo%2Fissue14411.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Fdebuginfo%2Fissue14411.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fissue14411.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-android: FIXME(#10381)\n+\n+// compile-flags:-g\n+\n+// No debugger interaction required: just make sure it compiles without\n+// crashing.\n+\n+fn test(a: &Vec<u8>) {\n+  print!(\"{}\", a.len());\n+}\n+\n+pub fn main() {\n+  let data = vec!();\n+  test(&data);\n+}"}, {"sha": "7fa88a7653ac4179f91c185a828e88af5279526c", "filename": "src/test/run-pass/issue-14865.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-14865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-14865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14865.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum X {\n+    Foo(uint),\n+    Bar(bool)\n+}\n+\n+fn main() {\n+    let x = match Foo(42) {\n+        Foo(..) => 1,\n+        _ if true => 0,\n+        Bar(..) => fail!(\"Oh dear\")\n+    };\n+    assert_eq!(x, 1);\n+\n+    let x = match Foo(42) {\n+        _ if true => 0,\n+        Foo(..) => 1,\n+        Bar(..) => fail!(\"Oh dear\")\n+    };\n+    assert_eq!(x, 0);\n+}"}, {"sha": "045d3cc0458f77ee00cc9cfee774df986bacf2c0", "filename": "src/test/run-pass/issue-14958.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(overloaded_calls)]\n+\n+trait Foo {}\n+\n+struct Bar;\n+\n+impl<'a> std::ops::Fn<(&'a Foo,), ()> for Bar {\n+    fn call(&self, _: (&'a Foo,)) {}\n+}\n+\n+struct Baz;\n+\n+impl Foo for Baz {}\n+\n+fn main() {\n+    let bar = Bar;\n+    let baz = &Baz;\n+    bar(baz);\n+}"}, {"sha": "4ff735708b5ab7753936e7408835ce30e9acfb39", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -13,9 +13,7 @@ use std::task::TaskBuilder;\n static generations: uint = 1024+256+128+49;\n \n fn spawn(f: proc():Send) {\n-    let mut t = TaskBuilder::new();\n-    t.opts.stack_size = Some(32 * 1024);\n-    t.spawn(f);\n+    TaskBuilder::new().stack_size(32 * 1024).spawn(f)\n }\n \n fn child_no(x: uint) -> proc():Send {"}, {"sha": "fd67b767104d502ed7a27a44f7e91f5360cc91da", "filename": "src/test/run-pass/issue-4333.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fissue-4333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4333.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -12,5 +12,5 @@ use std::io;\n \n pub fn main() {\n     let stdout = &mut io::stdout() as &mut io::Writer;\n-    stdout.write(bytes!(\"Hello!\"));\n+    stdout.write(b\"Hello!\");\n }"}, {"sha": "851f87adfc20dac8a0b72691db20eff460110b99", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -9,17 +9,14 @@\n // except according to those terms.\n \n use std::task;\n-use std::task::TaskBuilder;\n \n pub fn main() { test00(); }\n \n fn start(_task_number: int) { println!(\"Started / Finished task.\"); }\n \n fn test00() {\n     let i: int = 0;\n-    let mut builder = TaskBuilder::new();\n-    let mut result = builder.future_result();\n-    builder.spawn(proc() {\n+    let mut result = task::try_future(proc() {\n         start(i)\n     });\n \n@@ -31,7 +28,7 @@ fn test00() {\n     }\n \n     // Try joining tasks that have already finished.\n-    result.recv();\n+    result.unwrap();\n \n     println!(\"Joined task.\");\n }"}, {"sha": "cd31d15db10925d03ae24046a89f7c364f4ba26f", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,7 +10,7 @@\n \n extern crate debug;\n \n-use std::task::TaskBuilder;\n+use std::task;\n \n pub fn main() { println!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n@@ -39,14 +39,12 @@ fn test00() {\n     let mut results = Vec::new();\n     while i < number_of_tasks {\n         let tx = tx.clone();\n-        let mut builder = TaskBuilder::new();\n-        results.push(builder.future_result());\n-        builder.spawn({\n+        results.push(task::try_future({\n             let i = i;\n             proc() {\n                 test00_start(&tx, i, number_of_messages)\n             }\n-        });\n+        }));\n         i = i + 1;\n     }\n \n@@ -62,7 +60,7 @@ fn test00() {\n     }\n \n     // Join spawned tasks...\n-    for r in results.iter() { r.recv(); }\n+    for r in results.mut_iter() { r.get_ref(); }\n \n     println!(\"Completed: Final number is: \");\n     println!(\"{:?}\", sum);"}, {"sha": "a46b4513c5deecf0b4e12a7ead18685727c3de92", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -10,7 +10,7 @@\n \n extern crate debug;\n \n-use std::task::TaskBuilder;\n+use std::task;\n \n pub fn main() { test00(); }\n \n@@ -25,9 +25,7 @@ fn test00() {\n     let (tx, rx) = channel();\n     let number_of_messages: int = 10;\n \n-    let mut builder = TaskBuilder::new();\n-    let result = builder.future_result();\n-    builder.spawn(proc() {\n+    let result = task::try_future(proc() {\n         test00_start(&tx, number_of_messages);\n     });\n \n@@ -38,7 +36,7 @@ fn test00() {\n         i += 1;\n     }\n \n-    result.recv();\n+    result.unwrap();\n \n     assert_eq!(sum, number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "6a71f9df6e45ee70eff9b0cbb27d98739774fc29", "filename": "src/test/run-pass/task-stderr.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftask-stderr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-stderr.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::{ChanReader, ChanWriter};\n+use std::task::TaskBuilder;\n+\n+fn main() {\n+    let (tx, rx) = channel();\n+    let mut reader = ChanReader::new(rx);\n+    let stderr = ChanWriter::new(tx);\n+\n+    let res = TaskBuilder::new().stderr(box stderr as Box<Writer + Send>).try(proc() -> () {\n+        fail!(\"Hello, world!\")\n+    });\n+    assert!(res.is_err());\n+\n+    let output = reader.read_to_str().unwrap();\n+    assert!(output.as_slice().contains(\"Hello, world!\"));\n+}"}, {"sha": "99bf247229e059085ea5452de1286447f433b824", "filename": "src/test/run-pass/tcp-stress.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftcp-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-stress.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -60,9 +60,7 @@ fn main() {\n     let (tx, rx) = channel();\n     for _ in range(0, 1000) {\n         let tx = tx.clone();\n-        let mut builder = TaskBuilder::new();\n-        builder.opts.stack_size = Some(64 * 1024);\n-        builder.spawn(proc() {\n+        TaskBuilder::new().stack_size(64 * 1024).spawn(proc() {\n             let host = addr.ip.to_str();\n             let port = addr.port;\n             match TcpStream::connect(host.as_slice(), port) {"}, {"sha": "4355bf4127fc4f9c727d679a9cad16269971a985", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -29,7 +29,7 @@ fn test_tempdir() {\n     let path = {\n         let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n         let p = p.path();\n-        assert!(p.as_vec().ends_with(bytes!(\"foobar\")));\n+        assert!(p.as_vec().ends_with(b\"foobar\"));\n         p.clone()\n     };\n     assert!(!path.exists());"}, {"sha": "55beebbf2bc576534000f91008729a1d0bb6af9a", "filename": "src/test/run-pass/trait-coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-coercion.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -26,7 +26,7 @@ impl Trait for Struct {\n }\n \n fn foo(mut a: Box<Writer>) {\n-    a.write(bytes!(\"Hello\\n\"));\n+    a.write(b\"Hello\\n\");\n }\n \n pub fn main() {"}, {"sha": "89d204dcecbdbc03a8acd1835034b3609d2e3064", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -9,18 +9,15 @@\n // except according to those terms.\n \n use std::task;\n-use std::task::TaskBuilder;\n \n pub fn main() {\n-    let mut builder = TaskBuilder::new();\n-    let mut result = builder.future_result();\n-    builder.spawn(child);\n+    let mut result = task::try_future(child);\n     println!(\"1\");\n     task::deschedule();\n     println!(\"2\");\n     task::deschedule();\n     println!(\"3\");\n-    result.recv();\n+    result.unwrap();\n }\n \n fn child() {"}, {"sha": "d882b1abd295ddec68fa194365d6a1912dc01152", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3770c42a4959cbabc73da52abc7e3db96657974e/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=3770c42a4959cbabc73da52abc7e3db96657974e", "patch": "@@ -9,15 +9,12 @@\n // except according to those terms.\n \n use std::task;\n-use std::task::TaskBuilder;\n \n pub fn main() {\n-    let mut builder = TaskBuilder::new();\n-    let mut result = builder.future_result();\n-    builder.spawn(child);\n+    let mut result = task::try_future(child);\n     println!(\"1\");\n     task::deschedule();\n-    result.recv();\n+    result.unwrap();\n }\n \n fn child() { println!(\"2\"); }"}]}