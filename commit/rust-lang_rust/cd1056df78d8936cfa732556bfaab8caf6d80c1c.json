{"sha": "cd1056df78d8936cfa732556bfaab8caf6d80c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkMTA1NmRmNzhkODkzNmNmYTczMjU1NmJmYWFiOGNhZjZkODBjMWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-19T18:21:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-01-22T03:31:51Z"}, "message": "migrate size_of() and related funcs from trans into shape", "tree": {"sha": "29eeceb3c66030c89f589c7310bd85b61b4f796c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29eeceb3c66030c89f589c7310bd85b61b4f796c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd1056df78d8936cfa732556bfaab8caf6d80c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd1056df78d8936cfa732556bfaab8caf6d80c1c", "html_url": "https://github.com/rust-lang/rust/commit/cd1056df78d8936cfa732556bfaab8caf6d80c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd1056df78d8936cfa732556bfaab8caf6d80c1c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98fd120ac15948857084821bb3dead9a7f6b65e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/98fd120ac15948857084821bb3dead9a7f6b65e9", "html_url": "https://github.com/rust-lang/rust/commit/98fd120ac15948857084821bb3dead9a7f6b65e9"}], "stats": {"total": 554, "additions": 286, "deletions": 268}, "files": [{"sha": "8ba8f6d36aaeb9d3b95f7b610b23240ca7644bec", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 245, "deletions": 9, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -1,18 +1,26 @@\n // A \"shape\" is a compact encoding of a type that is used by interpreted glue.\n // This substitutes for the runtime tags used by e.g. MLs.\n \n-import lib::llvm::True;\n+import lib::llvm::llvm;\n+import lib::llvm::{True, False};\n import lib::llvm::llvm::{ModuleRef, TypeRef, ValueRef};\n import driver::session;\n+import driver::session::session;\n import middle::{trans, trans_common};\n-import middle::trans_common::{crate_ctxt, val_ty, C_bytes,\n-                              C_named_struct, C_struct, T_tag_variant};\n+import middle::trans_common::{crate_ctxt, val_ty, C_bytes, C_int,\n+                              C_named_struct, C_struct, T_tag_variant,\n+                              block_ctxt, result, rslt, bcx_ccx, bcx_tcx,\n+                              type_has_static_size, umax, umin, align_to,\n+                              tydesc_info};\n+import back::abi;\n import middle::ty;\n import middle::ty::field;\n import syntax::ast;\n import syntax::ast_util::dummy_sp;\n import syntax::util::interner;\n import util::common;\n+import trans_build::{Load, Store, Add, GEPi};\n+import syntax::codemap::span;\n \n import core::{vec, str};\n import std::map::hashmap;\n@@ -128,8 +136,8 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n                 // once we implement Issue #586.)\n                 check (trans_common::type_has_static_size(ccx, elem_t));\n                 let llty = trans::type_of(ccx, dummy_sp(), elem_t);\n-                min_size += trans::llsize_of_real(ccx, llty);\n-                min_align += trans::llalign_of_real(ccx, llty);\n+                min_size += llsize_of_real(ccx, llty);\n+                min_align += llalign_of_real(ccx, llty);\n             }\n         }\n \n@@ -210,8 +218,8 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n         }\n \n         let llty = trans_common::T_struct(lltys);\n-        let dp = trans::llsize_of_real(ccx, llty) as u16;\n-        let variant_align = trans::llalign_of_real(ccx, llty) as u8;\n+        let dp = llsize_of_real(ccx, llty) as u16;\n+        let variant_align = llalign_of_real(ccx, llty) as u8;\n \n         if max_size < dp { max_size = dp; }\n         if max_align < variant_align { max_align = variant_align; }\n@@ -222,8 +230,8 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     // aligned quantity, we don't align it.\n     if vec::len(*variants) > 1u {\n         let variant_t = T_tag_variant(ccx);\n-        max_size += trans::llsize_of_real(ccx, variant_t) as u16;\n-        let align = trans::llalign_of_real(ccx, variant_t) as u8;\n+        max_size += llsize_of_real(ccx, variant_t) as u16;\n+        let align = llalign_of_real(ccx, variant_t) as u8;\n         if max_align < align { max_align = align; }\n     }\n \n@@ -596,3 +604,231 @@ fn gen_shape_tables(ccx: @crate_ctxt) {\n                                         lib::llvm::llvm::Linkage);\n }\n \n+// ______________________________________________________________________\n+// compute sizeof / alignof\n+\n+fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llsize_of(bcx_ccx(cx), trans::type_of(ccx, sp, t)))\n+    } else { dynamic_size_of(cx, t) }\n+}\n+\n+fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n+    let ccx = bcx_ccx(cx);\n+    if check type_has_static_size(ccx, t) {\n+        let sp = cx.sp;\n+        rslt(cx, llalign_of(bcx_ccx(cx), trans::type_of(ccx, sp, t)))\n+    } else { dynamic_align_of(cx, t) }\n+}\n+\n+// Returns the real size of the given type for the current target.\n+fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n+}\n+\n+// Returns the real alignment of the given type for the current target.\n+fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n+    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n+}\n+\n+fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n+                               False);\n+}\n+\n+fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n+    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n+                               False);\n+}\n+\n+// Computes the size of the data part of a non-dynamically-sized enum.\n+fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n+    : type_has_static_size(cx, t) -> uint {\n+    if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n+    alt ty::struct(cx.tcx, t) {\n+      ty::ty_tag(tid, subtys) {\n+        // Compute max(variant sizes).\n+\n+        let max_size = 0u;\n+        let variants = ty::tag_variants(cx.tcx, tid);\n+        for variant: ty::variant_info in *variants {\n+            let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n+            // Perform any type parameter substitutions.\n+\n+            tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n+            // Here we possibly do a recursive call.\n+\n+            // FIXME: Avoid this check. Since the parent has static\n+            // size, any field must as well. There should be a way to\n+            // express that with constrained types.\n+            check (type_has_static_size(cx, tup_ty));\n+            let this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n+            if max_size < this_size { max_size = this_size; }\n+        }\n+        cx.tag_sizes.insert(t, max_size);\n+        ret max_size;\n+      }\n+      _ {\n+        cx.tcx.sess.span_fatal(sp, \"non-enum passed to static_size_of_tag()\");\n+      }\n+    }\n+}\n+\n+fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n+    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n+        //\n+        // C padding rules:\n+        //\n+        //\n+        //   - Pad after each element so that next element is aligned.\n+        //   - Pad after final structure member so that whole structure\n+        //     is aligned to max alignment of interior.\n+        //\n+\n+        let off = C_int(bcx_ccx(cx), 0);\n+        let max_align = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for e: ty::t in elts {\n+            let elt_align = align_of(bcx, e);\n+            bcx = elt_align.bcx;\n+            let elt_size = size_of(bcx, e);\n+            bcx = elt_size.bcx;\n+            let aligned_off = align_to(bcx, off, elt_align.val);\n+            off = Add(bcx, aligned_off, elt_size.val);\n+            max_align = umax(bcx, max_align, elt_align.val);\n+        }\n+        off = align_to(bcx, off, max_align);\n+        //off = alt mode {\n+        //  align_total. {\n+        //    align_to(bcx, off, max_align)\n+        //  }\n+        //  align_next(t) {\n+        //    let {bcx, val: align} = align_of(bcx, t);\n+        //    align_to(bcx, off, align)\n+        //  }\n+        //};\n+        ret rslt(bcx, off);\n+    }\n+    alt ty::struct(bcx_tcx(cx), t) {\n+      ty::ty_param(p, _) {\n+        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n+        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n+      }\n+      ty::ty_rec(flds) {\n+        let tys: [ty::t] = [];\n+        for f: ty::field in flds { tys += [f.mt.ty]; }\n+        ret align_elements(cx, tys);\n+      }\n+      ty::ty_tup(elts) {\n+        let tys = [];\n+        for tp in elts { tys += [tp]; }\n+        ret align_elements(cx, tys);\n+      }\n+      ty::ty_tag(tid, tps) {\n+        let bcx = cx;\n+        let ccx = bcx_ccx(bcx);\n+        // Compute max(variant sizes).\n+\n+        let max_size: ValueRef = trans::alloca(bcx, ccx.int_type);\n+        Store(bcx, C_int(ccx, 0), max_size);\n+        let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n+        for variant: ty::variant_info in *variants {\n+            // Perform type substitution on the raw argument types.\n+\n+            let raw_tys: [ty::t] = variant.args;\n+            let tys: [ty::t] = [];\n+            for raw_ty: ty::t in raw_tys {\n+                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n+                tys += [t];\n+            }\n+            let rslt = align_elements(bcx, tys);\n+            bcx = rslt.bcx;\n+            let this_size = rslt.val;\n+            let old_max_size = Load(bcx, max_size);\n+            Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n+        }\n+        let max_size_val = Load(bcx, max_size);\n+        let total_size =\n+            if vec::len(*variants) != 1u {\n+                Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n+            } else { max_size_val };\n+        ret rslt(bcx, total_size);\n+      }\n+    }\n+}\n+\n+fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n+// FIXME: Typestate constraint that shows this alt is\n+// exhaustive\n+    alt ty::struct(bcx_tcx(cx), t) {\n+      ty::ty_param(p, _) {\n+        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n+        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n+      }\n+      ty::ty_rec(flds) {\n+        let a = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for f: ty::field in flds {\n+            let align = align_of(bcx, f.mt.ty);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n+      }\n+      ty::ty_tag(_, _) {\n+        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n+      }\n+      ty::ty_tup(elts) {\n+        let a = C_int(bcx_ccx(cx), 1);\n+        let bcx = cx;\n+        for e in elts {\n+            let align = align_of(bcx, e);\n+            bcx = align.bcx;\n+            a = umax(bcx, a, align.val);\n+        }\n+        ret rslt(bcx, a);\n+      }\n+    }\n+}\n+\n+// Given a type and a field index into its corresponding type descriptor,\n+// returns an LLVM ValueRef of that field from the tydesc, generating the\n+// tydesc if necessary.\n+fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n+   result {\n+    let ti = none::<@tydesc_info>;\n+    let tydesc = trans::get_tydesc(cx, t, escapes, ti).result;\n+    ret rslt(tydesc.bcx,\n+             GEPi(tydesc.bcx, tydesc.val, [0, field]));\n+}\n+\n+// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n+// to have (a) the same size as the type that was passed in; (b) to be non-\n+// recursive. This is done by replacing all boxes in a type with boxed unit\n+// types.\n+fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n+    fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n+        alt ty::struct(ccx.tcx, typ) {\n+          ty::ty_box(_) | ty::ty_iface(_, _) {\n+            ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n+          }\n+          ty::ty_uniq(_) {\n+            ret ty::mk_imm_uniq(ccx.tcx, ty::mk_nil(ccx.tcx));\n+          }\n+          ty::ty_fn(_) {\n+            ret ty::mk_tup(ccx.tcx,\n+                           [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n+                            ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n+          }\n+          ty::ty_res(_, sub, tps) {\n+            let sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n+            ret ty::mk_tup(ccx.tcx,\n+                           [ty::mk_int(ccx.tcx), simplify_type(ccx, sub1)]);\n+          }\n+          _ { ret typ; }\n+        }\n+    }\n+    ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n+}"}, {"sha": "94d9b75fb13770b8e3d85ee73a22341560ae487d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 249, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -41,6 +41,8 @@ import link::{mangle_internal_name_by_type_only,\n               mangle_exported_name};\n import metadata::{csearch, cstore};\n import util::ppaux::{ty_to_str, ty_to_short_str};\n+import shape::{size_of, align_of, llsize_of_real, llalign_of_real,\n+               llsize_of, llalign_of, static_size_of_tag};\n \n import trans_common::*;\n import trans_build::*;\n@@ -374,63 +376,6 @@ fn trans_shared_free(cx: @block_ctxt, v: ValueRef) -> @block_ctxt {\n     ret cx;\n }\n \n-fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n-    ret Select(cx, cond, b, a);\n-}\n-\n-fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n-    let cond = ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n-    ret Select(cx, cond, a, b);\n-}\n-\n-fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n-    let mask = Sub(cx, align, C_int(bcx_ccx(cx), 1));\n-    let bumped = Add(cx, off, mask);\n-    ret And(cx, bumped, Not(cx, mask));\n-}\n-\n-\n-// Returns the real size of the given type for the current target.\n-fn llsize_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMStoreSizeOfType(cx.td.lltd, t) as uint;\n-}\n-\n-// Returns the real alignment of the given type for the current target.\n-fn llalign_of_real(cx: @crate_ctxt, t: TypeRef) -> uint {\n-    ret llvm::LLVMPreferredAlignmentOfType(cx.td.lltd, t) as uint;\n-}\n-\n-fn llsize_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMSizeOf(t), cx.int_type,\n-                               False);\n-}\n-\n-fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n-    ret llvm::LLVMConstIntCast(lib::llvm::llvm::LLVMAlignOf(t), cx.int_type,\n-                               False);\n-}\n-\n-fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    size_of_(cx, t)\n-}\n-\n-fn size_of_(cx: @block_ctxt, t: ty::t) -> result {\n-    let ccx = bcx_ccx(cx);\n-    if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n-    } else { dynamic_size_of(cx, t) }\n-}\n-\n-fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n-    let ccx = bcx_ccx(cx);\n-    if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n-    } else { dynamic_align_of(cx, t) }\n-}\n-\n fn alloca(cx: @block_ctxt, t: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(t); }\n     ret Alloca(new_raw_block_ctxt(cx.fcx, cx.fcx.llstaticallocas), t);\n@@ -467,187 +412,6 @@ fn mk_obstack_token(ccx: @crate_ctxt, fcx: @fn_ctxt) ->\n     ret Call(cx, ccx.upcalls.dynastack_mark, []);\n }\n \n-\n-// Creates a simpler, size-equivalent type. The resulting type is guaranteed\n-// to have (a) the same size as the type that was passed in; (b) to be non-\n-// recursive. This is done by replacing all boxes in a type with boxed unit\n-// types.\n-fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n-    fn simplifier(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n-        alt ty::struct(ccx.tcx, typ) {\n-          ty::ty_box(_) | ty::ty_iface(_, _) {\n-            ret ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx));\n-          }\n-          ty::ty_uniq(_) {\n-            ret ty::mk_imm_uniq(ccx.tcx, ty::mk_nil(ccx.tcx));\n-          }\n-          ty::ty_fn(_) {\n-            ret ty::mk_tup(ccx.tcx,\n-                           [ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx)),\n-                            ty::mk_imm_box(ccx.tcx, ty::mk_nil(ccx.tcx))]);\n-          }\n-          ty::ty_res(_, sub, tps) {\n-            let sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n-            ret ty::mk_tup(ccx.tcx,\n-                           [ty::mk_int(ccx.tcx), simplify_type(ccx, sub1)]);\n-          }\n-          _ { ret typ; }\n-        }\n-    }\n-    ret ty::fold_ty(ccx.tcx, ty::fm_general(bind simplifier(ccx, _)), typ);\n-}\n-\n-\n-// Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n-    : type_has_static_size(cx, t) -> uint {\n-    if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n-    alt ty::struct(cx.tcx, t) {\n-      ty::ty_tag(tid, subtys) {\n-        // Compute max(variant sizes).\n-\n-        let max_size = 0u;\n-        let variants = ty::tag_variants(cx.tcx, tid);\n-        for variant: ty::variant_info in *variants {\n-            let tup_ty = simplify_type(cx, ty::mk_tup(cx.tcx, variant.args));\n-            // Perform any type parameter substitutions.\n-\n-            tup_ty = ty::substitute_type_params(cx.tcx, subtys, tup_ty);\n-            // Here we possibly do a recursive call.\n-\n-            // FIXME: Avoid this check. Since the parent has static\n-            // size, any field must as well. There should be a way to\n-            // express that with constrained types.\n-            check (type_has_static_size(cx, tup_ty));\n-            let this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n-            if max_size < this_size { max_size = this_size; }\n-        }\n-        cx.tag_sizes.insert(t, max_size);\n-        ret max_size;\n-      }\n-      _ {\n-        cx.tcx.sess.span_fatal(sp, \"non-enum passed to static_size_of_tag()\");\n-      }\n-    }\n-}\n-\n-fn dynamic_size_of(cx: @block_ctxt, t: ty::t) -> result {\n-    fn align_elements(cx: @block_ctxt, elts: [ty::t]) -> result {\n-        //\n-        // C padding rules:\n-        //\n-        //\n-        //   - Pad after each element so that next element is aligned.\n-        //   - Pad after final structure member so that whole structure\n-        //     is aligned to max alignment of interior.\n-        //\n-\n-        let off = C_int(bcx_ccx(cx), 0);\n-        let max_align = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for e: ty::t in elts {\n-            let elt_align = align_of(bcx, e);\n-            bcx = elt_align.bcx;\n-            let elt_size = size_of(bcx, e);\n-            bcx = elt_size.bcx;\n-            let aligned_off = align_to(bcx, off, elt_align.val);\n-            off = Add(bcx, aligned_off, elt_size.val);\n-            max_align = umax(bcx, max_align, elt_align.val);\n-        }\n-        off = align_to(bcx, off, max_align);\n-        //off = alt mode {\n-        //  align_total. {\n-        //    align_to(bcx, off, max_align)\n-        //  }\n-        //  align_next(t) {\n-        //    let {bcx, val: align} = align_of(bcx, t);\n-        //    align_to(bcx, off, align)\n-        //  }\n-        //};\n-        ret rslt(bcx, off);\n-    }\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_param(p, _) {\n-        let szptr = field_of_tydesc(cx, t, false, abi::tydesc_field_size);\n-        ret rslt(szptr.bcx, Load(szptr.bcx, szptr.val));\n-      }\n-      ty::ty_rec(flds) {\n-        let tys: [ty::t] = [];\n-        for f: ty::field in flds { tys += [f.mt.ty]; }\n-        ret align_elements(cx, tys);\n-      }\n-      ty::ty_tup(elts) {\n-        let tys = [];\n-        for tp in elts { tys += [tp]; }\n-        ret align_elements(cx, tys);\n-      }\n-      ty::ty_tag(tid, tps) {\n-        let bcx = cx;\n-        let ccx = bcx_ccx(bcx);\n-        // Compute max(variant sizes).\n-\n-        let max_size: ValueRef = alloca(bcx, ccx.int_type);\n-        Store(bcx, C_int(ccx, 0), max_size);\n-        let variants = ty::tag_variants(bcx_tcx(bcx), tid);\n-        for variant: ty::variant_info in *variants {\n-            // Perform type substitution on the raw argument types.\n-\n-            let raw_tys: [ty::t] = variant.args;\n-            let tys: [ty::t] = [];\n-            for raw_ty: ty::t in raw_tys {\n-                let t = ty::substitute_type_params(bcx_tcx(cx), tps, raw_ty);\n-                tys += [t];\n-            }\n-            let rslt = align_elements(bcx, tys);\n-            bcx = rslt.bcx;\n-            let this_size = rslt.val;\n-            let old_max_size = Load(bcx, max_size);\n-            Store(bcx, umax(bcx, this_size, old_max_size), max_size);\n-        }\n-        let max_size_val = Load(bcx, max_size);\n-        let total_size =\n-            if vec::len(*variants) != 1u {\n-                Add(bcx, max_size_val, llsize_of(ccx, ccx.int_type))\n-            } else { max_size_val };\n-        ret rslt(bcx, total_size);\n-      }\n-    }\n-}\n-\n-fn dynamic_align_of(cx: @block_ctxt, t: ty::t) -> result {\n-// FIXME: Typestate constraint that shows this alt is\n-// exhaustive\n-    alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_param(p, _) {\n-        let aptr = field_of_tydesc(cx, t, false, abi::tydesc_field_align);\n-        ret rslt(aptr.bcx, Load(aptr.bcx, aptr.val));\n-      }\n-      ty::ty_rec(flds) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for f: ty::field in flds {\n-            let align = align_of(bcx, f.mt.ty);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-      ty::ty_tag(_, _) {\n-        ret rslt(cx, C_int(bcx_ccx(cx), 1)); // FIXME: stub\n-      }\n-      ty::ty_tup(elts) {\n-        let a = C_int(bcx_ccx(cx), 1);\n-        let bcx = cx;\n-        for e in elts {\n-            let align = align_of(bcx, e);\n-            bcx = align.bcx;\n-            a = umax(bcx, a, align.val);\n-        }\n-        ret rslt(bcx, a);\n-      }\n-    }\n-}\n-\n // Given a pointer p, returns a pointer sz(p) (i.e., inc'd by sz bytes).\n // The type of the returned pointer is always i8*.  If you care about the\n // return type, use bump_ptr().\n@@ -858,17 +622,6 @@ fn trans_malloc_boxed(cx: @block_ctxt, t: ty::t) ->\n \n // Type descriptor and type glue stuff\n \n-// Given a type and a field index into its corresponding type descriptor,\n-// returns an LLVM ValueRef of that field from the tydesc, generating the\n-// tydesc if necessary.\n-fn field_of_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool, field: int) ->\n-   result {\n-    let ti = none::<@tydesc_info>;\n-    let tydesc = get_tydesc(cx, t, escapes, ti).result;\n-    ret rslt(tydesc.bcx,\n-             GEPi(tydesc.bcx, tydesc.val, [0, field]));\n-}\n-\n // Given a type containing ty params, build a vector containing a ValueRef for\n // each of the ty params it uses (from the current frame) and a vector of the\n // indices of the ty params present in the type. This is used solely for"}, {"sha": "7fece0cefdfdcda22fb0f7f1e49a147797d25f9c", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -18,7 +18,6 @@ import util::ppaux::ty_to_str;\n import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n-    size_of,\n     node_id_type,\n     INIT,\n     trans_shared_free,\n@@ -27,6 +26,7 @@ import trans::{\n     load_if_immediate,\n     dest\n };\n+import shape::{size_of};\n \n // ___Good to know (tm)__________________________________________________\n //"}, {"sha": "7141117d2312d0d57e27dfd89242e5bc654082ad", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -902,6 +902,22 @@ fn hash_dict_id(&&dp: dict_id) -> uint {\n     h\n }\n \n+fn umax(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+    let cond = trans_build::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret trans_build::Select(cx, cond, b, a);\n+}\n+\n+fn umin(cx: @block_ctxt, a: ValueRef, b: ValueRef) -> ValueRef {\n+    let cond = trans_build::ICmp(cx, lib::llvm::LLVMIntULT, a, b);\n+    ret trans_build::Select(cx, cond, a, b);\n+}\n+\n+fn align_to(cx: @block_ctxt, off: ValueRef, align: ValueRef) -> ValueRef {\n+    let mask = trans_build::Sub(cx, align, C_int(bcx_ccx(cx), 1));\n+    let bumped = trans_build::Add(cx, off, mask);\n+    ret trans_build::And(cx, bumped, trans_build::Not(cx, mask));\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "b7ea546613e512bd95a027101216458b2fb8df76", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -5,7 +5,6 @@ import trans_build::*;\n import trans::{\n     trans_shared_malloc,\n     type_of_inner,\n-    size_of,\n     node_id_type,\n     INIT,\n     trans_shared_free,\n@@ -14,6 +13,7 @@ import trans::{\n     load_if_immediate,\n     dest\n };\n+import shape::{size_of};\n \n export trans_uniq, make_free_glue, type_is_unique_box, autoderef, duplicate,\n        alloc_uniq;"}, {"sha": "682078670716bbfd9873891c279435658e0660aa", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -3,11 +3,11 @@ import option::none;\n import syntax::ast;\n import lib::llvm::llvm::{ValueRef, TypeRef};\n import back::abi;\n-import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n-               INIT, copy_val, load_if_immediate, size_of,\n-               get_tydesc,\n+import trans::{call_memmove, trans_shared_malloc, type_of_or_i8,\n+               INIT, copy_val, load_if_immediate, get_tydesc,\n                node_id_type, new_sub_block_ctxt, do_spill_noroot,\n                dest};\n+import shape::{llsize_of, size_of};\n import trans_build::*;\n import trans_common::*;\n "}, {"sha": "0c3b83a4d09c87b6e4378b8f85135eccecb698f8", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd1056df78d8936cfa732556bfaab8caf6d80c1c/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=cd1056df78d8936cfa732556bfaab8caf6d80c1c", "patch": "@@ -2,15 +2,28 @@ type pair<A,B> = {\n     a: A, b: B\n };\n \n-fn f<A:send,B:send>(a: A, b: B) -> fn~() -> (A, B) {\n-    fn~() -> (A, B) { (a, b) }\n+tag rec<A> = _rec<A>;\n+type _rec<A> = {\n+    val: A,\n+    mutable rec: option<@rec<A>>\n+};\n+\n+fn make_cycle<A:copy>(a: A) {\n+    let g: @rec<A> = @rec({val: a, mutable rec: none});\n+    g.rec = some(g);\n+}\n+\n+fn f<A:send,B:send>(a: A, b: B) -> fn@() -> (A, B) {\n+    fn@() -> (A, B) { (a, b) }\n }\n \n fn main() {\n     let x = 22_u8;\n     let y = 44_u64;\n-    let (a, b) = f(~x, ~y)();\n-    #debug[\"a=%? b=%?\", *a, *b];\n+    let z = f(~x, y);\n+    make_cycle(z);\n+    let (a, b) = z();\n+    #debug[\"a=%u b=%u\", *a as uint, b as uint];\n     assert *a == x;\n-    assert *b == y;\n+    assert b == y;\n }\n\\ No newline at end of file"}]}