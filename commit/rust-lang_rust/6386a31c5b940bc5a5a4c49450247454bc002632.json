{"sha": "6386a31c5b940bc5a5a4c49450247454bc002632", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzODZhMzFjNWI5NDBiYzVhNWE0YzQ5NDUwMjQ3NDU0YmMwMDI2MzI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-04T18:29:07Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-31T15:24:54Z"}, "message": "rustc_codegen_utils: update mw's symbol mangler implementation.", "tree": {"sha": "90f97c7e071a3e76d43aba0772c23de968b3bf66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90f97c7e071a3e76d43aba0772c23de968b3bf66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6386a31c5b940bc5a5a4c49450247454bc002632", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6386a31c5b940bc5a5a4c49450247454bc002632", "html_url": "https://github.com/rust-lang/rust/commit/6386a31c5b940bc5a5a4c49450247454bc002632", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6386a31c5b940bc5a5a4c49450247454bc002632/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e5f27b1696148d584deb939a5d172ff4a4fe432", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5f27b1696148d584deb939a5d172ff4a4fe432", "html_url": "https://github.com/rust-lang/rust/commit/0e5f27b1696148d584deb939a5d172ff4a4fe432"}], "stats": {"total": 395, "additions": 223, "deletions": 172}, "files": [{"sha": "d16a9a53ddcd27b8682b891dcf8c9c412bbff8d5", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6386a31c5b940bc5a5a4c49450247454bc002632/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6386a31c5b940bc5a5a4c49450247454bc002632/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6386a31c5b940bc5a5a4c49450247454bc002632", "patch": "@@ -2699,7 +2699,7 @@ dependencies = [\n  \"rustc_metadata 0.0.0\",\n  \"rustc_mir 0.0.0\",\n  \"rustc_target 0.0.0\",\n- \"std-mangle-rs 0.1.0 (git+https://github.com/michaelwoerister/std-mangle-rs?rev=2336dcdfcc91db3cdda18eda73aca488773ac6fc)\",\n+ \"std-mangle-rs 0.1.0 (git+https://github.com/michaelwoerister/std-mangle-rs?rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -3339,7 +3339,7 @@ dependencies = [\n [[package]]\n name = \"std-mangle-rs\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/michaelwoerister/std-mangle-rs?rev=2336dcdfcc91db3cdda18eda73aca488773ac6fc#2336dcdfcc91db3cdda18eda73aca488773ac6fc\"\n+source = \"git+https://github.com/michaelwoerister/std-mangle-rs?rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c#e884304cfcb2f636db4d59ca8ad8fa95b983281c\"\n dependencies = [\n  \"unic-idna-punycode 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -4368,7 +4368,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum smallvec 0.6.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b73ea3738b47563803ef814925e69be00799a8c07420be8b996f8e98fb2336db\"\n \"checksum socket2 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c4d11a52082057d87cb5caa31ad812f4504b97ab44732cd8359df2e9ff9f48e7\"\n \"checksum stable_deref_trait 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffbc596e092fe5f598b12ef46cc03754085ac2f4d8c739ad61c4ae266cc3b3fa\"\n-\"checksum std-mangle-rs 0.1.0 (git+https://github.com/michaelwoerister/std-mangle-rs?rev=2336dcdfcc91db3cdda18eda73aca488773ac6fc)\" = \"<none>\"\n+\"checksum std-mangle-rs 0.1.0 (git+https://github.com/michaelwoerister/std-mangle-rs?rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c)\" = \"<none>\"\n \"checksum string_cache 0.7.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n \"checksum string_cache_codegen 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n \"checksum string_cache_shared 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\""}, {"sha": "4023d79df3a966ad640967bf7ae40e009eae179f", "filename": "src/librustc_codegen_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2FCargo.toml?ref=6386a31c5b940bc5a5a4c49450247454bc002632", "patch": "@@ -26,4 +26,4 @@ rustc_mir = { path = \"../librustc_mir\" }\n \n [dependencies.std-mangle-rs]\n git = \"https://github.com/michaelwoerister/std-mangle-rs\"\n-rev = \"2336dcdfcc91db3cdda18eda73aca488773ac6fc\"\n+rev = \"e884304cfcb2f636db4d59ca8ad8fa95b983281c\""}, {"sha": "c0d8fe5445bd9895499809cbfb8190137eb1e6f4", "filename": "src/librustc_codegen_utils/symbol_names/mw.rs", "status": "modified", "additions": 217, "deletions": 166, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fmw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fmw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names%2Fmw.rs?ref=6386a31c5b940bc5a5a4c49450247454bc002632", "patch": "@@ -1,12 +1,11 @@\n-use std_mangle_rs::{ast, compress::compress_ext};\n+use std_mangle_rs::ast;\n \n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId};\n use rustc::hir::map::{DefPathData, DisambiguatedDefPathData};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::print::{Printer, Print};\n use rustc::ty::subst::{Kind, UnpackedKind};\n-use rustc_data_structures::base_n;\n use rustc_mir::monomorphize::Instance;\n use rustc_target::spec::abi::Abi;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n@@ -25,25 +24,29 @@ pub(super) fn mangle(\n     }\n \n     let symbol = ast::Symbol {\n-        name: SymbolPrinter { tcx }\n+        version: None,\n+        path: SymbolPrinter { tcx }\n             .print_def_path(instance.def_id(), instance.substs)?,\n-        instantiating_crate: instantiating_crate.map(|instantiating_crate| {\n-            let fingerprint = tcx.crate_disambiguator(instantiating_crate).to_fingerprint();\n-            Arc::new(ast::PathPrefix::CrateId {\n-                name: tcx.original_crate_name(instantiating_crate).to_string(),\n-                dis: base_n::encode(fingerprint.to_smaller_hash() as u128, 62),\n-            })\n-        }),\n+        instantiating_crate: match instantiating_crate {\n+            Some(instantiating_crate) => Some(\n+                SymbolPrinter { tcx }\n+                    .path_crate(instantiating_crate)?\n+            ),\n+            None => None,\n+        },\n     };\n \n-    let mut uncompressed = String::new();\n+    let _ = symbol;\n+    unimplemented!(\"missing compressor/mangler for mw symbol mangling\");\n+\n+    /*let mut uncompressed = String::new();\n     symbol.mangle(&mut uncompressed);\n \n-    let (compressed_symbol, _) = compress_ext(&symbol);\n+    let (compressed_symbol, _) = std_mangle_rs::compress::compress_ext(&symbol);\n     let mut compressed = String::new();\n     compressed_symbol.mangle(&mut compressed);\n \n-    Ok((uncompressed, compressed))\n+    Ok((uncompressed, compressed))*/\n }\n \n #[derive(Copy, Clone)]\n@@ -54,11 +57,11 @@ struct SymbolPrinter<'a, 'tcx> {\n impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n     type Error = Unsupported;\n \n-    type Path = Arc<ast::AbsolutePath>;\n-    type Region = !;\n-    type Type = Arc<ast::Type>;\n-    type DynExistential = !;\n-    type Const = !;\n+    type Path = ast::Path;\n+    type Region = ast::Lifetime;\n+    type Type = ast::Type;\n+    type DynExistential = ast::DynBounds;\n+    type Const = ast::Const;\n \n     fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx\n@@ -84,9 +87,21 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n \n     fn print_region(\n         self,\n-        _region: ty::Region<'_>,\n+        region: ty::Region<'_>,\n     ) -> Result<Self::Region, Self::Error> {\n-        bug!(\"mw::print_region: should never be called\")\n+        let i = match *region {\n+            ty::ReErased => 0,\n+\n+            // FIXME(eddyb) copy the implementation over to here.\n+            ty::ReLateBound(_, ty::BrAnon(_)) => {\n+                return Err(Unsupported);\n+            }\n+\n+            _ => bug!(\"mw: non-erased region `{:?}`\", region),\n+        };\n+        Ok(ast::Lifetime {\n+            debruijn_index: ast::Base62Number(i),\n+        })\n     }\n \n     fn print_type(\n@@ -96,7 +111,7 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         macro_rules! basic {\n             ($name:ident) => (ast::Type::BasicType(ast::BasicType::$name))\n         }\n-        Ok(Arc::new(match ty.sty {\n+        Ok(match ty.sty {\n             ty::Bool => basic!(Bool),\n             ty::Char => basic!(Char),\n             ty::Str => basic!(Str),\n@@ -117,21 +132,34 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n             ty::Float(FloatTy::F64) => basic!(F64),\n             ty::Never => basic!(Never),\n \n-            ty::Ref(_, ty, hir::MutImmutable) => ast::Type::Ref(ty.print(self)?),\n-            ty::Ref(_, ty, hir::MutMutable) => ast::Type::RefMut(ty.print(self)?),\n+            // Placeholders (should be demangled as `_`).\n+            ty::Param(_) | ty::Bound(..) | ty::Placeholder(_) |\n+            ty::Infer(_) | ty::Error => basic!(Placeholder),\n+\n+            ty::Ref(r, ty, mutbl) => {\n+                let lt = if *r != ty::ReErased {\n+                    Some(r.print(self)?)\n+                } else {\n+                    None\n+                };\n+                let ty = Arc::new(ty.print(self)?);\n+                match mutbl {\n+                    hir::MutImmutable => ast::Type::Ref(lt, ty),\n+                    hir::MutMutable => ast::Type::RefMut(lt, ty),\n+                }\n+            }\n \n             ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::MutImmutable }) => {\n-                ast::Type::RawPtrConst(ty.print(self)?)\n+                ast::Type::RawPtrConst(Arc::new(ty.print(self)?))\n             }\n             ty::RawPtr(ty::TypeAndMut { ty, mutbl: hir::MutMutable }) => {\n-                ast::Type::RawPtrMut(ty.print(self)?)\n+                ast::Type::RawPtrMut(Arc::new(ty.print(self)?))\n             }\n \n             ty::Array(ty, len) => {\n-                let len = len.assert_usize(self.tcx()).ok_or(Unsupported)?;\n-                ast::Type::Array(Some(len), ty.print(self)?)\n+                ast::Type::Array(Arc::new(ty.print(self)?), Arc::new(len.print(self)?))\n             }\n-            ty::Slice(ty) => ast::Type::Array(None, ty.print(self)?),\n+            ty::Slice(ty) => ast::Type::Slice(Arc::new(ty.print(self)?)),\n \n             ty::Tuple(tys) => {\n                 let tys = tys.iter()\n@@ -148,74 +176,126 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n             ty::UnnormalizedProjection(ty::ProjectionTy { item_def_id: def_id, substs }) |\n             ty::Closure(def_id, ty::ClosureSubsts { substs }) |\n             ty::Generator(def_id, ty::GeneratorSubsts { substs }, _) => {\n-                ast::Type::Named(self.print_def_path(def_id, substs)?)\n+                ast::Type::Named(Arc::new(self.print_def_path(def_id, substs)?))\n             }\n             ty::Foreign(def_id) => {\n-                ast::Type::Named(self.print_def_path(def_id, &[])?)\n+                ast::Type::Named(Arc::new(self.print_def_path(def_id, &[])?))\n             }\n \n-            ty::Param(p) => ast::Type::GenericParam(ast::Ident {\n-                ident: p.name.to_string(),\n-                tag: ast::IdentTag::TypeNs,\n-                dis: ast::NumericDisambiguator(0),\n-            }),\n-\n             ty::FnPtr(sig) => {\n-                let mut params = sig.inputs().skip_binder().iter()\n+                let mut param_types = sig.inputs().skip_binder().iter()\n                     .map(|ty| ty.print(self))\n                     .collect::<Result<Vec<_>, _>>()?;\n                 if sig.c_variadic() {\n-                    params.push(Arc::new(basic!(Ellipsis)));\n+                    param_types.push(basic!(Ellipsis));\n                 }\n-                let output = *sig.output().skip_binder();\n-                let return_type = if output.is_unit() {\n-                    None\n-                } else {\n-                    Some(output.print(self)?)\n-                };\n-                ast::Type::Fn {\n+                let return_type = sig.output().skip_binder().print(self)?;\n+                ast::Type::Fn(Arc::new(ast::FnSig {\n+                    binder: ast::Binder {\n+                        // FIXME(eddyb) needs to be implemented, see `print_region`.\n+                        count: ast::Base62Number(0),\n+                    },\n                     is_unsafe: sig.unsafety() == hir::Unsafety::Unsafe,\n                     abi: match sig.abi() {\n-                        Abi::Rust => ast::Abi::Rust,\n-                        Abi::C => ast::Abi::C,\n-                        _ => return Err(Unsupported),\n+                        Abi::Rust => None,\n+                        Abi::C => Some(ast::Abi::C),\n+                        abi => Some(ast::Abi::Named(ast::UIdent(abi.name().replace('-', \"_\")))),\n                     },\n-                    params,\n+                    param_types,\n                     return_type,\n-                }\n+                }))\n+            }\n+\n+            ty::Dynamic(predicates, r) => {\n+                let bounds = Arc::new(self.print_dyn_existential(predicates.skip_binder())?);\n+                let lt = r.print(self)?;\n+                ast::Type::DynTrait(bounds, lt)\n             }\n \n-            _ => return Err(Unsupported),\n-        }))\n+            ty::GeneratorWitness(_) => {\n+                bug!(\"mw: unexpected `GeneratorWitness`\")\n+            }\n+        })\n     }\n \n     fn print_dyn_existential(\n         self,\n-        _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+        predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n-        Err(Unsupported)\n+        let mut traits = vec![];\n+        for predicate in predicates {\n+            match *predicate {\n+                ty::ExistentialPredicate::Trait(trait_ref) => {\n+                    // Use a type that can't appear in defaults of type parameters.\n+                    let dummy_self = self.tcx.mk_infer(ty::FreshTy(0));\n+                    let trait_ref = trait_ref.with_self_ty(self.tcx, dummy_self);\n+                    traits.push(ast::DynTrait {\n+                        path: self.print_def_path(trait_ref.def_id, trait_ref.substs)?,\n+                        assoc_type_bindings: vec![],\n+                    });\n+                }\n+                ty::ExistentialPredicate::Projection(projection) => {\n+                    let name = self.tcx.associated_item(projection.item_def_id).ident;\n+                    traits.last_mut().unwrap().assoc_type_bindings.push(ast::DynTraitAssocBinding {\n+                        ident: ast::UIdent(name.to_string()),\n+                        ty: projection.ty.print(self)?,\n+                    });\n+                }\n+                ty::ExistentialPredicate::AutoTrait(def_id) => {\n+                    traits.push(ast::DynTrait {\n+                        path: self.print_def_path(def_id, &[])?,\n+                        assoc_type_bindings: vec![],\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(ast::DynBounds {\n+            binder: ast::Binder {\n+                // FIXME(eddyb) needs to be implemented, see `print_region`.\n+                count: ast::Base62Number(0),\n+            },\n+            traits,\n+        })\n     }\n \n     fn print_const(\n         self,\n-        _ct: &'tcx ty::Const<'tcx>,\n+        ct: &'tcx ty::Const<'tcx>,\n     ) -> Result<Self::Const, Self::Error> {\n-        Err(Unsupported)\n+        match ct.ty.sty {\n+            ty::Uint(_) => {}\n+            _ => {\n+                bug!(\"mw: unsupported constant of type `{}` ({:?})\",\n+                    ct.ty, ct);\n+            }\n+        }\n+        let ty = ct.ty.print(self)?;\n+\n+        if let Some(bits) = ct.assert_bits(self.tcx, ty::ParamEnv::empty().and(ct.ty)) {\n+            if bits as u64 as u128 != bits {\n+                return Err(Unsupported);\n+            }\n+            Ok(ast::Const::Value(ty, bits as u64))\n+        } else {\n+            // NOTE(eddyb) despite having the path, we need to\n+            // encode a placeholder, as the path could refer\n+            // back to e.g. an `impl` using the constant.\n+            Ok(ast::Const::Placeholder(ty))\n+        }\n     }\n \n     fn path_crate(\n         self,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error> {\n         let fingerprint = self.tcx.crate_disambiguator(cnum).to_fingerprint();\n-        let path = ast::PathPrefix::CrateId {\n-            name: self.tcx.original_crate_name(cnum).to_string(),\n-            dis: base_n::encode(fingerprint.to_smaller_hash() as u128, 62),\n-        };\n-        Ok(Arc::new(ast::AbsolutePath::Path {\n-            name: Arc::new(path),\n-            args: ast::GenericArgumentList::new_empty(),\n-        }))\n+        Ok(ast::Path::CrateRoot {\n+            id: ast::Ident {\n+                dis: ast::Base62Number(fingerprint.to_smaller_hash()),\n+                u_ident: ast::UIdent(self.tcx.original_crate_name(cnum).to_string()),\n+            },\n+        })\n     }\n     fn path_qualified(\n         self,\n@@ -226,15 +306,10 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         let trait_ref = trait_ref.unwrap();\n \n         // This is a default method in the trait declaration.\n-        let path = ast::PathPrefix::TraitImpl {\n+        Ok(ast::Path::TraitDef {\n             self_type: self_ty.print(self)?,\n-            impled_trait: Some(self.print_def_path(trait_ref.def_id, trait_ref.substs)?),\n-            dis: ast::NumericDisambiguator(0),\n-        };\n-        Ok(Arc::new(ast::AbsolutePath::Path {\n-            name: Arc::new(path),\n-            args: ast::GenericArgumentList::new_empty(),\n-        }))\n+            trait_name: Arc::new(self.print_def_path(trait_ref.def_id, trait_ref.substs)?),\n+        })\n     }\n \n     fn path_append_impl(\n@@ -244,127 +319,103 @@ impl Printer<'tcx, 'tcx> for SymbolPrinter<'_, 'tcx> {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error> {\n-        let path = ast::PathPrefix::TraitImpl {\n-            // HACK(eddyb) include the `impl` prefix into the path, by nesting\n-            // another `TraitImpl` node into the Self type of the `impl`, e.g.:\n-            // `foo::<impl Tr for X>::..` becomes `<<X as foo> as Tr>::...`.\n-            self_type: Arc::new(ast::Type::Named(Arc::new(ast::AbsolutePath::Path {\n-                name: Arc::new(ast::PathPrefix::TraitImpl {\n-                    self_type: self_ty.print(self)?,\n-                    impled_trait: Some(print_prefix(self)?),\n-                    dis: ast::NumericDisambiguator(disambiguated_data.disambiguator as u64),\n-                }),\n-                args: ast::GenericArgumentList::new_empty(),\n-            }))),\n-\n-            impled_trait: match trait_ref {\n-                Some(trait_ref) => Some(\n-                    self.print_def_path(trait_ref.def_id, trait_ref.substs)?\n-                ),\n-                None => None,\n-            },\n-            dis: ast::NumericDisambiguator(0),\n+        let impl_path = ast::ImplPath {\n+            dis: Some(ast::Base62Number(disambiguated_data.disambiguator as u64)),\n+            path: Arc::new(print_prefix(self)?),\n         };\n-        Ok(Arc::new(ast::AbsolutePath::Path {\n-            name: Arc::new(path),\n-            args: ast::GenericArgumentList::new_empty(),\n-        }))\n+        let self_type = self_ty.print(self)?;\n+        match trait_ref {\n+            Some(trait_ref) => Ok(ast::Path::TraitImpl {\n+                impl_path,\n+                self_type,\n+                trait_name: Arc::new(self.print_def_path(trait_ref.def_id, trait_ref.substs)?),\n+            }),\n+            None => Ok(ast::Path::InherentImpl {\n+                impl_path,\n+                self_type,\n+            }),\n+        }\n     }\n     fn path_append(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         disambiguated_data: &DisambiguatedDefPathData,\n     ) -> Result<Self::Path, Self::Error> {\n-        let mut path = print_prefix(self)?;\n+        let inner = Arc::new(print_prefix(self)?);\n \n-        let (prefix, ast_args) = match Arc::make_mut(&mut path) {\n-            ast::AbsolutePath::Path { name, args } => (name, args),\n-            _ => unreachable!(),\n-        };\n+        let name = disambiguated_data.data.get_opt_name().map(|s| s.as_str());\n+        let name = name.as_ref().map_or(\"\", |s| &s[..]);\n+        let ns = match disambiguated_data.data {\n+            DefPathData::ClosureExpr => ast::Namespace(b'C'),\n \n-        let mut ident = match disambiguated_data.data {\n-            DefPathData::ClosureExpr => String::new(),\n-            _ => disambiguated_data.data.get_opt_name().ok_or(Unsupported)?.to_string(),\n-        };\n-\n-        let tag = match disambiguated_data.data {\n-            DefPathData::ClosureExpr => ast::IdentTag::Closure,\n-\n-            /*DefPathData::ValueNs(..) |\n-            DefPathData::Ctor |\n-            DefPathData::Field(..) => ast::IdentTag::ValueNs,*/\n-\n-            // HACK(eddyb) rather than using `ValueNs` (see above), this\n-            // encodes the disambiguated category into the identifier, so it's\n-            // lossless (see the RFC for why we can't just do type vs value).\n+            // Lowercase a-z are unspecified disambiguation categories.\n             _ => {\n-                let tag = {\n-                    let discriminant = unsafe {\n-                        ::std::intrinsics::discriminant_value(&disambiguated_data.data)\n-                    };\n-                    assert!(discriminant < 26);\n-\n-                    // Mix in the name to avoid making it too predictable.\n-                    let mut d = (discriminant ^ 0x55) % 26;\n-                    for (i, b) in ident.bytes().enumerate() {\n-                        d = (d + i as u64 + b as u64) % 26;\n-                    }\n-\n-                    (b'A' + d as u8) as char\n+                let discriminant = unsafe {\n+                    ::std::intrinsics::discriminant_value(&disambiguated_data.data)\n                 };\n-                ident.push(tag);\n+                assert!(discriminant < 26);\n \n-                ast::IdentTag::TypeNs\n-            }\n-        };\n-\n-        let dis = ast::NumericDisambiguator(disambiguated_data.disambiguator as u64);\n+                // Mix in the name to avoid making it too predictable.\n+                let mut d = (discriminant ^ 0x55) % 26;\n+                for (i, b) in name.bytes().enumerate() {\n+                    d = (d + i as u64 + b as u64) % 26;\n+                }\n \n-        let prefix = if !ast_args.is_empty() {\n-            Arc::new(ast::PathPrefix::AbsolutePath { path })\n-        } else {\n-            prefix.clone()\n+                ast::Namespace(b'a' + d as u8)\n+            }\n         };\n \n-        Ok(Arc::new(ast::AbsolutePath::Path {\n-            name: Arc::new(ast::PathPrefix::Node {\n-                prefix: prefix.clone(),\n-                ident: ast::Ident { ident, tag, dis },\n-            }),\n-            args: ast::GenericArgumentList::new_empty(),\n-        }))\n+        Ok(ast::Path::Nested {\n+            ns,\n+            inner,\n+            ident: ast::Ident {\n+                dis: ast::Base62Number(disambiguated_data.disambiguator as u64),\n+                u_ident: ast::UIdent(name.to_string()),\n+            }\n+        })\n     }\n     fn path_generic_args(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         args: &[Kind<'tcx>],\n     ) -> Result<Self::Path, Self::Error> {\n-        let mut path = print_prefix(self)?;\n+        let prefix = print_prefix(self)?;\n \n-        if args.is_empty() {\n-            return Ok(path);\n-        }\n-\n-        let ast_args = match Arc::make_mut(&mut path) {\n-            ast::AbsolutePath::Path { args, .. } => args,\n-            _ => unreachable!(),\n-        };\n+        // Don't print any regions if they're all erased.\n+        let print_regions = args.iter().any(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(r) => *r != ty::ReErased,\n+                _ => false,\n+            }\n+        });\n+        let args = args.iter().cloned().filter(|arg| {\n+            match arg.unpack() {\n+                UnpackedKind::Lifetime(_) => print_regions,\n+                _ => true,\n+            }\n+        });\n \n-        if !ast_args.is_empty() {\n-            bug!(\"mw::path_generic_args({:?}): prefix already has generic args: {:#?}\",\n-                args, path);\n+        if args.clone().next().is_none() {\n+            return Ok(prefix);\n         }\n \n-        for &arg in args {\n-            match arg.unpack() {\n-                UnpackedKind::Lifetime(_) => {}\n+        let args = args.map(|arg| {\n+            Ok(match arg.unpack() {\n+                UnpackedKind::Lifetime(lt) => {\n+                    ast::GenericArg::Lifetime(lt.print(self)?)\n+                }\n                 UnpackedKind::Type(ty) => {\n-                    ast_args.0.push(ty.print(self)?);\n+                    ast::GenericArg::Type(ty.print(self)?)\n                 }\n-                UnpackedKind::Const(_) => return Err(Unsupported),\n-            }\n-        }\n+                UnpackedKind::Const(ct) => {\n+                    ast::GenericArg::Const(ct.print(self)?)\n+                }\n+            })\n+        }).collect::<Result<Vec<_>, _>>()?;\n \n-        Ok(path)\n+        Ok(ast::Path::Generic {\n+            inner: Arc::new(prefix),\n+            args,\n+        })\n     }\n }"}, {"sha": "626ca8f6b5fc44f706da1dc9c3ae3625998e7111", "filename": "src/tools/tidy/src/extdeps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6386a31c5b940bc5a5a4c49450247454bc002632/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fextdeps.rs?ref=6386a31c5b940bc5a5a4c49450247454bc002632", "patch": "@@ -8,8 +8,8 @@ const WHITELISTED_SOURCES: &[&str] = &[\n     \"\\\"registry+https://github.com/rust-lang/crates.io-index\\\"\",\n \n     \"\\\"git+https://github.com/michaelwoerister/std-mangle-rs?\\\n-        rev=2336dcdfcc91db3cdda18eda73aca488773ac6fc#\\\n-            2336dcdfcc91db3cdda18eda73aca488773ac6fc\\\"\",\n+        rev=e884304cfcb2f636db4d59ca8ad8fa95b983281c#\\\n+            e884304cfcb2f636db4d59ca8ad8fa95b983281c\\\"\",\n ];\n \n /// Checks for external package sources."}]}