{"sha": "7fd4b52b1b83195594ef88c193fdd409b68f19ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmZDRiNTJiMWI4MzE5NTU5NGVmODhjMTkzZmRkNDA5YjY4ZjE5ZWY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-06-12T16:00:27Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-06-19T17:38:37Z"}, "message": "NLL: Broad rewrite of check_access_perimssions.\n\nTried to unify various common code paths and also vaguely approximate\nthe AST-borrowck diagnostics.\n\nThe change in (subjective) quality of diagnostics is not a universal\nimprovement. But I think this is a better code base to work from\nfor future fixes.", "tree": {"sha": "0271ea1e1cd937c2d5786a0aeca08aa86f171ef8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0271ea1e1cd937c2d5786a0aeca08aa86f171ef8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fd4b52b1b83195594ef88c193fdd409b68f19ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fd4b52b1b83195594ef88c193fdd409b68f19ef", "html_url": "https://github.com/rust-lang/rust/commit/7fd4b52b1b83195594ef88c193fdd409b68f19ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fd4b52b1b83195594ef88c193fdd409b68f19ef/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dfed7e813ae1d660ddaa4de778214b7906b87b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dfed7e813ae1d660ddaa4de778214b7906b87b3", "html_url": "https://github.com/rust-lang/rust/commit/6dfed7e813ae1d660ddaa4de778214b7906b87b3"}], "stats": {"total": 305, "additions": 205, "deletions": 100}, "files": [{"sha": "17c6bbf54898eb00526531cec08a30775f98ae47", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 205, "deletions": 100, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/7fd4b52b1b83195594ef88c193fdd409b68f19ef/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fd4b52b1b83195594ef88c193fdd409b68f19ef/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7fd4b52b1b83195594ef88c193fdd409b68f19ef", "patch": "@@ -18,7 +18,7 @@ use rustc::infer::InferCtxt;\n use rustc::ty::{self, ParamEnv, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{self, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{ClearCrossCrate, Local, Location, Place, Mir, Mutability, Operand};\n use rustc::mir::{Projection, ProjectionElem, Rvalue, Field, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -1658,36 +1658,6 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn specialized_description(&self, place:&Place<'tcx>) -> Option<String>{\n-        if let Some(_name) = self.describe_place(place) {\n-            Some(format!(\"data in a `&` reference\"))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    fn get_default_err_msg(&self, place:&Place<'tcx>) -> String{\n-        match self.describe_place(place) {\n-            Some(name) => format!(\"immutable item `{}`\", name),\n-            None => \"immutable item\".to_owned(),\n-        }\n-    }\n-\n-    fn get_secondary_err_msg(&self, place:&Place<'tcx>) -> String{\n-        match self.specialized_description(place) {\n-            Some(_) => format!(\"data in a `&` reference\"),\n-            None => self.get_default_err_msg(place)\n-        }\n-    }\n-\n-    fn get_primary_err_msg(&self, place:&Place<'tcx>) -> String{\n-        if let Some(name) = self.describe_place(place) {\n-            format!(\"`{}` is a `&` reference, so the data it refers to cannot be written\", name)\n-        } else {\n-            format!(\"cannot assign through `&`-reference\")\n-        }\n-    }\n-\n     /// Check the permissions for the given place and read or write kind\n     ///\n     /// Returns true if an error is reported, false otherwise.\n@@ -1703,6 +1673,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             place, kind, is_local_mutation_allowed\n         );\n \n+        #[derive(Copy, Clone, Debug)]\n+        enum AccessKind {\n+            MutableBorrow,\n+            Mutate,\n+        }\n+        let error_access;\n+        let the_place_err;\n+\n         match kind {\n             Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n             | Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. }))\n@@ -1720,20 +1698,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         return false;\n                     }\n                     Err(place_err) => {\n-                        let item_msg = self.get_default_err_msg(place);\n-                        let mut err = self.tcx\n-                            .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                        err.span_label(span, \"cannot borrow as mutable\");\n-\n-                        if place != place_err {\n-                            if let Some(name) = self.describe_place(place_err) {\n-                                err.note(&format!(\"the value which is causing this path not to be \\\n-                                    mutable is...: `{}`\", name));\n-                            }\n-                        }\n-\n-                        err.emit();\n-                        return true;\n+                        error_access = AccessKind::MutableBorrow;\n+                        the_place_err = place_err;\n                     }\n                 }\n             }\n@@ -1744,64 +1710,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         return false;\n                     }\n                     Err(place_err) => {\n-                        let err_info = if let Place::Projection(\n-                            box Projection {\n-                                base: Place::Local(local),\n-                                elem: ProjectionElem::Deref\n-                            }\n-                        ) = *place_err {\n-                            let locations = self.mir.find_assignments(local);\n-                            if locations.len() > 0 {\n-                                let item_msg = self.get_secondary_err_msg(&Place::Local(local));\n-                                let sp = self.mir.source_info(locations[0]).span;\n-                                let mut to_suggest_span = String::new();\n-                                if let Ok(src) =\n-                                    self.tcx.sess.codemap().span_to_snippet(sp) {\n-                                        to_suggest_span = src[1..].to_string();\n-                                };\n-                                Some((sp,\n-                                      \"consider changing this to be a \\\n-                                      mutable reference\",\n-                                      to_suggest_span,\n-                                      item_msg,\n-                                      self.get_primary_err_msg(&Place::Local(local))))\n-                            } else {\n-                                None\n-                            }\n-                        } else {\n-                            None\n-                        };\n-\n-                        if let Some((err_help_span,\n-                                     err_help_stmt,\n-                                     to_suggest_span,\n-                                     item_msg,\n-                                     sec_span)) = err_info {\n-                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                            err.span_suggestion(err_help_span,\n-                                                err_help_stmt,\n-                                                format!(\"&mut {}\", to_suggest_span));\n-                            if place != place_err {\n-                                err.span_label(span, sec_span);\n-                            }\n-                            err.emit()\n-                        } else {\n-                            let item_msg = self.get_default_err_msg(place);\n-                            let mut err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                            err.span_label(span, \"cannot mutate\");\n-                            if place != place_err {\n-                                if let Some(name) = self.describe_place(place_err) {\n-                                    err.note(&format!(\"the value which is causing this path not \\\n-                                                       to be mutable is...: `{}`\", name));\n-                                }\n-                            }\n-                            err.emit();\n-                        }\n-\n-                        return true;\n+                        error_access = AccessKind::Mutate;\n+                        the_place_err = place_err;\n                     }\n                 }\n             }\n+\n             Reservation(WriteKind::Move)\n             | Write(WriteKind::Move)\n             | Reservation(WriteKind::StorageDeadOrDrop)\n@@ -1831,6 +1745,197 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 return false;\n             }\n         }\n+\n+        // at this point, we have set up the error reporting state.\n+\n+        let mut err;\n+        let item_msg = match self.describe_place(place) {\n+            Some(name) => format!(\"immutable item `{}`\", name),\n+            None => \"immutable item\".to_owned(),\n+        };\n+\n+        // `act` and `acted_on` are strings that let us abstract over\n+        // the verbs used in some diagnostic messages.\n+        let act; let acted_on;\n+\n+        match error_access {\n+            AccessKind::Mutate => {\n+                let item_msg = match the_place_err {\n+                    Place::Projection(box Projection {\n+                        base: _,\n+                        elem: ProjectionElem::Deref }\n+                    ) => match self.describe_place(place) {\n+                        Some(description) =>\n+                            format!(\"`{}` which is behind a `&` reference\", description),\n+                        None => format!(\"data in a `&` reference\"),\n+                    },\n+                    _ => item_msg,\n+                };\n+                err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n+                act = \"assign\"; acted_on = \"written\";\n+            }\n+            AccessKind::MutableBorrow => {\n+                err = self.tcx\n+                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n+                act = \"borrow as mutable\"; acted_on = \"borrowed as mutable\";\n+            }\n+        }\n+\n+        match the_place_err {\n+            // We want to suggest users use `let mut` for local (user\n+            // variable) mutations...\n+            Place::Local(local) if local_can_be_made_mutable(self.mir, *local) => {\n+                // ... but it doesn't make sense to suggest it on\n+                // variables that are `ref x`, `ref mut x`, `&self`,\n+                // or `&mut self` (such variables are simply not\n+                // mutable)..\n+                let local_decl = &self.mir.local_decls[*local];\n+                assert_eq!(local_decl.mutability, Mutability::Not);\n+\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+                err.span_suggestion(local_decl.source_info.span,\n+                                    \"consider changing this to be mutable\",\n+                                    format!(\"mut {}\", local_decl.name.unwrap()));\n+            }\n+\n+            // complete hack to approximate old AST-borrowck\n+            // diagnostic: if the span starts with a mutable borrow of\n+            // a local variable, then just suggest the user remove it.\n+            Place::Local(_) if {\n+                if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                    snippet.starts_with(\"&mut \")\n+                } else {\n+                    false\n+                }\n+            } => {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+                err.span_label(span, \"try removing `&mut` here\");\n+            }\n+\n+            // We want to point out when a `&` can be readily replaced\n+            // with an `&mut`.\n+            //\n+            // FIXME: can this case be generalized to work for an\n+            // arbitrary base for the projection?\n+            Place::Projection(box Projection { base: Place::Local(local),\n+                                               elem: ProjectionElem::Deref })\n+                if local_is_nonref_binding(self.mir, *local) =>\n+            {\n+                let (err_help_span, suggested_code) =\n+                    find_place_to_suggest_ampmut(self.tcx, self.mir, *local);\n+                err.span_suggestion(err_help_span,\n+                                    \"consider changing this to be a mutable reference\",\n+                                    suggested_code);\n+\n+                let local_decl = &self.mir.local_decls[*local];\n+                if let Some(name) = local_decl.name {\n+                    err.span_label(\n+                        span, format!(\"`{NAME}` is a `&` reference, \\\n+                                       so the data it refers to cannot be {ACTED_ON}\",\n+                                      NAME=name, ACTED_ON=acted_on));\n+                } else {\n+                    err.span_label(span, format!(\"cannot {ACT} through `&`-reference\", ACT=act));\n+                }\n+            }\n+\n+            _ => {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT=act));\n+            }\n+        }\n+\n+        err.emit();\n+        return true;\n+\n+        // Returns true if local is a binding that can itself be made\n+        // mutable via the addition of the `mut` keyword, namely\n+        // something like:\n+        // - `fn foo(x: Type) { ... }`,\n+        // - `let x = ...`,\n+        // - or `match ... { C(x) => ... }`\n+        fn local_can_be_made_mutable(mir: &Mir, local: mir::Local) -> bool\n+        {\n+            let local = &mir.local_decls[local];\n+            match local.is_user_variable {\n+                Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                    binding_mode: ty::BindingMode::BindByValue(_),\n+                    opt_ty_info: _,\n+                }))) => true,\n+\n+                _ => false,\n+            }\n+        }\n+\n+        // Returns true if local is definitely not a `ref ident` or\n+        // `ref mut ident` binding. (Such bindings cannot be made into\n+        // mutable bindings.)\n+        fn local_is_nonref_binding(mir: &Mir, local: mir::Local) -> bool\n+        {\n+            let local = &mir.local_decls[local];\n+            match local.is_user_variable {\n+                Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                    binding_mode: ty::BindingMode::BindByValue(_),\n+                    opt_ty_info: _,\n+                }))) => true,\n+\n+                Some(ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf)) => true,\n+\n+            _ => false,\n+            }\n+        }\n+\n+        // Returns the span to highlight and the associated text to\n+        // present when suggesting that the user use an `&mut`.\n+        //\n+        // When we want to suggest a user change a local variable to be a `&mut`, there\n+        // are three potential \"obvious\" things to highlight:\n+        //\n+        // let ident [: Type] [= RightHandSideExresssion];\n+        //     ^^^^^    ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+        //     (1.)     (2.)              (3.)\n+        //\n+        // We can always fallback on highlighting the first. But chances are good that\n+        // the user experience will be better if we highlight one of the others if possible;\n+        // for example, if the RHS is present and the Type is not, then the type is going to\n+        // be inferred *from* the RHS, which means we should highlight that (and suggest\n+        // that they borrow the RHS mutably).\n+        fn find_place_to_suggest_ampmut<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+                                                         mir: &Mir<'tcx>,\n+                                                         local: Local) -> (Span, String)\n+        {\n+            // This implementation attempts to emulate AST-borrowck prioritization\n+            // by trying (3.), then (2.) and finally falling back on (1.).\n+            let locations = mir.find_assignments(local);\n+            if locations.len() > 0 {\n+                let assignment_rhs_span = mir.source_info(locations[0]).span;\n+                let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n+                if let Ok(src) = snippet {\n+                    // pnkfelix inherited code; believes intention is\n+                    // highlighted text will always be `&<expr>` and\n+                    // thus can transform to `&mut` by slicing off\n+                    // first ASCII character and prepending \"&mut \".\n+                    let borrowed_expr = src[1..].to_string();\n+                    return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n+                }\n+            }\n+\n+            let local_decl = &mir.local_decls[local];\n+            let highlight_span = match local_decl.is_user_variable {\n+                // if this is a variable binding with an explicit type,\n+                // try to highlight that for the suggestion.\n+                Some(ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                    opt_ty_info: Some(ty_span), .. }))) => ty_span,\n+\n+                Some(ClearCrossCrate::Clear) => bug!(\"saw cleared local state\"),\n+\n+                // otherwise, just highlight the span associated with\n+                // the (MIR) LocalDecl.\n+                _ => local_decl.source_info.span,\n+            };\n+\n+            let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n+            assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n+            return (highlight_span, format!(\"&mut {}\", ty_mut.ty));\n+        }\n     }\n \n     /// Adds the place into the used mutable variables set"}]}