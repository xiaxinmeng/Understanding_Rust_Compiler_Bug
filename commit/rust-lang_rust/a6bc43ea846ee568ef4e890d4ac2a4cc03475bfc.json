{"sha": "a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2YmM0M2VhODQ2ZWU1NjhlZjRlODkwZDRhYzJhNGNjMDM0NzViZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-17T23:30:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-17T23:30:08Z"}, "message": "Auto merge of #86417 - m-ou-se:rollup-vo2y1rz, r=m-ou-se\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #85925 (Linear interpolation)\n - #86202 (Specialize `io::Bytes::size_hint` for more types)\n - #86357 (Rely on libc for correct integer types in os/unix/net/ancillary.rs.)\n - #86388 (Make `s` pre-interned)\n - #86401 (Fix ICE when using `#[doc(keyword = \"...\")]` on non-items)\n - #86405 (Add incr-comp note for 1.53.0 relnotes)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8a81d4e386b32177053c95d4e0106c4af53bcf15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a81d4e386b32177053c95d4e0106c4af53bcf15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "html_url": "https://github.com/rust-lang/rust/commit/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "149f4836dd6d9e789a26dca16dc034588866894e", "url": "https://api.github.com/repos/rust-lang/rust/commits/149f4836dd6d9e789a26dca16dc034588866894e", "html_url": "https://github.com/rust-lang/rust/commit/149f4836dd6d9e789a26dca16dc034588866894e"}, {"sha": "4ec05e04d4abc3497fc35525c6bec5260c48af0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ec05e04d4abc3497fc35525c6bec5260c48af0c", "html_url": "https://github.com/rust-lang/rust/commit/4ec05e04d4abc3497fc35525c6bec5260c48af0c"}], "stats": {"total": 432, "additions": 320, "deletions": 112}, "files": [{"sha": "4b753a2b32fff9bf3c29e0c5510678323dca411c", "filename": "RELEASES.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -113,6 +113,7 @@ Compatibility Notes\n   In particular, this was known to be a problem in the `lexical-core` crate,\n   but they have published fixes for semantic versions 0.4 through 0.7. To\n   update this dependency alone, use `cargo update -p lexical-core`.\n+- Incremental compilation remains off by default, unless one uses the `RUSTC_FORCE_INCREMENTAL=1` environment variable added in 1.52.1.\n \n Internal Only\n -------------"}, {"sha": "c5f3a9d3379a7a0b6fec04f6841b303a80d450b4", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -124,12 +124,7 @@ pub fn expand_deriving_rustc_encodable(\n             explicit_self: borrowed_explicit_self(),\n             args: vec![(\n                 Ptr(Box::new(Literal(Path::new_local(typaram))), Borrowed(None, Mutability::Mut)),\n-                // FIXME: we could use `sym::s` here, but making `s` a static\n-                // symbol changes the symbol index ordering in a way that makes\n-                // ui/lint/rfc-2457-non-ascii-idents/lint-confusable-idents.rs\n-                // fail. The linting code should be fixed so that its output\n-                // does not depend on the symbol index ordering.\n-                Symbol::intern(\"s\"),\n+                sym::s,\n             )],\n             ret_ty: Literal(Path::new_(\n                 pathvec_std!(result::Result),"}, {"sha": "e85392cf0bda5b2bf615515821343d54db32f334", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -525,8 +525,11 @@ impl CheckAttrVisitor<'tcx> {\n             self.doc_attr_str_error(meta, \"keyword\");\n             return false;\n         }\n-        match self.tcx.hir().expect_item(hir_id).kind {\n-            ItemKind::Mod(ref module) => {\n+        match self.tcx.hir().find(hir_id).and_then(|node| match node {\n+            hir::Node::Item(item) => Some(&item.kind),\n+            _ => None,\n+        }) {\n+            Some(ItemKind::Mod(ref module)) => {\n                 if !module.item_ids.is_empty() {\n                     self.tcx\n                         .sess"}, {"sha": "862bde3f6a3e8fa04fa266dab34622e7dff92154", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -1062,6 +1062,7 @@ symbols! {\n         rustdoc,\n         rustfmt,\n         rvalue_static_promotion,\n+        s,\n         sanitize,\n         sanitizer_runtime,\n         saturating_add,"}, {"sha": "21bd79611a5e519d6dc6ad6ee206d36c96502b64", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -876,4 +876,40 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n+\n+    /// Linear interpolation between `start` and `end`.\n+    ///\n+    /// This enables linear interpolation between `start` and `end`, where start is represented by\n+    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n+    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n+    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n+    ///\n+    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n+    /// range from `start` to `end`. This also is useful for transition functions which might\n+    /// move slightly past the end or start for a desired effect. Mathematically, the values\n+    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n+    /// guarantees that are useful specifically to linear interpolation.\n+    ///\n+    /// These guarantees are:\n+    ///\n+    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n+    ///   value at 1.0 is always `end`. (exactness)\n+    /// * If `start` and `end` are [finite], the values will always move in the direction from\n+    ///   `start` to `end` (monotonicity)\n+    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n+    ///   `start == end`. (consistency)\n+    ///\n+    /// [finite]: #method.is_finite\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n+    pub fn lerp(self, start: f32, end: f32) -> f32 {\n+        // consistent\n+        if start == end {\n+            start\n+\n+        // exact/monotonic\n+        } else {\n+            self.mul_add(end, (-self).mul_add(start, start))\n+        }\n+    }\n }"}, {"sha": "fe66a73afd63ab7ef6d55f5dfe708640e22cde46", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -757,3 +757,66 @@ fn test_total_cmp() {\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n }\n+\n+#[test]\n+fn test_lerp_exact() {\n+    // simple values\n+    assert_eq!(f32::lerp(0.0, 2.0, 4.0), 2.0);\n+    assert_eq!(f32::lerp(1.0, 2.0, 4.0), 4.0);\n+\n+    // boundary values\n+    assert_eq!(f32::lerp(0.0, f32::MIN, f32::MAX), f32::MIN);\n+    assert_eq!(f32::lerp(1.0, f32::MIN, f32::MAX), f32::MAX);\n+}\n+\n+#[test]\n+fn test_lerp_consistent() {\n+    assert_eq!(f32::lerp(f32::MAX, f32::MIN, f32::MIN), f32::MIN);\n+    assert_eq!(f32::lerp(f32::MIN, f32::MAX, f32::MAX), f32::MAX);\n+\n+    // as long as t is finite, a/b can be infinite\n+    assert_eq!(f32::lerp(f32::MAX, f32::NEG_INFINITY, f32::NEG_INFINITY), f32::NEG_INFINITY);\n+    assert_eq!(f32::lerp(f32::MIN, f32::INFINITY, f32::INFINITY), f32::INFINITY);\n+}\n+\n+#[test]\n+fn test_lerp_nan_infinite() {\n+    // non-finite t is not NaN if a/b different\n+    assert!(!f32::lerp(f32::INFINITY, f32::MIN, f32::MAX).is_nan());\n+    assert!(!f32::lerp(f32::NEG_INFINITY, f32::MIN, f32::MAX).is_nan());\n+}\n+\n+#[test]\n+fn test_lerp_values() {\n+    // just a few basic values\n+    assert_eq!(f32::lerp(0.25, 1.0, 2.0), 1.25);\n+    assert_eq!(f32::lerp(0.50, 1.0, 2.0), 1.50);\n+    assert_eq!(f32::lerp(0.75, 1.0, 2.0), 1.75);\n+}\n+\n+#[test]\n+fn test_lerp_monotonic() {\n+    // near 0\n+    let below_zero = f32::lerp(-f32::EPSILON, f32::MIN, f32::MAX);\n+    let zero = f32::lerp(0.0, f32::MIN, f32::MAX);\n+    let above_zero = f32::lerp(f32::EPSILON, f32::MIN, f32::MAX);\n+    assert!(below_zero <= zero);\n+    assert!(zero <= above_zero);\n+    assert!(below_zero <= above_zero);\n+\n+    // near 0.5\n+    let below_half = f32::lerp(0.5 - f32::EPSILON, f32::MIN, f32::MAX);\n+    let half = f32::lerp(0.5, f32::MIN, f32::MAX);\n+    let above_half = f32::lerp(0.5 + f32::EPSILON, f32::MIN, f32::MAX);\n+    assert!(below_half <= half);\n+    assert!(half <= above_half);\n+    assert!(below_half <= above_half);\n+\n+    // near 1\n+    let below_one = f32::lerp(1.0 - f32::EPSILON, f32::MIN, f32::MAX);\n+    let one = f32::lerp(1.0, f32::MIN, f32::MAX);\n+    let above_one = f32::lerp(1.0 + f32::EPSILON, f32::MIN, f32::MAX);\n+    assert!(below_one <= one);\n+    assert!(one <= above_one);\n+    assert!(below_one <= above_one);\n+}"}, {"sha": "8c8cf73741b512aa4fa1f76833f7518ef94f4b8f", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -879,6 +879,42 @@ impl f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n+    /// Linear interpolation between `start` and `end`.\n+    ///\n+    /// This enables linear interpolation between `start` and `end`, where start is represented by\n+    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n+    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n+    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n+    ///\n+    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n+    /// range from `start` to `end`. This also is useful for transition functions which might\n+    /// move slightly past the end or start for a desired effect. Mathematically, the values\n+    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n+    /// guarantees that are useful specifically to linear interpolation.\n+    ///\n+    /// These guarantees are:\n+    ///\n+    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n+    ///   value at 1.0 is always `end`. (exactness)\n+    /// * If `start` and `end` are [finite], the values will always move in the direction from\n+    ///   `start` to `end` (monotonicity)\n+    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n+    ///   `start == end`. (consistency)\n+    ///\n+    /// [finite]: #method.is_finite\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n+    pub fn lerp(self, start: f64, end: f64) -> f64 {\n+        // consistent\n+        if start == end {\n+            start\n+\n+        // exact/monotonic\n+        } else {\n+            self.mul_add(end, (-self).mul_add(start, start))\n+        }\n+    }\n+\n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n     // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN)."}, {"sha": "04cb0109261a48068d54261a7c3cb381ed458220", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -753,3 +753,58 @@ fn test_total_cmp() {\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n }\n+\n+#[test]\n+fn test_lerp_exact() {\n+    // simple values\n+    assert_eq!(f64::lerp(0.0, 2.0, 4.0), 2.0);\n+    assert_eq!(f64::lerp(1.0, 2.0, 4.0), 4.0);\n+\n+    // boundary values\n+    assert_eq!(f64::lerp(0.0, f64::MIN, f64::MAX), f64::MIN);\n+    assert_eq!(f64::lerp(1.0, f64::MIN, f64::MAX), f64::MAX);\n+}\n+\n+#[test]\n+fn test_lerp_consistent() {\n+    assert_eq!(f64::lerp(f64::MAX, f64::MIN, f64::MIN), f64::MIN);\n+    assert_eq!(f64::lerp(f64::MIN, f64::MAX, f64::MAX), f64::MAX);\n+\n+    // as long as t is finite, a/b can be infinite\n+    assert_eq!(f64::lerp(f64::MAX, f64::NEG_INFINITY, f64::NEG_INFINITY), f64::NEG_INFINITY);\n+    assert_eq!(f64::lerp(f64::MIN, f64::INFINITY, f64::INFINITY), f64::INFINITY);\n+}\n+\n+#[test]\n+fn test_lerp_nan_infinite() {\n+    // non-finite t is not NaN if a/b different\n+    assert!(!f64::lerp(f64::INFINITY, f64::MIN, f64::MAX).is_nan());\n+    assert!(!f64::lerp(f64::NEG_INFINITY, f64::MIN, f64::MAX).is_nan());\n+}\n+\n+#[test]\n+fn test_lerp_values() {\n+    // just a few basic values\n+    assert_eq!(f64::lerp(0.25, 1.0, 2.0), 1.25);\n+    assert_eq!(f64::lerp(0.50, 1.0, 2.0), 1.50);\n+    assert_eq!(f64::lerp(0.75, 1.0, 2.0), 1.75);\n+}\n+\n+#[test]\n+fn test_lerp_monotonic() {\n+    // near 0\n+    let below_zero = f64::lerp(-f64::EPSILON, f64::MIN, f64::MAX);\n+    let zero = f64::lerp(0.0, f64::MIN, f64::MAX);\n+    let above_zero = f64::lerp(f64::EPSILON, f64::MIN, f64::MAX);\n+    assert!(below_zero <= zero);\n+    assert!(zero <= above_zero);\n+    assert!(below_zero <= above_zero);\n+\n+    // near 1\n+    let below_one = f64::lerp(1.0 - f64::EPSILON, f64::MIN, f64::MAX);\n+    let one = f64::lerp(1.0, f64::MIN, f64::MAX);\n+    let above_one = f64::lerp(1.0 + f64::EPSILON, f64::MIN, f64::MAX);\n+    assert!(below_one <= one);\n+    assert!(one <= above_one);\n+    assert!(below_one <= above_one);\n+}"}, {"sha": "32d194d9616523c6ae46a426acf602139ade7fbe", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -438,7 +438,13 @@ impl<R: Seek> Seek for BufReader<R> {\n }\n \n impl<T> SizeHint for BufReader<T> {\n+    #[inline]\n     fn lower_bound(&self) -> usize {\n-        self.buffer().len()\n+        SizeHint::lower_bound(self.get_ref()) + self.buffer().len()\n+    }\n+\n+    #[inline]\n+    fn upper_bound(&self) -> Option<usize> {\n+        SizeHint::upper_bound(self.get_ref()).and_then(|up| self.buffer().len().checked_add(up))\n     }\n }"}, {"sha": "a25ef8c87a5d23e5eeda8674241957799984e645", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -252,6 +252,7 @@\n mod tests;\n \n use crate::cmp;\n+use crate::convert::TryInto;\n use crate::fmt;\n use crate::mem::replace;\n use crate::ops::{Deref, DerefMut};\n@@ -2342,13 +2343,15 @@ impl<T: BufRead, U: BufRead> BufRead for Chain<T, U> {\n }\n \n impl<T, U> SizeHint for Chain<T, U> {\n+    #[inline]\n     fn lower_bound(&self) -> usize {\n         SizeHint::lower_bound(&self.first) + SizeHint::lower_bound(&self.second)\n     }\n \n+    #[inline]\n     fn upper_bound(&self) -> Option<usize> {\n         match (SizeHint::upper_bound(&self.first), SizeHint::upper_bound(&self.second)) {\n-            (Some(first), Some(second)) => Some(first + second),\n+            (Some(first), Some(second)) => first.checked_add(second),\n             _ => None,\n         }\n     }\n@@ -2553,6 +2556,21 @@ impl<T: BufRead> BufRead for Take<T> {\n     }\n }\n \n+impl<T> SizeHint for Take<T> {\n+    #[inline]\n+    fn lower_bound(&self) -> usize {\n+        cmp::min(SizeHint::lower_bound(&self.inner) as u64, self.limit) as usize\n+    }\n+\n+    #[inline]\n+    fn upper_bound(&self) -> Option<usize> {\n+        match SizeHint::upper_bound(&self.inner) {\n+            Some(upper_bound) => Some(cmp::min(upper_bound as u64, self.limit) as usize),\n+            None => self.limit.try_into().ok(),\n+        }\n+    }\n+}\n+\n /// An iterator over `u8` values of a reader.\n ///\n /// This struct is generally created by calling [`bytes`] on a reader.\n@@ -2597,15 +2615,53 @@ trait SizeHint {\n }\n \n impl<T> SizeHint for T {\n+    #[inline]\n     default fn lower_bound(&self) -> usize {\n         0\n     }\n \n+    #[inline]\n     default fn upper_bound(&self) -> Option<usize> {\n         None\n     }\n }\n \n+impl<T> SizeHint for &mut T {\n+    #[inline]\n+    fn lower_bound(&self) -> usize {\n+        SizeHint::lower_bound(*self)\n+    }\n+\n+    #[inline]\n+    fn upper_bound(&self) -> Option<usize> {\n+        SizeHint::upper_bound(*self)\n+    }\n+}\n+\n+impl<T> SizeHint for Box<T> {\n+    #[inline]\n+    fn lower_bound(&self) -> usize {\n+        SizeHint::lower_bound(&**self)\n+    }\n+\n+    #[inline]\n+    fn upper_bound(&self) -> Option<usize> {\n+        SizeHint::upper_bound(&**self)\n+    }\n+}\n+\n+impl SizeHint for &[u8] {\n+    #[inline]\n+    fn lower_bound(&self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn upper_bound(&self) -> Option<usize> {\n+        Some(self.len())\n+    }\n+}\n+\n /// An iterator over the contents of an instance of `BufRead` split on a\n /// particular byte.\n ///"}, {"sha": "2ee30f5fb4f08cbd7e9f98d3beb61d3dd6327345", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -224,6 +224,24 @@ fn empty_size_hint() {\n     assert_eq!(size_hint, (0, Some(0)));\n }\n \n+#[test]\n+fn slice_size_hint() {\n+    let size_hint = (&[1, 2, 3]).bytes().size_hint();\n+    assert_eq!(size_hint, (3, Some(3)));\n+}\n+\n+#[test]\n+fn take_size_hint() {\n+    let size_hint = (&[1, 2, 3]).take(2).bytes().size_hint();\n+    assert_eq!(size_hint, (2, Some(2)));\n+\n+    let size_hint = (&[1, 2, 3]).take(4).bytes().size_hint();\n+    assert_eq!(size_hint, (3, Some(3)));\n+\n+    let size_hint = io::repeat(0).take(3).bytes().size_hint();\n+    assert_eq!(size_hint, (3, Some(3)));\n+}\n+\n #[test]\n fn chain_empty_size_hint() {\n     let chain = io::empty().chain(io::empty());\n@@ -242,7 +260,7 @@ fn chain_size_hint() {\n \n     let chain = buf_reader_1.chain(buf_reader_2);\n     let size_hint = chain.bytes().size_hint();\n-    assert_eq!(size_hint, (testdata.len(), None));\n+    assert_eq!(size_hint, (testdata.len(), Some(testdata.len())));\n }\n \n #[test]"}, {"sha": "f3bff391fb3eaef60cca23ec8b1efb4fd89f7a07", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -83,6 +83,7 @@ impl fmt::Debug for Empty {\n }\n \n impl SizeHint for Empty {\n+    #[inline]\n     fn upper_bound(&self) -> Option<usize> {\n         Some(0)\n     }\n@@ -147,6 +148,18 @@ impl Read for Repeat {\n     }\n }\n \n+impl SizeHint for Repeat {\n+    #[inline]\n+    fn lower_bound(&self) -> usize {\n+        usize::MAX\n+    }\n+\n+    #[inline]\n+    fn upper_bound(&self) -> Option<usize> {\n+        None\n+    }\n+}\n+\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Repeat {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "664cc748ca6db6f28fff2ee5beeec903880e1166", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -268,6 +268,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n+#![feature(float_interpolation)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]"}, {"sha": "cd429d1426937e60dff18ce8ad96af2e5ac27fed", "filename": "library/std/src/os/unix/net/ancillary.rs", "status": "modified", "additions": 10, "deletions": 100, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fancillary.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -32,23 +32,8 @@ pub(super) fn recv_vectored_with_ancillary_from(\n         msg.msg_name = &mut msg_name as *mut _ as *mut _;\n         msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n         msg.msg_iov = bufs.as_mut_ptr().cast();\n-        cfg_if::cfg_if! {\n-            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n-                msg.msg_iovlen = bufs.len() as libc::size_t;\n-                msg.msg_controllen = ancillary.buffer.len() as libc::size_t;\n-            } else if #[cfg(any(\n-                          target_os = \"dragonfly\",\n-                          target_os = \"emscripten\",\n-                          target_os = \"freebsd\",\n-                          all(target_os = \"linux\", target_env = \"musl\",),\n-                          target_os = \"macos\",\n-                          target_os = \"netbsd\",\n-                          target_os = \"openbsd\",\n-                      ))] {\n-                msg.msg_iovlen = bufs.len() as libc::c_int;\n-                msg.msg_controllen = ancillary.buffer.len() as libc::socklen_t;\n-            }\n-        }\n+        msg.msg_iovlen = bufs.len() as _;\n+        msg.msg_controllen = ancillary.buffer.len() as _;\n         // macos requires that the control pointer is null when the len is 0.\n         if msg.msg_controllen > 0 {\n             msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n@@ -80,23 +65,8 @@ pub(super) fn send_vectored_with_ancillary_to(\n         msg.msg_name = &mut msg_name as *mut _ as *mut _;\n         msg.msg_namelen = msg_namelen;\n         msg.msg_iov = bufs.as_ptr() as *mut _;\n-        cfg_if::cfg_if! {\n-            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n-                msg.msg_iovlen = bufs.len() as libc::size_t;\n-                msg.msg_controllen = ancillary.length as libc::size_t;\n-            } else if #[cfg(any(\n-                          target_os = \"dragonfly\",\n-                          target_os = \"emscripten\",\n-                          target_os = \"freebsd\",\n-                          all(target_os = \"linux\", target_env = \"musl\",),\n-                          target_os = \"macos\",\n-                          target_os = \"netbsd\",\n-                          target_os = \"openbsd\",\n-                      ))] {\n-                msg.msg_iovlen = bufs.len() as libc::c_int;\n-                msg.msg_controllen = ancillary.length as libc::socklen_t;\n-            }\n-        }\n+        msg.msg_iovlen = bufs.len() as _;\n+        msg.msg_controllen = ancillary.length as _;\n         // macos requires that the control pointer is null when the len is 0.\n         if msg.msg_controllen > 0 {\n             msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n@@ -144,21 +114,7 @@ fn add_to_ancillary_data<T>(\n \n         let mut msg: libc::msghdr = zeroed();\n         msg.msg_control = buffer.as_mut_ptr().cast();\n-        cfg_if::cfg_if! {\n-            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n-                msg.msg_controllen = *length as libc::size_t;\n-            } else if #[cfg(any(\n-                          target_os = \"dragonfly\",\n-                          target_os = \"emscripten\",\n-                          target_os = \"freebsd\",\n-                          all(target_os = \"linux\", target_env = \"musl\",),\n-                          target_os = \"macos\",\n-                          target_os = \"netbsd\",\n-                          target_os = \"openbsd\",\n-                      ))] {\n-                msg.msg_controllen = *length as libc::socklen_t;\n-            }\n-        }\n+        msg.msg_controllen = *length as _;\n \n         let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n         let mut previous_cmsg = cmsg;\n@@ -180,21 +136,7 @@ fn add_to_ancillary_data<T>(\n \n         (*previous_cmsg).cmsg_level = cmsg_level;\n         (*previous_cmsg).cmsg_type = cmsg_type;\n-        cfg_if::cfg_if! {\n-            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n-                (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as libc::size_t;\n-            } else if #[cfg(any(\n-                          target_os = \"dragonfly\",\n-                          target_os = \"emscripten\",\n-                          target_os = \"freebsd\",\n-                          all(target_os = \"linux\", target_env = \"musl\",),\n-                          target_os = \"macos\",\n-                          target_os = \"netbsd\",\n-                          target_os = \"openbsd\",\n-                      ))] {\n-                (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as libc::socklen_t;\n-            }\n-        }\n+        (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as _;\n \n         let data = libc::CMSG_DATA(previous_cmsg).cast();\n \n@@ -364,28 +306,10 @@ impl<'a> AncillaryData<'a> {\n \n     fn try_from_cmsghdr(cmsg: &'a libc::cmsghdr) -> Result<Self, AncillaryError> {\n         unsafe {\n-            cfg_if::cfg_if! {\n-                if #[cfg(any(\n-                        target_os = \"android\",\n-                        all(target_os = \"linux\", target_env = \"gnu\"),\n-                        all(target_os = \"linux\", target_env = \"uclibc\"),\n-                   ))] {\n-                    let cmsg_len_zero = libc::CMSG_LEN(0) as libc::size_t;\n-                } else if #[cfg(any(\n-                              target_os = \"dragonfly\",\n-                              target_os = \"emscripten\",\n-                              target_os = \"freebsd\",\n-                              all(target_os = \"linux\", target_env = \"musl\",),\n-                              target_os = \"macos\",\n-                              target_os = \"netbsd\",\n-                              target_os = \"openbsd\",\n-                          ))] {\n-                    let cmsg_len_zero = libc::CMSG_LEN(0) as libc::socklen_t;\n-                }\n-            }\n-            let data_len = (*cmsg).cmsg_len - cmsg_len_zero;\n+            let cmsg_len_zero = libc::CMSG_LEN(0) as usize;\n+            let data_len = (*cmsg).cmsg_len as usize - cmsg_len_zero;\n             let data = libc::CMSG_DATA(cmsg).cast();\n-            let data = from_raw_parts(data, data_len as usize);\n+            let data = from_raw_parts(data, data_len);\n \n             match (*cmsg).cmsg_level {\n                 libc::SOL_SOCKET => match (*cmsg).cmsg_type {\n@@ -419,21 +343,7 @@ impl<'a> Iterator for Messages<'a> {\n         unsafe {\n             let mut msg: libc::msghdr = zeroed();\n             msg.msg_control = self.buffer.as_ptr() as *mut _;\n-            cfg_if::cfg_if! {\n-                if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n-                    msg.msg_controllen = self.buffer.len() as libc::size_t;\n-                } else if #[cfg(any(\n-                              target_os = \"dragonfly\",\n-                              target_os = \"emscripten\",\n-                              target_os = \"freebsd\",\n-                              all(target_os = \"linux\", target_env = \"musl\",),\n-                              target_os = \"macos\",\n-                              target_os = \"netbsd\",\n-                              target_os = \"openbsd\",\n-                          ))] {\n-                    msg.msg_controllen = self.buffer.len() as libc::socklen_t;\n-                }\n-            }\n+            msg.msg_controllen = self.buffer.len() as _;\n \n             let cmsg = if let Some(current) = self.current {\n                 libc::CMSG_NXTHDR(&msg, current)"}, {"sha": "4518f77ef933dec06e287d9104895f23b62549d2", "filename": "src/test/ui/rustdoc/doc_keyword.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -10,3 +10,11 @@ mod foo {\n \n #[doc(keyword = \"hall\")] //~ ERROR\n fn foo() {}\n+\n+\n+// Regression test for the ICE described in #83512.\n+trait Foo {\n+    #[doc(keyword = \"match\")]\n+    //~^ ERROR: `#[doc(keyword = \"...\")]` can only be used on modules\n+    fn quux() {}\n+}"}, {"sha": "6ba7034d5412212acfa48d3873a7026d84573b06", "filename": "src/test/ui/rustdoc/doc_keyword.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr?ref=a6bc43ea846ee568ef4e890d4ac2a4cc03475bfc", "patch": "@@ -10,11 +10,17 @@ error: `#[doc(keyword = \"...\")]` can only be used on modules\n LL | #[doc(keyword = \"hall\")]\n    |       ^^^^^^^^^^^^^^^^\n \n+error: `#[doc(keyword = \"...\")]` can only be used on modules\n+  --> $DIR/doc_keyword.rs:17:11\n+   |\n+LL |     #[doc(keyword = \"match\")]\n+   |           ^^^^^^^^^^^^^^^^^\n+\n error: `#![doc(keyword = \"...\")]` isn't allowed as a crate-level attribute\n   --> $DIR/doc_keyword.rs:4:8\n    |\n LL | #![doc(keyword = \"hello\")]\n    |        ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n "}]}