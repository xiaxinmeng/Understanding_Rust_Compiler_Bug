{"sha": "81609960fa30ea92e37b23dc7b025d1939626812", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNjA5OTYwZmEzMGVhOTJlMzdiMjNkYzdiMDI1ZDE5Mzk2MjY4MTI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-23T10:38:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-23T10:38:30Z"}, "message": "Merge #6324\n\n6324: Improve #[cfg] diagnostics r=jonas-schievink a=jonas-schievink\n\nUnfortunately I ran into https://github.com/rust-analyzer/rust-analyzer/issues/4058 while testing this on https://github.com/nrf-rs/nrf-hal/, so I didn't see much of it in action yet, but it does seem to work.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "835866b358bd597e1a2c481b93641418c2562c86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/835866b358bd597e1a2c481b93641418c2562c86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81609960fa30ea92e37b23dc7b025d1939626812", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfkrKmCRBK7hj4Ov3rIwAAdHIIAFojzFy+fgZ1HZon7K1dOmU3\nt3EmqKTE+7MrXo/1z025I2p20cpoBU1n3wuC8mqaxMQwQB24Pv01XSma1f3TLEZB\nV+HCxYg2TRcSCT09jrzcWNv0b6ljzf6NWt16Rv4oXp2zpPmToUZ1sgY5w94wrKiH\nDxY1iaqRR3xKXL0kZQvu01IvNbBfmDILpIABtzwv1TBDinMCy0yuzFE4V0abFTuW\nDWtNSdxyq08504siNO4/UAW8v7zOB6x9WufreG4xCZAIlCf92arKa7QXTp9xu8Uz\nyrL7DeD/x91035SgKIdgQAxflQVzvTlSdNcOD8C/yFsgeVViuTZ0I+7ZDy39Mro=\n=gVZf\n-----END PGP SIGNATURE-----\n", "payload": "tree 835866b358bd597e1a2c481b93641418c2562c86\nparent 8b3c851dd37f39f79e7e8807378f45fdde7f6411\nparent a246d4f599dcf2612fa99720fb4ca98101ed93fb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1603449510 +0000\ncommitter GitHub <noreply@github.com> 1603449510 +0000\n\nMerge #6324\n\n6324: Improve #[cfg] diagnostics r=jonas-schievink a=jonas-schievink\n\nUnfortunately I ran into https://github.com/rust-analyzer/rust-analyzer/issues/4058 while testing this on https://github.com/nrf-rs/nrf-hal/, so I didn't see much of it in action yet, but it does seem to work.\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81609960fa30ea92e37b23dc7b025d1939626812", "html_url": "https://github.com/rust-lang/rust/commit/81609960fa30ea92e37b23dc7b025d1939626812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81609960fa30ea92e37b23dc7b025d1939626812/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b3c851dd37f39f79e7e8807378f45fdde7f6411", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b3c851dd37f39f79e7e8807378f45fdde7f6411", "html_url": "https://github.com/rust-lang/rust/commit/8b3c851dd37f39f79e7e8807378f45fdde7f6411"}, {"sha": "a246d4f599dcf2612fa99720fb4ca98101ed93fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a246d4f599dcf2612fa99720fb4ca98101ed93fb", "html_url": "https://github.com/rust-lang/rust/commit/a246d4f599dcf2612fa99720fb4ca98101ed93fb"}], "stats": {"total": 956, "additions": 816, "deletions": 140}, "files": [{"sha": "8bafc38952377b566ea008d1f5a8ae9ed73f372e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -162,6 +162,7 @@ checksum = \"ed67cbde08356238e75fc4656be4749481eeffb09e19f320a25237d5221c985d\"\n name = \"cfg\"\n version = \"0.0.0\"\n dependencies = [\n+ \"expect-test\",\n  \"mbe\",\n  \"rustc-hash\",\n  \"syntax\","}, {"sha": "c68e391c1bd514183e73ad4a2fcacabb89d63740", "filename": "crates/cfg/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2FCargo.toml?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -17,3 +17,4 @@ tt = { path = \"../tt\", version = \"0.0.0\" }\n [dev-dependencies]\n mbe = { path = \"../mbe\" }\n syntax = { path = \"../syntax\" }\n+expect-test = \"1.0\""}, {"sha": "42327f1e147bbbadf2aaae0b9411aec2cea3434c", "filename": "crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 55, "deletions": 58, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -2,30 +2,77 @@\n //!\n //! See: https://doc.rust-lang.org/reference/conditional-compilation.html#conditional-compilation\n \n-use std::slice::Iter as SliceIter;\n+use std::{fmt, slice::Iter as SliceIter};\n \n use tt::SmolStr;\n \n+/// A simple configuration value passed in from the outside.\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n+pub enum CfgAtom {\n+    /// eg. `#[cfg(test)]`\n+    Flag(SmolStr),\n+    /// eg. `#[cfg(target_os = \"linux\")]`\n+    ///\n+    /// Note that a key can have multiple values that are all considered \"active\" at the same time.\n+    /// For example, `#[cfg(target_feature = \"sse\")]` and `#[cfg(target_feature = \"sse2\")]`.\n+    KeyValue { key: SmolStr, value: SmolStr },\n+}\n+\n+impl CfgAtom {\n+    /// Returns `true` when the atom comes from the target specification.\n+    ///\n+    /// If this returns `true`, then changing this atom requires changing the compilation target. If\n+    /// it returns `false`, the atom might come from a build script or the build system.\n+    pub fn is_target_defined(&self) -> bool {\n+        match self {\n+            CfgAtom::Flag(flag) => matches!(&**flag, \"unix\" | \"windows\"),\n+            CfgAtom::KeyValue { key, value: _ } => matches!(\n+                &**key,\n+                \"target_arch\"\n+                    | \"target_os\"\n+                    | \"target_env\"\n+                    | \"target_family\"\n+                    | \"target_endian\"\n+                    | \"target_pointer_width\"\n+                    | \"target_vendor\" // NOTE: `target_feature` is left out since it can be configured via `-Ctarget-feature`\n+            ),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CfgAtom {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CfgAtom::Flag(name) => write!(f, \"{}\", name),\n+            CfgAtom::KeyValue { key, value } => write!(f, \"{} = {:?}\", key, value),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum CfgExpr {\n     Invalid,\n-    Atom(SmolStr),\n-    KeyValue { key: SmolStr, value: SmolStr },\n+    Atom(CfgAtom),\n     All(Vec<CfgExpr>),\n     Any(Vec<CfgExpr>),\n     Not(Box<CfgExpr>),\n }\n \n+impl From<CfgAtom> for CfgExpr {\n+    fn from(atom: CfgAtom) -> Self {\n+        CfgExpr::Atom(atom)\n+    }\n+}\n+\n impl CfgExpr {\n     pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n         next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n     }\n     /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n-    pub fn fold(&self, query: &dyn Fn(&SmolStr, Option<&SmolStr>) -> bool) -> Option<bool> {\n+    pub fn fold(&self, query: &dyn Fn(&CfgAtom) -> bool) -> Option<bool> {\n         match self {\n             CfgExpr::Invalid => None,\n-            CfgExpr::Atom(name) => Some(query(name, None)),\n-            CfgExpr::KeyValue { key, value } => Some(query(key, Some(value))),\n+            CfgExpr::Atom(atom) => Some(query(atom)),\n             CfgExpr::All(preds) => {\n                 preds.iter().try_fold(true, |s, pred| Some(s && pred.fold(query)?))\n             }\n@@ -54,7 +101,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n                     // FIXME: escape? raw string?\n                     let value =\n                         SmolStr::new(literal.text.trim_start_matches('\"').trim_end_matches('\"'));\n-                    CfgExpr::KeyValue { key: name, value }\n+                    CfgAtom::KeyValue { key: name, value }.into()\n                 }\n                 _ => return Some(CfgExpr::Invalid),\n             }\n@@ -70,7 +117,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n                 _ => CfgExpr::Invalid,\n             }\n         }\n-        _ => CfgExpr::Atom(name),\n+        _ => CfgAtom::Flag(name).into(),\n     };\n \n     // Eat comma separator\n@@ -81,53 +128,3 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n     }\n     Some(ret)\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use mbe::ast_to_token_tree;\n-    use syntax::ast::{self, AstNode};\n-\n-    fn assert_parse_result(input: &str, expected: CfgExpr) {\n-        let (tt, _) = {\n-            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-            ast_to_token_tree(&tt).unwrap()\n-        };\n-        let cfg = CfgExpr::parse(&tt);\n-        assert_eq!(cfg, expected);\n-    }\n-\n-    #[test]\n-    fn test_cfg_expr_parser() {\n-        assert_parse_result(\"#![cfg(foo)]\", CfgExpr::Atom(\"foo\".into()));\n-        assert_parse_result(\"#![cfg(foo,)]\", CfgExpr::Atom(\"foo\".into()));\n-        assert_parse_result(\n-            \"#![cfg(not(foo))]\",\n-            CfgExpr::Not(Box::new(CfgExpr::Atom(\"foo\".into()))),\n-        );\n-        assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n-\n-        // Only take the first\n-        assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgExpr::Atom(\"foo\".into()));\n-\n-        assert_parse_result(\n-            r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n-            CfgExpr::All(vec![\n-                CfgExpr::Atom(\"foo\".into()),\n-                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n-            ]),\n-        );\n-\n-        assert_parse_result(\n-            r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n-            CfgExpr::Any(vec![\n-                CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n-                CfgExpr::All(vec![]),\n-                CfgExpr::Invalid,\n-                CfgExpr::KeyValue { key: \"bar\".into(), value: \"baz\".into() },\n-            ]),\n-        );\n-    }\n-}"}, {"sha": "580c9a9a2c1832d50f7845089cf0ad8936c981f0", "filename": "crates/cfg/src/dnf.rs", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Fdnf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Fdnf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fdnf.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -0,0 +1,320 @@\n+//! Disjunctive Normal Form construction.\n+//!\n+//! Algorithm from <https://www.cs.drexel.edu/~jjohnson/2015-16/fall/CS270/Lectures/3/dnf.pdf>,\n+//! which would have been much easier to read if it used pattern matching. It's also missing the\n+//! entire \"distribute ANDs over ORs\" part, which is not trivial. Oh well.\n+//!\n+//! This is currently both messy and inefficient. Feel free to improve, there are unit tests.\n+\n+use std::fmt;\n+\n+use rustc_hash::FxHashSet;\n+\n+use crate::{CfgAtom, CfgDiff, CfgExpr, CfgOptions, InactiveReason};\n+\n+/// A `#[cfg]` directive in Disjunctive Normal Form (DNF).\n+pub struct DnfExpr {\n+    conjunctions: Vec<Conjunction>,\n+}\n+\n+struct Conjunction {\n+    literals: Vec<Literal>,\n+}\n+\n+struct Literal {\n+    negate: bool,\n+    var: Option<CfgAtom>, // None = Invalid\n+}\n+\n+impl DnfExpr {\n+    pub fn new(expr: CfgExpr) -> Self {\n+        let builder = Builder { expr: DnfExpr { conjunctions: Vec::new() } };\n+\n+        builder.lower(expr.clone())\n+    }\n+\n+    /// Computes a list of present or absent atoms in `opts` that cause this expression to evaluate\n+    /// to `false`.\n+    ///\n+    /// Note that flipping a subset of these atoms might be sufficient to make the whole expression\n+    /// evaluate to `true`. For that, see `compute_enable_hints`.\n+    ///\n+    /// Returns `None` when `self` is already true, or contains errors.\n+    pub fn why_inactive(&self, opts: &CfgOptions) -> Option<InactiveReason> {\n+        let mut res = InactiveReason { enabled: Vec::new(), disabled: Vec::new() };\n+\n+        for conj in &self.conjunctions {\n+            let mut conj_is_true = true;\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = opts.enabled.contains(atom);\n+                if lit.negate == enabled {\n+                    // Literal is false, but needs to be true for this conjunction.\n+                    conj_is_true = false;\n+\n+                    if enabled {\n+                        res.enabled.push(atom.clone());\n+                    } else {\n+                        res.disabled.push(atom.clone());\n+                    }\n+                }\n+            }\n+\n+            if conj_is_true {\n+                // This expression is not actually inactive.\n+                return None;\n+            }\n+        }\n+\n+        res.enabled.sort_unstable();\n+        res.enabled.dedup();\n+        res.disabled.sort_unstable();\n+        res.disabled.dedup();\n+        Some(res)\n+    }\n+\n+    /// Returns `CfgDiff` objects that would enable this directive if applied to `opts`.\n+    pub fn compute_enable_hints<'a>(\n+        &'a self,\n+        opts: &'a CfgOptions,\n+    ) -> impl Iterator<Item = CfgDiff> + 'a {\n+        // A cfg is enabled if any of `self.conjunctions` evaluate to `true`.\n+\n+        self.conjunctions.iter().filter_map(move |conj| {\n+            let mut enable = FxHashSet::default();\n+            let mut disable = FxHashSet::default();\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = opts.enabled.contains(atom);\n+                if lit.negate && enabled {\n+                    disable.insert(atom.clone());\n+                }\n+                if !lit.negate && !enabled {\n+                    enable.insert(atom.clone());\n+                }\n+            }\n+\n+            // Check that this actually makes `conj` true.\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = enable.contains(atom)\n+                    || (opts.enabled.contains(atom) && !disable.contains(atom));\n+                if enabled == lit.negate {\n+                    return None;\n+                }\n+            }\n+\n+            if enable.is_empty() && disable.is_empty() {\n+                return None;\n+            }\n+\n+            let mut diff = CfgDiff {\n+                enable: enable.into_iter().collect(),\n+                disable: disable.into_iter().collect(),\n+            };\n+\n+            // Undo the FxHashMap randomization for consistent output.\n+            diff.enable.sort_unstable();\n+            diff.disable.sort_unstable();\n+\n+            Some(diff)\n+        })\n+    }\n+}\n+\n+impl fmt::Display for DnfExpr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.conjunctions.len() != 1 {\n+            write!(f, \"any(\")?;\n+        }\n+        for (i, conj) in self.conjunctions.iter().enumerate() {\n+            if i != 0 {\n+                f.write_str(\", \")?;\n+            }\n+\n+            write!(f, \"{}\", conj)?;\n+        }\n+        if self.conjunctions.len() != 1 {\n+            write!(f, \")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Conjunction {\n+    fn new(parts: Vec<CfgExpr>) -> Self {\n+        let mut literals = Vec::new();\n+        for part in parts {\n+            match part {\n+                CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => {\n+                    literals.push(Literal::new(part));\n+                }\n+                CfgExpr::All(conj) => {\n+                    // Flatten.\n+                    literals.extend(Conjunction::new(conj).literals);\n+                }\n+                CfgExpr::Any(_) => unreachable!(\"disjunction in conjunction\"),\n+            }\n+        }\n+\n+        Self { literals }\n+    }\n+}\n+\n+impl fmt::Display for Conjunction {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.literals.len() != 1 {\n+            write!(f, \"all(\")?;\n+        }\n+        for (i, lit) in self.literals.iter().enumerate() {\n+            if i != 0 {\n+                f.write_str(\", \")?;\n+            }\n+\n+            write!(f, \"{}\", lit)?;\n+        }\n+        if self.literals.len() != 1 {\n+            write!(f, \")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl Literal {\n+    fn new(expr: CfgExpr) -> Self {\n+        match expr {\n+            CfgExpr::Invalid => Self { negate: false, var: None },\n+            CfgExpr::Atom(atom) => Self { negate: false, var: Some(atom) },\n+            CfgExpr::Not(expr) => match *expr {\n+                CfgExpr::Invalid => Self { negate: true, var: None },\n+                CfgExpr::Atom(atom) => Self { negate: true, var: Some(atom) },\n+                _ => unreachable!(\"non-atom {:?}\", expr),\n+            },\n+            CfgExpr::Any(_) | CfgExpr::All(_) => unreachable!(\"non-literal {:?}\", expr),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.negate {\n+            write!(f, \"not(\")?;\n+        }\n+\n+        match &self.var {\n+            Some(var) => write!(f, \"{}\", var)?,\n+            None => f.write_str(\"<invalid>\")?,\n+        }\n+\n+        if self.negate {\n+            write!(f, \")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+struct Builder {\n+    expr: DnfExpr,\n+}\n+\n+impl Builder {\n+    fn lower(mut self, expr: CfgExpr) -> DnfExpr {\n+        let expr = make_nnf(expr);\n+        let expr = make_dnf(expr);\n+\n+        match expr {\n+            CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => {\n+                self.expr.conjunctions.push(Conjunction::new(vec![expr]));\n+            }\n+            CfgExpr::All(conj) => {\n+                self.expr.conjunctions.push(Conjunction::new(conj));\n+            }\n+            CfgExpr::Any(mut disj) => {\n+                disj.reverse();\n+                while let Some(conj) = disj.pop() {\n+                    match conj {\n+                        CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::All(_) | CfgExpr::Not(_) => {\n+                            self.expr.conjunctions.push(Conjunction::new(vec![conj]));\n+                        }\n+                        CfgExpr::Any(inner_disj) => {\n+                            // Flatten.\n+                            disj.extend(inner_disj.into_iter().rev());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.expr\n+    }\n+}\n+\n+fn make_dnf(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => expr,\n+        CfgExpr::Any(e) => CfgExpr::Any(e.into_iter().map(|expr| make_dnf(expr)).collect()),\n+        CfgExpr::All(e) => {\n+            let e = e.into_iter().map(|expr| make_nnf(expr)).collect::<Vec<_>>();\n+\n+            CfgExpr::Any(distribute_conj(&e))\n+        }\n+    }\n+}\n+\n+/// Turns a conjunction of expressions into a disjunction of expressions.\n+fn distribute_conj(conj: &[CfgExpr]) -> Vec<CfgExpr> {\n+    fn go(out: &mut Vec<CfgExpr>, with: &mut Vec<CfgExpr>, rest: &[CfgExpr]) {\n+        match rest {\n+            [head, tail @ ..] => match head {\n+                CfgExpr::Any(disj) => {\n+                    for part in disj {\n+                        with.push(part.clone());\n+                        go(out, with, tail);\n+                        with.pop();\n+                    }\n+                }\n+                _ => {\n+                    with.push(head.clone());\n+                    go(out, with, tail);\n+                    with.pop();\n+                }\n+            },\n+            _ => {\n+                // Turn accumulated parts into a new conjunction.\n+                out.push(CfgExpr::All(with.clone()));\n+            }\n+        }\n+    }\n+\n+    let mut out = Vec::new();\n+    let mut with = Vec::new();\n+\n+    go(&mut out, &mut with, conj);\n+\n+    out\n+}\n+\n+fn make_nnf(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::Invalid | CfgExpr::Atom(_) => expr,\n+        CfgExpr::Any(expr) => CfgExpr::Any(expr.into_iter().map(|expr| make_nnf(expr)).collect()),\n+        CfgExpr::All(expr) => CfgExpr::All(expr.into_iter().map(|expr| make_nnf(expr)).collect()),\n+        CfgExpr::Not(operand) => match *operand {\n+            CfgExpr::Invalid | CfgExpr::Atom(_) => CfgExpr::Not(operand.clone()), // Original negated expr\n+            CfgExpr::Not(expr) => {\n+                // Remove double negation.\n+                make_nnf(*expr)\n+            }\n+            // Convert negated conjunction/disjunction using DeMorgan's Law.\n+            CfgExpr::Any(inner) => CfgExpr::All(\n+                inner.into_iter().map(|expr| make_nnf(CfgExpr::Not(Box::new(expr)))).collect(),\n+            ),\n+            CfgExpr::All(inner) => CfgExpr::Any(\n+                inner.into_iter().map(|expr| make_nnf(CfgExpr::Not(Box::new(expr)))).collect(),\n+            ),\n+        },\n+    }\n+}"}, {"sha": "d0e08cf5f7741ea63570d52cdd82915813b43826", "filename": "crates/cfg/src/lib.rs", "status": "modified", "additions": 117, "deletions": 13, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Flib.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -1,11 +1,17 @@\n //! cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n \n mod cfg_expr;\n+mod dnf;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::fmt;\n \n use rustc_hash::FxHashSet;\n use tt::SmolStr;\n \n-pub use cfg_expr::CfgExpr;\n+pub use cfg_expr::{CfgAtom, CfgExpr};\n+pub use dnf::DnfExpr;\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes.\n /// We have two kind of options in different namespaces: atomic options like `unix`, and\n@@ -19,33 +25,131 @@ pub use cfg_expr::CfgExpr;\n /// See: https://doc.rust-lang.org/reference/conditional-compilation.html#set-configuration-options\n #[derive(Debug, Clone, PartialEq, Eq, Default)]\n pub struct CfgOptions {\n-    atoms: FxHashSet<SmolStr>,\n-    key_values: FxHashSet<(SmolStr, SmolStr)>,\n+    enabled: FxHashSet<CfgAtom>,\n }\n \n impl CfgOptions {\n     pub fn check(&self, cfg: &CfgExpr) -> Option<bool> {\n-        cfg.fold(&|key, value| match value {\n-            None => self.atoms.contains(key),\n-            Some(value) => self.key_values.contains(&(key.clone(), value.clone())),\n-        })\n+        cfg.fold(&|atom| self.enabled.contains(atom))\n     }\n \n     pub fn insert_atom(&mut self, key: SmolStr) {\n-        self.atoms.insert(key);\n+        self.enabled.insert(CfgAtom::Flag(key));\n     }\n \n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n-        self.key_values.insert((key, value));\n+        self.enabled.insert(CfgAtom::KeyValue { key, value });\n     }\n \n     pub fn append(&mut self, other: &CfgOptions) {\n-        for atom in &other.atoms {\n-            self.atoms.insert(atom.clone());\n+        for atom in &other.enabled {\n+            self.enabled.insert(atom.clone());\n+        }\n+    }\n+\n+    pub fn apply_diff(&mut self, diff: CfgDiff) {\n+        for atom in diff.enable {\n+            self.enabled.insert(atom);\n         }\n \n-        for (key, value) in &other.key_values {\n-            self.key_values.insert((key.clone(), value.clone()));\n+        for atom in diff.disable {\n+            self.enabled.remove(&atom);\n+        }\n+    }\n+}\n+\n+pub struct CfgDiff {\n+    // Invariants: No duplicates, no atom that's both in `enable` and `disable`.\n+    enable: Vec<CfgAtom>,\n+    disable: Vec<CfgAtom>,\n+}\n+\n+impl CfgDiff {\n+    /// Returns the total number of atoms changed by this diff.\n+    pub fn len(&self) -> usize {\n+        self.enable.len() + self.disable.len()\n+    }\n+}\n+\n+impl fmt::Display for CfgDiff {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if !self.enable.is_empty() {\n+            f.write_str(\"enable \")?;\n+            for (i, atom) in self.enable.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enable.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+\n+            if !self.disable.is_empty() {\n+                f.write_str(\"; \")?;\n+            }\n         }\n+\n+        if !self.disable.is_empty() {\n+            f.write_str(\"disable \")?;\n+            for (i, atom) in self.disable.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enable.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub struct InactiveReason {\n+    enabled: Vec<CfgAtom>,\n+    disabled: Vec<CfgAtom>,\n+}\n+\n+impl fmt::Display for InactiveReason {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if !self.enabled.is_empty() {\n+            for (i, atom) in self.enabled.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enabled.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+            let is_are = if self.enabled.len() == 1 { \"is\" } else { \"are\" };\n+            write!(f, \" {} enabled\", is_are)?;\n+\n+            if !self.disabled.is_empty() {\n+                f.write_str(\" and \")?;\n+            }\n+        }\n+\n+        if !self.disabled.is_empty() {\n+            for (i, atom) in self.disabled.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.disabled.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+            let is_are = if self.disabled.len() == 1 { \"is\" } else { \"are\" };\n+            write!(f, \" {} disabled\", is_are)?;\n+        }\n+\n+        Ok(())\n     }\n }"}, {"sha": "bd0f9ec4835df4a1655f4325df585d0eed3b3c67", "filename": "crates/cfg/src/tests.rs", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fcfg%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Ftests.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -0,0 +1,193 @@\n+use expect_test::{expect, Expect};\n+use mbe::ast_to_token_tree;\n+use syntax::{ast, AstNode};\n+\n+use crate::{CfgAtom, CfgExpr, CfgOptions, DnfExpr};\n+\n+fn assert_parse_result(input: &str, expected: CfgExpr) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    assert_eq!(cfg, expected);\n+}\n+\n+fn check_dnf(input: &str, expect: Expect) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let actual = format!(\"#![cfg({})]\", DnfExpr::new(cfg));\n+    expect.assert_eq(&actual);\n+}\n+\n+fn check_why_inactive(input: &str, opts: &CfgOptions, expect: Expect) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let dnf = DnfExpr::new(cfg);\n+    let why_inactive = dnf.why_inactive(opts).unwrap().to_string();\n+    expect.assert_eq(&why_inactive);\n+}\n+\n+#[track_caller]\n+fn check_enable_hints(input: &str, opts: &CfgOptions, expected_hints: &[&str]) {\n+    let (tt, _) = {\n+        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+        ast_to_token_tree(&tt).unwrap()\n+    };\n+    let cfg = CfgExpr::parse(&tt);\n+    let dnf = DnfExpr::new(cfg);\n+    let hints = dnf.compute_enable_hints(opts).map(|diff| diff.to_string()).collect::<Vec<_>>();\n+    assert_eq!(hints, expected_hints);\n+}\n+\n+#[test]\n+fn test_cfg_expr_parser() {\n+    assert_parse_result(\"#![cfg(foo)]\", CfgAtom::Flag(\"foo\".into()).into());\n+    assert_parse_result(\"#![cfg(foo,)]\", CfgAtom::Flag(\"foo\".into()).into());\n+    assert_parse_result(\n+        \"#![cfg(not(foo))]\",\n+        CfgExpr::Not(Box::new(CfgAtom::Flag(\"foo\".into()).into())),\n+    );\n+    assert_parse_result(\"#![cfg(foo(bar))]\", CfgExpr::Invalid);\n+\n+    // Only take the first\n+    assert_parse_result(r#\"#![cfg(foo, bar = \"baz\")]\"#, CfgAtom::Flag(\"foo\".into()).into());\n+\n+    assert_parse_result(\n+        r#\"#![cfg(all(foo, bar = \"baz\"))]\"#,\n+        CfgExpr::All(vec![\n+            CfgAtom::Flag(\"foo\".into()).into(),\n+            CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n+        ]),\n+    );\n+\n+    assert_parse_result(\n+        r#\"#![cfg(any(not(), all(), , bar = \"baz\",))]\"#,\n+        CfgExpr::Any(vec![\n+            CfgExpr::Not(Box::new(CfgExpr::Invalid)),\n+            CfgExpr::All(vec![]),\n+            CfgExpr::Invalid,\n+            CfgAtom::KeyValue { key: \"bar\".into(), value: \"baz\".into() }.into(),\n+        ]),\n+    );\n+}\n+\n+#[test]\n+fn smoke() {\n+    check_dnf(\"#![cfg(test)]\", expect![[r#\"#![cfg(test)]\"#]]);\n+    check_dnf(\"#![cfg(not(test))]\", expect![[r#\"#![cfg(not(test))]\"#]]);\n+    check_dnf(\"#![cfg(not(not(test)))]\", expect![[r#\"#![cfg(test)]\"#]]);\n+\n+    check_dnf(\"#![cfg(all(a, b))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(any(a, b))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+\n+    check_dnf(\"#![cfg(not(a))]\", expect![[r#\"#![cfg(not(a))]\"#]]);\n+}\n+\n+#[test]\n+fn distribute() {\n+    check_dnf(\"#![cfg(all(any(a, b), c))]\", expect![[r#\"#![cfg(any(all(a, c), all(b, c)))]\"#]]);\n+    check_dnf(\"#![cfg(all(c, any(a, b)))]\", expect![[r#\"#![cfg(any(all(c, a), all(c, b)))]\"#]]);\n+    check_dnf(\n+        \"#![cfg(all(any(a, b), any(c, d)))]\",\n+        expect![[r#\"#![cfg(any(all(a, c), all(a, d), all(b, c), all(b, d)))]\"#]],\n+    );\n+\n+    check_dnf(\n+        \"#![cfg(all(any(a, b, c), any(d, e, f), g))]\",\n+        expect![[\n+            r#\"#![cfg(any(all(a, d, g), all(a, e, g), all(a, f, g), all(b, d, g), all(b, e, g), all(b, f, g), all(c, d, g), all(c, e, g), all(c, f, g)))]\"#\n+        ]],\n+    );\n+}\n+\n+#[test]\n+fn demorgan() {\n+    check_dnf(\"#![cfg(not(all(a, b)))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(a, b)))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+\n+    check_dnf(\"#![cfg(not(all(not(a), b)))]\", expect![[r#\"#![cfg(any(a, not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(a, not(b))))]\", expect![[r#\"#![cfg(all(not(a), b))]\"#]]);\n+}\n+\n+#[test]\n+fn nested() {\n+    check_dnf(\"#![cfg(all(any(a), not(all(any(b)))))]\", expect![[r#\"#![cfg(all(a, not(b)))]\"#]]);\n+\n+    check_dnf(\"#![cfg(any(any(a, b)))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(not(any(any(a, b))))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+    check_dnf(\"#![cfg(all(all(a, b)))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+    check_dnf(\"#![cfg(not(all(all(a, b))))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+}\n+\n+#[test]\n+fn hints() {\n+    let mut opts = CfgOptions::default();\n+\n+    check_enable_hints(\"#![cfg(test)]\", &opts, &[\"enable test\"]);\n+    check_enable_hints(\"#![cfg(not(test))]\", &opts, &[]);\n+\n+    check_enable_hints(\"#![cfg(any(a, b))]\", &opts, &[\"enable a\", \"enable b\"]);\n+    check_enable_hints(\"#![cfg(any(b, a))]\", &opts, &[\"enable b\", \"enable a\"]);\n+\n+    check_enable_hints(\"#![cfg(all(a, b))]\", &opts, &[\"enable a and b\"]);\n+\n+    opts.insert_atom(\"test\".into());\n+\n+    check_enable_hints(\"#![cfg(test)]\", &opts, &[]);\n+    check_enable_hints(\"#![cfg(not(test))]\", &opts, &[\"disable test\"]);\n+}\n+\n+/// Tests that we don't suggest hints for cfgs that express an inconsistent formula.\n+#[test]\n+fn hints_impossible() {\n+    let mut opts = CfgOptions::default();\n+\n+    check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+\n+    opts.insert_atom(\"test\".into());\n+\n+    check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+}\n+\n+#[test]\n+fn why_inactive() {\n+    let mut opts = CfgOptions::default();\n+    opts.insert_atom(\"test\".into());\n+    opts.insert_atom(\"test2\".into());\n+\n+    check_why_inactive(\"#![cfg(a)]\", &opts, expect![[\"a is disabled\"]]);\n+    check_why_inactive(\"#![cfg(not(test))]\", &opts, expect![[\"test is enabled\"]]);\n+\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), not(test2)))]\",\n+        &opts,\n+        expect![[\"test and test2 are enabled\"]],\n+    );\n+    check_why_inactive(\"#![cfg(all(a, b))]\", &opts, expect![[\"a and b are disabled\"]]);\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), a))]\",\n+        &opts,\n+        expect![[\"test is enabled and a is disabled\"]],\n+    );\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), test2, a))]\",\n+        &opts,\n+        expect![[\"test is enabled and a is disabled\"]],\n+    );\n+    check_why_inactive(\n+        \"#![cfg(all(not(test), not(test2), a))]\",\n+        &opts,\n+        expect![[\"test and test2 are enabled and a is disabled\"]],\n+    );\n+}"}, {"sha": "b2ce7ca3c3d1c9613fde003af009ebf15a39ed71", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -125,12 +125,20 @@ impl Attrs {\n         AttrQuery { attrs: self, key }\n     }\n \n-    pub fn cfg(&self) -> impl Iterator<Item = CfgExpr> + '_ {\n+    pub fn cfg(&self) -> Option<CfgExpr> {\n         // FIXME: handle cfg_attr :-)\n-        self.by_key(\"cfg\").tt_values().map(CfgExpr::parse)\n+        let mut cfgs = self.by_key(\"cfg\").tt_values().map(CfgExpr::parse).collect::<Vec<_>>();\n+        match cfgs.len() {\n+            0 => None,\n+            1 => Some(cfgs.pop().unwrap()),\n+            _ => Some(CfgExpr::All(cfgs)),\n+        }\n     }\n     pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n-        self.cfg().all(|cfg| cfg_options.check(&cfg) != Some(false))\n+        match self.cfg() {\n+            None => true,\n+            Some(cfg) => cfg_options.check(&cfg) != Some(false),\n+        }\n     }\n }\n "}, {"sha": "532496b622fcf6b295fcd381581101dab2ea4ca1", "filename": "crates/hir_def/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -1,11 +1,12 @@\n //! Diagnostics produced by `hir_def`.\n \n use std::any::Any;\n+use stdx::format_to;\n \n+use cfg::{CfgExpr, CfgOptions, DnfExpr};\n use hir_expand::diagnostics::{Diagnostic, DiagnosticCode};\n-use syntax::{ast, AstPtr, SyntaxNodePtr};\n-\n use hir_expand::{HirFileId, InFile};\n+use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n // Diagnostic: unresolved-module\n //\n@@ -94,15 +95,23 @@ impl Diagnostic for UnresolvedImport {\n pub struct InactiveCode {\n     pub file: HirFileId,\n     pub node: SyntaxNodePtr,\n+    pub cfg: CfgExpr,\n+    pub opts: CfgOptions,\n }\n \n impl Diagnostic for InactiveCode {\n     fn code(&self) -> DiagnosticCode {\n         DiagnosticCode(\"inactive-code\")\n     }\n     fn message(&self) -> String {\n-        // FIXME: say *why* it is configured out\n-        \"code is inactive due to #[cfg] directives\".to_string()\n+        let inactive = DnfExpr::new(self.cfg.clone()).why_inactive(&self.opts);\n+        let mut buf = \"code is inactive due to #[cfg] directives\".to_string();\n+\n+        if let Some(inactive) = inactive {\n+            format_to!(buf, \": {}\", inactive);\n+        }\n+\n+        buf\n     }\n     fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.node.clone())"}, {"sha": "eb41d324e3fbe3fb3e60a6aab00fc83e7574bec9", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -283,6 +283,7 @@ pub enum ModuleSource {\n }\n \n mod diagnostics {\n+    use cfg::{CfgExpr, CfgOptions};\n     use hir_expand::diagnostics::DiagnosticSink;\n     use hir_expand::hygiene::Hygiene;\n     use hir_expand::InFile;\n@@ -299,7 +300,7 @@ mod diagnostics {\n \n         UnresolvedImport { ast: AstId<ast::Use>, index: usize },\n \n-        UnconfiguredCode { ast: InFile<SyntaxNodePtr> },\n+        UnconfiguredCode { ast: InFile<SyntaxNodePtr>, cfg: CfgExpr, opts: CfgOptions },\n     }\n \n     #[derive(Debug, PartialEq, Eq)]\n@@ -341,8 +342,10 @@ mod diagnostics {\n         pub(super) fn unconfigured_code(\n             container: LocalModuleId,\n             ast: InFile<SyntaxNodePtr>,\n+            cfg: CfgExpr,\n+            opts: CfgOptions,\n         ) -> Self {\n-            Self { in_module: container, kind: DiagnosticKind::UnconfiguredCode { ast } }\n+            Self { in_module: container, kind: DiagnosticKind::UnconfiguredCode { ast, cfg, opts } }\n         }\n \n         pub(super) fn add_to(\n@@ -395,8 +398,13 @@ mod diagnostics {\n                     }\n                 }\n \n-                DiagnosticKind::UnconfiguredCode { ast } => {\n-                    sink.push(InactiveCode { file: ast.file_id, node: ast.value.clone() });\n+                DiagnosticKind::UnconfiguredCode { ast, cfg, opts } => {\n+                    sink.push(InactiveCode {\n+                        file: ast.file_id,\n+                        node: ast.value.clone(),\n+                        cfg: cfg.clone(),\n+                        opts: opts.clone(),\n+                    });\n                 }\n             }\n         }"}, {"sha": "f30172d905d3dd44d50d76c6023fb28176cffb01", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -6,7 +6,7 @@\n use std::iter;\n \n use base_db::{CrateId, FileId, ProcMacroId};\n-use cfg::CfgOptions;\n+use cfg::{CfgExpr, CfgOptions};\n use hir_expand::InFile;\n use hir_expand::{\n     ast_id_map::FileAstId,\n@@ -900,7 +900,8 @@ impl ModCollector<'_, '_> {\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if self.is_cfg_enabled(self.item_tree.attrs((*item).into())) {\n+            let attrs = self.item_tree.attrs((*item).into());\n+            if attrs.cfg().map_or(true, |cfg| self.is_cfg_enabled(&cfg)) {\n                 if let ModItem::ExternCrate(id) = item {\n                     let import = self.item_tree[*id].clone();\n                     if import.is_macro_use {\n@@ -912,9 +913,11 @@ impl ModCollector<'_, '_> {\n \n         for &item in items {\n             let attrs = self.item_tree.attrs(item.into());\n-            if !self.is_cfg_enabled(attrs) {\n-                self.emit_unconfigured_diagnostic(item);\n-                continue;\n+            if let Some(cfg) = attrs.cfg() {\n+                if !self.is_cfg_enabled(&cfg) {\n+                    self.emit_unconfigured_diagnostic(item, &cfg);\n+                    continue;\n+                }\n             }\n             let module =\n                 ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n@@ -1321,20 +1324,22 @@ impl ModCollector<'_, '_> {\n         }\n     }\n \n-    fn is_cfg_enabled(&self, attrs: &Attrs) -> bool {\n-        attrs.is_cfg_enabled(self.def_collector.cfg_options)\n+    fn is_cfg_enabled(&self, cfg: &CfgExpr) -> bool {\n+        self.def_collector.cfg_options.check(cfg) != Some(false)\n     }\n \n-    fn emit_unconfigured_diagnostic(&mut self, item: ModItem) {\n+    fn emit_unconfigured_diagnostic(&mut self, item: ModItem, cfg: &CfgExpr) {\n         let ast_id = item.ast_id(self.item_tree);\n         let id_map = self.def_collector.db.ast_id_map(self.file_id);\n         let syntax_ptr = id_map.get(ast_id).syntax_node_ptr();\n \n         let ast_node = InFile::new(self.file_id, syntax_ptr);\n-        self.def_collector\n-            .def_map\n-            .diagnostics\n-            .push(DefDiagnostic::unconfigured_code(self.module_id, ast_node));\n+        self.def_collector.def_map.diagnostics.push(DefDiagnostic::unconfigured_code(\n+            self.module_id,\n+            ast_node,\n+            cfg.clone(),\n+            self.def_collector.cfg_options.clone(),\n+        ));\n     }\n }\n "}, {"sha": "5972248de7a84e85cfc4b900e33a38ca9119622f", "filename": "crates/hir_def/src/nameres/tests/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fdiagnostics.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -129,3 +129,25 @@ fn unresolved_module() {\n         \",\n     );\n }\n+\n+#[test]\n+fn inactive_item() {\n+    // Additional tests in `cfg` crate. This only tests disabled cfgs.\n+\n+    check_diagnostics(\n+        r#\"\n+        //- /lib.rs\n+          #[cfg(no)] pub fn f() {}\n+        //^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no is disabled\n+\n+          #[cfg(no)] #[cfg(no2)] mod m;\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: no and no2 are disabled\n+\n+          #[cfg(all(not(a), b))] enum E {}\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: b is disabled\n+\n+          #[cfg(feature = \"std\")] use std;\n+        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ code is inactive due to #[cfg] directives: feature = \"std\" is disabled\n+        \"#,\n+    );\n+}"}, {"sha": "0332c7be046e157dfae5bc41b6a1670132b55ee4", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -2128,7 +2128,7 @@ fn foo_<|>test() {}\n                                     ignore: false,\n                                 },\n                             },\n-                            cfg_exprs: [],\n+                            cfg: None,\n                         },\n                     ),\n                 ]\n@@ -2166,7 +2166,7 @@ mod tests<|> {\n                             kind: TestMod {\n                                 path: \"tests\",\n                             },\n-                            cfg_exprs: [],\n+                            cfg: None,\n                         },\n                     ),\n                 ]"}, {"sha": "eb82456ad8deeea31b210cd557b36b4acae9f56c", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -15,7 +15,7 @@ use crate::{display::ToNav, FileId, NavigationTarget};\n pub struct Runnable {\n     pub nav: NavigationTarget,\n     pub kind: RunnableKind,\n-    pub cfg_exprs: Vec<CfgExpr>,\n+    pub cfg: Option<CfgExpr>,\n }\n \n #[derive(Debug, Clone)]\n@@ -168,7 +168,7 @@ fn runnable_fn(\n     };\n \n     let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &fn_def));\n-    let cfg_exprs = attrs.cfg().collect();\n+    let cfg = attrs.cfg();\n \n     let nav = if let RunnableKind::DocTest { .. } = kind {\n         NavigationTarget::from_doc_commented(\n@@ -179,7 +179,7 @@ fn runnable_fn(\n     } else {\n         NavigationTarget::from_named(sema.db, InFile::new(file_id.into(), &fn_def))\n     };\n-    Some(Runnable { nav, kind, cfg_exprs })\n+    Some(Runnable { nav, kind, cfg })\n }\n \n #[derive(Debug, Copy, Clone)]\n@@ -255,9 +255,9 @@ fn runnable_mod(\n         .join(\"::\");\n \n     let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &module));\n-    let cfg_exprs = attrs.cfg().collect();\n+    let cfg = attrs.cfg();\n     let nav = module_def.to_nav(sema.db);\n-    Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg_exprs })\n+    Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg })\n }\n \n // We could create runnables for modules with number_of_test_submodules > 0,\n@@ -348,7 +348,7 @@ fn bench() {}\n                             docs: None,\n                         },\n                         kind: Bin,\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -373,7 +373,7 @@ fn bench() {}\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -398,7 +398,7 @@ fn bench() {}\n                                 ignore: true,\n                             },\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -420,7 +420,7 @@ fn bench() {}\n                                 \"bench\",\n                             ),\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                 ]\n             \"#]],\n@@ -507,7 +507,7 @@ fn should_have_no_runnable_6() {}\n                             docs: None,\n                         },\n                         kind: Bin,\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -527,7 +527,7 @@ fn should_have_no_runnable_6() {}\n                                 \"should_have_runnable\",\n                             ),\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -547,7 +547,7 @@ fn should_have_no_runnable_6() {}\n                                 \"should_have_runnable_1\",\n                             ),\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -567,7 +567,7 @@ fn should_have_no_runnable_6() {}\n                                 \"should_have_runnable_2\",\n                             ),\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                 ]\n             \"#]],\n@@ -609,7 +609,7 @@ impl Data {\n                             docs: None,\n                         },\n                         kind: Bin,\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -629,7 +629,7 @@ impl Data {\n                                 \"Data::foo\",\n                             ),\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                 ]\n             \"#]],\n@@ -668,7 +668,7 @@ mod test_mod {\n                         kind: TestMod {\n                             path: \"test_mod\",\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -693,7 +693,7 @@ mod test_mod {\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                 ]\n             \"#]],\n@@ -748,7 +748,7 @@ mod root_tests {\n                         kind: TestMod {\n                             path: \"root_tests::nested_tests_0\",\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -768,7 +768,7 @@ mod root_tests {\n                         kind: TestMod {\n                             path: \"root_tests::nested_tests_0::nested_tests_1\",\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -793,7 +793,7 @@ mod root_tests {\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -818,7 +818,7 @@ mod root_tests {\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -838,7 +838,7 @@ mod root_tests {\n                         kind: TestMod {\n                             path: \"root_tests::nested_tests_0::nested_tests_2\",\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                     Runnable {\n                         nav: NavigationTarget {\n@@ -863,7 +863,7 @@ mod root_tests {\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [],\n+                        cfg: None,\n                     },\n                 ]\n             \"#]],\n@@ -906,12 +906,14 @@ fn test_foo1() {}\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [\n-                            KeyValue {\n-                                key: \"feature\",\n-                                value: \"foo\",\n-                            },\n-                        ],\n+                        cfg: Some(\n+                            Atom(\n+                                KeyValue {\n+                                    key: \"feature\",\n+                                    value: \"foo\",\n+                                },\n+                            ),\n+                        ),\n                     },\n                 ]\n             \"#]],\n@@ -954,20 +956,24 @@ fn test_foo1() {}\n                                 ignore: false,\n                             },\n                         },\n-                        cfg_exprs: [\n+                        cfg: Some(\n                             All(\n                                 [\n-                                    KeyValue {\n-                                        key: \"feature\",\n-                                        value: \"foo\",\n-                                    },\n-                                    KeyValue {\n-                                        key: \"feature\",\n-                                        value: \"bar\",\n-                                    },\n+                                    Atom(\n+                                        KeyValue {\n+                                            key: \"feature\",\n+                                            value: \"foo\",\n+                                        },\n+                                    ),\n+                                    Atom(\n+                                        KeyValue {\n+                                            key: \"feature\",\n+                                            value: \"bar\",\n+                                        },\n+                                    ),\n                                 ],\n                             ),\n-                        ],\n+                        ),\n                     },\n                 ]\n             \"#]],"}, {"sha": "1ab72bd9158a4c3dd50eb458c7e25bf3871003ac", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -1,6 +1,6 @@\n //! See `CargoTargetSpec`\n \n-use cfg::CfgExpr;\n+use cfg::{CfgAtom, CfgExpr};\n use ide::{FileId, RunnableKind, TestId};\n use project_model::{self, TargetKind};\n use vfs::AbsPathBuf;\n@@ -24,7 +24,7 @@ impl CargoTargetSpec {\n         snap: &GlobalStateSnapshot,\n         spec: Option<CargoTargetSpec>,\n         kind: &RunnableKind,\n-        cfgs: &[CfgExpr],\n+        cfg: &Option<CfgExpr>,\n     ) -> Result<(Vec<String>, Vec<String>)> {\n         let mut args = Vec::new();\n         let mut extra_args = Vec::new();\n@@ -87,7 +87,7 @@ impl CargoTargetSpec {\n             args.push(\"--all-features\".to_string());\n         } else {\n             let mut features = Vec::new();\n-            for cfg in cfgs {\n+            if let Some(cfg) = cfg.as_ref() {\n                 required_features(cfg, &mut features);\n             }\n             for feature in &snap.config.cargo.features {\n@@ -160,7 +160,9 @@ impl CargoTargetSpec {\n /// Fill minimal features needed\n fn required_features(cfg_expr: &CfgExpr, features: &mut Vec<String>) {\n     match cfg_expr {\n-        CfgExpr::KeyValue { key, value } if key == \"feature\" => features.push(value.to_string()),\n+        CfgExpr::Atom(CfgAtom::KeyValue { key, value }) if key == \"feature\" => {\n+            features.push(value.to_string())\n+        }\n         CfgExpr::All(preds) => {\n             preds.iter().for_each(|cfg| required_features(cfg, features));\n         }"}, {"sha": "d0fb92f89b45faa674eab0b598f92caa1ba7965f", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81609960fa30ea92e37b23dc7b025d1939626812/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=81609960fa30ea92e37b23dc7b025d1939626812", "patch": "@@ -762,7 +762,7 @@ pub(crate) fn runnable(\n     let workspace_root = spec.as_ref().map(|it| it.workspace_root.clone());\n     let target = spec.as_ref().map(|s| s.target.clone());\n     let (cargo_args, executable_args) =\n-        CargoTargetSpec::runnable_args(snap, spec, &runnable.kind, &runnable.cfg_exprs)?;\n+        CargoTargetSpec::runnable_args(snap, spec, &runnable.kind, &runnable.cfg)?;\n     let label = runnable.label(target);\n     let location = location_link(snap, None, runnable.nav)?;\n "}]}