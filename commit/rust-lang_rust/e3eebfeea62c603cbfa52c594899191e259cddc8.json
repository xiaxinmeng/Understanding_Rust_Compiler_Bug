{"sha": "e3eebfeea62c603cbfa52c594899191e259cddc8", "node_id": "C_kwDOAAsO6NoAKGUzZWViZmVlYTYyYzYwM2NiZmE1MmM1OTQ4OTkxOTFlMjU5Y2RkYzg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-10-27T04:11:35Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-27T04:11:35Z"}, "message": "Rollup merge of #90154 - camelid:remove-getdefid, r=jyn514\n\nrustdoc: Remove `GetDefId`\n\nSee the individual commit messages for details.\n\nr? `@jyn514`", "tree": {"sha": "6264895faa70bba069cc2156bdf2d459d53ebee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6264895faa70bba069cc2156bdf2d459d53ebee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3eebfeea62c603cbfa52c594899191e259cddc8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJheNF4CRBK7hj4Ov3rIwAAgV4IAANL6vyWhWlldLV4IvSwOBxE\nhYU9yuEkdpcM0Ql08qMr8pbunZM7fOkqM+Y6pUo2YQ8M9+150VEccMIBtlHqJua8\ns+Xqr32fVnVo42CBV6e4sTffr5KAwRYk7Q410Mkkl570hYfVDiP50EvAWBo64nF0\ngHYlit2LtjWWWV43eNl9RCi6QL9pi9gyrjkZ4NIca+Fh/oWU0MsUiHjhuB99JgmC\ndpmQlitrxO2SuhFip1NGkq7Yg7c7k84mdT7BlqWo5/4lSJfv1bXOa/86lbRLzwpI\nbYe+PcbnJl5fdpGbsTnCAYsKsUwj+fN5o2zfv64+RMCou62jO/DIylNpEGOwPPE=\n=txal\n-----END PGP SIGNATURE-----\n", "payload": "tree 6264895faa70bba069cc2156bdf2d459d53ebee9\nparent e269e6bf47f40c9046cd44ab787881d700099252\nparent 3ad0834700ec3db9952a7b69daf805c04a98d8e0\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1635307895 +0200\ncommitter GitHub <noreply@github.com> 1635307895 +0200\n\nRollup merge of #90154 - camelid:remove-getdefid, r=jyn514\n\nrustdoc: Remove `GetDefId`\n\nSee the individual commit messages for details.\n\nr? `@jyn514`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3eebfeea62c603cbfa52c594899191e259cddc8", "html_url": "https://github.com/rust-lang/rust/commit/e3eebfeea62c603cbfa52c594899191e259cddc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3eebfeea62c603cbfa52c594899191e259cddc8/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e269e6bf47f40c9046cd44ab787881d700099252", "url": "https://api.github.com/repos/rust-lang/rust/commits/e269e6bf47f40c9046cd44ab787881d700099252", "html_url": "https://github.com/rust-lang/rust/commit/e269e6bf47f40c9046cd44ab787881d700099252"}, {"sha": "3ad0834700ec3db9952a7b69daf805c04a98d8e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad0834700ec3db9952a7b69daf805c04a98d8e0", "html_url": "https://github.com/rust-lang/rust/commit/3ad0834700ec3db9952a7b69daf805c04a98d8e0"}], "stats": {"total": 168, "additions": 69, "deletions": 99}, "files": [{"sha": "952676247489f938b1db7970fc9e97d94134e7b3", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -234,7 +234,7 @@ unsafe impl SliceIndex<str> for ops::Range<usize> {\n /// Implements substring slicing with syntax `&self[.. end]` or `&mut\n /// self[.. end]`.\n ///\n-/// Returns a slice of the given string from the byte range [`0`, `end`).\n+/// Returns a slice of the given string from the byte range \\[0, `end`).\n /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n ///\n /// This operation is *O*(1).\n@@ -304,9 +304,8 @@ unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n /// Implements substring slicing with syntax `&self[begin ..]` or `&mut\n /// self[begin ..]`.\n ///\n-/// Returns a slice of the given string from the byte range [`begin`,\n-/// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n-/// len]`.\n+/// Returns a slice of the given string from the byte range \\[`begin`, `len`).\n+/// Equivalent to `&self[begin .. len]` or `&mut self[begin .. len]`.\n ///\n /// This operation is *O*(1).\n ///\n@@ -433,7 +432,7 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n /// Implements substring slicing with syntax `&self[..= end]` or `&mut\n /// self[..= end]`.\n ///\n-/// Returns a slice of the given string from the byte range [0, `end`].\n+/// Returns a slice of the given string from the byte range \\[0, `end`\\].\n /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n /// value for `usize`.\n ///"}, {"sha": "0629859bd9dcc15bc232b502366bf21512500ff7", "filename": "library/std/src/sys_common/wtf8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fwtf8.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -686,7 +686,7 @@ impl Wtf8 {\n     }\n }\n \n-/// Returns a slice of the given string for the byte range [`begin`..`end`).\n+/// Returns a slice of the given string for the byte range \\[`begin`..`end`).\n ///\n /// # Panics\n ///"}, {"sha": "c5e0587581970fd4ef3ca0338f606f951866368b", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -14,9 +14,7 @@ use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n-use crate::clean::{\n-    self, utils, Attributes, AttributesExt, GetDefId, ItemId, NestedAttributesExt, Type,\n-};\n+use crate::clean::{self, utils, Attributes, AttributesExt, ItemId, NestedAttributesExt, Type};\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n \n@@ -325,7 +323,7 @@ fn merge_attrs(\n     }\n }\n \n-/// Builds a specific implementation of a type. The `did` could be a type method or trait method.\n+/// Inline an `impl`, inherent or of a trait. The `did` must be for an `impl`.\n crate fn build_impl(\n     cx: &mut DocContext<'_>,\n     parent_module: impl Into<Option<DefId>>,\n@@ -376,7 +374,7 @@ crate fn build_impl(\n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n-        if let Some(did) = for_.def_id() {\n+        if let Some(did) = for_.def_id(&cx.cache) {\n             if !cx.cache.access_levels.is_public(did) {\n                 return;\n             }\n@@ -464,7 +462,7 @@ crate fn build_impl(\n     }\n \n     while let Some(ty) = stack.pop() {\n-        if let Some(did) = ty.def_id() {\n+        if let Some(did) = ty.def_id(&cx.cache) {\n             if tcx.get_attrs(did).lists(sym::doc).has_word(sym::hidden) {\n                 return;\n             }\n@@ -481,7 +479,11 @@ crate fn build_impl(\n     let (merged_attrs, cfg) = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n     trace!(\"merged_attrs={:?}\", merged_attrs);\n \n-    trace!(\"build_impl: impl {:?} for {:?}\", trait_.as_ref().map(|t| t.def_id()), for_.def_id());\n+    trace!(\n+        \"build_impl: impl {:?} for {:?}\",\n+        trait_.as_ref().map(|t| t.def_id()),\n+        for_.def_id(&cx.cache)\n+    );\n     ret.push(clean::Item::from_def_id_and_attrs_and_parts(\n         did,\n         None,"}, {"sha": "9ea3112f178be2ad51a9fc098121dd6237546685", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -383,7 +383,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n         let self_type = self.self_ty().clean(cx);\n         Type::QPath {\n             name: cx.tcx.associated_item(self.item_def_id).ident.name,\n-            self_def_id: self_type.def_id(),\n+            self_def_id: self_type.def_id(&cx.cache),\n             self_type: box self_type,\n             trait_,\n         }\n@@ -1883,7 +1883,7 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n     }\n \n     let for_ = impl_.self_ty.clean(cx);\n-    let type_alias = for_.def_id().and_then(|did| match tcx.def_kind(did) {\n+    let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n         DefKind::TyAlias => Some(tcx.type_of(did).clean(cx)),\n         _ => None,\n     });"}, {"sha": "6ae057abb3d367c52478058440ae061b9e1839c2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 21, "deletions": 56, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -1370,17 +1370,10 @@ crate enum FnRetTy {\n     DefaultReturn,\n }\n \n-impl GetDefId for FnRetTy {\n-    fn def_id(&self) -> Option<DefId> {\n-        match *self {\n-            Return(ref ty) => ty.def_id(),\n-            DefaultReturn => None,\n-        }\n-    }\n-\n-    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n-        match *self {\n-            Return(ref ty) => ty.def_id_full(cache),\n+impl FnRetTy {\n+    crate fn as_return(&self) -> Option<&Type> {\n+        match self {\n+            Return(ret) => Some(ret),\n             DefaultReturn => None,\n         }\n     }\n@@ -1458,34 +1451,6 @@ crate enum Type {\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n rustc_data_structures::static_assert_size!(Type, 72);\n \n-crate trait GetDefId {\n-    /// Use this method to get the [`DefId`] of a [`clean`] AST node.\n-    /// This will return [`None`] when called on a primitive [`clean::Type`].\n-    /// Use [`Self::def_id_full`] if you want to include primitives.\n-    ///\n-    /// [`clean`]: crate::clean\n-    /// [`clean::Type`]: crate::clean::Type\n-    // FIXME: get rid of this function and always use `def_id_full`\n-    fn def_id(&self) -> Option<DefId>;\n-\n-    /// Use this method to get the [DefId] of a [clean] AST node, including [PrimitiveType]s.\n-    ///\n-    /// See [`Self::def_id`] for more.\n-    ///\n-    /// [clean]: crate::clean\n-    fn def_id_full(&self, cache: &Cache) -> Option<DefId>;\n-}\n-\n-impl<T: GetDefId> GetDefId for Option<T> {\n-    fn def_id(&self) -> Option<DefId> {\n-        self.as_ref().and_then(|d| d.def_id())\n-    }\n-\n-    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n-        self.as_ref().and_then(|d| d.def_id_full(cache))\n-    }\n-}\n-\n impl Type {\n     crate fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n@@ -1564,17 +1529,27 @@ impl Type {\n             QPath { ref self_type, .. } => return self_type.inner_def_id(cache),\n             Generic(_) | Infer | ImplTrait(_) => return None,\n         };\n-        cache.and_then(|c| Primitive(t).def_id_full(c))\n+        cache.and_then(|c| Primitive(t).def_id(c))\n     }\n-}\n \n-impl GetDefId for Type {\n-    fn def_id(&self) -> Option<DefId> {\n-        self.inner_def_id(None)\n+    /// Use this method to get the [DefId] of a [clean] AST node, including [PrimitiveType]s.\n+    ///\n+    /// See [`Self::def_id_no_primitives`] for more.\n+    ///\n+    /// [clean]: crate::clean\n+    crate fn def_id(&self, cache: &Cache) -> Option<DefId> {\n+        self.inner_def_id(Some(cache))\n     }\n \n-    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n-        self.inner_def_id(Some(cache))\n+    /// Use this method to get the [`DefId`] of a [`clean`] AST node.\n+    /// This will return [`None`] when called on a primitive [`clean::Type`].\n+    /// Use [`Self::def_id`] if you want to include primitives.\n+    ///\n+    /// [`clean`]: crate::clean\n+    /// [`clean::Type`]: crate::clean::Type\n+    // FIXME: get rid of this function and always use `def_id`\n+    crate fn def_id_no_primitives(&self) -> Option<DefId> {\n+        self.inner_def_id(None)\n     }\n }\n \n@@ -2092,16 +2067,6 @@ crate struct Typedef {\n     crate item_type: Option<Type>,\n }\n \n-impl GetDefId for Typedef {\n-    fn def_id(&self) -> Option<DefId> {\n-        self.type_.def_id()\n-    }\n-\n-    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n-        self.type_.def_id_full(cache)\n-    }\n-}\n-\n #[derive(Clone, Debug)]\n crate struct OpaqueTy {\n     crate bounds: Vec<GenericBound>,"}, {"sha": "6b9c9a9669b1a4a4284e9ff6877f0b9e37221d5d", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n-use crate::clean::{self, GetDefId, ItemId, PrimitiveType};\n+use crate::clean::{self, ItemId, PrimitiveType};\n use crate::config::RenderOptions;\n use crate::fold::DocFolder;\n use crate::formats::item_type::ItemType;\n@@ -206,7 +206,9 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 || i.trait_\n                     .as_ref()\n                     .map_or(false, |t| self.cache.masked_crates.contains(&t.def_id().krate))\n-                || i.for_.def_id().map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n+                || i.for_\n+                    .def_id(self.cache)\n+                    .map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n             {\n                 return None;\n             }\n@@ -454,7 +456,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n \n             if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n                 for bound in generics {\n-                    if let Some(did) = bound.def_id() {\n+                    if let Some(did) = bound.def_id(self.cache) {\n                         dids.insert(did);\n                     }\n                 }"}, {"sha": "0bbc510f7cbecb734e6a7851046d9830e8c3b845", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -7,9 +7,7 @@ use rustc_span::symbol::Symbol;\n use serde::ser::{Serialize, SerializeStruct, Serializer};\n \n use crate::clean;\n-use crate::clean::types::{\n-    FnDecl, FnRetTy, GenericBound, Generics, GetDefId, Type, WherePredicate,\n-};\n+use crate::clean::types::{FnDecl, FnRetTy, GenericBound, Generics, Type, WherePredicate};\n use crate::formats::cache::Cache;\n use crate::formats::item_type::ItemType;\n use crate::html::markdown::short_markdown_summary;\n@@ -278,7 +276,7 @@ crate fn get_real_types<'tcx>(\n     res: &mut FxHashSet<(Type, ItemType)>,\n ) -> usize {\n     fn insert(res: &mut FxHashSet<(Type, ItemType)>, tcx: TyCtxt<'_>, ty: Type) -> usize {\n-        if let Some(kind) = ty.def_id().map(|did| tcx.def_kind(did).into()) {\n+        if let Some(kind) = ty.def_id_no_primitives().map(|did| tcx.def_kind(did).into()) {\n             res.insert((ty, kind));\n             1\n         } else if ty.is_primitive() {\n@@ -298,7 +296,9 @@ crate fn get_real_types<'tcx>(\n \n     if let Type::Generic(arg_s) = *arg {\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n-            WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n+            WherePredicate::BoundPredicate { ty, .. } => {\n+                ty.def_id_no_primitives() == arg.def_id_no_primitives()\n+            }\n             _ => false,\n         }) {\n             let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n@@ -365,7 +365,8 @@ crate fn get_all_types<'tcx>(\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            if let Some(kind) = arg.type_.def_id().map(|did| tcx.def_kind(did).into()) {\n+            if let Some(kind) = arg.type_.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n+            {\n                 all_types.insert((arg.type_.clone(), kind));\n             }\n         }\n@@ -376,7 +377,9 @@ crate fn get_all_types<'tcx>(\n             let mut ret = FxHashSet::default();\n             get_real_types(generics, return_type, tcx, 0, &mut ret);\n             if ret.is_empty() {\n-                if let Some(kind) = return_type.def_id().map(|did| tcx.def_kind(did).into()) {\n+                if let Some(kind) =\n+                    return_type.def_id_no_primitives().map(|did| tcx.def_kind(did).into())\n+                {\n                     ret.insert((return_type.clone(), kind));\n                 }\n             }"}, {"sha": "a1b86c87d3aeee643701b16dc6cbb341355b0171", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -62,7 +62,7 @@ use rustc_span::{\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n-use crate::clean::{self, GetDefId, ItemId, RenderedLink, SelfTy};\n+use crate::clean::{self, ItemId, RenderedLink, SelfTy};\n use crate::docfs::PathError;\n use crate::error::Error;\n use crate::formats::cache::Cache;\n@@ -1184,8 +1184,8 @@ fn render_deref_methods(\n     debug!(\"Render deref methods for {:#?}, target {:#?}\", impl_.inner_impl().for_, target);\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n-    if let Some(did) = target.def_id_full(cache) {\n-        if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cache) {\n+    if let Some(did) = target.def_id(cache) {\n+        if let Some(type_did) = impl_.inner_impl().for_.def_id(cache) {\n             // `impl Deref<Target = S> for S`\n             if did == type_did {\n                 // Avoid infinite cycles\n@@ -1231,7 +1231,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n fn notable_traits_decl(decl: &clean::FnDecl, cx: &Context<'_>) -> String {\n     let mut out = Buffer::html();\n \n-    if let Some(did) = decl.output.def_id_full(cx.cache()) {\n+    if let Some(did) = decl.output.as_return().and_then(|t| t.def_id(cx.cache())) {\n         if let Some(impls) = cx.cache().impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n@@ -2074,8 +2074,8 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n         })\n     {\n         debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id_full(c) {\n-            if let Some(type_did) = impl_.inner_impl().for_.def_id_full(c) {\n+        if let Some(did) = target.def_id(c) {\n+            if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n                 // `impl Deref<Target = S> for S`\n                 if did == type_did {\n                     // Avoid infinite cycles\n@@ -2085,7 +2085,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n         }\n         let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n         let inner_impl = target\n-            .def_id_full(c)\n+            .def_id(c)\n             .or_else(|| {\n                 target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n             })\n@@ -2246,10 +2246,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n         let mut res = implementors\n             .iter()\n             .filter(|i| {\n-                i.inner_impl()\n-                    .for_\n-                    .def_id_full(cache)\n-                    .map_or(false, |d| !cache.paths.contains_key(&d))\n+                i.inner_impl().for_.def_id(cache).map_or(false, |d| !cache.paths.contains_key(&d))\n             })\n             .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n             .collect::<Vec<_>>();"}, {"sha": "1677b4adf827dbff602985ca38bc2fc084fae04b", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -21,7 +21,7 @@ use super::{\n     render_impl, render_stability_since_raw, write_srclink, AssocItemLink, Context,\n     ImplRenderingParameters,\n };\n-use crate::clean::{self, GetDefId};\n+use crate::clean;\n use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n@@ -742,7 +742,7 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id_full(cache).map_or(true, |d| cache.paths.contains_key(&d))\n+            i.inner_impl().for_.def_id(cache).map_or(true, |d| cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) ="}, {"sha": "91a0cb413eb28d0f3017ebbb274a05775b3dc2f7", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -70,7 +70,7 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n \n                 if let Some(prim) = target.primitive_type() {\n                     cleaner.prims.insert(prim);\n-                } else if let Some(did) = target.def_id() {\n+                } else if let Some(did) = target.def_id(&cx.cache) {\n                     cleaner.items.insert(did.into());\n                 }\n             }\n@@ -187,7 +187,7 @@ impl BadImplStripper {\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n-        } else if let Some(did) = ty.def_id() {\n+        } else if let Some(did) = ty.def_id_no_primitives() {\n             self.keep_impl_with_def_id(did.into())\n         } else {\n             false"}, {"sha": "74a9a2da06d36db0b117a930f588435c5dbb91ee", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::privacy::AccessLevels;\n use std::mem;\n \n-use crate::clean::{self, GetDefId, Item, ItemIdSet};\n+use crate::clean::{self, Item, ItemIdSet};\n use crate::fold::{strip_item, DocFolder};\n \n crate struct Stripper<'a> {\n@@ -127,7 +127,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n             if imp.trait_.is_none() && imp.items.is_empty() {\n                 return None;\n             }\n-            if let Some(did) = imp.for_.def_id() {\n+            if let Some(did) = imp.for_.def_id_no_primitives() {\n                 if did.is_local() && !imp.for_.is_assoc_ty() && !self.retained.contains(&did.into())\n                 {\n                     debug!(\"ImplStripper: impl item for stripped type; removing\");\n@@ -142,7 +142,7 @@ impl<'a> DocFolder for ImplStripper<'a> {\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n-                    if let Some(did) = typaram.def_id() {\n+                    if let Some(did) = typaram.def_id_no_primitives() {\n                         if did.is_local() && !self.retained.contains(&did.into()) {\n                             debug!(\n                                 \"ImplStripper: stripped item in trait's generics; removing impl\""}, {"sha": "94e82e3d9f7664f993ea6fcb2db1e0a9a156d1df", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eebfeea62c603cbfa52c594899191e259cddc8/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=e3eebfeea62c603cbfa52c594899191e259cddc8", "patch": "@@ -85,6 +85,8 @@ const INTRA_DOC_LINK_EXCEPTIONS: &[(&str, &[&str])] = &[\n     (\"core/slice/trait.SliceIndex.html\", &[\"begin</code>, <code>end\"]),\n     (\"alloc/slice/trait.SliceIndex.html\", &[\"begin</code>, <code>end\"]),\n     (\"std/slice/trait.SliceIndex.html\", &[\"begin</code>, <code>end\"]),\n+    (\"core/primitive.str.html\", &[\"begin</code>, <code>end\"]),\n+    (\"std/primitive.str.html\", &[\"begin</code>, <code>end\"]),\n \n ];\n "}]}