{"sha": "6256bff7a355a0dca497d8352080883d437d7765", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyNTZiZmY3YTM1NWEwZGNhNDk3ZDgzNTIwODA4ODNkNDM3ZDc3NjU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-19T11:57:18Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2018-01-22T09:54:32Z"}, "message": "Move the figuring out of the 'kind' of def out into functions", "tree": {"sha": "b5ca2fe80ecaf22513ff76c84881fcb4e983f41b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5ca2fe80ecaf22513ff76c84881fcb4e983f41b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6256bff7a355a0dca497d8352080883d437d7765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6256bff7a355a0dca497d8352080883d437d7765", "html_url": "https://github.com/rust-lang/rust/commit/6256bff7a355a0dca497d8352080883d437d7765", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6256bff7a355a0dca497d8352080883d437d7765/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5762fa4b5a22276626414d94b38b0e7886396089", "url": "https://api.github.com/repos/rust-lang/rust/commits/5762fa4b5a22276626414d94b38b0e7886396089", "html_url": "https://github.com/rust-lang/rust/commit/5762fa4b5a22276626414d94b38b0e7886396089"}], "stats": {"total": 101, "additions": 64, "deletions": 37}, "files": [{"sha": "adc2390e93dde53510d7cc7478b8cf5202b272e5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/6256bff7a355a0dca497d8352080883d437d7765/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6256bff7a355a0dca497d8352080883d437d7765/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6256bff7a355a0dca497d8352080883d437d7765", "patch": "@@ -836,6 +836,62 @@ impl AttributesExt for Attributes {\n     }\n }\n \n+/// Given a def, returns its name and disambiguator\n+/// for a value namespace\n+///\n+/// Returns None for things which cannot be ambiguous since\n+/// they exist in both namespaces (structs and modules)\n+fn value_ns_kind(def: Def, path_str: &str) -> Option<(&'static str, String)> {\n+    match def {\n+        // structs and mods exist in both namespaces. skip them\n+        Def::StructCtor(..) | Def::Mod(..) => None,\n+        Def::Variant(..) | Def::VariantCtor(..)\n+            => Some((\"variant\", format!(\"{}()\", path_str))),\n+        Def::Fn(..)\n+            => Some((\"function\", format!(\"{}()\", path_str))),\n+        Def::Method(..)\n+            => Some((\"method\", format!(\"{}()\", path_str))),\n+        Def::Const(..)\n+            => Some((\"const\", format!(\"const@{}\", path_str))),\n+        Def::Static(..)\n+            => Some((\"static\", format!(\"static@{}\", path_str))),\n+        _ => Some((\"value\", format!(\"value@{}\", path_str))),\n+    }\n+}\n+\n+/// Given a def, returns its name, the article to be used, and a disambiguator\n+/// for the type namespace\n+fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String) {\n+    let (kind, article) = match def {\n+        // we can still have non-tuple structs\n+        Def::Struct(..) => (\"struct\", \"a\"),\n+        Def::Enum(..) => (\"enum\", \"an\"),\n+        Def::Trait(..) => (\"trait\", \"a\"),\n+        Def::Union(..) => (\"union\", \"a\"),\n+        _ => (\"type\", \"a\"),\n+    };\n+    (kind, article, format!(\"{}@{}\", kind, path_str))\n+}\n+\n+fn ambiguity_error(cx: &DocContext, attrs: &Attributes,\n+                   path_str: &str,\n+                   article1: &str, kind1: &str, disambig1: &str,\n+                   article2: &str, kind2: &str, disambig2: &str) {\n+    let sp = attrs.doc_strings.first()\n+                  .map_or(DUMMY_SP, |a| a.span());\n+    cx.sess()\n+      .struct_span_err(sp,\n+                       &format!(\"`{}` is both {} {} and {} {}\",\n+                                path_str, article1, kind1,\n+                                article2, kind2))\n+      .help(&format!(\"try `{0}` if you want to select the {1}, \\\n+                      or `{2}@{3}` if you want to \\\n+                      select the {2}\",\n+                      disambig1, kind1, disambig2,\n+                      kind2))\n+             .emit();\n+}\n+\n enum PathKind {\n     /// can be either value or type, not a macro\n     Unknown,\n@@ -846,6 +902,7 @@ enum PathKind {\n     /// types, traits, everything in the type namespace\n     Type\n }\n+\n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext) -> Attributes {\n         let mut attrs = Attributes::from_ast(cx.sess().diagnostic(), self);\n@@ -957,43 +1014,13 @@ impl Clean<Attributes> for [ast::Attribute] {\n                             if let Ok(path) = resolve(false) {\n                                 // if there is something in both namespaces\n                                 if let Ok(value_path) = resolve(true) {\n-                                    let kind = match value_path.def {\n-                                        // structs and mods exist in both namespaces. skip them\n-                                        Def::StructCtor(..) | Def::Mod(..) => None,\n-                                        Def::Variant(..) | Def::VariantCtor(..)\n-                                            => Some((\"variant\", format!(\"{}()\", path_str))),\n-                                        Def::Fn(..)\n-                                            => Some((\"function\", format!(\"{}()\", path_str))),\n-                                        Def::Method(..)\n-                                            => Some((\"method\", format!(\"{}()\", path_str))),\n-                                        Def::Const(..)\n-                                            => Some((\"const\", format!(\"const@{}\", path_str))),\n-                                        Def::Static(..)\n-                                            => Some((\"static\", format!(\"static@{}\", path_str))),\n-                                        _ => Some((\"value\", format!(\"static@{}\", path_str))),\n-                                    };\n-                                    if let Some((value_kind, disambig)) = kind {\n-                                        let (type_kind, article) = match path.def {\n-                                            // we can still have non-tuple structs\n-                                            Def::Struct(..) => (\"struct\", \"a\"),\n-                                            Def::Enum(..) => (\"enum\", \"an\"),\n-                                            Def::Trait(..) => (\"trait\", \"a\"),\n-                                            Def::Union(..) => (\"union\", \"a\"),\n-                                            _ => (\"type\", \"a\"),\n-                                        };\n-                                        let sp = attrs.doc_strings.first()\n-                                                      .map_or(DUMMY_SP, |a| a.span());\n-                                        cx.sess()\n-                                          .struct_span_err(sp,\n-                                                           &format!(\"`{}` is both {} {} and a {}\",\n-                                                                    path_str, article, type_kind,\n-                                                                    value_kind))\n-                                          .help(&format!(\"try `{0}` if you want to select the {1}, \\\n-                                                          or `{2}@{3}` if you want to \\\n-                                                          select the {2}\",\n-                                                          disambig, value_kind, type_kind,\n-                                                          path_str))\n-                                                 .emit();\n+                                    let kind = value_ns_kind(value_path.def, path_str);\n+                                    if let Some((value_kind, value_disambig)) = kind {\n+                                        let (type_kind, article, type_disambig)\n+                                            = type_ns_kind(path.def);\n+                                        ambiguity_error(cx, &attrs,\n+                                                        article, type_kind, type_disambig,\n+                                                        \"a\", value_kind, value_disambig);\n                                         continue;\n                                     }\n                                 }"}]}