{"sha": "d71d13e82d5a7cb3037a70d2ac18453db6dacca7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MWQxM2U4MmQ1YTdjYjMwMzdhNzBkMmFjMTg0NTNkYjZkYWNjYTc=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-09-26T18:46:44Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-10-02T23:06:55Z"}, "message": "BTreeMap: refactoring around edges, missed spots", "tree": {"sha": "721b701291003f7dcdf4c9f5da3c911525d3ec86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/721b701291003f7dcdf4c9f5da3c911525d3ec86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d71d13e82d5a7cb3037a70d2ac18453db6dacca7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d71d13e82d5a7cb3037a70d2ac18453db6dacca7", "html_url": "https://github.com/rust-lang/rust/commit/d71d13e82d5a7cb3037a70d2ac18453db6dacca7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d71d13e82d5a7cb3037a70d2ac18453db6dacca7/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc42fb8e70af6ad63998f4bfbf62451551eda073", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc42fb8e70af6ad63998f4bfbf62451551eda073", "html_url": "https://github.com/rust-lang/rust/commit/fc42fb8e70af6ad63998f4bfbf62451551eda073"}], "stats": {"total": 14, "additions": 7, "deletions": 7}, "files": [{"sha": "9c8ba72e8e6497ab3836a55bbb55e94f8466f45c", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d71d13e82d5a7cb3037a70d2ac18453db6dacca7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d71d13e82d5a7cb3037a70d2ac18453db6dacca7/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=d71d13e82d5a7cb3037a70d2ac18453db6dacca7", "patch": "@@ -484,15 +484,15 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    pub unsafe fn key_mut_at(&mut self, idx: usize) -> &mut K {\n+    unsafe fn key_mut_at(&mut self, idx: usize) -> &mut K {\n         unsafe { self.reborrow_mut().into_key_mut_at(idx) }\n     }\n \n     /// Borrows a mutable reference to one of the values stored in the node.\n     ///\n     /// # Safety\n     /// The node has more than `idx` initialized elements.\n-    pub unsafe fn val_mut_at(&mut self, idx: usize) -> &mut V {\n+    unsafe fn val_mut_at(&mut self, idx: usize) -> &mut V {\n         unsafe { self.reborrow_mut().into_val_mut_at(idx) }\n     }\n \n@@ -655,7 +655,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n \n     /// Adds a key/value pair, and an edge to go to the left of that pair,\n     /// to the beginning of the node.\n-    pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n+    fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n \n@@ -1011,18 +1011,18 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n             let (middle_kv_idx, insertion) = splitpoint(self.idx);\n             let middle = unsafe { Handle::new_kv(self.node, middle_kv_idx) };\n             let (mut left, k, v, mut right) = middle.split();\n-            match insertion {\n+            let mut insertion_edge = match insertion {\n                 InsertionPlace::Left(insert_idx) => unsafe {\n-                    Handle::new_edge(left.reborrow_mut(), insert_idx).insert_fit(key, val, edge);\n+                    Handle::new_edge(left.reborrow_mut(), insert_idx)\n                 },\n                 InsertionPlace::Right(insert_idx) => unsafe {\n                     Handle::new_edge(\n                         right.node_as_mut().cast_unchecked::<marker::Internal>(),\n                         insert_idx,\n                     )\n-                    .insert_fit(key, val, edge);\n                 },\n-            }\n+            };\n+            insertion_edge.insert_fit(key, val, edge);\n             InsertResult::Split(SplitResult { left: left.forget_type(), k, v, right })\n         }\n     }"}]}