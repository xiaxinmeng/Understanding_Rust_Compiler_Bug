{"sha": "de56279cd9047832216e1d1c06dc45375bf01b31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNTYyNzljZDkwNDc4MzIyMTZlMWQxYzA2ZGM0NTM3NWJmMDFiMzE=", "commit": {"author": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-06-10T23:06:13Z"}, "committer": {"name": "rail", "email": "12975677+rail-rain@users.noreply.github.com", "date": "2020-09-24T21:02:05Z"}, "message": "Implement building the `manual_memcpy` sugggestion with loop counters", "tree": {"sha": "941112aff77a74161551d08f055d3ec64830a61e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/941112aff77a74161551d08f055d3ec64830a61e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de56279cd9047832216e1d1c06dc45375bf01b31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de56279cd9047832216e1d1c06dc45375bf01b31", "html_url": "https://github.com/rust-lang/rust/commit/de56279cd9047832216e1d1c06dc45375bf01b31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de56279cd9047832216e1d1c06dc45375bf01b31/comments", "author": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rail-rain", "id": 12975677, "node_id": "MDQ6VXNlcjEyOTc1Njc3", "avatar_url": "https://avatars.githubusercontent.com/u/12975677?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rail-rain", "html_url": "https://github.com/rail-rain", "followers_url": "https://api.github.com/users/rail-rain/followers", "following_url": "https://api.github.com/users/rail-rain/following{/other_user}", "gists_url": "https://api.github.com/users/rail-rain/gists{/gist_id}", "starred_url": "https://api.github.com/users/rail-rain/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rail-rain/subscriptions", "organizations_url": "https://api.github.com/users/rail-rain/orgs", "repos_url": "https://api.github.com/users/rail-rain/repos", "events_url": "https://api.github.com/users/rail-rain/events{/privacy}", "received_events_url": "https://api.github.com/users/rail-rain/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "720f19f2ec4282f636889b35beabf31272e3b1b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/720f19f2ec4282f636889b35beabf31272e3b1b2", "html_url": "https://github.com/rust-lang/rust/commit/720f19f2ec4282f636889b35beabf31272e3b1b2"}], "stats": {"total": 263, "additions": 213, "deletions": 50}, "files": [{"sha": "bd2ae47b723473f52ae2ec5b1207392f4415ef34", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 140, "deletions": 45, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/de56279cd9047832216e1d1c06dc45375bf01b31/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56279cd9047832216e1d1c06dc45375bf01b31/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=de56279cd9047832216e1d1c06dc45375bf01b31", "patch": "@@ -800,27 +800,108 @@ enum OffsetSign {\n }\n \n struct Offset {\n-    value: String,\n+    value: MinifyingSugg<'static>,\n     sign: OffsetSign,\n }\n \n impl Offset {\n-    fn negative(value: String) -> Self {\n+    fn negative(value: MinifyingSugg<'static>) -> Self {\n         Self {\n             value,\n             sign: OffsetSign::Negative,\n         }\n     }\n \n-    fn positive(value: String) -> Self {\n+    fn positive(value: MinifyingSugg<'static>) -> Self {\n         Self {\n             value,\n             sign: OffsetSign::Positive,\n         }\n     }\n \n     fn empty() -> Self {\n-        Self::positive(\"0\".into())\n+        Self::positive(MinifyingSugg::non_paren(\"0\"))\n+    }\n+}\n+\n+fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n+    match rhs.sign {\n+        OffsetSign::Positive => lhs + &rhs.value,\n+        OffsetSign::Negative => lhs - &rhs.value,\n+    }\n+}\n+\n+#[derive(Clone)]\n+struct MinifyingSugg<'a>(sugg::Sugg<'a>);\n+\n+impl std::fmt::Display for MinifyingSugg<'_> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n+        std::fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl<'a> MinifyingSugg<'a> {\n+    fn as_str(&self) -> &str {\n+        let sugg::Sugg::NonParen(s) | sugg::Sugg::MaybeParen(s) | sugg::Sugg::BinOp(_, s) = &self.0;\n+        s.as_ref()\n+    }\n+\n+    fn hir(cx: &LateContext<'_, '_>, expr: &Expr<'_>, default: &'a str) -> Self {\n+        Self(sugg::Sugg::hir(cx, expr, default))\n+    }\n+\n+    fn maybe_par(self) -> Self {\n+        Self(self.0.maybe_par())\n+    }\n+\n+    fn non_paren(str: impl Into<std::borrow::Cow<'a, str>>) -> Self {\n+        Self(sugg::Sugg::NonParen(str.into()))\n+    }\n+}\n+\n+impl std::ops::Add for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self.clone(),\n+            (_, _) => MinifyingSugg(&self.0 + &rhs.0),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self.clone(),\n+            (\"0\", _) => MinifyingSugg(sugg::make_unop(\"-\", rhs.0.clone())),\n+            (x, y) if x == y => MinifyingSugg::non_paren(\"0\"),\n+            (_, _) => MinifyingSugg(&self.0 - &rhs.0),\n+        }\n+    }\n+}\n+\n+impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self,\n+            (_, _) => MinifyingSugg(self.0 + &rhs.0),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self,\n+            (\"0\", _) => MinifyingSugg(sugg::make_unop(\"-\", rhs.0.clone())),\n+            (x, y) if x == y => MinifyingSugg::non_paren(\"0\"),\n+            (_, _) => MinifyingSugg(self.0 - &rhs.0),\n+        }\n     }\n }\n \n@@ -878,14 +959,15 @@ fn get_offset<'tcx>(\n         cx: &LateContext<'tcx>,\n         e: &Expr<'_>,\n         starts: &[Start<'tcx>],\n-    ) -> Option<String> {\n+    ) -> Option<MinifyingSugg<'static>> {\n         match &e.kind {\n             ExprKind::Lit(l) => match l.node {\n-                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                ast::LitKind::Int(x, _ty) => Some(MinifyingSugg::non_paren(x.to_string())),\n                 _ => None,\n             },\n             ExprKind::Path(..) if extract_start(cx, e, starts).is_none() => {\n-                Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into()))\n+                // `e` is always non paren as it's a `Path`\n+                Some(MinifyingSugg::non_paren(snippet(cx, e.span, \"???\")))\n             },\n             _ => None,\n         }\n@@ -979,75 +1061,88 @@ fn build_manual_memcpy_suggestion<'tcx>(\n     dst: IndexExpr<'_>,\n     src: IndexExpr<'_>,\n ) -> String {\n-    fn print_sum(arg1: &str, arg2: &Offset) -> String {\n-        match (arg1, &arg2.value[..], arg2.sign) {\n-            (\"0\", \"0\", _) => \"0\".into(),\n-            (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n-            (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n-            (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n-            (x, y, OffsetSign::Negative) => {\n-                if x == y {\n-                    \"0\".into()\n-                } else {\n-                    format!(\"({} - {})\", x, y)\n-                }\n-            },\n-        }\n-    }\n-\n-    fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n-        let offset = print_sum(start_str, inline_offset);\n+    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n         if offset.as_str() == \"0\" {\n-            \"\".into()\n+            MinifyingSugg::non_paren(\"\")\n         } else {\n             offset\n         }\n     }\n \n-    let print_limit = |end: &Expr<'_>, offset: Offset, base: &Expr<'_>| {\n+    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| -> MinifyingSugg<'static> {\n         if_chain! {\n             if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n             if method.ident.name == sym!(len);\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n             if var_def_id(cx, arg) == var_def_id(cx, base);\n             then {\n-                match offset.sign {\n-                    OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n-                    OffsetSign::Positive => \"\".into(),\n+                if sugg.as_str() == end_str {\n+                    MinifyingSugg::non_paren(\"\")\n+                } else {\n+                    sugg\n                 }\n             } else {\n-                let end_str = match limits {\n+                match limits {\n                     ast::RangeLimits::Closed => {\n-                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                        format!(\"{}\", end + sugg::ONE)\n+                        sugg + &MinifyingSugg::non_paren(\"1\")\n                     },\n-                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                };\n-\n-                print_sum(&end_str, &offset)\n+                    ast::RangeLimits::HalfOpen => sugg,\n+                }\n             }\n         }\n     };\n \n-    let start_str = snippet(cx, start.span, \"\").to_string();\n-    let dst_offset = print_offset(&start_str, &dst.idx_offset);\n-    let dst_limit = print_limit(end, dst.idx_offset, dst.base);\n-    let src_offset = print_offset(&start_str, &src.idx_offset);\n-    let src_limit = print_limit(end, src.idx_offset, src.base);\n+    let start_str = MinifyingSugg::hir(cx, start, \"\");\n+    let end_str = MinifyingSugg::hir(cx, end, \"\");\n+\n+    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n+        StartKind::Range => (\n+            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)),\n+            print_limit(\n+                end,\n+                end_str.as_str(),\n+                idx_expr.base,\n+                apply_offset(&end_str, &idx_expr.idx_offset),\n+            ),\n+        ),\n+        StartKind::Counter { initializer } => {\n+            let counter_start = MinifyingSugg::hir(cx, initializer, \"\");\n+            (\n+                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)),\n+                print_limit(\n+                    end,\n+                    end_str.as_str(),\n+                    idx_expr.base,\n+                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n+                ),\n+            )\n+        },\n+    };\n+\n+    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(&src);\n \n     let dst_base_str = snippet_opt(cx, dst.base.span).unwrap_or_else(|| \"???\".into());\n     let src_base_str = snippet_opt(cx, src.base.span).unwrap_or_else(|| \"???\".into());\n \n-    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n+    let dst = if dst_offset.as_str() == \"\" && dst_limit.as_str() == \"\" {\n         dst_base_str\n     } else {\n-        format!(\"{}[{}..{}]\", dst_base_str, dst_offset, dst_limit)\n+        format!(\n+            \"{}[{}..{}]\",\n+            dst_base_str,\n+            dst_offset.maybe_par(),\n+            dst_limit.maybe_par()\n+        )\n     };\n \n     format!(\n         \"{}.clone_from_slice(&{}[{}..{}])\",\n-        dst, src_base_str, src_offset, src_limit\n+        dst,\n+        src_base_str,\n+        src_offset.maybe_par(),\n+        src_limit.maybe_par()\n     )\n }\n "}, {"sha": "50d48650a0938d8ecd5e8b5d8bdda0bb100c5ffe", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 73, "deletions": 5, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/de56279cd9047832216e1d1c06dc45375bf01b31/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de56279cd9047832216e1d1c06dc45375bf01b31/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=de56279cd9047832216e1d1c06dc45375bf01b31", "patch": "@@ -36,6 +36,46 @@ impl Display for Sugg<'_> {\n     }\n }\n \n+// It's impossible to derive Clone due to the lack of the impl Clone for AssocOp\n+impl Clone for Sugg<'_> {\n+    fn clone(&self) -> Self {\n+        /// manually cloning AssocOp\n+        fn clone_assoc_op(this: &AssocOp) -> AssocOp {\n+            match this {\n+                AssocOp::Add => AssocOp::Add,\n+                AssocOp::Subtract => AssocOp::Subtract,\n+                AssocOp::Multiply => AssocOp::Multiply,\n+                AssocOp::Divide => AssocOp::Divide,\n+                AssocOp::Modulus => AssocOp::Modulus,\n+                AssocOp::LAnd => AssocOp::LAnd,\n+                AssocOp::LOr => AssocOp::LOr,\n+                AssocOp::BitXor => AssocOp::BitXor,\n+                AssocOp::BitAnd => AssocOp::BitAnd,\n+                AssocOp::BitOr => AssocOp::BitOr,\n+                AssocOp::ShiftLeft => AssocOp::ShiftLeft,\n+                AssocOp::ShiftRight => AssocOp::ShiftRight,\n+                AssocOp::Equal => AssocOp::Equal,\n+                AssocOp::Less => AssocOp::Less,\n+                AssocOp::LessEqual => AssocOp::LessEqual,\n+                AssocOp::NotEqual => AssocOp::NotEqual,\n+                AssocOp::Greater => AssocOp::Greater,\n+                AssocOp::GreaterEqual => AssocOp::GreaterEqual,\n+                AssocOp::Assign => AssocOp::Assign,\n+                AssocOp::AssignOp(t) => AssocOp::AssignOp(*t),\n+                AssocOp::As => AssocOp::As,\n+                AssocOp::DotDot => AssocOp::DotDot,\n+                AssocOp::DotDotEq => AssocOp::DotDotEq,\n+                AssocOp::Colon => AssocOp::Colon,\n+            }\n+        }\n+        match self {\n+            Sugg::NonParen(x) => Sugg::NonParen(x.clone()),\n+            Sugg::MaybeParen(x) => Sugg::MaybeParen(x.clone()),\n+            Sugg::BinOp(op, x) => Sugg::BinOp(clone_assoc_op(op), x.clone()),\n+        }\n+    }\n+}\n+\n #[allow(clippy::wrong_self_convention)] // ok, because of the function `as_ty` method\n impl<'a> Sugg<'a> {\n     /// Prepare a suggestion from an expression.\n@@ -267,21 +307,49 @@ impl<'a> Sugg<'a> {\n     }\n }\n \n-impl<'a, 'b> std::ops::Add<Sugg<'b>> for Sugg<'a> {\n+impl std::ops::Add for Sugg<'_> {\n     type Output = Sugg<'static>;\n-    fn add(self, rhs: Sugg<'b>) -> Sugg<'static> {\n+    fn add(self, rhs: Sugg<'_>) -> Sugg<'static> {\n         make_binop(ast::BinOpKind::Add, &self, &rhs)\n     }\n }\n \n-impl<'a, 'b> std::ops::Sub<Sugg<'b>> for Sugg<'a> {\n+impl std::ops::Sub for Sugg<'_> {\n     type Output = Sugg<'static>;\n-    fn sub(self, rhs: Sugg<'b>) -> Sugg<'static> {\n+    fn sub(self, rhs: Sugg<'_>) -> Sugg<'static> {\n         make_binop(ast::BinOpKind::Sub, &self, &rhs)\n     }\n }\n \n-impl<'a> std::ops::Not for Sugg<'a> {\n+impl std::ops::Add<&Sugg<'_>> for Sugg<'_> {\n+    type Output = Sugg<'static>;\n+    fn add(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Add, &self, rhs)\n+    }\n+}\n+\n+impl std::ops::Sub<&Sugg<'_>> for Sugg<'_> {\n+    type Output = Sugg<'static>;\n+    fn sub(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Sub, &self, rhs)\n+    }\n+}\n+\n+impl std::ops::Add for &Sugg<'_> {\n+    type Output = Sugg<'static>;\n+    fn add(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Add, self, rhs)\n+    }\n+}\n+\n+impl std::ops::Sub for &Sugg<'_> {\n+    type Output = Sugg<'static>;\n+    fn sub(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Sub, self, rhs)\n+    }\n+}\n+\n+impl std::ops::Not for Sugg<'_> {\n     type Output = Sugg<'static>;\n     fn not(self) -> Sugg<'static> {\n         make_unop(\"!\", self)"}]}