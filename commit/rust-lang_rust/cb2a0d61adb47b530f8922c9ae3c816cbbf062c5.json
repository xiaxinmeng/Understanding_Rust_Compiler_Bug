{"sha": "cb2a0d61adb47b530f8922c9ae3c816cbbf062c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMmEwZDYxYWRiNDdiNTMwZjg5MjJjOWFlM2M4MTZjYmJmMDYyYzU=", "commit": {"author": {"name": "Guillaume Girol", "email": "symphorien+git@xlumurb.eu", "date": "2018-05-24T21:50:28Z"}, "committer": {"name": "Guillaume Girol", "email": "symphorien+git@xlumurb.eu", "date": "2018-05-30T18:52:30Z"}, "message": "std::fs::DirEntry.metadata(): use fstatat instead of lstat when possible", "tree": {"sha": "af6643f38ac869db26395af6edc9a79f52ab55f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af6643f38ac869db26395af6edc9a79f52ab55f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb2a0d61adb47b530f8922c9ae3c816cbbf062c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb2a0d61adb47b530f8922c9ae3c816cbbf062c5", "html_url": "https://github.com/rust-lang/rust/commit/cb2a0d61adb47b530f8922c9ae3c816cbbf062c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb2a0d61adb47b530f8922c9ae3c816cbbf062c5/comments", "author": {"login": "symphorien", "id": 12595971, "node_id": "MDQ6VXNlcjEyNTk1OTcx", "avatar_url": "https://avatars.githubusercontent.com/u/12595971?v=4", "gravatar_id": "", "url": "https://api.github.com/users/symphorien", "html_url": "https://github.com/symphorien", "followers_url": "https://api.github.com/users/symphorien/followers", "following_url": "https://api.github.com/users/symphorien/following{/other_user}", "gists_url": "https://api.github.com/users/symphorien/gists{/gist_id}", "starred_url": "https://api.github.com/users/symphorien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/symphorien/subscriptions", "organizations_url": "https://api.github.com/users/symphorien/orgs", "repos_url": "https://api.github.com/users/symphorien/repos", "events_url": "https://api.github.com/users/symphorien/events{/privacy}", "received_events_url": "https://api.github.com/users/symphorien/received_events", "type": "User", "site_admin": false}, "committer": {"login": "symphorien", "id": 12595971, "node_id": "MDQ6VXNlcjEyNTk1OTcx", "avatar_url": "https://avatars.githubusercontent.com/u/12595971?v=4", "gravatar_id": "", "url": "https://api.github.com/users/symphorien", "html_url": "https://github.com/symphorien", "followers_url": "https://api.github.com/users/symphorien/followers", "following_url": "https://api.github.com/users/symphorien/following{/other_user}", "gists_url": "https://api.github.com/users/symphorien/gists{/gist_id}", "starred_url": "https://api.github.com/users/symphorien/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/symphorien/subscriptions", "organizations_url": "https://api.github.com/users/symphorien/orgs", "repos_url": "https://api.github.com/users/symphorien/repos", "events_url": "https://api.github.com/users/symphorien/events{/privacy}", "received_events_url": "https://api.github.com/users/symphorien/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74d09399c1289a20b1c258153f005f2604f9ec46", "url": "https://api.github.com/repos/rust-lang/rust/commits/74d09399c1289a20b1c258153f005f2604f9ec46", "html_url": "https://github.com/rust-lang/rust/commit/74d09399c1289a20b1c258153f005f2604f9ec46"}], "stats": {"total": 43, "additions": 32, "deletions": 11}, "files": [{"sha": "007511a992b93cefabe82bb5fd5bd725618af96d", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/cb2a0d61adb47b530f8922c9ae3c816cbbf062c5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb2a0d61adb47b530f8922c9ae3c816cbbf062c5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=cb2a0d61adb47b530f8922c9ae3c816cbbf062c5", "patch": "@@ -25,6 +25,8 @@ use sys_common::{AsInner, FromInner};\n \n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\n use libc::{stat64, fstat64, lstat64, off64_t, ftruncate64, lseek64, dirent64, readdir64_r, open64};\n+#[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n+use libc::{fstatat, dirfd};\n #[cfg(target_os = \"android\")]\n use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, lseek64,\n            dirent as dirent64, open as open64};\n@@ -48,20 +50,24 @@ pub struct FileAttr {\n     stat: stat64,\n }\n \n-pub struct ReadDir {\n+// all DirEntry's will have a reference to this struct\n+struct InnerReadDir {\n     dirp: Dir,\n-    root: Arc<PathBuf>,\n+    root: PathBuf,\n }\n \n+#[derive(Clone)]\n+pub struct ReadDir(Arc<InnerReadDir>);\n+\n struct Dir(*mut libc::DIR);\n \n unsafe impl Send for Dir {}\n unsafe impl Sync for Dir {}\n \n pub struct DirEntry {\n     entry: dirent64,\n-    root: Arc<PathBuf>,\n-    // We need to store an owned copy of the directory name\n+    dir: ReadDir,\n+    // We need to store an owned copy of the entry name\n     // on Solaris and Fuchsia because a) it uses a zero-length\n     // array to store the name, b) its lifetime between readdir\n     // calls is not guaranteed.\n@@ -207,7 +213,7 @@ impl fmt::Debug for ReadDir {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n         // Thus the result will be e g 'ReadDir(\"/home\")'\n-        fmt::Debug::fmt(&*self.root, f)\n+        fmt::Debug::fmt(&*self.0.root, f)\n     }\n }\n \n@@ -240,7 +246,7 @@ impl Iterator for ReadDir {\n                     entry: *entry_ptr,\n                     name: ::slice::from_raw_parts(name as *const u8,\n                                                   namelen as usize).to_owned().into_boxed_slice(),\n-                    root: self.root.clone()\n+                    dir: self.clone()\n                 };\n                 if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n                     return Some(Ok(ret))\n@@ -254,11 +260,11 @@ impl Iterator for ReadDir {\n         unsafe {\n             let mut ret = DirEntry {\n                 entry: mem::zeroed(),\n-                root: self.root.clone()\n+                dir: self.clone(),\n             };\n             let mut entry_ptr = ptr::null_mut();\n             loop {\n-                if readdir64_r(self.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n+                if readdir64_r(self.0.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n                     return Some(Err(Error::last_os_error()))\n                 }\n                 if entry_ptr.is_null() {\n@@ -281,13 +287,27 @@ impl Drop for Dir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        self.root.join(OsStr::from_bytes(self.name_bytes()))\n+        self.dir.0.root.join(OsStr::from_bytes(self.name_bytes()))\n     }\n \n     pub fn file_name(&self) -> OsString {\n         OsStr::from_bytes(self.name_bytes()).to_os_string()\n     }\n \n+    #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\"))]\n+    pub fn metadata(&self) -> io::Result<FileAttr> {\n+        let fd = cvt(unsafe {dirfd(self.dir.0.dirp.0)})?;\n+        let mut stat: stat64 = unsafe { mem::zeroed() };\n+        cvt(unsafe {\n+            fstatat(fd,\n+                    self.entry.d_name.as_ptr(),\n+                    &mut stat as *mut _ as *mut _,\n+                    libc::AT_SYMLINK_NOFOLLOW)\n+        })?;\n+        Ok(FileAttr { stat: stat })\n+    }\n+\n+    #[cfg(not(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"android\")))]\n     pub fn metadata(&self) -> io::Result<FileAttr> {\n         lstat(&self.path())\n     }\n@@ -664,14 +684,15 @@ impl fmt::Debug for File {\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = Arc::new(p.to_path_buf());\n+    let root = p.to_path_buf();\n     let p = cstr(p)?;\n     unsafe {\n         let ptr = libc::opendir(p.as_ptr());\n         if ptr.is_null() {\n             Err(Error::last_os_error())\n         } else {\n-            Ok(ReadDir { dirp: Dir(ptr), root: root })\n+            let inner = InnerReadDir { dirp: Dir(ptr), root };\n+            Ok(ReadDir(Arc::new(inner)))\n         }\n     }\n }"}]}