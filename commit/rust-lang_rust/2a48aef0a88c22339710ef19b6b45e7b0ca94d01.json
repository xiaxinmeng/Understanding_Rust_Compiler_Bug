{"sha": "2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNDhhZWYwYTg4YzIyMzM5NzEwZWYxOWI2YjQ1ZTdiMGNhOTRkMDE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-28T22:28:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-01-28T22:28:59Z"}, "message": "Merge remote-tracking branch 'thestinger/hashmap' into deriving", "tree": {"sha": "20abe5b6432d29b03d21241d0683263dd85c07ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20abe5b6432d29b03d21241d0683263dd85c07ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "html_url": "https://github.com/rust-lang/rust/commit/2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c75cc0aa1073ca91825d6513b9b23068a2a69f5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c75cc0aa1073ca91825d6513b9b23068a2a69f5a", "html_url": "https://github.com/rust-lang/rust/commit/c75cc0aa1073ca91825d6513b9b23068a2a69f5a"}, {"sha": "8eaf0737b75d7984a72bfd4393b4c1a9ab0a88e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eaf0737b75d7984a72bfd4393b4c1a9ab0a88e6", "html_url": "https://github.com/rust-lang/rust/commit/8eaf0737b75d7984a72bfd4393b4c1a9ab0a88e6"}], "stats": {"total": 96, "additions": 45, "deletions": 51}, "files": [{"sha": "da90a129e9a6351e9f31cce196100cf12c6c6637", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "patch": "@@ -465,20 +465,20 @@ fn parse_source(name: ~str, j: &json::Json) -> @Source {\n \n     match *j {\n         json::Object(j) => {\n-            let mut url = match j.find_copy(&~\"url\") {\n-                Some(json::String(u)) => u,\n+            let mut url = match j.find(&~\"url\") {\n+                Some(&json::String(u)) => copy u,\n                 _ => fail ~\"needed 'url' field in source\"\n             };\n-            let method = match j.find_copy(&~\"method\") {\n-                Some(json::String(u)) => u,\n+            let method = match j.find(&~\"method\") {\n+                Some(&json::String(u)) => copy u,\n                 _ => assume_source_method(url)\n             };\n-            let key = match j.find_copy(&~\"key\") {\n-                Some(json::String(u)) => Some(u),\n+            let key = match j.find(&~\"key\") {\n+                Some(&json::String(u)) => Some(copy u),\n                 _ => None\n             };\n-            let keyfp = match j.find_copy(&~\"keyfp\") {\n-                Some(json::String(u)) => Some(u),\n+            let keyfp = match j.find(&~\"keyfp\") {\n+                Some(&json::String(u)) => Some(copy u),\n                 _ => None\n             };\n             if method == ~\"file\" {\n@@ -512,8 +512,8 @@ fn try_parse_sources(filename: &Path, sources: map::HashMap<~str, @Source>) {\n }\n \n fn load_one_source_package(src: @Source, p: &json::Object) {\n-    let name = match p.find_copy(&~\"name\") {\n-        Some(json::String(n)) => {\n+    let name = match p.find(&~\"name\") {\n+        Some(&json::String(n)) => {\n             if !valid_pkg_name(n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + n + ~\"'\"+\n@@ -529,47 +529,47 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         }\n     };\n \n-    let uuid = match p.find_copy(&~\"uuid\") {\n-        Some(json::String(n)) => {\n+    let uuid = match p.find(&~\"uuid\") {\n+        Some(&json::String(n)) => {\n             if !is_uuid(n) {\n                 warn(~\"malformed source json: \"\n                      + src.name + ~\", '\" + n + ~\"'\"+\n                      ~\" is an invalid uuid\");\n                 return;\n             }\n-            n\n+            copy n\n         }\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing uuid)\");\n             return;\n         }\n     };\n \n-    let url = match p.find_copy(&~\"url\") {\n-        Some(json::String(n)) => n,\n+    let url = match p.find(&~\"url\") {\n+        Some(&json::String(n)) => copy n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name + ~\" (missing url)\");\n             return;\n         }\n     };\n \n-    let method = match p.find_copy(&~\"method\") {\n-        Some(json::String(n)) => n,\n+    let method = match p.find(&~\"method\") {\n+        Some(&json::String(n)) => copy n,\n         _ => {\n             warn(~\"malformed source json: \"\n                  + src.name + ~\" (missing method)\");\n             return;\n         }\n     };\n \n-    let reference = match p.find_copy(&~\"ref\") {\n-        Some(json::String(n)) => Some(n),\n+    let reference = match p.find(&~\"ref\") {\n+        Some(&json::String(n)) => Some(copy n),\n         _ => None\n     };\n \n     let mut tags = ~[];\n-    match p.find_copy(&~\"tags\") {\n-        Some(json::List(js)) => {\n+    match p.find(&~\"tags\") {\n+        Some(&json::List(js)) => {\n           for js.each |j| {\n                 match *j {\n                     json::String(ref j) => tags.grow(1u, j),\n@@ -580,8 +580,8 @@ fn load_one_source_package(src: @Source, p: &json::Object) {\n         _ => ()\n     }\n \n-    let description = match p.find_copy(&~\"description\") {\n-        Some(json::String(n)) => n,\n+    let description = match p.find(&~\"description\") {\n+        Some(&json::String(n)) => copy n,\n         _ => {\n             warn(~\"malformed source json: \" + src.name\n                  + ~\" (missing description)\");"}, {"sha": "47f0fcfd381bcb305689da3aaae396cc83328c7a", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "patch": "@@ -389,24 +389,6 @@ pub mod linear {\n         }\n     }\n \n-    impl<K: Hash IterBytes Eq, V: Copy> LinearMap<K, V> {\n-        pure fn find_copy(&self, k: &K) -> Option<V> {\n-            match self.bucket_for_key(self.buckets, k) {\n-                FoundEntry(idx) => {\n-                    // FIXME (#3148): Once we rewrite found_entry, this\n-                    // failure case won't be necessary\n-                    match self.buckets[idx] {\n-                        Some(Bucket {value: copy value, _}) => {Some(value)}\n-                        None => fail ~\"LinearMap::find: internal logic error\"\n-                    }\n-                }\n-                TableFull | FoundHole(_) => {\n-                    None\n-                }\n-            }\n-        }\n-    }\n-\n     impl<K: Hash IterBytes Eq, V: Eq> LinearMap<K, V>: Eq {\n         pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n@@ -560,8 +542,8 @@ pub mod test {\n         }\n         assert m.len() == 0;\n         assert m2.len() == 2;\n-        assert m2.find_copy(&1) == Some(2);\n-        assert m2.find_copy(&2) == Some(3);\n+        assert m2.get(&1) == &2;\n+        assert m2.get(&2) == &3;\n     }\n \n     #[test]"}, {"sha": "9f46ebef4401be8764984d8a539a63b1d85cb43c", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "patch": "@@ -167,15 +167,27 @@ struct Database {\n }\n \n impl Database {\n+    #[cfg(stage0)]\n+    #[cfg(stage1)]\n+    fn prepare(&mut self, fn_name: &str,\n+               declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n+    {\n+        let k = json_encode(&(fn_name, declared_inputs));\n+        let db_cache = copy self.db_cache;\n+        match db_cache.find(&k) {\n+            None => None,\n+            Some(&v) => Some(json_decode(copy v))\n+        }\n+    }\n \n-    fn prepare(&mut self,\n-               fn_name: &str,\n-               declared_inputs: &WorkMap) ->\n-        Option<(WorkMap, WorkMap, ~str)> {\n+    #[cfg(stage2)]\n+    fn prepare(&mut self, fn_name: &str,\n+               declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n+    {\n         let k = json_encode(&(fn_name, declared_inputs));\n-        match self.db_cache.find_copy(&k) {\n+        match self.db_cache.find(&k) {\n             None => None,\n-            Some(v) => Some(json_decode(v))\n+            Some(&v) => Some(json_decode(copy v))\n         }\n     }\n "}, {"sha": "4ea59fc4b6995f9c910dc5d6cb846406d2c41fdc", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a48aef0a88c22339710ef19b6b45e7b0ca94d01/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=2a48aef0a88c22339710ef19b6b45e7b0ca94d01", "patch": "@@ -23,9 +23,9 @@ enum object\n \n fn lookup(table: ~json::Object, key: ~str, default: ~str) -> ~str\n {\n-    match table.find_copy(&key)\n+    match table.find(&key)\n     {\n-        option::Some(std::json::String(copy s)) =>\n+        option::Some(&std::json::String(copy s)) =>\n         {\n             copy s\n         }"}]}