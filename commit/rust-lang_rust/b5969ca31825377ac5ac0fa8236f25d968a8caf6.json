{"sha": "b5969ca31825377ac5ac0fa8236f25d968a8caf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1OTY5Y2EzMTgyNTM3N2FjNWFjMGZhODIzNmYyNWQ5NjhhOGNhZjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-08-27T04:01:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-27T04:01:14Z"}, "message": "Rollup merge of #35877 - KiChjang:issue-35869, r=arielb1\n\nFix ICE when arg types can't be found in impl/trait methods while comparing\n\nFixes #35869.", "tree": {"sha": "350d2b1a46c15b45b9dd29cdd85ba28b1fdcff2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/350d2b1a46c15b45b9dd29cdd85ba28b1fdcff2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5969ca31825377ac5ac0fa8236f25d968a8caf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5969ca31825377ac5ac0fa8236f25d968a8caf6", "html_url": "https://github.com/rust-lang/rust/commit/b5969ca31825377ac5ac0fa8236f25d968a8caf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5969ca31825377ac5ac0fa8236f25d968a8caf6/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8da9472632997025f6e7cb3886d736bb9d0ef81", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8da9472632997025f6e7cb3886d736bb9d0ef81", "html_url": "https://github.com/rust-lang/rust/commit/e8da9472632997025f6e7cb3886d736bb9d0ef81"}, {"sha": "3d9cf30ddf83f4f5df327b0cbacfced7150296ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d9cf30ddf83f4f5df327b0cbacfced7150296ee", "html_url": "https://github.com/rust-lang/rust/commit/3d9cf30ddf83f4f5df327b0cbacfced7150296ee"}], "stats": {"total": 185, "additions": 122, "deletions": 63}, "files": [{"sha": "1604f34d575528209544e2eb2a52aa2890e67d01", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 85, "deletions": 63, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/b5969ca31825377ac5ac0fa8236f25d968a8caf6/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5969ca31825377ac5ac0fa8236f25d968a8caf6/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b5969ca31825377ac5ac0fa8236f25d968a8caf6", "patch": "@@ -299,11 +299,10 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &impl_sig);\n-        let impl_args = impl_sig.inputs.clone();\n         let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: impl_m.fty.unsafety,\n             abi: impl_m.fty.abi,\n-            sig: ty::Binder(impl_sig)\n+            sig: ty::Binder(impl_sig.clone())\n         }));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n@@ -318,11 +317,10 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                  impl_m_span,\n                                                  impl_m_body_id,\n                                                  &trait_sig);\n-        let trait_args = trait_sig.inputs.clone();\n         let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: trait_m.fty.unsafety,\n             abi: trait_m.fty.abi,\n-            sig: ty::Binder(trait_sig)\n+            sig: ty::Binder(trait_sig.clone())\n         }));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n@@ -332,65 +330,9 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                    impl_fty,\n                    trait_fty);\n \n-            let impl_m_iter = match tcx.map.expect_impl_item(impl_m_node_id).node {\n-                ImplItemKind::Method(ref impl_m_sig, _) => impl_m_sig.decl.inputs.iter(),\n-                _ => bug!(\"{:?} is not a method\", impl_m)\n-            };\n-\n-            let (impl_err_span, trait_err_span) = match terr {\n-                TypeError::Mutability => {\n-                    if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                        let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n-                                trait_m_sig.decl.inputs.iter(),\n-                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n-                        };\n-\n-                        impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n-                            match (&impl_arg.ty.node, &trait_arg.ty.node) {\n-                                (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n-                                (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) =>\n-                                    impl_mt.mutbl != trait_mt.mutbl,\n-                                _ => false\n-                            }\n-                        }).map(|(ref impl_arg, ref trait_arg)| {\n-                            match (impl_arg.to_self(), trait_arg.to_self()) {\n-                                (Some(impl_self), Some(trait_self)) =>\n-                                    (impl_self.span, Some(trait_self.span)),\n-                                (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n-                                _ => bug!(\"impl and trait fns have different first args, \\\n-                                           impl: {:?}, trait: {:?}\", impl_arg, trait_arg)\n-                            }\n-                        }).unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n-                    } else {\n-                        (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n-                    }\n-                }\n-                TypeError::Sorts(ExpectedFound { expected, found }) => {\n-                    if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                        let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n-                                trait_m_sig.decl.inputs.iter(),\n-                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n-                        };\n-                        let impl_iter = impl_args.iter();\n-                        let trait_iter = trait_args.iter();\n-                        let arg_idx = impl_iter.zip(trait_iter)\n-                                               .position(|(impl_arg_ty, trait_arg_ty)| {\n-                                                *impl_arg_ty == found && *trait_arg_ty == expected\n-                                               }).unwrap();\n-                        impl_m_iter.zip(trait_m_iter)\n-                                   .nth(arg_idx)\n-                                   .map(|(impl_arg, trait_arg)|\n-                                        (impl_arg.ty.span, Some(trait_arg.ty.span)))\n-                                   .unwrap_or(\n-                                    (origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n-                    } else {\n-                        (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n-                    }\n-                }\n-                _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n-            };\n+            let (impl_err_span, trait_err_span) =\n+                extract_spans_for_error_reporting(&infcx, &terr, origin, impl_m,\n+                    impl_sig, trait_m, trait_sig);\n \n             let origin = TypeOrigin::MethodCompatCheck(impl_err_span);\n \n@@ -479,6 +421,86 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n         return true;\n     }\n+\n+    fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                                         terr: &TypeError,\n+                                                         origin: TypeOrigin,\n+                                                         impl_m: &ty::Method,\n+                                                         impl_sig: ty::FnSig<'tcx>,\n+                                                         trait_m: &ty::Method,\n+                                                         trait_sig: ty::FnSig<'tcx>)\n+                                                        -> (Span, Option<Span>) {\n+        let tcx = infcx.tcx;\n+        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+        let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+            ImplItemKind::Method(ref impl_m_sig, _) =>\n+                (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter()),\n+            _ => bug!(\"{:?} is not a method\", impl_m)\n+        };\n+\n+        match *terr {\n+            TypeError::Mutability => {\n+                if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                    let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n+                            trait_m_sig.decl.inputs.iter(),\n+                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n+                    };\n+\n+                    impl_m_iter.zip(trait_m_iter).find(|&(ref impl_arg, ref trait_arg)| {\n+                        match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                            (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n+                            (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) =>\n+                                impl_mt.mutbl != trait_mt.mutbl,\n+                            _ => false\n+                        }\n+                    }).map(|(ref impl_arg, ref trait_arg)| {\n+                        match (impl_arg.to_self(), trait_arg.to_self()) {\n+                            (Some(impl_self), Some(trait_self)) =>\n+                                (impl_self.span, Some(trait_self.span)),\n+                            (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n+                            _ => bug!(\"impl and trait fns have different first args, \\\n+                                       impl: {:?}, trait: {:?}\", impl_arg, trait_arg)\n+                        }\n+                    }).unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+                } else {\n+                    (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                }\n+            }\n+            TypeError::Sorts(ExpectedFound { .. }) => {\n+                if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                    let (trait_m_output, trait_m_iter) =\n+                    match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) =>\n+                            (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter()),\n+                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m)\n+                    };\n+\n+                    let impl_iter = impl_sig.inputs.iter();\n+                    let trait_iter = trait_sig.inputs.iter();\n+                    impl_iter.zip(trait_iter).zip(impl_m_iter).zip(trait_m_iter)\n+                        .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n+                            match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n+                                Ok(_) => None,\n+                                Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span)))\n+                            }\n+                        })\n+                        .next()\n+                        .unwrap_or_else(|| {\n+                            if infcx.sub_types(false, origin, impl_sig.output,\n+                                               trait_sig.output).is_err() {\n+                                (impl_m_output.span(), Some(trait_m_output.span()))\n+                            } else {\n+                                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                            }\n+                        })\n+                } else {\n+                    (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                }\n+            }\n+            _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+        }\n+    }\n }\n \n pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "8b7fc80bdb6b774f873c1a58e3465c4949a34da1", "filename": "src/test/compile-fail/issue-35869.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b5969ca31825377ac5ac0fa8236f25d968a8caf6/src%2Ftest%2Fcompile-fail%2Fissue-35869.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5969ca31825377ac5ac0fa8236f25d968a8caf6/src%2Ftest%2Fcompile-fail%2Fissue-35869.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35869.rs?ref=b5969ca31825377ac5ac0fa8236f25d968a8caf6", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+trait Foo {\n+    fn foo(fn(u8) -> ()); //~ NOTE type in trait\n+    fn bar(Option<u8>); //~ NOTE type in trait\n+    fn baz((u8, u16)); //~ NOTE type in trait\n+    fn qux() -> u8; //~ NOTE type in trait\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo(_: fn(u16) -> ()) {}\n+    //~^ ERROR method `foo` has an incompatible type for trait\n+    //~| NOTE expected u8\n+    fn bar(_: Option<u16>) {}\n+    //~^ ERROR method `bar` has an incompatible type for trait\n+    //~| NOTE expected u8\n+    fn baz(_: (u16, u16)) {}\n+    //~^ ERROR method `baz` has an incompatible type for trait\n+    //~| NOTE expected u8\n+    fn qux() -> u16 { 5u16 }\n+    //~^ ERROR method `qux` has an incompatible type for trait\n+    //~| NOTE expected u8\n+}\n+\n+fn main() {}"}]}