{"sha": "8aba26d34c010f864974fedf94cd4b7d89c4d055", "node_id": "C_kwDOAAsO6NoAKDhhYmEyNmQzNGMwMTBmODY0OTc0ZmVkZjk0Y2Q0YjdkODljNGQwNTU", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2022-05-18T23:22:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-18T23:22:43Z"}, "message": "Rollup merge of #97127 - Mark-Simulacrum:revert-96441, r=m-ou-se\n\nRevert \"Auto merge of #96441 - ChrisDenton:sync-pipes, r=m-ou-se\"\n\nThis reverts commit ddb7fbe8434be481607ae199fe2aee976ee2fc2e.\n\nPartially addresses https://github.com/rust-lang/rust/issues/97124, but not marking as fixed as we're still pending on a beta backport (for 1.62, which is happening in https://github.com/rust-lang/rust/pull/97088).\n\nr? ``@m-ou-se`` ``@ChrisDenton``", "tree": {"sha": "b6f510a11fe90008ed6c74cc5473ad0b94eeb721", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6f510a11fe90008ed6c74cc5473ad0b94eeb721"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aba26d34c010f864974fedf94cd4b7d89c4d055", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJihX/DCRBK7hj4Ov3rIwAAOPgIAItdV/Rnv+nJ5Pf67s/jGban\njhrRjhLpDF4tQNv7lDcJ/rvgQatL8WeB2wByZmgQtmVpz3hLcoVFh4jYe79ioFT/\n9Zxg/GSJlB+JT9WVleXo476AGjv9o/865rEKerGHHLZDCfTEPVYPFhMeWiD7L0fh\nJgMLhQMPUZXijtdro0HHhwrvEQEKHxowRRX8+7xutyNr06XUdNt9qPSKYlIzaxs9\nrbbWu1ygaZAcMG3hJsule3WMPWWB/o8uCCgKlg6jgUcEzjtbFvIqWKjVtHlWcHjC\nDAXnshKaiOIKnLkWKNr5GCcC2vWJCEgvQbyB5g0uVnZmYp/MP/fHPCCgwbvFKAY=\n=iFgK\n-----END PGP SIGNATURE-----\n", "payload": "tree b6f510a11fe90008ed6c74cc5473ad0b94eeb721\nparent 330e03f682dad1fc04a346a855f32063d2d85e0d\nparent 6259670d50b145461f729042be8705444f4d8f78\nauthor Yuki Okushi <jtitor@2k36.org> 1652916163 +0900\ncommitter GitHub <noreply@github.com> 1652916163 +0900\n\nRollup merge of #97127 - Mark-Simulacrum:revert-96441, r=m-ou-se\n\nRevert \"Auto merge of #96441 - ChrisDenton:sync-pipes, r=m-ou-se\"\n\nThis reverts commit ddb7fbe8434be481607ae199fe2aee976ee2fc2e.\n\nPartially addresses https://github.com/rust-lang/rust/issues/97124, but not marking as fixed as we're still pending on a beta backport (for 1.62, which is happening in https://github.com/rust-lang/rust/pull/97088).\n\nr? ``@m-ou-se`` ``@ChrisDenton``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aba26d34c010f864974fedf94cd4b7d89c4d055", "html_url": "https://github.com/rust-lang/rust/commit/8aba26d34c010f864974fedf94cd4b7d89c4d055", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aba26d34c010f864974fedf94cd4b7d89c4d055/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "330e03f682dad1fc04a346a855f32063d2d85e0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/330e03f682dad1fc04a346a855f32063d2d85e0d", "html_url": "https://github.com/rust-lang/rust/commit/330e03f682dad1fc04a346a855f32063d2d85e0d"}, {"sha": "6259670d50b145461f729042be8705444f4d8f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/6259670d50b145461f729042be8705444f4d8f78", "html_url": "https://github.com/rust-lang/rust/commit/6259670d50b145461f729042be8705444f4d8f78"}], "stats": {"total": 163, "additions": 31, "deletions": 132}, "files": [{"sha": "90a5b7466fec49956a327fb089ac2656c413489c", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=8aba26d34c010f864974fedf94cd4b7d89c4d055", "patch": "@@ -204,19 +204,6 @@ impl OwnedHandle {\n         })?;\n         unsafe { Ok(Self::from_raw_handle(ret)) }\n     }\n-\n-    /// Allow child processes to inherit the handle.\n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub(crate) fn set_inheritable(&self) -> io::Result<()> {\n-        cvt(unsafe {\n-            c::SetHandleInformation(\n-                self.as_raw_handle(),\n-                c::HANDLE_FLAG_INHERIT,\n-                c::HANDLE_FLAG_INHERIT,\n-            )\n-        })?;\n-        Ok(())\n-    }\n }\n \n impl TryFrom<HandleOrInvalid> for OwnedHandle {"}, {"sha": "27776fdf533ee41f1ea60d07dcc11151ba1c90fe", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=8aba26d34c010f864974fedf94cd4b7d89c4d055", "patch": "@@ -1026,12 +1026,6 @@ extern \"system\" {\n         bWaitAll: BOOL,\n         dwMilliseconds: DWORD,\n     ) -> DWORD;\n-    pub fn CreatePipe(\n-        hReadPipe: *mut HANDLE,\n-        hWritePipe: *mut HANDLE,\n-        lpPipeAttributes: *const SECURITY_ATTRIBUTES,\n-        nSize: DWORD,\n-    ) -> BOOL;\n     pub fn CreateNamedPipeW(\n         lpName: LPCWSTR,\n         dwOpenMode: DWORD,"}, {"sha": "ef9a8bd690031c0fbf5dda54da5d87fc6b39c858", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=8aba26d34c010f864974fedf94cd4b7d89c4d055", "patch": "@@ -221,11 +221,6 @@ impl Handle {\n         Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n \n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub(crate) fn set_inheritable(&self) -> io::Result<()> {\n-        self.0.set_inheritable()\n-    }\n-\n     /// Performs a synchronous read.\n     ///\n     /// If the handle is opened for asynchronous I/O then this abort the process."}, {"sha": "013c776c476c361dce272d3e28a205534cae4656", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 25, "deletions": 76, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=8aba26d34c010f864974fedf94cd4b7d89c4d055", "patch": "@@ -18,67 +18,20 @@ use crate::sys_common::IntoInner;\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n-// A 64kb pipe capacity is the same as a typical Linux default.\n-const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n-\n-pub enum AnonPipe {\n-    Sync(Handle),\n-    Async(Handle),\n+pub struct AnonPipe {\n+    inner: Handle,\n }\n \n impl IntoInner<Handle> for AnonPipe {\n     fn into_inner(self) -> Handle {\n-        match self {\n-            Self::Sync(handle) => handle,\n-            Self::Async(handle) => handle,\n-        }\n+        self.inner\n     }\n }\n \n pub struct Pipes {\n     pub ours: AnonPipe,\n     pub theirs: AnonPipe,\n }\n-impl Pipes {\n-    /// Create a new pair of pipes where both pipes are synchronous.\n-    ///\n-    /// These must not be used asynchronously.\n-    pub fn new_synchronous(\n-        ours_readable: bool,\n-        their_handle_inheritable: bool,\n-    ) -> io::Result<Self> {\n-        unsafe {\n-            // If `CreatePipe` succeeds, these will be our pipes.\n-            let mut read = ptr::null_mut();\n-            let mut write = ptr::null_mut();\n-\n-            if c::CreatePipe(&mut read, &mut write, ptr::null(), PIPE_BUFFER_CAPACITY) == 0 {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                let (ours, theirs) = if ours_readable { (read, write) } else { (write, read) };\n-                let ours = Handle::from_raw_handle(ours);\n-                #[cfg(not(target_vendor = \"uwp\"))]\n-                let theirs = Handle::from_raw_handle(theirs);\n-                #[cfg(target_vendor = \"uwp\")]\n-                let mut theirs = Handle::from_raw_handle(theirs);\n-\n-                if their_handle_inheritable {\n-                    #[cfg(not(target_vendor = \"uwp\"))]\n-                    {\n-                        theirs.set_inheritable()?;\n-                    }\n-\n-                    #[cfg(target_vendor = \"uwp\")]\n-                    {\n-                        theirs = theirs.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?;\n-                    }\n-                }\n-\n-                Ok(Pipes { ours: AnonPipe::Sync(ours), theirs: AnonPipe::Sync(theirs) })\n-            }\n-        }\n-    }\n-}\n \n /// Although this looks similar to `anon_pipe` in the Unix module it's actually\n /// subtly different. Here we'll return two pipes in the `Pipes` return value,\n@@ -100,6 +53,9 @@ impl Pipes {\n /// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n /// once at a time (which we do indeed guarantee).\n pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {\n+    // A 64kb pipe capacity is the same as a typical Linux default.\n+    const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n+\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n     // operations. Instead, we create a \"hopefully unique\" name and create a\n@@ -200,9 +156,12 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n         };\n         opts.security_attributes(&mut sa);\n         let theirs = File::open(Path::new(&name), &opts)?;\n-        let theirs = AnonPipe::Sync(theirs.into_inner());\n+        let theirs = AnonPipe { inner: theirs.into_inner() };\n \n-        Ok(Pipes { ours: AnonPipe::Async(ours), theirs })\n+        Ok(Pipes {\n+            ours: AnonPipe { inner: ours },\n+            theirs: AnonPipe { inner: theirs.into_inner() },\n+        })\n     }\n }\n \n@@ -212,12 +171,12 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n /// This is achieved by creating a new set of pipes and spawning a thread that\n /// relays messages between the source and the synchronous pipe.\n pub fn spawn_pipe_relay(\n-    source: &Handle,\n+    source: &AnonPipe,\n     ours_readable: bool,\n     their_handle_inheritable: bool,\n ) -> io::Result<AnonPipe> {\n     // We need this handle to live for the lifetime of the thread spawned below.\n-    let source = AnonPipe::Async(source.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?);\n+    let source = source.duplicate()?;\n \n     // create a new pair of anon pipes.\n     let Pipes { theirs, ours } = anon_pipe(ours_readable, their_handle_inheritable)?;\n@@ -268,24 +227,19 @@ type AlertableIoFn = unsafe extern \"system\" fn(\n \n impl AnonPipe {\n     pub fn handle(&self) -> &Handle {\n-        match self {\n-            Self::Async(ref handle) => handle,\n-            Self::Sync(ref handle) => handle,\n-        }\n+        &self.inner\n     }\n     pub fn into_handle(self) -> Handle {\n-        self.into_inner()\n+        self.inner\n+    }\n+    fn duplicate(&self) -> io::Result<Self> {\n+        self.inner.duplicate(0, false, c::DUPLICATE_SAME_ACCESS).map(|inner| AnonPipe { inner })\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let result = unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            match self {\n-                Self::Sync(ref handle) => handle.read(buf),\n-                Self::Async(_) => {\n-                    self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n-                }\n-            }\n+            self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n         };\n \n         match result {\n@@ -299,33 +253,28 @@ impl AnonPipe {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::default_read_vectored(|buf| self.read(buf), bufs)\n+        self.inner.read_vectored(bufs)\n     }\n \n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        false\n+        self.inner.is_read_vectored()\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            match self {\n-                Self::Sync(ref handle) => handle.write(buf),\n-                Self::Async(_) => {\n-                    self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n-                }\n-            }\n+            self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n         }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::default_write_vectored(|buf| self.write(buf), bufs)\n+        self.inner.write_vectored(bufs)\n     }\n \n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        false\n+        self.inner.is_write_vectored()\n     }\n \n     /// Synchronizes asynchronous reads or writes using our anonymous pipe.\n@@ -397,7 +346,7 @@ impl AnonPipe {\n \n         // Asynchronous read of the pipe.\n         // If successful, `callback` will be called once it completes.\n-        let result = io(self.handle().as_handle(), buf, len, &mut overlapped, callback);\n+        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n         if result == c::FALSE {\n             // We can return here because the call failed.\n             // After this we must not return until the I/O completes."}, {"sha": "9fd399f4ba1d3193061af53e8e13dcb1484a76ef", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aba26d34c010f864974fedf94cd4b7d89c4d055/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=8aba26d34c010f864974fedf94cd4b7d89c4d055", "patch": "@@ -23,7 +23,7 @@ use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n use crate::sys::path;\n-use crate::sys::pipe::{self, AnonPipe, Pipes};\n+use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n@@ -172,7 +172,7 @@ pub enum Stdio {\n     Inherit,\n     Null,\n     MakePipe,\n-    AsyncPipe(Handle),\n+    Pipe(AnonPipe),\n     Handle(Handle),\n }\n \n@@ -527,33 +527,13 @@ impl Stdio {\n             },\n \n             Stdio::MakePipe => {\n-                // Handles that are passed to a child process must be synchronous\n-                // because they will be read synchronously (see #95759).\n-                // Therefore we prefer to make both ends of a pipe synchronous\n-                // just in case our end of the pipe is passed to another process.\n-                //\n-                // However, we may need to read from both the child's stdout and\n-                // stderr simultaneously when waiting for output. This requires\n-                // async reads so as to avoid blocking either pipe.\n-                //\n-                // The solution used here is to make handles synchronous\n-                // except for our side of the stdout and sterr pipes.\n-                // If our side of those pipes do end up being given to another\n-                // process then we use a \"pipe relay\" to synchronize access\n-                // (see `Stdio::AsyncPipe` below).\n-                let pipes = if stdio_id == c::STD_INPUT_HANDLE {\n-                    // For stdin both sides of the pipe are synchronous.\n-                    Pipes::new_synchronous(false, true)?\n-                } else {\n-                    // For stdout/stderr our side of the pipe is async and their side is synchronous.\n-                    pipe::anon_pipe(true, true)?\n-                };\n+                let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n+                let pipes = pipe::anon_pipe(ours_readable, true)?;\n                 *pipe = Some(pipes.ours);\n                 Ok(pipes.theirs.into_handle())\n             }\n \n-            Stdio::AsyncPipe(ref source) => {\n-                // We need to synchronize asynchronous pipes by using a pipe relay.\n+            Stdio::Pipe(ref source) => {\n                 let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n                 pipe::spawn_pipe_relay(source, ours_readable, true).map(AnonPipe::into_handle)\n             }\n@@ -582,13 +562,7 @@ impl Stdio {\n \n impl From<AnonPipe> for Stdio {\n     fn from(pipe: AnonPipe) -> Stdio {\n-        // Note that it's very important we don't give async handles to child processes.\n-        // Therefore if the pipe is asynchronous we must have a way to turn it synchronous.\n-        // See #95759.\n-        match pipe {\n-            AnonPipe::Sync(handle) => Stdio::Handle(handle),\n-            AnonPipe::Async(handle) => Stdio::AsyncPipe(handle),\n-        }\n+        Stdio::Pipe(pipe)\n     }\n }\n "}]}