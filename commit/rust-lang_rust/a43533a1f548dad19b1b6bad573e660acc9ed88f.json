{"sha": "a43533a1f548dad19b1b6bad573e660acc9ed88f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MzUzM2ExZjU0OGRhZDE5YjFiNmJhZDU3M2U2NjBhY2M5ZWQ4OGY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-10-18T16:15:57Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-11-15T17:22:32Z"}, "message": "simplify and reduce the size of EvaluationResult", "tree": {"sha": "730fe06740891ad9b4f9902e65bd34b7534d7988", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/730fe06740891ad9b4f9902e65bd34b7534d7988"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a43533a1f548dad19b1b6bad573e660acc9ed88f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a43533a1f548dad19b1b6bad573e660acc9ed88f", "html_url": "https://github.com/rust-lang/rust/commit/a43533a1f548dad19b1b6bad573e660acc9ed88f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a43533a1f548dad19b1b6bad573e660acc9ed88f/comments", "author": null, "committer": null, "parents": [{"sha": "768630be34594c32a14814e4e9e850d86125a265", "url": "https://api.github.com/repos/rust-lang/rust/commits/768630be34594c32a14814e4e9e850d86125a265", "html_url": "https://github.com/rust-lang/rust/commit/768630be34594c32a14814e4e9e850d86125a265"}], "stats": {"total": 229, "additions": 173, "deletions": 56}, "files": [{"sha": "6e6eeae93607ce544d877686b932bcd88f9f06a8", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=a43533a1f548dad19b1b6bad573e660acc9ed88f", "patch": "@@ -44,6 +44,7 @@ pub use self::object_safety::object_safety_violations;\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::is_vtable_safe_method;\n+pub use self::select::EvaluationCache;\n pub use self::select::SelectionContext;\n pub use self::select::SelectionCache;\n pub use self::select::{MethodMatchResult, MethodMatched, MethodAmbiguous, MethodDidNotMatch};"}, {"sha": "a24f027e74a57fd11e53ff8b6bd07e97279a9133", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 98, "deletions": 56, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=a43533a1f548dad19b1b6bad573e660acc9ed88f", "patch": "@@ -236,11 +236,24 @@ enum BuiltinBoundConditions<'tcx> {\n     AmbiguousBuiltin\n }\n \n-#[derive(Debug)]\n-enum EvaluationResult<'tcx> {\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+/// The result of trait evaluation. The order is important\n+/// here as the evaluation of a list is the maximum of the\n+/// evaluations.\n+enum EvaluationResult {\n+    /// Evaluation successful\n     EvaluatedToOk,\n+    /// Evaluation failed because of recursion - treated as ambiguous\n+    EvaluatedToUnknown,\n+    /// Evaluation is known to be ambiguous\n     EvaluatedToAmbig,\n-    EvaluatedToErr(SelectionError<'tcx>),\n+    /// Evaluation failed\n+    EvaluatedToErr,\n+}\n+\n+#[derive(Clone)]\n+pub struct EvaluationCache<'tcx> {\n+    hashmap: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, EvaluationResult>>\n }\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n@@ -381,6 +394,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // The result is \"true\" if the obligation *may* hold and \"false\" if\n     // we can be sure it does not.\n \n+\n     /// Evaluates whether the obligation `obligation` can be satisfied (by any means).\n     pub fn evaluate_obligation(&mut self,\n                                obligation: &PredicateObligation<'tcx>)\n@@ -393,41 +407,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .may_apply()\n     }\n \n-    fn evaluate_builtin_bound_recursively<'o>(&mut self,\n-                                              bound: ty::BuiltinBound,\n-                                              previous_stack: &TraitObligationStack<'o, 'tcx>,\n-                                              ty: Ty<'tcx>)\n-                                              -> EvaluationResult<'tcx>\n-    {\n-        let obligation =\n-            util::predicate_for_builtin_bound(\n-                self.tcx(),\n-                previous_stack.obligation.cause.clone(),\n-                bound,\n-                previous_stack.obligation.recursion_depth + 1,\n-                ty);\n-\n-        match obligation {\n-            Ok(obligation) => {\n-                self.evaluate_predicate_recursively(previous_stack.list(), &obligation)\n-            }\n-            Err(ErrorReported) => {\n-                EvaluatedToOk\n-            }\n-        }\n-    }\n-\n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n                                                 stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n-                                                -> EvaluationResult<'tcx>\n+                                                -> EvaluationResult\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n             match self.evaluate_predicate_recursively(stack, obligation) {\n-                EvaluatedToErr(e) => { return EvaluatedToErr(e); }\n+                EvaluatedToErr => { return EvaluatedToErr; }\n                 EvaluatedToAmbig => { result = EvaluatedToAmbig; }\n+                EvaluatedToUnknown => {\n+                    if result < EvaluatedToUnknown {\n+                        result = EvaluatedToUnknown;\n+                    }\n+                }\n                 EvaluatedToOk => { }\n             }\n         }\n@@ -437,7 +432,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_predicate_recursively<'o>(&mut self,\n                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n-                                           -> EvaluationResult<'tcx>\n+                                           -> EvaluationResult\n     {\n         debug!(\"evaluate_predicate_recursively({:?})\",\n                obligation);\n@@ -464,7 +459,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 });\n                 match result {\n                     Ok(()) => EvaluatedToOk,\n-                    Err(_) => EvaluatedToErr(Unimplemented),\n+                    Err(_) => EvaluatedToErr\n                 }\n             }\n \n@@ -489,7 +484,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 if object_safety::is_object_safe(self.tcx(), trait_def_id) {\n                     EvaluatedToOk\n                 } else {\n-                    EvaluatedToErr(Unimplemented)\n+                    EvaluatedToErr\n                 }\n             }\n \n@@ -505,7 +500,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             EvaluatedToAmbig\n                         }\n                         Err(_) => {\n-                            EvaluatedToErr(Unimplemented)\n+                            EvaluatedToErr\n                         }\n                     }\n                 })\n@@ -516,22 +511,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_obligation_recursively<'o>(&mut self,\n                                            previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                            obligation: &TraitObligation<'tcx>)\n-                                           -> EvaluationResult<'tcx>\n+                                           -> EvaluationResult\n     {\n         debug!(\"evaluate_obligation_recursively({:?})\",\n                obligation);\n \n         let stack = self.push_stack(previous_stack, obligation);\n+        let fresh_trait_ref = stack.fresh_trait_ref;\n+        if let Some(result) = self.check_evaluation_cache(fresh_trait_ref) {\n+            debug!(\"CACHE HIT: EVAL({:?})={:?}\",\n+                   fresh_trait_ref,\n+                   result);\n+            return result;\n+        }\n \n         let result = self.evaluate_stack(&stack);\n \n-        debug!(\"result: {:?}\", result);\n+        debug!(\"CACHE MISS: EVAL({:?})={:?}\",\n+               fresh_trait_ref,\n+               result);\n+        self.insert_evaluation_cache(fresh_trait_ref, result);\n+\n         result\n     }\n \n     fn evaluate_stack<'o>(&mut self,\n                           stack: &TraitObligationStack<'o, 'tcx>)\n-                          -> EvaluationResult<'tcx>\n+                          -> EvaluationResult\n     {\n         // In intercrate mode, whenever any of the types are unbound,\n         // there can always be an impl. Even if there are no impls in\n@@ -559,16 +565,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // precise still.\n         let input_types = stack.fresh_trait_ref.0.input_types();\n         let unbound_input_types = input_types.iter().any(|ty| ty.is_fresh());\n-        if\n-            unbound_input_types &&\n-             (self.intercrate ||\n+        if unbound_input_types && self.intercrate {\n+            debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n+                   stack.fresh_trait_ref);\n+            return EvaluatedToAmbig;\n+        }\n+        if unbound_input_types &&\n               stack.iter().skip(1).any(\n                   |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n-                                                     &prev.fresh_trait_ref)))\n+                                                     &prev.fresh_trait_ref))\n         {\n-            debug!(\"evaluate_stack({:?}) --> unbound argument, recursion -->  ambiguous\",\n+            debug!(\"evaluate_stack({:?}) --> unbound argument, recursive --> giving up\",\n                    stack.fresh_trait_ref);\n-            return EvaluatedToAmbig;\n+            return EvaluatedToUnknown;\n         }\n \n         // If there is any previous entry on the stack that precisely\n@@ -603,7 +612,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.candidate_from_obligation(stack) {\n             Ok(Some(c)) => self.winnow_candidate(stack, &c),\n             Ok(None) => EvaluatedToAmbig,\n-            Err(e) => EvaluatedToErr(e),\n+            Err(..) => EvaluatedToErr\n         }\n     }\n \n@@ -637,6 +646,34 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         })\n     }\n \n+    fn pick_evaluation_cache(&self) -> &EvaluationCache<'tcx> {\n+        &self.param_env().evaluation_cache\n+    }\n+\n+    fn check_evaluation_cache(&self, trait_ref: ty::PolyTraitRef<'tcx>)\n+                              -> Option<EvaluationResult>\n+    {\n+        let cache = self.pick_evaluation_cache();\n+        cache.hashmap.borrow().get(&trait_ref).cloned()\n+    }\n+\n+    fn insert_evaluation_cache(&mut self,\n+                               trait_ref: ty::PolyTraitRef<'tcx>,\n+                               result: EvaluationResult)\n+    {\n+        // Avoid caching results that depend on more than just the trait-ref:\n+        // The stack can create EvaluatedToUnknown, and closure signatures\n+        // being yet uninferred can create \"spurious\" EvaluatedToAmbig.\n+        if result == EvaluatedToUnknown ||\n+            (result == EvaluatedToAmbig && trait_ref.has_closure_types())\n+        {\n+            return;\n+        }\n+\n+        let cache = self.pick_evaluation_cache();\n+        cache.hashmap.borrow_mut().insert(trait_ref, result);\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n     //\n@@ -669,7 +706,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.check_candidate_cache(&cache_fresh_trait_pred) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+                debug!(\"CACHE HIT: SELECT({:?})={:?}\",\n                        cache_fresh_trait_pred,\n                        c);\n                 return c;\n@@ -681,7 +718,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n \n         if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n-            debug!(\"CACHE MISS: cache_fresh_trait_pred={:?}, candidate={:?}\",\n+            debug!(\"CACHE MISS: SELECT({:?})={:?}\",\n                    cache_fresh_trait_pred, candidate);\n             self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n         }\n@@ -1138,15 +1175,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn evaluate_where_clause<'o>(&mut self,\n                                  stack: &TraitObligationStack<'o, 'tcx>,\n                                  where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n-                                 -> EvaluationResult<'tcx>\n+                                 -> EvaluationResult\n     {\n         self.infcx().probe(move |_| {\n             match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n                     self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => {\n-                    EvaluatedToErr(Unimplemented)\n+                    EvaluatedToErr\n                 }\n             }\n         })\n@@ -1492,15 +1529,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn winnow_candidate<'o>(&mut self,\n                             stack: &TraitObligationStack<'o, 'tcx>,\n                             candidate: &SelectionCandidate<'tcx>)\n-                            -> EvaluationResult<'tcx>\n+                            -> EvaluationResult\n     {\n         debug!(\"winnow_candidate: candidate={:?}\", candidate);\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => self.winnow_selection(stack.list(),\n                                                        selection),\n-                Err(error) => EvaluatedToErr(error),\n+                Err(..) => EvaluatedToErr\n             }\n         });\n         debug!(\"winnow_candidate depth={} result={:?}\",\n@@ -1511,7 +1548,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn winnow_selection<'o>(&mut self,\n                             stack: TraitObligationStackList<'o,'tcx>,\n                             selection: Selection<'tcx>)\n-                            -> EvaluationResult<'tcx>\n+                            -> EvaluationResult\n     {\n         self.evaluate_predicates_recursively(stack,\n                                              selection.nested_obligations().iter())\n@@ -2956,6 +2993,14 @@ impl<'tcx> SelectionCache<'tcx> {\n     }\n }\n \n+impl<'tcx> EvaluationCache<'tcx> {\n+    pub fn new() -> EvaluationCache<'tcx> {\n+        EvaluationCache {\n+            hashmap: RefCell::new(FnvHashMap())\n+        }\n+    }\n+}\n+\n impl<'o,'tcx> TraitObligationStack<'o,'tcx> {\n     fn list(&'o self) -> TraitObligationStackList<'o,'tcx> {\n         TraitObligationStackList::with(self)\n@@ -3001,17 +3046,14 @@ impl<'o,'tcx> fmt::Debug for TraitObligationStack<'o,'tcx> {\n     }\n }\n \n-impl<'tcx> EvaluationResult<'tcx> {\n+impl EvaluationResult {\n     fn may_apply(&self) -> bool {\n         match *self {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) |\n-            EvaluatedToErr(TraitNotObjectSafe(_)) =>\n-                true,\n+            EvaluatedToUnknown => true,\n \n-            EvaluatedToErr(Unimplemented) =>\n-                false,\n+            EvaluatedToErr => false\n         }\n     }\n }"}, {"sha": "0a9fa1d6ce394c75e26d90ac38855eaf3c05c406", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=a43533a1f548dad19b1b6bad573e660acc9ed88f", "patch": "@@ -1091,6 +1091,9 @@ pub struct ParameterEnvironment<'a, 'tcx:'a> {\n     /// for things that have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n \n+    /// Caches the results of trait evaluation.\n+    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+\n     /// Scope that is attached to free regions for this scope. This\n     /// is usually the id of the fn body, but for more abstract scopes\n     /// like structs we often use the node-id of the struct.\n@@ -1112,6 +1115,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             implicit_region_bound: self.implicit_region_bound,\n             caller_bounds: caller_bounds,\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             free_id: self.free_id,\n         }\n     }\n@@ -2584,6 +2588,7 @@ impl<'tcx> ctxt<'tcx> {\n                                    caller_bounds: Vec::new(),\n                                    implicit_region_bound: ty::ReEmpty,\n                                    selection_cache: traits::SelectionCache::new(),\n+                                   evaluation_cache: traits::EvaluationCache::new(),\n \n                                    // for an empty parameter\n                                    // environment, there ARE no free\n@@ -2673,6 +2678,7 @@ impl<'tcx> ctxt<'tcx> {\n             implicit_region_bound: ty::ReScope(free_id_outlive),\n             caller_bounds: predicates,\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             free_id: free_id,\n         };\n "}, {"sha": "41303b46dfd09edf37c27c7e0ce95babdbc7a728", "filename": "src/librustc/middle/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fstructural_impls.rs?ref=a43533a1f548dad19b1b6bad573e660acc9ed88f", "patch": "@@ -822,6 +822,7 @@ impl<'a, 'tcx> TypeFoldable<'tcx> for ty::ParameterEnvironment<'a, 'tcx> where '\n             implicit_region_bound: self.implicit_region_bound.fold_with(folder),\n             caller_bounds: self.caller_bounds.fold_with(folder),\n             selection_cache: traits::SelectionCache::new(),\n+            evaluation_cache: traits::EvaluationCache::new(),\n             free_id: self.free_id,\n         }\n     }"}, {"sha": "64bfa232f3ffd0220c86a45f717919005be18ef6", "filename": "src/test/compile-fail/issue-29147.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Ftest%2Fcompile-fail%2Fissue-29147.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Ftest%2Fcompile-fail%2Fissue-29147.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29147.rs?ref=a43533a1f548dad19b1b6bad573e660acc9ed88f", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![recursion_limit=\"1024\"]\n+\n+pub struct S0<T>(T,T);\n+pub struct S1<T>(Option<Box<S0<S0<T>>>>,Option<Box<S0<S0<T>>>>);\n+pub struct S2<T>(Option<Box<S1<S1<T>>>>,Option<Box<S1<S1<T>>>>);\n+pub struct S3<T>(Option<Box<S2<S2<T>>>>,Option<Box<S2<S2<T>>>>);\n+pub struct S4<T>(Option<Box<S3<S3<T>>>>,Option<Box<S3<S3<T>>>>);\n+pub struct S5<T>(Option<Box<S4<S4<T>>>>,Option<Box<S4<S4<T>>>>,Option<T>);\n+\n+trait Foo { fn xxx(&self); }\n+trait Bar {} // anything local or #[fundamental]\n+\n+impl<T> Foo for T where T: Bar, T: Sync {\n+    fn xxx(&self) {}\n+}\n+\n+impl Foo for S5<u32> { fn xxx(&self) {} }\n+impl Foo for S5<u64> { fn xxx(&self) {} }\n+\n+fn main() {\n+    let _ = <S5<_>>::xxx; //~ ERROR cannot resolve `S5<_> : Foo`\n+}"}, {"sha": "460e92967e8e66fc36e5849a50bf0a156b6bafed", "filename": "src/test/run-pass/issue-29147.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Ftest%2Frun-pass%2Fissue-29147.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a43533a1f548dad19b1b6bad573e660acc9ed88f/src%2Ftest%2Frun-pass%2Fissue-29147.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29147.rs?ref=a43533a1f548dad19b1b6bad573e660acc9ed88f", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![recursion_limit=\"1024\"]\n+\n+use std::mem;\n+\n+pub struct S0<T>(T,T);\n+pub struct S1<T>(Option<Box<S0<S0<T>>>>,Option<Box<S0<S0<T>>>>);\n+pub struct S2<T>(Option<Box<S1<S1<T>>>>,Option<Box<S1<S1<T>>>>);\n+pub struct S3<T>(Option<Box<S2<S2<T>>>>,Option<Box<S2<S2<T>>>>);\n+pub struct S4<T>(Option<Box<S3<S3<T>>>>,Option<Box<S3<S3<T>>>>);\n+pub struct S5<T>(Option<Box<S4<S4<T>>>>,Option<Box<S4<S4<T>>>>,Option<T>);\n+\n+trait Foo { fn xxx(&self); }\n+trait Bar {} // anything local or #[fundamental]\n+\n+impl<T> Foo for T where T: Bar, T: Sync {\n+    fn xxx(&self) {}\n+}\n+\n+impl Foo for S5<u8> { fn xxx(&self) {} }\n+\n+fn main() {\n+    let s = S5(None,None,None);\n+    s.xxx();\n+    assert_eq!(mem::size_of_val(&s.2), mem::size_of::<Option<u8>>());\n+}"}]}