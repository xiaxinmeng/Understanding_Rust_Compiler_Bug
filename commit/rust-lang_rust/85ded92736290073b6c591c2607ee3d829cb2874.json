{"sha": "85ded92736290073b6c591c2607ee3d829cb2874", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1ZGVkOTI3MzYyOTAwNzNiNmM1OTFjMjYwN2VlM2Q4MjljYjI4NzQ=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-06-05T01:18:47Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-06-15T19:41:41Z"}, "message": "Make it possible to make tt_reader-based parsers.", "tree": {"sha": "ce43cefc84f02a514e6e6c40c0b59168cfe76481", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce43cefc84f02a514e6e6c40c0b59168cfe76481"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ded92736290073b6c591c2607ee3d829cb2874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ded92736290073b6c591c2607ee3d829cb2874", "html_url": "https://github.com/rust-lang/rust/commit/85ded92736290073b6c591c2607ee3d829cb2874", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ded92736290073b6c591c2607ee3d829cb2874/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d619e8995f70556d58e57a699ba726c17f9e48ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/d619e8995f70556d58e57a699ba726c17f9e48ad", "html_url": "https://github.com/rust-lang/rust/commit/d619e8995f70556d58e57a699ba726c17f9e48ad"}], "stats": {"total": 62, "additions": 42, "deletions": 20}, "files": [{"sha": "29cbb9db839561d6df9381d9be4871093d70b0c0", "filename": "src/libsyntax/parse.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85ded92736290073b6c591c2607ee3d829cb2874/src%2Flibsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ded92736290073b6c591c2607ee3d829cb2874/src%2Flibsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse.rs?ref=85ded92736290073b6c591c2607ee3d829cb2874", "patch": "@@ -18,7 +18,8 @@ import attr::parser_attr;\n import common::parser_common;\n import ast::node_id;\n import util::interner;\n-import lexer::{string_reader_as_reader, reader, string_reader};\n+import lexer::{string_reader_as_reader, tt_reader_as_reader,\n+               reader, string_reader, tt_reader};\n \n type parse_sess = @{\n     cm: codemap::codemap,\n@@ -178,3 +179,10 @@ fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, +path: str,\n     let (p, _) = new_parser_etc_from_file(sess, cfg, path, ftype);\n     ret p;\n }\n+\n+fn new_parser_from_tt(sess: parse_sess, cfg: ast::crate_cfg,\n+                      itr: @interner::interner<@str>, tt: ast::token_tree)\n+    -> parser {\n+    let trdr = lexer::new_tt_reader(sess.span_diagnostic, itr, tt);\n+    ret parser(sess, cfg, trdr as reader, parser::SOURCE_FILE)\n+}"}, {"sha": "51ab3085eaf20e1497db3f2fb44eef9be661d0b1", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/85ded92736290073b6c591c2607ee3d829cb2874/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ded92736290073b6c591c2607ee3d829cb2874/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=85ded92736290073b6c591c2607ee3d829cb2874", "patch": "@@ -4,8 +4,9 @@ import diagnostic;\n import ast::{tt_delim,tt_flat};\n \n export reader, string_reader, new_string_reader, is_whitespace;\n+export tt_reader, new_tt_reader;\n export nextch, is_eof, bump, get_str_from;\n-export string_reader_as_reader;\n+export string_reader_as_reader, tt_reader_as_reader;\n \n iface reader {\n     fn is_eof() -> bool;\n@@ -27,14 +28,27 @@ type tt_frame = @{\n };\n \n type tt_reader = @{\n-    mut cur: tt_frame,\n-    interner: @interner::interner<@str>,\n     span_diagnostic: diagnostic::span_handler,\n+    interner: @interner::interner<@str>,\n+    mut cur: tt_frame,\n     /* cached: */\n     mut cur_tok: token::token,\n     mut cur_chpos: uint\n };\n \n+fn new_tt_reader(span_diagnostic: diagnostic::span_handler,\n+                 itr: @interner::interner<@str>, src: ast::token_tree)\n+    -> tt_reader {\n+    let r = @{span_diagnostic: span_diagnostic, interner: itr,\n+              mut cur: @{readme: [src], mut idx: 0u,\n+                         up: tt_frame_up(option::none)},\n+              mut cur_tok: token::EOF, /* dummy value, never read */\n+              mut cur_chpos: 0u /* dummy value, never read */\n+             };\n+    (r as reader).next_token(); /* get cur_tok and cur_chpos set up */\n+    ret r;\n+}\n+\n type string_reader = @{\n     span_diagnostic: diagnostic::span_handler,\n     src: @str,\n@@ -46,6 +60,21 @@ type string_reader = @{\n     interner: @interner::interner<@str>\n };\n \n+fn new_string_reader(span_diagnostic: diagnostic::span_handler,\n+                     filemap: codemap::filemap,\n+                     itr: @interner::interner<@str>) -> string_reader {\n+    let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n+              mut col: 0u, mut pos: 0u, mut curr: -1 as char,\n+              mut chpos: filemap.start_pos.ch,\n+              filemap: filemap, interner: itr};\n+    if r.pos < (*filemap.src).len() {\n+        let next = str::char_range_at(*r.src, r.pos);\n+        r.pos = next.next;\n+        r.curr = next.ch;\n+    }\n+    ret r;\n+}\n+\n impl string_reader_as_reader of reader for string_reader {\n     fn is_eof() -> bool { is_eof(self) }\n     fn next_token() -> {tok: token::token, chpos: uint} {\n@@ -70,7 +99,6 @@ impl tt_reader_as_reader of reader for tt_reader {\n     fn is_eof() -> bool { self.cur_tok == token::EOF }\n     fn next_token() -> {tok: token::token, chpos: uint} {\n         let ret_val = { tok: self.cur_tok, chpos: self.cur_chpos };\n-        self.cur.idx += 1u;\n         if self.cur.idx >= vec::len(self.cur.readme) {\n             /* done with this set; pop */\n             alt self.cur.up {\n@@ -97,6 +125,7 @@ impl tt_reader_as_reader of reader for tt_reader {\n               }\n               tt_flat(chpos, tok) {\n                 self.cur_chpos = chpos; self.cur_tok = tok;\n+                self.cur.idx += 1u;\n                 ret ret_val;\n               }\n           }\n@@ -144,21 +173,6 @@ fn nextch(rdr: string_reader) -> char {\n     } else { ret -1 as char; }\n }\n \n-fn new_string_reader(span_diagnostic: diagnostic::span_handler,\n-                     filemap: codemap::filemap,\n-                     itr: @interner::interner<@str>) -> string_reader {\n-    let r = @{span_diagnostic: span_diagnostic, src: filemap.src,\n-              mut col: 0u, mut pos: 0u, mut curr: -1 as char,\n-              mut chpos: filemap.start_pos.ch,\n-              filemap: filemap, interner: itr};\n-    if r.pos < (*filemap.src).len() {\n-        let next = str::char_range_at(*r.src, r.pos);\n-        r.pos = next.next;\n-        r.curr = next.ch;\n-    }\n-    ret r;\n-}\n-\n fn dec_digit_val(c: char) -> int { ret (c as int) - ('0' as int); }\n \n fn hex_digit_val(c: char) -> int {"}]}