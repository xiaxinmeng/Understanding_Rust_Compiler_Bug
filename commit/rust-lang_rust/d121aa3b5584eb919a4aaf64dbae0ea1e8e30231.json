{"sha": "d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "node_id": "C_kwDOAAsO6NoAKGQxMjFhYTNiNTU4NGViOTE5YTRhYWY2NGRiYWUwZWExZThlMzAyMzE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-23T16:29:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-23T16:29:17Z"}, "message": "Auto merge of #104776 - Dylan-DPC:rollup-rf4c2u0, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #104269 (Fix hang in where-clause suggestion with `predicate_can_apply`)\n - #104286 (copy doc output files by format)\n - #104509 (Use obligation ctxt instead of dyn TraitEngine)\n - #104721 (Remove more `ref` patterns from the compiler)\n - #104744 (rustdoc: give struct fields CSS `display: block`)\n - #104751 (Fix an ICE parsing a malformed attribute.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "461296940a2cde7aafa71a03a1e2e9cb274af082", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461296940a2cde7aafa71a03a1e2e9cb274af082"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "html_url": "https://github.com/rust-lang/rust/commit/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "url": "https://api.github.com/repos/rust-lang/rust/commits/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "html_url": "https://github.com/rust-lang/rust/commit/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd"}, {"sha": "5d7b68c82bf4e6b4ba1171b01da2d11a0886f751", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d7b68c82bf4e6b4ba1171b01da2d11a0886f751", "html_url": "https://github.com/rust-lang/rust/commit/5d7b68c82bf4e6b4ba1171b01da2d11a0886f751"}], "stats": {"total": 949, "additions": 516, "deletions": 433}, "files": [{"sha": "49a070badc6de5c30c6cbd4b81b0407b970d9621", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -52,19 +52,15 @@ fn test_arena_alloc_nested() {\n \n     impl<'a> Wrap<'a> {\n         fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-            let r: &EI<'_> = self.0.alloc(EI::I(f()));\n-            if let &EI::I(ref i) = r {\n-                i\n-            } else {\n-                panic!(\"mismatch\");\n+            match self.0.alloc(EI::I(f())) {\n+                EI::I(i) => i,\n+                _ => panic!(\"mismatch\"),\n             }\n         }\n         fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n-            let r: &EI<'_> = self.0.alloc(EI::O(f()));\n-            if let &EI::O(ref o) = r {\n-                o\n-            } else {\n-                panic!(\"mismatch\");\n+            match self.0.alloc(EI::O(f())) {\n+                EI::O(o) => o,\n+                _ => panic!(\"mismatch\"),\n             }\n         }\n     }"}, {"sha": "3e0129531150c9f9bf651a92300aa0ded41c0e16", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -618,9 +618,12 @@ impl MetaItemKind {\n             }) => MetaItemKind::list_from_tokens(tokens.clone()),\n             AttrArgs::Delimited(..) => None,\n             AttrArgs::Eq(_, AttrArgsEq::Ast(expr)) => match expr.kind {\n-                ast::ExprKind::Lit(token_lit) => Some(MetaItemKind::NameValue(\n-                    Lit::from_token_lit(token_lit, expr.span).expect(\"token_lit in from_attr_args\"),\n-                )),\n+                ast::ExprKind::Lit(token_lit) => {\n+                    // Turn failures to `None`, we'll get parse errors elsewhere.\n+                    Lit::from_token_lit(token_lit, expr.span)\n+                        .ok()\n+                        .map(|lit| MetaItemKind::NameValue(lit))\n+                }\n                 _ => None,\n             },\n             AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => Some(MetaItemKind::NameValue(lit.clone())),"}, {"sha": "2a0338adc9ca4c51be01dd2aa41de1a2ea0ab054", "filename": "compiler/rustc_ast_lowering/src/asm.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fasm.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .operands\n             .iter()\n             .map(|(op, op_sp)| {\n-                let lower_reg = |reg| match reg {\n+                let lower_reg = |&reg: &_| match reg {\n                     InlineAsmRegOrRegClass::Reg(reg) => {\n                         asm::InlineAsmRegOrRegClass::Reg(if let Some(asm_arch) = asm_arch {\n                             asm::InlineAsmReg::parse(asm_arch, reg).unwrap_or_else(|error| {\n@@ -152,32 +152,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                 };\n \n-                let op = match *op {\n-                    InlineAsmOperand::In { reg, ref expr } => hir::InlineAsmOperand::In {\n+                let op = match op {\n+                    InlineAsmOperand::In { reg, expr } => hir::InlineAsmOperand::In {\n                         reg: lower_reg(reg),\n                         expr: self.lower_expr(expr),\n                     },\n-                    InlineAsmOperand::Out { reg, late, ref expr } => hir::InlineAsmOperand::Out {\n+                    InlineAsmOperand::Out { reg, late, expr } => hir::InlineAsmOperand::Out {\n                         reg: lower_reg(reg),\n-                        late,\n+                        late: *late,\n                         expr: expr.as_ref().map(|expr| self.lower_expr(expr)),\n                     },\n-                    InlineAsmOperand::InOut { reg, late, ref expr } => {\n-                        hir::InlineAsmOperand::InOut {\n-                            reg: lower_reg(reg),\n-                            late,\n-                            expr: self.lower_expr(expr),\n-                        }\n-                    }\n-                    InlineAsmOperand::SplitInOut { reg, late, ref in_expr, ref out_expr } => {\n+                    InlineAsmOperand::InOut { reg, late, expr } => hir::InlineAsmOperand::InOut {\n+                        reg: lower_reg(reg),\n+                        late: *late,\n+                        expr: self.lower_expr(expr),\n+                    },\n+                    InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                         hir::InlineAsmOperand::SplitInOut {\n                             reg: lower_reg(reg),\n-                            late,\n+                            late: *late,\n                             in_expr: self.lower_expr(in_expr),\n                             out_expr: out_expr.as_ref().map(|expr| self.lower_expr(expr)),\n                         }\n                     }\n-                    InlineAsmOperand::Const { ref anon_const } => {\n+                    InlineAsmOperand::Const { anon_const } => {\n                         if !self.tcx.features().asm_const {\n                             feature_err(\n                                 &sess.parse_sess,\n@@ -191,7 +189,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             anon_const: self.lower_anon_const(anon_const),\n                         }\n                     }\n-                    InlineAsmOperand::Sym { ref sym } => {\n+                    InlineAsmOperand::Sym { sym } => {\n                         let static_def_id = self\n                             .resolver\n                             .get_partial_res(sym.id)\n@@ -347,7 +345,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                     skip = true;\n \n                                     let idx2 = *o.get();\n-                                    let &(ref op2, op_sp2) = &operands[idx2];\n+                                    let (ref op2, op_sp2) = operands[idx2];\n                                     let Some(asm::InlineAsmRegOrRegClass::Reg(reg2)) = op2.reg() else {\n                                         unreachable!();\n                                     };"}, {"sha": "d310f72f7a3f8f8bdb3527ecf0fa3cc10c0474b9", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -31,16 +31,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut stmts = SmallVec::<[hir::Stmt<'hir>; 8]>::new();\n         let mut expr = None;\n         while let [s, tail @ ..] = ast_stmts {\n-            match s.kind {\n-                StmtKind::Local(ref local) => {\n+            match &s.kind {\n+                StmtKind::Local(local) => {\n                     let hir_id = self.lower_node_id(s.id);\n                     let local = self.lower_local(local);\n                     self.alias_attrs(hir_id, local.hir_id);\n                     let kind = hir::StmtKind::Local(local);\n                     let span = self.lower_span(s.span);\n                     stmts.push(hir::Stmt { hir_id, kind, span });\n                 }\n-                StmtKind::Item(ref it) => {\n+                StmtKind::Item(it) => {\n                     stmts.extend(self.lower_item_ref(it).into_iter().enumerate().map(\n                         |(i, item_id)| {\n                             let hir_id = match i {\n@@ -53,7 +53,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         },\n                     ));\n                 }\n-                StmtKind::Expr(ref e) => {\n+                StmtKind::Expr(e) => {\n                     let e = self.lower_expr(e);\n                     if tail.is_empty() {\n                         expr = Some(e);\n@@ -65,7 +65,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         stmts.push(hir::Stmt { hir_id, kind, span });\n                     }\n                 }\n-                StmtKind::Semi(ref e) => {\n+                StmtKind::Semi(e) => {\n                     let e = self.lower_expr(e);\n                     let hir_id = self.lower_node_id(s.id);\n                     self.alias_attrs(hir_id, e.hir_id);"}, {"sha": "a00100ee0a8458f506a7eb1d4d14056e832fd219", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 78, "deletions": 84, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -31,20 +31,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_expr_mut(&mut self, e: &Expr) -> hir::Expr<'hir> {\n         ensure_sufficient_stack(|| {\n-            let kind = match e.kind {\n-                ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n-                ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n-                ExprKind::ConstBlock(ref anon_const) => {\n+            let kind = match &e.kind {\n+                ExprKind::Box(inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n+                ExprKind::Array(exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::ConstBlock(anon_const) => {\n                     let anon_const = self.lower_anon_const(anon_const);\n                     hir::ExprKind::ConstBlock(anon_const)\n                 }\n-                ExprKind::Repeat(ref expr, ref count) => {\n+                ExprKind::Repeat(expr, count) => {\n                     let expr = self.lower_expr(expr);\n                     let count = self.lower_array_length(count);\n                     hir::ExprKind::Repeat(expr, count)\n                 }\n-                ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n-                ExprKind::Call(ref f, ref args) => {\n+                ExprKind::Tup(elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+                ExprKind::Call(f, args) => {\n                     if e.attrs.get(0).map_or(false, |a| a.has_name(sym::rustc_box)) {\n                         if let [inner] = &args[..] && e.attrs.len() == 1 {\n                             let kind = hir::ExprKind::Box(self.lower_expr(&inner));\n@@ -61,7 +61,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::ExprKind::Call(f, self.lower_exprs(args))\n                     }\n                 }\n-                ExprKind::MethodCall(box MethodCall { ref seg, ref receiver, ref args, span }) => {\n+                ExprKind::MethodCall(box MethodCall { seg, receiver, args, span }) => {\n                     let hir_seg = self.arena.alloc(self.lower_path_segment(\n                         e.span,\n                         seg,\n@@ -72,92 +72,88 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let receiver = self.lower_expr(receiver);\n                     let args =\n                         self.arena.alloc_from_iter(args.iter().map(|x| self.lower_expr_mut(x)));\n-                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(span))\n+                    hir::ExprKind::MethodCall(hir_seg, receiver, args, self.lower_span(*span))\n                 }\n-                ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-                    let binop = self.lower_binop(binop);\n+                ExprKind::Binary(binop, lhs, rhs) => {\n+                    let binop = self.lower_binop(*binop);\n                     let lhs = self.lower_expr(lhs);\n                     let rhs = self.lower_expr(rhs);\n                     hir::ExprKind::Binary(binop, lhs, rhs)\n                 }\n-                ExprKind::Unary(op, ref ohs) => {\n-                    let op = self.lower_unop(op);\n+                ExprKind::Unary(op, ohs) => {\n+                    let op = self.lower_unop(*op);\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::Unary(op, ohs)\n                 }\n                 ExprKind::Lit(token_lit) => {\n-                    let lit_kind = match LitKind::from_token_lit(token_lit) {\n+                    let lit_kind = match LitKind::from_token_lit(*token_lit) {\n                         Ok(lit_kind) => lit_kind,\n                         Err(err) => {\n-                            report_lit_error(&self.tcx.sess.parse_sess, err, token_lit, e.span);\n+                            report_lit_error(&self.tcx.sess.parse_sess, err, *token_lit, e.span);\n                             LitKind::Err\n                         }\n                     };\n                     hir::ExprKind::Lit(respan(self.lower_span(e.span), lit_kind))\n                 }\n-                ExprKind::IncludedBytes(ref bytes) => hir::ExprKind::Lit(respan(\n+                ExprKind::IncludedBytes(bytes) => hir::ExprKind::Lit(respan(\n                     self.lower_span(e.span),\n                     LitKind::ByteStr(bytes.clone()),\n                 )),\n-                ExprKind::Cast(ref expr, ref ty) => {\n+                ExprKind::Cast(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n                         self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Cast(expr, ty)\n                 }\n-                ExprKind::Type(ref expr, ref ty) => {\n+                ExprKind::Type(expr, ty) => {\n                     let expr = self.lower_expr(expr);\n                     let ty =\n                         self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                     hir::ExprKind::Type(expr, ty)\n                 }\n-                ExprKind::AddrOf(k, m, ref ohs) => {\n+                ExprKind::AddrOf(k, m, ohs) => {\n                     let ohs = self.lower_expr(ohs);\n-                    hir::ExprKind::AddrOf(k, m, ohs)\n+                    hir::ExprKind::AddrOf(*k, *m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                ExprKind::Let(pat, scrutinee, span) => {\n                     hir::ExprKind::Let(self.arena.alloc(hir::Let {\n                         hir_id: self.next_id(),\n-                        span: self.lower_span(span),\n+                        span: self.lower_span(*span),\n                         pat: self.lower_pat(pat),\n                         ty: None,\n                         init: self.lower_expr(scrutinee),\n                     }))\n                 }\n-                ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                ExprKind::If(cond, then, else_opt) => {\n                     self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }\n-                ExprKind::While(ref cond, ref body, opt_label) => {\n-                    self.with_loop_scope(e.id, |this| {\n-                        let span =\n-                            this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n-                        this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)\n-                    })\n-                }\n-                ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                ExprKind::While(cond, body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                    let span = this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);\n+                    this.lower_expr_while_in_loop_scope(span, cond, body, *opt_label)\n+                }),\n+                ExprKind::Loop(body, opt_label) => self.with_loop_scope(e.id, |this| {\n                     hir::ExprKind::Loop(\n                         this.lower_block(body, false),\n-                        this.lower_label(opt_label),\n+                        this.lower_label(*opt_label),\n                         hir::LoopSource::Loop,\n                         DUMMY_SP,\n                     )\n                 }),\n-                ExprKind::TryBlock(ref body) => self.lower_expr_try_block(body),\n-                ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                ExprKind::TryBlock(body) => self.lower_expr_try_block(body),\n+                ExprKind::Match(expr, arms) => hir::ExprKind::Match(\n                     self.lower_expr(expr),\n                     self.arena.alloc_from_iter(arms.iter().map(|x| self.lower_arm(x))),\n                     hir::MatchSource::Normal,\n                 ),\n-                ExprKind::Async(capture_clause, closure_node_id, ref block) => self\n-                    .make_async_expr(\n-                        capture_clause,\n-                        closure_node_id,\n-                        None,\n-                        block.span,\n-                        hir::AsyncGeneratorKind::Block,\n-                        |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n-                    ),\n-                ExprKind::Await(ref expr) => {\n+                ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n+                    *capture_clause,\n+                    *closure_node_id,\n+                    None,\n+                    block.span,\n+                    hir::AsyncGeneratorKind::Block,\n+                    |this| this.with_new_scopes(|this| this.lower_block_expr(block)),\n+                ),\n+                ExprKind::Await(expr) => {\n                     let dot_await_span = if expr.span.hi() < e.span.hi() {\n                         let span_with_whitespace = self\n                             .tcx\n@@ -173,65 +169,63 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     self.lower_expr_await(dot_await_span, expr)\n                 }\n                 ExprKind::Closure(box Closure {\n-                    ref binder,\n+                    binder,\n                     capture_clause,\n                     asyncness,\n                     movability,\n-                    ref fn_decl,\n-                    ref body,\n+                    fn_decl,\n+                    body,\n                     fn_decl_span,\n                 }) => {\n                     if let Async::Yes { closure_id, .. } = asyncness {\n                         self.lower_expr_async_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            closure_id,\n+                            *closure_id,\n                             fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n                         )\n                     } else {\n                         self.lower_expr_closure(\n                             binder,\n-                            capture_clause,\n+                            *capture_clause,\n                             e.id,\n-                            movability,\n+                            *movability,\n                             fn_decl,\n                             body,\n-                            fn_decl_span,\n+                            *fn_decl_span,\n                         )\n                     }\n                 }\n-                ExprKind::Block(ref blk, opt_label) => {\n-                    let opt_label = self.lower_label(opt_label);\n+                ExprKind::Block(blk, opt_label) => {\n+                    let opt_label = self.lower_label(*opt_label);\n                     hir::ExprKind::Block(self.lower_block(blk, opt_label.is_some()), opt_label)\n                 }\n-                ExprKind::Assign(ref el, ref er, span) => {\n-                    self.lower_expr_assign(el, er, span, e.span)\n-                }\n-                ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n-                    self.lower_binop(op),\n+                ExprKind::Assign(el, er, span) => self.lower_expr_assign(el, er, *span, e.span),\n+                ExprKind::AssignOp(op, el, er) => hir::ExprKind::AssignOp(\n+                    self.lower_binop(*op),\n                     self.lower_expr(el),\n                     self.lower_expr(er),\n                 ),\n-                ExprKind::Field(ref el, ident) => {\n-                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(ident))\n+                ExprKind::Field(el, ident) => {\n+                    hir::ExprKind::Field(self.lower_expr(el), self.lower_ident(*ident))\n                 }\n-                ExprKind::Index(ref el, ref er) => {\n+                ExprKind::Index(el, er) => {\n                     hir::ExprKind::Index(self.lower_expr(el), self.lower_expr(er))\n                 }\n-                ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                ExprKind::Range(Some(e1), Some(e2), RangeLimits::Closed) => {\n                     self.lower_expr_range_closed(e.span, e1, e2)\n                 }\n-                ExprKind::Range(ref e1, ref e2, lims) => {\n-                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), lims)\n+                ExprKind::Range(e1, e2, lims) => {\n+                    self.lower_expr_range(e.span, e1.as_deref(), e2.as_deref(), *lims)\n                 }\n                 ExprKind::Underscore => {\n                     self.tcx.sess.emit_err(UnderscoreExprLhsAssign { span: e.span });\n                     hir::ExprKind::Err\n                 }\n-                ExprKind::Path(ref qself, ref path) => {\n+                ExprKind::Path(qself, path) => {\n                     let qpath = self.lower_qpath(\n                         e.id,\n                         qself,\n@@ -241,22 +235,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     );\n                     hir::ExprKind::Path(qpath)\n                 }\n-                ExprKind::Break(opt_label, ref opt_expr) => {\n+                ExprKind::Break(opt_label, opt_expr) => {\n                     let opt_expr = opt_expr.as_ref().map(|x| self.lower_expr(x));\n-                    hir::ExprKind::Break(self.lower_jump_destination(e.id, opt_label), opt_expr)\n+                    hir::ExprKind::Break(self.lower_jump_destination(e.id, *opt_label), opt_expr)\n                 }\n                 ExprKind::Continue(opt_label) => {\n-                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, opt_label))\n+                    hir::ExprKind::Continue(self.lower_jump_destination(e.id, *opt_label))\n                 }\n-                ExprKind::Ret(ref e) => {\n+                ExprKind::Ret(e) => {\n                     let e = e.as_ref().map(|x| self.lower_expr(x));\n                     hir::ExprKind::Ret(e)\n                 }\n-                ExprKind::Yeet(ref sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n-                ExprKind::InlineAsm(ref asm) => {\n+                ExprKind::Yeet(sub_expr) => self.lower_expr_yeet(e.span, sub_expr.as_deref()),\n+                ExprKind::InlineAsm(asm) => {\n                     hir::ExprKind::InlineAsm(self.lower_inline_asm(e.span, asm))\n                 }\n-                ExprKind::Struct(ref se) => {\n+                ExprKind::Struct(se) => {\n                     let rest = match &se.rest {\n                         StructRest::Base(e) => Some(self.lower_expr(e)),\n                         StructRest::Rest(sp) => {\n@@ -278,10 +272,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         rest,\n                     )\n                 }\n-                ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n+                ExprKind::Yield(opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n                 ExprKind::Err => hir::ExprKind::Err,\n-                ExprKind::Try(ref sub_expr) => self.lower_expr_try(e.span, sub_expr),\n-                ExprKind::Paren(ref ex) => {\n+                ExprKind::Try(sub_expr) => self.lower_expr_try(e.span, sub_expr),\n+                ExprKind::Paren(ex) => {\n                     let mut ex = self.lower_expr_mut(ex);\n                     // Include parens in span, but only if it is a super-span.\n                     if e.span.contains(ex.span) {\n@@ -306,8 +300,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 // Desugar `ExprForLoop`\n                 // from: `[opt_ident]: for <pat> in <head> <body>`\n-                ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                    return self.lower_expr_for(e, pat, head, body, opt_label);\n+                ExprKind::ForLoop(pat, head, body, opt_label) => {\n+                    return self.lower_expr_for(e, pat, head, body, *opt_label);\n                 }\n                 ExprKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", e.span),\n             };\n@@ -358,7 +352,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: Vec<AstP<Expr>>,\n         legacy_args_idx: &[usize],\n     ) -> hir::ExprKind<'hir> {\n-        let ExprKind::Path(None, ref mut path) = f.kind else {\n+        let ExprKind::Path(None, path) = &mut f.kind else {\n             unreachable!();\n         };\n \n@@ -552,10 +546,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         let pat = self.lower_pat(&arm.pat);\n         let guard = arm.guard.as_ref().map(|cond| {\n-            if let ExprKind::Let(ref pat, ref scrutinee, span) = cond.kind {\n+            if let ExprKind::Let(pat, scrutinee, span) = &cond.kind {\n                 hir::Guard::IfLet(self.arena.alloc(hir::Let {\n                     hir_id: self.next_id(),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                     pat: self.lower_pat(pat),\n                     ty: None,\n                     init: self.lower_expr(scrutinee),\n@@ -961,8 +955,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> (hir::ClosureBinder, &'c [GenericParam]) {\n         let (binder, params) = match binder {\n             ClosureBinder::NotPresent => (hir::ClosureBinder::Default, &[][..]),\n-            &ClosureBinder::For { span, ref generic_params } => {\n-                let span = self.lower_span(span);\n+            ClosureBinder::For { span, generic_params } => {\n+                let span = self.lower_span(*span);\n                 (hir::ClosureBinder::For { span }, &**generic_params)\n             }\n         };"}, {"sha": "695a698e0227a15127be2688bf5c2b5b2ea43115", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -145,7 +145,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n-            if let ItemKind::Struct(ref struct_def, _) = i.kind {\n+            if let ItemKind::Struct(struct_def, _) = &i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));"}, {"sha": "a1941b5d8d3700f19736161eaf010cd4f43d9d11", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 79, "deletions": 102, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n             match parent_hir.node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n+                hir::ItemKind::Impl(hir::Impl { of_trait, .. }) => {\n                     lctx.is_in_trait_impl = of_trait.is_some();\n                 }\n                 _ => {}\n@@ -178,7 +178,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n         let mut node_ids =\n             smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n-        if let ItemKind::Use(ref use_tree) = &i.kind {\n+        if let ItemKind::Use(use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n         node_ids\n@@ -190,8 +190,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         base_id: NodeId,\n         vec: &mut SmallVec<[hir::ItemId; 1]>,\n     ) {\n-        match tree.kind {\n-            UseTreeKind::Nested(ref nested_vec) => {\n+        match &tree.kind {\n+            UseTreeKind::Nested(nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n@@ -201,8 +201,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             UseTreeKind::Glob => {}\n             UseTreeKind::Simple(_, id1, id2) => {\n-                for (_, &id) in\n-                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n+                for (_, id) in\n+                    iter::zip(self.expect_full_res_from_use(base_id).skip(1), [*id1, *id2])\n                 {\n                     vec.push(hir::ItemId {\n                         owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n@@ -238,26 +238,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         vis_span: Span,\n         i: &ItemKind,\n     ) -> hir::ItemKind<'hir> {\n-        match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n-            ItemKind::Use(ref use_tree) => {\n+        match i {\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(*orig_name),\n+            ItemKind::Use(use_tree) => {\n                 // Start with an empty prefix.\n                 let prefix = Path { segments: ThinVec::new(), span: use_tree.span, tokens: None };\n \n                 self.lower_use_tree(use_tree, &prefix, id, vis_span, ident, attrs)\n             }\n-            ItemKind::Static(ref t, m, ref e) => {\n+            ItemKind::Static(t, m, e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n-                hir::ItemKind::Static(ty, m, body_id)\n+                hir::ItemKind::Static(ty, *m, body_id)\n             }\n-            ItemKind::Const(_, ref t, ref e) => {\n+            ItemKind::Const(_, t, e) => {\n                 let (ty, body_id) = self.lower_const_item(t, span, e.as_deref());\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(box Fn {\n-                sig: FnSig { ref decl, header, span: fn_sig_span },\n-                ref generics,\n-                ref body,\n+                sig: FnSig { decl, header, span: fn_sig_span },\n+                generics,\n+                body,\n                 ..\n             }) => {\n                 self.with_new_scopes(|this| {\n@@ -274,37 +274,30 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n                         let ret_id = asyncness.opt_return_id();\n-                        this.lower_fn_decl(&decl, Some(id), fn_sig_span, FnDeclKind::Fn, ret_id)\n+                        this.lower_fn_decl(&decl, Some(id), *fn_sig_span, FnDeclKind::Fn, ret_id)\n                     });\n                     let sig = hir::FnSig {\n                         decl,\n-                        header: this.lower_fn_header(header),\n-                        span: this.lower_span(fn_sig_span),\n+                        header: this.lower_fn_header(*header),\n+                        span: this.lower_span(*fn_sig_span),\n                     };\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+            ItemKind::Mod(_, mod_kind) => match mod_kind {\n                 ModKind::Loaded(items, _, spans) => {\n                     hir::ItemKind::Mod(self.lower_mod(items, spans))\n                 }\n                 ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n             },\n-            ItemKind::ForeignMod(ref fm) => hir::ItemKind::ForeignMod {\n+            ItemKind::ForeignMod(fm) => hir::ItemKind::ForeignMod {\n                 abi: fm.abi.map_or(abi::Abi::FALLBACK, |abi| self.lower_abi(abi)),\n                 items: self\n                     .arena\n                     .alloc_from_iter(fm.items.iter().map(|x| self.lower_foreign_item_ref(x))),\n             },\n-            ItemKind::GlobalAsm(ref asm) => {\n-                hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm))\n-            }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ty: Some(ref ty),\n-                ..\n-            }) => {\n+            ItemKind::GlobalAsm(asm) => hir::ItemKind::GlobalAsm(self.lower_inline_asm(span, asm)),\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: Some(ty), .. }) => {\n                 // We lower\n                 //\n                 // type Foo = impl Trait\n@@ -314,7 +307,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // type Foo = Foo1\n                 // opaque type Foo1: Trait\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, true);\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n                     &generics,\n                     id,\n@@ -323,9 +316,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::TyAlias(box TyAlias {\n-                ref generics, ref where_clauses, ty: None, ..\n-            }) => {\n+            ItemKind::TyAlias(box TyAlias { generics, where_clauses, ty: None, .. }) => {\n                 let mut generics = generics.clone();\n                 add_ty_alias_where_clause(&mut generics, *where_clauses, true);\n                 let (generics, ty) = self.lower_generics(\n@@ -336,7 +327,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TyAlias(ty, generics)\n             }\n-            ItemKind::Enum(ref enum_definition, ref generics) => {\n+            ItemKind::Enum(enum_definition, generics) => {\n                 let (generics, variants) = self.lower_generics(\n                     generics,\n                     id,\n@@ -349,7 +340,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Enum(hir::EnumDef { variants }, generics)\n             }\n-            ItemKind::Struct(ref struct_def, ref generics) => {\n+            ItemKind::Struct(struct_def, generics) => {\n                 let (generics, struct_def) = self.lower_generics(\n                     generics,\n                     id,\n@@ -358,7 +349,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::Struct(struct_def, generics)\n             }\n-            ItemKind::Union(ref vdata, ref generics) => {\n+            ItemKind::Union(vdata, generics) => {\n                 let (generics, vdata) = self.lower_generics(\n                     generics,\n                     id,\n@@ -372,10 +363,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 polarity,\n                 defaultness,\n                 constness,\n-                generics: ref ast_generics,\n-                of_trait: ref trait_ref,\n-                self_ty: ref ty,\n-                items: ref impl_items,\n+                generics: ast_generics,\n+                of_trait: trait_ref,\n+                self_ty: ty,\n+                items: impl_items,\n             }) => {\n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -413,30 +404,24 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // `defaultness.has_value()` is never called for an `impl`, always `true` in order\n                 // to not cause an assertion failure inside the `lower_defaultness` function.\n                 let has_val = true;\n-                let (defaultness, defaultness_span) = self.lower_defaultness(defaultness, has_val);\n+                let (defaultness, defaultness_span) = self.lower_defaultness(*defaultness, has_val);\n                 let polarity = match polarity {\n                     ImplPolarity::Positive => ImplPolarity::Positive,\n-                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(s)),\n+                    ImplPolarity::Negative(s) => ImplPolarity::Negative(self.lower_span(*s)),\n                 };\n                 hir::ItemKind::Impl(self.arena.alloc(hir::Impl {\n-                    unsafety: self.lower_unsafety(unsafety),\n+                    unsafety: self.lower_unsafety(*unsafety),\n                     polarity,\n                     defaultness,\n                     defaultness_span,\n-                    constness: self.lower_constness(constness),\n+                    constness: self.lower_constness(*constness),\n                     generics,\n                     of_trait: trait_ref,\n                     self_ty: lowered_ty,\n                     items: new_impl_items,\n                 }))\n             }\n-            ItemKind::Trait(box Trait {\n-                is_auto,\n-                unsafety,\n-                ref generics,\n-                ref bounds,\n-                ref items,\n-            }) => {\n+            ItemKind::Trait(box Trait { is_auto, unsafety, generics, bounds, items }) => {\n                 let (generics, (unsafety, items, bounds)) = self.lower_generics(\n                     generics,\n                     id,\n@@ -449,13 +434,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let items = this.arena.alloc_from_iter(\n                             items.iter().map(|item| this.lower_trait_item_ref(item)),\n                         );\n-                        let unsafety = this.lower_unsafety(unsafety);\n+                        let unsafety = this.lower_unsafety(*unsafety);\n                         (unsafety, items, bounds)\n                     },\n                 );\n-                hir::ItemKind::Trait(is_auto, unsafety, generics, bounds, items)\n+                hir::ItemKind::Trait(*is_auto, unsafety, generics, bounds, items)\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+            ItemKind::TraitAlias(generics, bounds) => {\n                 let (generics, bounds) = self.lower_generics(\n                     generics,\n                     id,\n@@ -469,10 +454,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 hir::ItemKind::TraitAlias(generics, bounds)\n             }\n-            ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n+            ItemKind::MacroDef(MacroDef { body, macro_rules }) => {\n                 let body = P(self.lower_delim_args(body));\n                 let macro_kind = self.resolver.decl_macro_kind(self.local_def_id(id));\n-                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules }, macro_kind)\n+                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules: *macro_rules }, macro_kind)\n             }\n             ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")\n@@ -664,8 +649,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let item = hir::ForeignItem {\n             owner_id,\n             ident: self.lower_ident(i.ident),\n-            kind: match i.kind {\n-                ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n+            kind: match &i.kind {\n+                ForeignItemKind::Fn(box Fn { sig, generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, (fn_dec, fn_args)) =\n@@ -685,10 +670,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n-                ForeignItemKind::Static(ref t, m, _) => {\n+                ForeignItemKind::Static(t, m, _) => {\n                     let ty =\n                         self.lower_ty(t, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n-                    hir::ForeignItemKind::Static(ty, m)\n+                    hir::ForeignItemKind::Static(ty, *m)\n                 }\n                 ForeignItemKind::TyAlias(..) => hir::ForeignItemKind::Type,\n                 ForeignItemKind::MacCall(_) => panic!(\"macro shouldn't exist here\"),\n@@ -725,33 +710,33 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         parent_id: hir::HirId,\n         vdata: &VariantData,\n     ) -> hir::VariantData<'hir> {\n-        match *vdata {\n-            VariantData::Struct(ref fields, recovered) => hir::VariantData::Struct(\n+        match vdata {\n+            VariantData::Struct(fields, recovered) => hir::VariantData::Struct(\n                 self.arena\n                     .alloc_from_iter(fields.iter().enumerate().map(|f| self.lower_field_def(f))),\n-                recovered,\n+                *recovered,\n             ),\n-            VariantData::Tuple(ref fields, id) => {\n-                let ctor_id = self.lower_node_id(id);\n+            VariantData::Tuple(fields, id) => {\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n                 hir::VariantData::Tuple(\n                     self.arena.alloc_from_iter(\n                         fields.iter().enumerate().map(|f| self.lower_field_def(f)),\n                     ),\n                     ctor_id,\n-                    self.local_def_id(id),\n+                    self.local_def_id(*id),\n                 )\n             }\n             VariantData::Unit(id) => {\n-                let ctor_id = self.lower_node_id(id);\n+                let ctor_id = self.lower_node_id(*id);\n                 self.alias_attrs(ctor_id, parent_id);\n-                hir::VariantData::Unit(ctor_id, self.local_def_id(id))\n+                hir::VariantData::Unit(ctor_id, self.local_def_id(*id))\n             }\n         }\n     }\n \n     fn lower_field_def(&mut self, (index, f): (usize, &FieldDef)) -> hir::FieldDef<'hir> {\n-        let ty = if let TyKind::Path(ref qself, ref path) = f.ty.kind {\n+        let ty = if let TyKind::Path(qself, path) = &f.ty.kind {\n             let t = self.lower_path_ty(\n                 &f.ty,\n                 qself,\n@@ -783,13 +768,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         let trait_item_def_id = hir_id.expect_owner();\n \n-        let (generics, kind, has_default) = match i.kind {\n-            AssocItemKind::Const(_, ref ty, ref default) => {\n+        let (generics, kind, has_default) = match &i.kind {\n+            AssocItemKind::Const(_, ty, default) => {\n                 let ty = self.lower_ty(ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let body = default.as_ref().map(|x| self.lower_const_body(i.span, Some(x)));\n                 (hir::Generics::empty(), hir::TraitItemKind::Const(ty, body), body.is_some())\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: None, .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: None, .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n@@ -801,7 +786,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)), false)\n             }\n-            AssocItemKind::Fn(box Fn { ref sig, ref generics, body: Some(ref body), .. }) => {\n+            AssocItemKind::Fn(box Fn { sig, generics, body: Some(body), .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n                     self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n@@ -814,15 +799,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 );\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)), true)\n             }\n-            AssocItemKind::Type(box TyAlias {\n-                ref generics,\n-                where_clauses,\n-                ref bounds,\n-                ref ty,\n-                ..\n-            }) => {\n+            AssocItemKind::Type(box TyAlias { generics, where_clauses, bounds, ty, .. }) => {\n                 let mut generics = generics.clone();\n-                add_ty_alias_where_clause(&mut generics, where_clauses, false);\n+                add_ty_alias_where_clause(&mut generics, *where_clauses, false);\n                 let (generics, kind) = self.lower_generics(\n                     &generics,\n                     i.id,\n@@ -1354,7 +1333,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // keep track of the Span info. Now, `add_implicitly_sized` in `AstConv` checks both param bounds and\n         // where clauses for `?Sized`.\n         for pred in &generics.where_clause.predicates {\n-            let WherePredicate::BoundPredicate(ref bound_pred) = *pred else {\n+            let WherePredicate::BoundPredicate(bound_pred) = pred else {\n                 continue;\n             };\n             let compute_is_param = || {\n@@ -1515,11 +1494,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n-        match *pred {\n+        match pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                ref bound_generic_params,\n-                ref bounded_ty,\n-                ref bounds,\n+                bound_generic_params,\n+                bounded_ty,\n+                bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                 hir_id: self.next_id(),\n@@ -1532,29 +1511,27 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                     )\n                 })),\n-                span: self.lower_span(span),\n+                span: self.lower_span(*span),\n                 origin: PredicateOrigin::WhereClause,\n             }),\n-            WherePredicate::RegionPredicate(WhereRegionPredicate {\n-                ref lifetime,\n-                ref bounds,\n-                span,\n-            }) => hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                span: self.lower_span(span),\n-                lifetime: self.lower_lifetime(lifetime),\n-                bounds: self.lower_param_bounds(\n-                    bounds,\n-                    &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n-                ),\n-                in_where_clause: true,\n-            }),\n-            WherePredicate::EqPredicate(WhereEqPredicate { ref lhs_ty, ref rhs_ty, span }) => {\n+            WherePredicate::RegionPredicate(WhereRegionPredicate { lifetime, bounds, span }) => {\n+                hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    span: self.lower_span(*span),\n+                    lifetime: self.lower_lifetime(lifetime),\n+                    bounds: self.lower_param_bounds(\n+                        bounds,\n+                        &ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    ),\n+                    in_where_clause: true,\n+                })\n+            }\n+            WherePredicate::EqPredicate(WhereEqPredicate { lhs_ty, rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     lhs_ty: self\n                         .lower_ty(lhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                     rhs_ty: self\n                         .lower_ty(rhs_ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n-                    span: self.lower_span(span),\n+                    span: self.lower_span(*span),\n                 })\n             }\n         }"}, {"sha": "d1666dfbf64446d996fbd51f54828f77c2280fea", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 58, "deletions": 60, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -932,13 +932,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_attr_args(&self, args: &AttrArgs) -> AttrArgs {\n-        match *args {\n+        match args {\n             AttrArgs::Empty => AttrArgs::Empty,\n-            AttrArgs::Delimited(ref args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n+            AttrArgs::Delimited(args) => AttrArgs::Delimited(self.lower_delim_args(args)),\n             // This is an inert key-value attribute - it will never be visible to macros\n             // after it gets lowered to HIR. Therefore, we can extract literals to handle\n             // nonterminals in `#[doc]` (e.g. `#[doc = $e]`).\n-            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(ref expr)) => {\n+            AttrArgs::Eq(eq_span, AttrArgsEq::Ast(expr)) => {\n                 // In valid code the value always ends up as a single literal. Otherwise, a dummy\n                 // literal suffices because the error is handled elsewhere.\n                 let lit = if let ExprKind::Lit(token_lit) = expr.kind {\n@@ -957,9 +957,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         span: DUMMY_SP,\n                     }\n                 };\n-                AttrArgs::Eq(eq_span, AttrArgsEq::Hir(lit))\n+                AttrArgs::Eq(*eq_span, AttrArgsEq::Hir(lit))\n             }\n-            AttrArgs::Eq(_, AttrArgsEq::Hir(ref lit)) => {\n+            AttrArgs::Eq(_, AttrArgsEq::Hir(lit)) => {\n                 unreachable!(\"in literal form when lowering mac args eq: {:?}\", lit)\n             }\n         }\n@@ -987,12 +987,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::TypeBinding<'hir> {\n         debug!(\"lower_assoc_ty_constraint(constraint={:?}, itctx={:?})\", constraint, itctx);\n         // lower generic arguments of identifier in constraint\n-        let gen_args = if let Some(ref gen_args) = constraint.gen_args {\n+        let gen_args = if let Some(gen_args) = &constraint.gen_args {\n             let gen_args_ctor = match gen_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n+                GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, ParamMode::Explicit, itctx).0\n                 }\n-                GenericArgs::Parenthesized(ref data) => {\n+                GenericArgs::Parenthesized(data) => {\n                     self.emit_bad_parenthesized_trait_in_assoc_ty(data);\n                     let aba = self.ast_arena.aba.alloc(data.as_angle_bracketed_args());\n                     self.lower_angle_bracketed_parameter_data(aba, ParamMode::Explicit, itctx).0\n@@ -1004,15 +1004,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n         let itctx_tait = &ImplTraitContext::TypeAliasesOpaqueTy;\n \n-        let kind = match constraint.kind {\n-            AssocConstraintKind::Equality { ref term } => {\n+        let kind = match &constraint.kind {\n+            AssocConstraintKind::Equality { term } => {\n                 let term = match term {\n-                    Term::Ty(ref ty) => self.lower_ty(ty, itctx).into(),\n-                    Term::Const(ref c) => self.lower_anon_const(c).into(),\n+                    Term::Ty(ty) => self.lower_ty(ty, itctx).into(),\n+                    Term::Const(c) => self.lower_anon_const(c).into(),\n                 };\n                 hir::TypeBindingKind::Equality { term }\n             }\n-            AssocConstraintKind::Bound { ref bounds } => {\n+            AssocConstraintKind::Bound { bounds } => {\n                 // Piggy-back on the `impl Trait` context to figure out the correct behavior.\n                 let (desugar_to_impl_trait, itctx) = match itctx {\n                     // We are in the return position:\n@@ -1122,7 +1122,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         match arg {\n             ast::GenericArg::Lifetime(lt) => GenericArg::Lifetime(self.lower_lifetime(&lt)),\n             ast::GenericArg::Type(ty) => {\n-                match ty.kind {\n+                match &ty.kind {\n                     TyKind::Infer if self.tcx.features().generic_arg_infer => {\n                         return GenericArg::Infer(hir::InferArg {\n                             hir_id: self.lower_node_id(ty.id),\n@@ -1133,7 +1133,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // parsing. We try to resolve that ambiguity by attempting resolution in both the\n                     // type and value namespaces. If we resolved the path in the value namespace, we\n                     // transform it into a generic const argument.\n-                    TyKind::Path(ref qself, ref path) => {\n+                    TyKind::Path(qself, path) => {\n                         if let Some(res) = self\n                             .resolver\n                             .get_partial_res(ty.id)\n@@ -1240,12 +1240,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_ty_direct(&mut self, t: &Ty, itctx: &ImplTraitContext) -> hir::Ty<'hir> {\n-        let kind = match t.kind {\n+        let kind = match &t.kind {\n             TyKind::Infer => hir::TyKind::Infer,\n             TyKind::Err => hir::TyKind::Err,\n-            TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n-            TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n-            TyKind::Rptr(ref region, ref mt) => {\n+            TyKind::Slice(ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n+            TyKind::Ptr(mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n+            TyKind::Rptr(region, mt) => {\n                 let region = region.unwrap_or_else(|| {\n                     let id = if let Some(LifetimeRes::ElidedAnchor { start, end }) =\n                         self.resolver.get_lifetime_res(t.id)\n@@ -1261,7 +1261,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => {\n+            TyKind::BareFn(f) => {\n                 let generic_params = self.lower_lifetime_binder(t.id, &f.generic_params);\n                 hir::TyKind::BareFn(self.arena.alloc(hir::BareFnTy {\n                     generic_params,\n@@ -1272,13 +1272,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }))\n             }\n             TyKind::Never => hir::TyKind::Never,\n-            TyKind::Tup(ref tys) => hir::TyKind::Tup(\n+            TyKind::Tup(tys) => hir::TyKind::Tup(\n                 self.arena.alloc_from_iter(tys.iter().map(|ty| self.lower_ty_direct(ty, itctx))),\n             ),\n-            TyKind::Paren(ref ty) => {\n+            TyKind::Paren(ty) => {\n                 return self.lower_ty_direct(ty, itctx);\n             }\n-            TyKind::Path(ref qself, ref path) => {\n+            TyKind::Path(qself, path) => {\n                 return self.lower_path_ty(t, qself, path, ParamMode::Explicit, itctx);\n             }\n             TyKind::ImplicitSelf => {\n@@ -1298,70 +1298,68 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }),\n                 ))\n             }\n-            TyKind::Array(ref ty, ref length) => {\n+            TyKind::Array(ty, length) => {\n                 hir::TyKind::Array(self.lower_ty(ty, itctx), self.lower_array_length(length))\n             }\n-            TyKind::Typeof(ref expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n-            TyKind::TraitObject(ref bounds, kind) => {\n+            TyKind::Typeof(expr) => hir::TyKind::Typeof(self.lower_anon_const(expr)),\n+            TyKind::TraitObject(bounds, kind) => {\n                 let mut lifetime_bound = None;\n                 let (bounds, lifetime_bound) = self.with_dyn_type_scope(true, |this| {\n                     let bounds =\n-                        this.arena.alloc_from_iter(bounds.iter().filter_map(\n-                            |bound| match *bound {\n-                                GenericBound::Trait(\n-                                    ref ty,\n-                                    TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n-                                ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n-                                // `~const ?Bound` will cause an error during AST validation\n-                                // anyways, so treat it like `?Bound` as compilation proceeds.\n-                                GenericBound::Trait(\n-                                    _,\n-                                    TraitBoundModifier::Maybe | TraitBoundModifier::MaybeConstMaybe,\n-                                ) => None,\n-                                GenericBound::Outlives(ref lifetime) => {\n-                                    if lifetime_bound.is_none() {\n-                                        lifetime_bound = Some(this.lower_lifetime(lifetime));\n-                                    }\n-                                    None\n+                        this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| match bound {\n+                            GenericBound::Trait(\n+                                ty,\n+                                TraitBoundModifier::None | TraitBoundModifier::MaybeConst,\n+                            ) => Some(this.lower_poly_trait_ref(ty, itctx)),\n+                            // `~const ?Bound` will cause an error during AST validation\n+                            // anyways, so treat it like `?Bound` as compilation proceeds.\n+                            GenericBound::Trait(\n+                                _,\n+                                TraitBoundModifier::Maybe | TraitBoundModifier::MaybeConstMaybe,\n+                            ) => None,\n+                            GenericBound::Outlives(lifetime) => {\n+                                if lifetime_bound.is_none() {\n+                                    lifetime_bound = Some(this.lower_lifetime(lifetime));\n                                 }\n-                            },\n-                        ));\n+                                None\n+                            }\n+                        }));\n                     let lifetime_bound =\n                         lifetime_bound.unwrap_or_else(|| this.elided_dyn_bound(t.span));\n                     (bounds, lifetime_bound)\n                 });\n-                hir::TyKind::TraitObject(bounds, lifetime_bound, kind)\n+                hir::TyKind::TraitObject(bounds, lifetime_bound, *kind)\n             }\n-            TyKind::ImplTrait(def_node_id, ref bounds) => {\n+            TyKind::ImplTrait(def_node_id, bounds) => {\n                 let span = t.span;\n                 match itctx {\n                     ImplTraitContext::ReturnPositionOpaqueTy { origin, in_trait } => self\n                         .lower_opaque_impl_trait(\n                             span,\n                             *origin,\n-                            def_node_id,\n+                            *def_node_id,\n                             bounds,\n                             *in_trait,\n                             itctx,\n                         ),\n                     ImplTraitContext::TypeAliasesOpaqueTy => self.lower_opaque_impl_trait(\n                         span,\n                         hir::OpaqueTyOrigin::TyAlias,\n-                        def_node_id,\n+                        *def_node_id,\n                         bounds,\n                         false,\n                         itctx,\n                     ),\n                     ImplTraitContext::Universal => {\n                         self.create_def(\n                             self.current_hir_id_owner.def_id,\n-                            def_node_id,\n+                            *def_node_id,\n                             DefPathData::ImplTrait,\n                         );\n                         let span = t.span;\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         let (param, bounds, path) =\n-                            self.lower_generic_and_bounds(def_node_id, span, ident, bounds);\n+                            self.lower_generic_and_bounds(*def_node_id, span, ident, bounds);\n                         self.impl_trait_defs.push(param);\n                         if let Some(bounds) = bounds {\n                             self.impl_trait_bounds.push(bounds);\n@@ -1740,8 +1738,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 matches!(kind, FnDeclKind::Trait),\n             )\n         } else {\n-            match decl.output {\n-                FnRetTy::Ty(ref ty) => {\n+            match &decl.output {\n+                FnRetTy::Ty(ty) => {\n                     let mut context = match fn_node_id {\n                         Some(fn_node_id) if kind.impl_trait_allowed(self.tcx) => {\n                             let fn_def_id = self.local_def_id(fn_node_id);\n@@ -1763,7 +1761,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     };\n                     hir::FnRetTy::Return(self.lower_ty(ty, &mut context))\n                 }\n-                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(span)),\n+                FnRetTy::Default(span) => hir::FnRetTy::DefaultReturn(self.lower_span(*span)),\n             }\n         };\n \n@@ -1777,18 +1775,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     PatKind::Ident(hir::BindingAnnotation(_, Mutability::Mut), ..)\n                 );\n \n-                match arg.ty.kind {\n+                match &arg.ty.kind {\n                     TyKind::ImplicitSelf if is_mutable_pat => hir::ImplicitSelfKind::Mut,\n                     TyKind::ImplicitSelf => hir::ImplicitSelfKind::Imm,\n                     // Given we are only considering `ImplicitSelf` types, we needn't consider\n                     // the case where we have a mutable pattern to a reference as that would\n                     // no longer be an `ImplicitSelf`.\n-                    TyKind::Rptr(_, ref mt)\n+                    TyKind::Rptr(_, mt)\n                         if mt.ty.kind.is_implicit_self() && mt.mutbl == ast::Mutability::Mut =>\n                     {\n                         hir::ImplicitSelfKind::MutRef\n                     }\n-                    TyKind::Rptr(_, ref mt) if mt.ty.kind.is_implicit_self() => {\n+                    TyKind::Rptr(_, mt) if mt.ty.kind.is_implicit_self() => {\n                         hir::ImplicitSelfKind::ImmRef\n                     }\n                     _ => hir::ImplicitSelfKind::None,\n@@ -2181,7 +2179,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         param: &GenericParam,\n     ) -> (hir::ParamName, hir::GenericParamKind<'hir>) {\n-        match param.kind {\n+        match &param.kind {\n             GenericParamKind::Lifetime => {\n                 // AST resolution emitted an error on those parameters, so we lower them using\n                 // `ParamName::Error`.\n@@ -2197,7 +2195,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 (param_name, kind)\n             }\n-            GenericParamKind::Type { ref default, .. } => {\n+            GenericParamKind::Type { default, .. } => {\n                 let kind = hir::GenericParamKind::Type {\n                     default: default.as_ref().map(|x| {\n                         self.lower_ty(x, &ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n@@ -2207,7 +2205,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n-            GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n+            GenericParamKind::Const { ty, kw_span: _, default } => {\n                 let ty = self.lower_ty(&ty, &ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 ("}, {"sha": "16b012630da0e90d847c0961c019666420536230", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -22,16 +22,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         ensure_sufficient_stack(|| {\n             // loop here to avoid recursion\n             let node = loop {\n-                match pattern.kind {\n+                match &pattern.kind {\n                     PatKind::Wild => break hir::PatKind::Wild,\n-                    PatKind::Ident(binding_mode, ident, ref sub) => {\n-                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    PatKind::Ident(binding_mode, ident, sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(s));\n+                        break self.lower_pat_ident(pattern, *binding_mode, *ident, lower_sub);\n                     }\n-                    PatKind::Lit(ref e) => {\n+                    PatKind::Lit(e) => {\n                         break hir::PatKind::Lit(self.lower_expr_within_pat(e, false));\n                     }\n-                    PatKind::TupleStruct(ref qself, ref path, ref pats) => {\n+                    PatKind::TupleStruct(qself, path, pats) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -42,12 +42,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n                         break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n                     }\n-                    PatKind::Or(ref pats) => {\n+                    PatKind::Or(pats) => {\n                         break hir::PatKind::Or(\n                             self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat_mut(x))),\n                         );\n                     }\n-                    PatKind::Path(ref qself, ref path) => {\n+                    PatKind::Path(qself, path) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -57,7 +57,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         );\n                         break hir::PatKind::Path(qpath);\n                     }\n-                    PatKind::Struct(ref qself, ref path, ref fields, etc) => {\n+                    PatKind::Struct(qself, path, fields, etc) => {\n                         let qpath = self.lower_qpath(\n                             pattern.id,\n                             qself,\n@@ -78,32 +78,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span: self.lower_span(f.span),\n                             }\n                         }));\n-                        break hir::PatKind::Struct(qpath, fs, etc);\n+                        break hir::PatKind::Struct(qpath, fs, *etc);\n                     }\n-                    PatKind::Tuple(ref pats) => {\n+                    PatKind::Tuple(pats) => {\n                         let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n                         break hir::PatKind::Tuple(pats, ddpos);\n                     }\n-                    PatKind::Box(ref inner) => {\n+                    PatKind::Box(inner) => {\n                         break hir::PatKind::Box(self.lower_pat(inner));\n                     }\n-                    PatKind::Ref(ref inner, mutbl) => {\n-                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    PatKind::Ref(inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), *mutbl);\n                     }\n-                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                    PatKind::Range(e1, e2, Spanned { node: end, .. }) => {\n                         break hir::PatKind::Range(\n                             e1.as_deref().map(|e| self.lower_expr_within_pat(e, true)),\n                             e2.as_deref().map(|e| self.lower_expr_within_pat(e, true)),\n                             self.lower_range_end(end, e2.is_some()),\n                         );\n                     }\n-                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Slice(pats) => break self.lower_pat_slice(pats),\n                     PatKind::Rest => {\n                         // If we reach here the `..` pattern is not semantically allowed.\n                         break self.ban_illegal_rest_pat(pattern.span);\n                     }\n                     // return inner to be processed in next loop\n-                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::Paren(inner) => pattern = inner,\n                     PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n             };\n@@ -126,20 +126,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Note that unlike for slice patterns,\n             // where `xs @ ..` is a legal sub-slice pattern,\n             // it is not a legal sub-tuple pattern.\n-            match pat.kind {\n+            match &pat.kind {\n                 // Found a sub-tuple rest pattern\n                 PatKind::Rest => {\n                     rest = Some((idx, pat.span));\n                     break;\n                 }\n                 // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n                 // This is not allowed as a sub-tuple pattern\n-                PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(_, ident, Some(sub)) if sub.is_rest() => {\n                     let sp = pat.span;\n                     self.tcx.sess.emit_err(SubTupleBinding {\n                         span: sp,\n                         ident_name: ident.name,\n-                        ident,\n+                        ident: *ident,\n                         ctx,\n                     });\n                 }\n@@ -176,7 +176,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut prev_rest_span = None;\n \n         // Lowers `$bm $ident @ ..` to `$bm $ident @ _`.\n-        let lower_rest_sub = |this: &mut Self, pat, ann, ident, sub| {\n+        let lower_rest_sub = |this: &mut Self, pat, &ann, &ident, sub| {\n             let lower_sub = |this: &mut Self| Some(this.pat_wild_with_node_id_of(sub));\n             let node = this.lower_pat_ident(pat, ann, ident, lower_sub);\n             this.pat_with_node_id_of(pat, node)\n@@ -185,7 +185,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let mut iter = pats.iter();\n         // Lower all the patterns until the first occurrence of a sub-slice pattern.\n         for pat in iter.by_ref() {\n-            match pat.kind {\n+            match &pat.kind {\n                 // Found a sub-slice pattern `..`. Record, lower it to `_`, and stop here.\n                 PatKind::Rest => {\n                     prev_rest_span = Some(pat.span);\n@@ -194,7 +194,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 // Found a sub-slice pattern `$binding_mode $ident @ ..`.\n                 // Record, lower it to `$binding_mode $ident @ _`, and stop here.\n-                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(sub)) if sub.is_rest() => {\n                     prev_rest_span = Some(sub.span);\n                     slice = Some(self.arena.alloc(lower_rest_sub(self, pat, ann, ident, sub)));\n                     break;\n@@ -207,9 +207,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Lower all the patterns after the first sub-slice pattern.\n         for pat in iter {\n             // There was a previous subslice pattern; make sure we don't allow more.\n-            let rest_span = match pat.kind {\n+            let rest_span = match &pat.kind {\n                 PatKind::Rest => Some(pat.span),\n-                PatKind::Ident(ann, ident, Some(ref sub)) if sub.is_rest() => {\n+                PatKind::Ident(ann, ident, Some(sub)) if sub.is_rest() => {\n                     // #69103: Lower into `binding @ _` as above to avoid ICEs.\n                     after.push(lower_rest_sub(self, pat, ann, ident, sub));\n                     Some(sub.span)\n@@ -322,13 +322,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // m!(S);\n     // ```\n     fn lower_expr_within_pat(&mut self, expr: &Expr, allow_paths: bool) -> &'hir hir::Expr<'hir> {\n-        match expr.kind {\n+        match &expr.kind {\n             ExprKind::Lit(..)\n             | ExprKind::ConstBlock(..)\n             | ExprKind::IncludedBytes(..)\n             | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n-            ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n+            ExprKind::Unary(UnOp::Neg, inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => {\n                 self.tcx.sess.emit_err(ArbitraryExpressionInPattern { span: expr.span });\n                 return self.arena.alloc(self.expr_err(expr.span));"}, {"sha": "27b44c0b6a2b275eb6cd39324cff17e3077ff4fb", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -185,12 +185,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: &ImplTraitContext,\n     ) -> hir::PathSegment<'hir> {\n         debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n-        let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n-            match **generic_args {\n-                GenericArgs::AngleBracketed(ref data) => {\n+        let (mut generic_args, infer_args) = if let Some(generic_args) = segment.args.as_deref() {\n+            match generic_args {\n+                GenericArgs::AngleBracketed(data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n-                GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n+                GenericArgs::Parenthesized(data) => match parenthesized_generic_args {\n                     ParenthesizedGenericArgs::Ok => {\n                         self.lower_parenthesized_parameter_data(data, itctx)\n                     }"}, {"sha": "3f0d0a76027f45ca49a0bc3473037f465bfe799c", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -46,7 +46,7 @@ use rustc_hir::Expr;\n use rustc_hir_analysis::astconv::AstConv;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n-use rustc_infer::traits::{Obligation, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::Obligation;\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n@@ -62,8 +62,7 @@ use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::TraitEngineExt as _;\n-use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, ObligationCtxt};\n \n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n@@ -1055,9 +1054,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let Ok(ok) = coerce.coerce(source, target) else {\n                 return false;\n             };\n-            let mut fcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n-            fcx.register_predicate_obligations(self, ok.obligations);\n-            fcx.select_where_possible(&self).is_empty()\n+            let ocx = ObligationCtxt::new_in_snapshot(self);\n+            ocx.register_obligations(ok.obligations);\n+            ocx.select_where_possible().is_empty()\n         })\n     }\n "}, {"sha": "0ed24fe849c079ba0b0d186bb652ab258583363d", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -245,9 +245,9 @@ impl<'a> Parser<'a> {\n     ///     PATH `=` UNSUFFIXED_LIT\n     /// The delimiters or `=` are still put into the resulting token stream.\n     pub fn parse_attr_item(&mut self, capture_tokens: bool) -> PResult<'a, ast::AttrItem> {\n-        let item = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n+        let item = match &self.token.kind {\n+            token::Interpolated(nt) => match &**nt {\n+                Nonterminal::NtMeta(item) => Some(item.clone().into_inner()),\n                 _ => None,\n             },\n             _ => None,\n@@ -364,9 +364,9 @@ impl<'a> Parser<'a> {\n     /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     /// ```\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n-        let nt_meta = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref e) => Some(e.clone()),\n+        let nt_meta = match &self.token.kind {\n+            token::Interpolated(nt) => match &**nt {\n+                token::NtMeta(e) => Some(e.clone()),\n                 _ => None,\n             },\n             _ => None,"}, {"sha": "94c83503dc99b923b62932811a989ddc1032319b", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -973,7 +973,7 @@ impl<'a> Parser<'a> {\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n     ) -> bool /* advanced the cursor */ {\n-        if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n+        if let ExprKind::Binary(op, l1, r1) = &inner_op.kind {\n             if let ExprKind::Field(_, ident) = l1.kind\n                 && ident.as_str().parse::<i32>().is_err()\n                 && !matches!(r1.kind, ExprKind::Lit(_))\n@@ -1079,8 +1079,8 @@ impl<'a> Parser<'a> {\n \n         let mk_err_expr = |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err)));\n \n-        match inner_op.kind {\n-            ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n+        match &inner_op.kind {\n+            ExprKind::Binary(op, l1, r1) if op.node.is_comparison() => {\n                 let mut err = ComparisonOperatorsCannotBeChained {\n                     span: vec![op.span, self.prev_token.span],\n                     suggest_turbofish: None,\n@@ -1237,8 +1237,8 @@ impl<'a> Parser<'a> {\n         let bounds = self.parse_generic_bounds(None)?;\n         let sum_span = ty.span.to(self.prev_token.span);\n \n-        let sub = match ty.kind {\n-            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n+        let sub = match &ty.kind {\n+            TyKind::Rptr(lifetime, mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n                     s.print_opt_lifetime(lifetime);"}, {"sha": "dc914f5ea6454d443cf18a401e1da3e859854026", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -414,7 +414,7 @@ impl<'a> Parser<'a> {\n                 self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n                 false\n             }\n-            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => false,\n+            (true, Some(op)) if !op.can_continue_expr_unambiguously() => false,\n             (true, Some(_)) => {\n                 self.error_found_expr_would_be_stmt(lhs);\n                 true\n@@ -1728,7 +1728,7 @@ impl<'a> Parser<'a> {\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n         {\n             let expr = self.parse_expr_opt()?;\n-            if let Some(ref expr) = expr {\n+            if let Some(expr) = &expr {\n                 if label.is_some()\n                     && matches!(\n                         expr.kind,\n@@ -2590,8 +2590,8 @@ impl<'a> Parser<'a> {\n         // Used to check the `let_chains` and `if_let_guard` features mostly by scanning\n         // `&&` tokens.\n         fn check_let_expr(expr: &Expr) -> (bool, bool) {\n-            match expr.kind {\n-                ExprKind::Binary(BinOp { node: BinOpKind::And, .. }, ref lhs, ref rhs) => {\n+            match &expr.kind {\n+                ExprKind::Binary(BinOp { node: BinOpKind::And, .. }, lhs, rhs) => {\n                     let lhs_rslt = check_let_expr(lhs);\n                     let rhs_rslt = check_let_expr(rhs);\n                     (lhs_rslt.0 || rhs_rslt.0, false)"}, {"sha": "db3072e42627447712936eb4af29de8bc9f53c66", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -1255,8 +1255,8 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        match impl_info.1 {\n-            ItemKind::Impl(box Impl { of_trait: Some(ref trai), ref mut constness, .. }) => {\n+        match &mut impl_info.1 {\n+            ItemKind::Impl(box Impl { of_trait: Some(trai), constness, .. }) => {\n                 *constness = Const::Yes(const_span);\n \n                 let before_trait = trai.path.span.shrink_to_lo();\n@@ -2585,8 +2585,8 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_named_param(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n+        let offset = match &self.token.kind {\n+            token::Interpolated(nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             },"}, {"sha": "4d8bff28b05aa300a4ed81e7505536914837e8fd", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -384,8 +384,8 @@ enum TokenType {\n \n impl TokenType {\n     fn to_string(&self) -> String {\n-        match *self {\n-            TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_kind_to_string(t)),\n+        match self {\n+            TokenType::Token(t) => format!(\"`{}`\", pprust::token_kind_to_string(t)),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw),\n             TokenType::Operator => \"an operator\".to_string(),\n             TokenType::Lifetime => \"lifetime\".to_string(),\n@@ -738,8 +738,8 @@ impl<'a> Parser<'a> {\n \n     fn check_inline_const(&self, dist: usize) -> bool {\n         self.is_keyword_ahead(dist, &[kw::Const])\n-            && self.look_ahead(dist + 1, |t| match t.kind {\n-                token::Interpolated(ref nt) => matches!(**nt, token::NtBlock(..)),\n+            && self.look_ahead(dist + 1, |t| match &t.kind {\n+                token::Interpolated(nt) => matches!(**nt, token::NtBlock(..)),\n                 token::OpenDelim(Delimiter::Brace) => true,\n                 _ => false,\n             })\n@@ -860,7 +860,7 @@ impl<'a> Parser<'a> {\n             if let token::CloseDelim(..) | token::Eof = self.token.kind {\n                 break;\n             }\n-            if let Some(ref t) = sep.sep {\n+            if let Some(t) = &sep.sep {\n                 if first {\n                     first = false;\n                 } else {\n@@ -895,7 +895,7 @@ impl<'a> Parser<'a> {\n \n                                 _ => {\n                                     // Attempt to keep parsing if it was a similar separator.\n-                                    if let Some(ref tokens) = t.similar_tokens() {\n+                                    if let Some(tokens) = t.similar_tokens() {\n                                         if tokens.contains(&self.token.kind) && !unclosed_delims {\n                                             self.bump();\n                                         }"}, {"sha": "239ed79ce2ffb825682f1fd3db0d26661cd8cf5e", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -42,9 +42,9 @@ impl<'a> Parser<'a> {\n                 token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n                 _ => token.can_begin_type(),\n             },\n-            NonterminalKind::Block => match token.kind {\n+            NonterminalKind::Block => match &token.kind {\n                 token::OpenDelim(Delimiter::Brace) => true,\n-                token::Interpolated(ref nt) => !matches!(\n+                token::Interpolated(nt) => !matches!(\n                     **nt,\n                     token::NtItem(_)\n                         | token::NtPat(_)\n@@ -56,16 +56,16 @@ impl<'a> Parser<'a> {\n                 ),\n                 _ => false,\n             },\n-            NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n+            NonterminalKind::Path | NonterminalKind::Meta => match &token.kind {\n                 token::ModSep | token::Ident(..) => true,\n-                token::Interpolated(ref nt) => match **nt {\n+                token::Interpolated(nt) => match **nt {\n                     token::NtPath(_) | token::NtMeta(_) => true,\n                     _ => may_be_ident(&nt),\n                 },\n                 _ => false,\n             },\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n-                match token.kind {\n+                match &token.kind {\n                 token::Ident(..) |                          // box, ref, mut, and other identifiers (can stricten)\n                 token::OpenDelim(Delimiter::Parenthesis) |  // tuple pattern\n                 token::OpenDelim(Delimiter::Bracket) |      // slice pattern\n@@ -80,13 +80,13 @@ impl<'a> Parser<'a> {\n                 token::BinOp(token::Shl) => true,           // path (double UFCS)\n                 // leading vert `|` or-pattern\n                 token::BinOp(token::Or) =>  matches!(kind, NonterminalKind::PatWithOr {..}),\n-                token::Interpolated(ref nt) => may_be_ident(nt),\n+                token::Interpolated(nt) => may_be_ident(nt),\n                 _ => false,\n             }\n             }\n-            NonterminalKind::Lifetime => match token.kind {\n+            NonterminalKind::Lifetime => match &token.kind {\n                 token::Lifetime(_) => true,\n-                token::Interpolated(ref nt) => {\n+                token::Interpolated(nt) => {\n                     matches!(**nt, token::NtLifetime(_))\n                 }\n                 _ => false,"}, {"sha": "cbeec951e2dfe8dd0c037ae7f44a966ce11905d7", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -485,7 +485,7 @@ impl<'a> Parser<'a> {\n         let mut rhs = self.parse_pat_no_top_alt(None)?;\n         let sp = lhs.span.to(rhs.span);\n \n-        if let PatKind::Ident(_, _, ref mut sub @ None) = rhs.kind {\n+        if let PatKind::Ident(_, _, sub @ None) = &mut rhs.kind {\n             // The user inverted the order, so help them fix that.\n             let mut applicability = Applicability::MachineApplicable;\n             // FIXME(bindings_after_at): Remove this code when stabilizing the feature.\n@@ -595,7 +595,7 @@ impl<'a> Parser<'a> {\n         self.recover_additional_muts();\n \n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n-        if let token::Interpolated(ref nt) = self.token.kind {\n+        if let token::Interpolated(nt) = &self.token.kind {\n             if let token::NtPat(_) = **nt {\n                 self.expected_ident_found().emit();\n             }\n@@ -796,7 +796,7 @@ impl<'a> Parser<'a> {\n     /// expression syntax `...expr` for splatting in expressions.\n     fn parse_pat_range_to(&mut self, mut re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n         let end = self.parse_pat_range_end()?;\n-        if let RangeEnd::Included(ref mut syn @ RangeSyntax::DotDotDot) = &mut re.node {\n+        if let RangeEnd::Included(syn @ RangeSyntax::DotDotDot) = &mut re.node {\n             *syn = RangeSyntax::DotDotEq;\n             self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n                 .span_suggestion_short("}, {"sha": "1b56cd72db079b872f3fea8678b4d7b640743b2a", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -563,9 +563,9 @@ impl<'a> Parser<'a> {\n         };\n \n         let mut eat_semi = true;\n-        match stmt.kind {\n+        match &mut stmt.kind {\n             // Expression without semicolon.\n-            StmtKind::Expr(ref mut expr)\n+            StmtKind::Expr(expr)\n                 if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) => {\n                 // Just check for errors and recover; do not eat semicolon yet.\n                 // `expect_one_of` returns PResult<'a, bool /* recovered */>\n@@ -611,7 +611,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             StmtKind::Expr(_) | StmtKind::MacCall(_) => {}\n-            StmtKind::Local(ref mut local) if let Err(e) = self.expect_semi() => {\n+            StmtKind::Local(local) if let Err(e) = self.expect_semi() => {\n                 // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n                 match &mut local.kind {\n                     LocalKind::Init(expr) | LocalKind::InitElse(expr, _) => {"}, {"sha": "59d017545c0324329e651fc31b575eb1f71456b8", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -4,13 +4,12 @@ pub mod suggestions;\n \n use super::{\n     FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes, Obligation, ObligationCause,\n-    ObligationCauseCode, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n-    SelectionContext, SelectionError, TraitNotObjectSafe,\n+    ObligationCauseCode, ObligationCtxt, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n-use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use crate::traits::query::normalize::AtExt as _;\n use crate::traits::specialize::to_pretty_impl_header;\n@@ -30,7 +29,6 @@ use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::TypeErrCtxt;\n use rustc_infer::infer::TypeTrace;\n-use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -354,9 +352,9 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     param_env,\n                     ty.rebind(ty::TraitPredicate { trait_ref, constness, polarity }),\n                 );\n-                let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(self.tcx);\n-                fulfill_cx.register_predicate_obligation(self, obligation);\n-                if fulfill_cx.select_all_or_error(self).is_empty() {\n+                let ocx = ObligationCtxt::new_in_snapshot(self);\n+                ocx.register_obligation(obligation);\n+                if ocx.select_all_or_error().is_empty() {\n                     return Ok((\n                         ty::ClosureKind::from_def_id(self.tcx, trait_def_id)\n                             .expect(\"expected to map DefId to ClosureKind\"),\n@@ -2546,7 +2544,10 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let obligation =\n                 Obligation::new(self.tcx, ObligationCause::dummy(), param_env, cleaned_pred);\n \n-            self.predicate_may_hold(&obligation)\n+            // We don't use `InferCtxt::predicate_may_hold` because that\n+            // will re-run predicates that overflow locally, which ends up\n+            // taking a really long time to compute.\n+            self.evaluate_obligation(&obligation).map_or(false, |eval| eval.may_apply())\n         })\n     }\n "}, {"sha": "bb6d7d0e8dff181a1f0586a2413bdb68b7e42aaf", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -1340,9 +1340,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     obligation.param_env,\n                     trait_pred_and_suggested_ty,\n                 );\n-                let suggested_ty_would_satisfy_obligation = self\n-                    .evaluate_obligation_no_overflow(&new_obligation)\n-                    .must_apply_modulo_regions();\n+                let suggested_ty_would_satisfy_obligation =\n+                    self.predicate_must_hold_modulo_regions(&new_obligation);\n                 if suggested_ty_would_satisfy_obligation {\n                     let sp = self\n                         .tcx"}, {"sha": "548ca1c1d7faa4abe86ab5dc9050f0c58e2e07c3", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -31,7 +31,6 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::{\n@@ -403,9 +402,7 @@ pub fn fully_solve_obligation<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     obligation: PredicateObligation<'tcx>,\n ) -> Vec<FulfillmentError<'tcx>> {\n-    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    engine.register_predicate_obligation(infcx, obligation);\n-    engine.select_all_or_error(infcx)\n+    fully_solve_obligations(infcx, [obligation])\n }\n \n /// Process a set of obligations (and any nested obligations that come from them)\n@@ -414,9 +411,9 @@ pub fn fully_solve_obligations<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     obligations: impl IntoIterator<Item = PredicateObligation<'tcx>>,\n ) -> Vec<FulfillmentError<'tcx>> {\n-    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    engine.register_predicate_obligations(infcx, obligations);\n-    engine.select_all_or_error(infcx)\n+    let ocx = ObligationCtxt::new(infcx);\n+    ocx.register_obligations(obligations);\n+    ocx.select_all_or_error()\n }\n \n /// Process a bound (and any nested obligations that come from it) to completion.\n@@ -429,9 +426,16 @@ pub fn fully_solve_bound<'tcx>(\n     ty: Ty<'tcx>,\n     bound: DefId,\n ) -> Vec<FulfillmentError<'tcx>> {\n-    let mut engine = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-    engine.register_bound(infcx, param_env, ty, bound, cause);\n-    engine.select_all_or_error(infcx)\n+    let tcx = infcx.tcx;\n+    let trait_ref = ty::TraitRef { def_id: bound, substs: tcx.mk_substs_trait(ty, []) };\n+    let obligation = Obligation {\n+        cause,\n+        recursion_depth: 0,\n+        param_env,\n+        predicate: ty::Binder::dummy(trait_ref).without_const().to_predicate(tcx),\n+    };\n+\n+    fully_solve_obligation(infcx, obligation)\n }\n \n /// Normalizes the predicates and checks whether they hold in an empty environment. If this"}, {"sha": "9a3c0707c7ce950102b9e99a36cac2c10f8a7644", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -10,14 +10,14 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n pub mod specialization_graph;\n-use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use specialization_graph::GraphExt;\n \n use crate::errors::NegativePositiveConflict;\n use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n-use crate::traits::engine::TraitEngineExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n-use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause};\n+use crate::traits::{\n+    self, coherence, FutureCompatOverlapErrorKind, ObligationCause, ObligationCtxt,\n+};\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::{error_code, DelayDm, Diagnostic};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -204,12 +204,12 @@ fn fulfill_implication<'tcx>(\n \n     // Needs to be `in_snapshot` because this function is used to rebase\n     // substitutions, which may happen inside of a select within a probe.\n-    let mut engine = <dyn TraitEngine<'tcx>>::new_in_snapshot(infcx.tcx);\n+    let ocx = ObligationCtxt::new_in_snapshot(infcx);\n     // attempt to prove all of the predicates for impl2 given those for impl1\n     // (which are packed up in penv)\n-    engine.register_predicate_obligations(infcx, obligations.chain(more_obligations));\n+    ocx.register_obligations(obligations.chain(more_obligations));\n \n-    let errors = engine.select_all_or_error(infcx);\n+    let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n         // no dice!\n         debug!("}, {"sha": "40dbe0b3ff063d927dc78c3de0e2eefb1ab3b113", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -1,6 +1,5 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n-use crate::traits::ObligationCause;\n-use crate::traits::{TraitEngine, TraitEngineExt};\n+use crate::traits::{ObligationCause, ObligationCtxt};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -72,28 +71,16 @@ fn type_marked_structural<'tcx>(\n     adt_ty: Ty<'tcx>,\n     cause: ObligationCause<'tcx>,\n ) -> bool {\n-    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+    let ocx = ObligationCtxt::new(infcx);\n     // require `#[derive(PartialEq)]`\n     let structural_peq_def_id =\n         infcx.tcx.require_lang_item(LangItem::StructuralPeq, Some(cause.span));\n-    fulfillment_cx.register_bound(\n-        infcx,\n-        ty::ParamEnv::empty(),\n-        adt_ty,\n-        structural_peq_def_id,\n-        cause.clone(),\n-    );\n+    ocx.register_bound(cause.clone(), ty::ParamEnv::empty(), adt_ty, structural_peq_def_id);\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n     let structural_teq_def_id =\n         infcx.tcx.require_lang_item(LangItem::StructuralTeq, Some(cause.span));\n-    fulfillment_cx.register_bound(\n-        infcx,\n-        ty::ParamEnv::empty(),\n-        adt_ty,\n-        structural_teq_def_id,\n-        cause,\n-    );\n+    ocx.register_bound(cause, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id);\n \n     // We deliberately skip *reporting* fulfillment errors (via\n     // `report_fulfillment_errors`), for two reasons:\n@@ -104,7 +91,7 @@ fn type_marked_structural<'tcx>(\n     //\n     // 2. We are sometimes doing future-incompatibility lints for\n     //    now, so we do not want unconditional errors here.\n-    fulfillment_cx.select_all_or_error(infcx).is_empty()\n+    ocx.select_all_or_error().is_empty()\n }\n \n /// This implements the traversal over the structure of a given type to try to"}, {"sha": "3ab353c96380230b75d1e3b7902eb8769dfe6abe", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -5,16 +5,15 @@\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{self, Canonical};\n use rustc_infer::infer::outlives::components::{push_outlives_components, Component};\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::query::OutlivesBound;\n-use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitable};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n use rustc_trait_selection::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n use rustc_trait_selection::traits::wf;\n-use rustc_trait_selection::traits::{TraitEngine, TraitEngineExt};\n+use rustc_trait_selection::traits::ObligationCtxt;\n use smallvec::{smallvec, SmallVec};\n \n pub(crate) fn provide(p: &mut Providers) {\n@@ -30,16 +29,16 @@ fn implied_outlives_bounds<'tcx>(\n > {\n     tcx.infer_ctxt().enter_canonical_trait_query(&goal, |ocx, key| {\n         let (param_env, ty) = key.into_parts();\n-        compute_implied_outlives_bounds(&ocx.infcx, param_env, ty)\n+        compute_implied_outlives_bounds(ocx, param_env, ty)\n     })\n }\n \n fn compute_implied_outlives_bounds<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ocx: &ObligationCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n-    let tcx = infcx.tcx;\n+    let tcx = ocx.infcx.tcx;\n \n     // Sometimes when we ask what it takes for T: WF, we get back that\n     // U: WF is required; in that case, we push U onto this stack and\n@@ -52,8 +51,6 @@ fn compute_implied_outlives_bounds<'tcx>(\n     let mut outlives_bounds: Vec<ty::OutlivesPredicate<ty::GenericArg<'tcx>, ty::Region<'tcx>>> =\n         vec![];\n \n-    let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new(tcx);\n-\n     while let Some(arg) = wf_args.pop() {\n         if !checked_wf_args.insert(arg) {\n             continue;\n@@ -70,15 +67,15 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // FIXME(@lcnr): It's not really \"always fine\", having fewer implied\n         // bounds can be backward incompatible, e.g. #101951 was caused by\n         // us not dealing with inference vars in `TypeOutlives` predicates.\n-        let obligations = wf::obligations(infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n-            .unwrap_or_default();\n+        let obligations =\n+            wf::obligations(ocx.infcx, param_env, hir::CRATE_HIR_ID, 0, arg, DUMMY_SP)\n+                .unwrap_or_default();\n \n         // While these predicates should all be implied by other parts of\n         // the program, they are still relevant as they may constrain\n         // inference variables, which is necessary to add the correct\n         // implied bounds in some cases, mostly when dealing with projections.\n-        fulfill_cx.register_predicate_obligations(\n-            infcx,\n+        ocx.register_obligations(\n             obligations.iter().filter(|o| o.predicate.has_non_region_infer()).cloned(),\n         );\n \n@@ -116,9 +113,9 @@ fn compute_implied_outlives_bounds<'tcx>(\n         }));\n     }\n \n-    // Ensure that those obligations that we had to solve\n-    // get solved *here*.\n-    match fulfill_cx.select_all_or_error(infcx).as_slice() {\n+    // This call to `select_all_or_error` is necessary to constrain inference variables, which we\n+    // use further down when computing the implied bounds.\n+    match ocx.select_all_or_error().as_slice() {\n         [] => (),\n         _ => return Err(NoSolution),\n     }\n@@ -130,7 +127,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n         .flat_map(|ty::OutlivesPredicate(a, r_b)| match a.unpack() {\n             ty::GenericArgKind::Lifetime(r_a) => vec![OutlivesBound::RegionSubRegion(r_b, r_a)],\n             ty::GenericArgKind::Type(ty_a) => {\n-                let ty_a = infcx.resolve_vars_if_possible(ty_a);\n+                let ty_a = ocx.infcx.resolve_vars_if_possible(ty_a);\n                 let mut components = smallvec![];\n                 push_outlives_components(tcx, ty_a, &mut components);\n                 implied_bounds_from_components(r_b, components)"}, {"sha": "251431a15eb89a19bcba27d867eff9f99f18365b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -1094,7 +1094,13 @@ impl<'a> Builder<'a> {\n             let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n                 Mode::Rustc | Mode::ToolRustc => self.compiler_doc_out(target),\n-                Mode::Std => out_dir.join(target.triple).join(\"doc\"),\n+                Mode::Std => {\n+                    if self.config.cmd.json() {\n+                        out_dir.join(target.triple).join(\"json-doc\")\n+                    } else {\n+                        out_dir.join(target.triple).join(\"doc\")\n+                    }\n+                }\n                 _ => panic!(\"doc mode {:?} not expected\", mode),\n             };\n             let rustdoc = self.rustdoc(compiler);"}, {"sha": "571396eb835bff3e247dd03a8e895d552c7b7173", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -564,27 +564,22 @@ fn doc_std(\n         );\n     }\n     let compiler = builder.compiler(stage, builder.config.build);\n+\n+    let target_doc_dir_name = if format == DocumentationFormat::JSON { \"json-doc\" } else { \"doc\" };\n+    let target_dir =\n+        builder.stage_out(compiler, Mode::Std).join(target.triple).join(target_doc_dir_name);\n+\n     // This is directory where the compiler will place the output of the command.\n     // We will then copy the files from this directory into the final `out` directory, the specified\n     // as a function parameter.\n-    let out_dir = builder.stage_out(compiler, Mode::Std).join(target.triple).join(\"doc\");\n-    // `cargo` uses the same directory for both JSON docs and HTML docs.\n-    // This could lead to cross-contamination when copying files into the specified `out` directory.\n-    // For example:\n-    // ```bash\n-    // x doc std\n-    // x doc std --json\n-    // ```\n-    // could lead to HTML docs being copied into the JSON docs output directory.\n-    // To avoid this issue, we clean the doc folder before invoking `cargo`.\n-    if out_dir.exists() {\n-        builder.remove_dir(&out_dir);\n-    }\n+    let out_dir = target_dir.join(target.triple).join(\"doc\");\n \n     let run_cargo_rustdoc_for = |package: &str| {\n         let mut cargo = builder.cargo(compiler, Mode::Std, SourceType::InTree, target, \"rustdoc\");\n         compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n         cargo\n+            .arg(\"--target-dir\")\n+            .arg(&*target_dir.to_string_lossy())\n             .arg(\"-p\")\n             .arg(package)\n             .arg(\"-Zskip-rustdoc-fingerprint\")"}, {"sha": "63530b924c270bab4a3a5adcf7c883e169e804ff", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -701,6 +701,8 @@ a {\n }\n \n .small-section-header {\n+\t/* fields use <span> tags, but should get their own lines */\n+\tdisplay: block;\n \tposition: relative;\n }\n "}, {"sha": "bfabbbc65862fcb04d3190ebfd89713ddb7e38d2", "filename": "src/test/run-make/rustdoc-verify-output-files/Makefile", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frun-make%2Frustdoc-verify-output-files%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frun-make%2Frustdoc-verify-output-files%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-verify-output-files%2FMakefile?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,36 @@\n+include ../../run-make-fulldeps/tools.mk\n+\n+OUTPUT_DIR := \"$(TMPDIR)/rustdoc\"\n+TMP_OUTPUT_DIR := \"$(TMPDIR)/tmp-rustdoc\"\n+\n+all:\n+\t# Generate html docs\n+\t$(RUSTDOC) src/lib.rs --crate-name foobar --crate-type lib --out-dir $(OUTPUT_DIR)\n+\n+\t# Copy first output for to check if it's exactly same after second compilation\n+\tcp -R $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)\n+\n+\t# Generate html docs once again on same output\n+\t$(RUSTDOC) src/lib.rs --crate-name foobar --crate-type lib --out-dir $(OUTPUT_DIR)\n+\n+\t# Check if everything exactly same\n+\t$(DIFF) -r -q $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)\n+\n+\t# Generate json doc on the same output\n+\t$(RUSTDOC) src/lib.rs --crate-name foobar --crate-type lib --out-dir $(OUTPUT_DIR) -Z unstable-options --output-format json\n+\n+\t# Check if expected json file is generated\n+\t[ -e $(OUTPUT_DIR)/foobar.json ]\n+\n+\t# TODO\n+\t# We should re-generate json doc once again and compare the diff with previously\n+\t# generated one. Because layout of json docs changes in each compilation, we can't\n+\t# do that currently.\n+\t#\n+\t# See https://github.com/rust-lang/rust/issues/103785#issuecomment-1307425590 for details.\n+\n+\t# remove generated json doc\n+\trm $(OUTPUT_DIR)/foobar.json\n+\n+\t# Check if json doc compilation broke any of the html files generated previously\n+\t$(DIFF) -r -q $(OUTPUT_DIR) $(TMP_OUTPUT_DIR)"}, {"sha": "5df7576133a684ab8f887f442084e99062eb4886", "filename": "src/test/run-make/rustdoc-verify-output-files/src/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frun-make%2Frustdoc-verify-output-files%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frun-make%2Frustdoc-verify-output-files%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-verify-output-files%2Fsrc%2Flib.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1 @@\n+// nothing to see here"}, {"sha": "dea154c931935e95246ba1cb26e290fe45f83594", "filename": "src/test/rustdoc-gui/src/test_docs/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsrc%2Ftest_docs%2Flib.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -408,6 +408,11 @@ pub struct WithGenerics<T: TraitWithNoDocblocks, S = String, E = WhoLetTheDogOut\n     p: P,\n }\n \n+pub struct StructWithPublicUndocumentedFields {\n+    pub first: u32,\n+    pub second: u32,\n+}\n+\n pub const CONST: u8 = 0;\n \n pub trait TraitWithoutGenerics {"}, {"sha": "3ec60b58cfde82ffd8861e3a9014c759f7a6e5e5", "filename": "src/test/rustdoc-gui/struct-fields.goml", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frustdoc-gui%2Fstruct-fields.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Frustdoc-gui%2Fstruct-fields.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fstruct-fields.goml?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,5 @@\n+goto: \"file://\" + |DOC_PATH| + \"/test_docs/struct.StructWithPublicUndocumentedFields.html\"\n+\n+// Both fields must be on their own line. In other words, they have display: block.\n+store-property: (first_top, \"//*[@id='structfield.first']\", \"offsetTop\")\n+assert-property-false: (\"//*[@id='structfield.second']\", { \"offsetTop\": |first_top| })"}, {"sha": "f49476c44084cbd9e3f4a8aad3c4f384372140a4", "filename": "src/test/ui/parser/issue-104620.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Fparser%2Fissue-104620.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Fparser%2Fissue-104620.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-104620.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,4 @@\n+#![feature(rustc_attrs)]\n+\n+#![rustc_dummy=5z] //~ ERROR unexpected expression: `5z`\n+fn main() {}"}, {"sha": "d06a6b2554bb5b51c25391d2e9028fcc75019817", "filename": "src/test/ui/parser/issue-104620.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Fparser%2Fissue-104620.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Fparser%2Fissue-104620.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-104620.stderr?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,8 @@\n+error: unexpected expression: `5z`\n+  --> $DIR/issue-104620.rs:3:16\n+   |\n+LL | #![rustc_dummy=5z]\n+   |                ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5f01645da5242c5fd26b4ba510fe93bdb60fcf63", "filename": "src/test/ui/traits/predicate_can_apply-hang.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftraits%2Fpredicate_can_apply-hang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftraits%2Fpredicate_can_apply-hang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fpredicate_can_apply-hang.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,6 @@\n+fn f<B>(x: Vec<[[[B; 1]; 1]; 1]>) -> impl PartialEq<B> {\n+    //~^ ERROR can't compare `Vec<[[[B; 1]; 1]; 1]>` with `B`\n+    x\n+}\n+\n+fn main() {}"}, {"sha": "49fe63b412ac91b3ec165282a82e421abe8c30cb", "filename": "src/test/ui/traits/predicate_can_apply-hang.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftraits%2Fpredicate_can_apply-hang.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftraits%2Fpredicate_can_apply-hang.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fpredicate_can_apply-hang.stderr?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: can't compare `Vec<[[[B; 1]; 1]; 1]>` with `B`\n+  --> $DIR/predicate_can_apply-hang.rs:1:38\n+   |\n+LL | fn f<B>(x: Vec<[[[B; 1]; 1]; 1]>) -> impl PartialEq<B> {\n+   |                                      ^^^^^^^^^^^^^^^^^ no implementation for `Vec<[[[B; 1]; 1]; 1]> == B`\n+LL |\n+LL |     x\n+   |     - return type was inferred to be `Vec<[[[B; 1]; 1]; 1]>` here\n+   |\n+   = help: the trait `PartialEq<B>` is not implemented for `Vec<[[[B; 1]; 1]; 1]>`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n+             <Vec<T, A> as PartialEq<&[U; N]>>\n+             <Vec<T, A> as PartialEq<&[U]>>\n+             <Vec<T, A> as PartialEq<&mut [U]>>\n+             <Vec<T, A> as PartialEq<[U; N]>>\n+             <Vec<T, A> as PartialEq<[U]>>\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "a8330c9b65c312d232b09b08a2a6c0c5f29073fd", "filename": "src/test/ui/typeck/hang-in-overflow.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftypeck%2Fhang-in-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftypeck%2Fhang-in-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fhang-in-overflow.rs?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,19 @@\n+// normalize-stderr-test \"the requirement `.*`\" -> \"the requirement `...`\"\n+// normalize-stderr-test \"required for `.*` to implement `.*`\" -> \"required for `...` to implement `...`\"\n+// normalize-stderr-test: \".*the full type name has been written to.*\\n\" -> \"\"\n+\n+// Currently this fatally aborts instead of hanging.\n+// Make sure at least that this doesn't turn into a hang.\n+\n+fn f() {\n+    foo::<_>();\n+    //~^ ERROR overflow evaluating the requirement\n+}\n+\n+fn foo<B>()\n+where\n+    Vec<[[[B; 1]; 1]; 1]>: PartialEq<B>,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "7a7b85b19b4eee4acec356b30f56f7025dd6ba4c", "filename": "src/test/ui/typeck/hang-in-overflow.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftypeck%2Fhang-in-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d121aa3b5584eb919a4aaf64dbae0ea1e8e30231/src%2Ftest%2Fui%2Ftypeck%2Fhang-in-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fhang-in-overflow.stderr?ref=d121aa3b5584eb919a4aaf64dbae0ea1e8e30231", "patch": "@@ -0,0 +1,22 @@\n+error[E0275]: overflow evaluating the requirement `...`\n+  --> $DIR/hang-in-overflow.rs:9:5\n+   |\n+LL |     foo::<_>();\n+   |     ^^^^^^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`hang_in_overflow`)\n+   = note: required for `...` to implement `...`\n+   = note: 127 redundant requirements hidden\n+   = note: required for `...` to implement `...`\n+note: required by a bound in `foo`\n+  --> $DIR/hang-in-overflow.rs:15:28\n+   |\n+LL | fn foo<B>()\n+   |    --- required by a bound in this\n+LL | where\n+LL |     Vec<[[[B; 1]; 1]; 1]>: PartialEq<B>,\n+   |                            ^^^^^^^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0275`."}]}