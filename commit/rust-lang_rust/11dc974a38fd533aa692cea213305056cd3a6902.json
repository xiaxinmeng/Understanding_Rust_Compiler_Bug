{"sha": "11dc974a38fd533aa692cea213305056cd3a6902", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExZGM5NzRhMzhmZDUzM2FhNjkyY2VhMjEzMzA1MDU2Y2QzYTY5MDI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-20T18:56:01Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:47:10Z"}, "message": "refactor to use new snippet code and model\n\nMajor changes:\n- Remove old snippet rendering code and use the new stuff.\n- Introduce `span_label` method to add a label\n- Remove EndSpan mode and replace with a fn to get the last\n  character of a span.\n- Stop using `Option<MultiSpan>` and just use an empty `MultiSpan`\n- and probably a bunch of other stuff :)", "tree": {"sha": "2c0d355faea79ba7412e56e1017fd8f65acaf72c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c0d355faea79ba7412e56e1017fd8f65acaf72c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11dc974a38fd533aa692cea213305056cd3a6902", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11dc974a38fd533aa692cea213305056cd3a6902", "html_url": "https://github.com/rust-lang/rust/commit/11dc974a38fd533aa692cea213305056cd3a6902", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11dc974a38fd533aa692cea213305056cd3a6902/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca", "html_url": "https://github.com/rust-lang/rust/commit/5b150cf0ca2145c7d03a2b5ed92d9f65cc0ebcca"}], "stats": {"total": 1101, "additions": 357, "deletions": 744}, "files": [{"sha": "edb1c4530c240a979a8dd682d95a5ed7792de732", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -567,7 +567,7 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(None, msg, None, errors::Level::Fatal);\n+    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Fatal);\n     panic!(errors::FatalError);\n }\n \n@@ -578,7 +578,7 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n         }\n         config::ErrorOutputType::Json => Box::new(JsonEmitter::basic()),\n     };\n-    emitter.emit(None, msg, None, errors::Level::Warning);\n+    emitter.emit(&MultiSpan::new(), msg, None, errors::Level::Warning);\n }\n \n // Err(0) means compilation was stopped, but no errors were found."}, {"sha": "52306e388e23516d7cf6524e5c72b3dce198642e", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -91,8 +91,9 @@ use std::thread;\n \n use rustc::session::early_error;\n \n-use syntax::{ast, errors, diagnostics};\n-use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n+use syntax::{ast, errors, diagnostic};\n+use syntax::codemap::MultiSpan;\n+use syntax::parse::{self, PResult};\n use syntax::errors::emitter::Emitter;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult, token};\n@@ -136,7 +137,8 @@ pub fn run(args: Vec<String>) -> isize {\n                     None => {\n                         let mut emitter =\n                             errors::emitter::BasicEmitter::stderr(errors::ColorConfig::Auto);\n-                        emitter.emit(None, &abort_msg(err_count), None, errors::Level::Fatal);\n+                        emitter.emit(&MultiSpan::new(), &abort_msg(err_count), None,\n+                            errors::Level::Fatal);\n                         exit_on_err();\n                     }\n                 }\n@@ -379,7 +381,7 @@ fn check_cfg(sopts: &config::Options,\n         match item.node {\n             ast::MetaItemKind::List(ref pred, _) => {\n                 saw_invalid_predicate = true;\n-                emitter.emit(None,\n+                emitter.emit(&MultiSpan::new(),\n                              &format!(\"invalid predicate in --cfg command line argument: `{}`\",\n                                       pred),\n                              None,\n@@ -1028,19 +1030,19 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) {\n             // a .span_bug or .bug call has already printed what\n             // it wants to print.\n             if !value.is::<errors::ExplicitBug>() {\n-                emitter.emit(None, \"unexpected panic\", None, errors::Level::Bug);\n+                emitter.emit(&MultiSpan::new(), \"unexpected panic\", None, errors::Level::Bug);\n             }\n \n             let xs = [\"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n                       format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL)];\n             for note in &xs {\n-                emitter.emit(None, &note[..], None, errors::Level::Note)\n+                emitter.emit(&MultiSpan::new(), &note[..], None, errors::Level::Note)\n             }\n             if match env::var_os(\"RUST_BACKTRACE\") {\n                 Some(val) => &val != \"0\",\n                 None => false,\n             } {\n-                emitter.emit(None,\n+                emitter.emit(&MultiSpan::new(),\n                              \"run with `RUST_BACKTRACE=1` for a backtrace\",\n                              None,\n                              errors::Level::Note);"}, {"sha": "60f4ab1c95f2b03443fdb2fa5f865d109a71e539", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -86,10 +86,6 @@ impl Emitter for ExpectErrorEmitter {\n             lvl: Level) {\n         remove_message(self, msg, lvl);\n     }\n-\n-    fn custom_emit(&mut self, _sp: &RenderSpan, msg: &str, lvl: Level) {\n-        remove_message(self, msg, lvl);\n-    }\n }\n \n fn errors(msgs: &[&str]) -> (Box<Emitter + Send>, usize) {"}, {"sha": "50fd0392762534c228587b0b7cfc3eb47b07c050", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -19,7 +19,7 @@ use llvm::SMDiagnosticRef;\n use {CrateTranslation, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n-use syntax::codemap;\n+use syntax::codemap::{self, MultiSpan};\n use syntax::errors::{self, Handler, Level};\n use syntax::errors::emitter::Emitter;\n \n@@ -84,13 +84,13 @@ impl SharedEmitter {\n         for diag in &*buffer {\n             match diag.code {\n                 Some(ref code) => {\n-                    handler.emit_with_code(None,\n+                    handler.emit_with_code(&MultiSpan::new(),\n                                            &diag.msg,\n                                            &code[..],\n                                            diag.lvl);\n                 },\n                 None => {\n-                    handler.emit(None,\n+                    handler.emit(&MultiSpan::new(),\n                                  &diag.msg,\n                                  diag.lvl);\n                 },\n@@ -101,9 +101,12 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit(&mut self, sp: Option<&codemap::MultiSpan>,\n-            msg: &str, code: Option<&str>, lvl: Level) {\n-        assert!(sp.is_none(), \"SharedEmitter doesn't support spans\");\n+    fn emit(&mut self,\n+            sp: &codemap::MultiSpan,\n+            msg: &str,\n+            code: Option<&str>,\n+            lvl: Level) {\n+        assert!(sp.primary_span().is_none(), \"SharedEmitter doesn't support spans\");\n \n         self.buffer.lock().unwrap().push(Diagnostic {\n             msg: msg.to_string(),\n@@ -112,8 +115,8 @@ impl Emitter for SharedEmitter {\n         });\n     }\n \n-    fn custom_emit(&mut self, _sp: &errors::RenderSpan, _msg: &str, _lvl: Level) {\n-        bug!(\"SharedEmitter doesn't support custom_emit\");\n+    fn emit_struct(&mut self, _db: &errors::DiagnosticBuilder) {\n+        bug!(\"SharedEmitter doesn't support emit_struct\");\n     }\n }\n "}, {"sha": "5862538de2e043b291c1f6c80834a2fbfb517d6c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 13, "deletions": 74, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -163,6 +163,12 @@ pub const COMMAND_LINE_SP: Span = Span { lo: BytePos(0),\n                                          expn_id: COMMAND_LINE_EXPN };\n \n impl Span {\n+    /// Returns a new span representing just the end-point of this span\n+    pub fn end_point(self) -> Span {\n+        let lo = cmp::max(self.hi.0 - 1, self.lo.0);\n+        Span { lo: BytePos(lo), hi: self.hi, expn_id: self.expn_id}\n+    }\n+\n     /// Returns `self` if `self` is not the dummy span, and `other` otherwise.\n     pub fn substitute_dummy(self, other: Span) -> Span {\n         if self.source_equal(&DUMMY_SP) { other } else { self }\n@@ -794,7 +800,7 @@ impl CodeMap {\n     /// Creates a new filemap and sets its line information.\n     pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n         let fm = self.new_filemap(filename.to_string(), src.to_owned());\n-        let mut byte_pos: u32 = 0;\n+        let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n             // register the start of this line\n             fm.next_line(BytePos(byte_pos));\n@@ -1126,7 +1132,9 @@ impl CodeMap {\n         // numbers in Loc are 1-based, so we subtract 1 to get 0-based\n         // lines.\n         for line_index in lo.line-1 .. hi.line-1 {\n-            let line_len = lo.file.get_line(line_index).map(|s| s.len()).unwrap_or(0);\n+            let line_len = lo.file.get_line(line_index)\n+                                  .map(|s| s.chars().count())\n+                                  .unwrap_or(0);\n             lines.push(LineInfo { line_index: line_index,\n                                   start_col: start_col,\n                                   end_col: CharPos::from_usize(line_len) });\n@@ -1584,13 +1592,13 @@ mod tests {\n         assert_eq!(file_lines.lines[0].line_index, 1);\n     }\n \n-    /// Given a string like \" ^~~~~~~~~~~~ \", produces a span\n+    /// Given a string like \" ~~~~~~~~~~~~ \", produces a span\n     /// coverting that range. The idea is that the string has the same\n     /// length as the input, and we uncover the byte positions.  Note\n     /// that this can span lines and so on.\n     fn span_from_selection(input: &str, selection: &str) -> Span {\n         assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('^').unwrap() as u32;\n+        let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n     }\n@@ -1601,7 +1609,7 @@ mod tests {\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n         cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n@@ -1751,73 +1759,4 @@ r\"blork2.rs:2:1: 2:12\n \";\n         assert_eq!(sstr, res_str);\n     }\n-\n-    #[test]\n-    fn t13() {\n-        // Test that collecting multiple spans into line-groups works correctly\n-        let cm = CodeMap::new();\n-        let inp  =      \"_aaaaa__bbb\\nvv\\nw\\nx\\ny\\nz\\ncccccc__ddddee__\";\n-        let sp1  =      \" ^~~~~     \\n  \\n \\n \\n \\n \\n                \";\n-        let sp2  =      \"           \\n  \\n \\n \\n \\n^\\n                \";\n-        let sp3  =      \"        ^~~\\n~~\\n \\n \\n \\n \\n                \";\n-        let sp4  =      \"           \\n  \\n \\n \\n \\n \\n^~~~~~          \";\n-        let sp5  =      \"           \\n  \\n \\n \\n \\n \\n        ^~~~    \";\n-        let sp6  =      \"           \\n  \\n \\n \\n \\n \\n          ^~~~  \";\n-        let sp_trim =   \"           \\n  \\n \\n \\n \\n \\n            ^~  \";\n-        let sp_merge =  \"           \\n  \\n \\n \\n \\n \\n        ^~~~~~  \";\n-        let sp7  =      \"           \\n ^\\n \\n \\n \\n \\n                \";\n-        let sp8  =      \"           \\n  \\n^\\n \\n \\n \\n                \";\n-        let sp9  =      \"           \\n  \\n \\n^\\n \\n \\n                \";\n-        let sp10 =      \"           \\n  \\n \\n \\n^\\n \\n                \";\n-\n-        let span = |sp, expected| {\n-            let sp = span_from_selection(inp, sp);\n-            assert_eq!(&cm.span_to_snippet(sp).unwrap(), expected);\n-            sp\n-        };\n-\n-        cm.new_filemap_and_lines(\"blork.rs\", inp);\n-        let sp1 = span(sp1, \"aaaaa\");\n-        let sp2 = span(sp2, \"z\");\n-        let sp3 = span(sp3, \"bbb\\nvv\");\n-        let sp4 = span(sp4, \"cccccc\");\n-        let sp5 = span(sp5, \"dddd\");\n-        let sp6 = span(sp6, \"ddee\");\n-        let sp7 = span(sp7, \"v\");\n-        let sp8 = span(sp8, \"w\");\n-        let sp9 = span(sp9, \"x\");\n-        let sp10 = span(sp10, \"y\");\n-        let sp_trim = span(sp_trim, \"ee\");\n-        let sp_merge = span(sp_merge, \"ddddee\");\n-\n-        let spans = vec![sp5, sp2, sp4, sp9, sp10, sp7, sp3, sp8, sp1, sp6];\n-\n-        macro_rules! check_next {\n-            ($groups: expr, $expected: expr) => ({\n-                let actual = $groups.next().map(|g|&g.spans[..]);\n-                let expected = $expected;\n-                println!(\"actual:\\n{:?}\\n\", actual);\n-                println!(\"expected:\\n{:?}\\n\", expected);\n-                assert_eq!(actual, expected.as_ref().map(|x|&x[..]));\n-            });\n-        }\n-\n-        let _groups = cm.group_spans(spans.clone());\n-        let it = &mut _groups.iter();\n-\n-        check_next!(it, Some([sp1, sp7, sp8, sp9, sp10, sp2]));\n-        // New group because we're exceeding MAX_HIGHLIGHT_LINES\n-        check_next!(it, Some([sp4, sp_merge]));\n-        check_next!(it, Some([sp3]));\n-        check_next!(it, None::<[Span; 0]>);\n-\n-        let _groups = cm.end_group_spans(spans);\n-        let it = &mut _groups.iter();\n-\n-        check_next!(it, Some([sp1, sp7, sp8, sp9, sp10, sp2]));\n-        // New group because we're exceeding MAX_HIGHLIGHT_LINES\n-        check_next!(it, Some([sp4, sp5, sp_trim]));\n-        check_next!(it, Some([sp3]));\n-        check_next!(it, None::<[Span; 0]>);\n-    }\n }"}, {"sha": "e963a5f794cb67247d2609cb48e70bd3dd96eff4", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 235, "deletions": 561, "changes": 796, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -16,6 +16,7 @@ use diagnostics;\n use errors::{Level, RenderSpan, CodeSuggestion, DiagnosticBuilder};\n use errors::RenderSpan::*;\n use errors::Level::*;\n+use errors::snippet::{RenderedLineKind, SnippetData, Style};\n \n use std::{cmp, fmt};\n use std::io::prelude::*;\n@@ -24,27 +25,15 @@ use std::rc::Rc;\n use term;\n \n pub trait Emitter {\n-    fn emit(&mut self, span: Option<&MultiSpan>, msg: &str, code: Option<&str>, lvl: Level);\n-    fn custom_emit(&mut self, sp: &RenderSpan, msg: &str, lvl: Level);\n+    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, lvl: Level);\n \n     /// Emit a structured diagnostic.\n-    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n-        self.emit(db.span.as_ref(), &db.message, db.code.as_ref().map(|s| &**s), db.level);\n-        for child in &db.children {\n-            match child.render_span {\n-                Some(ref sp) => self.custom_emit(sp, &child.message, child.level),\n-                None => self.emit(child.span.as_ref(), &child.message, None, child.level),\n-            }\n-        }\n-    }\n+    fn emit_struct(&mut self, db: &DiagnosticBuilder);\n }\n \n /// maximum number of lines we will print for each error; arbitrary.\n pub const MAX_HIGHLIGHT_LINES: usize = 6;\n \n-/// maximum number of lines we will print for each span; arbitrary.\n-const MAX_SP_LINES: usize = 6;\n-\n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ColorConfig {\n     Auto,\n@@ -70,19 +59,23 @@ pub struct BasicEmitter {\n \n impl Emitter for BasicEmitter {\n     fn emit(&mut self,\n-            msp: Option<&MultiSpan>,\n+            msp: &MultiSpan,\n             msg: &str,\n             code: Option<&str>,\n             lvl: Level) {\n-        assert!(msp.is_none(), \"BasicEmitter can't handle spans\");\n+        assert!(msp.primary_span().is_none(), \"BasicEmitter can't handle spans\");\n+\n         if let Err(e) = print_diagnostic(&mut self.dst, \"\", lvl, msg, code) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n-\n     }\n \n-    fn custom_emit(&mut self, _: &RenderSpan, _: &str, _: Level) {\n-        panic!(\"BasicEmitter can't handle custom_emit\");\n+    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n+        self.emit(&db.span, &db.message, db.code.as_ref().map(|s| &**s), db.level);\n+        for child in &db.children {\n+            assert!(child.render_span.is_none(), \"BasicEmitter can't handle spans\");\n+            self.emit(&child.span, &child.message, None, child.level);\n+        }\n     }\n }\n \n@@ -101,33 +94,31 @@ pub struct EmitterWriter {\n     dst: Destination,\n     registry: Option<diagnostics::registry::Registry>,\n     cm: Rc<codemap::CodeMap>,\n+    first: bool,\n }\n \n impl Emitter for EmitterWriter {\n     fn emit(&mut self,\n-            msp: Option<&MultiSpan>,\n+            msp: &MultiSpan,\n             msg: &str,\n             code: Option<&str>,\n             lvl: Level) {\n-        let error = match msp.map(|s|(s.to_span_bounds(), s)) {\n-            Some((COMMAND_LINE_SP, msp)) => {\n-                self.emit_(&FileLine(msp.clone()), msg, code, lvl)\n-            },\n-            Some((DUMMY_SP, _)) | None => print_diagnostic(&mut self.dst, \"\", lvl, msg, code),\n-            Some((_, msp)) => self.emit_(&FullSpan(msp.clone()), msg, code, lvl),\n-        };\n-\n-        if let Err(e) = error {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n+        self.emit_multispan(msp, msg, code, lvl, true);\n     }\n \n-    fn custom_emit(&mut self,\n-                   rsp: &RenderSpan,\n-                   msg: &str,\n-                   lvl: Level) {\n-        if let Err(e) = self.emit_(rsp, msg, None, lvl) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n+    fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n+        self.emit_multispan(&db.span, &db.message,\n+            db.code.as_ref().map(|s| &**s), db.level, true);\n+\n+        for child in &db.children {\n+            match child.render_span {\n+                Some(ref sp) =>\n+                    self.emit_renderspan(sp, &child.message,\n+                        child.level),\n+                None =>\n+                    self.emit_multispan(&child.span,\n+                        &child.message, None, child.level, false),\n+            }\n         }\n     }\n }\n@@ -153,17 +144,60 @@ impl EmitterWriter {\n                   -> EmitterWriter {\n         if color_config.use_color() {\n             let dst = Destination::from_stderr();\n-            EmitterWriter { dst: dst, registry: registry, cm: code_map }\n+            EmitterWriter { dst: dst, registry: registry, cm: code_map, first: true }\n         } else {\n-            EmitterWriter { dst: Raw(Box::new(io::stderr())), registry: registry, cm: code_map }\n+            EmitterWriter { dst: Raw(Box::new(io::stderr())),\n+                registry: registry, cm: code_map, first: true }\n         }\n     }\n \n     pub fn new(dst: Box<Write + Send>,\n                registry: Option<diagnostics::registry::Registry>,\n                code_map: Rc<codemap::CodeMap>)\n                -> EmitterWriter {\n-        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map }\n+        EmitterWriter { dst: Raw(dst), registry: registry, cm: code_map, first: true }\n+    }\n+\n+    fn emit_multispan(&mut self,\n+                      span: &MultiSpan,\n+                      msg: &str,\n+                      code: Option<&str>,\n+                      lvl: Level,\n+                      is_header: bool) {\n+        if is_header {\n+            if self.first {\n+                self.first = false;\n+            } else {\n+                match write!(self.dst, \"\\n\") {\n+                    Ok(_) => { }\n+                    Err(e) => {\n+                        panic!(\"failed to print diagnostics: {:?}\", e)\n+                    }\n+                }\n+            }\n+        }\n+\n+        let error = match span.primary_span() {\n+            Some(COMMAND_LINE_SP) => {\n+                self.emit_(&FileLine(span.clone()), msg, code, lvl)\n+            }\n+            Some(DUMMY_SP) | None => {\n+                print_diagnostic(&mut self.dst, \"\", lvl, msg, code)\n+            }\n+            Some(_) => {\n+                self.emit_(&FullSpan(span.clone()), msg, code, lvl)\n+            }\n+        };\n+\n+        if let Err(e) = error {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n+        }\n+    }\n+\n+    fn emit_renderspan(&mut self, sp: &RenderSpan, msg: &str, lvl: Level) {\n+        if let Err(e) = self.emit_(sp, msg, None, lvl) {\n+            panic!(\"failed to print diagnostics: {:?}\", e);\n+        }\n     }\n \n     fn emit_(&mut self,\n@@ -173,51 +207,43 @@ impl EmitterWriter {\n              lvl: Level)\n              -> io::Result<()> {\n         let msp = rsp.span();\n-        let bounds = msp.to_span_bounds();\n-\n-        let ss = if bounds == COMMAND_LINE_SP {\n-            \"<command line option>\".to_string()\n-        } else if let EndSpan(_) = *rsp {\n-            let span_end = Span { lo: bounds.hi, hi: bounds.hi, expn_id: bounds.expn_id};\n-            self.cm.span_to_string(span_end)\n-        } else {\n-            self.cm.span_to_string(bounds)\n-        };\n-\n-        print_diagnostic(&mut self.dst, &ss[..], lvl, msg, code)?;\n+        let primary_span = msp.primary_span();\n+\n+        match code {\n+            Some(code) if self.registry.as_ref()\n+                          .and_then(|registry| registry.find_description(code)).is_some() =>\n+            {\n+                let code_with_explain = String::from(\"--explain \") + code;\n+                print_diagnostic(&mut self.dst, \"\", lvl, msg, Some(&code_with_explain))?\n+            }\n+            _ => print_diagnostic(&mut self.dst, \"\", lvl, msg, code)?\n+        }\n \n         match *rsp {\n             FullSpan(_) => {\n                 self.highlight_lines(msp, lvl)?;\n-                self.print_macro_backtrace(bounds)?;\n-            }\n-            EndSpan(_) => {\n-                self.end_highlight_lines(msp, lvl)?;\n-                self.print_macro_backtrace(bounds)?;\n+                if let Some(primary_span) = primary_span {\n+                    self.print_macro_backtrace(primary_span)?;\n+                }\n             }\n             Suggestion(ref suggestion) => {\n                 self.highlight_suggestion(suggestion)?;\n-                self.print_macro_backtrace(bounds)?;\n+                if let Some(primary_span) = primary_span {\n+                    self.print_macro_backtrace(primary_span)?;\n+                }\n             }\n             FileLine(..) => {\n                 // no source text in this case!\n             }\n         }\n \n-        if let Some(code) = code {\n-            if let Some(_) = self.registry.as_ref()\n-                                          .and_then(|registry| registry.find_description(code)) {\n-                print_diagnostic(&mut self.dst, &ss[..], Help,\n-                                 &format!(\"run `rustc --explain {}` to see a \\\n-                                           detailed explanation\", code), None)?;\n-            }\n-        }\n         Ok(())\n     }\n \n     fn highlight_suggestion(&mut self, suggestion: &CodeSuggestion) -> io::Result<()>\n     {\n-        let lines = self.cm.span_to_lines(suggestion.msp.to_span_bounds()).unwrap();\n+        let primary_span = suggestion.msp.primary_span().unwrap();\n+        let lines = self.cm.span_to_lines(primary_span).unwrap();\n         assert!(!lines.lines.is_empty());\n \n         let complete = suggestion.splice_lines(&self.cm);\n@@ -251,325 +277,21 @@ impl EmitterWriter {\n                        lvl: Level)\n                        -> io::Result<()>\n     {\n-        let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\")?;\n-                return Ok(());\n-            }\n-        };\n-\n-        let fm = &*lines.file;\n-        if let None = fm.src {\n-            return Ok(());\n-        }\n-\n-        let display_line_infos = &lines.lines[..];\n-        assert!(display_line_infos.len() > 0);\n-\n-        // Calculate the widest number to format evenly and fix #11715\n-        let digits = line_num_max_digits(display_line_infos.last().unwrap());\n-        let first_line_index = display_line_infos.first().unwrap().line_index;\n-\n-        let skip = fm.name.chars().count() + digits + 2;\n-\n-        let mut spans = msp.spans.iter().peekable();\n-        let mut lines = display_line_infos.iter();\n-        let mut prev_line_index = first_line_index.wrapping_sub(1);\n-\n-        // Display at most MAX_HIGHLIGHT_LINES lines.\n-        let mut remaining_err_lines = MAX_HIGHLIGHT_LINES;\n-\n-        // To emit a overflowed spans code-lines *AFTER* the rendered spans\n-        let mut overflowed_buf = String::new();\n-        let mut overflowed = false;\n-\n-        // FIXME (#8706)\n-        'l: loop {\n-            if remaining_err_lines <= 0 {\n-                break;\n-            }\n-            let line = match lines.next() {\n-                Some(l) => l,\n-                None => break,\n-            };\n-\n-            // Skip is the number of characters we need to skip because they are\n-            // part of the 'filename:line ' part of the code line.\n-            let mut s: String = ::std::iter::repeat(' ').take(skip).collect();\n-            let mut col = skip;\n-            let mut lastc = ' ';\n-\n-            let cur_line_str = fm.get_line(line.line_index).unwrap();\n-            let mut line_chars = cur_line_str.chars().enumerate().peekable();\n-            let mut line_spans = 0;\n-\n-            // Assemble spans for this line\n-            loop {\n-                // Peek here to preserve the span if it doesn't belong to this line\n-                let sp = match spans.peek() {\n-                    Some(sp) => **sp,\n-                    None => break,\n-                };\n-                let lo = self.cm.lookup_char_pos(sp.lo);\n-                let hi = self.cm.lookup_char_pos(sp.hi);\n-                let line_num = line.line_index + 1;\n-\n-                if !(lo.line <= line_num && hi.line >= line_num) {\n-                    // This line is not contained in the span\n-                    if overflowed {\n-                        // Never elide the final line of an overflowed span\n-                        prev_line_index = line.line_index - 1;\n-                        overflowed = false;\n-                        break;\n-                    }\n-\n-                    if line_spans == 0 {\n-                        continue 'l;\n-                    } else {\n-                        // This line is finished, now render the spans we've assembled\n-                        break;\n-                    }\n-                }\n-                spans.next();\n-                line_spans += 1;\n-\n-                if lo.line != hi.line {\n-                    // Assemble extra code lines to be emitted after this lines spans\n-                    // (substract `2` because the first and last line are rendered normally)\n-                    let max_lines = cmp::min(remaining_err_lines, MAX_SP_LINES) - 2;\n-                    prev_line_index = line.line_index;\n-                    let count = cmp::min((hi.line - lo.line - 1), max_lines);\n-                    for _ in 0..count {\n-                        let line = match lines.next() {\n-                            Some(l) => l,\n-                            None => break,\n-                        };\n-                        let line_str = fm.get_line(line.line_index).unwrap();\n-                        overflowed_buf.push_str(&format!(\"{}:{:>width$} {}\\n\",\n-                                                       fm.name,\n-                                                       line.line_index + 1,\n-                                                       line_str,\n-                                                       width=digits));\n-                        remaining_err_lines -= 1;\n-                        prev_line_index += 1\n-                    }\n-                    // Remember that the span overflowed to ensure\n-                    // that we emit its last line exactly once\n-                    // (other spans may, or may not, start on it)\n-                    overflowed = true;\n-                    break;\n-                }\n-\n-                for (pos, ch) in line_chars.by_ref() {\n-                    lastc = ch;\n-                    if pos >= lo.col.to_usize() { break; }\n-                    // Whenever a tab occurs on the code line, we insert one on\n-                    // the error-point-squiggly-line as well (instead of a space).\n-                    // That way the squiggly line will usually appear in the correct\n-                    // position.\n-                    match ch {\n-                        '\\t' => {\n-                            col += 8 - col%8;\n-                            s.push('\\t');\n-                        },\n-                        _ => {\n-                            col += 1;\n-                            s.push(' ');\n-                        },\n-                    }\n-                }\n-\n-                s.push('^');\n-                let col_ptr = col;\n-                let count = match lastc {\n-                    // Most terminals have a tab stop every eight columns by default\n-                    '\\t' => 8 - col%8,\n-                    _ => 1,\n-                };\n-                col += count;\n-                s.extend(::std::iter::repeat('~').take(count));\n-\n-                let hi = self.cm.lookup_char_pos(sp.hi);\n-                if hi.col != lo.col {\n-                    let mut chars = line_chars.by_ref();\n-                    loop {\n-                        // We peek here to preserve the value for the next span\n-                        let (pos, ch) = match chars.peek() {\n-                            Some(elem) => *elem,\n-                            None => break,\n-                        };\n-                        if pos >= hi.col.to_usize() { break; }\n-                        let count = match ch {\n-                            '\\t' => 8 - col%8,\n-                            _ => 1,\n-                        };\n-                        col += count;\n-                        s.extend(::std::iter::repeat('~').take(count));\n-\n-                        chars.next();\n-                    }\n-                }\n-                if (col - col_ptr) > 0 {\n-                    // One extra squiggly is replaced by a \"^\"\n-                    s.pop();\n-                }\n-            }\n-\n-            // If we elided something put an ellipsis.\n-            if prev_line_index != line.line_index.wrapping_sub(1) && !overflowed {\n-                write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n-            }\n-\n-            // Print offending code-line\n-            remaining_err_lines -= 1;\n-            write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n-                   fm.name,\n-                   line.line_index + 1,\n-                   cur_line_str,\n-                   width=digits)?;\n-\n-            if s.len() > skip {\n-                // Render the spans we assembled previously (if any).\n-                println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                      \"{}\", s)?;\n-            }\n-\n-            if !overflowed_buf.is_empty() {\n-                // Print code-lines trailing the rendered spans (when a span overflows)\n-                write!(&mut self.dst, \"{}\", &overflowed_buf)?;\n-                overflowed_buf.clear();\n-            } else {\n-                prev_line_index = line.line_index;\n-            }\n-        }\n-\n-        // If we elided something, put an ellipsis.\n-        if lines.next().is_some() {\n-            write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n-        }\n-        Ok(())\n-    }\n-\n-    /// Here are the differences between this and the normal `highlight_lines`:\n-    /// `end_highlight_lines` will always put arrow on the last byte of each\n-    /// span (instead of the first byte). Also, when a span is too long (more\n-    /// than 6 lines), `end_highlight_lines` will print the first line, then\n-    /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n-    /// six lines.\n-    #[allow(deprecated)]\n-    fn end_highlight_lines(&mut self,\n-                           msp: &MultiSpan,\n-                           lvl: Level)\n-                          -> io::Result<()> {\n-        let lines = match self.cm.span_to_lines(msp.to_span_bounds()) {\n-            Ok(lines) => lines,\n-            Err(_) => {\n-                write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\")?;\n-                return Ok(());\n-            }\n-        };\n-\n-        let fm = &*lines.file;\n-        if let None = fm.src {\n-            return Ok(());\n+        let mut snippet_data = SnippetData::new(self.cm.clone(),\n+                                                msp.primary_span());\n+        for span_label in msp.span_labels() {\n+            snippet_data.push(span_label.span,\n+                              span_label.is_primary,\n+                              span_label.label);\n         }\n-\n-        let lines = &lines.lines[..];\n-\n-        // Calculate the widest number to format evenly\n-        let first_line = lines.first().unwrap();\n-        let last_line = lines.last().unwrap();\n-        let digits = line_num_max_digits(last_line);\n-\n-        let skip = fm.name.chars().count() + digits + 2;\n-\n-        let mut spans = msp.spans.iter().peekable();\n-        let mut lines = lines.iter();\n-        let mut prev_line_index = first_line.line_index.wrapping_sub(1);\n-\n-        // Display at most MAX_HIGHLIGHT_LINES lines.\n-        let mut remaining_err_lines = MAX_HIGHLIGHT_LINES;\n-\n-        'l: loop {\n-            if remaining_err_lines <= 0 {\n-                break;\n-            }\n-            let line = match lines.next() {\n-                Some(line) => line,\n-                None => break,\n-            };\n-\n-            // Skip is the number of characters we need to skip because they are\n-            // part of the 'filename:line ' part of the previous line.\n-            let mut s: String = ::std::iter::repeat(' ').take(skip).collect();\n-\n-            let line_str = fm.get_line(line.line_index).unwrap();\n-            let mut line_chars = line_str.chars().enumerate();\n-            let mut line_spans = 0;\n-\n-            loop {\n-                // Peek here to preserve the span if it doesn't belong to this line\n-                let sp = match spans.peek() {\n-                    Some(sp) => **sp,\n-                    None => break,\n-                };\n-                let lo = self.cm.lookup_char_pos(sp.lo);\n-                let hi = self.cm.lookup_char_pos(sp.hi);\n-                let elide_sp = (hi.line - lo.line) >= MAX_SP_LINES;\n-\n-                let line_num = line.line_index + 1;\n-                if !(lo.line <= line_num && hi.line >= line_num) {\n-                    // This line is not contained in the span\n-                    if line_spans == 0 {\n-                        continue 'l;\n-                    } else {\n-                        // This line is finished, now render the spans we've assembled\n-                        break\n-                    }\n-                } else if hi.line > line_num {\n-                    if elide_sp && lo.line < line_num {\n-                        // This line is inbetween the first and last line of the span,\n-                        // so we may want to elide it.\n-                        continue 'l;\n-                    } else {\n-                        break\n-                    }\n-                }\n-                line_spans += 1;\n-                spans.next();\n-\n-                for (pos, ch) in line_chars.by_ref() {\n-                    // Span seems to use half-opened interval, so subtract 1\n-                    if pos >= hi.col.to_usize() - 1 { break; }\n-                    // Whenever a tab occurs on the previous line, we insert one on\n-                    // the error-point-squiggly-line as well (instead of a space).\n-                    // That way the squiggly line will usually appear in the correct\n-                    // position.\n-                    match ch {\n-                        '\\t' => s.push('\\t'),\n-                        _ => s.push(' '),\n-                    }\n-                }\n-                s.push('^');\n+        let rendered_lines = snippet_data.render_lines();\n+        for rendered_line in &rendered_lines {\n+            for styled_string in &rendered_line.text {\n+                self.dst.apply_style(lvl, &rendered_line.kind, styled_string.style)?;\n+                write!(&mut self.dst, \"{}\", styled_string.text)?;\n+                self.dst.reset_attrs()?;\n             }\n-\n-            if prev_line_index != line.line_index.wrapping_sub(1) {\n-                // If we elided something, put an ellipsis.\n-                write!(&mut self.dst, \"{0:1$}...\\n\", \"\", skip)?;\n-            }\n-\n-            // Print offending code-lines\n-            write!(&mut self.dst, \"{}:{:>width$} {}\\n\", fm.name,\n-                   line.line_index + 1, line_str, width=digits)?;\n-            remaining_err_lines -= 1;\n-\n-            if s.len() > skip {\n-                // Render the spans we assembled previously (if any)\n-                println_maybe_styled!(&mut self.dst, term::Attr::ForegroundColor(lvl.color()),\n-                                      \"{}\", s)?;\n-            }\n-            prev_line_index = line.line_index;\n+            write!(&mut self.dst, \"\\n\")?;\n         }\n         Ok(())\n     }\n@@ -602,24 +324,30 @@ fn line_num_max_digits(line: &codemap::LineInfo) -> usize {\n     digits\n }\n \n+\n fn print_diagnostic(dst: &mut Destination,\n                     topic: &str,\n                     lvl: Level,\n                     msg: &str,\n                     code: Option<&str>)\n                     -> io::Result<()> {\n     if !topic.is_empty() {\n-        write!(dst, \"{} \", topic)?;\n-    }\n-\n-    print_maybe_styled!(dst, term::Attr::ForegroundColor(lvl.color()),\n-                        \"{}: \", lvl.to_string())?;\n-    print_maybe_styled!(dst, term::Attr::Bold, \"{}\", msg)?;\n-\n+        dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+        write!(dst, \"{}: \", topic)?;\n+        dst.reset_attrs()?;\n+    }\n+    dst.start_attr(term::Attr::Bold)?;\n+    dst.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+    write!(dst, \"{}\", lvl.to_string())?;\n+    dst.reset_attrs()?;\n+    write!(dst, \": \")?;\n+    dst.start_attr(term::Attr::Bold)?;\n+    write!(dst, \"{}\", msg)?;\n     if let Some(code) = code {\n         let style = term::Attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n         print_maybe_styled!(dst, style, \" [{}]\", code.clone())?;\n     }\n+    dst.reset_attrs()?;\n     write!(dst, \"\\n\")?;\n     Ok(())\n }\n@@ -660,6 +388,52 @@ impl Destination {\n         }\n     }\n \n+    fn apply_style(&mut self,\n+                   lvl: Level,\n+                   _kind: &RenderedLineKind,\n+                   style: Style)\n+                   -> io::Result<()> {\n+        match style {\n+            Style::FileNameStyle => {\n+            }\n+            Style::LineAndColumn => {\n+            }\n+            Style::LineNumber => {\n+                self.start_attr(term::Attr::Bold)?;\n+                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            }\n+            Style::Quotation => {\n+            }\n+            Style::UnderlinePrimary | Style::LabelPrimary => {\n+                self.start_attr(term::Attr::Bold)?;\n+                self.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+            }\n+            Style::UnderlineSecondary | Style::LabelSecondary => {\n+                self.start_attr(term::Attr::Bold)?;\n+                self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+            }\n+            Style::NoStyle => {\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn start_attr(&mut self, attr: term::Attr) -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => { t.attr(attr)?; }\n+            Raw(_) => { }\n+        }\n+        Ok(())\n+    }\n+\n+    fn reset_attrs(&mut self) -> io::Result<()> {\n+        match *self {\n+            Terminal(ref mut t) => { t.reset()?; }\n+            Raw(_) => { }\n+        }\n+        Ok(())\n+    }\n+\n     fn print_maybe_styled(&mut self,\n                           args: fmt::Arguments,\n                           color: term::Attr,\n@@ -741,7 +515,7 @@ mod test {\n     /// that this can span lines and so on.\n     fn span_from_selection(input: &str, selection: &str) -> Span {\n         assert_eq!(input.len(), selection.len());\n-        let left_index = selection.find('^').unwrap() as u32;\n+        let left_index = selection.find('~').unwrap() as u32;\n         let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), expn_id: NO_EXPANSION }\n     }\n@@ -777,20 +551,23 @@ mod test {\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;\n         let str = from_utf8(vec).unwrap();\n-        println!(\"{}\", str);\n-        assert_eq!(str, \"dummy.txt: 8         line8\\n\\\n-                         dummy.txt: 9         line9\\n\\\n-                         dummy.txt:10         line10\\n\\\n-                         dummy.txt:11         e-l\u00e4-v\u00e4n\\n\\\n-                         dummy.txt:12         tolv\\n\");\n+        println!(\"r#\\\"\\n{}\\\"#\", str);\n+        assert_eq!(str, &r#\"\n+   --> dummy.txt:8:1\n+8   |>         line8\n+    |> ^^^^^^^^^^^^^\n+...\n+11  |>         e-l\u00e4-v\u00e4n\n+    |> ^^^^^^^^^^^^^^^^\n+\"#[1..]);\n     }\n \n     #[test]\n     fn test_single_span_splice() {\n         // Test that a `MultiSpan` containing a single span splices a substition correctly\n         let cm = CodeMap::new();\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n-        let selection = \"     \\n    ^~\\n~~~\\n~~~~~     \\n   \\n\";\n+        let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n         cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n         let sp = span_from_selection(inputtext, selection);\n         let msp: MultiSpan = sp.into();\n@@ -808,51 +585,25 @@ mod test {\n     }\n \n     #[test]\n-    fn test_multiple_span_splice() {\n-        // Test that a `MultiSpan` containing multiple spans splices substitions on\n-        // several lines correctly\n+    fn test_multi_span_splice() {\n+        // Test that a `MultiSpan` containing multiple spans splices a substition correctly\n         let cm = CodeMap::new();\n-        let inp = \"aaaaabbbbBB\\nZZ\\nZZ\\nCCCDDDDDdddddeee\";\n-        let sp1 = \"     ^~~~~~\\n  \\n  \\n                \";\n-        let sp2 = \"           \\n  \\n  \\n^~~~~~          \";\n-        let sp3 = \"           \\n  \\n  \\n        ^~~     \";\n-        let sp4 = \"           \\n  \\n  \\n           ^~~~ \";\n-\n-        let span_eq = |sp, eq| assert_eq!(&cm.span_to_snippet(sp).unwrap(), eq);\n-\n-        cm.new_filemap_and_lines(\"blork.rs\", inp);\n-        let sp1 = span_from_selection(inp, sp1);\n-        let sp2 = span_from_selection(inp, sp2);\n-        let sp3 = span_from_selection(inp, sp3);\n-        let sp4 = span_from_selection(inp, sp4);\n-        span_eq(sp1, \"bbbbBB\");\n-        span_eq(sp2, \"CCCDDD\");\n-        span_eq(sp3, \"ddd\");\n-        span_eq(sp4, \"ddee\");\n-\n-        let substitutes: Vec<String> = [\"1\", \"2\", \"3\", \"4\"].iter().map(|x|x.to_string()).collect();\n-        let expected = \"aaaaa1\\nZZ\\nZZ\\n2DD34e\";\n-\n-        let test = |msp| {\n-            let suggest = CodeSuggestion {\n-                msp: msp,\n-                substitutes: substitutes.clone(),\n-            };\n-            let actual = suggest.splice_lines(&cm);\n-            assert_eq!(actual, expected);\n+        let inputtext  = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n+        let selection1 = \"     \\n      \\n   \\n          \\n ~ \\n\"; // intentionally out of order\n+        let selection2 = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n+        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        let sp1 = span_from_selection(inputtext, selection1);\n+        let sp2 = span_from_selection(inputtext, selection2);\n+        let msp: MultiSpan = MultiSpan::from_spans(vec![sp1, sp2]);\n+\n+        let expected = \"bbbbZZZZZZddddd\\neXYZe\";\n+        let suggest = CodeSuggestion {\n+            msp: msp,\n+            substitutes: vec![\"ZZZZZZ\".to_owned(),\n+                              \"XYZ\".to_owned()]\n         };\n-        test(MultiSpan { spans: vec![sp1, sp2, sp3, sp4] });\n-\n-        // Test ordering and merging by `MultiSpan::push`\n-        let mut msp = MultiSpan::new();\n-        msp.push_merge(sp2);\n-        msp.push_merge(sp1);\n-        assert_eq!(&msp.spans, &[sp1, sp2]);\n-        msp.push_merge(sp4);\n-        assert_eq!(&msp.spans, &[sp1, sp2, sp4]);\n-        msp.push_merge(sp3);\n-        assert_eq!(&msp.spans, &[sp1, sp2, sp3, sp4]);\n-        test(msp);\n+\n+        assert_eq!(suggest.splice_lines(&cm), expected);\n     }\n \n     #[test]\n@@ -862,17 +613,17 @@ mod test {\n         let mut diag = EmitterWriter::new(Box::new(Sink(data.clone())), None, cm.clone());\n \n         let inp =       \"_____aaaaaa____bbbbbb__cccccdd_\";\n-        let sp1 =       \"     ^~~~~~                    \";\n-        let sp2 =       \"               ^~~~~~          \";\n-        let sp3 =       \"                       ^~~~~   \";\n-        let sp4 =       \"                          ^~~~ \";\n-        let sp34 =      \"                       ^~~~~~~ \";\n-        let sp4_end =   \"                            ^~ \";\n-\n-        let expect_start = \"dummy.txt:1 _____aaaaaa____bbbbbb__cccccdd_\\n\\\n-                         \\x20                ^~~~~~    ^~~~~~  ^~~~~~~\\n\";\n-        let expect_end =   \"dummy.txt:1 _____aaaaaa____bbbbbb__cccccdd_\\n\\\n-                         \\x20                     ^         ^      ^ ^\\n\";\n+        let sp1 =       \"     ~~~~~~                    \";\n+        let sp2 =       \"               ~~~~~~          \";\n+        let sp3 =       \"                       ~~~~~   \";\n+        let sp4 =       \"                          ~~~~ \";\n+        let sp34 =      \"                       ~~~~~~~ \";\n+\n+        let expect_start = &r#\"\n+ --> dummy.txt:1:6\n+1 |> _____aaaaaa____bbbbbb__cccccdd_\n+  |>      ^^^^^^    ^^^^^^  ^^^^^^^\n+\"#[1..];\n \n         let span = |sp, expected| {\n             let sp = span_from_selection(inp, sp);\n@@ -885,7 +636,6 @@ mod test {\n         let sp3 = span(sp3, \"ccccc\");\n         let sp4 = span(sp4, \"ccdd\");\n         let sp34 = span(sp34, \"cccccdd\");\n-        let sp4_end = span(sp4_end, \"dd\");\n \n         let spans = vec![sp1, sp2, sp3, sp4];\n \n@@ -894,26 +644,17 @@ mod test {\n             highlight();\n             let vec = data.lock().unwrap().clone();\n             let actual = from_utf8(&vec[..]).unwrap();\n+            println!(\"actual=\\n{}\", actual);\n             assert_eq!(actual, expected);\n         };\n \n-        let msp = MultiSpan { spans: vec![sp1, sp2, sp34] };\n-        let msp_end = MultiSpan { spans: vec![sp1, sp2, sp3, sp4_end] };\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp34]);\n         test(expect_start, &mut || {\n             diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n-        test(expect_end, &mut || {\n-            diag.end_highlight_lines(&msp_end, Level::Error).unwrap();\n-        });\n         test(expect_start, &mut || {\n-            for msp in cm.group_spans(spans.clone()) {\n-                diag.highlight_lines(&msp, Level::Error).unwrap();\n-            }\n-        });\n-        test(expect_end, &mut || {\n-            for msp in cm.end_group_spans(spans.clone()) {\n-                diag.end_highlight_lines(&msp, Level::Error).unwrap();\n-            }\n+            let msp = MultiSpan::from_spans(spans.clone());\n+            diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n     }\n \n@@ -950,75 +691,31 @@ mod test {\n         let sp4 = span(10, 10, (2, 3));\n         let sp5 = span(10, 10, (4, 6));\n \n-        let expect0 = \"dummy.txt: 5 ccccc\\n\\\n-                       dummy.txt: 6 xxxxx\\n\\\n-                       dummy.txt: 7 yyyyy\\n\\\n-                    \\x20            ...\\n\\\n-                       dummy.txt: 9 ddd__eee_\\n\\\n-                    \\x20            ^~~  ^~~\\n\\\n-                    \\x20            ...\\n\\\n-                       dummy.txt:11 __f_gg\\n\\\n-                    \\x20              ^ ^~\\n\";\n-\n-        let expect = \"dummy.txt: 1 aaaaa\\n\\\n-                      dummy.txt: 2 aaaaa\\n\\\n-                      dummy.txt: 3 aaaaa\\n\\\n-                      dummy.txt: 4 bbbbb\\n\\\n-                      dummy.txt: 5 ccccc\\n\\\n-                      dummy.txt: 6 xxxxx\\n\\\n-                   \\x20            ...\\n\";\n-\n-        let expect_g1 = \"dummy.txt:1 aaaaa\\n\\\n-                         dummy.txt:2 aaaaa\\n\\\n-                         dummy.txt:3 aaaaa\\n\\\n-                         dummy.txt:4 bbbbb\\n\\\n-                         dummy.txt:5 ccccc\\n\\\n-                         dummy.txt:6 xxxxx\\n\\\n-                      \\x20           ...\\n\";\n-\n-        let expect2 = \"dummy.txt: 9 ddd__eee_\\n\\\n-                    \\x20            ^~~  ^~~\\n\\\n-                    \\x20            ...\\n\\\n-                       dummy.txt:11 __f_gg\\n\\\n-                    \\x20              ^ ^~\\n\";\n-\n-\n-        let expect_end = \"dummy.txt: 1 aaaaa\\n\\\n-                       \\x20            ...\\n\\\n-                          dummy.txt: 7 yyyyy\\n\\\n-                       \\x20                ^\\n\\\n-                       \\x20            ...\\n\\\n-                          dummy.txt: 9 ddd__eee_\\n\\\n-                       \\x20              ^    ^\\n\\\n-                       \\x20            ...\\n\\\n-                          dummy.txt:11 __f_gg\\n\\\n-                       \\x20              ^  ^\\n\";\n-\n-        let expect0_end = \"dummy.txt: 5 ccccc\\n\\\n-                           dummy.txt: 6 xxxxx\\n\\\n-                           dummy.txt: 7 yyyyy\\n\\\n-                        \\x20                ^\\n\\\n-                        \\x20            ...\\n\\\n-                           dummy.txt: 9 ddd__eee_\\n\\\n-                        \\x20              ^    ^\\n\\\n-                        \\x20            ...\\n\\\n-                           dummy.txt:11 __f_gg\\n\\\n-                        \\x20              ^  ^\\n\";\n-\n-        let expect_end_g1 = \"dummy.txt:1 aaaaa\\n\\\n-                          \\x20           ...\\n\\\n-                             dummy.txt:7 yyyyy\\n\\\n-                          \\x20               ^\\n\";\n-\n-        let expect2_end = \"dummy.txt: 9 ddd__eee_\\n\\\n-                        \\x20              ^    ^\\n\\\n-                        \\x20            ...\\n\\\n-                           dummy.txt:11 __f_gg\\n\\\n-                        \\x20              ^  ^\\n\";\n-\n-        let expect_groups = [expect2, expect_g1];\n-        let expect_end_groups = [expect2_end, expect_end_g1];\n-        let spans = vec![sp3, sp1, sp4, sp2, sp5];\n+        let expect0 = &r#\"\n+   --> dummy.txt:5:1\n+5   |> ccccc\n+    |> ^^^^^\n+...\n+8   |> _____\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n+\n+        let expect = &r#\"\n+   --> dummy.txt:1:1\n+1   |> aaaaa\n+    |> ^^^^^\n+...\n+8   |> _____\n+9   |> ddd__eee_\n+    |> ^^^  ^^^\n+10  |> elided\n+11  |> __f_gg\n+    |>   ^ ^^\n+\"#[1..];\n \n         macro_rules! test {\n             ($expected: expr, $highlight: expr) => ({\n@@ -1034,37 +731,14 @@ mod test {\n             });\n         }\n \n-        let msp0 = MultiSpan { spans: vec![sp0, sp2, sp3, sp4, sp5] };\n-        let msp = MultiSpan { spans: vec![sp1, sp2, sp3, sp4, sp5] };\n-        let msp2 = MultiSpan { spans: vec![sp2, sp3, sp4, sp5] };\n+        let msp0 = MultiSpan::from_spans(vec![sp0, sp2, sp3, sp4, sp5]);\n+        let msp = MultiSpan::from_spans(vec![sp1, sp2, sp3, sp4, sp5]);\n \n         test!(expect0, || {\n             diag.highlight_lines(&msp0, Level::Error).unwrap();\n         });\n-        test!(expect0_end, || {\n-            diag.end_highlight_lines(&msp0, Level::Error).unwrap();\n-        });\n         test!(expect, || {\n             diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n-        test!(expect_end, || {\n-            diag.end_highlight_lines(&msp, Level::Error).unwrap();\n-        });\n-        test!(expect2, || {\n-            diag.highlight_lines(&msp2, Level::Error).unwrap();\n-        });\n-        test!(expect2_end, || {\n-            diag.end_highlight_lines(&msp2, Level::Error).unwrap();\n-        });\n-        for (msp, expect) in cm.group_spans(spans.clone()).iter().zip(expect_groups.iter()) {\n-            test!(expect, || {\n-                diag.highlight_lines(&msp, Level::Error).unwrap();\n-            });\n-        }\n-        for (msp, expect) in cm.group_spans(spans.clone()).iter().zip(expect_end_groups.iter()) {\n-            test!(expect, || {\n-                diag.end_highlight_lines(&msp, Level::Error).unwrap();\n-            });\n-        }\n     }\n }"}, {"sha": "abbc4eef7bf81d3a7069223750e3cbbb4de22140", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 87, "deletions": 88, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11dc974a38fd533aa692cea213305056cd3a6902/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=11dc974a38fd533aa692cea213305056cd3a6902", "patch": "@@ -13,7 +13,7 @@ pub use errors::emitter::ColorConfig;\n use self::Level::*;\n use self::RenderSpan::*;\n \n-use codemap::{self, CodeMap, MultiSpan};\n+use codemap::{self, CodeMap, MultiSpan, NO_EXPANSION, Span};\n use diagnostics;\n use errors::emitter::{Emitter, EmitterWriter};\n \n@@ -24,6 +24,7 @@ use term;\n \n pub mod emitter;\n pub mod json;\n+pub mod snippet;\n \n #[derive(Clone)]\n pub enum RenderSpan {\n@@ -32,13 +33,6 @@ pub enum RenderSpan {\n     /// the source code covered by the span.\n     FullSpan(MultiSpan),\n \n-    /// Similar to a FullSpan, but the cited position is the end of\n-    /// the span, instead of the start. Used, at least, for telling\n-    /// compiletest/runtest to look at the last line of the span\n-    /// (since `end_highlight_lines` displays an arrow to the end\n-    /// of the span).\n-    EndSpan(MultiSpan),\n-\n     /// A suggestion renders with both with an initial line for the\n     /// message, prefixed by file:linenum, followed by a summary\n     /// of hypothetical source code, where each `String` is spliced\n@@ -61,7 +55,6 @@ impl RenderSpan {\n         match *self {\n             FullSpan(ref msp) |\n             Suggestion(CodeSuggestion { ref msp, .. }) |\n-            EndSpan(ref msp) |\n             FileLine(ref msp) =>\n                 msp\n         }\n@@ -88,12 +81,24 @@ impl CodeSuggestion {\n                 }\n             }\n         }\n-        let bounds = self.msp.to_span_bounds();\n-        let lines = cm.span_to_lines(bounds).unwrap();\n-        assert!(!lines.lines.is_empty());\n \n-        // This isn't strictly necessary, but would in all likelyhood be an error\n-        assert_eq!(self.msp.spans.len(), self.substitutes.len());\n+        let mut primary_spans = self.msp.primary_spans().to_owned();\n+\n+        assert_eq!(primary_spans.len(), self.substitutes.len());\n+        if primary_spans.is_empty() {\n+            return format!(\"\");\n+        }\n+\n+        // Assumption: all spans are in the same file, and all spans\n+        // are disjoint. Sort in ascending order.\n+        primary_spans.sort_by_key(|sp| sp.lo);\n+\n+        // Find the bounding span.\n+        let lo = primary_spans.iter().map(|sp| sp.lo).min().unwrap();\n+        let hi = primary_spans.iter().map(|sp| sp.hi).min().unwrap();\n+        let bounding_span = Span { lo: lo, hi: hi, expn_id: NO_EXPANSION };\n+        let lines = cm.span_to_lines(bounding_span).unwrap();\n+        assert!(!lines.lines.is_empty());\n \n         // To build up the result, we do this for each span:\n         // - push the line segment trailing the previous span\n@@ -105,13 +110,13 @@ impl CodeSuggestion {\n         //\n         // Finally push the trailing line segment of the last span\n         let fm = &lines.file;\n-        let mut prev_hi = cm.lookup_char_pos(bounds.lo);\n+        let mut prev_hi = cm.lookup_char_pos(bounding_span.lo);\n         prev_hi.col = CharPos::from_usize(0);\n \n         let mut prev_line = fm.get_line(lines.lines[0].line_index);\n         let mut buf = String::new();\n \n-        for (sp, substitute) in self.msp.spans.iter().zip(self.substitutes.iter()) {\n+        for (sp, substitute) in primary_spans.iter().zip(self.substitutes.iter()) {\n             let cur_lo = cm.lookup_char_pos(sp.lo);\n             if prev_hi.line == cur_lo.line {\n                 push_trailing(&mut buf, prev_line, &prev_hi, Some(&cur_lo));\n@@ -183,7 +188,7 @@ pub struct DiagnosticBuilder<'a> {\n     level: Level,\n     message: String,\n     code: Option<String>,\n-    span: Option<MultiSpan>,\n+    span: MultiSpan,\n     children: Vec<SubDiagnostic>,\n }\n \n@@ -192,7 +197,7 @@ pub struct DiagnosticBuilder<'a> {\n struct SubDiagnostic {\n     level: Level,\n     message: String,\n-    span: Option<MultiSpan>,\n+    span: MultiSpan,\n     render_span: Option<RenderSpan>,\n }\n \n@@ -228,37 +233,61 @@ impl<'a> DiagnosticBuilder<'a> {\n         self.level == Level::Fatal\n     }\n \n-    pub fn note(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, None, None);\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    pub fn span_label(mut self, span: Span, label: &fmt::Display)\n+                      -> DiagnosticBuilder<'a> {\n+        self.span.push_span_label(span, format!(\"{}\", label));\n+        self\n+    }\n+\n+    pub fn note_expected_found(mut self,\n+                               label: &fmt::Display,\n+                               expected: &fmt::Display,\n+                               found: &fmt::Display)\n+                               -> DiagnosticBuilder<'a>\n+    {\n+        // For now, just attach these as notes\n+        self.note(&format!(\"expected {} `{}`\", label, expected));\n+        self.note(&format!(\"   found {} `{}`\", label, found));\n+        self\n+    }\n+\n+    pub fn note(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n+        self.sub(Level::Note, msg, MultiSpan::new(), None);\n         self\n     }\n     pub fn span_note<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n                                          -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, Some(sp.into()), None);\n+        self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n     pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, None, None);\n+        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n                                          -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, Some(sp.into()), None);\n+        self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n     pub fn help(&mut self , msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, None, None);\n+        self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n     pub fn span_help<S: Into<MultiSpan>>(&mut self,\n                                          sp: S,\n                                          msg: &str)\n                                          -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, Some(sp.into()), None);\n+        self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n     /// Prints out a message with a suggested edit of the code.\n@@ -269,43 +298,15 @@ impl<'a> DiagnosticBuilder<'a> {\n                                                msg: &str,\n                                                suggestion: String)\n                                                -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, None, Some(Suggestion(CodeSuggestion {\n+        self.sub(Level::Help, msg, MultiSpan::new(), Some(Suggestion(CodeSuggestion {\n             msp: sp.into(),\n             substitutes: vec![suggestion],\n         })));\n         self\n     }\n-    pub fn span_end_note<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, None, Some(EndSpan(sp.into())));\n-        self\n-    }\n-    pub fn fileline_warn<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, None, Some(FileLine(sp.into())));\n-        self\n-    }\n-    pub fn fileline_note<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, None, Some(FileLine(sp.into())));\n-        self\n-    }\n-    pub fn fileline_help<S: Into<MultiSpan>>(&mut self,\n-                                             sp: S,\n-                                             msg: &str)\n-                                             -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, None, Some(FileLine(sp.into())));\n-        self\n-    }\n \n-    pub fn span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n-        self.span = Some(sp.into());\n+    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n+        self.span = sp.into();\n         self\n     }\n \n@@ -324,7 +325,7 @@ impl<'a> DiagnosticBuilder<'a> {\n             level: level,\n             message: message.to_owned(),\n             code: None,\n-            span: None,\n+            span: MultiSpan::new(),\n             children: vec![],\n         }\n     }\n@@ -334,7 +335,7 @@ impl<'a> DiagnosticBuilder<'a> {\n     fn sub(&mut self,\n            level: Level,\n            message: &str,\n-           span: Option<MultiSpan>,\n+           span: MultiSpan,\n            render_span: Option<RenderSpan>) {\n         let sub = SubDiagnostic {\n             level: level,\n@@ -357,7 +358,10 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n         if !self.cancelled() {\n-            self.emitter.borrow_mut().emit(None, \"Error constructed but not emitted\", None, Bug);\n+            self.emitter.borrow_mut().emit(&MultiSpan::new(),\n+                                           \"Error constructed but not emitted\",\n+                                           None,\n+                                           Bug);\n             panic!();\n         }\n     }\n@@ -412,7 +416,7 @@ impl Handler {\n                                                     msg: &str)\n                                                     -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n@@ -424,7 +428,7 @@ impl Handler {\n                                                               code: &str)\n                                                               -> DiagnosticBuilder<'a> {\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result.code(code.to_owned());\n         if !self.can_emit_warnings {\n             result.cancel();\n@@ -444,7 +448,7 @@ impl Handler {\n                                                    -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result\n     }\n     pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n@@ -454,7 +458,7 @@ impl Handler {\n                                                              -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n@@ -468,7 +472,7 @@ impl Handler {\n                                                      -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result\n     }\n     pub fn struct_span_fatal_with_code<'a, S: Into<MultiSpan>>(&'a self,\n@@ -478,7 +482,7 @@ impl Handler {\n                                                                -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n         let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n-        result.span(sp);\n+        result.set_span(sp);\n         result.code(code.to_owned());\n         result\n     }\n@@ -499,7 +503,7 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit(Some(&sp.into()), msg, Fatal);\n+        self.emit(&sp.into(), msg, Fatal);\n         self.bump_err_count();\n         return FatalError;\n     }\n@@ -508,44 +512,44 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit_with_code(Some(&sp.into()), msg, code, Fatal);\n+        self.emit_with_code(&sp.into(), msg, code, Fatal);\n         self.bump_err_count();\n         return FatalError;\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit(Some(&sp.into()), msg, Error);\n+        self.emit(&sp.into(), msg, Error);\n         self.bump_err_count();\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         if self.treat_err_as_bug {\n             self.span_bug(sp, msg);\n         }\n-        self.emit_with_code(Some(&sp.into()), msg, code, Error);\n+        self.emit_with_code(&sp.into(), msg, code, Error);\n         self.bump_err_count();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(Some(&sp.into()), msg, Warning);\n+        self.emit(&sp.into(), msg, Warning);\n     }\n     pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n-        self.emit_with_code(Some(&sp.into()), msg, code, Warning);\n+        self.emit_with_code(&sp.into(), msg, code, Warning);\n     }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.emit(Some(&sp.into()), msg, Bug);\n+        self.emit(&sp.into(), msg, Bug);\n         panic!(ExplicitBug);\n     }\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         let mut delayed = self.delayed_span_bug.borrow_mut();\n         *delayed = Some((sp.into(), msg.to_string()));\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(Some(&sp.into()), msg, Bug);\n+        self.emit(&sp.into(), msg, Bug);\n         self.bump_err_count();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit.borrow_mut().emit(Some(&sp.into()), msg, None, Note);\n+        self.emit.borrow_mut().emit(&sp.into(), msg, None, Note);\n     }\n     pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n@@ -554,25 +558,25 @@ impl Handler {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(None, msg, None, Fatal);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Fatal);\n         self.bump_err_count();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n         if self.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        self.emit.borrow_mut().emit(None, msg, None, Error);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Error);\n         self.bump_err_count();\n     }\n     pub fn warn(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Warning);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Warning);\n     }\n     pub fn note_without_error(&self, msg: &str) {\n-        self.emit.borrow_mut().emit(None, msg, None, Note);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Note);\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        self.emit.borrow_mut().emit(None, msg, None, Bug);\n+        self.emit.borrow_mut().emit(&MultiSpan::new(), msg, None, Bug);\n         panic!(ExplicitBug);\n     }\n     pub fn unimpl(&self, msg: &str) -> ! {\n@@ -614,25 +618,20 @@ impl Handler {\n         panic!(self.fatal(&s));\n     }\n     pub fn emit(&self,\n-                msp: Option<&MultiSpan>,\n+                msp: &MultiSpan,\n                 msg: &str,\n                 lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(msp, msg, None, lvl);\n+        self.emit.borrow_mut().emit(&msp, msg, None, lvl);\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n     pub fn emit_with_code(&self,\n-                          msp: Option<&MultiSpan>,\n+                          msp: &MultiSpan,\n                           msg: &str,\n                           code: &str,\n                           lvl: Level) {\n         if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().emit(msp, msg, Some(code), lvl);\n-        if !self.continue_after_error.get() { self.abort_if_errors(); }\n-    }\n-    pub fn custom_emit(&self, rsp: RenderSpan, msg: &str, lvl: Level) {\n-        if lvl == Warning && !self.can_emit_warnings { return }\n-        self.emit.borrow_mut().custom_emit(&rsp, msg, lvl);\n+        self.emit.borrow_mut().emit(&msp, msg, Some(code), lvl);\n         if !self.continue_after_error.get() { self.abort_if_errors(); }\n     }\n }"}]}