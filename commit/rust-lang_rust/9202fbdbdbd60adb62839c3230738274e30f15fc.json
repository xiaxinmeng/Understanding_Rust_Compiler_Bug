{"sha": "9202fbdbdbd60adb62839c3230738274e30f15fc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMDJmYmRiZGJkNjBhZGI2MjgzOWMzMjMwNzM4Mjc0ZTMwZjE1ZmM=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-10-21T00:18:08Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-10-21T00:18:08Z"}, "message": "Check for exhaustion in SliceIndex for RangeInclusive", "tree": {"sha": "6d3e5083973900ea887238e6b3e7ec6ebcc249ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d3e5083973900ea887238e6b3e7ec6ebcc249ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9202fbdbdbd60adb62839c3230738274e30f15fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9202fbdbdbd60adb62839c3230738274e30f15fc", "html_url": "https://github.com/rust-lang/rust/commit/9202fbdbdbd60adb62839c3230738274e30f15fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9202fbdbdbd60adb62839c3230738274e30f15fc/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fd79a39044be777a39604856d0a276484d6480f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd79a39044be777a39604856d0a276484d6480f", "html_url": "https://github.com/rust-lang/rust/commit/9fd79a39044be777a39604856d0a276484d6480f"}], "stats": {"total": 105, "additions": 85, "deletions": 20}, "files": [{"sha": "834dd4656ff76bdb171ef96c3329af15e6ff1e31", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=9202fbdbdbd60adb62839c3230738274e30f15fc", "patch": "@@ -529,6 +529,13 @@ mod slice_index {\n             message: \"out of bounds\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: \"abcdef\";\n+            good: data[0..=5] == \"abcdef\";\n+            bad: data[0..=6];\n+            message: \"out of bounds\";\n+        }\n+\n         in mod range_len_len {\n             data: \"abcdef\";\n             good: data[6..6] == \"\";\n@@ -544,6 +551,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: \"abcdef\";\n+\n+            good: data[0..=5] == \"abcdef\";\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == \"\";\n+\n+            // 0..=6 is out of bounds before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of bounds\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: \"abcdef\";"}, {"sha": "1d67e65e51f5f16effad651f589cd99b13a2163b", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=9202fbdbdbd60adb62839c3230738274e30f15fc", "patch": "@@ -446,6 +446,20 @@ impl<Idx> RangeInclusive<Idx> {\n     }\n }\n \n+impl RangeInclusive<usize> {\n+    /// Converts to an exclusive `Range` for `SliceIndex` implementations.\n+    /// The caller is responsible for dealing with `end == usize::MAX`.\n+    #[inline]\n+    pub(crate) fn into_slice_range(self) -> Range<usize> {\n+        // If we're not exhausted, we want to simply slice `start..end + 1`.\n+        // If we are exhausted, then slicing with `end + 1..end + 1` gives us an\n+        // empty range that is still subject to bounds-checks for that endpoint.\n+        let exclusive_end = self.end + 1;\n+        let start = if self.exhausted { exclusive_end } else { self.start };\n+        start..exclusive_end\n+    }\n+}\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "660c8a2da5da04ac3a8006d05ea6bd830e80cd93", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=9202fbdbdbd60adb62839c3230738274e30f15fc", "patch": "@@ -376,44 +376,40 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "f3635414311008d7ef52c3c94841296140ef04ce", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=9202fbdbdbd60adb62839c3230738274e30f15fc", "patch": "@@ -398,39 +398,35 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "9ccc5a08dcbeab1e254f54f9a90fcbadb8bb786d", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9202fbdbdbd60adb62839c3230738274e30f15fc/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=9202fbdbdbd60adb62839c3230738274e30f15fc", "patch": "@@ -1341,6 +1341,14 @@ mod slice_index {\n             message: \"out of range\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[0..=6];\n+            message: \"out of range\";\n+        }\n+\n         in mod range_len_len {\n             data: [0, 1, 2, 3, 4, 5];\n \n@@ -1358,6 +1366,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == [];\n+\n+            // 0..=6 is out of range before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of range\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: [0, 1, 2, 3, 4, 5];"}]}