{"sha": "bbc4dc995612916a4c0a99396b5259a5fb1dda80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYzRkYzk5NTYxMjkxNmE0YzBhOTkzOTZiNTI1OWE1ZmIxZGRhODA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-29T15:22:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-29T15:23:01Z"}, "message": "Update the rest of the tests", "tree": {"sha": "fac101a18e111a2a05bce14fbb68981c5bef3bfd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fac101a18e111a2a05bce14fbb68981c5bef3bfd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbc4dc995612916a4c0a99396b5259a5fb1dda80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc4dc995612916a4c0a99396b5259a5fb1dda80", "html_url": "https://github.com/rust-lang/rust/commit/bbc4dc995612916a4c0a99396b5259a5fb1dda80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbc4dc995612916a4c0a99396b5259a5fb1dda80/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e805e8c1d5bf26e9716fb855f97d950395129c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/e805e8c1d5bf26e9716fb855f97d950395129c20", "html_url": "https://github.com/rust-lang/rust/commit/e805e8c1d5bf26e9716fb855f97d950395129c20"}], "stats": {"total": 757, "additions": 311, "deletions": 446}, "files": [{"sha": "5424e6bb19f204aa61bc562d0f7b175c0d60bca8", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -17,11 +17,11 @@ use hir_def::{\n     item_scope::ItemScope,\n     keys,\n     nameres::CrateDefMap,\n-    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n+    AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n use insta::assert_snapshot;\n-use ra_db::{fixture::WithFixture, salsa::Database, FilePosition, SourceDatabase};\n+use ra_db::{fixture::WithFixture, salsa::Database, FileRange, SourceDatabase};\n use ra_syntax::{\n     algo,\n     ast::{self, AstNode},\n@@ -39,35 +39,37 @@ use crate::{\n // update the snapshots.\n \n fn check_types(ra_fixture: &str) {\n+    check_types_impl(ra_fixture, false)\n+}\n+\n+fn check_types_source_code(ra_fixture: &str) {\n+    check_types_impl(ra_fixture, true)\n+}\n+\n+fn check_types_impl(ra_fixture: &str, display_source: bool) {\n     let db = TestDB::with_files(ra_fixture);\n     let mut checked_one = false;\n     for file_id in db.all_files() {\n         let text = db.parse(file_id).syntax_node().to_string();\n         let annotations = extract_annotations(&text);\n-        for (offset, expected) in annotations {\n-            let actual = type_at_pos(&db, FilePosition { file_id, offset });\n+        for (range, expected) in annotations {\n+            let ty = type_at_range(&db, FileRange { file_id, range });\n+            let actual = if display_source {\n+                let module = db.module_for_file(file_id);\n+                ty.display_source_code(&db, module).unwrap()\n+            } else {\n+                ty.display(&db).to_string()\n+            };\n             assert_eq!(expected, actual);\n             checked_one = true;\n         }\n     }\n     assert!(checked_one, \"no `//^` annotations found\");\n }\n \n-fn type_at_pos(db: &TestDB, pos: FilePosition) -> String {\n-    type_at_pos_displayed(db, pos, |ty, _| ty.display(db).to_string())\n-}\n-\n-fn displayed_source_at_pos(db: &TestDB, pos: FilePosition) -> String {\n-    type_at_pos_displayed(db, pos, |ty, module_id| ty.display_source_code(db, module_id).unwrap())\n-}\n-\n-fn type_at_pos_displayed(\n-    db: &TestDB,\n-    pos: FilePosition,\n-    display_fn: impl FnOnce(&Ty, ModuleId) -> String,\n-) -> String {\n+fn type_at_range(db: &TestDB, pos: FileRange) -> Ty {\n     let file = db.parse(pos.file_id).ok().unwrap();\n-    let expr = algo::find_node_at_offset::<ast::Expr>(file.syntax(), pos.offset).unwrap();\n+    let expr = algo::find_node_at_range::<ast::Expr>(file.syntax(), pos.range).unwrap();\n     let fn_def = expr.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n     let module = db.module_for_file(pos.file_id);\n     let func = *module.child_by_source(db)[keys::FUNCTION]\n@@ -77,17 +79,11 @@ fn type_at_pos_displayed(\n     let (_body, source_map) = db.body_with_source_map(func.into());\n     if let Some(expr_id) = source_map.node_expr(InFile::new(pos.file_id.into(), &expr)) {\n         let infer = db.infer(func.into());\n-        let ty = &infer[expr_id];\n-        return display_fn(ty, module);\n+        return infer[expr_id].clone();\n     }\n     panic!(\"Can't find expression\")\n }\n \n-fn type_at(ra_fixture: &str) -> String {\n-    let (db, file_pos) = TestDB::with_position(ra_fixture);\n-    type_at_pos(&db, file_pos)\n-}\n-\n fn infer(ra_fixture: &str) -> String {\n     infer_with_mismatches(ra_fixture, false)\n }"}, {"sha": "136d28a9160998b214b7e6dc223b12983ff07e18", "filename": "crates/ra_hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -1,7 +1,8 @@\n-use super::infer_with_mismatches;\n use insta::assert_snapshot;\n use test_utils::mark;\n \n+use super::infer_with_mismatches;\n+\n // Infer with some common definitions and impls.\n fn infer(source: &str) -> String {\n     let defs = r#\""}, {"sha": "b502135d8e203af545ddfce284dff315d7c4fcb2", "filename": "crates/ra_hir_ty/src/tests/display_source_code.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -1,50 +1,41 @@\n-use super::displayed_source_at_pos;\n-use crate::test_db::TestDB;\n-use ra_db::fixture::WithFixture;\n+use super::check_types_source_code;\n \n #[test]\n fn qualify_path_to_submodule() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types_source_code(\n         r#\"\n-//- /main.rs\n-\n mod foo {\n     pub struct Foo;\n }\n \n fn bar() {\n     let foo: foo::Foo = foo::Foo;\n-    foo<|>\n-}\n+    foo\n+}  //^ foo::Foo\n \n \"#,\n     );\n-    assert_eq!(\"foo::Foo\", displayed_source_at_pos(&db, pos));\n }\n \n #[test]\n fn omit_default_type_parameters() {\n-    let (db, pos) = TestDB::with_position(\n-        r\"\n-        //- /main.rs\n-        struct Foo<T = u8> { t: T }\n-        fn main() {\n-            let foo = Foo { t: 5u8 };\n-            foo<|>;\n-        }\n-        \",\n+    check_types_source_code(\n+        r#\"\n+struct Foo<T = u8> { t: T }\n+fn main() {\n+    let foo = Foo { t: 5u8 };\n+    foo;\n+}  //^ Foo\n+\"#,\n     );\n-    assert_eq!(\"Foo\", displayed_source_at_pos(&db, pos));\n \n-    let (db, pos) = TestDB::with_position(\n-        r\"\n-        //- /main.rs\n-        struct Foo<K, T = u8> { k: K, t: T }\n-        fn main() {\n-            let foo = Foo { k: 400, t: 5u8 };\n-            foo<|>;\n-        }\n-        \",\n+    check_types_source_code(\n+        r#\"\n+struct Foo<K, T = u8> { k: K, t: T }\n+fn main() {\n+    let foo = Foo { k: 400, t: 5u8 };\n+    foo;\n+}   //^ Foo<i32>\n+\"#,\n     );\n-    assert_eq!(\"Foo<i32>\", displayed_source_at_pos(&db, pos));\n }"}, {"sha": "45c4e309e2b9c4514bdbc9aa5cc38ab430281e3b", "filename": "crates/ra_hir_ty/src/tests/macros.rs", "status": "modified", "additions": 49, "deletions": 67, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -1,16 +1,13 @@\n use std::fs;\n \n use insta::assert_snapshot;\n-use ra_db::fixture::WithFixture;\n use test_utils::project_dir;\n \n-use crate::test_db::TestDB;\n-\n-use super::{infer, type_at, type_at_pos};\n+use super::{check_types, infer};\n \n #[test]\n fn cfg_impl_def() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:foo cfg:test\n use foo::S as T;\n@@ -28,8 +25,8 @@ impl S {\n \n fn test() {\n     let t = (S.foo1(), S.foo2(), T.foo3(), T.foo4());\n-    t<|>;\n-}\n+    t;\n+} //^ (i32, {unknown}, i32, {unknown})\n \n //- /foo.rs crate:foo\n struct S;\n@@ -45,7 +42,6 @@ impl S {\n }\n \"#,\n     );\n-    assert_eq!(\"(i32, {unknown}, i32, {unknown})\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -253,26 +249,24 @@ fn foo() {\n \n #[test]\n fn processes_impls_generated_by_macros() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n macro_rules! m {\n     ($ident:ident) => (impl Trait for $ident {})\n }\n trait Trait { fn foo(self) -> u128 {} }\n struct S;\n m!(S);\n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn infer_assoc_items_generated_by_macros() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n macro_rules! m {\n     () => (fn foo(&self) -> u128 {0})\n }\n@@ -281,17 +275,16 @@ impl S {\n     m!();\n }\n \n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn infer_assoc_items_generated_by_macros_chain() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n macro_rules! m_inner {\n     () => {fn foo(&self) -> u128 {0}}\n }\n@@ -304,21 +297,21 @@ impl S {\n     m!();\n }\n \n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:foo\n fn test() {\n     let x = (foo::foo!(1), foo::foo!(2));\n-    x<|>;\n-}\n+    x;\n+} //^ (i32, usize)\n \n //- /lib.rs crate:foo\n #[macro_export]\n@@ -335,20 +328,20 @@ macro_rules! bar {\n pub fn baz() -> usize { 31usize }\n \"#,\n     );\n-    assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_macro_with_dollar_crate_is_correct_in_trait_associate_type() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:foo\n use foo::Trait;\n \n fn test() {\n     let msg = foo::Message(foo::MessageRef);\n     let r = msg.deref();\n-    r<|>;\n+    r;\n+  //^ &MessageRef\n }\n \n //- /lib.rs crate:foo\n@@ -375,7 +368,6 @@ macro_rules! expand {\n expand!();\n \"#,\n     );\n-    assert_eq!(\"&MessageRef\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -429,13 +421,13 @@ fn main() {\n \n #[test]\n fn infer_local_inner_macros() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:foo\n fn test() {\n     let x = foo::foo!(1);\n-    x<|>;\n-}\n+    x;\n+} //^ i32\n \n //- /lib.rs crate:foo\n #[macro_export(local_inner_macros)]\n@@ -450,7 +442,6 @@ macro_rules! bar {\n \n \"#,\n     );\n-    assert_eq!(\"i32\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -531,7 +522,7 @@ fn main() {\n \n #[test]\n fn infer_builtin_macros_include() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs\n #[rustc_builtin_macro]\n@@ -540,14 +531,13 @@ macro_rules! include {() => {}}\n include!(\"foo.rs\");\n \n fn main() {\n-    bar()<|>;\n-}\n+    bar();\n+}     //^ u32\n \n //- /foo.rs\n fn bar() -> u32 {0}\n \"#,\n     );\n-    assert_eq!(\"u32\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -565,18 +555,17 @@ macro_rules! include {() => {}}\n include!(\"foo.rs\");\n \n fn main() {\n-    RegisterBlock { }<|>;\n+    RegisterBlock { };\n+                  //^ RegisterBlock\n }\n     \"#;\n     let fixture = format!(\"{}\\n//- /foo.rs\\n{}\", fixture, big_file);\n-\n-    let (db, pos) = TestDB::with_position(&fixture);\n-    assert_eq!(\"RegisterBlock\", type_at_pos(&db, pos));\n+    check_types(&fixture);\n }\n \n #[test]\n fn infer_builtin_macros_include_concat() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs\n #[rustc_builtin_macro]\n@@ -588,19 +577,18 @@ macro_rules! concat {() => {}}\n include!(concat!(\"f\", \"oo.rs\"));\n \n fn main() {\n-    bar()<|>;\n-}\n+    bar();\n+}     //^ u32\n \n //- /foo.rs\n fn bar() -> u32 {0}\n \"#,\n     );\n-    assert_eq!(\"u32\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_builtin_macros_include_concat_with_bad_env_should_failed() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs\n #[rustc_builtin_macro]\n@@ -615,32 +603,29 @@ macro_rules! env {() => {}}\n include!(concat!(env!(\"OUT_DIR\"), \"/foo.rs\"));\n \n fn main() {\n-    bar()<|>;\n-}\n+    bar();\n+}     //^ {unknown}\n \n //- /foo.rs\n fn bar() -> u32 {0}\n \"#,\n     );\n-    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_builtin_macros_include_itself_should_failed() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[rustc_builtin_macro]\n macro_rules! include {() => {}}\n \n include!(\"main.rs\");\n \n fn main() {\n-    0<|>\n-}\n+    0\n+} //^ i32\n \"#,\n     );\n-    assert_eq!(\"i32\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -686,14 +671,14 @@ fn main() {\n \n #[test]\n fn infer_derive_clone_simple() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n #[derive(Clone)]\n struct S;\n fn test() {\n-    S.clone()<|>;\n-}\n+    S.clone();\n+}         //^ S\n \n //- /lib.rs crate:core\n #[prelude_import]\n@@ -705,12 +690,11 @@ mod clone {\n }\n \"#,\n     );\n-    assert_eq!(\"S\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_derive_clone_in_core() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /lib.rs crate:core\n #[prelude_import]\n@@ -726,16 +710,15 @@ pub struct S;\n //- /main.rs crate:main deps:core\n use core::S;\n fn test() {\n-    S.clone()<|>;\n-}\n+    S.clone();\n+}         //^ S\n \"#,\n     );\n-    assert_eq!(\"S\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_derive_clone_with_params() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n #[derive(Clone)]\n@@ -744,7 +727,8 @@ struct S;\n struct Wrapper<T>(T);\n struct NonClone;\n fn test() {\n-    (Wrapper(S).clone(), Wrapper(NonClone).clone())<|>;\n+    (Wrapper(S).clone(), Wrapper(NonClone).clone());\n+  //^ (Wrapper<S>, {unknown})\n }\n \n //- /lib.rs crate:core\n@@ -757,13 +741,12 @@ mod clone {\n }\n \"#,\n     );\n-    assert_eq!(\"(Wrapper<S>, {unknown})\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_custom_derive_simple() {\n     // FIXME: this test current now do nothing\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main\n use foo::Foo;\n@@ -772,11 +755,10 @@ use foo::Foo;\n struct S{}\n \n fn test() {\n-    S{}<|>;\n-}\n+    S{};\n+}   //^ S\n \"#,\n     );\n-    assert_eq!(\"S\", type_at_pos(&db, pos));\n }\n \n #[test]"}, {"sha": "9c8f223141ba6d5741fe7f2ca133f37d68a3fdab", "filename": "crates/ra_hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 68, "deletions": 90, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -1,7 +1,6 @@\n-use super::{infer, type_at, type_at_pos};\n-use crate::test_db::TestDB;\n use insta::assert_snapshot;\n-use ra_db::fixture::WithFixture;\n+\n+use super::{check_types, infer};\n \n #[test]\n fn infer_slice_method() {\n@@ -246,13 +245,13 @@ fn test() {\n \n #[test]\n fn cross_crate_associated_method_call() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:other_crate\n fn test() {\n     let x = other_crate::foo::S::thing();\n-    x<|>;\n-}\n+    x;\n+} //^ i128\n \n //- /lib.rs crate:other_crate\n mod foo {\n@@ -263,7 +262,6 @@ mod foo {\n }\n \"#,\n     );\n-    assert_eq!(\"i128\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -684,135 +682,127 @@ fn test() {\n \n #[test]\n fn method_resolution_unify_impl_self_type() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct S<T>;\n impl S<u32> { fn foo(&self) -> u8 {} }\n impl S<i32> { fn foo(&self) -> i8 {} }\n-fn test() { (S::<u32>.foo(), S::<i32>.foo())<|>; }\n+fn test() { (S::<u32>.foo(), S::<i32>.foo()); }\n+          //^ (u8, i8)\n \"#,\n     );\n-    assert_eq!(t, \"(u8, i8)\");\n }\n \n #[test]\n fn method_resolution_trait_before_autoref() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl S { fn foo(&self) -> i8 { 0 } }\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn method_resolution_by_value_before_autoref() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Clone { fn clone(&self) -> Self; }\n struct S;\n impl Clone for S {}\n impl Clone for &S {}\n-fn test() { (S.clone(), (&S).clone(), (&&S).clone())<|>; }\n+fn test() { (S.clone(), (&S).clone(), (&&S).clone()); }\n+          //^ (S, S, &S)\n \"#,\n     );\n-    assert_eq!(t, \"(S, S, &S)\");\n }\n \n #[test]\n fn method_resolution_trait_before_autoderef() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl S { fn foo(self) -> i8 { 0 } }\n impl Trait for &S { fn foo(self) -> u128 { 0 } }\n-fn test() { (&S).foo()<|>; }\n+fn test() { (&S).foo(); }\n+                   //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn method_resolution_impl_before_trait() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl S { fn foo(self) -> i8 { 0 } }\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ i8\n \"#,\n     );\n-    assert_eq!(t, \"i8\");\n }\n \n #[test]\n fn method_resolution_impl_ref_before_trait() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl S { fn foo(&self) -> i8 { 0 } }\n impl Trait for &S { fn foo(self) -> u128 { 0 } }\n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ i8\n \"#,\n     );\n-    assert_eq!(t, \"i8\");\n }\n \n #[test]\n fn method_resolution_trait_autoderef() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S { fn foo(self) -> u128 { 0 } }\n-fn test() { (&S).foo()<|>; }\n+fn test() { (&S).foo(); }\n+                   //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn method_resolution_unsize_array() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[lang = \"slice\"]\n impl<T> [T] {\n     fn len(&self) -> usize { loop {} }\n }\n fn test() {\n     let a = [1, 2, 3];\n-    a.len()<|>;\n-}\n+    a.len();\n+}       //^ usize\n \"#,\n     );\n-    assert_eq!(t, \"usize\");\n }\n \n #[test]\n fn method_resolution_trait_from_prelude() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:other_crate\n struct S;\n impl Clone for S {}\n \n fn test() {\n-    S.clone()<|>;\n+    S.clone();\n+          //^ S\n }\n \n //- /lib.rs crate:other_crate\n@@ -825,115 +815,107 @@ mod foo {\n }\n \"#,\n     );\n-    assert_eq!(\"S\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn method_resolution_where_clause_for_unknown_trait() {\n     // The blanket impl currently applies because we ignore the unresolved where clause\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T> Trait for T where T: UnknownTrait {}\n-fn test() { (&S).foo()<|>; }\n+fn test() { (&S).foo(); }\n+                   //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn method_resolution_where_clause_not_met() {\n     // The blanket impl shouldn't apply because we can't prove S: Clone\n-    let t = type_at(\n+    // This is also to make sure that we don't resolve to the foo method just\n+    // because that's the only method named foo we can find, which would make\n+    // the below tests not work\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T> Trait for T where T: Clone {}\n-fn test() { (&S).foo()<|>; }\n+fn test() { (&S).foo(); }\n+                   //^ {unknown}\n \"#,\n     );\n-    // This is also to make sure that we don't resolve to the foo method just\n-    // because that's the only method named foo we can find, which would make\n-    // the below tests not work\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn method_resolution_where_clause_inline_not_met() {\n     // The blanket impl shouldn't apply because we can't prove S: Clone\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl<T: Clone> Trait for T {}\n-fn test() { (&S).foo()<|>; }\n+fn test() { (&S).foo(); }\n+                   //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn method_resolution_where_clause_1() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n-fn test() { S.foo()<|>; }\n+fn test() { S.foo(); }\n+                //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn method_resolution_where_clause_2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Into<T> { fn into(self) -> T; }\n trait From<T> { fn from(other: T) -> Self; }\n struct S1;\n struct S2;\n impl From<S2> for S1 {}\n impl<T, U> Into<U> for T where U: From<T> {}\n-fn test() { S2.into()<|>; }\n+fn test() { S2.into(); }\n+                  //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn method_resolution_where_clause_inline() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Into<T> { fn into(self) -> T; }\n trait From<T> { fn from(other: T) -> Self; }\n struct S1;\n struct S2;\n impl From<S2> for S1 {}\n impl<T, U: From<T>> Into<U> for T {}\n-fn test() { S2.into()<|>; }\n+fn test() { S2.into(); }\n+                  //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn method_resolution_overloaded_method() {\n     test_utils::mark::check!(impl_self_type_match_without_receiver);\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct Wrapper<T>(T);\n struct Foo<T>(T);\n struct Bar<T>(T);\n@@ -953,30 +935,30 @@ impl<T> Wrapper<Bar<T>> {\n fn main() {\n     let a = Wrapper::<Foo<f32>>::new(1.0);\n     let b = Wrapper::<Bar<f32>>::new(1.0);\n-    (a, b)<|>;\n+    (a, b);\n+  //^ (Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\n }\n \"#,\n     );\n-    assert_eq!(t, \"(Wrapper<Foo<f32>>, Wrapper<Bar<f32>>)\")\n }\n \n #[test]\n fn method_resolution_encountering_fn_type() {\n-    type_at(\n+    check_types(\n         r#\"\n //- /main.rs\n fn foo() {}\n trait FnOnce { fn call(self); }\n-fn test() { foo.call()<|>; }\n+fn test() { foo.call(); }\n+                   //^ {unknown}\n \"#,\n     );\n }\n \n #[test]\n fn method_resolution_non_parameter_type() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n mod a {\n     pub trait Foo {\n         fn foo(&self);\n@@ -988,38 +970,34 @@ fn foo<T>(t: Wrapper<T>)\n where\n     Wrapper<T>: a::Foo,\n {\n-    t.foo()<|>;\n-}\n+    t.foo();\n+}       //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn method_resolution_3373() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct A<T>(T);\n \n impl A<i32> {\n     fn from(v: i32) -> A<i32> { A(v) }\n }\n \n fn main() {\n-    A::from(3)<|>;\n-}\n+    A::from(3);\n+}          //^ A<i32>\n \"#,\n     );\n-    assert_eq!(t, \"A<i32>\");\n }\n \n #[test]\n fn method_resolution_slow() {\n     // this can get quite slow if we set the solver size limit too high\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait SendX {}\n \n struct S1; impl SendX for S1 {}\n@@ -1037,10 +1015,10 @@ trait FnX {}\n \n impl<B, C> Trait for S<B, C> where C: FnX, B: SendX {}\n \n-fn test() { (S {}).method()<|>; }\n+fn test() { (S {}).method(); }\n+                        //^ ()\n \"#,\n     );\n-    assert_eq!(t, \"()\");\n }\n \n #[test]"}, {"sha": "d806e0ffb34605b70cd45f69bdf2306178122b3d", "filename": "crates/ra_hir_ty/src/tests/regression.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -1,10 +1,7 @@\n use insta::assert_snapshot;\n-use ra_db::fixture::WithFixture;\n use test_utils::mark;\n \n-use crate::test_db::TestDB;\n-\n-use super::infer;\n+use super::{check_types, infer};\n \n #[test]\n fn bug_484() {\n@@ -404,13 +401,13 @@ fn test() {\n \n #[test]\n fn issue_2683_chars_impl() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n fn test() {\n     let chars: std::str::Chars<'_>;\n-    (chars.next(), chars.nth(1))<|>;\n-}\n+    (chars.next(), chars.nth(1));\n+} //^ (Option<char>, Option<char>)\n \n //- /std.rs crate:std\n #[prelude_import]\n@@ -449,15 +446,12 @@ pub mod str {\n }\n \"#,\n     );\n-\n-    assert_eq!(\"(Option<char>, Option<char>)\", super::type_at_pos(&db, pos));\n }\n \n #[test]\n fn issue_3642_bad_macro_stackover() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[macro_export]\n macro_rules! match_ast {\n     (match $node:ident { $($tt:tt)* }) => { match_ast!(match ($node) { $($tt)* }) };\n@@ -472,16 +466,15 @@ macro_rules! match_ast {\n }\n \n fn main() {\n-    let anchor<|> = match_ast! {\n+    let anchor = match_ast! {\n+       //^ ()\n         match parent {\n             as => {},\n             _ => return None\n         }\n     };\n }\"#,\n     );\n-\n-    assert_eq!(\"()\", super::type_at_pos(&db, pos));\n }\n \n #[test]"}, {"sha": "01c919a7ecae2c430534498300c68920081f7751", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 130, "deletions": 212, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -1,17 +1,13 @@\n use insta::assert_snapshot;\n-use ra_db::fixture::WithFixture;\n use test_utils::mark;\n \n-use crate::test_db::TestDB;\n-\n-use super::{infer, infer_with_mismatches, type_at, type_at_pos};\n+use super::{check_types, infer, infer_with_mismatches};\n \n #[test]\n fn infer_await() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n-\n struct IntFuture;\n \n impl Future for IntFuture {\n@@ -21,8 +17,8 @@ impl Future for IntFuture {\n fn test() {\n     let r = IntFuture;\n     let v = r.await;\n-    v<|>;\n-}\n+    v;\n+} //^ u64\n \n //- /core.rs crate:core\n #[prelude_import] use future::*;\n@@ -32,27 +28,24 @@ mod future {\n         type Output;\n     }\n }\n-\n \"#,\n     );\n-    assert_eq!(\"u64\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_async() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n-\n async fn foo() -> u64 {\n     128\n }\n \n fn test() {\n     let r = foo();\n     let v = r.await;\n-    v<|>;\n-}\n+    v;\n+} //^ u64\n \n //- /core.rs crate:core\n #[prelude_import] use future::*;\n@@ -62,26 +55,23 @@ mod future {\n         type Output;\n     }\n }\n-\n \"#,\n     );\n-    assert_eq!(\"u64\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_desugar_async() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n-\n async fn foo() -> u64 {\n     128\n }\n \n fn test() {\n     let r = foo();\n-    r<|>;\n-}\n+    r;\n+} //^ impl Future<Output = u64>\n \n //- /core.rs crate:core\n #[prelude_import] use future::*;\n@@ -93,23 +83,20 @@ mod future {\n \n \"#,\n     );\n-    assert_eq!(\"impl Future<Output = u64>\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_try() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n-\n fn test() {\n     let r: Result<i32, u64> = Result::Ok(1);\n     let v = r?;\n-    v<|>;\n-}\n+    v;\n+} //^ i32\n \n //- /core.rs crate:core\n-\n #[prelude_import] use ops::*;\n mod ops {\n     trait Try {\n@@ -130,30 +117,26 @@ mod result {\n         type Error = E;\n     }\n }\n-\n \"#,\n     );\n-    assert_eq!(\"i32\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_for_loop() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core,alloc\n-\n use alloc::collections::Vec;\n \n fn test() {\n     let v = Vec::new();\n     v.push(\"foo\");\n     for x in v {\n-        x<|>;\n-    }\n+        x;\n+    } //^ &str\n }\n \n //- /core.rs crate:core\n-\n #[prelude_import] use iter::*;\n mod iter {\n     trait IntoIterator {\n@@ -162,7 +145,6 @@ mod iter {\n }\n \n //- /alloc.rs crate:alloc deps:core\n-\n mod collections {\n     struct Vec<T> {}\n     impl<T> Vec<T> {\n@@ -176,15 +158,13 @@ mod collections {\n }\n \"#,\n     );\n-    assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_ops_neg() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n-\n struct Bar;\n struct Foo;\n \n@@ -195,11 +175,10 @@ impl std::ops::Neg for Bar {\n fn test() {\n     let a = Bar;\n     let b = -a;\n-    b<|>;\n-}\n+    b;\n+} //^ Foo\n \n //- /std.rs crate:std\n-\n #[prelude_import] use ops::*;\n mod ops {\n     #[lang = \"neg\"]\n@@ -209,15 +188,13 @@ mod ops {\n }\n \"#,\n     );\n-    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_ops_not() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n-\n struct Bar;\n struct Foo;\n \n@@ -228,11 +205,10 @@ impl std::ops::Not for Bar {\n fn test() {\n     let a = Bar;\n     let b = !a;\n-    b<|>;\n-}\n+    b;\n+} //^ Foo\n \n //- /std.rs crate:std\n-\n #[prelude_import] use ops::*;\n mod ops {\n     #[lang = \"not\"]\n@@ -242,7 +218,6 @@ mod ops {\n }\n \"#,\n     );\n-    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -537,10 +512,9 @@ fn indexing_arrays() {\n \n #[test]\n fn infer_ops_index() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n-\n struct Bar;\n struct Foo;\n \n@@ -551,11 +525,10 @@ impl std::ops::Index<u32> for Bar {\n fn test() {\n     let a = Bar;\n     let b = a[1u32];\n-    b<|>;\n-}\n+    b;\n+} //^ Foo\n \n //- /std.rs crate:std\n-\n #[prelude_import] use ops::*;\n mod ops {\n     #[lang = \"index\"]\n@@ -565,19 +538,18 @@ mod ops {\n }\n \"#,\n     );\n-    assert_eq!(\"Foo\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn infer_ops_index_autoderef() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n fn test() {\n     let a = &[1u32, 2, 3];\n     let b = a[1u32];\n-    b<|>;\n-}\n+    b;\n+} //^ u32\n \n //- /std.rs crate:std\n impl<T> ops::Index<u32> for [T] {\n@@ -593,14 +565,12 @@ mod ops {\n }\n \"#,\n     );\n-    assert_eq!(\"u32\", type_at_pos(&db, pos));\n }\n \n #[test]\n fn deref_trait() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[lang = \"deref\"]\n trait Deref {\n     type Target;\n@@ -618,16 +588,15 @@ impl S {\n }\n \n fn test(s: Arc<S>) {\n-    (*s, s.foo())<|>;\n-}\n+    (*s, s.foo());\n+} //^ (S, u128)\n \"#,\n     );\n-    assert_eq!(t, \"(S, u128)\");\n }\n \n #[test]\n fn deref_trait_with_inference_var() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /main.rs\n #[lang = \"deref\"]\n@@ -647,19 +616,18 @@ fn foo(a: Arc<S>) {}\n \n fn test() {\n     let a = new_arc();\n-    let b = (*a)<|>;\n+    let b = (*a);\n+          //^ S\n     foo(a);\n }\n \"#,\n     );\n-    assert_eq!(t, \"S\");\n }\n \n #[test]\n fn deref_trait_infinite_recursion() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[lang = \"deref\"]\n trait Deref {\n     type Target;\n@@ -673,18 +641,16 @@ impl Deref for S {\n }\n \n fn test(s: S) {\n-    s.foo()<|>;\n-}\n+    s.foo();\n+}       //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn deref_trait_with_question_mark_size() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[lang = \"deref\"]\n trait Deref {\n     type Target;\n@@ -702,18 +668,16 @@ impl S {\n }\n \n fn test(s: Arc<S>) {\n-    (*s, s.foo())<|>;\n-}\n+    (*s, s.foo());\n+} //^ (S, u128)\n \"#,\n     );\n-    assert_eq!(t, \"(S, u128)\");\n }\n \n #[test]\n fn obligation_from_function_clause() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct S;\n \n trait Trait<T> {}\n@@ -722,16 +686,15 @@ impl Trait<u32> for S {}\n fn foo<T: Trait<U>, U>(t: T) -> U {}\n \n fn test(s: S) {\n-    foo(s)<|>;\n-}\n+    (foo(s));\n+} //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n fn obligation_from_method_clause() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /main.rs\n struct S;\n@@ -745,18 +708,16 @@ impl O {\n }\n \n fn test() {\n-    O.foo(S)<|>;\n-}\n+    O.foo(S);\n+}      //^ isize\n \"#,\n     );\n-    assert_eq!(t, \"isize\");\n }\n \n #[test]\n fn obligation_from_self_method_clause() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct S;\n \n trait Trait<T> {}\n@@ -767,18 +728,16 @@ impl S {\n }\n \n fn test() {\n-    S.foo()<|>;\n-}\n+    S.foo();\n+}       //^ i64\n \"#,\n     );\n-    assert_eq!(t, \"i64\");\n }\n \n #[test]\n fn obligation_from_impl_clause() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct S;\n \n trait Trait<T> {}\n@@ -790,78 +749,73 @@ impl<U, T: Trait<U>> O<T> {\n }\n \n fn test(o: O<S>) {\n-    o.foo()<|>;\n-}\n+    o.foo();\n+}       //^ &str\n \"#,\n     );\n-    assert_eq!(t, \"&str\");\n }\n \n #[test]\n fn generic_param_env_1() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n-fn test<T: Clone>(t: T) { t.foo()<|>; }\n+fn test<T: Clone>(t: T) { t.foo(); }\n+                             //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn generic_param_env_1_not_met() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /main.rs\n trait Clone {}\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Clone for S {}\n impl<T> Trait for T where T: Clone {}\n-fn test<T>(t: T) { t.foo()<|>; }\n+fn test<T>(t: T) { t.foo(); }\n+                       //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn generic_param_env_2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S {}\n-fn test<T: Trait>(t: T) { t.foo()<|>; }\n+fn test<T: Trait>(t: T) { t.foo(); }\n+                              //^ u128\n \"#,\n     );\n-    assert_eq!(t, \"u128\");\n }\n \n #[test]\n fn generic_param_env_2_not_met() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait { fn foo(self) -> u128; }\n struct S;\n impl Trait for S {}\n-fn test<T>(t: T) { t.foo()<|>; }\n+fn test<T>(t: T) { t.foo(); }\n+                       //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn generic_param_env_deref() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n #[lang = \"deref\"]\n trait Deref {\n     type Target;\n@@ -870,17 +824,17 @@ trait Trait {}\n impl<T> Deref for T where T: Trait {\n     type Target = i128;\n }\n-fn test<T: Trait>(t: T) { (*t)<|>; }\n+fn test<T: Trait>(t: T) { (*t); }\n+                        //^ i128\n \"#,\n     );\n-    assert_eq!(t, \"i128\");\n }\n \n #[test]\n fn associated_type_placeholder() {\n-    let t = type_at(\n+    // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n+    check_types(\n         r#\"\n-//- /main.rs\n pub trait ApplyL {\n     type Out;\n }\n@@ -893,31 +847,27 @@ impl<T> ApplyL for RefMutL<T> {\n \n fn test<T: ApplyL>() {\n     let y: <RefMutL<T> as ApplyL>::Out = no_matter;\n-    y<|>;\n-}\n+    y;\n+} //^ ApplyL::Out<T>\n \"#,\n     );\n-    // inside the generic function, the associated type gets normalized to a placeholder `ApplL::Out<T>` [https://rust-lang.github.io/rustc-guide/traits/associated-types.html#placeholder-associated-types].\n-    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]\n fn associated_type_placeholder_2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n pub trait ApplyL {\n     type Out;\n }\n fn foo<T: ApplyL>(t: T) -> <T as ApplyL>::Out;\n \n fn test<T: ApplyL>(t: T) {\n     let y = foo(t);\n-    y<|>;\n-}\n+    y;\n+} //^ ApplyL::Out<T>\n \"#,\n     );\n-    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]\n@@ -1398,19 +1348,17 @@ fn test(a: impl Trait + 'lifetime, b: impl 'lifetime, c: impl (Trait), d: impl (\n #[test]\n #[ignore]\n fn error_bound_chalk() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait {\n     fn foo(&self) -> u32 {}\n }\n \n fn test(x: (impl Trait + UnknownTrait)) {\n-    x.foo()<|>;\n-}\n+    x.foo();\n+}       //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n@@ -1480,7 +1428,7 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n \n #[test]\n fn impl_trait_assoc_binding_projection_bug() {\n-    let (db, pos) = TestDB::with_position(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:std\n pub trait Language {\n@@ -1499,8 +1447,8 @@ trait Clone {\n \n fn api_walkthrough() {\n     for node in foo() {\n-        node.clone()<|>;\n-    }\n+        node.clone();\n+    }            //^ {unknown}\n }\n \n //- /std.rs crate:std\n@@ -1518,7 +1466,6 @@ mod iter {\n }\n \"#,\n     );\n-    assert_eq!(\"{unknown}\", type_at_pos(&db, pos));\n }\n \n #[test]\n@@ -1549,21 +1496,19 @@ fn test<T: Trait1<Type = u32>>(x: T) {\n \n #[test]\n fn where_clause_trait_in_scope_for_method_resolution() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n mod foo {\n     trait Trait {\n         fn foo(&self) -> u32 {}\n     }\n }\n \n fn test<T: foo::Trait>(x: T) {\n-    x.foo()<|>;\n-}\n+    x.foo();\n+}      //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n@@ -2012,7 +1957,7 @@ fn test() {\n \n #[test]\n fn unselected_projection_in_trait_env_1() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /main.rs\n trait Trait {\n@@ -2025,18 +1970,16 @@ trait Trait2 {\n \n fn test<T: Trait>() where T::Item: Trait2 {\n     let x: T::Item = no_matter;\n-    x.foo()<|>;\n-}\n+    x.foo();\n+}       //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n fn unselected_projection_in_trait_env_2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait<T> {\n     type Item;\n }\n@@ -2047,11 +1990,10 @@ trait Trait2 {\n \n fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n     let x: T::Item = no_matter;\n-    x.foo()<|>;\n-}\n+    x.foo();\n+}       //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n@@ -2097,9 +2039,8 @@ impl Trait for S2 {\n \n #[test]\n fn unselected_projection_on_trait_self() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait {\n     type Item;\n \n@@ -2112,18 +2053,16 @@ impl Trait for S {\n }\n \n fn test() {\n-    S.f()<|>;\n-}\n+    S.f();\n+}     //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n fn unselected_projection_chalk_fold() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Interner {}\n trait Fold<I: Interner, TI = I> {\n     type Result;\n@@ -2142,18 +2081,16 @@ where\n }\n \n fn foo<I: Interner>(interner: &I, t: Ty<I>) {\n-    fold(interner, t)<|>;\n-}\n+    fold(interner, t);\n+}     //^ Ty<I>\n \"#,\n     );\n-    assert_eq!(t, \"Ty<I>\");\n }\n \n #[test]\n fn trait_impl_self_ty() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait<T> {\n    fn foo(&self);\n }\n@@ -2163,18 +2100,16 @@ struct S;\n impl Trait<Self> for S {}\n \n fn test() {\n-    S.foo()<|>;\n-}\n+    S.foo();\n+}       //^ ()\n \"#,\n     );\n-    assert_eq!(t, \"()\");\n }\n \n #[test]\n fn trait_impl_self_ty_cycle() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait {\n    fn foo(&self);\n }\n@@ -2184,56 +2119,51 @@ struct S<T>;\n impl Trait for S<Self> {}\n \n fn test() {\n-    S.foo()<|>;\n-}\n+    S.foo();\n+}       //^ {unknown}\n \"#,\n     );\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn unselected_projection_in_trait_env_cycle_1() {\n-    let t = type_at(\n+    // this is a legitimate cycle\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Trait {\n     type Item;\n }\n \n trait Trait2<T> {}\n \n fn test<T: Trait>() where T: Trait2<T::Item> {\n-    let x: T::Item = no_matter<|>;\n-}\n+    let x: T::Item = no_matter;\n+}                       //^ {unknown}\n \"#,\n     );\n-    // this is a legitimate cycle\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn unselected_projection_in_trait_env_cycle_2() {\n-    let t = type_at(\n+    // this is a legitimate cycle\n+    check_types(\n         r#\"\n //- /main.rs\n trait Trait<T> {\n     type Item;\n }\n \n fn test<T, U>() where T: Trait<U::Item>, U: Trait<T::Item> {\n-    let x: T::Item = no_matter<|>;\n-}\n+    let x: T::Item = no_matter;\n+}                   //^ {unknown}\n \"#,\n     );\n-    // this is a legitimate cycle\n-    assert_eq!(t, \"{unknown}\");\n }\n \n #[test]\n fn inline_assoc_type_bounds_1() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Iterator {\n     type Item;\n }\n@@ -2249,29 +2179,26 @@ impl<T: Iterator> Iterator for S<T> {\n \n fn test<I: Iterator<Item: OtherTrait<u32>>>() {\n     let x: <S<I> as Iterator>::Item;\n-    x.foo()<|>;\n-}\n+    x.foo();\n+}       //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n fn inline_assoc_type_bounds_2() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n trait Iterator {\n     type Item;\n }\n \n fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n     let x: <<I as Iterator>::Item as Iterator>::Item;\n-    x<|>;\n-}\n+    x;\n+} //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n@@ -2445,9 +2372,8 @@ fn main() {\n \n #[test]\n fn associated_type_bound() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n pub trait Trait {\n     type Item: OtherTrait<u32>;\n }\n@@ -2463,18 +2389,16 @@ impl<T: Trait> Trait for S<T> {\n \n fn test<T: Trait>() {\n     let y: <S<T> as Trait>::Item = no_matter;\n-    y.foo()<|>;\n-}\n+    y.foo();\n+}       //^ u32\n \"#,\n     );\n-    assert_eq!(t, \"u32\");\n }\n \n #[test]\n fn dyn_trait_through_chalk() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct Box<T> {}\n #[lang = \"deref\"]\n trait Deref {\n@@ -2488,18 +2412,16 @@ trait Trait {\n }\n \n fn test(x: Box<dyn Trait>) {\n-    x.foo()<|>;\n-}\n+    x.foo();\n+}       //^ ()\n \"#,\n     );\n-    assert_eq!(t, \"()\");\n }\n \n #[test]\n fn string_to_owned() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct String {}\n pub trait ToOwned {\n     type Owned;\n@@ -2509,11 +2431,10 @@ impl ToOwned for str {\n     type Owned = String;\n }\n fn test() {\n-    \"foo\".to_owned()<|>;\n-}\n+    \"foo\".to_owned();\n+}               //^ String\n \"#,\n     );\n-    assert_eq!(t, \"String\");\n }\n \n #[test]\n@@ -2637,9 +2558,8 @@ fn main() {\n \n #[test]\n fn nested_assoc() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n-//- /main.rs\n struct Bar;\n struct Foo;\n \n@@ -2662,11 +2582,10 @@ impl<T:A> B for T {\n }\n \n fn main() {\n-    Bar::foo()<|>;\n-}\n+    Bar::foo();\n+}          //^ Foo\n \"#,\n     );\n-    assert_eq!(t, \"Foo\");\n }\n \n #[test]\n@@ -2846,12 +2765,12 @@ fn test() {\n \n #[test]\n fn integer_range_iterate() {\n-    let t = type_at(\n+    check_types(\n         r#\"\n //- /main.rs crate:main deps:core\n fn test() {\n-    for x in 0..100 { x<|>; }\n-}\n+    for x in 0..100 { x; }\n+}                   //^ i32\n \n //- /core.rs crate:core\n pub mod ops {\n@@ -2886,7 +2805,6 @@ impl<A: Step> iter::Iterator for ops::Range<A> {\n }\n \"#,\n     );\n-    assert_eq!(t, \"i32\");\n }\n \n #[test]"}, {"sha": "26b3c813a1d6060cd60f161d56b080b4f9bcc793", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -41,6 +41,10 @@ pub fn find_node_at_offset<N: AstNode>(syntax: &SyntaxNode, offset: TextSize) ->\n     ancestors_at_offset(syntax, offset).find_map(N::cast)\n }\n \n+pub fn find_node_at_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n+    find_covering_element(syntax, range).ancestors().find_map(N::cast)\n+}\n+\n /// Skip to next non `trivia` token\n pub fn skip_trivia_token(mut token: SyntaxToken, direction: Direction) -> Option<SyntaxToken> {\n     while token.kind().is_trivia() {"}, {"sha": "caf847273ba5d5b5cf97d478b11138e88f1ac85b", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc4dc995612916a4c0a99396b5259a5fb1dda80/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=bbc4dc995612916a4c0a99396b5259a5fb1dda80", "patch": "@@ -161,15 +161,15 @@ pub fn add_cursor(text: &str, offset: TextSize) -> String {\n }\n \n /// Extracts `//^ some text` annotations\n-pub fn extract_annotations(text: &str) -> Vec<(TextSize, String)> {\n+pub fn extract_annotations(text: &str) -> Vec<(TextRange, String)> {\n     let mut res = Vec::new();\n     let mut prev_line_start: Option<TextSize> = None;\n     let mut line_start: TextSize = 0.into();\n     for line in lines_with_ends(text) {\n         if let Some(idx) = line.find(\"//^\") {\n             let offset = prev_line_start.unwrap() + TextSize::of(&line[..idx + \"//\".len()]);\n             let data = line[idx + \"//^\".len()..].trim().to_string();\n-            res.push((offset, data))\n+            res.push((TextRange::at(offset, 1.into()), data))\n         }\n         prev_line_start = Some(line_start);\n         line_start += TextSize::of(line);\n@@ -179,18 +179,20 @@ pub fn extract_annotations(text: &str) -> Vec<(TextSize, String)> {\n \n #[test]\n fn test_extract_annotations() {\n-    let res = extract_annotations(&trim_indent(\n+    let text = stdx::trim_indent(\n         r#\"\n fn main() {\n     let x = 92;\n       //^ def\n-\n-    x + 1\n+    z + 1\n } //^ i32\n     \"#,\n-    ));\n-\n-    assert_eq!(res, vec![(20.into(), \"def\".into()), (47.into(), \"i32\".into())]);\n+    );\n+    let res = extract_annotations(&text)\n+        .into_iter()\n+        .map(|(range, ann)| (&text[range], ann))\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![(\"x\", \"def\".into()), (\"z\", \"i32\".into()),]);\n }\n \n // Comparison functionality borrowed from cargo:"}]}