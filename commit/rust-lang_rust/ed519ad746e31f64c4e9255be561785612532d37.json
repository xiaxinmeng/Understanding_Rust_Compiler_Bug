{"sha": "ed519ad746e31f64c4e9255be561785612532d37", "node_id": "C_kwDOAAsO6NoAKGVkNTE5YWQ3NDZlMzFmNjRjNGU5MjU1YmU1NjE3ODU2MTI1MzJkMzc", "commit": {"author": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-10-12T08:34:25Z"}, "committer": {"name": "Samuel Moelius", "email": "sam@moeli.us", "date": "2022-12-20T10:12:13Z"}, "message": "Improve `possible_borrower`", "tree": {"sha": "26bbaab9d4c94e3f451cac8bae41acbd58adff4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26bbaab9d4c94e3f451cac8bae41acbd58adff4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed519ad746e31f64c4e9255be561785612532d37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed519ad746e31f64c4e9255be561785612532d37", "html_url": "https://github.com/rust-lang/rust/commit/ed519ad746e31f64c4e9255be561785612532d37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed519ad746e31f64c4e9255be561785612532d37/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6477eb71188311f01f409da628fab7062697bd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6477eb71188311f01f409da628fab7062697bd7", "html_url": "https://github.com/rust-lang/rust/commit/c6477eb71188311f01f409da628fab7062697bd7"}], "stats": {"total": 303, "additions": 195, "deletions": 108}, "files": [{"sha": "728941b8b3d9ab007fea377f4b2a6824ceca957e", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -1282,10 +1282,10 @@ fn referent_used_exactly_once<'tcx>(\n             possible_borrowers.push((body_owner_local_def_id, PossibleBorrowerMap::new(cx, mir)));\n         }\n         let possible_borrower = &mut possible_borrowers.last_mut().unwrap().1;\n-        // If `only_borrowers` were used here, the `copyable_iterator::warn` test would fail. The reason is\n-        // that `PossibleBorrowerVisitor::visit_terminator` considers `place.local` a possible borrower of\n-        // itself. See the comment in that method for an explanation as to why.\n-        possible_borrower.bounded_borrowers(&[local], &[local, place.local], place.local, location)\n+        // If `place.local` were not included here, the `copyable_iterator::warn` test would fail. The\n+        // reason is that `PossibleBorrowerVisitor::visit_terminator` considers `place.local` a possible\n+        // borrower of itself. See the comment in that method for an explanation as to why.\n+        possible_borrower.at_most_borrowers(cx, &[local, place.local], place.local, location)\n             && used_exactly_once(mir, place.local).unwrap_or(false)\n     } else {\n         false"}, {"sha": "0e7c5cca7240bd02ba8a0523905de512d6930b8f", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 // `res = clone(arg)` can be turned into `res = move arg;`\n                 // if `arg` is the only borrow of `cloned` at this point.\n \n-                if cannot_move_out || !possible_borrower.only_borrowers(&[arg], cloned, loc) {\n+                if cannot_move_out || !possible_borrower.at_most_borrowers(cx, &[arg], cloned, loc) {\n                     continue;\n                 }\n \n@@ -178,7 +178,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 // StorageDead(pred_arg);\n                 // res = to_path_buf(cloned);\n                 // ```\n-                if cannot_move_out || !possible_borrower.only_borrowers(&[arg, cloned], local, loc) {\n+                if cannot_move_out || !possible_borrower.at_most_borrowers(cx, &[arg, cloned], local, loc) {\n                     continue;\n                 }\n "}, {"sha": "ebe7d3393097d94a1a65e9f0f731843e7b5d9cc3", "filename": "clippy_utils/src/mir/possible_borrower.rs", "status": "modified", "additions": 167, "deletions": 98, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmir%2Fpossible_borrower.rs?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -1,89 +1,137 @@\n-use super::{possible_origin::PossibleOriginVisitor, transitive_relation::TransitiveRelation};\n+use super::possible_origin::PossibleOriginVisitor;\n use crate::ty::is_copy;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexMap};\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_lint::LateContext;\n-use rustc_middle::mir::{self, visit::Visitor as _, Mutability};\n-use rustc_middle::ty::{self, visit::TypeVisitor};\n-use rustc_mir_dataflow::{impls::MaybeStorageLive, Analysis, ResultsCursor};\n+use rustc_middle::mir::{\n+    self, visit::Visitor as _, BasicBlock, Local, Location, Mutability, Statement, StatementKind, Terminator,\n+};\n+use rustc_middle::ty::{self, visit::TypeVisitor, TyCtxt};\n+use rustc_mir_dataflow::{\n+    fmt::DebugWithContext, impls::MaybeStorageLive, lattice::JoinSemiLattice, Analysis, AnalysisDomain,\n+    CallReturnPlaces, ResultsCursor,\n+};\n+use std::collections::VecDeque;\n use std::ops::ControlFlow;\n \n /// Collects the possible borrowers of each local.\n /// For example, `b = &a; c = &a;` will make `b` and (transitively) `c`\n /// possible borrowers of `a`.\n #[allow(clippy::module_name_repetitions)]\n-struct PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n-    possible_borrower: TransitiveRelation,\n+struct PossibleBorrowerAnalysis<'b, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     body: &'b mir::Body<'tcx>,\n-    cx: &'a LateContext<'tcx>,\n     possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n }\n \n-impl<'a, 'b, 'tcx> PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n-    fn new(\n-        cx: &'a LateContext<'tcx>,\n-        body: &'b mir::Body<'tcx>,\n-        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    ) -> Self {\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct PossibleBorrowerState {\n+    map: FxIndexMap<Local, BitSet<Local>>,\n+    domain_size: usize,\n+}\n+\n+impl PossibleBorrowerState {\n+    fn new(domain_size: usize) -> Self {\n         Self {\n-            possible_borrower: TransitiveRelation::default(),\n-            cx,\n-            body,\n-            possible_origin,\n+            map: FxIndexMap::default(),\n+            domain_size,\n         }\n     }\n \n-    fn into_map(\n-        self,\n-        cx: &'a LateContext<'tcx>,\n-        maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n-    ) -> PossibleBorrowerMap<'b, 'tcx> {\n-        let mut map = FxHashMap::default();\n-        for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n-            if is_copy(cx, self.body.local_decls[row].ty) {\n-                continue;\n-            }\n+    #[allow(clippy::similar_names)]\n+    fn add(&mut self, borrowed: Local, borrower: Local) {\n+        self.map\n+            .entry(borrowed)\n+            .or_insert(BitSet::new_empty(self.domain_size))\n+            .insert(borrower);\n+    }\n+}\n+\n+impl<C> DebugWithContext<C> for PossibleBorrowerState {\n+    fn fmt_with(&self, _ctxt: &C, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        <_ as std::fmt::Debug>::fmt(self, f)\n+    }\n+    fn fmt_diff_with(&self, _old: &Self, _ctxt: &C, _f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        unimplemented!()\n+    }\n+}\n \n-            let mut borrowers = self.possible_borrower.reachable_from(row, self.body.local_decls.len());\n-            borrowers.remove(mir::Local::from_usize(0));\n+impl JoinSemiLattice for PossibleBorrowerState {\n+    fn join(&mut self, other: &Self) -> bool {\n+        let mut changed = false;\n+        for (&borrowed, borrowers) in other.map.iter() {\n             if !borrowers.is_empty() {\n-                map.insert(row, borrowers);\n+                changed |= self\n+                    .map\n+                    .entry(borrowed)\n+                    .or_insert(BitSet::new_empty(self.domain_size))\n+                    .union(borrowers);\n             }\n         }\n+        changed\n+    }\n+}\n \n-        let bs = BitSet::new_empty(self.body.local_decls.len());\n-        PossibleBorrowerMap {\n-            map,\n-            maybe_live,\n-            bitset: (bs.clone(), bs),\n+impl<'b, 'tcx> AnalysisDomain<'tcx> for PossibleBorrowerAnalysis<'b, 'tcx> {\n+    type Domain = PossibleBorrowerState;\n+\n+    const NAME: &'static str = \"possible_borrower\";\n+\n+    fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n+        PossibleBorrowerState::new(body.local_decls.len())\n+    }\n+\n+    fn initialize_start_block(&self, _body: &mir::Body<'tcx>, _entry_set: &mut Self::Domain) {}\n+}\n+\n+impl<'b, 'tcx> PossibleBorrowerAnalysis<'b, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        body: &'b mir::Body<'tcx>,\n+        possible_origin: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            body,\n+            possible_origin,\n         }\n     }\n }\n \n-impl<'a, 'b, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'b, 'tcx> {\n-    fn visit_assign(&mut self, place: &mir::Place<'tcx>, rvalue: &mir::Rvalue<'_>, _location: mir::Location) {\n-        let lhs = place.local;\n-        match rvalue {\n-            mir::Rvalue::Ref(_, _, borrowed) => {\n-                self.possible_borrower.add(borrowed.local, lhs);\n-            },\n-            other => {\n-                if ContainsRegion\n-                    .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n-                    .is_continue()\n-                {\n-                    return;\n-                }\n-                rvalue_locals(other, |rhs| {\n-                    if lhs != rhs {\n-                        self.possible_borrower.add(rhs, lhs);\n+impl<'b, 'tcx> Analysis<'tcx> for PossibleBorrowerAnalysis<'b, 'tcx> {\n+    fn apply_call_return_effect(\n+        &self,\n+        _state: &mut Self::Domain,\n+        _block: BasicBlock,\n+        _return_places: CallReturnPlaces<'_, 'tcx>,\n+    ) {\n+    }\n+\n+    fn apply_statement_effect(&self, state: &mut Self::Domain, statement: &Statement<'tcx>, _location: Location) {\n+        if let StatementKind::Assign(box (place, rvalue)) = &statement.kind {\n+            let lhs = place.local;\n+            match rvalue {\n+                mir::Rvalue::Ref(_, _, borrowed) => {\n+                    state.add(borrowed.local, lhs);\n+                },\n+                other => {\n+                    if ContainsRegion\n+                        .visit_ty(place.ty(&self.body.local_decls, self.tcx).ty)\n+                        .is_continue()\n+                    {\n+                        return;\n                     }\n-                });\n-            },\n+                    rvalue_locals(other, |rhs| {\n+                        if lhs != rhs {\n+                            state.add(rhs, lhs);\n+                        }\n+                    });\n+                },\n+            }\n         }\n     }\n \n-    fn visit_terminator(&mut self, terminator: &mir::Terminator<'_>, _loc: mir::Location) {\n+    fn apply_terminator_effect(&self, state: &mut Self::Domain, terminator: &Terminator<'tcx>, _location: Location) {\n         if let mir::TerminatorKind::Call {\n             args,\n             destination: mir::Place { local: dest, .. },\n@@ -123,10 +171,10 @@ impl<'a, 'b, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'b,\n \n             for y in mutable_variables {\n                 for x in &immutable_borrowers {\n-                    self.possible_borrower.add(*x, y);\n+                    state.add(*x, y);\n                 }\n                 for x in &mutable_borrowers {\n-                    self.possible_borrower.add(*x, y);\n+                    state.add(*x, y);\n                 }\n             }\n         }\n@@ -162,73 +210,94 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n     }\n }\n \n-/// Result of `PossibleBorrowerVisitor`.\n+/// Result of `PossibleBorrowerAnalysis`.\n #[allow(clippy::module_name_repetitions)]\n pub struct PossibleBorrowerMap<'b, 'tcx> {\n-    /// Mapping `Local -> its possible borrowers`\n-    pub map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n+    body: &'b mir::Body<'tcx>,\n+    possible_borrower: ResultsCursor<'b, 'tcx, PossibleBorrowerAnalysis<'b, 'tcx>>,\n     maybe_live: ResultsCursor<'b, 'tcx, MaybeStorageLive>,\n-    // Caches to avoid allocation of `BitSet` on every query\n-    pub bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n }\n \n-impl<'a, 'b, 'tcx> PossibleBorrowerMap<'b, 'tcx> {\n-    pub fn new(cx: &'a LateContext<'tcx>, mir: &'b mir::Body<'tcx>) -> Self {\n+impl<'b, 'tcx> PossibleBorrowerMap<'b, 'tcx> {\n+    pub fn new(cx: &LateContext<'tcx>, mir: &'b mir::Body<'tcx>) -> Self {\n         let possible_origin = {\n             let mut vis = PossibleOriginVisitor::new(mir);\n             vis.visit_body(mir);\n             vis.into_map(cx)\n         };\n-        let maybe_storage_live_result = MaybeStorageLive::new(BitSet::new_empty(mir.local_decls.len()))\n+        let possible_borrower = PossibleBorrowerAnalysis::new(cx.tcx, mir, possible_origin)\n             .into_engine(cx.tcx, mir)\n-            .pass_name(\"redundant_clone\")\n+            .pass_name(\"possible_borrower\")\n             .iterate_to_fixpoint()\n             .into_results_cursor(mir);\n-        let mut vis = PossibleBorrowerVisitor::new(cx, mir, possible_origin);\n-        vis.visit_body(mir);\n-        vis.into_map(cx, maybe_storage_live_result)\n-    }\n-\n-    /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n-    pub fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n-        self.bounded_borrowers(borrowers, borrowers, borrowed, at)\n+        let maybe_live = MaybeStorageLive::new(BitSet::new_empty(mir.local_decls.len()))\n+            .into_engine(cx.tcx, mir)\n+            .pass_name(\"possible_borrower\")\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(mir);\n+        PossibleBorrowerMap {\n+            body: mir,\n+            possible_borrower,\n+            maybe_live,\n+        }\n     }\n \n-    /// Returns true if the set of borrowers of `borrowed` living at `at` includes at least `below`\n-    /// but no more than `above`.\n-    pub fn bounded_borrowers(\n+    /// Returns true if the set of borrowers of `borrowed` living at `at` includes no more than\n+    /// `borrowers`.\n+    /// Notes:\n+    /// 1. It would be nice if `PossibleBorrowerMap` could store `cx` so that `at_most_borrowers`\n+    /// would not require it to be passed in. But a `PossibleBorrowerMap` is stored in `LintPass`\n+    /// `Dereferencing`, which outlives any `LateContext`.\n+    /// 2. In all current uses of `at_most_borrowers`, `borrowers` is a slice of at most two\n+    /// elements. Thus, `borrowers.contains(...)` is effectively a constant-time operation. If\n+    /// `at_most_borrowers`'s uses were to expand beyond this, its implementation might have to be\n+    /// adjusted.\n+    pub fn at_most_borrowers(\n         &mut self,\n-        below: &[mir::Local],\n-        above: &[mir::Local],\n+        cx: &LateContext<'tcx>,\n+        borrowers: &[mir::Local],\n         borrowed: mir::Local,\n         at: mir::Location,\n     ) -> bool {\n-        self.maybe_live.seek_after_primary_effect(at);\n+        if is_copy(cx, self.body.local_decls[borrowed].ty) {\n+            return true;\n+        }\n+\n+        self.possible_borrower.seek_before_primary_effect(at);\n+        self.maybe_live.seek_before_primary_effect(at);\n \n-        self.bitset.0.clear();\n-        let maybe_live = &mut self.maybe_live;\n-        if let Some(bitset) = self.map.get(&borrowed) {\n-            for b in bitset.iter().filter(move |b| maybe_live.contains(*b)) {\n-                self.bitset.0.insert(b);\n+        let possible_borrower = &self.possible_borrower.get().map;\n+        let maybe_live = &self.maybe_live;\n+\n+        let mut queued = BitSet::new_empty(self.body.local_decls.len());\n+        let mut deque = VecDeque::with_capacity(self.body.local_decls.len());\n+\n+        if let Some(borrowers) = possible_borrower.get(&borrowed) {\n+            for b in borrowers.iter() {\n+                if queued.insert(b) {\n+                    deque.push_back(b);\n+                }\n             }\n         } else {\n-            return false;\n+            // Nothing borrows `borrowed` at `at`.\n+            return true;\n         }\n \n-        self.bitset.1.clear();\n-        for b in below {\n-            self.bitset.1.insert(*b);\n-        }\n-\n-        if !self.bitset.0.superset(&self.bitset.1) {\n-            return false;\n-        }\n+        while let Some(borrower) = deque.pop_front() {\n+            if maybe_live.contains(borrower) && !borrowers.contains(&borrower) {\n+                return false;\n+            }\n \n-        for b in above {\n-            self.bitset.0.remove(*b);\n+            if let Some(borrowers) = possible_borrower.get(&borrower) {\n+                for b in borrowers.iter() {\n+                    if queued.insert(b) {\n+                        deque.push_back(b);\n+                    }\n+                }\n+            }\n         }\n \n-        self.bitset.0.is_empty()\n+        true\n     }\n \n     pub fn local_is_alive_at(&mut self, local: mir::Local, at: mir::Location) -> bool {"}, {"sha": "31e1cb6c3d7f7efd0e083c67233079d557f11947", "filename": "tests/ui/needless_borrow.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fneedless_borrow.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fneedless_borrow.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.fixed?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -499,6 +499,6 @@ extern crate rustc_span;\n mod span_lint {\n     use rustc_lint::{LateContext, Lint, LintContext};\n     fn foo(cx: &LateContext<'_>, lint: &'static Lint) {\n-        cx.struct_span_lint(lint, rustc_span::Span::default(), \"\", |diag| diag.note(&String::new()));\n+        cx.struct_span_lint(lint, rustc_span::Span::default(), \"\", |diag| diag.note(String::new()));\n     }\n }"}, {"sha": "98a48d68317b495e9b50713d97aa4d470e2ab4ed", "filename": "tests/ui/needless_borrow.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fneedless_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fneedless_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_borrow.stderr?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -216,5 +216,11 @@ error: the borrowed expression implements the required traits\n LL |         foo(&a);\n    |             ^^ help: change this to: `a`\n \n-error: aborting due to 36 previous errors\n+error: the borrowed expression implements the required traits\n+  --> $DIR/needless_borrow.rs:502:85\n+   |\n+LL |         cx.struct_span_lint(lint, rustc_span::Span::default(), \"\", |diag| diag.note(&String::new()));\n+   |                                                                                     ^^^^^^^^^^^^^^ help: change this to: `String::new()`\n+\n+error: aborting due to 37 previous errors\n "}, {"sha": "a157b6a6f9adbfd417b10fd0ed51734ab7f63f6f", "filename": "tests/ui/redundant_clone.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fredundant_clone.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fredundant_clone.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.fixed?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -243,5 +243,5 @@ fn false_negative_5707() {\n #[allow(unused, clippy::manual_retain)]\n fn possible_borrower_improvements() {\n     let mut s = String::from(\"foobar\");\n-    s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+    s = s.chars().filter(|&c| c != 'o').collect();\n }"}, {"sha": "1bacc2c76af1597f3b044506ed4e4f081a3b9251", "filename": "tests/ui/redundant_clone.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fredundant_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed519ad746e31f64c4e9255be561785612532d37/tests%2Fui%2Fredundant_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_clone.stderr?ref=ed519ad746e31f64c4e9255be561785612532d37", "patch": "@@ -179,5 +179,17 @@ note: this value is dropped without further use\n LL |     foo(&x.clone(), move || {\n    |          ^\n \n-error: aborting due to 15 previous errors\n+error: redundant clone\n+  --> $DIR/redundant_clone.rs:246:40\n+   |\n+LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+   |                                        ^^^^^^^^^^^ help: remove this\n+   |\n+note: this value is dropped without further use\n+  --> $DIR/redundant_clone.rs:246:9\n+   |\n+LL |     s = s.chars().filter(|&c| c != 'o').to_owned().collect();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 16 previous errors\n "}]}