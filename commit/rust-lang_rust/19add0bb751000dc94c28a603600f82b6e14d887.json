{"sha": "19add0bb751000dc94c28a603600f82b6e14d887", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YWRkMGJiNzUxMDAwZGM5NGMyOGE2MDM2MDBmODJiNmUxNGQ4ODc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-04T08:52:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-04T08:52:09Z"}, "message": "places and pointers are not the same thing; this is a place", "tree": {"sha": "60c1a8e70262111fd57ee9a655c6ab06a15a3afc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c1a8e70262111fd57ee9a655c6ab06a15a3afc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19add0bb751000dc94c28a603600f82b6e14d887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19add0bb751000dc94c28a603600f82b6e14d887", "html_url": "https://github.com/rust-lang/rust/commit/19add0bb751000dc94c28a603600f82b6e14d887", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19add0bb751000dc94c28a603600f82b6e14d887/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "html_url": "https://github.com/rust-lang/rust/commit/f47e58950bc8541a887d9e1720a5ecc9b9c346d5"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "b7a1761167d54c6d91c12a62c548a40c12df1742", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/19add0bb751000dc94c28a603600f82b6e14d887/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19add0bb751000dc94c28a603600f82b6e14d887/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=19add0bb751000dc94c28a603600f82b6e14d887", "patch": "@@ -49,83 +49,83 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"volatile_load\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(ptr.into(), dest)?;\n+                let place = this.deref_operand(args[0])?;\n+                this.copy_op(place.into(), dest)?;\n             }\n \n             \"volatile_store\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(args[1], ptr.into())?;\n+                let place = this.deref_operand(args[0])?;\n+                this.copy_op(args[1], place.into())?;\n             }\n \n             \"atomic_load\" |\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                let val = this.read_scalar(ptr.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n+                let place = this.deref_operand(args[0])?;\n+                let val = this.read_scalar(place.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n-                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_scalar(val, dest)?;\n             }\n \n             \"atomic_store\" |\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" => {\n-                let ptr = this.deref_operand(args[0])?;\n+                let place = this.deref_operand(args[0])?;\n                 let val = this.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n-                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n \n-                this.write_scalar(val, ptr.into())?;\n+                this.write_scalar(val, place.into())?;\n             }\n \n             \"atomic_fence_acq\" => {\n                 // we are inherently singlethreaded and singlecored, this is a nop\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_xchg\") => {\n-                let ptr = this.deref_operand(args[0])?;\n+                let place = this.deref_operand(args[0])?;\n                 let new = this.read_scalar(args[1])?;\n-                let old = this.read_scalar(ptr.into())?;\n+                let old = this.read_scalar(place.into())?;\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n-                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_scalar(old, dest)?; // old value is returned\n-                this.write_scalar(new, ptr.into())?;\n+                this.write_scalar(new, place.into())?;\n             }\n \n             _ if intrinsic_name.starts_with(\"atomic_cxchg\") => {\n-                let ptr = this.deref_operand(args[0])?;\n+                let place = this.deref_operand(args[0])?;\n                 let expect_old = this.read_immediate(args[1])?; // read as immediate for the sake of `binary_op()`\n                 let new = this.read_scalar(args[2])?;\n-                let old = this.read_immediate(ptr.into())?; // read as immediate for the sake of `binary_op()`\n+                let old = this.read_immediate(place.into())?; // read as immediate for the sake of `binary_op()`\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n-                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 // binary_op will bail if either of them is not a scalar\n                 let (eq, _) = this.binary_op(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n                 this.write_immediate(res, dest)?; // old value is returned\n                 // update ptr depending on comparison\n                 if eq.to_bool()? {\n-                    this.write_scalar(new, ptr.into())?;\n+                    this.write_scalar(new, place.into())?;\n                 }\n             }\n \n@@ -159,18 +159,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             \"atomic_xsub_rel\" |\n             \"atomic_xsub_acqrel\" |\n             \"atomic_xsub_relaxed\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                if !ptr.layout.ty.is_integral() {\n+                let place = this.deref_operand(args[0])?;\n+                if !place.layout.ty.is_integral() {\n                     bug!(\"Atomic arithmetic operations only work on integer types\");\n                 }\n                 let rhs = this.read_immediate(args[1])?;\n-                let old = this.read_immediate(ptr.into())?;\n+                let old = this.read_immediate(place.into())?;\n \n                 // Check alignment requirements. Atomics must always be aligned to their size,\n                 // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n                 // be 8-aligned).\n-                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n-                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+                let align = Align::from_bytes(place.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(place.ptr, place.layout.size, align)?;\n \n                 this.write_immediate(*old, dest)?; // old value is returned\n                 let (op, neg) = match intrinsic_name.split('_').nth(1).unwrap() {\n@@ -189,7 +189,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 } else {\n                     val\n                 };\n-                this.write_scalar(val, ptr.into())?;\n+                this.write_scalar(val, place.into())?;\n             }\n \n             \"breakpoint\" => unimplemented!(), // halt miri"}]}