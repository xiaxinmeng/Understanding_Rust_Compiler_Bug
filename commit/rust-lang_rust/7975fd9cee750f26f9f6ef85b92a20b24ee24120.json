{"sha": "7975fd9cee750f26f9f6ef85b92a20b24ee24120", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5NzVmZDljZWU3NTBmMjZmOWY2ZWY4NWI5MmEyMGIyNGVlMjQxMjA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T03:01:17Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-06T03:01:17Z"}, "message": "rollup merge of #20482: kmcallister/macro-reform\n\nConflicts:\n\tsrc/libflate/lib.rs\n\tsrc/libstd/lib.rs\n\tsrc/libstd/macros.rs\n\tsrc/libsyntax/feature_gate.rs\n\tsrc/libsyntax/parse/parser.rs\n\tsrc/libsyntax/show_span.rs\n\tsrc/test/auxiliary/macro_crate_test.rs\n\tsrc/test/compile-fail/lint-stability.rs\n\tsrc/test/run-pass/intrinsics-math.rs\n\tsrc/test/run-pass/tcp-connect-timeouts.rs", "tree": {"sha": "0c36840cd8bf89ad1f662ed81d8e71c93e22c41e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c36840cd8bf89ad1f662ed81d8e71c93e22c41e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7975fd9cee750f26f9f6ef85b92a20b24ee24120", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7975fd9cee750f26f9f6ef85b92a20b24ee24120", "html_url": "https://github.com/rust-lang/rust/commit/7975fd9cee750f26f9f6ef85b92a20b24ee24120", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7975fd9cee750f26f9f6ef85b92a20b24ee24120/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "563f6d8218cf15bf2590507c38ce4cbb734d6bba", "url": "https://api.github.com/repos/rust-lang/rust/commits/563f6d8218cf15bf2590507c38ce4cbb734d6bba", "html_url": "https://github.com/rust-lang/rust/commit/563f6d8218cf15bf2590507c38ce4cbb734d6bba"}, {"sha": "78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "html_url": "https://github.com/rust-lang/rust/commit/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7"}], "stats": {"total": 5043, "additions": 3445, "deletions": 1598}, "files": [{"sha": "0ce31a335d8ab7d698804a6ed7efd31172d23a67", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -15,7 +15,14 @@\n \n extern crate test;\n extern crate getopts;\n-#[phase(plugin, link)] extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n \n extern crate regex;\n "}, {"sha": "dc6d281307a7a602e746a599b78f16961f628da9", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 97, "deletions": 58, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -1,14 +1,5 @@\n % The Rust Macros Guide\n \n-<div class=\"unstable-feature\">\n-<b>Warning:</b> There are currently various problems with invoking macros, how\n-they interact with their environment, and how they are used outside of the\n-location in which they are defined. Macro definitions are likely to change\n-slightly in the future. For this reason, they are hidden behind the\n-<code>macro_rules</code> <a href=\"reference.html#compiler-features\">feature\n-attribute</a>.\n-</div>\n-\n # Introduction\n \n Functions are the primary tool that programmers can use to build abstractions.\n@@ -46,19 +37,18 @@ lightweight custom syntax extensions, themselves defined using the\n the pattern in the above code:\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T { SpecialA(uint), SpecialB(uint) }\n # fn f() -> uint {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n-macro_rules! early_return(\n+macro_rules! early_return {\n     ($inp:expr $sp:path) => ( // invoke it like `(input_5 SpecialE)`\n         match $inp {\n             $sp(x) => { return x; }\n             _ => {}\n         }\n     );\n-);\n+}\n // ...\n early_return!(input_1 T::SpecialA);\n // ...\n@@ -109,10 +99,10 @@ that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n ## Invocation location\n \n-A macro invocation may take the place of (and therefore expand to)\n-an expression, an item, or a statement.\n-The Rust parser will parse the macro invocation as a \"placeholder\"\n-for whichever of those three nonterminals is appropriate for the location.\n+A macro invocation may take the place of (and therefore expand to) an\n+expression, item, statement, or pattern.  The Rust parser will parse the macro\n+invocation as a \"placeholder\" for whichever syntactic form is appropriate for\n+the location.\n \n At expansion time, the output of the macro will be parsed as whichever of the\n three nonterminals it stands in for. This means that a single macro might,\n@@ -166,12 +156,11 @@ separator token (a comma-separated list could be written `$(...),*`), and `+`\n instead of `*` to mean \"at least one\".\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)}\n # fn f() -> uint {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n-macro_rules! early_return(\n+macro_rules! early_return {\n     ($inp:expr, [ $($sp:path)|+ ]) => (\n         match $inp {\n             $(\n@@ -180,7 +169,7 @@ macro_rules! early_return(\n             _ => {}\n         }\n     )\n-);\n+}\n // ...\n early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n // ...\n@@ -228,7 +217,6 @@ solves the problem.\n Now consider code like the following:\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n@@ -255,8 +243,7 @@ a match, but with a syntax that suits the problem better. The following macro\n can solve the problem:\n \n ~~~~\n-# #![feature(macro_rules)]\n-macro_rules! biased_match (\n+macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n       binds $bind_res:ident\n@@ -275,7 +262,7 @@ macro_rules! biased_match (\n             _ => { $err }\n         };\n     )\n-);\n+}\n \n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n@@ -297,13 +284,12 @@ like this, we might prefer to write a single macro invocation. The input\n pattern we want is clear:\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {}\n-# macro_rules! b(\n+# macro_rules! b {\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n-# => (0));\n+# => (0) }\n ~~~~\n \n However, it's not possible to directly expand to nested match statements. But\n@@ -320,35 +306,32 @@ process the semicolon-terminated lines, one-by-one. So, we want the following\n input patterns:\n \n ~~~~\n-# #![feature(macro_rules)]\n-# macro_rules! b(\n+# macro_rules! b {\n     ( binds $( $bind_res:ident ),* )\n-# => (0));\n+# => (0) }\n # fn main() {}\n ~~~~\n \n ...and:\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {}\n-# macro_rules! b(\n+# macro_rules! b {\n     (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n       $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n-# => (0));\n+# => (0) }\n ~~~~\n \n The resulting macro looks like this. Note that the separation into\n `biased_match!` and `biased_match_rec!` occurs only because we have an outer\n piece of syntax (the `let`) which we only want to transcribe once.\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {\n \n-macro_rules! biased_match_rec (\n+macro_rules! biased_match_rec {\n     // Handle the first layer\n     (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n@@ -366,10 +349,10 @@ macro_rules! biased_match_rec (\n     );\n     // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-);\n+}\n \n // Wrap the whole thing in a `let`.\n-macro_rules! biased_match (\n+macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n@@ -388,7 +371,7 @@ macro_rules! biased_match (\n             binds $( $bind_res ),*\n         );\n     )\n-);\n+}\n \n \n # enum T1 { Good1(T2, uint), Bad1}\n@@ -434,17 +417,15 @@ As an example, `loop` and `for-loop` labels (discussed in the lifetimes guide)\n will not clash. The following code will print \"Hello!\" only once:\n \n ~~~\n-#![feature(macro_rules)]\n-\n-macro_rules! loop_x (\n+macro_rules! loop_x {\n     ($e: expr) => (\n         // $e will not interact with this 'x\n         'x: loop {\n             println!(\"Hello!\");\n             $e\n         }\n     );\n-);\n+}\n \n fn main() {\n     'x: loop {\n@@ -467,45 +448,53 @@ lexical-order traversal of a crate's source. So a macro defined at module scope\n is visible to any subsequent code in the same module, which includes the body\n of any subsequent child `mod` items.\n \n-If a module has the `macro_escape` attribute, its macros are also visible in\n-its parent module after the child's `mod` item. If the parent also has\n-`macro_escape` then the macros will be visible in the grandparent after the\n-parent's `mod` item, and so forth.\n+If a module has the `macro_use` attribute, its macros are also visible in its\n+parent module after the child's `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent's `mod`\n+item, and so forth.\n \n-Independent of `macro_escape`, the `macro_export` attribute controls visibility\n-between crates.  Any `macro_rules!` definition with the `macro_export`\n-attribute will be visible to other crates that have loaded this crate with\n-`phase(plugin)`. There is currently no way for the importing crate to control\n-which macros are imported.\n+The `macro_use` attribute can also appear on `extern crate`.  In this context\n+it controls which macros are loaded from the external crate, e.g.\n+\n+```rust,ignore\n+#[macro_use(foo, bar)]\n+extern crate baz;\n+```\n+\n+If the attribute is given simply as `#[macro_use]`, all macros are loaded.  If\n+there is no `#[macro_use]` attribute then no macros are loaded.  Only macros\n+defined with the `#[macro_export]` attribute may be loaded.\n+\n+To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+as well.\n \n An example:\n \n ```rust\n-# #![feature(macro_rules)]\n-macro_rules! m1 (() => (()));\n+macro_rules! m1 { () => (()) }\n \n // visible here: m1\n \n mod foo {\n     // visible here: m1\n \n     #[macro_export]\n-    macro_rules! m2 (() => (()));\n+    macro_rules! m2 { () => (()) }\n \n     // visible here: m1, m2\n }\n \n // visible here: m1\n \n-macro_rules! m3 (() => (()));\n+macro_rules! m3 { () => (()) }\n \n // visible here: m1, m3\n \n-#[macro_escape]\n+#[macro_use]\n mod bar {\n     // visible here: m1, m3\n \n-    macro_rules! m4 (() => (()));\n+    macro_rules! m4 { () => (()) }\n \n     // visible here: m1, m3, m4\n }\n@@ -514,8 +503,58 @@ mod bar {\n # fn main() { }\n ```\n \n-When this library is loaded with `#[phase(plugin)] extern crate`, only `m2`\n-will be imported.\n+When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n+be imported.\n+\n+The Rust Reference has a [listing of macro-related\n+attributes](reference.html#macro--and-plugin-related-attributes).\n+\n+# The variable `$crate`\n+\n+A further difficulty occurs when a macro is used in multiple crates.  Say that\n+`mylib` defines\n+\n+```rust\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! inc_a {\n+    ($x:expr) => ( ::increment($x) )\n+}\n+\n+#[macro_export]\n+macro_rules! inc_b {\n+    ($x:expr) => ( ::mylib::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+`inc_a` only works within `mylib`, while `inc_b` only works outside the\n+library.  Furthermore, `inc_b` will break if the user imports `mylib` under\n+another name.\n+\n+Rust does not (yet) have a hygiene system for crate references, but it does\n+provide a simple workaround for this problem.  Within a macro imported from a\n+crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n+By contrast, when a macro is defined and then used in the same crate, `$crate`\n+will expand to nothing.  This means we can write\n+\n+```rust\n+#[macro_export]\n+macro_rules! inc {\n+    ($x:expr) => ( $crate::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+to define a single macro that works both inside and outside our library.  The\n+function name will expand to either `::increment` or `::mylib::increment`.\n+\n+To keep this system simple and correct, `#[macro_use] extern crate ...` may\n+only appear at the root of your crate, not inside `mod`.  This ensures that\n+`$crate` is a single identifier.\n \n # A final note\n "}, {"sha": "025f0cced63a6a6cb6b3dd37f793ecd07ba84a99", "filename": "src/doc/guide-plugin.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fdoc%2Fguide-plugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fdoc%2Fguide-plugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-plugin.md?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -31,10 +31,14 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n \n A plugin is a dynamic library crate with a designated \"registrar\" function that\n registers extensions with `rustc`. Other crates can use these extensions by\n-loading the plugin crate with `#[phase(plugin)] extern crate`. See the\n+loading the plugin crate with `#[plugin] extern crate`. See the\n [`rustc::plugin`](rustc/plugin/index.html) documentation for more about the\n mechanics of defining and loading a plugin.\n \n+Arguments passed as `#[plugin=...]` or `#[plugin(...)]` are not interpreted by\n+rustc itself.  They are provided to the plugin through the `Registry`'s [`args`\n+method](rustc/plugin/registry/struct.Registry.html#method.args).\n+\n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n@@ -105,10 +109,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n Then we can use `rn!()` like any other macro:\n \n ```ignore\n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n-extern crate roman_numerals;\n+#[plugin] extern crate roman_numerals;\n \n fn main() {\n     assert_eq!(rn!(MMXV), 2015);\n@@ -217,8 +220,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n Then code like\n \n ```ignore\n-#[phase(plugin)]\n-extern crate lint_plugin_test;\n+#[plugin] extern crate lint_plugin_test;\n \n fn lintme() { }\n ```"}, {"sha": "0f1f26d3e711c8f2d75d3250fef6178e2d61a243", "filename": "src/doc/reference.md", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -193,12 +193,12 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n | break    | const    | continue | crate    | do      |\n | else     | enum     | extern   | false    | final   |\n | fn       | for      | if       | impl     | in      |\n-| let      | loop     | match    | mod      | move    |\n-| mut      | offsetof | override | priv     | pub     |\n-| pure     | ref      | return   | sizeof   | static  |\n-| self     | struct   | super    | true     | trait   |\n-| type     | typeof   | unsafe   | unsized  | use     |\n-| virtual  | where    | while    | yield    |\n+| let      | loop     | macro    | match    | mod     |\n+| move     | mut      | offsetof | override | priv    |\n+| pub      | pure     | ref      | return   | sizeof  |\n+| static   | self     | struct   | super    | true    |\n+| trait    | type     | typeof   | unsafe   | unsized |\n+| use      | virtual  | where    | while    | yield   |\n \n \n Each of these keywords has special meaning in its grammar, and all of them are\n@@ -668,9 +668,11 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n             | non_special_token ;\n ```\n \n-User-defined syntax extensions are called \"macros\", and the `macro_rules`\n-syntax extension defines them. Currently, user-defined macros can expand to\n-expressions, statements, items, or patterns.\n+`macro_rules` allows users to define syntax extension in a declarative way.  We\n+call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n+from the \"procedural macros\" defined in [compiler plugins][plugin].\n+\n+Currently, macros can expand to expressions, statements, items, or patterns.\n \n (A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n any token other than a delimiter or `$`.)\n@@ -2002,8 +2004,6 @@ type int8_t = i8;\n \n ### Module-only attributes\n \n-- `macro_escape` - macros defined in this module will be visible in the\n-  module's parent, after this module has been included.\n - `no_implicit_prelude` - disable injecting `use std::prelude::*` in this\n   module.\n - `path` - specifies the file to load the module from. `#[path=\"foo.rs\"] mod\n@@ -2066,23 +2066,43 @@ On `struct`s:\n   remove any padding between fields (note that this is very fragile and may\n   break platforms which require aligned access).\n \n+### Macro- and plugin-related attributes\n+\n+- `macro_use` on a `mod` \u2014 macros defined in this module will be visible in the\n+  module's parent, after this module has been included.\n+\n+- `macro_use` on an `extern crate` \u2014 load macros from this crate.  An optional\n+  list of names `#[macro_use(foo, bar)]` restricts the import to just those\n+  macros named.  The `extern crate` must appear at the crate root, not inside\n+  `mod`, which ensures proper function of the [`$crate` macro\n+  variable](guide-macros.html#the-variable-$crate).\n+\n+- `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n+\n+- `macro_export` - export a macro for cross-crate usage.\n+\n+- `plugin` on an `extern crate`\u00a0\u2014 load this crate as a [compiler\n+  plugin][plugin].  The `plugin` feature gate is required.  Any arguments to\n+  the attribute, e.g. `#[plugin=...]` or `#[plugin(...)]`, are provided to the\n+  plugin.\n+\n+- `no_link` on an `extern crate` \u2014 even if we load this crate for macros or\n+  compiler plugins, don't link it into the output.\n+\n+See the [macros guide](guide-macros.html#scoping-and-macro-import/export) for\n+more information on macro scope.\n+\n+\n ### Miscellaneous attributes\n \n - `export_name` - on statics and functions, this determines the name of the\n   exported symbol.\n - `link_section` - on statics and functions, this specifies the section of the\n   object file that this item's contents will be placed into.\n-- `macro_export` - export a macro for cross-crate usage.\n - `no_mangle` - on any item, do not apply the standard name mangling. Set the\n   symbol for this item to its identifier.\n - `packed` - on structs or enums, eliminate any padding that would be used to\n   align fields.\n-- `phase` - on `extern crate` statements, allows specifying which \"phase\" of\n-  compilation the crate should be loaded for. Currently, there are two\n-  choices: `link` and `plugin`. `link` is the default. `plugin` will [load the\n-  crate at compile-time][plugin] and use any syntax extensions or lints that the crate\n-  defines. They can both be specified, `#[phase(link, plugin)]` to use a crate\n-  both at runtime and compiletime.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n@@ -2569,15 +2589,6 @@ The currently implemented features of the reference compiler are:\n * `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n                  nasty hack that will certainly be removed.\n \n-* `macro_rules` - The definition of new macros. This does not encompass\n-                  macro-invocation, that is always enabled by default, this\n-                  only covers the definition of new macros. There are currently\n-                  various problems with invoking macros, how they interact with\n-                  their environment, and possibly how they are used outside of\n-                  location in which they are defined. Macro definitions are\n-                  likely to change slightly in the future, so they are\n-                  currently hidden behind this feature.\n-\n * `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n                        but the implementation is a little rough around the\n                        edges, so this can be seen as an experimental feature\n@@ -2588,15 +2599,10 @@ The currently implemented features of the reference compiler are:\n                closure as `once` is unlikely to be supported going forward. So\n                they are hidden behind this feature until they are to be removed.\n \n-* `phase` - Usage of the `#[phase]` attribute allows loading compiler plugins\n-            for custom lints or syntax extensions. The implementation is\n-            considered unwholesome and in need of overhaul, and it is not clear\n-            what they will look like moving forward.\n+* `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n+             These depend on compiler internals and are subject to change.\n \n-* `plugin_registrar` - Indicates that a crate has [compiler plugins][plugin] that it\n-                       wants to load. As with `phase`, the implementation is\n-                       in need of an overhaul, and it is not clear that plugins\n-                       defined using this will continue to work.\n+* `plugin_registrar` - Indicates that a crate provides [compiler plugins][plugin].\n \n * `quote` - Allows use of the `quote_*!` family of macros, which are\n             implemented very poorly and will likely change significantly"}, {"sha": "dce6d3f66879e3cca1d93594a22ad555fda3b650", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -56,7 +56,7 @@ syn match rustMacroRepeatCount \".\\?[*+]\" contained\n syn match rustMacroVariable \"$\\w\\+\"\n \n \" Reserved (but not yet used) keywords {{{2\n-syn keyword   rustReservedKeyword alignof be do offsetof priv pure sizeof typeof unsized yield abstract final override\n+syn keyword   rustReservedKeyword alignof be do offsetof priv pure sizeof typeof unsized yield abstract final override macro\n \n \" Built-in types {{{2\n syn keyword   rustType        int uint float char bool u8 u16 u32 u64 f32"}, {"sha": "9194c7a47663d66e343750d8c515e39da09b8c8a", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,15 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(globs, phase, macro_rules)]\n+#![feature(globs, plugin)]\n \n extern crate syntax;\n extern crate rustc;\n \n-#[phase(link)]\n extern crate regex;\n \n-#[phase(link, plugin)]\n+#[macro_use]\n extern crate log;\n \n use std::collections::HashMap;\n@@ -269,7 +268,7 @@ fn main() {\n         assert!(rustc_tok.sp == antlr_tok.sp, \"{} and {} have different spans\", rustc_tok,\n                 antlr_tok);\n \n-        macro_rules! matches (\n+        macro_rules! matches {\n             ( $($x:pat),+ ) => (\n                 match rustc_tok.tok {\n                     $($x => match antlr_tok.tok {\n@@ -285,7 +284,7 @@ fn main() {\n                     ref c => assert!(c == &antlr_tok.tok, \"{} is not {}\", rustc_tok, antlr_tok)\n                 }\n             )\n-        );\n+        }\n \n         matches!(\n             token::Literal(token::Byte(..), _),"}, {"sha": "001e02f9c0dd5c29cc91e2f0f25ecd51b4697e86", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -68,14 +68,33 @@\n #![feature(lang_items, phase, unsafe_destructor, default_type_params, old_orphan_check)]\n #![feature(associated_types)]\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate core;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate core;\n+\n extern crate libc;\n \n // Allow testing this library\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate std;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate std;\n+\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n \n // Heaps provided for low-level allocation strategies\n "}, {"sha": "5bf5f78af94c272381f14d4581bdb9b1946d9c00", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -29,15 +29,34 @@\n #![feature(associated_types)]\n #![no_std]\n \n-#[phase(plugin, link)] extern crate core;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate core;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate core;\n+\n extern crate unicode;\n extern crate alloc;\n \n #[cfg(test)] extern crate test;\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate std;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate std;\n \n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n \n pub use binary_heap::BinaryHeap;\n pub use bitv::Bitv;\n@@ -51,6 +70,11 @@ pub use string::String;\n pub use vec::Vec;\n pub use vec_map::VecMap;\n \n+// Needed for the vec! macro\n+pub use alloc::boxed;\n+\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n \n pub mod binary_heap;"}, {"sha": "0c5929e8661d6d22870fbab4f215118834675009", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n /// Creates a `std::vec::Vec` containing the arguments.\n+// NOTE: remove after the next snapshot\n+#[cfg(stage0)]\n macro_rules! vec {\n     ($($e:expr),*) => ({\n         // leading _ to allow empty construction without a warning.\n@@ -21,3 +21,13 @@ macro_rules! vec {\n     ($($e:expr),+,) => (vec!($($e),+))\n }\n \n+/// Creates a `Vec` containing the arguments.\n+#[cfg(not(stage0))]\n+#[macro_export]\n+macro_rules! vec {\n+    ($($x:expr),*) => ({\n+        let xs: $crate::boxed::Box<[_]> = box [$($x),*];\n+        $crate::slice::SliceExt::into_vec(xs)\n+    });\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}"}, {"sha": "1cb9e9009db62bd8c30ee33e496ed73d585cee57", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -2598,13 +2598,13 @@ mod tests {\n \n     #[test]\n     fn test_show() {\n-        macro_rules! test_show_vec(\n+        macro_rules! test_show_vec {\n             ($x:expr, $x_str:expr) => ({\n                 let (x, x_str) = ($x, $x_str);\n                 assert_eq!(format!(\"{}\", x), x_str);\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n-        );\n+        }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1i], \"[1]\");\n@@ -2624,12 +2624,12 @@ mod tests {\n \n     #[test]\n     fn test_vec_default() {\n-        macro_rules! t (\n+        macro_rules! t {\n             ($ty:ty) => {{\n                 let v: $ty = Default::default();\n                 assert!(v.is_empty());\n             }}\n-        );\n+        }\n \n         t!(&[int]);\n         t!(Vec<int>);"}, {"sha": "c0482702ccdb66c1a6ee149ebaa0811d7a66808b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -1846,7 +1846,9 @@ mod tests {\n     #[test]\n     fn test_is_utf16() {\n         use unicode::str::is_utf16;\n-        macro_rules! pos ( ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } });\n+        macro_rules! pos {\n+            ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } }\n+        }\n \n         // non-surrogates\n         pos!(&[0x0000],\n@@ -1866,7 +1868,9 @@ mod tests {\n              &[0x0067, 0xd8ff, 0xddb7, 0x000f, 0xd900, 0xdc80]);\n \n         // negative tests\n-        macro_rules! neg ( ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } });\n+        macro_rules! neg {\n+            ($($e:expr),*) => { { $(assert!(!is_utf16($e));)* } }\n+        }\n \n         neg!(\n             // surrogate + regular unit"}, {"sha": "0bf311e4d3f6e5674bc1eb9fd32f097087bea6e4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -182,15 +182,15 @@ impl String {\n             let byte = unsafe_get(v, i);\n             i += 1;\n \n-            macro_rules! error(() => ({\n+            macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n                         res.as_mut_vec().push_all(v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n                 }\n-            }));\n+            })}\n \n             if byte < 128u8 {\n                 // subseqidx handles this"}, {"sha": "951f5c29f00e8c923c5520e0bb9c0c341360f7b7", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -20,12 +20,15 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use ops::{Deref, FnOnce};\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n use result;\n use slice::SliceExt;\n use slice;\n use str::{self, StrExt, Utf8Error};\n \n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n+\n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;"}, {"sha": "aff0065c52744d8d8430b8d7b9c69ef9125213cd", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -62,11 +62,24 @@\n #![feature(default_type_params, unboxed_closures, associated_types)]\n #![deny(missing_docs)]\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n \n-#[path = \"num/float_macros.rs\"] mod float_macros;\n-#[path = \"num/int_macros.rs\"]   mod int_macros;\n-#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+#[path = \"num/float_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod float_macros;\n+\n+#[path = \"num/int_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod int_macros;\n+\n+#[path = \"num/uint_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n@@ -130,6 +143,7 @@ mod array;\n #[doc(hidden)]\n mod core {\n     pub use panicking;\n+    pub use fmt;\n }\n \n #[doc(hidden)]"}, {"sha": "a579f9db4161c3a8f04b1742a1f53d1602a7e96a", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 177, "deletions": 24, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n macro_rules! panic {\n@@ -30,69 +28,224 @@ macro_rules! panic {\n     });\n }\n \n-/// Runtime assertion, for details see std::macros\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n         }\n     );\n-    ($cond:expr, $($arg:tt)*) => (\n+    ($cond:expr, $($arg:expr),+) => (\n         if !$cond {\n-            panic!($($arg)*)\n+            panic!($($arg),+)\n         }\n     );\n }\n \n-/// Runtime assertion for equality, for details see std::macros\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! assert_eq {\n-    ($cond1:expr, $cond2:expr) => ({\n-        let c1 = $cond1;\n-        let c2 = $cond2;\n-        if c1 != c2 || c2 != c1 {\n-            panic!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n+    ($left:expr , $right:expr) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                // check both directions of equality....\n+                if !((*left_val == *right_val) &&\n+                     (*right_val == *left_val)) {\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                }\n+            }\n         }\n     })\n }\n \n-/// Runtime assertion for equality, only without `--cfg ndebug`\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n+/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// debug_assert!(true);\n+/// # fn some_expensive_computation() -> bool { true }\n+/// debug_assert!(some_expensive_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// debug_assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n+/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n+/// useful for checks that are too expensive to be present in a release build\n+/// but may be helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// debug_assert_eq!(a, b);\n+/// ```\n #[macro_export]\n macro_rules! debug_assert_eq {\n-    ($($a:tt)*) => ({\n-        if cfg!(not(ndebug)) {\n-            assert_eq!($($a)*);\n-        }\n-    })\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n }\n \n-/// Runtime assertion, disableable at compile time with `--cfg ndebug`\n+#[cfg(stage0)]\n #[macro_export]\n-macro_rules! debug_assert {\n-    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+macro_rules! try {\n+    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n }\n \n /// Short circuiting evaluation on Err\n+///\n+/// `libstd` contains a more general `try!` macro that uses `FromError`.\n+#[cfg(not(stage0))]\n #[macro_export]\n macro_rules! try {\n-    ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n+    ($e:expr) => ({\n+        use $crate::result::Result::{Ok, Err};\n+\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(e),\n+        }\n+    })\n }\n \n-/// Writing a formatted string into a writer\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n #[macro_export]\n macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n }\n \n-/// Writing a formatted string plus a newline into a writer\n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n #[macro_export]\n+#[stable]\n macro_rules! writeln {\n     ($dst:expr, $fmt:expr $($arg:tt)*) => (\n         write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n     )\n }\n \n+/// A utility macro for indicating unreachable code.\n+///\n+/// This is useful any time that the compiler can't determine that some code is unreachable. For\n+/// example:\n+///\n+/// * Match arms with guard conditions.\n+/// * Loops that dynamically terminate.\n+/// * Iterators that dynamically terminate.\n+///\n+/// # Panics\n+///\n+/// This will always panic.\n+///\n+/// # Examples\n+///\n+/// Match arms:\n+///\n+/// ```rust\n+/// fn foo(x: Option<int>) {\n+///     match x {\n+///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n+///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n+///         Some(_)           => unreachable!(), // compile error if commented out\n+///         None              => println!(\"None\")\n+///     }\n+/// }\n+/// ```\n+///\n+/// Iterators:\n+///\n+/// ```rust\n+/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n+///     for i in std::iter::count(0_u32, 1) {\n+///         if 3*i < i { panic!(\"u32 overflow\"); }\n+///         if x < 3*i { return i-1; }\n+///     }\n+///     unreachable!();\n+/// }\n+/// ```\n #[macro_export]\n-macro_rules! unreachable { () => (panic!(\"unreachable code\")) }\n+macro_rules! unreachable {\n+    () => ({\n+        panic!(\"internal error: entered unreachable code\")\n+    });\n+    ($msg:expr) => ({\n+        unreachable!(\"{}\", $msg)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+    });\n+}\n \n+/// A standardised placeholder for marking unfinished code. It panics with the\n+/// message `\"not yet implemented\"` when executed.\n+#[macro_export]\n+macro_rules! unimplemented {\n+    () => (panic!(\"not yet implemented\"))\n+}"}, {"sha": "20300d29fa0c5f1e66e5d255eb79bc5b1c11ed17", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "61cd8cbf7c10153da90d5f0da64168ae845e5e1a", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty, $bits:expr) => ("}, {"sha": "535765840a0fcacc345b9065311456d9e644bdf7", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => ("}, {"sha": "8e9bf5487e3ed1faa974a1a3e04a6d8944af98a3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -220,9 +220,9 @@\n //!\n //! ```\n //! # #![feature(macro_rules)]\n-//! macro_rules! try(\n+//! macro_rules! try {\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-//! );\n+//! }\n //! # fn main() { }\n //! ```\n //!"}, {"sha": "a39787b8207b5161c2fcbdb54c899d0829a93e11", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -964,17 +964,18 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         let old = *iter;\n \n         // restore the iterator we had at the start of this codepoint.\n-        macro_rules! err (() => { {\n+        macro_rules! err { () => {{\n             *iter = old;\n             return Err(Utf8Error::InvalidByte(whole.len() - iter.as_slice().len()))\n-        } });\n-        macro_rules! next ( () => {\n+        }}}\n+\n+        macro_rules! next { () => {\n             match iter.next() {\n                 Some(a) => *a,\n                 // we needed data, but there was none: error!\n                 None => return Err(Utf8Error::TooShort),\n             }\n-        });\n+        }}\n \n         let first = match iter.next() {\n             Some(&b) => b,"}, {"sha": "50ae59e70dc930ec32e21d96a444345b4b8f1bc9", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -7,7 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, unsafe_destructor, macro_rules, slicing_syntax, default_type_params)]\n+#![feature(globs, unsafe_destructor, slicing_syntax, default_type_params)]\n #![feature(unboxed_closures)]\n \n extern crate core;"}, {"sha": "b98432e26b215c739066af43918ea4f20ee76f8e", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n-macro_rules! int_module (($T:ty, $T_i:ident) => (\n+macro_rules! int_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n@@ -205,4 +203,4 @@ mod tests {\n     }\n }\n \n-));\n+)}"}, {"sha": "f86c85f821638f98813ab459ea8dab0293e00331", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -14,13 +14,20 @@ use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::kinds::Copy;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod int_macros;\n+\n mod i8;\n mod i16;\n mod i32;\n mod i64;\n mod int;\n+\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod uint_macros;\n+\n mod u8;\n mod u16;\n mod u32;"}, {"sha": "04d8fb15cf5aa41715d3043adf44c0fc95805c23", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n-macro_rules! uint_module (($T:ty, $T_i:ident) => (\n+macro_rules! uint_module { ($T:ty, $T_i:ident) => (\n #[cfg(test)]\n mod tests {\n     use core::$T_i::*;\n@@ -125,4 +123,5 @@ mod tests {\n         assert!(5u.checked_div(0) == None);\n     }\n }\n-));\n+\n+)}"}, {"sha": "6ac311fe4b646ae2f5d9a8ae5642a8b5f0fd6e11", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -21,9 +21,9 @@\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(phase, unboxed_closures, associated_types)]\n+#![feature(unboxed_closures, associated_types)]\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n extern crate libc;\n "}, {"sha": "917c6e99992f24c2aa084a23d03352b695516cb4", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -23,7 +23,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(macro_rules, globs, slicing_syntax)]\n+#![feature(globs, slicing_syntax)]\n #![feature(associated_types)]\n \n pub use self::Piece::*;"}, {"sha": "18077795e245f16dda711c3bc2c62a0373e86d83", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -85,11 +85,11 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(globs, phase, slicing_syntax)]\n+#![feature(globs, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![deny(missing_docs)]\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(test)] #[macro_use] extern crate log;\n \n use self::Name::*;\n use self::HasArg::*;"}, {"sha": "df85e89efd17c5a805f46094b1766e0ba76be7e7", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,7 @@\n //! # Examples\n //!\n //! ```\n-//! #![feature(phase)]\n-//! #[phase(plugin, link)] extern crate log;\n+//! #[macro_use] extern crate log;\n //!\n //! fn main() {\n //!     debug!(\"this is a debug {}\", \"message\");\n@@ -183,7 +182,10 @@ use regex::Regex;\n \n use directive::LOG_LEVEL_NAMES;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod macros;\n+\n mod directive;\n \n /// Maximum logging level of a module that can be specified. Common logging"}, {"sha": "5c7085b7b6c5f8909a451fcaf892ba473d66b6a7", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,6 @@\n \n //! Logging macros\n \n-#![macro_escape]\n-\n /// The standard logging macro\n ///\n /// This macro will generically log over a provided level (of type u32) with a\n@@ -21,8 +19,7 @@\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     log!(log::WARN, \"this is a warning {}\", \"message\");\n@@ -70,8 +67,7 @@ macro_rules! log {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     let error = 3u;\n@@ -96,8 +92,7 @@ macro_rules! error {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     let code = 3u;\n@@ -121,8 +116,7 @@ macro_rules! warn {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     let ret = 3;\n@@ -148,8 +142,7 @@ macro_rules! info {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// fn main() {\n ///     debug!(\"x = {x}, y = {y}\", x=10, y=20);\n@@ -172,8 +165,7 @@ macro_rules! debug {\n /// # Example\n ///\n /// ```\n-/// #![feature(phase)]\n-/// #[phase(plugin, link)] extern crate log;\n+/// #[macro_use] extern crate log;\n ///\n /// struct Point { x: int, y: int }\n /// fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }"}, {"sha": "2fdba8a6c4f960358a1c064d4d6ec7561cdb06ef", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -297,7 +297,7 @@ mod tests {\n         // it doesn't do weird things to the RNG (so 0 maps to 0, 1 to\n         // 1, internally; modulo a modulo operation).\n \n-        macro_rules! t (\n+        macro_rules! t {\n             ($items:expr, $expected:expr) => {{\n                 let mut items = $items;\n                 let wc = WeightedChoice::new(items.as_mut_slice());\n@@ -309,7 +309,7 @@ mod tests {\n                     assert_eq!(wc.ind_sample(&mut rng), val)\n                 }\n             }}\n-        );\n+        }\n \n         t!(vec!(Weighted { weight: 1, item: 10i}), [10]);\n "}, {"sha": "1038009522d67313af1e85c46f03d166a2f9222e", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -182,7 +182,7 @@ mod tests {\n     #[test]\n     fn test_integers() {\n         let mut rng = ::test::rng();\n-        macro_rules! t (\n+        macro_rules! t {\n             ($($ty:ty),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0, 10),\n@@ -199,15 +199,15 @@ mod tests {\n                     }\n                  )*\n             }}\n-        );\n+        }\n         t!(i8, i16, i32, i64, int,\n            u8, u16, u32, u64, uint)\n     }\n \n     #[test]\n     fn test_floats() {\n         let mut rng = ::test::rng();\n-        macro_rules! t (\n+        macro_rules! t {\n             ($($ty:ty),*) => {{\n                 $(\n                    let v: &[($ty, $ty)] = &[(0.0, 100.0),\n@@ -225,7 +225,7 @@ mod tests {\n                     }\n                  )*\n             }}\n-        );\n+        }\n \n         t!(f32, f64)\n     }"}, {"sha": "84328360ce32431e7b40f0ca582d2268ada3feee", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 72, "deletions": 69, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -69,7 +69,7 @@ impl IsaacRng {\n         let mut g = a;\n         let mut h = a;\n \n-        macro_rules! mix(\n+        macro_rules! mix {\n             () => {{\n                 a^=b<<11; d+=a; b+=c;\n                 b^=c>>2;  e+=b; c+=d;\n@@ -80,14 +80,14 @@ impl IsaacRng {\n                 g^=h<<8;  b+=g; h+=a;\n                 h^=a>>9;  c+=h; a+=b;\n             }}\n-        );\n+        }\n \n         for _ in range(0u, 4) {\n             mix!();\n         }\n \n         if use_rsl {\n-            macro_rules! memloop (\n+            macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range_step(0, RAND_SIZE as uint, 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n@@ -101,7 +101,7 @@ impl IsaacRng {\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n-            );\n+            }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n@@ -129,41 +129,42 @@ impl IsaacRng {\n \n         static MIDPOINT: uint = (RAND_SIZE / 2) as uint;\n \n-        macro_rules! ind (($x:expr) => {\n-            self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))]\n-        });\n+        macro_rules! ind {\n+            ($x:expr) => ( self.mem[(($x >> 2) as uint & ((RAND_SIZE - 1) as uint))] )\n+        }\n \n         let r = [(0, MIDPOINT), (MIDPOINT, 0)];\n         for &(mr_offset, m2_offset) in r.iter() {\n \n-            macro_rules! rngstepp(\n+            macro_rules! rngstepp {\n                 ($j:expr, $shift:expr) => {{\n-                        let base = $j;\n-                        let mix = a << $shift as uint;\n+                    let base = $j;\n+                    let mix = a << $shift as uint;\n \n-                        let x = self.mem[base  + mr_offset];\n-                        a = (a ^ mix) + self.mem[base + m2_offset];\n-                        let y = ind!(x) + a + b;\n-                        self.mem[base + mr_offset] = y;\n+                    let x = self.mem[base  + mr_offset];\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                        self.rsl[base + mr_offset] = b;\n-                    }}\n-                );\n-            macro_rules! rngstepn(\n+                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    self.rsl[base + mr_offset] = b;\n+                }}\n+            }\n+\n+            macro_rules! rngstepn {\n                 ($j:expr, $shift:expr) => {{\n-                        let base = $j;\n-                        let mix = a >> $shift as uint;\n+                    let base = $j;\n+                    let mix = a >> $shift as uint;\n \n-                        let x = self.mem[base  + mr_offset];\n-                        a = (a ^ mix) + self.mem[base + m2_offset];\n-                        let y = ind!(x) + a + b;\n-                        self.mem[base + mr_offset] = y;\n+                    let x = self.mem[base  + mr_offset];\n+                    a = (a ^ mix) + self.mem[base + m2_offset];\n+                    let y = ind!(x) + a + b;\n+                    self.mem[base + mr_offset] = y;\n \n-                        b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n-                        self.rsl[base + mr_offset] = b;\n-                    }}\n-                );\n+                    b = ind!(y >> RAND_SIZE_LEN as uint) + x;\n+                    self.rsl[base + mr_offset] = b;\n+                }}\n+            }\n \n             for i in range_step(0u, MIDPOINT, 4) {\n                 rngstepp!(i + 0, 13);\n@@ -301,15 +302,15 @@ impl Isaac64Rng {\n     /// of `rsl` as a seed, otherwise construct one algorithmically (not\n     /// randomly).\n     fn init(&mut self, use_rsl: bool) {\n-        macro_rules! init (\n+        macro_rules! init {\n             ($var:ident) => (\n                 let mut $var = 0x9e3779b97f4a7c13;\n             )\n-        );\n+        }\n         init!(a); init!(b); init!(c); init!(d);\n         init!(e); init!(f); init!(g); init!(h);\n \n-        macro_rules! mix(\n+        macro_rules! mix {\n             () => {{\n                 a-=e; f^=h>>9;  h+=a;\n                 b-=f; g^=a<<9;  a+=b;\n@@ -320,14 +321,14 @@ impl Isaac64Rng {\n                 g-=c; d^=f>>17; f+=g;\n                 h-=d; e^=g<<14; g+=h;\n             }}\n-        );\n+        }\n \n         for _ in range(0u, 4) {\n             mix!();\n         }\n \n         if use_rsl {\n-            macro_rules! memloop (\n+            macro_rules! memloop {\n                 ($arr:expr) => {{\n                     for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n                         a+=$arr[i  ]; b+=$arr[i+1];\n@@ -341,7 +342,7 @@ impl Isaac64Rng {\n                         self.mem[i+6]=g; self.mem[i+7]=h;\n                     }\n                 }}\n-            );\n+            }\n \n             memloop!(self.rsl);\n             memloop!(self.mem);\n@@ -366,49 +367,51 @@ impl Isaac64Rng {\n         let mut b = self.b + self.c;\n         const MIDPOINT: uint =  RAND_SIZE_64 / 2;\n         const MP_VEC: [(uint, uint); 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n-        macro_rules! ind (\n+        macro_rules! ind {\n             ($x:expr) => {\n                 *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n-        );\n+        }\n \n         for &(mr_offset, m2_offset) in MP_VEC.iter() {\n             for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n \n-                macro_rules! rngstepp(\n+                macro_rules! rngstepp {\n                     ($j:expr, $shift:expr) => {{\n-                            let base = base + $j;\n-                            let mix = a ^ (a << $shift as uint);\n-                            let mix = if $j == 0 {!mix} else {mix};\n-\n-                            unsafe {\n-                                let x = *self.mem.get_unchecked(base + mr_offset);\n-                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                                let y = ind!(x) + a + b;\n-                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                            }\n-                        }}\n-                    );\n-                macro_rules! rngstepn(\n+                        let base = base + $j;\n+                        let mix = a ^ (a << $shift as uint);\n+                        let mix = if $j == 0 {!mix} else {mix};\n+\n+                        unsafe {\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                        }\n+                    }}\n+                }\n+\n+                macro_rules! rngstepn {\n                     ($j:expr, $shift:expr) => {{\n-                            let base = base + $j;\n-                            let mix = a ^ (a >> $shift as uint);\n-                            let mix = if $j == 0 {!mix} else {mix};\n-\n-                            unsafe {\n-                                let x = *self.mem.get_unchecked(base + mr_offset);\n-                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n-                                let y = ind!(x) + a + b;\n-                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n-\n-                                b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n-                            }\n-                        }}\n-                    );\n+                        let base = base + $j;\n+                        let mix = a ^ (a >> $shift as uint);\n+                        let mix = if $j == 0 {!mix} else {mix};\n+\n+                        unsafe {\n+                            let x = *self.mem.get_unchecked(base + mr_offset);\n+                            a = mix + *self.mem.get_unchecked(base + m2_offset);\n+                            let y = ind!(x) + a + b;\n+                            *self.mem.get_unchecked_mut(base + mr_offset) = y;\n+\n+                            b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                            *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n+                        }\n+                    }}\n+                }\n+\n                 rngstepp!(0u, 21);\n                 rngstepn!(1u, 5);\n                 rngstepp!(2u, 12);"}, {"sha": "99dd505a9ef3910ee3342d16f2d03015e0929837", "filename": "src/librand/lib.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -29,11 +29,29 @@\n #![no_std]\n #![experimental]\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate core;\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate std;\n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate core;\n+\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate std;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate std;\n+\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n \n use core::prelude::*;\n "}, {"sha": "e57542a6d14de1c1e2e08f91d51fe59ed594dc0f", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -30,7 +30,14 @@\n \n extern crate serialize;\n \n-#[phase(plugin, link)] extern crate log;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n #[cfg(test)] extern crate test;\n \n pub use self::EbmlEncoderTag::*;"}, {"sha": "0084be49b561904534e693d4b69e736ab96f5eff", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -24,7 +24,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n-#![feature(macro_rules, phase, slicing_syntax, globs)]\n+#![feature(macro_rules, slicing_syntax, globs)]\n #![feature(unboxed_closures)]\n #![feature(associated_types)]\n #![deny(missing_docs)]"}, {"sha": "3ed712b15dfdcdb4eba468811aaff5a1634d3a42", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -40,8 +40,22 @@ extern crate rustc_back;\n extern crate serialize;\n extern crate rbml;\n extern crate collections;\n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n "}, {"sha": "5c0fd8944368f60da86abc2a3a85b2860e3de174", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -167,21 +167,27 @@ impl LintStore {\n     }\n \n     pub fn register_builtin(&mut self, sess: Option<&Session>) {\n-        macro_rules! add_builtin ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                self.register_pass($sess, false, box builtin::$name as LintPassObject);\n-            )*}\n-        ));\n-\n-        macro_rules! add_builtin_with_new ( ( $sess:ident, $($name:ident),*, ) => (\n-            {$(\n-                self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n-            )*}\n-        ));\n-\n-        macro_rules! add_lint_group ( ( $sess:ident, $name:expr, $($lint:ident),* ) => (\n-            self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n-        ));\n+        macro_rules! add_builtin {\n+            ($sess:ident, $($name:ident),*,) => (\n+                {$(\n+                    self.register_pass($sess, false, box builtin::$name as LintPassObject);\n+                )*}\n+            )\n+        }\n+\n+        macro_rules! add_builtin_with_new {\n+            ($sess:ident, $($name:ident),*,) => (\n+                {$(\n+                    self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n+                )*}\n+            )\n+        }\n+\n+        macro_rules! add_lint_group {\n+            ($sess:ident, $name:expr, $($lint:ident),*) => (\n+                self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n+            )\n+        }\n \n         add_builtin!(sess,\n                      HardwiredLints,"}, {"sha": "e9778fa05ff1787f419d717d979591d8816a69ef", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -28,8 +28,6 @@\n //! example) requires more effort. See `emit_lint` and `GatherNodeLevels`\n //! in `context.rs`.\n \n-#![macro_escape]\n-\n pub use self::Level::*;\n pub use self::LintSource::*;\n "}, {"sha": "de9a09ffe44c1ba33dddee1c55b41199e02dbe20", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -206,8 +206,8 @@ pub const tag_native_libraries_name: uint = 0x89;\n pub const tag_native_libraries_kind: uint = 0x8a;\n \n pub const tag_plugin_registrar_fn: uint = 0x8b;\n-pub const tag_exported_macros: uint = 0x8c;\n-pub const tag_macro_def: uint = 0x8d;\n+\n+// GAP 0x8c, 0x8d\n \n pub const tag_method_argument_names: uint = 0x8e;\n pub const tag_method_argument_name: uint = 0x8f;\n@@ -261,3 +261,7 @@ pub const tag_associated_type_names: uint = 0xb2;\n pub const tag_associated_type_name: uint = 0xb3;\n \n pub const tag_polarity: uint = 0xb4;\n+\n+pub const tag_macro_defs: uint = 0xb5;\n+pub const tag_macro_def: uint = 0xb6;\n+pub const tag_macro_def_body: uint = 0xb7;"}, {"sha": "171bfd74a816b4604c281b7ac1933a002d453447", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 414, "deletions": 344, "changes": 758, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -16,11 +16,10 @@ use back::svh::Svh;\n use session::{config, Session};\n use session::search_paths::PathKind;\n use metadata::cstore;\n-use metadata::cstore::{CStore, CrateSource};\n+use metadata::cstore::{CStore, CrateSource, MetadataBlob};\n use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n-use plugin::load::PluginMetadata;\n use util::nodemap::FnvHashMap;\n \n use std::rc::Rc;\n@@ -29,43 +28,27 @@ use syntax::ast;\n use syntax::abi;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::codemap::{Span};\n+use syntax::codemap::{Span, mk_sp};\n use syntax::diagnostic::SpanHandler;\n+use syntax::parse;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::visit;\n use util::fs;\n+use log;\n \n-struct Env<'a> {\n+pub struct CrateReader<'a> {\n     sess: &'a Session,\n     next_crate_num: ast::CrateNum,\n }\n \n-// Traverses an AST, reading all the information about use'd crates and extern\n-// libraries necessary for later resolving, typechecking, linking, etc.\n-pub fn read_crates(sess: &Session,\n-                   krate: &ast::Crate) {\n-    let mut e = Env {\n-        sess: sess,\n-        next_crate_num: sess.cstore.next_crate_num(),\n-    };\n-    visit_crate(&e, krate);\n-    visit::walk_crate(&mut e, krate);\n-    dump_crates(&sess.cstore);\n-    warn_if_multiple_versions(sess.diagnostic(), &sess.cstore);\n-\n-    for &(ref name, kind) in sess.opts.libs.iter() {\n-        register_native_lib(sess, None, name.clone(), kind);\n-    }\n-}\n-\n-impl<'a, 'v> visit::Visitor<'v> for Env<'a> {\n+impl<'a, 'v> visit::Visitor<'v> for CrateReader<'a> {\n     fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        visit_view_item(self, a);\n+        self.process_view_item(a);\n         visit::walk_view_item(self, a);\n     }\n     fn visit_item(&mut self, a: &ast::Item) {\n-        visit_item(self, a);\n+        self.process_item(a);\n         visit::walk_item(self, a);\n     }\n }\n@@ -105,42 +88,8 @@ fn warn_if_multiple_versions(diag: &SpanHandler, cstore: &CStore) {\n     }\n }\n \n-fn visit_crate(e: &Env, c: &ast::Crate) {\n-    for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-        match a.value_str() {\n-            Some(ref linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n-            None => { /* fallthrough */ }\n-        }\n-    }\n-}\n-\n fn should_link(i: &ast::ViewItem) -> bool {\n-    i.attrs.iter().all(|attr| {\n-        attr.name().get() != \"phase\" ||\n-            attr.meta_item_list().map_or(false, |phases| {\n-                attr::contains_name(phases[], \"link\")\n-            })\n-    })\n-}\n-\n-fn visit_view_item(e: &mut Env, i: &ast::ViewItem) {\n-    if !should_link(i) {\n-        return;\n-    }\n-\n-    match extract_crate_info(e, i) {\n-        Some(info) => {\n-            let (cnum, _, _) = resolve_crate(e,\n-                                             &None,\n-                                             info.ident[],\n-                                             info.name[],\n-                                             None,\n-                                             i.span,\n-                                             PathKind::Crate);\n-            e.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-        }\n-        None => ()\n-    }\n+    !attr::contains_name(i.attrs[], \"no_link\")\n }\n \n struct CrateInfo {\n@@ -150,32 +99,6 @@ struct CrateInfo {\n     should_link: bool,\n }\n \n-fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n-    match i.node {\n-        ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n-            let ident = token::get_ident(ident);\n-            debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n-                   ident, path_opt);\n-            let name = match *path_opt {\n-                Some((ref path_str, _)) => {\n-                    let name = path_str.get().to_string();\n-                    validate_crate_name(Some(e.sess), name[],\n-                                        Some(i.span));\n-                    name\n-                }\n-                None => ident.get().to_string(),\n-            };\n-            Some(CrateInfo {\n-                ident: ident.get().to_string(),\n-                name: name,\n-                id: id,\n-                should_link: should_link(i),\n-            })\n-        }\n-        _ => None\n-    }\n-}\n-\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let err = |&: s: &str| {\n         match (sp, sess) {\n@@ -198,85 +121,6 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     }\n }\n \n-fn visit_item(e: &Env, i: &ast::Item) {\n-    match i.node {\n-        ast::ItemForeignMod(ref fm) => {\n-            if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n-                return;\n-            }\n-\n-            // First, add all of the custom link_args attributes\n-            let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name() == \"link_args\" {\n-                    Some(at)\n-                } else {\n-                    None\n-                })\n-                .collect::<Vec<&ast::Attribute>>();\n-            for m in link_args.iter() {\n-                match m.value_str() {\n-                    Some(linkarg) => e.sess.cstore.add_used_link_args(linkarg.get()),\n-                    None => { /* fallthrough */ }\n-                }\n-            }\n-\n-            // Next, process all of the #[link(..)]-style arguments\n-            let link_args = i.attrs.iter()\n-                .filter_map(|at| if at.name() == \"link\" {\n-                    Some(at)\n-                } else {\n-                    None\n-                })\n-                .collect::<Vec<&ast::Attribute>>();\n-            for m in link_args.iter() {\n-                match m.meta_item_list() {\n-                    Some(items) => {\n-                        let kind = items.iter().find(|k| {\n-                            k.name() == \"kind\"\n-                        }).and_then(|a| a.value_str());\n-                        let kind = match kind {\n-                            Some(k) => {\n-                                if k == \"static\" {\n-                                    cstore::NativeStatic\n-                                } else if e.sess.target.target.options.is_like_osx\n-                                          && k == \"framework\" {\n-                                    cstore::NativeFramework\n-                                } else if k == \"framework\" {\n-                                    cstore::NativeFramework\n-                                } else if k == \"dylib\" {\n-                                    cstore::NativeUnknown\n-                                } else {\n-                                    e.sess.span_err(m.span,\n-                                        format!(\"unknown kind: `{}`\",\n-                                                k)[]);\n-                                    cstore::NativeUnknown\n-                                }\n-                            }\n-                            None => cstore::NativeUnknown\n-                        };\n-                        let n = items.iter().find(|n| {\n-                            n.name() == \"name\"\n-                        }).and_then(|a| a.value_str());\n-                        let n = match n {\n-                            Some(n) => n,\n-                            None => {\n-                                e.sess.span_err(m.span,\n-                                    \"#[link(...)] specified without \\\n-                                     `name = \\\"foo\\\"`\");\n-                                InternedString::new(\"foo\")\n-                            }\n-                        };\n-                        register_native_lib(e.sess, Some(m.span),\n-                                            n.get().to_string(), kind);\n-                    }\n-                    None => {}\n-                }\n-            }\n-        }\n-        _ => { }\n-    }\n-}\n-\n fn register_native_lib(sess: &Session,\n                        span: Option<Span>,\n                        name: String,\n@@ -304,172 +148,341 @@ fn register_native_lib(sess: &Session,\n     sess.cstore.add_used_library(name, kind);\n }\n \n-fn existing_match(e: &Env, name: &str,\n-                  hash: Option<&Svh>) -> Option<ast::CrateNum> {\n-    let mut ret = None;\n-    e.sess.cstore.iter_crate_data(|cnum, data| {\n-        if data.name != name { return }\n+pub struct PluginMetadata<'a> {\n+    sess: &'a Session,\n+    metadata: PMDSource,\n+    dylib: Option<Path>,\n+    info: CrateInfo,\n+    vi_span: Span,\n+    target_only: bool,\n+}\n \n-        match hash {\n-            Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n-            Some(..) => return,\n-            None => {}\n-        }\n+enum PMDSource {\n+    Registered(Rc<cstore::crate_metadata>),\n+    Owned(MetadataBlob),\n+}\n \n-        // When the hash is None we're dealing with a top-level dependency in\n-        // which case we may have a specification on the command line for this\n-        // library. Even though an upstream library may have loaded something of\n-        // the same name, we have to make sure it was loaded from the exact same\n-        // location as well.\n-        //\n-        // We're also sure to compare *paths*, not actual byte slices. The\n-        // `source` stores paths which are normalized which may be different\n-        // from the strings on the command line.\n-        let source = e.sess.cstore.get_used_crate_source(cnum).unwrap();\n-        match e.sess.opts.externs.get(name) {\n-            Some(locs) => {\n-                let found = locs.iter().any(|l| {\n-                    let l = fs::realpath(&Path::new(l[])).ok();\n-                    l == source.dylib || l == source.rlib\n-                });\n-                if found {\n-                    ret = Some(cnum);\n-                }\n-            }\n-            None => ret = Some(cnum),\n+impl PMDSource {\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        match *self {\n+            PMDSource::Registered(ref cmd) => cmd.data(),\n+            PMDSource::Owned(ref mdb) => mdb.as_slice(),\n         }\n-    });\n-    return ret;\n+    }\n }\n \n-fn register_crate<'a>(e: &mut Env,\n-                  root: &Option<CratePaths>,\n-                  ident: &str,\n-                  name: &str,\n-                  span: Span,\n-                  lib: loader::Library)\n-                        -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                            cstore::CrateSource) {\n-    // Claim this crate number and cache it\n-    let cnum = e.next_crate_num;\n-    e.next_crate_num += 1;\n-\n-    // Stash paths for top-most crate locally if necessary.\n-    let crate_paths = if root.is_none() {\n-        Some(CratePaths {\n-            ident: ident.to_string(),\n-            dylib: lib.dylib.clone(),\n-            rlib:  lib.rlib.clone(),\n-        })\n-    } else {\n-        None\n-    };\n-    // Maintain a reference to the top most crate.\n-    let root = if root.is_some() { root } else { &crate_paths };\n+impl<'a> CrateReader<'a> {\n+    pub fn new(sess: &'a Session) -> CrateReader<'a> {\n+        CrateReader {\n+            sess: sess,\n+            next_crate_num: sess.cstore.next_crate_num(),\n+        }\n+    }\n \n-    let cnum_map = resolve_crate_deps(e, root, lib.metadata.as_slice(), span);\n+    // Traverses an AST, reading all the information about use'd crates and extern\n+    // libraries necessary for later resolving, typechecking, linking, etc.\n+    pub fn read_crates(&mut self, krate: &ast::Crate) {\n+        self.process_crate(krate);\n+        visit::walk_crate(self, krate);\n \n-    let loader::Library{ dylib, rlib, metadata } = lib;\n+        if log_enabled!(log::DEBUG) {\n+            dump_crates(&self.sess.cstore);\n+        }\n+        warn_if_multiple_versions(self.sess.diagnostic(), &self.sess.cstore);\n \n-    let cmeta = Rc::new( cstore::crate_metadata {\n-        name: name.to_string(),\n-        data: metadata,\n-        cnum_map: cnum_map,\n-        cnum: cnum,\n-        span: span,\n-    });\n+        for &(ref name, kind) in self.sess.opts.libs.iter() {\n+            register_native_lib(self.sess, None, name.clone(), kind);\n+        }\n+    }\n \n-    let source = cstore::CrateSource {\n-        dylib: dylib,\n-        rlib: rlib,\n-        cnum: cnum,\n-    };\n+    fn process_crate(&self, c: &ast::Crate) {\n+        for a in c.attrs.iter().filter(|m| m.name() == \"link_args\") {\n+            match a.value_str() {\n+                Some(ref linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                None => { /* fallthrough */ }\n+            }\n+        }\n+    }\n \n-    e.sess.cstore.set_crate_data(cnum, cmeta.clone());\n-    e.sess.cstore.add_used_crate_source(source.clone());\n-    (cnum, cmeta, source)\n-}\n+    fn process_view_item(&mut self, i: &ast::ViewItem) {\n+        if !should_link(i) {\n+            return;\n+        }\n \n-fn resolve_crate(e: &mut Env,\n-                 root: &Option<CratePaths>,\n-                 ident: &str,\n-                 name: &str,\n-                 hash: Option<&Svh>,\n-                 span: Span,\n-                 kind: PathKind)\n-                     -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n-                         cstore::CrateSource) {\n-    match existing_match(e, name, hash) {\n-        None => {\n-            let mut load_ctxt = loader::Context {\n-                sess: e.sess,\n-                span: span,\n-                ident: ident,\n-                crate_name: name,\n-                hash: hash.map(|a| &*a),\n-                filesearch: e.sess.target_filesearch(kind),\n-                triple: e.sess.opts.target_triple[],\n-                root: root,\n-                rejected_via_hash: vec!(),\n-                rejected_via_triple: vec!(),\n-                should_match_name: true,\n-            };\n-            let library = load_ctxt.load_library_crate();\n-            register_crate(e, root, ident, name, span, library)\n+        match self.extract_crate_info(i) {\n+            Some(info) => {\n+                let (cnum, _, _) = self.resolve_crate(&None,\n+                                                      info.ident[],\n+                                                      info.name[],\n+                                                      None,\n+                                                      i.span,\n+                                                      PathKind::Crate);\n+                self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+            }\n+            None => ()\n         }\n-        Some(cnum) => (cnum,\n-                       e.sess.cstore.get_crate_data(cnum),\n-                       e.sess.cstore.get_used_crate_source(cnum).unwrap())\n     }\n-}\n \n-// Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: &mut Env,\n+    fn extract_crate_info(&self, i: &ast::ViewItem) -> Option<CrateInfo> {\n+        match i.node {\n+            ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n+                let ident = token::get_ident(ident);\n+                debug!(\"resolving extern crate stmt. ident: {} path_opt: {}\",\n+                       ident, path_opt);\n+                let name = match *path_opt {\n+                    Some((ref path_str, _)) => {\n+                        let name = path_str.get().to_string();\n+                        validate_crate_name(Some(self.sess), name[],\n+                                            Some(i.span));\n+                        name\n+                    }\n+                    None => ident.get().to_string(),\n+                };\n+                Some(CrateInfo {\n+                    ident: ident.get().to_string(),\n+                    name: name,\n+                    id: id,\n+                    should_link: should_link(i),\n+                })\n+            }\n+            _ => None\n+        }\n+    }\n+\n+    fn process_item(&self, i: &ast::Item) {\n+        match i.node {\n+            ast::ItemForeignMod(ref fm) => {\n+                if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n+                    return;\n+                }\n+\n+                // First, add all of the custom link_args attributes\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link_args\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in link_args.iter() {\n+                    match m.value_str() {\n+                        Some(linkarg) => self.sess.cstore.add_used_link_args(linkarg.get()),\n+                        None => { /* fallthrough */ }\n+                    }\n+                }\n+\n+                // Next, process all of the #[link(..)]-style arguments\n+                let link_args = i.attrs.iter()\n+                    .filter_map(|at| if at.name() == \"link\" {\n+                        Some(at)\n+                    } else {\n+                        None\n+                    })\n+                    .collect::<Vec<&ast::Attribute>>();\n+                for m in link_args.iter() {\n+                    match m.meta_item_list() {\n+                        Some(items) => {\n+                            let kind = items.iter().find(|k| {\n+                                k.name() == \"kind\"\n+                            }).and_then(|a| a.value_str());\n+                            let kind = match kind {\n+                                Some(k) => {\n+                                    if k == \"static\" {\n+                                        cstore::NativeStatic\n+                                    } else if self.sess.target.target.options.is_like_osx\n+                                              && k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"framework\" {\n+                                        cstore::NativeFramework\n+                                    } else if k == \"dylib\" {\n+                                        cstore::NativeUnknown\n+                                    } else {\n+                                        self.sess.span_err(m.span,\n+                                            format!(\"unknown kind: `{}`\",\n+                                                    k)[]);\n+                                        cstore::NativeUnknown\n+                                    }\n+                                }\n+                                None => cstore::NativeUnknown\n+                            };\n+                            let n = items.iter().find(|n| {\n+                                n.name() == \"name\"\n+                            }).and_then(|a| a.value_str());\n+                            let n = match n {\n+                                Some(n) => n,\n+                                None => {\n+                                    self.sess.span_err(m.span,\n+                                        \"#[link(...)] specified without \\\n+                                         `name = \\\"foo\\\"`\");\n+                                    InternedString::new(\"foo\")\n+                                }\n+                            };\n+                            register_native_lib(self.sess, Some(m.span),\n+                                                n.get().to_string(), kind);\n+                        }\n+                        None => {}\n+                    }\n+                }\n+            }\n+            _ => { }\n+        }\n+    }\n+\n+    fn existing_match(&self, name: &str,\n+                      hash: Option<&Svh>) -> Option<ast::CrateNum> {\n+        let mut ret = None;\n+        self.sess.cstore.iter_crate_data(|cnum, data| {\n+            if data.name != name { return }\n+\n+            match hash {\n+                Some(hash) if *hash == data.hash() => { ret = Some(cnum); return }\n+                Some(..) => return,\n+                None => {}\n+            }\n+\n+            // When the hash is None we're dealing with a top-level dependency in\n+            // which case we may have a specification on the command line for this\n+            // library. Even though an upstream library may have loaded something of\n+            // the same name, we have to make sure it was loaded from the exact same\n+            // location as well.\n+            //\n+            // We're also sure to compare *paths*, not actual byte slices. The\n+            // `source` stores paths which are normalized which may be different\n+            // from the strings on the command line.\n+            let source = self.sess.cstore.get_used_crate_source(cnum).unwrap();\n+            match self.sess.opts.externs.get(name) {\n+                Some(locs) => {\n+                    let found = locs.iter().any(|l| {\n+                        let l = fs::realpath(&Path::new(l[])).ok();\n+                        l == source.dylib || l == source.rlib\n+                    });\n+                    if found {\n+                        ret = Some(cnum);\n+                    }\n+                }\n+                None => ret = Some(cnum),\n+            }\n+        });\n+        return ret;\n+    }\n+\n+    fn register_crate(&mut self,\n                       root: &Option<CratePaths>,\n-                      cdata: &[u8], span : Span)\n-                   -> cstore::cnum_map {\n-    debug!(\"resolving deps of external crate\");\n-    // The map from crate numbers in the crate we're resolving to local crate\n-    // numbers\n-    decoder::get_crate_deps(cdata).iter().map(|dep| {\n-        debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-        let (local_cnum, _, _) = resolve_crate(e, root,\n-                                               dep.name[],\n-                                               dep.name[],\n-                                               Some(&dep.hash),\n-                                               span,\n-                                               PathKind::Dependency);\n-        (dep.cnum, local_cnum)\n-    }).collect()\n-}\n+                      ident: &str,\n+                      name: &str,\n+                      span: Span,\n+                      lib: loader::Library)\n+                      -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                          cstore::CrateSource) {\n+        // Claim this crate number and cache it\n+        let cnum = self.next_crate_num;\n+        self.next_crate_num += 1;\n+\n+        // Stash paths for top-most crate locally if necessary.\n+        let crate_paths = if root.is_none() {\n+            Some(CratePaths {\n+                ident: ident.to_string(),\n+                dylib: lib.dylib.clone(),\n+                rlib:  lib.rlib.clone(),\n+            })\n+        } else {\n+            None\n+        };\n+        // Maintain a reference to the top most crate.\n+        let root = if root.is_some() { root } else { &crate_paths };\n \n-pub struct PluginMetadataReader<'a> {\n-    env: Env<'a>,\n-}\n+        let cnum_map = self.resolve_crate_deps(root, lib.metadata.as_slice(), span);\n+\n+        let loader::Library{ dylib, rlib, metadata } = lib;\n+\n+        let cmeta = Rc::new( cstore::crate_metadata {\n+            name: name.to_string(),\n+            data: metadata,\n+            cnum_map: cnum_map,\n+            cnum: cnum,\n+            span: span,\n+        });\n+\n+        let source = cstore::CrateSource {\n+            dylib: dylib,\n+            rlib: rlib,\n+            cnum: cnum,\n+        };\n+\n+        self.sess.cstore.set_crate_data(cnum, cmeta.clone());\n+        self.sess.cstore.add_used_crate_source(source.clone());\n+        (cnum, cmeta, source)\n+    }\n \n-impl<'a> PluginMetadataReader<'a> {\n-    pub fn new(sess: &'a Session) -> PluginMetadataReader<'a> {\n-        PluginMetadataReader {\n-            env: Env {\n-                sess: sess,\n-                next_crate_num: sess.cstore.next_crate_num(),\n+    fn resolve_crate(&mut self,\n+                     root: &Option<CratePaths>,\n+                     ident: &str,\n+                     name: &str,\n+                     hash: Option<&Svh>,\n+                     span: Span,\n+                     kind: PathKind)\n+                         -> (ast::CrateNum, Rc<cstore::crate_metadata>,\n+                             cstore::CrateSource) {\n+        match self.existing_match(name, hash) {\n+            None => {\n+                let mut load_ctxt = loader::Context {\n+                    sess: self.sess,\n+                    span: span,\n+                    ident: ident,\n+                    crate_name: name,\n+                    hash: hash.map(|a| &*a),\n+                    filesearch: self.sess.target_filesearch(kind),\n+                    triple: self.sess.opts.target_triple[],\n+                    root: root,\n+                    rejected_via_hash: vec!(),\n+                    rejected_via_triple: vec!(),\n+                    should_match_name: true,\n+                };\n+                let library = load_ctxt.load_library_crate();\n+                self.register_crate(root, ident, name, span, library)\n             }\n+            Some(cnum) => (cnum,\n+                           self.sess.cstore.get_crate_data(cnum),\n+                           self.sess.cstore.get_used_crate_source(cnum).unwrap())\n         }\n     }\n \n-    pub fn read_plugin_metadata(&mut self,\n-                                krate: &ast::ViewItem) -> PluginMetadata {\n-        let info = extract_crate_info(&self.env, krate).unwrap();\n-        let target_triple = self.env.sess.opts.target_triple[];\n+    // Go through the crate metadata and load any crates that it references\n+    fn resolve_crate_deps(&mut self,\n+                          root: &Option<CratePaths>,\n+                          cdata: &[u8], span : Span)\n+                       -> cstore::cnum_map {\n+        debug!(\"resolving deps of external crate\");\n+        // The map from crate numbers in the crate we're resolving to local crate\n+        // numbers\n+        decoder::get_crate_deps(cdata).iter().map(|dep| {\n+            debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n+            let (local_cnum, _, _) = self.resolve_crate(root,\n+                                                   dep.name[],\n+                                                   dep.name[],\n+                                                   Some(&dep.hash),\n+                                                   span,\n+                                                   PathKind::Dependency);\n+            (dep.cnum, local_cnum)\n+        }).collect()\n+    }\n+\n+    pub fn read_plugin_metadata<'b>(&'b mut self,\n+                                    vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n+        let info = self.extract_crate_info(vi).unwrap();\n+        let target_triple = self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n+        let mut target_only = false;\n+        let ident = info.ident.clone();\n+        let name = info.name.clone();\n         let mut load_ctxt = loader::Context {\n-            sess: self.env.sess,\n-            span: krate.span,\n-            ident: info.ident[],\n-            crate_name: info.name[],\n+            sess: self.sess,\n+            span: vi.span,\n+            ident: ident[],\n+            crate_name: name[],\n             hash: None,\n-            filesearch: self.env.sess.host_filesearch(PathKind::Crate),\n+            filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n             root: &None,\n             rejected_via_hash: vec!(),\n@@ -479,49 +492,106 @@ impl<'a> PluginMetadataReader<'a> {\n         let library = match load_ctxt.maybe_load_library_crate() {\n             Some(l) => l,\n             None if is_cross => {\n-                // try loading from target crates (only valid if there are\n-                // no syntax extensions)\n-                load_ctxt.triple = target_triple;\n-                load_ctxt.filesearch = self.env.sess.target_filesearch(PathKind::Crate);\n-                let lib = load_ctxt.load_library_crate();\n-                if decoder::get_plugin_registrar_fn(lib.metadata.as_slice()).is_some() {\n-                    let message = format!(\"crate `{}` contains a plugin_registrar fn but \\\n-                                  only a version for triple `{}` could be found (need {})\",\n-                                  info.ident, target_triple, config::host_triple());\n-                    self.env.sess.span_err(krate.span, message[]);\n-                    // need to abort now because the syntax expansion\n-                    // code will shortly attempt to load and execute\n-                    // code from the found library.\n-                    self.env.sess.abort_if_errors();\n-                }\n+                // Try loading from target crates. This will abort later if we try to\n+                // load a plugin registrar function,\n+                target_only = true;\n                 should_link = info.should_link;\n-                lib\n+\n+                load_ctxt.triple = target_triple;\n+                load_ctxt.filesearch = self.sess.target_filesearch(PathKind::Crate);\n+                load_ctxt.load_library_crate()\n             }\n             None => { load_ctxt.report_load_errs(); unreachable!() },\n         };\n-        let macros = decoder::get_exported_macros(library.metadata.as_slice());\n-        let registrar = decoder::get_plugin_registrar_fn(library.metadata.as_slice()).map(|id| {\n-            decoder::get_symbol(library.metadata.as_slice(), id)\n-        });\n-        if library.dylib.is_none() && registrar.is_some() {\n-            let message = format!(\"plugin crate `{}` only found in rlib format, \\\n-                                   but must be available in dylib format\",\n-                                  info.ident);\n-            self.env.sess.span_err(krate.span, message[]);\n-            // No need to abort because the loading code will just ignore this\n-            // empty dylib.\n-        }\n-        let pc = PluginMetadata {\n-            lib: library.dylib.clone(),\n-            macros: macros,\n-            registrar_symbol: registrar,\n+\n+        let dylib = library.dylib.clone();\n+        let register = should_link && self.existing_match(info.name[], None).is_none();\n+        let metadata = if register {\n+            // Register crate now to avoid double-reading metadata\n+            let (_, cmd, _) = self.register_crate(&None, info.ident[],\n+                                info.name[], vi.span, library);\n+            PMDSource::Registered(cmd)\n+        } else {\n+            // Not registering the crate; just hold on to the metadata\n+            PMDSource::Owned(library.metadata)\n         };\n-        if should_link && existing_match(&self.env, info.name[],\n-                                         None).is_none() {\n-            // register crate now to avoid double-reading metadata\n-            register_crate(&mut self.env, &None, info.ident[],\n-                           info.name[], krate.span, library);\n+\n+        PluginMetadata {\n+            sess: self.sess,\n+            metadata: metadata,\n+            dylib: dylib,\n+            info: info,\n+            vi_span: vi.span,\n+            target_only: target_only,\n+        }\n+    }\n+}\n+\n+impl<'a> PluginMetadata<'a> {\n+    /// Read exported macros\n+    pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n+        let imported_from = Some(token::intern(self.info.ident[]).ident());\n+        let source_name = format!(\"<{} macros>\", self.info.ident[]);\n+        let mut macros = vec![];\n+        decoder::each_exported_macro(self.metadata.as_slice(),\n+                                     &*self.sess.cstore.intr,\n+            |name, attrs, body| {\n+                // NB: Don't use parse::parse_tts_from_source_str because it parses with\n+                // quote_depth > 0.\n+                let mut p = parse::new_parser_from_source_str(&self.sess.parse_sess,\n+                                                              self.sess.opts.cfg.clone(),\n+                                                              source_name.clone(),\n+                                                              body);\n+                let lo = p.span.lo;\n+                let body = p.parse_all_token_trees();\n+                let span = mk_sp(lo, p.last_span.hi);\n+                p.abort_if_errors();\n+                macros.push(ast::MacroDef {\n+                    ident: name.ident(),\n+                    attrs: attrs,\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: span,\n+                    imported_from: imported_from,\n+                    // overridden in plugin/load.rs\n+                    export: false,\n+                    use_locally: false,\n+\n+                    body: body,\n+                });\n+                true\n+            }\n+        );\n+        macros\n+    }\n+\n+    /// Look for a plugin registrar. Returns library path and symbol name.\n+    pub fn plugin_registrar(&self) -> Option<(Path, String)> {\n+        if self.target_only {\n+            // Need to abort before syntax expansion.\n+            let message = format!(\"plugin crate `{}` is not available for triple `{}` \\\n+                                   (only found {})\",\n+                                  self.info.ident,\n+                                  config::host_triple(),\n+                                  self.sess.opts.target_triple);\n+            self.sess.span_err(self.vi_span, message[]);\n+            self.sess.abort_if_errors();\n+        }\n+\n+        let registrar = decoder::get_plugin_registrar_fn(self.metadata.as_slice())\n+            .map(|id| decoder::get_symbol(self.metadata.as_slice(), id));\n+\n+        match (self.dylib.as_ref(), registrar) {\n+            (Some(dylib), Some(reg)) => Some((dylib.clone(), reg)),\n+            (None, Some(_)) => {\n+                let message = format!(\"plugin crate `{}` only found in rlib format, \\\n+                                       but must be available in dylib format\",\n+                                       self.info.ident);\n+                self.sess.span_err(self.vi_span, message[]);\n+                // No need to abort because the loading code will just ignore this\n+                // empty dylib.\n+                None\n+            }\n+            _ => None,\n         }\n-        pc\n     }\n }"}, {"sha": "ed0a1f6211b16edd5cc56be5cf8c7321e340c51d", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -1353,15 +1353,16 @@ pub fn get_plugin_registrar_fn(data: &[u8]) -> Option<ast::NodeId> {\n         .map(|doc| FromPrimitive::from_u32(reader::doc_as_u32(doc)).unwrap())\n }\n \n-pub fn get_exported_macros(data: &[u8]) -> Vec<String> {\n-    let macros = reader::get_doc(rbml::Doc::new(data),\n-                                 tag_exported_macros);\n-    let mut result = Vec::new();\n+pub fn each_exported_macro<F>(data: &[u8], intr: &IdentInterner, mut f: F) where\n+    F: FnMut(ast::Name, Vec<ast::Attribute>, String) -> bool,\n+{\n+    let macros = reader::get_doc(rbml::Doc::new(data), tag_macro_defs);\n     reader::tagged_docs(macros, tag_macro_def, |macro_doc| {\n-        result.push(macro_doc.as_str().to_string());\n-        true\n+        let name = item_name(intr, macro_doc);\n+        let attrs = get_attributes(macro_doc);\n+        let body = reader::get_doc(macro_doc, tag_macro_def_body);\n+        f(name, attrs, body.as_str().to_string())\n     });\n-    result\n }\n \n pub fn get_dylib_dependency_formats(cdata: Cmd)"}, {"sha": "e4226ddde85b6540c0a6bd78e255e16420a46729", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -42,6 +42,7 @@ use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::SpanHandler;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n+use syntax::print::pprust;\n use syntax::ptr::P;\n use syntax::visit::Visitor;\n use syntax::visit;\n@@ -1817,25 +1818,21 @@ fn encode_plugin_registrar_fn(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     }\n }\n \n-/// Given a span, write the text of that span into the output stream\n-/// as an exported macro\n-fn encode_macro_def(ecx: &EncodeContext,\n-                    rbml_w: &mut Encoder,\n-                    span: &syntax::codemap::Span) {\n-    let def = ecx.tcx.sess.codemap().span_to_snippet(*span)\n-        .expect(\"Unable to find source for macro\");\n-    rbml_w.start_tag(tag_macro_def);\n-    rbml_w.wr_str(def[]);\n-    rbml_w.end_tag();\n-}\n-\n /// Serialize the text of the exported macros\n-fn encode_macro_defs(ecx: &EncodeContext,\n-                     krate: &ast::Crate,\n-                     rbml_w: &mut Encoder) {\n-    rbml_w.start_tag(tag_exported_macros);\n-    for item in krate.exported_macros.iter() {\n-        encode_macro_def(ecx, rbml_w, &item.span);\n+fn encode_macro_defs(rbml_w: &mut Encoder,\n+                     krate: &ast::Crate) {\n+    rbml_w.start_tag(tag_macro_defs);\n+    for def in krate.exported_macros.iter() {\n+        rbml_w.start_tag(tag_macro_def);\n+\n+        encode_name(rbml_w, def.ident.name);\n+        encode_attributes(rbml_w, def.attrs[]);\n+\n+        rbml_w.start_tag(tag_macro_def_body);\n+        rbml_w.wr_str(pprust::tts_to_string(def.body[])[]);\n+        rbml_w.end_tag();\n+\n+        rbml_w.end_tag();\n     }\n     rbml_w.end_tag();\n }\n@@ -2153,7 +2150,7 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     // Encode macro definitions\n     i = rbml_w.writer.tell().unwrap();\n-    encode_macro_defs(&ecx, krate, &mut rbml_w);\n+    encode_macro_defs(&mut rbml_w, krate);\n     stats.macro_defs_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     // Encode the types of all unboxed closures in this crate."}, {"sha": "32482fce4daa8b05d556f35333e724f4980937cb", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -503,7 +503,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                                         \"target type not found for const cast\")\n                 });\n \n-        macro_rules! define_casts(\n+        macro_rules! define_casts {\n             ($val:ident, {\n                 $($ty_pat:pat => (\n                     $intermediate_ty:ty,\n@@ -524,7 +524,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                 },)*\n                 _ => Err(\"can't cast this type\".to_string())\n             })\n-        );\n+        }\n \n         eval_const_expr_partial(tcx, &**base)\n             .and_then(|val| define_casts!(val, {"}, {"sha": "c359233eca173cd4ad7b9fe05d76b6838a4bc6d4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -6171,8 +6171,8 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n     return state.result();\n \n     fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n-        macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n-        macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n+        macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n+        macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n \n         let region = |&: state: &mut sip::SipState, r: Region| {\n             match r {"}, {"sha": "44a223954858a76d7089143c981353b2a72a705a", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 125, "deletions": 44, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,55 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Used by `rustc` when loading a plugin.\n+//! Used by `rustc` when loading a plugin, or a crate with exported macros.\n \n use session::Session;\n-use metadata::creader::PluginMetadataReader;\n+use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n use std::mem;\n use std::os;\n use std::dynamic_lib::DynamicLibrary;\n+use std::collections::HashSet;\n use syntax::ast;\n use syntax::attr;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n-use syntax::ext::expand::ExportedMacros;\n use syntax::attr::AttrMetaMethods;\n \n-/// Plugin-related crate metadata.\n-pub struct PluginMetadata {\n-    /// Source code of macros exported by the crate.\n-    pub macros: Vec<String>,\n-    /// Path to the shared library file.\n-    pub lib: Option<Path>,\n-    /// Symbol name of the plugin registrar function.\n-    pub registrar_symbol: Option<String>,\n-}\n-\n /// Pointer to a registrar function.\n pub type PluginRegistrarFun =\n     fn(&mut Registry);\n \n+pub struct PluginRegistrar {\n+    pub fun: PluginRegistrarFun,\n+    pub args: P<ast::MetaItem>,\n+}\n+\n /// Information about loaded plugins.\n pub struct Plugins {\n-    /// Source code of exported macros.\n-    pub macros: Vec<ExportedMacros>,\n+    /// Imported macros.\n+    pub macros: Vec<ast::MacroDef>,\n     /// Registrars, as function pointers.\n-    pub registrars: Vec<PluginRegistrarFun>,\n+    pub registrars: Vec<PluginRegistrar>,\n }\n \n struct PluginLoader<'a> {\n     sess: &'a Session,\n-    reader: PluginMetadataReader<'a>,\n+    span_whitelist: HashSet<Span>,\n+    reader: CrateReader<'a>,\n     plugins: Plugins,\n }\n \n impl<'a> PluginLoader<'a> {\n     fn new(sess: &'a Session) -> PluginLoader<'a> {\n         PluginLoader {\n             sess: sess,\n-            reader: PluginMetadataReader::new(sess),\n+            reader: CrateReader::new(sess),\n+            span_whitelist: HashSet::new(),\n             plugins: Plugins {\n                 macros: vec!(),\n                 registrars: vec!(),\n@@ -69,6 +69,14 @@ impl<'a> PluginLoader<'a> {\n pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n                     addl_plugins: Option<Plugins>) -> Plugins {\n     let mut loader = PluginLoader::new(sess);\n+\n+    // We need to error on `#[macro_use] extern crate` when it isn't at the\n+    // crate root, because `$crate` won't work properly. Identify these by\n+    // spans, because the crate map isn't set up yet.\n+    for vi in krate.module.view_items.iter() {\n+        loader.span_whitelist.insert(vi.span);\n+    }\n+\n     visit::walk_crate(&mut loader, krate);\n \n     let mut plugins = loader.plugins;\n@@ -89,41 +97,112 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n     fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n+        // We're only interested in `extern crate`.\n         match vi.node {\n-            ast::ViewItemExternCrate(name, _, _) => {\n-                let mut plugin_phase = false;\n+            ast::ViewItemExternCrate(..) => (),\n+            _ => return,\n+        }\n \n-                for attr in vi.attrs.iter().filter(|a| a.check_name(\"phase\")) {\n-                    let phases = attr.meta_item_list().unwrap_or(&[]);\n-                    if attr::contains_name(phases, \"plugin\") {\n-                        plugin_phase = true;\n+        // Parse the attributes relating to macro / plugin loading.\n+        let mut plugin_attr = None;\n+        let mut macro_selection = Some(HashSet::new());  // None => load all\n+        let mut reexport = HashSet::new();\n+        for attr in vi.attrs.iter() {\n+            let mut used = true;\n+            match attr.name().get() {\n+                \"phase\" => {\n+                    self.sess.span_err(attr.span, \"#[phase] is deprecated; use \\\n+                                       #[macro_use], #[plugin], and/or #[no_link]\");\n+                }\n+                \"plugin\" => {\n+                    if plugin_attr.is_some() {\n+                        self.sess.span_err(attr.span, \"#[plugin] specified multiple times\");\n+                    }\n+                    plugin_attr = Some(attr.node.value.clone());\n+                }\n+                \"macro_use\" => {\n+                    let names = attr.meta_item_list();\n+                    if names.is_none() {\n+                        // no names => load all\n+                        macro_selection = None;\n+                    }\n+                    if let (Some(sel), Some(names)) = (macro_selection.as_mut(), names) {\n+                        for name in names.iter() {\n+                            if let ast::MetaWord(ref name) = name.node {\n+                                sel.insert(name.clone());\n+                            } else {\n+                                self.sess.span_err(name.span, \"bad macro import\");\n+                            }\n+                        }\n                     }\n-                    if attr::contains_name(phases, \"syntax\") {\n-                        plugin_phase = true;\n-                        self.sess.span_warn(attr.span,\n-                            \"phase(syntax) is a deprecated synonym for phase(plugin)\");\n+                }\n+                \"macro_reexport\" => {\n+                    let names = match attr.meta_item_list() {\n+                        Some(names) => names,\n+                        None => {\n+                            self.sess.span_err(attr.span, \"bad macro reexport\");\n+                            continue;\n+                        }\n+                    };\n+\n+                    for name in names.iter() {\n+                        if let ast::MetaWord(ref name) = name.node {\n+                            reexport.insert(name.clone());\n+                        } else {\n+                            self.sess.span_err(name.span, \"bad macro reexport\");\n+                        }\n                     }\n                 }\n+                _ => used = false,\n+            }\n+            if used {\n+                attr::mark_used(attr);\n+            }\n+        }\n \n-                if !plugin_phase { return; }\n+        let mut macros = vec![];\n+        let mut registrar = None;\n \n-                let PluginMetadata { macros, lib, registrar_symbol } =\n-                    self.reader.read_plugin_metadata(vi);\n+        let load_macros = match macro_selection.as_ref() {\n+            Some(sel) => sel.len() != 0 || reexport.len() != 0,\n+            None => true,\n+        };\n+        let load_registrar = plugin_attr.is_some();\n \n-                self.plugins.macros.push(ExportedMacros {\n-                    crate_name: name,\n-                    macros: macros,\n-                });\n+        if load_macros && !self.span_whitelist.contains(&vi.span) {\n+            self.sess.span_err(vi.span, \"an `extern crate` loading macros must be at \\\n+                                         the crate root\");\n+        }\n \n-                match (lib, registrar_symbol) {\n-                    (Some(lib), Some(symbol))\n-                        => self.dylink_registrar(vi, lib, symbol),\n-                    _ => (),\n-                }\n+        if load_macros || load_registrar {\n+            let pmd = self.reader.read_plugin_metadata(vi);\n+            if load_macros {\n+                macros = pmd.exported_macros();\n+            }\n+            if load_registrar {\n+                registrar = pmd.plugin_registrar();\n             }\n-            _ => (),\n+        }\n+\n+        for mut def in macros.into_iter() {\n+            let name = token::get_ident(def.ident);\n+            def.use_locally = match macro_selection.as_ref() {\n+                None => true,\n+                Some(sel) => sel.contains(&name),\n+            };\n+            def.export = reexport.contains(&name);\n+            self.plugins.macros.push(def);\n+        }\n+\n+        if let Some((lib, symbol)) = registrar {\n+            let fun = self.dylink_registrar(vi, lib, symbol);\n+            self.plugins.registrars.push(PluginRegistrar {\n+                fun: fun,\n+                args: plugin_attr.unwrap(),\n+            });\n         }\n     }\n+\n     fn visit_mac(&mut self, _: &ast::Mac) {\n         // bummer... can't see plugins inside macros.\n         // do nothing.\n@@ -132,7 +211,10 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n \n impl<'a> PluginLoader<'a> {\n     // Dynamically link a registrar function into the compiler process.\n-    fn dylink_registrar(&mut self, vi: &ast::ViewItem, path: Path, symbol: String) {\n+    fn dylink_registrar(&mut self,\n+                        vi: &ast::ViewItem,\n+                        path: Path,\n+                        symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n         let path = os::make_absolute(&path).unwrap();\n \n@@ -154,13 +236,12 @@ impl<'a> PluginLoader<'a> {\n                     Err(err) => self.sess.span_fatal(vi.span, err[])\n                 };\n \n-            self.plugins.registrars.push(registrar);\n-\n             // Intentionally leak the dynamic library. We can't ever unload it\n             // since the library can make things that will live arbitrarily long\n             // (e.g. an @-box cycle or a task).\n             mem::forget(lib);\n \n+            registrar\n         }\n     }\n }"}, {"sha": "fd8873454b4d983fe21831454c17fe083744075e", "filename": "src/librustc/plugin/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fplugin%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fplugin%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -43,14 +43,14 @@\n //! To use a plugin while compiling another crate:\n //!\n //! ```rust\n-//! #![feature(phase)]\n+//! #![feature(plugin)]\n //!\n-//! #[phase(plugin)]\n+//! #[plugin]\n //! extern crate myplugin;\n //! ```\n //!\n-//! If you also need the plugin crate available at runtime, use\n-//! `phase(plugin, link)`.\n+//! If you don't need the plugin crate available at runtime, use\n+//! `#[no_link]` as well.\n //!\n //! See [the compiler plugin guide](../../guide-plugin.html)\n //! for more examples."}, {"sha": "feec97f02da55dd204399f7bdf39066605298934", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,12 +11,14 @@\n //! Used by plugin crates to tell `rustc` about the plugins they provide.\n \n use lint::{LintPassObject, LintId, Lint};\n+use session::Session;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, LetSyntaxTT, Decorator, Modifier};\n+use syntax::ext::base::{IdentTT, Decorator, Modifier, MacroRulesTT};\n use syntax::ext::base::{MacroExpanderFn};\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::ptr::P;\n use syntax::ast;\n \n use std::collections::HashMap;\n@@ -29,7 +31,14 @@ use std::collections::HashMap;\n /// This struct has public fields and other methods for use by `rustc`\n /// itself. They are not documented here, and plugin authors should\n /// not use them.\n-pub struct Registry {\n+pub struct Registry<'a> {\n+    /// Compiler session. Useful if you want to emit diagnostic messages\n+    /// from the plugin registrar.\n+    pub sess: &'a Session,\n+\n+    #[doc(hidden)]\n+    pub args_hidden: Option<P<ast::MetaItem>>,\n+\n     #[doc(hidden)]\n     pub krate_span: Span,\n \n@@ -43,17 +52,27 @@ pub struct Registry {\n     pub lint_groups: HashMap<&'static str, Vec<LintId>>,\n }\n \n-impl Registry {\n+impl<'a> Registry<'a> {\n     #[doc(hidden)]\n-    pub fn new(krate: &ast::Crate) -> Registry {\n+    pub fn new(sess: &'a Session, krate: &ast::Crate) -> Registry<'a> {\n         Registry {\n+            sess: sess,\n+            args_hidden: None,\n             krate_span: krate.span,\n             syntax_exts: vec!(),\n             lint_passes: vec!(),\n             lint_groups: HashMap::new(),\n         }\n     }\n \n+    /// Get the `#[plugin]` attribute used to load this plugin.\n+    ///\n+    /// This gives access to arguments passed via `#[plugin=...]` or\n+    /// `#[plugin(...)]`.\n+    pub fn args<'b>(&'b self) -> &'b P<ast::MetaItem> {\n+        self.args_hidden.as_ref().expect(\"args not set\")\n+    }\n+\n     /// Register a syntax extension of any kind.\n     ///\n     /// This is the most general hook into `libsyntax`'s expansion behavior.\n@@ -63,8 +82,11 @@ impl Registry {\n             IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n             Decorator(ext) => Decorator(ext),\n             Modifier(ext) => Modifier(ext),\n-            // there's probably a nicer way to signal this:\n-            LetSyntaxTT(_, _) => panic!(\"can't register a new LetSyntax!\"),\n+\n+            MacroRulesTT => {\n+                self.sess.err(\"plugin tried to register a new MacroRulesTT\");\n+                return;\n+            }\n         }));\n     }\n "}, {"sha": "238c84e88a9e0178fb37d9e17ffca8fd71535ee5", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -34,8 +34,14 @@\n #![feature(unboxed_closures)]\n #![feature(old_orphan_check)]\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n extern crate syntax;\n extern crate serialize;\n "}, {"sha": "d606c5158d0f7d930ae003664e2ac4cee9f47f59", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -346,12 +346,12 @@ impl Engine256State {\n \n         // Sha-512 and Sha-256 use basically the same calculations which are implemented\n         // by these macros. Inlining the calculations seems to result in better generated code.\n-        macro_rules! schedule_round( ($t:expr) => (\n+        macro_rules! schedule_round { ($t:expr) => (\n                 w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n                 )\n-        );\n+        }\n \n-        macro_rules! sha2_round(\n+        macro_rules! sha2_round {\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n              $E:ident, $F:ident, $G:ident, $H:ident, $K:ident, $t:expr) => (\n                 {\n@@ -360,7 +360,7 @@ impl Engine256State {\n                     $H += sum0($A) + maj($A, $B, $C);\n                 }\n              )\n-        );\n+        }\n \n         read_u32v_be(w.slice_mut(0, 16), data);\n "}, {"sha": "86bd74d3f85e5b2ca97769ca579130767638a09a", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -327,11 +327,11 @@ mod svh_visitor {\n \n     impl<'a, 'v> Visitor<'v> for StrictVersionHashVisitor<'a> {\n \n-        fn visit_mac(&mut self, macro: &Mac) {\n+        fn visit_mac(&mut self, mac: &Mac) {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n-            if macro_name(macro).get() == \"macro_rules\" {\n+            if macro_name(mac).get() == \"macro_rules\" {\n                 // Pretty-printing definition to a string strips out\n                 // surface artifacts (currently), such as the span\n                 // information, yielding a content-based hash.\n@@ -341,22 +341,22 @@ mod svh_visitor {\n                 // trees might be faster. Implementing this is far\n                 // easier in short term.\n                 let macro_defn_as_string = pprust::to_string(|pp_state| {\n-                    pp_state.print_mac(macro, token::Paren)\n+                    pp_state.print_mac(mac, token::Paren)\n                 });\n                 macro_defn_as_string.hash(self.st);\n             } else {\n                 // It is not possible to observe any kind of macro\n                 // invocation at this stage except `macro_rules!`.\n                 panic!(\"reached macro somehow: {}\",\n                       pprust::to_string(|pp_state| {\n-                          pp_state.print_mac(macro, token::Paren)\n+                          pp_state.print_mac(mac, token::Paren)\n                       }));\n             }\n \n-            visit::walk_mac(self, macro);\n+            visit::walk_mac(self, mac);\n \n-            fn macro_name(macro: &Mac) -> token::InternedString {\n-                match &macro.node {\n+            fn macro_name(mac: &Mac) -> token::InternedString {\n+                match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n                         let s = path.segments[];\n                         assert_eq!(s.len(), 1);"}, {"sha": "f14583bb9aa81b23282861f47019b9786790d6ce", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -239,7 +239,7 @@ impl Target {\n             options: Default::default(),\n         };\n \n-        macro_rules! key (\n+        macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n                 obj.find(name[]).map(|o| o.as_string()\n@@ -257,7 +257,7 @@ impl Target {\n                         )\n                     );\n             } );\n-        );\n+        }\n \n         key!(cpu);\n         key!(linker);\n@@ -305,7 +305,7 @@ impl Target {\n         }\n \n         // this would use a match if stringify! were allowed in pattern position\n-        macro_rules! load_specific (\n+        macro_rules! load_specific {\n             ( $($name:ident),+ ) => (\n                 {\n                     let target = target.replace(\"-\", \"_\");\n@@ -326,7 +326,7 @@ impl Target {\n                     }\n                 }\n             )\n-        );\n+        }\n \n         load_specific!(\n             x86_64_unknown_linux_gnu,"}, {"sha": "20949151557cbeec572e1cd76102e75ec5d2c399", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -39,15 +39,6 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{FnDecl, Block, NodeId};\n \n-macro_rules! if_ok {\n-    ($inp: expr) => (\n-        match $inp {\n-            Ok(v) => { v }\n-            Err(e) => { return Err(e); }\n-        }\n-    )\n-}\n-\n pub mod doc;\n \n pub mod check_loans;"}, {"sha": "0600ddba01897e1e257848c6533ca51b90c9c67a", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -24,8 +24,21 @@\n #![feature(old_orphan_check)]\n #![allow(non_camel_case_types)]\n \n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n // for \"clarity\", rename the graphviz crate to dot; graphviz within `borrowck`\n // refers to the borrowck-specific graphviz adapter traits."}, {"sha": "74f81ae9d6d1eeb7f256f4cc940e847caa7a574d", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,7 +12,7 @@ use rustc::session::Session;\n use rustc::session::config::{self, Input, OutputFilenames};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n-use rustc::metadata::creader;\n+use rustc::metadata::creader::CrateReader;\n use rustc::middle::{stability, ty, reachable};\n use rustc::middle::dependency_format;\n use rustc::middle;\n@@ -182,7 +182,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     // strip before expansion to allow macros to depend on\n     // configuration variables e.g/ in\n     //\n-    //   #[macro_escape] #[cfg(foo)]\n+    //   #[macro_use] #[cfg(foo)]\n     //   mod bar { macro_rules! baz!(() => {{}}) }\n     //\n     // baz! should not use this definition unless foo is enabled.\n@@ -216,9 +216,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n         = time(time_passes, \"plugin loading\", (), |_|\n                plugin::load::load_plugins(sess, &krate, addl_plugins.take().unwrap()));\n \n-    let mut registry = Registry::new(&krate);\n+    let mut registry = Registry::new(sess, &krate);\n \n-    time(time_passes, \"plugin registration\", (), |_| {\n+    time(time_passes, \"plugin registration\", registrars, |registrars| {\n         if sess.features.borrow().rustc_diagnostic_macros {\n             registry.register_macro(\"__diagnostic_used\",\n                 diagnostics::plugin::expand_diagnostic_used);\n@@ -228,8 +228,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n                 diagnostics::plugin::expand_build_diagnostic_array);\n         }\n \n-        for &registrar in registrars.iter() {\n-            registrar(&mut registry);\n+        for registrar in registrars.into_iter() {\n+            registry.args_hidden = Some(registrar.args);\n+            (registrar.fun)(&mut registry);\n         }\n     });\n \n@@ -351,7 +352,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", (), |_|\n-         creader::read_crates(&sess, krate));\n+         CrateReader::new(&sess).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", (), |_|\n                           middle::lang_items::collect_language_items(krate, &sess));"}, {"sha": "89b2e0f257acd97b5ca75a1b0c2b393e0f7e84dc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -39,11 +39,25 @@ extern crate rustc_borrowck;\n extern crate rustc_resolve;\n extern crate rustc_trans;\n extern crate rustc_typeck;\n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n \n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n+\n pub use syntax::diagnostic;\n \n use rustc_trans::back::link;"}, {"sha": "61fd7d16ab7ddea401a618297fa3dc6e7cafc56d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -484,8 +484,8 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n     // in general the pretty printer processes unexpanded code, so\n     // we override the default `fold_mac` method which panics.\n-    fn fold_mac(&mut self, _macro: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(_macro, self)\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n "}, {"sha": "58102fe5629d9f43bc2656d609830f2451a0f68e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -21,8 +21,21 @@\n #![feature(associated_types)]\n #![feature(old_orphan_check)]\n \n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n extern crate rustc;\n "}, {"sha": "705fecf4d198eec8b7590c53b659c719dbf93fdf", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -37,11 +37,25 @@ extern crate graphviz;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_back;\n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n extern crate serialize;\n extern crate \"rustc_llvm\" as llvm;\n \n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n+\n pub use rustc::session;\n pub use rustc::metadata;\n pub use rustc::middle;"}, {"sha": "3726cf14023ee35c88ac7b05af5cbe377ff75b87", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -736,7 +736,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n }\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n-    macro_rules! ifn (\n+    macro_rules! ifn {\n         ($name:expr fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(\n@@ -754,10 +754,10 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    );\n-    macro_rules! mk_struct (\n+    }\n+    macro_rules! mk_struct {\n         ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n-    );\n+    }\n \n     let i8p = Type::i8p(ccx);\n     let void = Type::void(ccx);\n@@ -878,7 +878,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n     // were introduced in LLVM 3.4, so we case on that.\n-    macro_rules! compatible_ifn (\n+    macro_rules! compatible_ifn {\n         ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n                 // The `if key == $name` is already in ifn!\n@@ -891,7 +891,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    );\n+    }\n \n     compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n     compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);"}, {"sha": "77efcc6fb0030d9d768d644c02f30696ec91b09b", "filename": "src/librustc_trans/trans/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n macro_rules! unpack_datum {\n     ($bcx: ident, $inp: expr) => (\n         {"}, {"sha": "fa9cd5a698bbe05784d661832f89cbb630529f90", "filename": "src/librustc_trans/trans/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_trans%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -16,8 +16,11 @@ pub use self::base::trans_crate;\n pub use self::context::CrateContext;\n pub use self::common::gensym_name;\n \n-mod doc;\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n+\n+mod doc;\n mod inline;\n mod monomorphize;\n mod controlflow;"}, {"sha": "dc434f1401585af1fa782235e983011bb418430e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -77,8 +77,21 @@ This API is completely unstable and subject to change.\n #![feature(unboxed_closures)]\n #![allow(non_camel_case_types)]\n \n-#[phase(plugin, link)] extern crate log;\n-#[phase(plugin, link)] extern crate syntax;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate syntax;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate syntax;\n \n extern crate arena;\n extern crate rustc;"}, {"sha": "30b9d6c63c5bb127db68bb38141011e850ed0f3c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -166,6 +166,9 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n                 }\n             }\n \n+            // Special macro vars are like keywords\n+            token::SpecialVarNt(_) => \"kw-2\",\n+\n             token::Lifetime(..) => \"lifetime\",\n             token::DocComment(..) => \"doccomment\",\n             token::Underscore | token::Eof | token::Interpolated(..) |"}, {"sha": "6e42c50f974c51f2a4748db95d47c78a2ddf9fbe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -32,7 +32,14 @@ extern crate rustc_driver;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;\n-#[phase(plugin, link)] extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n \n extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n@@ -49,11 +56,13 @@ use rustc::session::search_paths::SearchPaths;\n // reexported from `clean` so it can be easily updated with the mod itself\n pub use clean::SCHEMA_VERSION;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod externalfiles;\n+\n pub mod clean;\n pub mod core;\n pub mod doctree;\n-#[macro_escape]\n-pub mod externalfiles;\n pub mod fold;\n pub mod html {\n     pub mod highlight;"}, {"sha": "ad67672ea6ea741a35dc916fe31c990ee0f183f2", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                                               None);\n         // attach the crate's exported macros to the top-level module:\n         self.module.macros = krate.exported_macros.iter()\n-            .map(|it| self.visit_macro(&**it)).collect();\n+            .map(|def| self.visit_macro(def)).collect();\n         self.module.is_crate = true;\n     }\n \n@@ -363,13 +363,13 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     // convert each exported_macro into a doc item\n-    fn visit_macro(&self, item: &ast::Item) -> Macro {\n+    fn visit_macro(&self, def: &ast::MacroDef) -> Macro {\n         Macro {\n-            id: item.id,\n-            attrs: item.attrs.clone(),\n-            name: item.ident,\n-            whence: item.span,\n-            stab: self.stability(item.id),\n+            id: def.id,\n+            attrs: def.attrs.clone(),\n+            name: def.ident,\n+            whence: def.span,\n+            stab: self.stability(def.id),\n         }\n     }\n }"}, {"sha": "8fe15f00ded73e55f60285fd6720e192686b49fb", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -31,8 +31,14 @@ Core encoding and decoding interfaces.\n #[cfg(test)]\n extern crate test;\n \n+#[cfg(stage0)]\n #[phase(plugin, link)]\n extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n extern crate unicode;\n \n extern crate collections;"}, {"sha": "ed3f2cbe1a1da3f5471e06bb12aa2d0de1f0309d", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "38ea4dad027a09b0a6d41b6a816501d16b773920", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -21,7 +21,9 @@ use hash::{Hash, Hasher, RandomSipHasher};\n use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n-use result::Result::{Ok, Err};\n+\n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::{Ok, Err};\n \n use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n "}, {"sha": "d590aa8419453d6de9ce3ed35c62fba98b719052", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -18,11 +18,14 @@ use iter::{IteratorExt, ExactSizeIterator};\n use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n use slice::{SliceExt};\n use slice;\n use vec::Vec;\n \n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n+\n /// Wraps a Reader and buffers input from it\n ///\n /// It can be excessively inefficient to work directly with a `Reader`. For"}, {"sha": "5bef473db990c8879a7fcb23d801ad6a88321769", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -282,10 +282,13 @@ pub mod net;\n pub mod pipe;\n pub mod process;\n pub mod stdio;\n-pub mod test;\n pub mod timer;\n pub mod util;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod test;\n+\n /// The default buffer size for various I/O operations\n // libuv recommends 64k buffers to maximize throughput\n // https://groups.google.com/forum/#!topic/libuv/oQO1HJAIDdA"}, {"sha": "6eeef175f73d50844c1d17123385c3cc544a61da", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,6 @@\n \n //! Various utility functions useful for writing I/O tests\n \n-#![macro_escape]\n-\n use prelude::v1::*;\n \n use libc;"}, {"sha": "e937cd24d8d78274f128f9f6c95528128347ba46", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 55, "deletions": 6, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -117,13 +117,36 @@\n \n #![reexport_test_harness_main = \"test_main\"]\n \n-#[cfg(test)] #[phase(plugin, link)] extern crate log;\n+#[cfg(all(test, stage0))]\n+#[phase(plugin, link)]\n+extern crate log;\n \n-extern crate alloc;\n-extern crate unicode;\n+#[cfg(all(test, not(stage0)))]\n+#[macro_use]\n+extern crate log;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate core;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+#[macro_reexport(assert, assert_eq, debug_assert, debug_assert_eq,\n+    unreachable, unimplemented, write, writeln)]\n extern crate core;\n+\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate \"collections\" as core_collections;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+#[macro_reexport(vec)]\n extern crate \"collections\" as core_collections;\n+\n extern crate \"rand\" as core_rand;\n+extern crate alloc;\n+extern crate unicode;\n extern crate libc;\n \n // Make std testable by not duplicating lang items. See #2912\n@@ -167,7 +190,18 @@ pub use unicode::char;\n \n /* Exported macros */\n \n+#[cfg(stage0)]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod macros_stage0;\n+\n+#[cfg(not(stage0))]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod macros;\n+\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod bitflags;\n \n mod rtdeps;\n@@ -179,9 +213,20 @@ pub mod prelude;\n \n /* Primitive types */\n \n-#[path = \"num/float_macros.rs\"] mod float_macros;\n-#[path = \"num/int_macros.rs\"]   mod int_macros;\n-#[path = \"num/uint_macros.rs\"]  mod uint_macros;\n+#[path = \"num/float_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod float_macros;\n+\n+#[path = \"num/int_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod int_macros;\n+\n+#[path = \"num/uint_macros.rs\"]\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n #[path = \"num/i8.rs\"]   pub mod i8;\n@@ -210,6 +255,10 @@ pub mod num;\n \n pub mod thread_local; // first for macros\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n+pub mod thread_local;\n+\n pub mod dynamic_lib;\n pub mod ffi;\n pub mod fmt;"}, {"sha": "22cbf16e2b0b98d80483556d894b8a3e6df7236f", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 4, "deletions": 41, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -15,7 +15,6 @@\n //! library.\n \n #![experimental]\n-#![macro_escape]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -246,34 +245,6 @@ macro_rules! format {\n     ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n }\n \n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n-/// See `std::fmt` for more information.\n-///\n-/// # Example\n-///\n-/// ```\n-/// # #![allow(unused_must_use)]\n-///\n-/// let mut w = Vec::new();\n-/// write!(&mut w, \"test\");\n-/// write!(&mut w, \"formatted {}\", \"arguments\");\n-/// ```\n-#[macro_export]\n-#[stable]\n-macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n-}\n-\n-/// Equivalent to the `write!` macro, except that a newline is appended after\n-/// the message is written.\n-#[macro_export]\n-#[stable]\n-macro_rules! writeln {\n-    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n-        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n-    )\n-}\n-\n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n@@ -306,23 +277,15 @@ macro_rules! println {\n #[macro_export]\n macro_rules! try {\n     ($expr:expr) => ({\n+        use $crate::result::Result::{Ok, Err};\n+\n         match $expr {\n             Ok(val) => val,\n-            Err(err) => return Err(::std::error::FromError::from_error(err))\n+            Err(err) => return Err($crate::error::FromError::from_error(err)),\n         }\n     })\n }\n \n-/// Create a `std::vec::Vec` containing the arguments.\n-#[macro_export]\n-macro_rules! vec {\n-    ($($x:expr),*) => ({\n-        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n-        ::std::slice::SliceExt::into_vec(xs)\n-    });\n-    ($($x:expr,)*) => (vec![$($x),*])\n-}\n-\n /// A macro to select an event from a number of receivers.\n ///\n /// This macro is used to wait for the first event to occur on a number of\n@@ -358,7 +321,7 @@ macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n     ) => ({\n-        use std::sync::mpsc::Select;\n+        use $crate::sync::mpsc::Select;\n         let sel = Select::new();\n         $( let mut $rx = sel.handle(&$rx); )+\n         unsafe {"}, {"sha": "48d62e73e13edeba26b4b7f7907dc6a23716bb65", "filename": "src/libstd/macros_stage0.rs", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fmacros_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fmacros_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros_stage0.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,648 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Standard library macros\n+//!\n+//! This modules contains a set of macros which are exported from the standard\n+//! library. Each macro is available for use when linking against the standard\n+//! library.\n+\n+#![experimental]\n+\n+/// The entry point for panic of Rust tasks.\n+///\n+/// This macro is used to inject panic into a Rust task, causing the task to\n+/// unwind and panic entirely. Each task's panic can be reaped as the\n+/// `Box<Any>` type, and the single-argument form of the `panic!` macro will be\n+/// the value which is transmitted.\n+///\n+/// The multi-argument form of this macro panics with a string and has the\n+/// `format!` syntax for building a string.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #![allow(unreachable_code)]\n+/// panic!();\n+/// panic!(\"this is a terrible mistake!\");\n+/// panic!(4i); // panic with the value of 4 to be collected elsewhere\n+/// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n+/// ```\n+#[macro_export]\n+macro_rules! panic {\n+    () => ({\n+        panic!(\"explicit panic\")\n+    });\n+    ($msg:expr) => ({\n+        // static requires less code at runtime, more constant data\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind($msg, &_FILE_LINE)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        // The leading _'s are to avoid dead code warnings if this is\n+        // used inside a dead function. Just `#[allow(dead_code)]` is\n+        // insufficient, since the user may have\n+        // `#[forbid(dead_code)]` and which cannot be overridden.\n+        static _FILE_LINE: (&'static str, uint) = (file!(), line!());\n+        ::std::rt::begin_unwind_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+\n+    });\n+}\n+\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// assert!(true);\n+/// # fn some_computation() -> bool { true }\n+/// assert!(some_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! assert {\n+    ($cond:expr) => (\n+        if !$cond {\n+            panic!(concat!(\"assertion failed: \", stringify!($cond)))\n+        }\n+    );\n+    ($cond:expr, $($arg:expr),+) => (\n+        if !$cond {\n+            panic!($($arg),+)\n+        }\n+    );\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// assert_eq!(a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! assert_eq {\n+    ($left:expr , $right:expr) => ({\n+        match (&($left), &($right)) {\n+            (left_val, right_val) => {\n+                // check both directions of equality....\n+                if !((*left_val == *right_val) &&\n+                     (*right_val == *left_val)) {\n+                    panic!(\"assertion failed: `(left == right) && (right == left)` \\\n+                           (left: `{}`, right: `{}`)\", *left_val, *right_val)\n+                }\n+            }\n+        }\n+    })\n+}\n+\n+/// Ensure that a boolean expression is `true` at runtime.\n+///\n+/// This will invoke the `panic!` macro if the provided expression cannot be\n+/// evaluated to `true` at runtime.\n+///\n+/// Unlike `assert!`, `debug_assert!` statements can be disabled by passing\n+/// `--cfg ndebug` to the compiler. This makes `debug_assert!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// // the panic message for these assertions is the stringified value of the\n+/// // expression given.\n+/// debug_assert!(true);\n+/// # fn some_expensive_computation() -> bool { true }\n+/// debug_assert!(some_expensive_computation());\n+///\n+/// // assert with a custom message\n+/// # let x = true;\n+/// debug_assert!(x, \"x wasn't true!\");\n+/// # let a = 3i; let b = 27i;\n+/// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n+}\n+\n+/// Asserts that two expressions are equal to each other, testing equality in\n+/// both directions.\n+///\n+/// On panic, this macro will print the values of the expressions.\n+///\n+/// Unlike `assert_eq!`, `debug_assert_eq!` statements can be disabled by\n+/// passing `--cfg ndebug` to the compiler. This makes `debug_assert_eq!`\n+/// useful for checks that are too expensive to be present in a release build\n+/// but may be helpful during development.\n+///\n+/// # Example\n+///\n+/// ```\n+/// let a = 3i;\n+/// let b = 1i + 2i;\n+/// debug_assert_eq!(a, b);\n+/// ```\n+#[macro_export]\n+macro_rules! debug_assert_eq {\n+    ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n+}\n+\n+/// A utility macro for indicating unreachable code.\n+///\n+/// This is useful any time that the compiler can't determine that some code is unreachable. For\n+/// example:\n+///\n+/// * Match arms with guard conditions.\n+/// * Loops that dynamically terminate.\n+/// * Iterators that dynamically terminate.\n+///\n+/// # Panics\n+///\n+/// This will always panic.\n+///\n+/// # Examples\n+///\n+/// Match arms:\n+///\n+/// ```rust\n+/// fn foo(x: Option<int>) {\n+///     match x {\n+///         Some(n) if n >= 0 => println!(\"Some(Non-negative)\"),\n+///         Some(n) if n <  0 => println!(\"Some(Negative)\"),\n+///         Some(_)           => unreachable!(), // compile error if commented out\n+///         None              => println!(\"None\")\n+///     }\n+/// }\n+/// ```\n+///\n+/// Iterators:\n+///\n+/// ```rust\n+/// fn divide_by_three(x: u32) -> u32 { // one of the poorest implementations of x/3\n+///     for i in std::iter::count(0_u32, 1) {\n+///         if 3*i < i { panic!(\"u32 overflow\"); }\n+///         if x < 3*i { return i-1; }\n+///     }\n+///     unreachable!();\n+/// }\n+/// ```\n+#[macro_export]\n+macro_rules! unreachable {\n+    () => ({\n+        panic!(\"internal error: entered unreachable code\")\n+    });\n+    ($msg:expr) => ({\n+        unreachable!(\"{}\", $msg)\n+    });\n+    ($fmt:expr, $($arg:tt)*) => ({\n+        panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n+    });\n+}\n+\n+/// A standardised placeholder for marking unfinished code. It panics with the\n+/// message `\"not yet implemented\"` when executed.\n+#[macro_export]\n+macro_rules! unimplemented {\n+    () => (panic!(\"not yet implemented\"))\n+}\n+\n+/// Use the syntax described in `std::fmt` to create a value of type `String`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// format!(\"test\");\n+/// format!(\"hello {}\", \"world!\");\n+/// format!(\"x = {}, y = {y}\", 10i, y = 30i);\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! format {\n+    ($($arg:tt)*) => (::std::fmt::format(format_args!($($arg)*)))\n+}\n+\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// See `std::fmt` for more information.\n+///\n+/// # Example\n+///\n+/// ```\n+/// # #![allow(unused_must_use)]\n+///\n+/// let mut w = Vec::new();\n+/// write!(&mut w, \"test\");\n+/// write!(&mut w, \"formatted {}\", \"arguments\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! write {\n+    ($dst:expr, $($arg:tt)*) => ((&mut *$dst).write_fmt(format_args!($($arg)*)))\n+}\n+\n+/// Equivalent to the `write!` macro, except that a newline is appended after\n+/// the message is written.\n+#[macro_export]\n+#[stable]\n+macro_rules! writeln {\n+    ($dst:expr, $fmt:expr $($arg:tt)*) => (\n+        write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n+    )\n+}\n+\n+/// Equivalent to the `println!` macro except that a newline is not printed at\n+/// the end of the message.\n+#[macro_export]\n+#[stable]\n+macro_rules! print {\n+    ($($arg:tt)*) => (::std::io::stdio::print_args(format_args!($($arg)*)))\n+}\n+\n+/// Macro for printing to a task's stdout handle.\n+///\n+/// Each task can override its stdout handle via `std::io::stdio::set_stdout`.\n+/// The syntax of this macro is the same as that used for `format!`. For more\n+/// information, see `std::fmt` and `std::io::stdio`.\n+///\n+/// # Example\n+///\n+/// ```\n+/// println!(\"hello there!\");\n+/// println!(\"format {} arguments\", \"some\");\n+/// ```\n+#[macro_export]\n+#[stable]\n+macro_rules! println {\n+    ($($arg:tt)*) => (::std::io::stdio::println_args(format_args!($($arg)*)))\n+}\n+\n+/// Helper macro for unwrapping `Result` values while returning early with an\n+/// error if the value of the expression is `Err`. For more information, see\n+/// `std::io`.\n+#[macro_export]\n+macro_rules! try {\n+    ($expr:expr) => ({\n+        match $expr {\n+            Ok(val) => val,\n+            Err(err) => return Err(::std::error::FromError::from_error(err))\n+        }\n+    })\n+}\n+\n+/// Create a `std::vec::Vec` containing the arguments.\n+#[macro_export]\n+macro_rules! vec {\n+    ($($x:expr),*) => ({\n+        let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n+        ::std::slice::SliceExt::into_vec(xs)\n+    });\n+    ($($x:expr,)*) => (vec![$($x),*])\n+}\n+\n+/// A macro to select an event from a number of receivers.\n+///\n+/// This macro is used to wait for the first event to occur on a number of\n+/// receivers. It places no restrictions on the types of receivers given to\n+/// this macro, this can be viewed as a heterogeneous select.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::thread::Thread;\n+/// use std::sync::mpsc::channel;\n+///\n+/// let (tx1, rx1) = channel();\n+/// let (tx2, rx2) = channel();\n+/// # fn long_running_task() {}\n+/// # fn calculate_the_answer() -> int { 42i }\n+///\n+/// Thread::spawn(move|| { long_running_task(); tx1.send(()) }).detach();\n+/// Thread::spawn(move|| { tx2.send(calculate_the_answer()) }).detach();\n+///\n+/// select! (\n+///     _ = rx1.recv() => println!(\"the long running task finished first\"),\n+///     answer = rx2.recv() => {\n+///         println!(\"the answer was: {}\", answer.unwrap());\n+///     }\n+/// )\n+/// ```\n+///\n+/// For more information about select, see the `std::sync::mpsc::Select` structure.\n+#[macro_export]\n+#[experimental]\n+macro_rules! select {\n+    (\n+        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n+    ) => ({\n+        use std::sync::mpsc::Select;\n+        let sel = Select::new();\n+        $( let mut $rx = sel.handle(&$rx); )+\n+        unsafe {\n+            $( $rx.add(); )+\n+        }\n+        let ret = sel.wait();\n+        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n+        { unreachable!() }\n+    })\n+}\n+\n+// When testing the standard library, we link to the liblog crate to get the\n+// logging macros. In doing so, the liblog crate was linked against the real\n+// version of libstd, and uses a different std::fmt module than the test crate\n+// uses. To get around this difference, we redefine the log!() macro here to be\n+// just a dumb version of what it should be.\n+#[cfg(test)]\n+macro_rules! log {\n+    ($lvl:expr, $($args:tt)*) => (\n+        if log_enabled!($lvl) { println!($($args)*) }\n+    )\n+}\n+\n+/// Built-in macros to the compiler itself.\n+///\n+/// These macros do not have any corresponding definition with a `macro_rules!`\n+/// macro, but are documented here. Their implementations can be found hardcoded\n+/// into libsyntax itself.\n+#[cfg(dox)]\n+pub mod builtin {\n+    /// The core macro for formatted string creation & output.\n+    ///\n+    /// This macro produces a value of type `fmt::Arguments`. This value can be\n+    /// passed to the functions in `std::fmt` for performing useful functions.\n+    /// All other formatting macros (`format!`, `write!`, `println!`, etc) are\n+    /// proxied through this one.\n+    ///\n+    /// For more information, see the documentation in `std::fmt`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// let s = fmt::format(format_args!(\"hello {}\", \"world\"));\n+    /// assert_eq!(s, format!(\"hello {}\", \"world\"));\n+    ///\n+    /// ```\n+    #[macro_export]\n+    macro_rules! format_args { ($fmt:expr $($args:tt)*) => ({\n+        /* compiler built-in */\n+    }) }\n+\n+    /// Inspect an environment variable at compile time.\n+    ///\n+    /// This macro will expand to the value of the named environment variable at\n+    /// compile time, yielding an expression of type `&'static str`.\n+    ///\n+    /// If the environment variable is not defined, then a compilation error\n+    /// will be emitted.  To not emit a compile error, use the `option_env!`\n+    /// macro instead.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let path: &'static str = env!(\"PATH\");\n+    /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Optionally inspect an environment variable at compile time.\n+    ///\n+    /// If the named environment variable is present at compile time, this will\n+    /// expand into an expression of type `Option<&'static str>` whose value is\n+    /// `Some` of the value of the environment variable. If the environment\n+    /// variable is not present, then this will expand to `None`.\n+    ///\n+    /// A compile time error is never emitted when using this macro regardless\n+    /// of whether the environment variable is present or not.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let key: Option<&'static str> = option_env!(\"SECRET_KEY\");\n+    /// println!(\"the secret key might be: {}\", key);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate literals into a static byte slice.\n+    ///\n+    /// This macro takes any number of comma-separated literal expressions,\n+    /// yielding an expression of type `&'static [u8]` which is the\n+    /// concatenation (left to right) of all the literals in their byte format.\n+    ///\n+    /// This extension currently only supports string literals, character\n+    /// literals, and integers less than 256. The byte slice returned is the\n+    /// utf8-encoding of strings and characters.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let rust = bytes!(\"r\", 'u', \"st\", 255);\n+    /// assert_eq!(rust[1], b'u');\n+    /// assert_eq!(rust[4], 255);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! bytes { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// Concatenate identifiers into one identifier.\n+    ///\n+    /// This macro takes any number of comma-separated identifiers, and\n+    /// concatenates them all into one, yielding an expression which is a new\n+    /// identifier. Note that hygiene makes it such that this macro cannot\n+    /// capture local variables, and macros are only allowed in item,\n+    /// statement or expression position, meaning this macro may be difficult to\n+    /// use in some situations.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(concat_idents)]\n+    ///\n+    /// # fn main() {\n+    /// fn foobar() -> int { 23 }\n+    ///\n+    /// let f = concat_idents!(foo, bar);\n+    /// println!(\"{}\", f());\n+    /// # }\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat_idents {\n+        ($($e:ident),*) => ({ /* compiler built-in */ })\n+    }\n+\n+    /// Concatenates literals into a static string slice.\n+    ///\n+    /// This macro takes any number of comma-separated literals, yielding an\n+    /// expression of type `&'static str` which represents all of the literals\n+    /// concatenated left-to-right.\n+    ///\n+    /// Integer and floating point literals are stringified in order to be\n+    /// concatenated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let s = concat!(\"test\", 10i, 'b', true);\n+    /// assert_eq!(s, \"test10btrue\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the line number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned line is not\n+    /// the invocation of the `line!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `line!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_line = line!();\n+    /// println!(\"defined on line: {}\", current_line);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! line { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the column number on which it was invoked.\n+    ///\n+    /// The expanded expression has type `uint`, and the returned column is not\n+    /// the invocation of the `column!()` macro itself, but rather the first macro\n+    /// invocation leading up to the invocation of the `column!()` macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let current_col = column!();\n+    /// println!(\"defined on column: {}\", current_col);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! column { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which expands to the file name from which it was invoked.\n+    ///\n+    /// The expanded expression has type `&'static str`, and the returned file\n+    /// is not the invocation of the `file!()` macro itself, but rather the\n+    /// first macro invocation leading up to the invocation of the `file!()`\n+    /// macro.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let this_file = file!();\n+    /// println!(\"defined in file: {}\", this_file);\n+    /// ```\n+    #[macro_export]\n+    macro_rules! file { () => ({ /* compiler built-in */ }) }\n+\n+    /// A macro which stringifies its argument.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// stringification of all the tokens passed to the macro. No restrictions\n+    /// are placed on the syntax of the macro invocation itself.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let one_plus_one = stringify!(1 + 1);\n+    /// assert_eq!(one_plus_one, \"1 + 1\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a utf8-encoded file as a string.\n+    ///\n+    /// This macro will yield an expression of type `&'static str` which is the\n+    /// contents of the filename specified. The file is located relative to the\n+    /// current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_str!(\"secret-key.ascii\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Includes a file as a byte slice.\n+    ///\n+    /// This macro will yield an expression of type `&'static [u8]` which is\n+    /// the contents of the filename specified. The file is located relative to\n+    /// the current file (similarly to how modules are found),\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust,ignore\n+    /// let secret_key = include_bytes!(\"secret-key.bin\");\n+    /// ```\n+    #[macro_export]\n+    macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n+\n+    /// Deprecated alias for `include_bytes!()`.\n+    #[macro_export]\n+    macro_rules! include_bin { ($file:expr) => ({ /* compiler built-in */}) }\n+\n+    /// Expands to a string that represents the current module path.\n+    ///\n+    /// The current module path can be thought of as the hierarchy of modules\n+    /// leading back up to the crate root. The first component of the path\n+    /// returned is the name of the crate currently being compiled.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// mod test {\n+    ///     pub fn foo() {\n+    ///         assert!(module_path!().ends_with(\"test\"));\n+    ///     }\n+    /// }\n+    ///\n+    /// test::foo();\n+    /// ```\n+    #[macro_export]\n+    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n+\n+    /// Boolean evaluation of configuration flags.\n+    ///\n+    /// In addition to the `#[cfg]` attribute, this macro is provided to allow\n+    /// boolean expression evaluation of configuration flags. This frequently\n+    /// leads to less duplicated code.\n+    ///\n+    /// The syntax given to this macro is the same syntax as the `cfg`\n+    /// attribute.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let my_directory = if cfg!(windows) {\n+    ///     \"windows-specific-directory\"\n+    /// } else {\n+    ///     \"unix-directory\"\n+    /// };\n+    /// ```\n+    #[macro_export]\n+    macro_rules! cfg { ($cfg:tt) => ({ /* compiler built-in */ }) }\n+}"}, {"sha": "4c52f29b12d763a2433b29af0341b0c29ac1b656", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "ebcb20861879c87aebf86b92b17cc568e198ea92", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "08ea1b024c99360264b37d989ac2c099486e1014", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![experimental]\n-#![macro_escape]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "d9981ace0301ec52b40ae8453951b392fe99df2d", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -535,7 +535,7 @@ mod tests {\n         t!(b\"foo/\\xFFbar\", filename_display, \"\\u{FFFD}bar\");\n         t!(b\"/\", filename_display, \"\");\n \n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -550,7 +550,7 @@ mod tests {\n                     assert!(mo.as_slice() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"foo\", \"foo\");\n         t!(b\"foo\\x80\", \"foo\\u{FFFD}\");\n@@ -562,7 +562,7 @@ mod tests {\n \n     #[test]\n     fn test_display() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -572,7 +572,7 @@ mod tests {\n                     assert!(f == $expf);\n                 }\n             )\n-        );\n+        }\n \n         t!(b\"foo\", \"foo\", \"foo\");\n         t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n@@ -585,7 +585,7 @@ mod tests {\n \n     #[test]\n     fn test_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -606,7 +606,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n         t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n@@ -669,7 +669,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr) => (\n                 {\n                     let path = $path;\n@@ -680,7 +680,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"..\");\n         t!(s: \"/a/b/c\", \"d\");\n@@ -690,7 +690,7 @@ mod tests {\n \n     #[test]\n     fn test_push_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -699,7 +699,7 @@ mod tests {\n                     assert!(p.as_str() == Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -711,7 +711,7 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -726,7 +726,7 @@ mod tests {\n                     assert!(p.as_vec() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n@@ -739,7 +739,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -756,7 +756,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", b\"a/b\", true);\n         t!(b: b\"a\", b\".\", true);\n@@ -795,7 +795,7 @@ mod tests {\n \n     #[test]\n     fn test_join_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -804,7 +804,7 @@ mod tests {\n                     assert!(res.as_str() == Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"..\", \"a/b\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -816,7 +816,7 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -831,7 +831,7 @@ mod tests {\n                     assert!(res.as_vec() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n@@ -894,7 +894,7 @@ mod tests {\n \n     #[test]\n     fn test_setters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n@@ -915,7 +915,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n@@ -938,7 +938,7 @@ mod tests {\n \n     #[test]\n     fn test_getters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n@@ -969,7 +969,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n         t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n@@ -1008,15 +1008,15 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $abs:expr, $rel:expr) => (\n                 {\n                     let path = Path::new($path);\n                     assert_eq!(path.is_absolute(), $abs);\n                     assert_eq!(path.is_relative(), $rel);\n                 }\n             )\n-        );\n+        }\n         t!(s: \"a/b/c\", false, true);\n         t!(s: \"/a/b/c\", true, false);\n         t!(s: \"a\", false, true);\n@@ -1029,15 +1029,15 @@ mod tests {\n \n     #[test]\n     fn test_is_ancestor_of() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let dest = Path::new($dest);\n                     assert_eq!(path.is_ancestor_of(&dest), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"a/b/c/d\", true);\n         t!(s: \"a/b/c\", \"a/b/c\", true);\n@@ -1063,7 +1063,7 @@ mod tests {\n \n     #[test]\n     fn test_ends_with_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1078,7 +1078,7 @@ mod tests {\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"c\", true);\n         t!(s: \"a/b/c\", \"d\", false);\n@@ -1102,7 +1102,7 @@ mod tests {\n \n     #[test]\n     fn test_path_relative_from() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1111,7 +1111,7 @@ mod tests {\n                     assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n         t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n@@ -1147,7 +1147,7 @@ mod tests {\n \n     #[test]\n     fn test_components_iter() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1173,7 +1173,7 @@ mod tests {\n                     assert_eq!(comps, exp)\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n@@ -1193,7 +1193,7 @@ mod tests {\n \n     #[test]\n     fn test_str_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (b: $arg:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($arg);\n@@ -1205,7 +1205,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n         t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);"}, {"sha": "4b5d793355b60137fabd2b321f25efb458076cb0", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -1127,7 +1127,7 @@ mod tests {\n \n     #[test]\n     fn test_parse_prefix() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = $path;\n@@ -1137,7 +1137,7 @@ mod tests {\n                             \"parse_prefix(\\\"{}\\\"): expected {}, found {}\", path, exp, res);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"\\\\\\\\SERVER\\\\share\\\\foo\", Some(UNCPrefix(6,5)));\n         t!(\"\\\\\\\\\", None);\n@@ -1326,7 +1326,7 @@ mod tests {\n \n     #[test]\n     fn test_display() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr, $expf:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1336,7 +1336,7 @@ mod tests {\n                     assert_eq!(f, $expf);\n                 }\n             )\n-        );\n+        }\n \n         t!(\"foo\", \"foo\", \"foo\");\n         t!(\"foo\\\\bar\", \"foo\\\\bar\", \"bar\");\n@@ -1345,7 +1345,7 @@ mod tests {\n \n     #[test]\n     fn test_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $exp:expr) => (\n                 {\n                     let path = $path;\n@@ -1368,7 +1368,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n@@ -1468,7 +1468,7 @@ mod tests {\n \n     #[test]\n     fn test_push() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr) => (\n                 {\n                     let path = $path;\n@@ -1479,7 +1479,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"..\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n@@ -1503,7 +1503,7 @@ mod tests {\n \n     #[test]\n     fn test_push_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -1512,7 +1512,7 @@ mod tests {\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1555,7 +1555,7 @@ mod tests {\n \n     #[test]\n     fn test_push_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $push:expr, $exp:expr) => (\n                 {\n                     let mut p = Path::new($path);\n@@ -1570,7 +1570,7 @@ mod tests {\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n@@ -1584,7 +1584,7 @@ mod tests {\n \n     #[test]\n     fn test_pop() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $left:expr, $right:expr) => (\n                 {\n                     let pstr = $path;\n@@ -1605,7 +1605,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", true);\n         t!(s: \"a\", \".\", true);\n@@ -1673,7 +1673,7 @@ mod tests {\n \n     #[test]\n     fn test_join_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1682,7 +1682,7 @@ mod tests {\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"..\", \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1696,7 +1696,7 @@ mod tests {\n \n     #[test]\n     fn test_join_many() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $join:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1711,7 +1711,7 @@ mod tests {\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n@@ -1724,7 +1724,7 @@ mod tests {\n \n     #[test]\n     fn test_with_helpers() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $op:ident, $arg:expr, $res:expr) => (\n                 {\n                     let pstr = $path;\n@@ -1737,7 +1737,7 @@ mod tests {\n                             pstr, stringify!($op), arg, exp, res.as_str().unwrap());\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n         t!(s: \".\", with_filename, \"foo\", \"foo\");\n@@ -1809,7 +1809,7 @@ mod tests {\n \n     #[test]\n     fn test_setters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n                 {\n                     let path = $path;\n@@ -1830,7 +1830,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        );\n+        }\n \n         t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n@@ -1854,7 +1854,7 @@ mod tests {\n \n     #[test]\n     fn test_getters() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n                 {\n                     let path = $path;\n@@ -1885,7 +1885,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        );\n+        }\n \n         t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n@@ -1920,7 +1920,7 @@ mod tests {\n \n     #[test]\n     fn test_is_absolute() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $abs:expr, $vol:expr, $cwd:expr, $rel:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1939,7 +1939,7 @@ mod tests {\n                             path.as_str().unwrap(), rel, b);\n                 }\n             )\n-        );\n+        }\n         t!(\"a\\\\b\\\\c\", false, false, false, true);\n         t!(\"\\\\a\\\\b\\\\c\", false, true, false, false);\n         t!(\"a\", false, false, false, true);\n@@ -1960,7 +1960,7 @@ mod tests {\n \n     #[test]\n     fn test_is_ancestor_of() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $dest:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -1972,7 +1972,7 @@ mod tests {\n                             path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", true);\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n@@ -2063,15 +2063,15 @@ mod tests {\n \n     #[test]\n     fn test_ends_with_path() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $child:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     let child = Path::new($child);\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"c\", true);\n         t!(s: \"a\\\\b\\\\c\", \"d\", false);\n@@ -2095,7 +2095,7 @@ mod tests {\n \n     #[test]\n     fn test_path_relative_from() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $other:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2108,7 +2108,7 @@ mod tests {\n                             res.as_ref().and_then(|x| x.as_str()));\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", Some(\"..\\\\c\"));\n@@ -2229,7 +2229,7 @@ mod tests {\n \n     #[test]\n     fn test_str_components() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2243,7 +2243,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             );\n-        );\n+        }\n \n         t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n@@ -2287,7 +2287,7 @@ mod tests {\n \n     #[test]\n     fn test_components_iter() {\n-        macro_rules! t(\n+        macro_rules! t {\n             (s: $path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2299,7 +2299,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(s: \".\", [b\".\"]);\n@@ -2308,7 +2308,7 @@ mod tests {\n \n     #[test]\n     fn test_make_non_verbatim() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n@@ -2317,7 +2317,7 @@ mod tests {\n                     assert!(make_non_verbatim(&path) == exp);\n                 }\n             )\n-        );\n+        }\n \n         t!(r\"\\a\\b\\c\", Some(r\"\\a\\b\\c\"));\n         t!(r\"a\\b\\c\", Some(r\"a\\b\\c\"));"}, {"sha": "a79a6e35ebcfd377ff74265cba1a9ec9d842d149", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -23,11 +23,14 @@ mod imp {\n     use path::Path;\n     use rand::Rng;\n     use rand::reader::ReaderRng;\n-    use result::Result::{Ok, Err};\n+    use result::Result::Ok;\n     use slice::SliceExt;\n     use mem;\n     use os::errno;\n \n+    // NOTE: for old macros; remove after the next snapshot\n+    #[cfg(stage0)] use result::Result::Err;\n+\n     #[cfg(all(target_os = \"linux\",\n               any(target_arch = \"x86_64\",\n                   target_arch = \"x86\","}, {"sha": "bbc96d0b19f125fa91ee2297e062e905ed937c76", "filename": "src/libstd/rt/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Frt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Frt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! These macros call functions which are only accessible in the `rt` module, so\n //! they aren't defined anywhere outside of the `rt` module.\n \n-#![macro_escape]\n-\n macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         ::rt::util::dumb_print(format_args!(concat!($fmt, \"\\n\") $($arg)*))"}, {"sha": "e556888a470a288b100364bf8fd29aaae1ae94bf", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -39,6 +39,8 @@ pub use alloc::heap;\n pub mod backtrace;\n \n // Internals\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n mod macros;\n \n // These should be refactored/moved/made private over time"}, {"sha": "e0cbaa8ca50edbbb99c63a147445d1951f8551a7", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -34,13 +34,14 @@\n //! will want to make use of some form of **interior mutability** through the\n //! `Cell` or `RefCell` types.\n \n-#![macro_escape]\n #![stable]\n \n use prelude::v1::*;\n \n use cell::UnsafeCell;\n \n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod scoped;\n \n // Sure wish we had macro hygiene, no?"}, {"sha": "714b71d5dbd4e75364c4ee165a32dc8b8eafc10b", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -38,7 +38,6 @@\n //! });\n //! ```\n \n-#![macro_escape]\n #![unstable = \"scoped TLS has yet to have wide enough use to fully consider \\\n                stabilizing its interface\"]\n "}, {"sha": "ac1f0c5d803ac6a5b5b1e37a0a5fa7c51644c198", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -17,8 +17,10 @@ use ops::{Add, Sub, Mul, Div, Neg, FnOnce};\n use option::Option;\n use option::Option::{Some, None};\n use num::Int;\n-use result::Result;\n-use result::Result::{Ok, Err};\n+use result::Result::Ok;\n+\n+// NOTE: for old macros; remove after the next snapshot\n+#[cfg(stage0)] use result::Result::Err;\n \n /// The number of nanoseconds in a microsecond.\n const NANOS_PER_MICRO: i32 = 1000;"}, {"sha": "7aa7c4fcfb3019be51d900134fb6adab37a0c81a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -476,7 +476,7 @@ pub struct Crate {\n     pub attrs: Vec<Attribute>,\n     pub config: CrateConfig,\n     pub span: Span,\n-    pub exported_macros: Vec<P<Item>>\n+    pub exported_macros: Vec<MacroDef>,\n }\n \n pub type MetaItem = Spanned<MetaItem_>;\n@@ -884,6 +884,7 @@ impl TokenTree {\n         match *self {\n             TtToken(_, token::DocComment(_)) => 2,\n             TtToken(_, token::SubstNt(..)) => 2,\n+            TtToken(_, token::SpecialVarNt(..)) => 2,\n             TtToken(_, token::MatchNt(..)) => 3,\n             TtDelimited(_, ref delimed) => {\n                 delimed.tts.len() + 2\n@@ -925,6 +926,12 @@ impl TokenTree {\n                          TtToken(sp, token::Ident(name, name_st))];\n                 v[index]\n             }\n+            (&TtToken(sp, token::SpecialVarNt(var)), _) => {\n+                let v = [TtToken(sp, token::Dollar),\n+                         TtToken(sp, token::Ident(token::str_to_ident(var.as_str()),\n+                                                  token::Plain))];\n+                v[index]\n+            }\n             (&TtToken(sp, token::MatchNt(name, kind, name_st, kind_st)), _) => {\n                 let v = [TtToken(sp, token::SubstNt(name, name_st)),\n                          TtToken(sp, token::Colon),\n@@ -1689,6 +1696,21 @@ pub enum InlinedItem {\n     IIForeign(P<ForeignItem>),\n }\n \n+/// A macro definition, in this crate or imported from another.\n+///\n+/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n+pub struct MacroDef {\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub imported_from: Option<Ident>,\n+    pub export: bool,\n+    pub use_locally: bool,\n+    pub body: Vec<TokenTree>,\n+}\n+\n #[cfg(test)]\n mod test {\n     use serialize::json;"}, {"sha": "34a193dffd3db5d1d7079a2bf16fa08f3c7e1aff", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n #[macro_export]\n macro_rules! register_diagnostic {\n     ($code:tt, $description:tt) => (__register_diagnostic! { $code, $description });"}, {"sha": "91ae7396ea46920b4a97f1b188e30b9a714f2438", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -16,6 +16,7 @@ use codemap;\n use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n+use ext::tt::macro_rules;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -28,19 +29,6 @@ use fold::Folder;\n use std::collections::HashMap;\n use std::rc::Rc;\n \n-// new-style macro! tt code:\n-//\n-//    MacResult, NormalTT, IdentTT\n-//\n-// also note that ast::Mac used to have a bunch of extraneous cases and\n-// is now probably a redundant AST node, can be merged with\n-// ast::MacInvocTT.\n-\n-pub struct MacroDef {\n-    pub name: String,\n-    pub ext: SyntaxExtension\n-}\n-\n pub trait ItemDecorator {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n@@ -140,13 +128,6 @@ impl<F> IdentMacroExpander for F\n /// methods are spliced into the AST at the callsite of the macro (or\n /// just into the compiler's internal macro table, for `make_def`).\n pub trait MacResult {\n-    /// Attempt to define a new macro.\n-    // this should go away; the idea that a macro might expand into\n-    // either a macro definition or an expression, depending on what\n-    // the context wants, is kind of silly.\n-    fn make_def(&mut self) -> Option<MacroDef> {\n-        None\n-    }\n     /// Create an expression.\n     fn make_expr(self: Box<Self>) -> Option<P<ast::Expr>> {\n         None\n@@ -328,13 +309,8 @@ pub enum SyntaxExtension {\n     ///\n     IdentTT(Box<IdentMacroExpander + 'static>, Option<Span>),\n \n-    /// An ident macro that has two properties:\n-    /// - it adds a macro definition to the environment, and\n-    /// - the definition it adds doesn't introduce any new\n-    ///   identifiers.\n-    ///\n-    /// `macro_rules!` is a LetSyntaxTT\n-    LetSyntaxTT(Box<IdentMacroExpander + 'static>, Option<Span>),\n+    /// Represents `macro_rules!` itself.\n+    MacroRulesTT,\n }\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n@@ -364,8 +340,7 @@ fn initial_syntax_expander_table(ecfg: &expand::ExpansionConfig) -> SyntaxEnv {\n     }\n \n     let mut syntax_expanders = SyntaxEnv::new();\n-    syntax_expanders.insert(intern(\"macro_rules\"),\n-                            LetSyntaxTT(box ext::tt::macro_rules::add_new_extension, None));\n+    syntax_expanders.insert(intern(\"macro_rules\"), MacroRulesTT);\n     syntax_expanders.insert(intern(\"fmt\"),\n                             builtin_normal_expander(\n                                 ext::fmt::expand_syntax_ext));\n@@ -475,7 +450,7 @@ pub struct ExtCtxt<'a> {\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub trace_mac: bool,\n-    pub exported_macros: Vec<P<ast::Item>>,\n+    pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n     pub recursion_count: uint,\n@@ -594,6 +569,17 @@ impl<'a> ExtCtxt<'a> {\n             }\n         }\n     }\n+\n+    pub fn insert_macro(&mut self, def: ast::MacroDef) {\n+        if def.export {\n+            self.exported_macros.push(def.clone());\n+        }\n+        if def.use_locally {\n+            let ext = macro_rules::compile(self, &def);\n+            self.syntax_env.insert(def.ident.name, ext);\n+        }\n+    }\n+\n     /// Emit `msg` attached to `sp`, and stop compilation immediately.\n     ///\n     /// `span_err` should be strongly preferred where-ever possible:"}, {"sha": "7cb7ee3d35533e43fa9fa4c8231cd131a3a3f3b4", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -61,7 +61,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n             cx, span, substr)\n     }\n \n-    macro_rules! md (\n+    macro_rules! md {\n         ($name:expr, $f:ident) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n             let attrs = vec!(cx.attribute(span, inline));\n@@ -77,7 +77,7 @@ pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n                 })\n             }\n         } }\n-    );\n+    }\n \n     let trait_def = TraitDef {\n         span: span,"}, {"sha": "c126238be8293f8a4e0e4efecc5ff827d49bf23c", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                               push: F) where\n     F: FnOnce(P<Item>),\n {\n-    macro_rules! md (\n+    macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n             let attrs = vec!(cx.attribute(span, inline));\n@@ -43,7 +43,7 @@ pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n                 })\n             }\n         } }\n-    );\n+    }\n \n     let ordering_ty = Literal(Path::new(vec![\"std\", \"cmp\", \"Ordering\"]));\n     let ret_ty = Literal(Path::new_(vec![\"std\", \"option\", \"Option\"],"}, {"sha": "e72c83b67c89be435404aea043c5b9b6d0f54f62", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -71,9 +71,11 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                     MetaNameValue(ref tname, _) |\n                     MetaList(ref tname, _) |\n                     MetaWord(ref tname) => {\n-                        macro_rules! expand(($func:path) => ($func(cx, titem.span,\n-                                                                   &**titem, item,\n-                                                                   |i| push.call_mut((i,)))));\n+                        macro_rules! expand {\n+                            ($func:path) => ($func(cx, titem.span, &**titem, item,\n+                                                   |i| push.call_mut((i,))))\n+                        }\n+\n                         match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n "}, {"sha": "212ec3b0903252ccd9f7c418cb473c39f6bbe1bf", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 64, "deletions": 78, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -7,7 +7,6 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use self::Either::*;\n \n use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n use ast::{Local, Ident, MacInvocTT};\n@@ -33,11 +32,6 @@ use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n \n-enum Either<L,R> {\n-    Left(L),\n-    Right(R)\n-}\n-\n pub fn expand_type(t: P<ast::Ty>,\n                    fld: &mut MacroExpander,\n                    impl_ty: Option<P<ast::Ty>>)\n@@ -445,9 +439,9 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n             if valid_ident {\n                 fld.cx.mod_push(it.ident);\n             }\n-            let macro_escape = contains_macro_escape(new_attrs[]);\n+            let macro_use = contains_macro_use(fld, new_attrs[]);\n             let result = with_exts_frame!(fld.cx.syntax_env,\n-                                          macro_escape,\n+                                          macro_use,\n                                           noop_fold_item(it, fld));\n             if valid_ident {\n                 fld.cx.mod_pop();\n@@ -527,15 +521,34 @@ fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Ite\n     }\n }\n \n-// does this attribute list contain \"macro_escape\" ?\n-fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n-    attr::contains_name(attrs, \"macro_escape\")\n+// does this attribute list contain \"macro_use\" ?\n+fn contains_macro_use(fld: &mut MacroExpander, attrs: &[ast::Attribute]) -> bool {\n+    for attr in attrs.iter() {\n+        let mut is_use = attr.check_name(\"macro_use\");\n+        if attr.check_name(\"macro_escape\") {\n+            fld.cx.span_warn(attr.span, \"macro_escape is a deprecated synonym for macro_use\");\n+            is_use = true;\n+            if let ast::AttrInner = attr.node.style {\n+                fld.cx.span_help(attr.span, \"consider an outer attribute, \\\n+                                             #[macro_use] mod ...\");\n+            }\n+        };\n+\n+        if is_use {\n+            match attr.node.value.node {\n+                ast::MetaWord(..) => (),\n+                _ => fld.cx.span_err(attr.span, \"arguments to macro_use are not allowed here\"),\n+            }\n+            return true;\n+        }\n+    }\n+    false\n }\n \n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n-pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n-                       -> SmallVector<P<ast::Item>> {\n+pub fn expand_item_mac(it: P<ast::Item>,\n+                       fld: &mut MacroExpander) -> SmallVector<P<ast::Item>> {\n     let (extname, path_span, tts) = match it.node {\n         ItemMac(codemap::Spanned {\n             node: MacInvocTT(ref pth, ref tts, _),\n@@ -548,8 +561,8 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n \n     let extnamestr = token::get_ident(extname);\n     let fm = fresh_mark();\n-    let def_or_items = {\n-        let mut expanded = match fld.cx.syntax_env.find(&extname.name) {\n+    let items = {\n+        let expanded = match fld.cx.syntax_env.find(&extname.name) {\n             None => {\n                 fld.cx.span_err(path_span,\n                                 format!(\"macro undefined: '{}!'\",\n@@ -600,23 +613,37 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n                     let marked_tts = mark_tts(tts[], fm);\n                     expander.expand(fld.cx, it.span, it.ident, marked_tts)\n                 }\n-                LetSyntaxTT(ref expander, span) => {\n+                MacroRulesTT => {\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n-                                        format!(\"macro {}! expects an ident argument\",\n-                                                extnamestr.get())[]);\n+                                        format!(\"macro_rules! expects an ident argument\")[]);\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n                             name: extnamestr.get().to_string(),\n                             format: MacroBang,\n-                            span: span\n+                            span: None,\n                         }\n                     });\n-                    // DON'T mark before expansion:\n-                    expander.expand(fld.cx, it.span, it.ident, tts)\n+                    // DON'T mark before expansion.\n+\n+                    let def = ast::MacroDef {\n+                        ident: it.ident,\n+                        attrs: it.attrs.clone(),\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: it.span,\n+                        imported_from: None,\n+                        export: attr::contains_name(it.attrs.as_slice(), \"macro_export\"),\n+                        use_locally: true,\n+                        body: tts,\n+                    };\n+                    fld.cx.insert_macro(def);\n+\n+                    // macro_rules! has a side effect but expands to nothing.\n+                    fld.cx.bt_pop();\n+                    return SmallVector::zero();\n                 }\n                 _ => {\n                     fld.cx.span_err(it.span,\n@@ -627,31 +654,17 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n             }\n         };\n \n-        match expanded.make_def() {\n-            Some(def) => Left(def),\n-            None => Right(expanded.make_items())\n-        }\n+        expanded.make_items()\n     };\n \n-    let items = match def_or_items {\n-        Left(MacroDef { name, ext }) => {\n-            // hidden invariant: this should only be possible as the\n-            // result of expanding a LetSyntaxTT, and thus doesn't\n-            // need to be marked. Not that it could be marked anyway.\n-            // create issue to recommend refactoring here?\n-            fld.cx.syntax_env.insert(intern(name[]), ext);\n-            if attr::contains_name(it.attrs[], \"macro_export\") {\n-                fld.cx.exported_macros.push(it);\n-            }\n-            SmallVector::zero()\n-        }\n-        Right(Some(items)) => {\n+    let items = match items {\n+        Some(items) => {\n             items.into_iter()\n                 .map(|i| mark_item(i, fm))\n                 .flat_map(|i| fld.fold_item(i).into_iter())\n                 .collect()\n         }\n-        Right(None) => {\n+        None => {\n             fld.cx.span_err(path_span,\n                             format!(\"non-item macro in item position: {}\",\n                                     extnamestr.get())[]);\n@@ -664,9 +677,6 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n }\n \n /// Expand a stmt\n-//\n-// I don't understand why this returns a vector... it looks like we're\n-// half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let (mac, style) = match s.node {\n         StmtMac(mac, style) => (mac, style),\n@@ -976,8 +986,8 @@ impl<'a> Folder for IdentRenamer<'a> {\n             ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n-    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(macro, self)\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n \n@@ -1013,8 +1023,8 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n             _ => unreachable!()\n         })\n     }\n-    fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n-        fold::noop_fold_mac(macro, self)\n+    fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+        fold::noop_fold_mac(mac, self)\n     }\n }\n \n@@ -1175,31 +1185,17 @@ impl ExpansionConfig {\n     }\n }\n \n-pub struct ExportedMacros {\n-    pub crate_name: Ident,\n-    pub macros: Vec<String>,\n-}\n-\n pub fn expand_crate(parse_sess: &parse::ParseSess,\n                     cfg: ExpansionConfig,\n                     // these are the macros being imported to this crate:\n-                    imported_macros: Vec<ExportedMacros>,\n+                    imported_macros: Vec<ast::MacroDef>,\n                     user_exts: Vec<NamedSyntaxExtension>,\n                     c: Crate) -> Crate {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg);\n     let mut expander = MacroExpander::new(&mut cx);\n \n-    for ExportedMacros { crate_name, macros } in imported_macros.into_iter() {\n-        let name = format!(\"<{} macros>\", token::get_ident(crate_name));\n-\n-        for source in macros.into_iter() {\n-            let item = parse::parse_item_from_source_str(name.clone(),\n-                                                         source,\n-                                                         expander.cx.cfg(),\n-                                                         expander.cx.parse_sess())\n-                    .expect(\"expected a serialized item\");\n-            expand_item_mac(item, &mut expander);\n-        }\n+    for def in imported_macros.into_iter() {\n+        expander.cx.insert_macro(def);\n     }\n \n     for (name, extension) in user_exts.into_iter() {\n@@ -1288,8 +1284,8 @@ struct MacroExterminator<'a>{\n }\n \n impl<'a, 'v> Visitor<'v> for MacroExterminator<'a> {\n-    fn visit_mac(&mut self, macro: &ast::Mac) {\n-        self.sess.span_diagnostic.span_bug(macro.span,\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        self.sess.span_diagnostic.span_bug(mac.span,\n                                            \"macro exterminator: expected AST \\\n                                            with no macro invocations\");\n     }\n@@ -1298,7 +1294,7 @@ impl<'a, 'v> Visitor<'v> for MacroExterminator<'a> {\n \n #[cfg(test)]\n mod test {\n-    use super::{pattern_bindings, expand_crate, contains_macro_escape};\n+    use super::{pattern_bindings, expand_crate, contains_macro_use};\n     use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer, ExpansionConfig};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord, Name};\n@@ -1395,9 +1391,9 @@ mod test {\n         expand_crate(&sess,test_ecfg(),vec!(),vec!(),crate_ast);\n     }\n \n-    // macro_escape modules should allow macros to escape\n+    // macro_use modules should allow macros to escape\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4));}\\\n+        let src = \"#[macro_use] mod foo {macro_rules! z (() => (3+4));}\\\n                    fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n@@ -1407,16 +1403,6 @@ mod test {\n         expand_crate(&sess, test_ecfg(), vec!(), vec!(), crate_ast);\n     }\n \n-    #[test] fn test_contains_flatten (){\n-        let attr1 = make_dummy_attr (\"foo\");\n-        let attr2 = make_dummy_attr (\"bar\");\n-        let escape_attr = make_dummy_attr (\"macro_escape\");\n-        let attrs1 = vec!(attr1.clone(), escape_attr, attr2.clone());\n-        assert_eq!(contains_macro_escape(attrs1[]),true);\n-        let attrs2 = vec!(attr1,attr2);\n-        assert_eq!(contains_macro_escape(attrs2[]),false);\n-    }\n-\n     // make a MetaWord outer attribute with the given name\n     fn make_dummy_attr(s: &str) -> ast::Attribute {\n         Spanned {"}, {"sha": "9837c8088fa4507a38f6ec9a523384009787d53c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,7 +11,7 @@\n use ast::{Ident, TtDelimited, TtSequence, TtToken};\n use ast;\n use codemap::{Span, DUMMY_SP};\n-use ext::base::{ExtCtxt, MacResult, MacroDef};\n+use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n use ext::tt::macro_parser::{Success, Error, Failure};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n@@ -38,8 +38,8 @@ impl<'a> ParserAnyMacro<'a> {\n     /// Make sure we don't have any tokens left to parse, so we don't\n     /// silently drop anything. `allow_semi` is so that \"optional\"\n     /// semicolons at the end of normal expressions aren't complained\n-    /// about e.g. the semicolon in `macro_rules! kapow( () => {\n-    /// panic!(); } )` doesn't get picked up by .parse_expr(), but it's\n+    /// about e.g. the semicolon in `macro_rules! kapow { () => {\n+    /// panic!(); } }` doesn't get picked up by .parse_expr(), but it's\n     /// allowed to be there.\n     fn ensure_complete_parse(&self, allow_semi: bool) {\n         let mut parser = self.parser.borrow_mut();\n@@ -110,6 +110,7 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n \n struct MacroRulesMacroExpander {\n     name: Ident,\n+    imported_from: Option<Ident>,\n     lhses: Vec<Rc<NamedMatch>>,\n     rhses: Vec<Rc<NamedMatch>>,\n }\n@@ -123,25 +124,18 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n         generic_extension(cx,\n                           sp,\n                           self.name,\n+                          self.imported_from,\n                           arg,\n                           self.lhses[],\n                           self.rhses[])\n     }\n }\n \n-struct MacroRulesDefiner {\n-    def: Option<MacroDef>\n-}\n-impl MacResult for MacroRulesDefiner {\n-    fn make_def(&mut self) -> Option<MacroDef> {\n-        Some(self.def.take().expect(\"empty MacroRulesDefiner\"))\n-    }\n-}\n-\n /// Given `lhses` and `rhses`, this is the new macro we create\n fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                           sp: Span,\n                           name: Ident,\n+                          imported_from: Option<Ident>,\n                           arg: &[ast::TokenTree],\n                           lhses: &[Rc<NamedMatch>],\n                           rhses: &[Rc<NamedMatch>])\n@@ -165,6 +159,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n             };\n             // `None` is because we're not interpolating\n             let mut arg_rdr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n+                                            None,\n                                             None,\n                                             arg.iter()\n                                                .map(|x| (*x).clone())\n@@ -186,6 +181,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // rhs has holes ( `$id` and `$(...)` that need filled)\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                            Some(named_matches),\n+                                           imported_from,\n                                            rhs);\n                 let p = Parser::new(cx.parse_sess(), cx.cfg(), box trncbr);\n                 // Let the context choose how to interpret the result.\n@@ -212,14 +208,9 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n //\n // Holy self-referential!\n \n-/// This procedure performs the expansion of the\n-/// macro_rules! macro. It parses the RHS and adds\n-/// an extension to the current context.\n-pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n-                              sp: Span,\n-                              name: Ident,\n-                              arg: Vec<ast::TokenTree> )\n-                              -> Box<MacResult+'cx> {\n+/// Converts a `macro_rules!` invocation into a syntax extension.\n+pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n+                    def: &ast::MacroDef) -> SyntaxExtension {\n \n     let lhs_nm =  gensym_ident(\"lhs\");\n     let rhs_nm =  gensym_ident(\"rhs\");\n@@ -256,7 +247,8 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                    None,\n-                                   arg.clone());\n+                                   None,\n+                                   def.body.clone());\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader,\n@@ -265,24 +257,20 @@ pub fn add_new_extension<'cx>(cx: &'cx mut ExtCtxt,\n     // Extract the arguments:\n     let lhses = match *argument_map[lhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n-        _ => cx.span_bug(sp, \"wrong-structured lhs\")\n+        _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map[rhs_nm] {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n-        _ => cx.span_bug(sp, \"wrong-structured rhs\")\n+        _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };\n \n     let exp = box MacroRulesMacroExpander {\n-        name: name,\n+        name: def.ident,\n+        imported_from: def.imported_from,\n         lhses: lhses,\n         rhses: rhses,\n     };\n \n-    box MacroRulesDefiner {\n-        def: Some(MacroDef {\n-            name: token::get_ident(name).to_string(),\n-            ext: NormalTT(exp, Some(sp))\n-        })\n-    } as Box<MacResult+'cx>\n+    NormalTT(exp, Some(def.span))\n }"}, {"sha": "e4e6f5ac6b0f0f0c4953b6ab426eb8cb914d2e31", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -15,7 +15,7 @@ use codemap::{Span, DUMMY_SP};\n use diagnostic::SpanHandler;\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{Eof, DocComment, Interpolated, MatchNt, SubstNt};\n-use parse::token::{Token, NtIdent};\n+use parse::token::{Token, NtIdent, SpecialMacroVar};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n \n@@ -39,6 +39,10 @@ pub struct TtReader<'a> {\n     stack: Vec<TtFrame>,\n     /* for MBE-style macro transcription */\n     interpolations: HashMap<Ident, Rc<NamedMatch>>,\n+    imported_from: Option<Ident>,\n+\n+    // Some => return imported_from as the next token\n+    crate_name_next: Option<Span>,\n     repeat_idx: Vec<uint>,\n     repeat_len: Vec<uint>,\n     /* cached: */\n@@ -53,6 +57,7 @@ pub struct TtReader<'a> {\n /// should) be none.\n pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n                          interp: Option<HashMap<Ident, Rc<NamedMatch>>>,\n+                         imported_from: Option<Ident>,\n                          src: Vec<ast::TokenTree> )\n                          -> TtReader<'a> {\n     let mut r = TtReader {\n@@ -71,6 +76,8 @@ pub fn new_tt_reader<'a>(sp_diag: &'a SpanHandler,\n             None => HashMap::new(),\n             Some(x) => x,\n         },\n+        imported_from: imported_from,\n+        crate_name_next: None,\n         repeat_idx: Vec::new(),\n         repeat_len: Vec::new(),\n         desugar_doc_comments: false,\n@@ -162,6 +169,14 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n         sp: r.cur_span.clone(),\n     };\n     loop {\n+        match r.crate_name_next.take() {\n+            None => (),\n+            Some(sp) => {\n+                r.cur_span = sp;\n+                r.cur_tok = token::Ident(r.imported_from.unwrap(), token::Plain);\n+                return ret_val;\n+            },\n+        }\n         let should_pop = match r.stack.last() {\n             None => {\n                 assert_eq!(ret_val.tok, token::Eof);\n@@ -307,6 +322,18 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                    sep: None\n                 });\n             }\n+            TtToken(sp, token::SpecialVarNt(SpecialMacroVar::CrateMacroVar)) => {\n+                r.stack.last_mut().unwrap().idx += 1;\n+\n+                if r.imported_from.is_some() {\n+                    r.cur_span = sp;\n+                    r.cur_tok = token::ModSep;\n+                    r.crate_name_next = Some(sp);\n+                    return ret_val;\n+                }\n+\n+                // otherwise emit nothing and proceed to the next token\n+            }\n             TtToken(sp, tok) => {\n                 r.cur_span = sp;\n                 r.cur_tok = tok;"}, {"sha": "43e4039330837c157408da3cb1e30f20d7f9af0a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -37,14 +37,14 @@ use std::ascii::AsciiExt;\n // if you change this list without updating src/doc/reference.md, @cmr will be sad\n static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"globs\", Accepted),\n-    (\"macro_rules\", Active),\n+    (\"macro_rules\", Accepted),\n     (\"struct_variant\", Accepted),\n     (\"asm\", Active),\n     (\"managed_boxes\", Removed),\n     (\"non_ascii_idents\", Active),\n     (\"thread_local\", Active),\n     (\"link_args\", Active),\n-    (\"phase\", Active),\n+    (\"phase\", Active),  // NOTE(stage0): switch to Removed after next snapshot\n     (\"plugin_registrar\", Active),\n     (\"log_syntax\", Active),\n     (\"trace_macros\", Active),\n@@ -74,6 +74,8 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"if_let\", Accepted),\n     (\"while_let\", Accepted),\n \n+    (\"plugin\", Active),\n+\n     // A temporary feature gate used to enable parser extensions needed\n     // to bootstrap fix for #5723.\n     (\"issue_5723_bootstrap\", Accepted),\n@@ -161,32 +163,11 @@ struct MacroVisitor<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for MacroVisitor<'a> {\n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.node {\n-            ast::ViewItemExternCrate(..) => {\n-                for attr in i.attrs.iter() {\n-                    if attr.name().get() == \"phase\"{\n-                        self.context.gate_feature(\"phase\", attr.span,\n-                                          \"compile time crate loading is \\\n-                                           experimental and possibly buggy\");\n-                    }\n-                }\n-            },\n-            _ => { }\n-        }\n-        visit::walk_view_item(self, i)\n-    }\n-\n-    fn visit_mac(&mut self, macro: &ast::Mac) {\n-        let ast::MacInvocTT(ref path, _, _) = macro.node;\n+    fn visit_mac(&mut self, mac: &ast::Mac) {\n+        let ast::MacInvocTT(ref path, _, _) = mac.node;\n         let id = path.segments.last().unwrap().identifier;\n \n-        if id == token::str_to_ident(\"macro_rules\") {\n-            self.context.gate_feature(\"macro_rules\", path.span, \"macro definitions are \\\n-                not stable enough for use and are subject to change\");\n-        }\n-\n-        else if id == token::str_to_ident(\"asm\") {\n+        if id == token::str_to_ident(\"asm\") {\n             self.context.gate_feature(\"asm\", path.span, \"inline assembly is not \\\n                 stable enough for use and is subject to change\");\n         }\n@@ -233,10 +214,10 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             ast::ViewItemUse(..) => {}\n             ast::ViewItemExternCrate(..) => {\n                 for attr in i.attrs.iter() {\n-                    if attr.name().get() == \"phase\"{\n-                        self.gate_feature(\"phase\", attr.span,\n-                                          \"compile time crate loading is \\\n-                                           experimental and possibly buggy\");\n+                    if attr.check_name(\"plugin\") {\n+                        self.gate_feature(\"plugin\", attr.span,\n+                                          \"compiler plugins are experimental \\\n+                                           and possibly buggy\");\n                     }\n                 }\n             }"}, {"sha": "c45a4005339baea337116a1494daf44e2da0d048", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -194,13 +194,13 @@ pub trait Folder : Sized {\n         noop_fold_local(l, self)\n     }\n \n-    fn fold_mac(&mut self, _macro: Mac) -> Mac {\n+    fn fold_mac(&mut self, _mac: Mac) -> Mac {\n         panic!(\"fold_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a folder that\n         // works on macros, use this\n         // definition in your trait impl:\n-        // fold::noop_fold_mac(_macro, self)\n+        // fold::noop_fold_mac(_mac, self)\n     }\n \n     fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n@@ -1104,7 +1104,7 @@ pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mu\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros, span}: Crate,\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_macros, span}: Crate,\n                                   folder: &mut T) -> Crate {\n     let config = folder.fold_meta_items(config);\n \n@@ -1135,6 +1135,10 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros,\n         }, Vec::new(), span)\n     };\n \n+    for def in exported_macros.iter_mut() {\n+        def.id = folder.new_id(def.id);\n+    }\n+\n     Crate {\n         module: module,\n         attrs: attrs,\n@@ -1472,8 +1476,8 @@ mod test {\n         fn fold_ident(&mut self, _: ast::Ident) -> ast::Ident {\n             token::str_to_ident(\"zz\")\n         }\n-        fn fold_mac(&mut self, macro: ast::Mac) -> ast::Mac {\n-            fold::noop_fold_mac(macro, self)\n+        fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+            fold::noop_fold_mac(mac, self)\n         }\n     }\n "}, {"sha": "b7bfd346d506b96fffdfbbb0e535d273a0969255", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -31,11 +31,18 @@\n \n extern crate arena;\n extern crate fmt_macros;\n-#[phase(plugin, link)] extern crate log;\n extern crate serialize;\n extern crate term;\n extern crate libc;\n \n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n+\n extern crate \"serialize\" as rustc_serialize; // used by deriving\n \n pub mod util {"}, {"sha": "b0969a573e66b3cf35e1cb5a0573c079e85228de", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -24,8 +24,11 @@ use std::num::Int;\n use std::str;\n use std::iter;\n \n-pub mod lexer;\n+#[cfg_attr(stage0, macro_escape)]\n+#[cfg_attr(not(stage0), macro_use)]\n pub mod parser;\n+\n+pub mod lexer;\n pub mod token;\n pub mod attr;\n \n@@ -166,6 +169,8 @@ pub fn parse_stmt_from_source_str(name: String,\n \n // Note: keep in sync with `with_hygiene::parse_tts_from_source_str`\n // until #16472 is resolved.\n+//\n+// Warning: This parses with quote_depth > 0, which is not the default.\n pub fn parse_tts_from_source_str(name: String,\n                                  source: String,\n                                  cfg: ast::CrateConfig,\n@@ -291,7 +296,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n-    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n+    let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, None, tts);\n     Parser::new(sess, cfg, box trdr)\n }\n \n@@ -307,6 +312,8 @@ pub mod with_hygiene {\n \n     // Note: keep this in sync with `super::parse_tts_from_source_str` until\n     // #16472 is resolved.\n+    //\n+    // Warning: This parses with quote_depth > 0, which is not the default.\n     pub fn parse_tts_from_source_str(name: String,\n                                      source: String,\n                                      cfg: ast::CrateConfig,"}, {"sha": "cdfbd2c74b6af296f4d0346c20df6ac5730fe649", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![macro_escape]\n-\n pub use self::PathParsingMode::*;\n use self::ItemOrViewItem::*;\n \n@@ -74,8 +72,8 @@ use parse::classify;\n use parse::common::{SeqSep, seq_sep_none, seq_sep_trailing_allowed};\n use parse::lexer::{Reader, TokenAndSpan};\n use parse::obsolete::*;\n-use parse::token::{self, MatchNt, SubstNt, InternedString};\n-use parse::token::{keywords, special_idents};\n+use parse::token::{self, MatchNt, SubstNt, SpecialVarNt, InternedString};\n+use parse::token::{keywords, special_idents, SpecialMacroVar};\n use parse::{new_sub_parser_from_file, ParseSess};\n use print::pprust;\n use ptr::P;\n@@ -2739,6 +2737,9 @@ impl<'a> Parser<'a> {\n                                    op: repeat,\n                                    num_captures: name_num\n                                }))\n+                } else if p.token.is_keyword_allow_following_colon(keywords::Crate) {\n+                    p.bump();\n+                    TtToken(sp, SpecialVarNt(SpecialMacroVar::CrateMacroVar))\n                 } else {\n                     // A nonterminal that matches or not\n                     let namep = match p.token { token::Ident(_, p) => p, _ => token::Plain };\n@@ -3881,13 +3882,13 @@ impl<'a> Parser<'a> {\n                                                                   &mut stmts,\n                                                                   &mut expr);\n                         }\n-                        StmtMac(macro, MacStmtWithoutBraces) => {\n+                        StmtMac(mac, MacStmtWithoutBraces) => {\n                             // statement macro without braces; might be an\n                             // expr depending on whether a semicolon follows\n                             match self.token {\n                                 token::Semi => {\n                                     stmts.push(P(Spanned {\n-                                        node: StmtMac(macro,\n+                                        node: StmtMac(mac,\n                                                       MacStmtWithSemicolon),\n                                         span: span,\n                                     }));\n@@ -3896,10 +3897,16 @@ impl<'a> Parser<'a> {\n                                 _ => {\n                                     let e = self.mk_mac_expr(span.lo,\n                                                              span.hi,\n+<<<<<<< HEAD\n                                                              macro.and_then(|m| m.node));\n                                     let e = self.parse_dot_or_call_expr_with(e);\n                                     let e = self.parse_more_binops(e, 0);\n                                     let e = self.parse_assign_expr_with(e);\n+=======\n+                                                             mac.and_then(|m| m.node));\n+                                    let e =\n+                                        self.parse_dot_or_call_expr_with(e);\n+>>>>>>> kmc/macro-reform\n                                     self.handle_expression_like_statement(\n                                         e,\n                                         ast::DUMMY_NODE_ID,\n@@ -6026,6 +6033,10 @@ impl<'a> Parser<'a> {\n     fn parse_view_path(&mut self) -> P<ViewPath> {\n         let lo = self.span.lo;\n \n+        // Allow a leading :: because the paths are absolute either way.\n+        // This occurs with \"use $crate::...\" in macros.\n+        self.eat(&token::ModSep);\n+\n         if self.check(&token::OpenDelim(token::Brace)) {\n             // use {foo,bar}\n             let idents = self.parse_unspanned_seq("}, {"sha": "094aacf3207fcb0a14be6207f51d79f21d623275", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -61,6 +61,21 @@ pub enum IdentStyle {\n     Plain,\n }\n \n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n+pub enum SpecialMacroVar {\n+    /// `$crate` will be filled in with the name of the crate a macro was\n+    /// imported from, if any.\n+    CrateMacroVar,\n+}\n+\n+impl SpecialMacroVar {\n+    pub fn as_str(self) -> &'static str {\n+        match self {\n+            SpecialMacroVar::CrateMacroVar => \"crate\",\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Show, Copy)]\n pub enum Lit {\n     Byte(ast::Name),\n@@ -143,6 +158,8 @@ pub enum Token {\n     // In right-hand-sides of MBE macros:\n     /// A syntactic variable that will be filled in by macro expansion.\n     SubstNt(ast::Ident, IdentStyle),\n+    /// A macro variable with special meaning.\n+    SpecialVarNt(SpecialMacroVar),\n \n     // Junk. These carry no data because we don't really care about the data\n     // they *would* carry, and don't really want to allocate a new ident for\n@@ -265,6 +282,13 @@ impl Token {\n         }\n     }\n \n+    pub fn is_keyword_allow_following_colon(&self, kw: keywords::Keyword) -> bool {\n+        match *self {\n+            Ident(sid, _) => { kw.to_name() == sid.name }\n+            _ => { false }\n+        }\n+    }\n+\n     /// Returns `true` if the token is either a special identifier, or a strict\n     /// or reserved keyword.\n     #[allow(non_upper_case_globals)]\n@@ -550,6 +574,7 @@ declare_special_idents_and_keywords! {\n         (56,                         Abstract,   \"abstract\");\n         (57,                         Final,      \"final\");\n         (58,                         Override,   \"override\");\n+        (59,                         Macro,      \"macro\");\n     }\n }\n "}, {"sha": "402583b60fae5387e6c89055f875408341539c5e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -272,6 +272,8 @@ pub fn token_to_string(tok: &Token) -> String {\n         token::Comment              => \"/* */\".to_string(),\n         token::Shebang(s)           => format!(\"/* shebang: {}*/\", s.as_str()),\n \n+        token::SpecialVarNt(var)    => format!(\"${}\", var.as_str()),\n+\n         token::Interpolated(ref nt) => match *nt {\n             token::NtExpr(ref e)  => expr_to_string(&**e),\n             token::NtMeta(ref e)  => meta_item_to_string(&**e),"}, {"sha": "4ef7eb97a218946e8c16b2b24d70c91d7617aff4", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -65,12 +65,8 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n                                            Some((actual_crate_name, ast::CookedStr)),\n                                            ast::DUMMY_NODE_ID),\n             attrs: vec!(\n-                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_list_item(\n-                        InternedString::new(\"phase\"),\n-                        vec!(\n-                            attr::mk_word_item(InternedString::new(\"plugin\")),\n-                            attr::mk_word_item(InternedString::new(\"link\")\n-                        ))))),\n+                attr::mk_attr_outer(attr::mk_attr_id(), attr::mk_word_item(\n+                        InternedString::new(\"macro_use\")))),\n             vis: ast::Inherited,\n             span: DUMMY_SP\n         });\n@@ -82,16 +78,6 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n         // don't add #![no_std] here, that will block the prelude injection later.\n         // Add it during the prelude injection instead.\n \n-        // Add #![feature(phase)] here, because we use #[phase] on extern crate std.\n-        let feat_phase_attr = attr::mk_attr_inner(attr::mk_attr_id(),\n-                                                  attr::mk_list_item(\n-                                  InternedString::new(\"feature\"),\n-                                  vec![attr::mk_word_item(InternedString::new(\"phase\"))],\n-                              ));\n-        // std_inject runs after feature checking so manually mark this attr\n-        attr::mark_used(&feat_phase_attr);\n-        krate.attrs.push(feat_phase_attr);\n-\n         krate\n     }\n }"}, {"sha": "3f91304dcc5f21c528b2cfcdcee0c570109f10de", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -115,13 +115,13 @@ pub trait Visitor<'v> : Sized {\n     fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n         walk_explicit_self(self, es)\n     }\n-    fn visit_mac(&mut self, _macro: &'v Mac) {\n+    fn visit_mac(&mut self, _mac: &'v Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a visitor that\n         // works on macros, use this\n         // definition in your trait impl:\n-        // visit::walk_mac(self, _macro)\n+        // visit::walk_mac(self, _mac)\n     }\n     fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n         walk_path(self, path)\n@@ -334,7 +334,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                 visitor.visit_trait_item(method)\n             }\n         }\n-        ItemMac(ref macro) => visitor.visit_mac(macro),\n+        ItemMac(ref mac) => visitor.visit_mac(mac),\n     }\n     for attr in item.attrs.iter() {\n         visitor.visit_attribute(attr);\n@@ -538,7 +538,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n                 visitor.visit_pat(&**postpattern)\n             }\n         }\n-        PatMac(ref macro) => visitor.visit_mac(macro),\n+        PatMac(ref mac) => visitor.visit_mac(mac),\n     }\n }\n \n@@ -738,7 +738,7 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n             visitor.visit_expr(&**expression)\n         }\n-        StmtMac(ref macro, _) => visitor.visit_mac(&**macro),\n+        StmtMac(ref mac, _) => visitor.visit_mac(&**mac),\n     }\n }\n \n@@ -885,7 +885,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n         ExprRet(ref optional_expression) => {\n             walk_expr_opt(visitor, optional_expression)\n         }\n-        ExprMac(ref macro) => visitor.visit_mac(macro),\n+        ExprMac(ref mac) => visitor.visit_mac(mac),\n         ExprParen(ref subexpression) => {\n             visitor.visit_expr(&**subexpression)\n         }"}, {"sha": "dd42bede13ac3e69d8f35850bad010214a9e9e24", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -52,7 +52,13 @@\n \n #![deny(missing_docs)]\n \n-#[phase(plugin, link)] extern crate log;\n+#[cfg(stage0)]\n+#[phase(plugin, link)]\n+extern crate log;\n+\n+#[cfg(not(stage0))]\n+#[macro_use]\n+extern crate log;\n \n pub use terminfo::TerminfoTerminal;\n #[cfg(windows)]"}, {"sha": "5f0111c7d7a84de51191dff892f86531c099cc44", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -160,12 +160,12 @@ pub static stringnames: &'static[&'static str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tb\n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n pub fn parse(file: &mut io::Reader, longnames: bool)\n              -> Result<Box<TermInfo>, String> {\n-    macro_rules! try( ($e:expr) => (\n+    macro_rules! try { ($e:expr) => (\n         match $e {\n             Ok(e) => e,\n             Err(e) => return Err(format!(\"{}\", e))\n         }\n-    ) );\n+    ) }\n \n     let bnames;\n     let snames;"}, {"sha": "0419d85d3914ec32bde0b610532ce62649a5bbcc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -32,7 +32,7 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![allow(unknown_features)]\n-#![feature(asm, macro_rules, phase, globs, slicing_syntax)]\n+#![feature(asm, globs, slicing_syntax)]\n #![feature(unboxed_closures, default_type_params)]\n #![feature(old_orphan_check)]\n "}, {"sha": "5510d3e2e0df18386d82ee8c10183186d608ea70", "filename": "src/test/auxiliary/issue-13560-3.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-13560-3.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,7 @@\n // no-prefer-dynamic\n \n #![crate_type = \"rlib\"]\n-#![feature(phase)]\n \n-#[phase(plugin)] extern crate \"issue-13560-1\" as t1;\n-#[phase(plugin, link)] extern crate \"issue-13560-2\" as t2;\n+#[macro_use] #[no_link] extern crate \"issue-13560-1\" as t1;\n+#[macro_use] extern crate \"issue-13560-2\" as t2;\n "}, {"sha": "097a5827fc4be1fe937301a2e97da7c71837a616", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,12 +10,12 @@\n \n // force-host\n \n-#![feature(phase, plugin_registrar)]\n+#![feature(plugin_registrar)]\n \n extern crate syntax;\n \n // Load rustc as a plugin to get macros\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate rustc;\n \n use syntax::ast;"}, {"sha": "01ef08c475234c3a402dd66648755eed2ce5c3ef", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,12 +10,12 @@\n \n // force-host\n \n-#![feature(phase, plugin_registrar)]\n+#![feature(plugin_registrar)]\n \n extern crate syntax;\n \n // Load rustc as a plugin to get macros\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate rustc;\n \n use syntax::ast;"}, {"sha": "708830d02598643bed2c33caa802baccd910b628", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,9 +10,6 @@\n #![crate_name=\"lint_stability\"]\n #![crate_type = \"lib\"]\n \n-#![feature(macro_rules)]\n-#![macro_escape]\n-\n #[deprecated]\n pub fn deprecated() {}\n #[deprecated=\"text\"]\n@@ -181,16 +178,16 @@ pub struct FrozenTupleStruct(pub int);\n pub struct LockedTupleStruct(pub int);\n \n #[macro_export]\n-macro_rules! macro_test(\n+macro_rules! macro_test {\n     () => (deprecated());\n-);\n+}\n \n #[macro_export]\n-macro_rules! macro_test_arg(\n+macro_rules! macro_test_arg {\n     ($func:expr) => ($func);\n-);\n+}\n \n #[macro_export]\n-macro_rules! macro_test_arg_nested(\n+macro_rules! macro_test_arg_nested {\n     ($func:ident) => (macro_test_arg!($func()));\n-);\n+}"}, {"sha": "67037a3ac9e08cde559758543ff5280e342b3849", "filename": "src/test/auxiliary/logging_right_crate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flogging_right_crate.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n+#[macro_use] extern crate log;\n \n pub fn foo<T>() {\n     fn death() -> int { panic!() }"}, {"sha": "d50c27a4e75bb0efae4bb6c6fbd2e98e03b8bbb3", "filename": "src/test/auxiliary/macro_crate_MacroRulesTT.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_MacroRulesTT.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use syntax::parse::token;\n+use syntax::ext::base::MacroRulesTT;\n+use rustc::plugin::Registry;\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_syntax_extension(token::intern(\"bogus\"), MacroRulesTT);\n+}"}, {"sha": "4f55ac4f65fd48ee9e56f8164fc8b73dcba93419", "filename": "src/test/auxiliary/macro_crate_def_only.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n #[macro_export]\n-macro_rules! make_a_5(\n+macro_rules! make_a_5 {\n     () => (5)\n-);\n+}"}, {"sha": "922efc1aec38fa99f2a1928155a0c85c28d3f78e", "filename": "src/test/auxiliary/macro_crate_nonterminal.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_nonterminal.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! increment {\n+    ($x:expr) => ($crate::increment($x))\n+}\n+\n+pub fn check_local() {\n+    assert_eq!(increment!(3), 4);\n+}"}, {"sha": "99f02cf2d58ba02ca15d5f74e348ea2d8a1fd51c", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,7 +10,7 @@\n \n // force-host\n \n-#![feature(plugin_registrar, macro_rules, quote)]\n+#![feature(plugin_registrar, quote)]\n \n extern crate syntax;\n extern crate rustc;\n@@ -24,9 +24,9 @@ use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n #[macro_export]\n-macro_rules! exported_macro (() => (2i));\n+macro_rules! exported_macro { () => (2i) }\n \n-macro_rules! unexported_macro (() => (3i));\n+macro_rules! unexported_macro { () => (3i) }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "84e944f69b98ee406dfec98baea4aaf10a1db92d", "filename": "src/test/auxiliary/macro_export_inner_module.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n pub mod inner {\n     #[macro_export]\n-    macro_rules! foo(\n+    macro_rules! foo {\n         () => (1)\n-    );\n+    }\n }"}, {"sha": "910fcd2e3671d55321f570f364cd4046bfc0e753", "filename": "src/test/auxiliary/macro_non_reexport_2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_non_reexport_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_non_reexport_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_non_reexport_2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+// Since we load a serialized macro with all its attributes, accidentally\n+// re-exporting a `#[macro_export] macro_rules!` is something of a concern!\n+//\n+// We avoid it at the moment only because of the order in which we do things.\n+\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_1;"}, {"sha": "a913749bc66a92397d8399a4fa85840499aaf64b", "filename": "src/test/auxiliary/macro_reexport_1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_reexport_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_reexport_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_1.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+#[macro_export]\n+macro_rules! reexported {\n+    () => ( 3u )\n+}"}, {"sha": "15d9f9cc9146d0a2c5e88fd1e2e762b1cc2b1fe1", "filename": "src/test/auxiliary/macro_reexport_2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+#[macro_reexport(reexported)]\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_1;"}, {"sha": "63142b0a69935bd63308ef2a8ff8321fece1c287", "filename": "src/test/auxiliary/macro_reexport_2_no_use.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_reexport_2_no_use.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"dylib\"]\n+\n+#[macro_reexport(reexported)]\n+#[no_link]\n+extern crate macro_reexport_1;"}, {"sha": "b90c3f1d727bf6190b37539a2fcff83b1ed80aa1", "filename": "src/test/auxiliary/plugin_args.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fplugin_args.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#![feature(plugin_registrar)]\n+\n+extern crate syntax;\n+extern crate rustc;\n+\n+use std::borrow::ToOwned;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacExpr, NormalTT};\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+use syntax::ptr::P;\n+use rustc::plugin::Registry;\n+\n+struct Expander {\n+    args: P<ast::MetaItem>,\n+}\n+\n+impl TTMacroExpander for Expander {\n+    fn expand<'cx>(&self,\n+                   ecx: &'cx mut ExtCtxt,\n+                   sp: Span,\n+                   _: &[ast::TokenTree]) -> Box<MacResult+'cx> {\n+\n+        let attr = ecx.attribute(sp, self.args.clone());\n+        let src = pprust::attribute_to_string(&attr);\n+        let interned = token::intern_and_get_ident(src.as_slice());\n+        MacExpr::new(ecx.expr_str(sp, interned))\n+    }\n+}\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    let args = reg.args().clone();\n+    reg.register_syntax_extension(token::intern(\"plugin_args\"),\n+        NormalTT(box Expander { args: args, }, None));\n+}"}, {"sha": "12833daf6045854990ba64e416c6670832e64876", "filename": "src/test/auxiliary/svh-a-base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-base.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "9e74bf281358faa1e582d81080183fb0fc38f392", "filename": "src/test/auxiliary/svh-a-change-lit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-lit.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "c900550041b5c82a58d243ce64e67c18a1cf72d4", "filename": "src/test/auxiliary/svh-a-change-significant-cfg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-significant-cfg.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "04f8eb3cf9bc0fd4121230931631fa66da136818", "filename": "src/test/auxiliary/svh-a-change-trait-bound.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-trait-bound.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "c7e0a18768a3d36ae7271d56bd00fd5bcd3ee9fb", "filename": "src/test/auxiliary/svh-a-change-type-arg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-arg.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "5100af323183b18726535987931245f269798ed0", "filename": "src/test/auxiliary/svh-a-change-type-ret.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-ret.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "077c33cb90d756f3555b64c1aa81c2b1f4a7b2a0", "filename": "src/test/auxiliary/svh-a-change-type-static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-change-type-static.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "d481fa5a1fa3b033d65967408d0f13e7209e53d2", "filename": "src/test/auxiliary/svh-a-comment.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-comment.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "9e99a355ac1ee2a17df3d10d77ed5bb798e93a6d", "filename": "src/test/auxiliary/svh-a-doc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-doc.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "b8dd497ac99c8e6fae182d27dd29d4a40d0491df", "filename": "src/test/auxiliary/svh-a-macro.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-macro.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "12833daf6045854990ba64e416c6670832e64876", "filename": "src/test/auxiliary/svh-a-no-change.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-no-change.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "690ddc670f5fa57bb919d670d9bf31c4b1d45a33", "filename": "src/test/auxiliary/svh-a-redundant-cfg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-redundant-cfg.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "216e8e997f22de643e86f712dd718888965dd7a1", "filename": "src/test/auxiliary/svh-a-whitespace.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fsvh-a-whitespace.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n //! should not affect the strict version hash (SVH) computation\n //! (#14132).\n \n-#![feature(macro_rules)]\n-\n #![crate_name = \"a\"]\n \n macro_rules! three {"}, {"sha": "11b6108b99ed91245f3dc35508662ce7aa7bd671", "filename": "src/test/auxiliary/two_macros.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Ftwo_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Ftwo_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftwo_macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+\n+#[macro_export]\n+macro_rules! macro_one { () => (\"one\") }\n+\n+#[macro_export]\n+macro_rules! macro_two { () => (\"two\") }"}, {"sha": "39462fdc1e528b8dfce72d33d0fd2d910a31caba", "filename": "src/test/auxiliary/weak-lang-items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fweak-lang-items.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -14,10 +14,9 @@\n // it hasn't been defined just yet. Make sure we don't explode.\n \n #![no_std]\n-#![feature(phase)]\n #![crate_type = \"rlib\"]\n \n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate core;\n \n struct A;"}, {"sha": "9007b4fd64c43c440985a8da75774168e1ff27a4", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,7 +11,6 @@\n // ignore-lexer-test FIXME #15679\n // Microbenchmarks for various functions in std and extra\n \n-#![feature(macro_rules)]\n #![feature(unboxed_closures)]\n \n use std::io::File;\n@@ -28,11 +27,12 @@ fn main() {\n     let argv = os::args();\n     let _tests = argv.slice(1, argv.len());\n \n-    macro_rules! bench (\n+    macro_rules! bench {\n         ($id:ident) =>\n             (maybe_run_test(argv.as_slice(),\n                             stringify!($id).to_string(),\n-                            $id)));\n+                            $id))\n+    }\n \n     bench!(shift_push);\n     bench!(read_line);"}, {"sha": "16d6036d4c40ff8eb9b6d228941e37b088a41815", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -38,7 +38,6 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-#![feature(macro_rules)]\n #![feature(simd)]\n #![allow(experimental)]\n "}, {"sha": "ef538eb699189e1d7cfd042ccc4fac62c625952d", "filename": "src/test/bench/shootout-regex-dna.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-regex-dna.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -41,7 +41,7 @@\n // ignore-stage1\n // ignore-cross-compile #12102\n \n-#![feature(macro_rules, phase, slicing_syntax)]\n+#![feature(plugin, slicing_syntax)]\n \n extern crate regex;\n "}, {"sha": "89090d5f38abec32d8f37c5c97a1d09402a86d0a", "filename": "src/test/compile-fail-fulldeps/gated-plugin.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,8 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#[phase(plugin)]\n-//~^ ERROR compile time crate loading is experimental and possibly buggy\n+#[plugin] #[no_link]\n+//~^ ERROR compiler plugins are experimental and possibly buggy\n extern crate macro_crate_test;\n \n fn main() {}", "previous_filename": "src/test/compile-fail-fulldeps/gated-phase.rs"}, {"sha": "11ae55639596201edee9e5ead41537e9dc11c74d", "filename": "src/test/compile-fail-fulldeps/lint-group-plugin-deny-cmdline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-group-plugin-deny-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-group-plugin-deny-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-group-plugin-deny-cmdline.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // ignore-stage1\n // compile-flags: -D lint-me\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_group_plugin_test;\n \n fn lintme() { } //~ ERROR item is named 'lintme'"}, {"sha": "62007d6575a8db289fb27f98bf68d0db83601146", "filename": "src/test/compile-fail-fulldeps/lint-plugin-deny-attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-attr.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,10 +11,10 @@\n // aux-build:lint_plugin_test.rs\n // ignore-stage1\n \n-#![feature(phase)]\n+#![feature(plugin)]\n #![deny(test_lint)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_plugin_test;\n \n fn lintme() { } //~ ERROR item is named 'lintme'"}, {"sha": "da51c047f57e1109cbb2f2d9c65f4a576fdcee8c", "filename": "src/test/compile-fail-fulldeps/lint-plugin-deny-cmdline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-deny-cmdline.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // ignore-stage1\n // compile-flags: -D test-lint\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_plugin_test;\n \n fn lintme() { } //~ ERROR item is named 'lintme'"}, {"sha": "cf51958b53d8bec9304640e2cf4fd589675d6a7d", "filename": "src/test/compile-fail-fulldeps/lint-plugin-forbid-attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-attrs.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,10 +11,10 @@\n // aux-build:lint_plugin_test.rs\n // ignore-stage1\n \n-#![feature(phase)]\n+#![feature(plugin)]\n #![forbid(test_lint)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_plugin_test;\n \n fn lintme() { } //~ ERROR item is named 'lintme'"}, {"sha": "9a36143f65c6ad33e6a183faf953d864317126e2", "filename": "src/test/compile-fail-fulldeps/lint-plugin-forbid-cmdline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Flint-plugin-forbid-cmdline.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // ignore-stage1\n // compile-flags: -F test-lint\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_plugin_test;\n \n fn lintme() { } //~ ERROR item is named 'lintme'"}, {"sha": "46eb4d4b2eff1d7e8d116f209845128ab0fb63a6", "filename": "src/test/compile-fail-fulldeps/macro-crate-cannot-read-embedded-ident.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-cannot-read-embedded-ident.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -20,9 +20,9 @@\n // editors, so instead he made a macro that expands into the embedded\n // ident form.\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate macro_crate_test;\n \n fn main() {"}, {"sha": "adcdba04cc7823dcb62068d6524d20852e91683f", "filename": "src/test/compile-fail-fulldeps/macro-crate-doesnt-resolve.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,7 @@\n // ignore-stage1\n // ignore-android\n \n-#![feature(phase)]\n-\n-#[phase(plugin)]\n+#[macro_use] #[no_link]\n extern crate macro_crate_test;\n \n fn main() {", "previous_filename": "src/test/compile-fail-fulldeps/phase-syntax-doesnt-resolve.rs"}, {"sha": "1f44ac7cf9cae0f7604b30e8743a3242a8c6fb33", "filename": "src/test/compile-fail-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -14,8 +14,8 @@\n // ignore-android\n // ignore-cross-compile gives a different error message\n \n-#![feature(phase)]\n-#[phase(plugin)] extern crate rlib_crate_test;\n+#![feature(plugin)]\n+#[plugin] #[no_link] extern crate rlib_crate_test;\n //~^ ERROR: plugin crate `rlib_crate_test` only found in rlib format, but must be available in dylib format\n \n fn main() {}"}, {"sha": "b5ff8b715563288616a5a0fc5637dd56e100cd13", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,7 @@\n // ignore-stage1\n // ignore-android\n \n-#![feature(phase)]\n-\n-#[phase(plugin)]\n+#[macro_use] #[no_link]\n extern crate macro_crate_test;\n \n fn main() {"}, {"sha": "65657eea1efb0e0b2871a80758bf80d21d0a9798", "filename": "src/test/compile-fail-fulldeps/macro-crate-unknown-crate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unknown-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unknown-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unknown-crate.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n-\n-#[phase(plugin)]\n+#[macro_use] #[no_link]\n extern crate doesnt_exist; //~ ERROR can't find crate\n \n fn main() {}"}, {"sha": "cff2e5eaf8786226904552cc21d2699d59383beb", "filename": "src/test/compile-fail-fulldeps/plugin-MacroRulesTT.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-MacroRulesTT.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-MacroRulesTT.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-MacroRulesTT.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_MacroRulesTT.rs\n+// ignore-stage1\n+// ignore-android\n+// error-pattern: plugin tried to register a new MacroRulesTT\n+\n+#![feature(plugin)]\n+\n+#[plugin] #[no_link]\n+extern crate macro_crate_MacroRulesTT;\n+\n+fn main() { }"}, {"sha": "5ebcdb20b19523d44c6ab7ae1638ec71cb0b8369", "filename": "src/test/compile-fail/asm-src-loc-codegen-units.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fasm-src-loc-codegen-units.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fasm-src-loc-codegen-units.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-src-loc-codegen-units.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n //\n+// ignore-stage1 (#20184)\n // compile-flags: -C codegen-units=2\n // error-pattern: build without -C codegen-units for more exact errors\n "}, {"sha": "dcbb25ba5a95f629e64253039afe0c62f1b18b73", "filename": "src/test/compile-fail/cleanup-rvalue-scopes-cf.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fcleanup-rvalue-scopes-cf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fcleanup-rvalue-scopes-cf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcleanup-rvalue-scopes-cf.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n // Test that the borrow checker prevents pointers to temporaries\n // with statement lifetimes from escaping.\n \n-#![feature(macro_rules)]\n-\n use std::ops::Drop;\n \n static mut FLAGS: u64 = 0;"}, {"sha": "1814b1cd544ef8ee02a725543b2cd2d4c41e667d", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n static A: uint = { 1u; 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions\n "}, {"sha": "1401494d987a28af300ad026f11f02a1c5b7afa8", "filename": "src/test/compile-fail/deprecated-phase.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fdeprecated-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fdeprecated-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-phase.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n-#![feature(phase)]\n-\n-#[phase(plugin)]\n-use std::mem;\n+#[phase(blah)]\n+//~^ ERROR #[phase] is deprecated\n+extern crate foo;\n \n fn main() {}\n-", "previous_filename": "src/test/run-pass/phase-use-ignored.rs"}, {"sha": "fbf6287db9444fcd18a9855b0e9e84ef01615586", "filename": "src/test/compile-fail/empty-macro-use.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use()]\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_two!();  //~ ERROR macro undefined\n+}"}, {"sha": "6f75181c31cbc4bc0712581f148200859f9a3465", "filename": "src/test/compile-fail/fail-no-dead-code-core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n #![deny(dead_code)]\n #![allow(unreachable_code)]\n \n-#[phase(link, plugin)] extern crate core;\n+#[macro_use] extern crate core;\n \n \n fn foo() { //~ ERROR function is never used"}, {"sha": "dd6682a6f4282c0cbddef859aba64e5f01b260f2", "filename": "src/test/compile-fail/hygienic-label-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-1.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! foo {\n     () => { break 'x; }\n }"}, {"sha": "24194d7bbe9702a6a86b64e41c19ded5b42f506f", "filename": "src/test/compile-fail/hygienic-label-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! foo {\n     ($e: expr) => { 'x: loop { $e } }\n }"}, {"sha": "4ff3bec3c64594eb49b8b4bf0aef9fe54e6f11ad", "filename": "src/test/compile-fail/hygienic-label-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-3.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! foo {\n     () => { break 'x; }\n }"}, {"sha": "174e8a2834f4ba9507f1865fb7183e7358992bd8", "filename": "src/test/compile-fail/hygienic-label-4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhygienic-label-4.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! foo {\n     ($e: expr) => { 'x: for _ in range(0,1) { $e } }\n }"}, {"sha": "971f643c0fe91c319c5ab276458078b663c5e2c5", "filename": "src/test/compile-fail/if-let.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fif-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fif-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-let.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n fn macros() {\n     macro_rules! foo{\n         ($p:pat, $e:expr, $b:block) => {{"}, {"sha": "74835f4bf22cafce53576e85bfb0c108da852fa9", "filename": "src/test/compile-fail/infinite-macro-expansion.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,13 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! recursive(\n-      () => (\n-                recursive!() //~ ERROR recursion limit reached while expanding the macro `recursive`\n-              )\n-      );\n+macro_rules! recursive {\n+    () => (recursive!()) //~ ERROR recursion limit reached while expanding the macro `recursive`\n+}\n \n fn main() {\n     recursive!()"}, {"sha": "370a6228db6ac733358a97e8ee5df73b3cde769d", "filename": "src/test/compile-fail/issue-10536.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10536.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n \n // error-pattern:\n \n-#![feature(macro_rules)]\n-\n macro_rules! foo{\n     () => {{\n         macro_rules! bar{() => (())}"}, {"sha": "d4de4e177f02684e19d87b14ce1a8faaf7def19b", "filename": "src/test/compile-fail/issue-15167.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15167.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -15,9 +15,7 @@\n \n // ignore-test\n \n-#![feature(macro_rules)]\n-\n-macro_rules! f(() => (n))\n+macro_rules! f { () => (n) }\n \n fn main() -> (){\n     for n in range(0i, 1) {"}, {"sha": "68ac19b383f5a06eeb6e09f5af834de762c5ff75", "filename": "src/test/compile-fail/issue-16098.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-16098.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-16098.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16098.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! prob1 {\n     (0) => {\n         0"}, {"sha": "c5be0da5f4b2a2b6d866d5931901281d008bcfda", "filename": "src/test/compile-fail/issue-6596.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n // error-pattern: unexpected token\n \n-macro_rules! e(\n+macro_rules! e {\n     ($inp:ident) => (\n         $nonexistent\n     );\n-);\n+}\n \n fn main() {\n     e!(foo);"}, {"sha": "0e24269ec444905b96e3e335efe2348b37822ce5", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,19 +13,19 @@\n // aux-build:stability_cfg1.rs\n // aux-build:stability_cfg2.rs\n \n-#![feature(phase)]\n #![deny(unstable)]\n #![deny(deprecated)]\n #![deny(experimental)]\n #![allow(dead_code)]\n \n+#[macro_use]\n+extern crate lint_stability; //~ ERROR: use of unmarked item\n+\n mod cross_crate {\n     extern crate stability_cfg1;\n     extern crate stability_cfg2; //~ ERROR: use of experimental item\n \n-    #[phase(plugin, link)]\n-    extern crate lint_stability; //~ ERROR: use of unmarked item\n-    use self::lint_stability::*;\n+    use lint_stability::*;\n \n     fn test() {\n         let foo = MethodTester;"}, {"sha": "56d2b2cd6c0845c8a2b4e1ca0df6e6e95ddb853f", "filename": "src/test/compile-fail/lint-unsafe-block.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-block.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n #![allow(unused_unsafe)]\n #![allow(dead_code)]\n #![deny(unsafe_blocks)]\n-#![feature(macro_rules)]\n-\n unsafe fn allowed() {}\n \n #[allow(unsafe_blocks)] fn also_allowed() { unsafe {} }"}, {"sha": "9cfffb5fa6b629941c6ba29045a2408825d2bfbb", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,9 +10,7 @@\n //\n // regression test for #8005\n \n-#![feature(macro_rules)]\n-\n-macro_rules! test ( () => { fn foo() -> int { 1i; } } );\n+macro_rules! test { () => { fn foo() -> int { 1i; } } }\n                                              //~^ ERROR not all control paths return a value\n                                              //~^^ HELP consider removing this semicolon\n "}, {"sha": "67aaf05c3101b7ddcd747d7aef962efa3f672034", "filename": "src/test/compile-fail/macro-crate-nonterminal-non-root.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-crate-nonterminal-non-root.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-crate-nonterminal-non-root.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-crate-nonterminal-non-root.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_nonterminal.rs\n+// ignore-stage1\n+\n+mod foo {\n+    #[macro_use]\n+    extern crate macro_crate_nonterminal;  //~ ERROR must be at the crate root\n+}\n+\n+fn main() {\n+}"}, {"sha": "53b29ccb0c0c7580b48be88f1ff096e0795fd921", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! ignored_item {\n     () => {\n         fn foo() {}"}, {"sha": "e4fc5bb462700d0d8409e534488bc6e139bd98ba", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! test ( ($nm:ident,\n+macro_rules! test { ($nm:ident,\n                      #[$a:meta],\n-                     $i:item) => (mod $nm { #![$a] $i }); );\n+                     $i:item) => (mod $nm { #![$a] $i }); }\n \n test!(a,\n       #[cfg(qux)],"}, {"sha": "9d4ec9c176ccef34c2c657d47bc31b9f46321d1a", "filename": "src/test/compile-fail/macro-keyword.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-keyword.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn macro() {  //~ ERROR `macro` is a reserved keyword\n+}\n+\n+pub fn main() {\n+}"}, {"sha": "a66b63870143614aa407a27ce56eaab6688d4fd2", "filename": "src/test/compile-fail/macro-match-nonterminal.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! test ( ($a, $b) => (()); ); //~ ERROR Cannot transcribe\n+macro_rules! test { ($a, $b) => (()); } //~ ERROR Cannot transcribe\n \n fn main() {\n     test!()"}, {"sha": "4a427f121fcab23cf6222fd6c309a0a9486780fc", "filename": "src/test/compile-fail/macro-no-implicit-reexport.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_reexport_1.rs\n+// aux-build:macro_non_reexport_2.rs\n+// ignore-stage1\n+\n+#[macro_use] #[no_link]\n+extern crate macro_non_reexport_2;\n+\n+fn main() {\n+    assert_eq!(reexported!(), 3u);  //~ ERROR macro undefined\n+}"}, {"sha": "a0f23c72bc41e0b590f03d55081fb4a3d5b6b27e", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! test ( ($nm:ident,\n+macro_rules! test { ($nm:ident,\n                      #[$a:meta],\n-                     $i:item) => (mod $nm { #[$a] $i }); );\n+                     $i:item) => (mod $nm { #[$a] $i }); }\n \n test!(a,\n       #[cfg(qux)],"}, {"sha": "b9f754b2778bc653e8c196ec620f5494cb0e5549", "filename": "src/test/compile-fail/macro-reexport-malformed-1.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-1.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_reexport]  //~ ERROR bad macro reexport\n+extern crate std;\n+\n+fn main() { }"}, {"sha": "9ced5be8479baf0c226d32169c30b11c05f1bd2e", "filename": "src/test/compile-fail/macro-reexport-malformed-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_reexport=\"foo\"]  //~ ERROR bad macro reexport\n+extern crate std;\n+\n+fn main() { }"}, {"sha": "c8bd0a0509cdcfa81e9ea375c96d407e66504160", "filename": "src/test/compile-fail/macro-reexport-malformed-3.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-malformed-3.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_reexport(foo=\"bar\")]  //~ ERROR bad macro reexport\n+extern crate std;\n+\n+fn main() { }"}, {"sha": "c8e59f98d3cea2ec9d51486f715911e02eca134c", "filename": "src/test/compile-fail/macro-reexport-not-locally-visible.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_reexport_1.rs\n+// ignore-stage1\n+\n+#[macro_reexport(reexported)]\n+#[no_link]\n+extern crate macro_reexport_1;\n+\n+fn main() {\n+    assert_eq!(reexported!(), 3u);  //~ ERROR macro undefined\n+}"}, {"sha": "a73c4adb71f9ff0e651b535de78e0b15d6aadc22", "filename": "src/test/compile-fail/macro-use-bad-args-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-use-bad-args-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-use-bad-args-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-bad-args-1.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use(foo(bar))]  //~ ERROR bad macro import\n+extern crate std;\n+\n+fn main() {\n+}"}, {"sha": "31efe857605b412730e4b943ab7f4e4ab2895d7e", "filename": "src/test/compile-fail/macro-use-bad-args-2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-use-bad-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-use-bad-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-bad-args-2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use(foo=\"bar\")]  //~ ERROR bad macro import\n+extern crate std;\n+\n+fn main() {\n+}"}, {"sha": "4e0486f0db7e9e649a2866dd40e45ea66395b37d", "filename": "src/test/compile-fail/macro-use-wrong-name.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use(macro_one)]\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_two!();  //~ ERROR macro undefined\n+}"}, {"sha": "314292085dfe61ab5ca34a90aeb5cb134ab28c56", "filename": "src/test/compile-fail/macros-no-semicolon-items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,4 +12,3 @@ macro_rules! foo()  //~ ERROR semicolon\n \n fn main() {\n }\n-"}, {"sha": "f4740492651ae03e4cd15a1412f8d8a8887bfccd", "filename": "src/test/compile-fail/method-macro-backtrace.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,11 +10,9 @@\n \n // forbid-output: in expansion of\n \n-#![feature(macro_rules)]\n-\n-macro_rules! make_method ( ($name:ident) => (\n-    fn $name(&self) { }\n-));\n+macro_rules! make_method {\n+    ($name:ident) => ( fn $name(&self) { } )\n+}\n \n struct S;\n "}, {"sha": "0153d71fb268fbbdbb93fe4c8c69034f10c788af", "filename": "src/test/compile-fail/missing-macro-use.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_two!();  //~ ERROR macro undefined\n+}"}, {"sha": "6d3038b4820d6a96a268d19fd6c6fa101fccb157", "filename": "src/test/compile-fail/module-macro_use-arguments.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmodule-macro_use-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmodule-macro_use-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmodule-macro_use-arguments.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[macro_use(foo, bar)] //~ ERROR arguments to macro_use are not allowed here\n+mod foo {\n+}\n+\n+fn main() {\n+}"}, {"sha": "1d98cd26a38f51c01824800e9a9df851335cff80", "filename": "src/test/compile-fail/multi-plugin-attr.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmulti-plugin-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fmulti-plugin-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmulti-plugin-attr.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! foo(() => ());\n-//~^ ERROR: macro definitions are not stable enough for use\n+#[plugin]\n+#[plugin]  //~ ERROR #[plugin] specified multiple times\n+extern crate std;\n \n fn main() {}", "previous_filename": "src/test/compile-fail/gated-macro-rules.rs"}, {"sha": "a9c2b6a942c658dab4e09a84e3752eba44cf51db", "filename": "src/test/compile-fail/no-link.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fno-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-link.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[no_link]\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        libc::abs(0);  //~ ERROR Use of undeclared type or module `libc`\n+                      //~^ ERROR unresolved name `libc::abs`\n+    }\n+}"}, {"sha": "1c79c9a2293a0f03bfbe9a63d151a265ab6bdb34", "filename": "src/test/compile-fail/pattern-macro-hygiene.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! foo ( () => ( x ) );\n+macro_rules! foo { () => ( x ) }\n \n fn main() {\n     let foo!() = 2;"}, {"sha": "6e1ecb10e3a2ad1c46af841761b029522fb7cb35", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,7 +12,6 @@\n // deeply nested types that will fail the `Send` check by overflow\n // when the recursion limit is set very low.\n \n-#![feature(macro_rules)]\n #![allow(dead_code)]\n #![recursion_limit=\"10\"]\n "}, {"sha": "c839ade75cf29875bc0b835b10477c0baeb22129", "filename": "src/test/compile-fail/svh-change-lit.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-lit.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n // aux-build:svh-b.rs\n // aux-build:svh-a-change-lit.rs\n \n-#![feature(macro_rules)]\n-\n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n //~^ NOTE: perhaps this crate needs to be recompiled"}, {"sha": "df0adf36ce2e6f4fb72fe61aee610ceac7c2a8e0", "filename": "src/test/compile-fail/svh-change-significant-cfg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-significant-cfg.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n // aux-build:svh-b.rs\n // aux-build:svh-a-change-significant-cfg.rs\n \n-#![feature(macro_rules)]\n-\n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n //~^ NOTE: perhaps this crate needs to be recompiled"}, {"sha": "4774384fecd496558f6b282dfb8c8c6715075317", "filename": "src/test/compile-fail/svh-change-trait-bound.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-trait-bound.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n // aux-build:svh-b.rs\n // aux-build:svh-a-change-trait-bound.rs\n \n-#![feature(macro_rules)]\n-\n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n //~^ NOTE: perhaps this crate needs to be recompiled"}, {"sha": "51d3fd0a73a129401789e3dafded5ebeaca7dd34", "filename": "src/test/compile-fail/svh-change-type-arg.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-arg.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n // aux-build:svh-b.rs\n // aux-build:svh-a-change-type-arg.rs\n \n-#![feature(macro_rules)]\n-\n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n //~^ NOTE: perhaps this crate needs to be recompiled"}, {"sha": "609e0f3689e5dfe6e2738771571b8241fd86149b", "filename": "src/test/compile-fail/svh-change-type-ret.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-ret.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n // aux-build:svh-b.rs\n // aux-build:svh-a-change-type-ret.rs\n \n-#![feature(macro_rules)]\n-\n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n //~^ NOTE: perhaps this crate needs to be recompiled"}, {"sha": "c42714609b6f8908f07d258d5e4b0b6b6e777805", "filename": "src/test/compile-fail/svh-change-type-static.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsvh-change-type-static.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,8 +13,6 @@\n // aux-build:svh-b.rs\n // aux-build:svh-a-change-type-static.rs\n \n-#![feature(macro_rules)]\n-\n extern crate a;\n extern crate b; //~ ERROR: found possibly newer version of crate `a` which `b` depends on\n //~^ NOTE: perhaps this crate needs to be recompiled"}, {"sha": "95cb17c215b7bbca96848e3f8e644a6f2fb2ad48", "filename": "src/test/compile-fail/trace_macros-format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Ftrace_macros-format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Ftrace_macros-format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrace_macros-format.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules, trace_macros)]\n+#![feature(trace_macros)]\n \n fn main() {\n     trace_macros!(); //~ ERROR trace_macros! accepts only `true` or `false`"}, {"sha": "adb8ee6940d3b22f94d32da70faa3f6e56307086", "filename": "src/test/compile-fail/while-let.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-let.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n fn macros() {\n     macro_rules! foo{\n         ($p:pat, $e:expr, $b:block) => {{"}, {"sha": "2aa31969a46ad30fba375b2b4f5a9e98f23c8f98", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -111,7 +111,6 @@\n // lldb-command:continue\n \n \n-#![feature(macro_rules)]\n #![omit_gdb_pretty_printer_section]\n \n macro_rules! trivial {"}, {"sha": "500305f597075a6048b1ebaaf9f70ef489fff19e", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -1,7 +1,6 @@\n-#![feature(phase)]\n #![no_std]\n #![feature(globs)]\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate \"std\" as std;\n #[prelude_import]\n use std::prelude::v1::*;"}, {"sha": "fd7c3f8cc0e4b346713e2854ff1d97d8ea09402d", "filename": "src/test/run-fail/rt-set-exit-status-panic.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,7 @@\n \n // error-pattern:whatever\n \n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n+#[macro_use] extern crate log;\n use std::os;\n \n fn main() {"}, {"sha": "446ef6f97e2972cb5e25156ad11fbc075d586148", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,7 @@\n \n // error-pattern:whatever\n \n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n+#[macro_use] extern crate log;\n use std::os;\n use std::thread::Thread;\n "}, {"sha": "39ece8a464a6fe8c77600ca6f9eacab0cb27196b", "filename": "src/test/run-fail/rt-set-exit-status.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,7 @@\n \n // error-pattern:whatever\n \n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n+#[macro_use] extern crate log;\n use std::os;\n \n fn main() {"}, {"sha": "11e042c8c4a067da2747cf79f23418486b78b420", "filename": "src/test/run-make/extern-diff-internal-name/test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Fextern-diff-internal-name%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Fextern-diff-internal-name%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fextern-diff-internal-name%2Ftest.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n-\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate foo;\n \n fn main() {"}, {"sha": "a38b2cfb9628772d560e5b4703d021578b196551", "filename": "src/test/run-make/lto-syntax-extension/main.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flto-syntax-extension%2Fmain.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n-\n extern crate lib;\n-#[phase(plugin, link)] extern crate log;\n+#[macro_use] extern crate log;\n \n fn main() {}"}, {"sha": "6febe2ff7c1d324c76239c574a68c0b4a3fdb46c", "filename": "src/test/run-make/pretty-expanded-hygiene/input.pp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.pp.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n // minimal junk\n #![no_std]\n "}, {"sha": "c31b67b8043ae400303e47c2a336e1db328231e5", "filename": "src/test/run-make/pretty-expanded-hygiene/input.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fpretty-expanded-hygiene%2Finput.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n // minimal junk\n #![no_std]\n "}, {"sha": "11e7da770291a309e45b0d675bc92a1e237a80a8", "filename": "src/test/run-pass-fulldeps/issue_16723_multiple_items_syntax_ext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,9 +11,9 @@\n // ignore-stage1\n // ignore-android\n // aux-build:issue_16723_multiple_items_syntax_ext.rs\n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)] extern crate issue_16723_multiple_items_syntax_ext;\n+#[plugin] #[no_link] extern crate issue_16723_multiple_items_syntax_ext;\n \n multiple_items!();\n "}, {"sha": "7615b25f9e40cacab27a0915db68c4ca523800ce", "filename": "src/test/run-pass-fulldeps/lint-group-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Flint-group-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Flint-group-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-group-plugin.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // ignore-stage1\n // ignore-pretty\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_group_plugin_test;\n \n fn lintme() { } //~ WARNING item is named 'lintme'"}, {"sha": "7144d2b0f1e7162ac22652f586b82f78ad6bcba0", "filename": "src/test/run-pass-fulldeps/lint-plugin-cmdline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin-cmdline.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // ignore-stage1\n // compile-flags: -A test-lint\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_plugin_test;\n \n fn lintme() { }"}, {"sha": "d11242f4fe643e92f07282bc0b898bf7a52b1c82", "filename": "src/test/run-pass-fulldeps/lint-plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flint-plugin.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // ignore-stage1\n // ignore-pretty\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate lint_plugin_test;\n \n fn lintme() { } //~ WARNING item is named 'lintme'"}, {"sha": "a8762234ad996db102285f217f5ec591b8c7f9b6", "filename": "src/test/run-pass-fulldeps/macro-crate-does-hygiene-work.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-does-hygiene-work.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-does-hygiene-work.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-does-hygiene-work.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -14,9 +14,9 @@\n // Issue #15750: a macro that internally parses its input and then\n // uses `quote_expr!` to rearrange it should be hygiene-preserving.\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate macro_crate_test;\n \n fn main() {"}, {"sha": "d943cf0457b4feace6006a53515159ba934fa64e", "filename": "src/test/run-pass-fulldeps/macro-crate-outlive-expansion-phase.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-outlive-expansion-phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-outlive-expansion-phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate-outlive-expansion-phase.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,9 +11,9 @@\n // aux-build:plugin_crate_outlive_expansion_phase.rs\n // ignore-stage1\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate plugin_crate_outlive_expansion_phase;\n \n pub fn main() {}"}, {"sha": "4ffb8a3f74d4f0769bd368dc443ab267d595fd9b", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,9 +11,9 @@\n // aux-build:macro_crate_test.rs\n // ignore-stage1\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[macro_use] #[plugin] #[no_link]\n extern crate macro_crate_test;\n \n #[into_foo]"}, {"sha": "518d02e3d75bbc6c12657d619211c607b7fe1da1", "filename": "src/test/run-pass-fulldeps/plugin-link-does-resolve.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-link-does-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-link-does-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fplugin-link-does-resolve.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -15,9 +15,9 @@\n // macro_crate_test will not compile on a cross-compiled target because\n // libsyntax is not compiled for it.\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin, link)]\n+#[plugin]\n extern crate macro_crate_test;\n \n fn main() {", "previous_filename": "src/test/run-pass-fulldeps/phase-syntax-link-does-resolve.rs"}, {"sha": "d76766094ed773d40974da44a142b0ff8b728116", "filename": "src/test/run-pass-fulldeps/roman-numerals-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Froman-numerals-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Froman-numerals-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Froman-numerals-macro.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,9 +11,9 @@\n // aux-build:roman_numerals.rs\n // ignore-stage1\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate roman_numerals;\n \n pub fn main() {"}, {"sha": "1c74c8ad08eec0bb64bfbbc338853b7f9bdb7d97", "filename": "src/test/run-pass-fulldeps/syntax-extension-with-dll-deps.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-with-dll-deps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-with-dll-deps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fsyntax-extension-with-dll-deps.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,9 @@\n // aux-build:syntax-extension-with-dll-deps-2.rs\n // ignore-stage1\n \n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n+#[plugin] #[no_link]\n extern crate \"syntax-extension-with-dll-deps-2\" as extension;\n \n fn main() {"}, {"sha": "28db3953a0021d2834c2c1efa3234f1120ea121c", "filename": "src/test/run-pass/borrowck-macro-interaction-issue-6304.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n // Check that we do not ICE when compiling this\n // macro, which reuses the expression `$id`\n \n-#![feature(macro_rules)]\n-\n \n struct Foo {\n   a: int\n@@ -24,12 +22,12 @@ pub enum Bar {\n \n impl Foo {\n   fn elaborate_stm(&mut self, s: Box<Bar>) -> Box<Bar> {\n-    macro_rules! declare(\n+    macro_rules! declare {\n       ($id:expr, $rest:expr) => ({\n         self.check_id($id);\n         box Bar::Bar2($id, $rest)\n       })\n-    );\n+    }\n     match s {\n       box Bar::Bar2(id, rest) => declare!(id, self.elaborate_stm(rest)),\n       _ => panic!()"}, {"sha": "e3e004105076244cb945a09ffdb4aa86a249212d", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,9 +11,7 @@\n // ignore-android (FIXME #11419)\n // exec-env:RUST_LOG=info\n \n-#![feature(phase)]\n-\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate log;\n \n use log::{set_logger, Logger, LogRecord};"}, {"sha": "aeb6fcbbc0f01fb63f9e28a03aa29606eec6b74f", "filename": "src/test/run-pass/cfg-macros-foo.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcfg-macros-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcfg-macros-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-macros-foo.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,18 +13,16 @@\n // check that cfg correctly chooses between the macro impls (see also\n // cfg-macros-notfoo.rs)\n \n-#![feature(macro_rules)]\n-\n #[cfg(foo)]\n-#[macro_escape]\n+#[macro_use]\n mod foo {\n     macro_rules! bar {\n         () => { true }\n     }\n }\n \n #[cfg(not(foo))]\n-#[macro_escape]\n+#[macro_use]\n mod foo {\n     macro_rules! bar {\n         () => { false }"}, {"sha": "adc27d556227e3fb22b3bf10e4c1216f53b50c72", "filename": "src/test/run-pass/cfg-macros-notfoo.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcfg-macros-notfoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcfg-macros-notfoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg-macros-notfoo.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -13,18 +13,16 @@\n // check that cfg correctly chooses between the macro impls (see also\n // cfg-macros-foo.rs)\n \n-#![feature(macro_rules)]\n-\n #[cfg(foo)]\n-#[macro_escape]\n+#[macro_use]\n mod foo {\n     macro_rules! bar {\n         () => { true }\n     }\n }\n \n #[cfg(not(foo))]\n-#[macro_escape]\n+#[macro_use]\n mod foo {\n     macro_rules! bar {\n         () => { false }"}, {"sha": "8969cca2610ea65f1461364b66ad6f593a7adcf0", "filename": "src/test/run-pass/cleanup-rvalue-for-scope.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-for-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-for-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-for-scope.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n // Test that the lifetime of rvalues in for loops is extended\n // to the for loop itself.\n \n-#![feature(macro_rules)]\n-\n use std::ops::Drop;\n \n static mut FLAGS: u64 = 0;"}, {"sha": "59763e417a2585233030bad588bddd738472c98b", "filename": "src/test/run-pass/cleanup-rvalue-scopes.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,8 +12,6 @@\n // statement or end of block, as appropriate given the temporary\n // lifetime rules.\n \n-#![feature(macro_rules)]\n-\n use std::ops::Drop;\n \n static mut FLAGS: u64 = 0;\n@@ -61,7 +59,7 @@ impl Drop for AddFlags {\n     }\n }\n \n-macro_rules! end_of_block(\n+macro_rules! end_of_block {\n     ($pat:pat, $expr:expr) => (\n         {\n             println!(\"end_of_block({})\", stringify!({let $pat = $expr;}));\n@@ -74,9 +72,9 @@ macro_rules! end_of_block(\n             check_flags(1);\n         }\n     )\n-);\n+}\n \n-macro_rules! end_of_stmt(\n+macro_rules! end_of_stmt {\n     ($pat:pat, $expr:expr) => (\n         {\n             println!(\"end_of_stmt({})\", stringify!($expr));\n@@ -91,7 +89,7 @@ macro_rules! end_of_stmt(\n             check_flags(0);\n         }\n     )\n-);\n+}\n \n pub fn main() {\n "}, {"sha": "ca7f761b80d3111ecf485d39c56a26675f75ecf4", "filename": "src/test/run-pass/colorful-write-macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcolorful-write-macros.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n // no-pretty-expanded\n \n #![allow(unused_must_use, dead_code, deprecated)]\n-#![feature(macro_rules)]\n-\n use std::io::MemWriter;\n use std::fmt;\n "}, {"sha": "e3bdbeb169295e7a8d9236af7726f6da72b95af1", "filename": "src/test/run-pass/conditional-debug-macro-off.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-debug-macro-off.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,7 @@\n // compile-flags: --cfg ndebug\n // exec-env:RUST_LOG=conditional-debug-macro-off=4\n \n-#![feature(phase)]\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate log;\n \n pub fn main() {"}, {"sha": "11590ceb19d4889960e84669a22b9a51608094fb", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! assert_approx_eq(\n+macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-);\n+}\n \n static A: int = -4 + 3;\n static A2: uint = 3 + 3;"}, {"sha": "03afe798954d514afe053882edf4b35b0028c0cb", "filename": "src/test/run-pass/const-block-item-macro-codegen.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconst-block-item-macro-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconst-block-item-macro-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block-item-macro-codegen.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n // General test that function items in static blocks\n // can be generated with a macro.\n \n-#![feature(macro_rules)]\n-\n struct MyType {\n     desc: &'static str,\n     data: uint,"}, {"sha": "d55b420db083e28f882e112cbb4d4643a3ef1092", "filename": "src/test/run-pass/const-block-item.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconst-block-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fconst-block-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-block-item.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n mod foo {\n     pub trait Value {\n         fn value(&self) -> uint;"}, {"sha": "3298976de6ce34d8bd6f13fe8af4d629b951f1fe", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -15,7 +15,6 @@\n // memory, which makes for some *confusing* logs. That's why these are here\n // instead of in std.\n \n-#![feature(macro_rules)]\n #![reexport_test_harness_main = \"test_main\"]\n \n extern crate libc;\n@@ -26,9 +25,9 @@ use std::str;\n use std::sync::mpsc::channel;\n use std::thread::Thread;\n \n-macro_rules! succeed( ($e:expr) => (\n+macro_rules! succeed { ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => panic!(\"panic: {}\", e) }\n-) );\n+) }\n \n fn test_destroy_once() {\n     let mut p = sleeper();"}, {"sha": "b2956f4e229b6b81d065c43266be0cc9d7482e5f", "filename": "src/test/run-pass/crate-leading-sep.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcrate-leading-sep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fcrate-leading-sep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrate-leading-sep.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    use ::std::mem;\n+    mem::drop(2u);\n+}"}, {"sha": "7960a91bdc4fc125499aa200718270a63a80e178", "filename": "src/test/run-pass/deprecated-macro_escape-inner.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape-inner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape-inner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape-inner.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty\n+\n+mod foo {\n+    #![macro_escape] //~ WARNING macro_escape is a deprecated synonym for macro_use\n+    //~^ HELP consider an outer attribute\n+}\n+\n+fn main() {\n+}"}, {"sha": "b03905e1a0d63f2a8696aadb9667c8194dcf3127", "filename": "src/test/run-pass/deprecated-macro_escape.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeprecated-macro_escape.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n+// ignore-pretty\n \n-//~ WARNING phase(syntax) is a deprecated synonym for phase(plugin)\n-#[phase(syntax, link)]\n-extern crate log;\n+#[macro_escape] //~ WARNING macro_escape is a deprecated synonym for macro_use\n+mod foo {\n+}\n \n fn main() {\n-    debug!(\"foo\");\n }", "previous_filename": "src/test/run-pass/deprecated-phase-syntax.rs"}, {"sha": "c9b60d22ecb7b9bd7a6e6a8cbd3172b198be353e", "filename": "src/test/run-pass/deriving-in-macro.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! define_vec (\n+macro_rules! define_vec {\n     () => (\n         mod foo {\n             #[derive(PartialEq)]\n             pub struct bar;\n         }\n     )\n-);\n+}\n \n define_vec!();\n "}, {"sha": "e8086b8b7c6b20c2a988de3cd5976fa32160c03c", "filename": "src/test/run-pass/deriving-show.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fderiving-show.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-show.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n #[derive(Show)]\n struct Unit;\n "}, {"sha": "07941eca2243ec4cb8107bdf177b8489c1c2fc5c", "filename": "src/test/run-pass/enum-discrim-width-stuff.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenum-discrim-width-stuff.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! check {\n     ($m:ident, $t:ty, $v:expr) => {{\n         mod $m {"}, {"sha": "1fb434f7d76192332c667e6747fa6c317e634563", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n use std::num::strconv::ExponentFormat::{ExpBin, ExpDec};\n use std::num::strconv::SignificantDigits::DigMax;\n use std::num::strconv::SignFormat::{SignAll, SignNeg};\n use std::num::strconv::float_to_str_common as to_string;\n \n-macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } });\n+macro_rules! t {\n+    ($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } }\n+}\n \n pub fn main() {\n     // Basic usage"}, {"sha": "fbaeb1753f41de6436f2c376b6b401c9672e38b0", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,6 @@\n \n // A test of the macro system. Can we do HTML literals?\n \n-#![feature(macro_rules)]\n-\n \n /*\n \n@@ -27,13 +25,13 @@ left.\n */\n use HTMLFragment::{tag, text};\n \n-macro_rules! html (\n+macro_rules! html {\n     ( $($body:tt)* ) => (\n         parse_node!( []; []; $($body)* )\n     )\n-);\n+}\n \n-macro_rules! parse_node (\n+macro_rules! parse_node {\n     (\n         [:$head:ident ($(:$head_nodes:expr),*)\n          $(:$tags:ident ($(:$tag_nodes:expr),*))*];\n@@ -85,7 +83,7 @@ macro_rules! parse_node (\n     );\n \n     ( []; [:$e:expr]; ) => ( $e );\n-);\n+}\n \n pub fn main() {\n     let _page = html! ("}, {"sha": "17c0299cf4dd7aaf8d6c73579a5b907891f789dd", "filename": "src/test/run-pass/hygienic-labels-in-let.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels-in-let.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,6 @@\n \n // ignore-pretty: pprust doesn't print hygiene output\n \n-#![feature(macro_rules)]\n-\n macro_rules! loop_x {\n     ($e: expr) => {\n         // $e shouldn't be able to interact with this 'x"}, {"sha": "e899a1adb794f1a5e72b4b543f451c3908b88819", "filename": "src/test/run-pass/hygienic-labels.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhygienic-labels.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! loop_x {\n     ($e: expr) => {\n         // $e shouldn't be able to interact with this 'x"}, {"sha": "d38b0ea27476569f1f8ac0df6e1cb7776c03e3cb", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,7 +11,6 @@\n // no-pretty-expanded unnecessary unsafe block generated\n // ignore-lexer-test FIXME #15679\n \n-#![feature(macro_rules)]\n #![deny(warnings)]\n #![allow(unused_must_use)]\n \n@@ -37,7 +36,9 @@ impl fmt::Show for C {\n     }\n }\n \n-macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) });\n+macro_rules! t {\n+    ($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) }\n+}\n \n pub fn main() {\n     // Various edge cases without formats"}, {"sha": "ed88b3c65e09c8f428c3740c77e693a0a9b82c2e", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -9,16 +9,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules, intrinsics)]\n+#![feature(intrinsics)]\n \n-macro_rules! assert_approx_eq(\n+macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         use std::num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-);\n+}\n \n mod rusti {\n     extern \"rust-intrinsic\" {"}, {"sha": "f983f233ee35680e8697439ab39d43e9fab1e40b", "filename": "src/test/run-pass/issue-14330.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-14330.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-14330.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14330.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(phase)]\n-\n-#[phase(plugin, link)] extern crate \"std\" as std2;\n+#[macro_use] extern crate \"std\" as std2;\n \n fn main() {}"}, {"sha": "a441729e2d0ba015287dad9217a5a823f59a9a4a", "filename": "src/test/run-pass/issue-14936.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-14936.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14936.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(asm, macro_rules)]\n+#![feature(asm)]\n \n type History = Vec<&'static str>;\n "}, {"sha": "6d1813f8aa437bb965aa254a31777c3467c64fc3", "filename": "src/test/run-pass/issue-15189.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15189.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,9 +10,9 @@\n \n // ignore-pretty\n \n-#![feature(macro_rules)]\n-\n-macro_rules! third(($e:expr)=>({let x = 2; $e[x]}));\n+macro_rules! third {\n+    ($e:expr) => ({let x = 2; $e[x]})\n+}\n \n fn main() {\n     let x = vec!(10u,11u,12u,13u);"}, {"sha": "e3c102e01ec5e0cb0a2a3289befde1848167a3f9", "filename": "src/test/run-pass/issue-15221.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15221.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! inner (\n-    ($e:pat ) => ($e));\n+macro_rules! inner {\n+    ($e:pat ) => ($e)\n+}\n \n-macro_rules! outer (\n-    ($e:pat ) => (inner!($e)));\n+macro_rules! outer {\n+    ($e:pat ) => (inner!($e))\n+}\n \n fn main() {\n     let outer!(g1) = 13i;"}, {"sha": "7c3b0a5f1f0146fbd413735612440b2c8056aa63", "filename": "src/test/run-pass/issue-5060.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5060.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! print_hd_tl (\n+macro_rules! print_hd_tl {\n     ($field_hd:ident, $($field_tl:ident),+) => ({\n         print!(\"{}\", stringify!($field_hd));\n         print!(\"::[\");\n@@ -21,7 +19,7 @@ macro_rules! print_hd_tl (\n         // FIXME: #9970\n         print!(\"{}\", \"]\\n\");\n     })\n-);\n+}\n \n pub fn main() {\n     print_hd_tl!(x, y, z, w)"}, {"sha": "32fca7a182c1b7c465dfc2f915fa11cbb8912bd5", "filename": "src/test/run-pass/issue-5554.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-5554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5554.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n use std::default::Default;\n \n pub struct X<T> {"}, {"sha": "589ccefd9ea2801a2b6e7e6d6fb2049129037733", "filename": "src/test/run-pass/issue-5718.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-5718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-5718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5718.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n struct Element;\n \n macro_rules! foo {"}, {"sha": "86948ebcb91e0e4dbf2de046876376d3508a3f41", "filename": "src/test/run-pass/issue-7911.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7911.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -14,8 +14,6 @@\n // with different mutability in macro in two methods\n \n #![allow(unused_variable)] // unused foobar_immut + foobar_mut\n-#![feature(macro_rules)]\n-\n trait FooBar {}\n struct Bar(i32);\n struct Foo { bar: Bar }\n@@ -27,7 +25,7 @@ trait Test {\n     fn get_mut(&mut self) -> &mut FooBar;\n }\n \n-macro_rules! generate_test(($type_:path, $slf:ident, $field:expr) => (\n+macro_rules! generate_test { ($type_:path, $slf:ident, $field:expr) => (\n     impl Test for $type_ {\n         fn get_immut(&$slf) -> &FooBar {\n             &$field as &FooBar\n@@ -37,7 +35,7 @@ macro_rules! generate_test(($type_:path, $slf:ident, $field:expr) => (\n             &mut $field as &mut FooBar\n         }\n     }\n-));\n+)}\n \n generate_test!(Foo, self, self.bar);\n "}, {"sha": "865905bf50441a9143b527b7af53924cf8f20573", "filename": "src/test/run-pass/issue-8709.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-8709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-8709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8709.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,15 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! sty(\n+macro_rules! sty {\n     ($t:ty) => (stringify!($t))\n-);\n+}\n \n-macro_rules! spath(\n+macro_rules! spath {\n     ($t:path) => (stringify!($t))\n-);\n+}\n \n fn main() {\n     assert_eq!(sty!(int), \"int\");"}, {"sha": "b70711f9f39e25a393a5fafc2e59b3726e5ff92e", "filename": "src/test/run-pass/issue-8851.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8851.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n // after fixing #9384 and implementing hygiene for match bindings,\n // this now fails because the insertion of the 'y' into the match\n // doesn't cause capture. Making this macro hygienic (as I've done)\n@@ -20,7 +18,7 @@ enum T {\n     B(uint)\n }\n \n-macro_rules! test(\n+macro_rules! test {\n     ($id:ident, $e:expr) => (\n         fn foo(t: T) -> int {\n             match t {\n@@ -29,7 +27,7 @@ macro_rules! test(\n             }\n         }\n     )\n-);\n+}\n \n test!(y, 10 + (y as int));\n "}, {"sha": "09d0f20c96d6c4d9eda35e3fdb22a6daf2780b4e", "filename": "src/test/run-pass/issue-9110.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-9110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-9110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9110.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,16 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! silly_macro(\n+macro_rules! silly_macro {\n     () => (\n         pub mod Qux {\n             pub struct Foo { x : u8 }\n             pub fn bar(_foo : Foo) {}\n         }\n     );\n-);\n+}\n \n silly_macro!();\n "}, {"sha": "5d5240272e542df6e08ada88770da3f653922ffd", "filename": "src/test/run-pass/issue-9129.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9129.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,17 +10,15 @@\n \n // ignore-pretty\n \n-#![feature(macro_rules)]\n-\n \n pub trait bomb { fn boom(&self, Ident); }\n pub struct S;\n impl bomb for S { fn boom(&self, _: Ident) { } }\n \n pub struct Ident { name: uint }\n \n-// macro_rules! int3( () => ( unsafe { asm!( \"int3\" ); } ) )\n-macro_rules! int3( () => ( { } ) );\n+// macro_rules! int3 { () => ( unsafe { asm!( \"int3\" ); } ) }\n+macro_rules! int3 { () => ( { } ) }\n \n fn Ident_new() -> Ident {\n     int3!();"}, {"sha": "e5a287d01491939f3818c3702b2d82632063c715", "filename": "src/test/run-pass/issue-9737.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-9737.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fissue-9737.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9737.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,9 +10,9 @@\n \n // ignore-test #9737\n \n-#![feature(macro_rules)]\n-\n-macro_rules! f((v: $x:expr) => ( println!(\"{}\", $x) ))\n+macro_rules! f {\n+    (v: $x:expr) => ( println!(\"{}\", $x) )\n+}\n \n fn main () {\n     let v = 5;"}, {"sha": "a6060bebbc5cde4ec793ec374d0e54d73469ada4", "filename": "src/test/run-pass/lambda-var-hygiene.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flambda-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flambda-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-var-hygiene.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,10 +10,10 @@\n \n // ignore-test #9383\n \n-#![feature(macro_rules)]\n-\n // shouldn't affect evaluation of $ex:\n-macro_rules! bad_macro (($ex:expr) => ({(|_x| { $ex }) (9) }))\n+macro_rules! bad_macro {\n+    ($ex:expr) => ({(|_x| { $ex }) (9) })\n+}\n \n fn takes_x(_x : int) {\n     assert_eq!(bad_macro!(_x),8);"}, {"sha": "2287cc48b66ce1e6504255e18347567c96fbc0f5", "filename": "src/test/run-pass/let-var-hygiene.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n // shouldn't affect evaluation of $ex:\n-macro_rules! bad_macro (($ex:expr) => ({let _x = 9i; $ex}));\n+macro_rules! bad_macro {\n+    ($ex:expr) => ({let _x = 9i; $ex})\n+}\n+\n pub fn main() {\n     let _x = 8i;\n     assert_eq!(bad_macro!(_x),8i)"}, {"sha": "262d9b21eb48bddd57815f6d246e26151037ef4a", "filename": "src/test/run-pass/logging-enabled-debug.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flogging-enabled-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flogging-enabled-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-enabled-debug.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,7 @@\n // compile-flags:--cfg ndebug\n // exec-env:RUST_LOG=logging-enabled-debug=debug\n \n-#![feature(phase)]\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate log;\n \n pub fn main() {"}, {"sha": "372cdc401b54929ee084e12cbf7bcb88a16caf89", "filename": "src/test/run-pass/logging-enabled.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flogging-enabled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flogging-enabled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-enabled.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,7 @@\n \n // exec-env:RUST_LOG=logging-enabled=info\n \n-#![feature(phase)]\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate log;\n \n pub fn main() {"}, {"sha": "0f13df644a1f7760d69da0eefbc4901ffd259b52", "filename": "src/test/run-pass/logging-separate-lines.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-separate-lines.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -12,9 +12,7 @@\n // ignore-windows\n // exec-env:RUST_LOG=debug\n \n-#![feature(phase)]\n-\n-#[phase(plugin, link)]\n+#[macro_use]\n extern crate log;\n \n use std::io::Command;"}, {"sha": "80b2f408c1915674ad74da5987f5eb904bb59df5", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,16 +10,14 @@\n \n // ignore-pretty - token trees can't pretty print\n \n-#![feature(macro_rules)]\n-\n pub fn main() {\n \n-    macro_rules! mylambda_tt(\n+    macro_rules! mylambda_tt {\n         ($x:ident, $body:expr) => ({\n             fn f($x: int) -> int { return $body; };\n             f\n         })\n-    );\n+    }\n \n     assert!(mylambda_tt!(y, y * 2)(8) == 16);\n }"}, {"sha": "60217139cd77804e60bc652b67b0de7552422ca2", "filename": "src/test/run-pass/macro-attribute-expansion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,6 @@\n \n // ignore-pretty - token trees can't pretty print\n \n-#![feature(macro_rules)]\n-\n macro_rules! descriptions {\n     ($name:ident is $desc:expr) => {\n         // Check that we will correctly expand attributes"}, {"sha": "521aef4b5ba5b0b02bebe2e30381d75fc3d8c512", "filename": "src/test/run-pass/macro-attributes.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,6 @@\n \n // ignore-pretty - token trees can't pretty print\n \n-#![feature(macro_rules)]\n-\n macro_rules! compiles_fine {\n     (#[$at:meta]) => {\n         // test that the different types of attributes work"}, {"sha": "6c568d6d493ca9d2aa352280ea4a6f3ea5e21707", "filename": "src/test/run-pass/macro-block-nonterminal.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-block-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-block-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-block-nonterminal.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! do_block{\n     ($val:block) => {$val}\n }"}, {"sha": "7505fa6e6841afbb37d63a03f2e7bc4866c86e89", "filename": "src/test/run-pass/macro-crate-def-only.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-def-only.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,9 +10,7 @@\n \n // aux-build:macro_crate_def_only.rs\n \n-#![feature(phase)]\n-\n-#[phase(plugin)]\n+#[macro_use] #[no_link]\n extern crate macro_crate_def_only;\n \n pub fn main() {"}, {"sha": "cb919297b04064c2ef0042157ad8bf89c07cb322", "filename": "src/test/run-pass/macro-crate-nonterminal-renamed.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_nonterminal.rs\n+// ignore-stage1\n+\n+#[macro_use]\n+extern crate \"macro_crate_nonterminal\" as new_name;\n+\n+pub fn main() {\n+    new_name::check_local();\n+    assert_eq!(increment!(5), 6);\n+}"}, {"sha": "9882f806a9eea7744c76721fcae5e0e8dbcb1914", "filename": "src/test/run-pass/macro-crate-nonterminal.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_crate_nonterminal.rs\n+// ignore-stage1\n+\n+#[macro_use]\n+extern crate macro_crate_nonterminal;\n+\n+pub fn main() {\n+    macro_crate_nonterminal::check_local();\n+    assert_eq!(increment!(5), 6);\n+}"}, {"sha": "fbbe0105cf4fe3dc8e64185c363d3bf64344238e", "filename": "src/test/run-pass/macro-crate-use.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-crate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-use.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! increment {\n+    ($x:expr) => ({\n+        use $crate::increment;\n+        increment($x)\n+    })\n+}\n+\n+fn main() {\n+    assert_eq!(increment!(3), 4);\n+}"}, {"sha": "c4012e2cf3c7e4459d30492642b5d0b879d5ce1e", "filename": "src/test/run-pass/macro-deep_expansion.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-deep_expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-deep_expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-deep_expansion.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n macro_rules! foo2 {\n     () => {\n         \"foo\""}, {"sha": "ef22410751c0c860045e2830ed4921c80a4b052a", "filename": "src/test/run-pass/macro-export-inner-module.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,9 +11,7 @@\n //aux-build:macro_export_inner_module.rs\n //ignore-stage1\n \n-#![feature(phase)]\n-\n-#[phase(plugin)]\n+#[macro_use] #[no_link]\n extern crate macro_export_inner_module;\n \n pub fn main() {"}, {"sha": "ff5b29d6ac88b16f3c3fa294327972ce12314406", "filename": "src/test/run-pass/macro-interpolation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! overly_complicated (\n+macro_rules! overly_complicated {\n     ($fnname:ident, $arg:ident, $ty:ty, $body:block, $val:expr, $pat:pat, $res:path) =>\n     ({\n         fn $fnname($arg: $ty) -> Option<$ty> $body\n@@ -22,7 +20,7 @@ macro_rules! overly_complicated (\n         }\n     })\n \n-);\n+}\n \n pub fn main() {\n     assert!(overly_complicated!(f, x, Option<uint>, { return Some(x); },"}, {"sha": "ce748967498387ad24166e01167ee5b23f872074", "filename": "src/test/run-pass/macro-invocation-in-count-expr-fixed-array-type.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! four (\n+macro_rules! four {\n     () => (4)\n-);\n+}\n \n fn main() {\n     let _x: [u16; four!()];"}, {"sha": "47e3a0723993e2240f1fd499fd194d1758282efc", "filename": "src/test/run-pass/macro-meta-items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -11,8 +11,6 @@\n // ignore-pretty - token trees can't pretty print\n // compile-flags: --cfg foo\n \n-#![feature(macro_rules)]\n-\n macro_rules! compiles_fine {\n     ($at:meta) => {\n         #[cfg($at)]"}, {"sha": "fd16958d8964b9ab259951290d586acd97107c9c", "filename": "src/test/run-pass/macro-method-issue-4621.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n struct A;\n \n macro_rules! make_thirteen_method {() => (fn thirteen(&self)->int {13})}"}, {"sha": "f78f93e84810c8108d130ff63af29ac72749917d", "filename": "src/test/run-pass/macro-multiple-items.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,17 +10,15 @@\n \n // ignore-pretty - token trees can't pretty print\n \n-#![feature(macro_rules)]\n-\n-macro_rules! make_foo(\n+macro_rules! make_foo {\n     () => (\n         struct Foo;\n \n         impl Foo {\n             fn bar(&self) {}\n         }\n     )\n-);\n+}\n \n make_foo!();\n "}, {"sha": "c6efc2f2bc83bbbd1180c747490c68d1bab8255c", "filename": "src/test/run-pass/macro-nt-list.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! list (\n+macro_rules! list {\n     ( ($($id:ident),*) ) => (());\n     ( [$($id:ident),*] ) => (());\n     ( {$($id:ident),*} ) => (());\n-);\n+}\n \n-macro_rules! tt_list (\n+macro_rules! tt_list {\n     ( ($($tt:tt),*) ) => (());\n-);\n+}\n \n pub fn main() {\n     list!( () );"}, {"sha": "3276aa0265f70dd15e4e3799070a56954fc45c5f", "filename": "src/test/run-pass/macro-of-higher-order.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,14 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! higher_order (\n+macro_rules! higher_order {\n     (subst $lhs:tt => $rhs:tt) => ({\n-            macro_rules! anon ( $lhs => $rhs );\n+            macro_rules! anon { $lhs => $rhs }\n             anon!(1u, 2u, \"foo\")\n     });\n-);\n+}\n \n fn main() {\n     let val = higher_order!(subst ($x:expr, $y:expr, $foo:expr) => (($x + $y, $foo)));"}, {"sha": "07b75389cf4ffaccd8afa83c206c6f02f773a5cb", "filename": "src/test/run-pass/macro-pat.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pat.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,37 +8,35 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! mypat(\n+macro_rules! mypat {\n     () => (\n         Some('y')\n     )\n-);\n+}\n \n-macro_rules! char_x(\n+macro_rules! char_x {\n     () => (\n         'x'\n     )\n-);\n+}\n \n-macro_rules! some(\n+macro_rules! some {\n     ($x:pat) => (\n         Some($x)\n     )\n-);\n+}\n \n-macro_rules! indirect(\n+macro_rules! indirect {\n     () => (\n         some!(char_x!())\n     )\n-);\n+}\n \n-macro_rules! ident_pat(\n+macro_rules! ident_pat {\n     ($x:ident) => (\n         $x\n     )\n-);\n+}\n \n fn f(c: Option<char>) -> uint {\n     match c {"}, {"sha": "4aa1587943413de7cc5fa0be6948fc642054c7ac", "filename": "src/test/run-pass/macro-path.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-path.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n mod m {\n     pub type t = int;\n }"}, {"sha": "77ef9421273ef96d846512a811ec85e6083f8c3a", "filename": "src/test/run-pass/macro-reexport-no-intermediate-use.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-reexport-no-intermediate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-reexport-no-intermediate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-reexport-no-intermediate-use.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_reexport_1.rs\n+// aux-build:macro_reexport_2_no_use.rs\n+// ignore-stage1\n+\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_2_no_use;\n+\n+fn main() {\n+    assert_eq!(reexported!(), 3u);\n+}"}, {"sha": "9701610cbd9645f522c8a31899c2376fb0bf0b12", "filename": "src/test/run-pass/macro-reexport.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-reexport.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:macro_reexport_1.rs\n+// aux-build:macro_reexport_2.rs\n+// ignore-stage1\n+\n+#[macro_use] #[no_link]\n+extern crate macro_reexport_2;\n+\n+fn main() {\n+    assert_eq!(reexported!(), 3u);\n+}"}, {"sha": "cb5370c8bcba1b1f27b1c8ee12a8276485d883dc", "filename": "src/test/run-pass/macro-stmt.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,23 +10,21 @@\n \n // ignore-pretty - token trees can't pretty print\n \n-#![feature(macro_rules)]\n-\n-macro_rules! myfn(\n+macro_rules! myfn {\n     ( $f:ident, ( $( $x:ident ),* ), $body:block ) => (\n         fn $f( $( $x : int),* ) -> int $body\n     )\n-);\n+}\n \n myfn!(add, (a,b), { return a+b; } );\n \n pub fn main() {\n \n-    macro_rules! mylet(\n+    macro_rules! mylet {\n         ($x:ident, $val:expr) => (\n             let $x = $val;\n         )\n-    );\n+    }\n \n     mylet!(y, 8i*2);\n     assert_eq!(y, 16i);\n@@ -35,9 +33,9 @@ pub fn main() {\n \n     assert_eq!(mult(2, add(4,4)), 16);\n \n-    macro_rules! actually_an_expr_macro (\n+    macro_rules! actually_an_expr_macro {\n         () => ( 16i )\n-    );\n+    }\n \n     assert_eq!({ actually_an_expr_macro!() }, 16i);\n "}, {"sha": "b46910290a8a09d3c139baedb7b2c5cf78294161", "filename": "src/test/run-pass/macro-use-all-and-none.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-all-and-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-all-and-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-all-and-none.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use]\n+#[macro_use()]\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_one!();\n+    macro_two!();\n+}"}, {"sha": "cf72d2c623044149cf8a27a548b2467c0b6a0d3c", "filename": "src/test/run-pass/macro-use-all.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-all.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use]\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_one!();\n+    macro_two!();\n+}"}, {"sha": "4b0814bef04b811516938725cef95a1d8ca9506d", "filename": "src/test/run-pass/macro-use-both.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-both.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-both.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-both.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use(macro_one, macro_two)]\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_one!();\n+    macro_two!();\n+}"}, {"sha": "7911fec94da8bd74b915fbff33557368d93e3d97", "filename": "src/test/run-pass/macro-use-one.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-use-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-one.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:two_macros.rs\n+// ignore-stage1\n+\n+#[macro_use(macro_two)]\n+extern crate two_macros;\n+\n+pub fn main() {\n+    macro_two!();\n+}"}, {"sha": "3f9d07466cc8197e3ba3de62f8bd733f555a070e", "filename": "src/test/run-pass/macro-with-attrs1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,13 +10,11 @@\n \n // compile-flags: --cfg foo\n \n-#![feature(macro_rules)]\n-\n #[cfg(foo)]\n-macro_rules! foo( () => (1i) );\n+macro_rules! foo { () => (1i) }\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2i) );\n+macro_rules! foo { () => (2i) }\n \n pub fn main() {\n     assert_eq!(foo!(), 1i);"}, {"sha": "f90a0dfa6b31e41c2bec64082769b381dbe2e19a", "filename": "src/test/run-pass/macro-with-attrs2.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n #[cfg(foo)]\n-macro_rules! foo( () => (1i) );\n+macro_rules! foo { () => (1i) }\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2i) );\n+macro_rules! foo { () => (2i) }\n \n pub fn main() {\n     assert_eq!(foo!(), 2i);"}, {"sha": "93bb9557604c49cd9d4e61fa1373b74edd7485bf", "filename": "src/test/run-pass/macro-with-braces-in-expr-position.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n use std::thread::Thread;\n \n-macro_rules! expr (($e: expr) => { $e });\n+macro_rules! expr { ($e: expr) => { $e } }\n \n macro_rules! spawn {\n     ($($code: tt)*) => {"}, {"sha": "e4886ddaa0ed3155943fe8221cec54a23a66f638", "filename": "src/test/run-pass/match-in-macro.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,19 +8,17 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n enum Foo {\n     B { b1: int, bb1: int},\n }\n \n-macro_rules! match_inside_expansion(\n+macro_rules! match_inside_expansion {\n     () => (\n         match (Foo::B { b1:29 , bb1: 100}) {\n             Foo::B { b1:b2 , bb1:bb2 } => b2+bb2\n         }\n     )\n-);\n+}\n \n pub fn main() {\n     assert_eq!(match_inside_expansion!(),129);"}, {"sha": "984f675b4dc7ddab5e0ba6183ebcc25d4ca74d2b", "filename": "src/test/run-pass/match-var-hygiene.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmatch-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fmatch-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-var-hygiene.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,12 +10,10 @@\n \n // ignore-test #9384\n \n-#![feature(macro_rules)]\n-\n // shouldn't affect evaluation of $ex.\n-macro_rules! bad_macro (($ex:expr) => (\n+macro_rules! bad_macro { ($ex:expr) => (\n     {match 9 {_x => $ex}}\n-))\n+)}\n \n fn main() {\n     match 8 {"}, {"sha": "8b41670734f95bee52407cf7c9065ef205728e05", "filename": "src/test/run-pass/non-built-in-quote.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n-macro_rules! quote_tokens ( () => (()) );\n+macro_rules! quote_tokens { () => (()) }\n \n pub fn main() {\n     quote_tokens!();"}, {"sha": "9b9a7f68995f7e90456ef1753fd93190d652a07d", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n use std::{option, mem};\n \n // Iota-reduction is a rule in the Calculus of (Co-)Inductive Constructions,"}, {"sha": "02fc0cf0291d43ba23e1eee7986f7efa39460e93", "filename": "src/test/run-pass/nullable-pointer-size.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-size.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(macro_rules)]\n-\n use std::mem;\n \n enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8; 0]) }"}, {"sha": "5a91f603f9681cac54062e9ddad404e9e1893d5a", "filename": "src/test/run-pass/plugin-args-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplugin-args-1.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:plugin_args.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+\n+#[no_link]\n+#[plugin]\n+extern crate plugin_args;\n+\n+fn main() {\n+    assert_eq!(plugin_args!(), \"#[plugin]\");\n+}"}, {"sha": "d0ac22a529021641694689a24771f47ddfcddad4", "filename": "src/test/run-pass/plugin-args-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplugin-args-2.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:plugin_args.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+\n+#[no_link]\n+#[plugin()]\n+extern crate plugin_args;\n+\n+fn main() {\n+    assert_eq!(plugin_args!(), \"#[plugin()]\");\n+}"}, {"sha": "7cac8ac57e55c09d31b9da0c21ac32afbd71f9c7", "filename": "src/test/run-pass/plugin-args-3.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplugin-args-3.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:plugin_args.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+\n+#[no_link]\n+#[plugin(hello(there), how(are=\"you\"))]\n+extern crate plugin_args;\n+\n+fn main() {\n+    assert_eq!(plugin_args!(), \"#[plugin(hello(there), how(are = \\\"you\\\"))]\");\n+}"}, {"sha": "8563c8c178ff88bb5e090c655481ab033c60094a", "filename": "src/test/run-pass/plugin-args-4.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Fplugin-args-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplugin-args-4.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:plugin_args.rs\n+// ignore-stage1\n+\n+#![feature(plugin)]\n+\n+#[no_link]\n+#[plugin=\"foobar\"]\n+extern crate plugin_args;\n+\n+fn main() {\n+    assert_eq!(plugin_args!(), \"#[plugin = \\\"foobar\\\"]\");\n+}"}, {"sha": "95f90ebbf8edf89589de19a82bdbe021e07bd91c", "filename": "src/test/run-pass/rust-log-filter.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7975fd9cee750f26f9f6ef85b92a20b24ee24120/src%2Ftest%2Frun-pass%2Frust-log-filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frust-log-filter.rs?ref=7975fd9cee750f26f9f6ef85b92a20b24ee24120", "patch": "@@ -10,8 +10,7 @@\n \n // exec-env:RUST_LOG=rust-log-filter/f.o\n \n-#![feature(phase)]\n-#[phase(plugin,link)]\n+#[macro_use]\n extern crate log;\n \n use std::sync::mpsc::{channel, Sender, Receiver};"}]}