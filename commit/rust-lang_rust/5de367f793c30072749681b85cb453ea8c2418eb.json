{"sha": "5de367f793c30072749681b85cb453ea8c2418eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkZTM2N2Y3OTNjMzAwNzI3NDk2ODFiODVjYjQ1M2VhOGMyNDE4ZWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-09T09:56:17Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-30T07:46:00Z"}, "message": "Don't create additional references when invoking binary operators", "tree": {"sha": "1e4f7453f12abdd9341d438c1f6b5ff579b169e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e4f7453f12abdd9341d438c1f6b5ff579b169e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5de367f793c30072749681b85cb453ea8c2418eb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAljct7gACgkQpp+NIls6\n19mQHg//bqoKjgmBrwpSlgVeqDUytk2ZJvU0jjhPom1jHkhMGZDfvG9iu6wAQP9Q\nQatygUewhbdTrxDE01x7uTITBsvBd8Ttnxl+c6qWnwPiGj2U42mD6wLdztV9xs7D\n3cMlID901iBc6xnPWoI0VxX48ij2lm9va8WsE/RixqN8K8uKlWPZDzQXyx3A3XqB\nJ50dzUkAJMc+5ZRpS35EHRuPhV5MqgwhJ3b2ZqtbaPI4ivbQ5aJOxksCacMJds2p\nGnNqc2ahyKx+vPhEdsyBJrGfFiVQ925m2PV1A2MIMdzxbnGnOMuxTiOPL+iqGdJM\nP+9Cw7z6xK/dgzZH8tzExk48YtSNCNEdK8uWjGme1h9JVK513JMfOM/C3t1WBOiq\ngGsrBDTEgoZ659pCOtQWknkxXNEK+AZBOHmZ9j6MEIWwwEOy+sIfkBW+h0DndGNd\nAritzxlBihh2WK78MraCt7yCAxPbuhPyqIjho/ydl22DYQD/dzWj6pgwkgwet1Mf\nv2blONLldeRHimZ4fy2yTcD191VfiyKZ5tcjr7mffdEpgRma/WQ9y9fBx0SbfZkh\nhso6JokqYd+FW3GPXPtHnwxQ/mOOv98O6cw3aCyOJ1PDNim6jMxiz4Q0CsD86h+a\ntYH/CXtoi6k2rkEqT3TvrFyoP0t8VqQ1ayXLzc+gKRC65ijmLng=\n=dRG/\n-----END PGP SIGNATURE-----", "payload": "tree 1e4f7453f12abdd9341d438c1f6b5ff579b169e1\nparent 813daf236f2cbc5ea8ebbb80d676d58f0f012e6a\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1489053377 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1490859960 +0200\n\nDon't create additional references when invoking binary operators"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5de367f793c30072749681b85cb453ea8c2418eb", "html_url": "https://github.com/rust-lang/rust/commit/5de367f793c30072749681b85cb453ea8c2418eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5de367f793c30072749681b85cb453ea8c2418eb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "813daf236f2cbc5ea8ebbb80d676d58f0f012e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/813daf236f2cbc5ea8ebbb80d676d58f0f012e6a", "html_url": "https://github.com/rust-lang/rust/commit/813daf236f2cbc5ea8ebbb80d676d58f0f012e6a"}], "stats": {"total": 83, "additions": 76, "deletions": 7}, "files": [{"sha": "dccfed87269222f8edb0624b6ef976729d44cff7", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5de367f793c30072749681b85cb453ea8c2418eb/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5de367f793c30072749681b85cb453ea8c2418eb/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=5de367f793c30072749681b85cb453ea8c2418eb", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::*;\n use rustc::lint::*;\n-use utils::{SpanlessEq, span_lint};\n+use utils::{SpanlessEq, span_lint, span_lint_and_then, multispan_sugg, snippet};\n+use utils::sugg::Sugg;\n \n /// **What it does:** Checks for equal operands to comparison, logical and\n /// bitwise, difference and division binary operators (`==`, `>`, etc., `&&`,\n@@ -23,23 +24,91 @@ declare_lint! {\n     \"equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\"\n }\n \n+/// **What it does:** Checks for arguments to `==` which have their address taken to satisfy a bound\n+/// and suggests to dereference the other argument instead\n+///\n+/// **Why is this bad?** It is more idiomatic to dereference the other argument.\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// &x == y\n+/// ```\n+declare_lint! {\n+    pub OP_REF,\n+    Warn,\n+    \"taking a reference to satisfy the type constraints on `==`\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct EqOp;\n \n impl LintPass for EqOp {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(EQ_OP)\n+        lint_array!(EQ_OP, OP_REF)\n     }\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n-                span_lint(cx,\n-                          EQ_OP,\n-                          e.span,\n-                          &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+            if is_valid_operator(op) {\n+                if SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n+                    span_lint(cx,\n+                            EQ_OP,\n+                            e.span,\n+                            &format!(\"equal expressions as operands to `{}`\", op.node.as_str()));\n+                } else {\n+                    match (&left.node, &right.node) {\n+                        (&ExprAddrOf(_, ref l), &ExprAddrOf(_, ref r)) => {\n+                            span_lint_and_then(cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"taken reference of both operands, which is done automatically by the operator anyway\",\n+                                |db| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    multispan_sugg(db,\n+                                                \"use the values directly\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                     (right.span, rsnip)]);\n+                                }\n+                            )\n+                        }\n+                        (&ExprAddrOf(_, ref l), _) => {\n+                            span_lint_and_then(cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"taken reference of left operand\",\n+                                |db| {\n+                                    let lsnip = snippet(cx, l.span, \"...\").to_string();\n+                                    let rsnip = Sugg::hir(cx, right, \"...\").deref().to_string();\n+                                    multispan_sugg(db,\n+                                                \"dereference the right operand instead\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                     (right.span, rsnip)]);\n+                                }\n+                            )\n+                        }\n+                        (_, &ExprAddrOf(_, ref r)) => {\n+                            span_lint_and_then(cx,\n+                                OP_REF,\n+                                e.span,\n+                                \"taken reference of right operand\",\n+                                |db| {\n+                                    let lsnip = Sugg::hir(cx, left, \"...\").deref().to_string();\n+                                    let rsnip = snippet(cx, r.span, \"...\").to_string();\n+                                    multispan_sugg(db,\n+                                                \"dereference the left operand instead\".to_string(),\n+                                                vec![(left.span, lsnip),\n+                                                     (right.span, rsnip)]);\n+                                }\n+                            )\n+                        }\n+                        _ => {}\n+                    }\n+                }\n             }\n         }\n     }"}]}