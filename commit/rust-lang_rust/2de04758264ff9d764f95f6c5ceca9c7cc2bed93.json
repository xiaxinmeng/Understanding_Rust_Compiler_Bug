{"sha": "2de04758264ff9d764f95f6c5ceca9c7cc2bed93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZTA0NzU4MjY0ZmY5ZDc2NGY5NWY2YzVjZWNhOWM3Y2MyYmVkOTM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-21T23:26:53Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-27T18:22:19Z"}, "message": "Rename `pat_constructor` to `Constructor::from_pat`", "tree": {"sha": "ebb0192af2ded6f10a94216d05ab3260a4beccb4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebb0192af2ded6f10a94216d05ab3260a4beccb4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2de04758264ff9d764f95f6c5ceca9c7cc2bed93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2de04758264ff9d764f95f6c5ceca9c7cc2bed93", "html_url": "https://github.com/rust-lang/rust/commit/2de04758264ff9d764f95f6c5ceca9c7cc2bed93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2de04758264ff9d764f95f6c5ceca9c7cc2bed93/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba3c419a43c9b20950ad8c0e74c1be2616de40fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3c419a43c9b20950ad8c0e74c1be2616de40fd", "html_url": "https://github.com/rust-lang/rust/commit/ba3c419a43c9b20950ad8c0e74c1be2616de40fd"}], "stats": {"total": 126, "additions": 63, "deletions": 63}, "files": [{"sha": "be96d5ae816849d5f6840f3d3e7af2ec832d9e59", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2de04758264ff9d764f95f6c5ceca9c7cc2bed93/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de04758264ff9d764f95f6c5ceca9c7cc2bed93/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=2de04758264ff9d764f95f6c5ceca9c7cc2bed93", "patch": "@@ -306,7 +306,7 @@\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n-use super::deconstruct_pat::{pat_constructor, Constructor, Fields, MissingConstructors};\n+use super::deconstruct_pat::{Constructor, Fields, MissingConstructors};\n use super::{Pat, PatKind};\n use super::{PatternFoldable, PatternFolder};\n \n@@ -438,7 +438,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     }\n \n     fn head_ctor<'a>(&'a self, cx: &MatchCheckCtxt<'p, 'tcx>) -> &'a Constructor<'tcx> {\n-        self.head_ctor.get_or_init(|| pat_constructor(cx, self.head()))\n+        self.head_ctor.get_or_init(|| Constructor::from_pat(cx, self.head()))\n     }\n \n     fn iter(&self) -> impl Iterator<Item = &Pat<'tcx>> {"}, {"sha": "1ff7ed5d8fd4d196d616370925dc5d5d4c02d59e", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/2de04758264ff9d764f95f6c5ceca9c7cc2bed93/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2de04758264ff9d764f95f6c5ceca9c7cc2bed93/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=2de04758264ff9d764f95f6c5ceca9c7cc2bed93", "patch": "@@ -606,6 +606,67 @@ impl<'tcx> Constructor<'tcx> {\n         }\n     }\n \n+    /// Determines the constructor that the given pattern can be specialized to.\n+    pub(super) fn from_pat<'p>(cx: &MatchCheckCtxt<'p, 'tcx>, pat: &'p Pat<'tcx>) -> Self {\n+        match pat.kind.as_ref() {\n+            PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n+            PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n+            PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n+            &PatKind::Variant { adt_def, variant_index, .. } => {\n+                Variant(adt_def.variants[variant_index].def_id)\n+            }\n+            PatKind::Constant { value } => {\n+                if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span)\n+                {\n+                    IntRange(int_range)\n+                } else {\n+                    match pat.ty.kind() {\n+                        ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n+                        // In `expand_pattern`, we convert string literals to `&CONST` patterns with\n+                        // `CONST` a pattern of type `str`. In truth this contains a constant of type\n+                        // `&str`.\n+                        ty::Str => Str(value),\n+                        // All constants that can be structurally matched have already been expanded\n+                        // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n+                        // opaque.\n+                        _ => Opaque,\n+                    }\n+                }\n+            }\n+            &PatKind::Range(PatRange { lo, hi, end }) => {\n+                let ty = lo.ty;\n+                if let Some(int_range) = IntRange::from_range(\n+                    cx.tcx,\n+                    lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n+                    hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n+                    ty,\n+                    &end,\n+                    pat.span,\n+                ) {\n+                    IntRange(int_range)\n+                } else {\n+                    FloatRange(lo, hi, end)\n+                }\n+            }\n+            PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n+                let array_len = match pat.ty.kind() {\n+                    ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n+                    ty::Slice(_) => None,\n+                    _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n+                };\n+                let prefix = prefix.len() as u64;\n+                let suffix = suffix.len() as u64;\n+                let kind = if slice.is_some() {\n+                    VarLen(prefix, suffix)\n+                } else {\n+                    FixedLen(prefix + suffix)\n+                };\n+                Slice(Slice::new(array_len, kind))\n+            }\n+            PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n+        }\n+    }\n+\n     /// Some constructors (namely `Wildcard`, `IntRange` and `Slice`) actually stand for a set of actual\n     /// constructors (like variants, integers or fixed-sized slices). When specializing for these\n     /// constructors, we want to be specialising for the actual underlying constructors.\n@@ -756,67 +817,6 @@ impl<'tcx> Constructor<'tcx> {\n     }\n }\n \n-/// Determines the constructor that the given pattern can be specialized to.\n-/// Returns `None` in case of a catch-all, which can't be specialized.\n-pub(super) fn pat_constructor<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    pat: &'p Pat<'tcx>,\n-) -> Constructor<'tcx> {\n-    match pat.kind.as_ref() {\n-        PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n-        PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n-        PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n-        &PatKind::Variant { adt_def, variant_index, .. } => {\n-            Variant(adt_def.variants[variant_index].def_id)\n-        }\n-        PatKind::Constant { value } => {\n-            if let Some(int_range) = IntRange::from_const(cx.tcx, cx.param_env, value, pat.span) {\n-                IntRange(int_range)\n-            } else {\n-                match pat.ty.kind() {\n-                    ty::Float(_) => FloatRange(value, value, RangeEnd::Included),\n-                    // In `expand_pattern`, we convert string literals to `&CONST` patterns with\n-                    // `CONST` a pattern of type `str`. In truth this contains a constant of type\n-                    // `&str`.\n-                    ty::Str => Str(value),\n-                    // All constants that can be structurally matched have already been expanded\n-                    // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n-                    // opaque.\n-                    _ => Opaque,\n-                }\n-            }\n-        }\n-        &PatKind::Range(PatRange { lo, hi, end }) => {\n-            let ty = lo.ty;\n-            if let Some(int_range) = IntRange::from_range(\n-                cx.tcx,\n-                lo.eval_bits(cx.tcx, cx.param_env, lo.ty),\n-                hi.eval_bits(cx.tcx, cx.param_env, hi.ty),\n-                ty,\n-                &end,\n-                pat.span,\n-            ) {\n-                IntRange(int_range)\n-            } else {\n-                FloatRange(lo, hi, end)\n-            }\n-        }\n-        PatKind::Array { prefix, slice, suffix } | PatKind::Slice { prefix, slice, suffix } => {\n-            let array_len = match pat.ty.kind() {\n-                ty::Array(_, length) => Some(length.eval_usize(cx.tcx, cx.param_env)),\n-                ty::Slice(_) => None,\n-                _ => span_bug!(pat.span, \"bad ty {:?} for slice pattern\", pat.ty),\n-            };\n-            let prefix = prefix.len() as u64;\n-            let suffix = suffix.len() as u64;\n-            let kind =\n-                if slice.is_some() { VarLen(prefix, suffix) } else { FixedLen(prefix + suffix) };\n-            Slice(Slice::new(array_len, kind))\n-        }\n-        PatKind::Or { .. } => bug!(\"Or-pattern should have been expanded earlier on.\"),\n-    }\n-}\n-\n /// This determines the set of all possible constructors of a pattern matching\n /// values of type `left_ty`. For vectors, this would normally be an infinite set\n /// but is instead bounded by the maximum fixed length of slice patterns in"}]}