{"sha": "cb7f116c04d3355665f8d1e7aa51880010c2d8d7", "node_id": "C_kwDOAAsO6NoAKGNiN2YxMTZjMDRkMzM1NTY2NWY4ZDFlN2FhNTE4ODAwMTBjMmQ4ZDc", "commit": {"author": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-05-07T13:02:25Z"}, "committer": {"name": "SparrowLii", "email": "liyuan179@huawei.com", "date": "2022-05-07T13:02:25Z"}, "message": "optimize `promote_consts` by cache the validate check", "tree": {"sha": "f4e47b312ba007a5b9f4649e75a09b1c4f34852f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4e47b312ba007a5b9f4649e75a09b1c4f34852f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb7f116c04d3355665f8d1e7aa51880010c2d8d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb7f116c04d3355665f8d1e7aa51880010c2d8d7", "html_url": "https://github.com/rust-lang/rust/commit/cb7f116c04d3355665f8d1e7aa51880010c2d8d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb7f116c04d3355665f8d1e7aa51880010c2d8d7/comments", "author": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SparrowLii", "id": 68270294, "node_id": "MDQ6VXNlcjY4MjcwMjk0", "avatar_url": "https://avatars.githubusercontent.com/u/68270294?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SparrowLii", "html_url": "https://github.com/SparrowLii", "followers_url": "https://api.github.com/users/SparrowLii/followers", "following_url": "https://api.github.com/users/SparrowLii/following{/other_user}", "gists_url": "https://api.github.com/users/SparrowLii/gists{/gist_id}", "starred_url": "https://api.github.com/users/SparrowLii/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SparrowLii/subscriptions", "organizations_url": "https://api.github.com/users/SparrowLii/orgs", "repos_url": "https://api.github.com/users/SparrowLii/repos", "events_url": "https://api.github.com/users/SparrowLii/events{/privacy}", "received_events_url": "https://api.github.com/users/SparrowLii/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4799baa70d0ff1780ee6dffb743d62c79235ace9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4799baa70d0ff1780ee6dffb743d62c79235ace9", "html_url": "https://github.com/rust-lang/rust/commit/4799baa70d0ff1780ee6dffb743d62c79235ace9"}], "stats": {"total": 111, "additions": 70, "deletions": 41}, "files": [{"sha": "daba60fca38079f9212ea61f31ded10b635d91de", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 70, "deletions": 41, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cb7f116c04d3355665f8d1e7aa51880010c2d8d7/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb7f116c04d3355665f8d1e7aa51880010c2d8d7/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=cb7f116c04d3355665f8d1e7aa51880010c2d8d7", "patch": "@@ -60,9 +60,9 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n \n         let mut rpo = traversal::reverse_postorder(body);\n         let ccx = ConstCx::new(tcx, body);\n-        let (temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n+        let (mut temps, all_candidates) = collect_temps_and_candidates(&ccx, &mut rpo);\n \n-        let promotable_candidates = validate_candidates(&ccx, &temps, &all_candidates);\n+        let promotable_candidates = validate_candidates(&ccx, &mut temps, &all_candidates);\n \n         let promoted = promote_candidates(body, tcx, temps, promotable_candidates);\n         self.promoted_fragments.set(promoted);\n@@ -77,14 +77,21 @@ pub enum TempState {\n     /// One direct assignment and any number of direct uses.\n     /// A borrow of this temp is promotable if the assigned\n     /// value is qualified as constant.\n-    Defined { location: Location, uses: usize },\n+    Defined { location: Location, uses: usize, valid: Valid },\n     /// Any other combination of assignments/uses.\n     Unpromotable,\n     /// This temp was part of an rvalue which got extracted\n     /// during promotion and needs cleanup.\n     PromotedOut,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Valid {\n+    Unknown,\n+    InValid,\n+    Validated,\n+}\n+\n impl TempState {\n     pub fn is_promotable(&self) -> bool {\n         debug!(\"is_promotable: self={:?}\", self);\n@@ -133,7 +140,7 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             match context {\n                 PlaceContext::MutatingUse(MutatingUseContext::Store)\n                 | PlaceContext::MutatingUse(MutatingUseContext::Call) => {\n-                    *temp = TempState::Defined { location, uses: 0 };\n+                    *temp = TempState::Defined { location, uses: 0, valid: Valid::Unknown };\n                     return;\n                 }\n                 _ => { /* mark as unpromotable below */ }\n@@ -188,7 +195,7 @@ pub fn collect_temps_and_candidates<'tcx>(\n /// This wraps an `Item`, and has access to all fields of that `Item` via `Deref` coercion.\n struct Validator<'a, 'tcx> {\n     ccx: &'a ConstCx<'a, 'tcx>,\n-    temps: &'a IndexVec<Local, TempState>,\n+    temps: &'a mut IndexVec<Local, TempState>,\n }\n \n impl<'a, 'tcx> std::ops::Deref for Validator<'a, 'tcx> {\n@@ -202,7 +209,7 @@ impl<'a, 'tcx> std::ops::Deref for Validator<'a, 'tcx> {\n struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n-    fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n+    fn validate_candidate(&mut self, candidate: Candidate) -> Result<(), Unpromotable> {\n         let loc = candidate.location;\n         let statement = &self.body[loc.block].statements[loc.statement_index];\n         match &statement.kind {\n@@ -234,7 +241,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n \n     // FIXME(eddyb) maybe cache this?\n-    fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n+    fn qualif_local<Q: qualifs::Qualif>(&mut self, local: Local) -> bool {\n         if let TempState::Defined { location: loc, .. } = self.temps[local] {\n             let num_stmts = self.body[loc.block].statements.len();\n \n@@ -272,40 +279,62 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    // FIXME(eddyb) maybe cache this?\n-    fn validate_local(&self, local: Local) -> Result<(), Unpromotable> {\n-        if let TempState::Defined { location: loc, .. } = self.temps[local] {\n-            let block = &self.body[loc.block];\n-            let num_stmts = block.statements.len();\n-\n-            if loc.statement_index < num_stmts {\n-                let statement = &block.statements[loc.statement_index];\n-                match &statement.kind {\n-                    StatementKind::Assign(box (_, rhs)) => self.validate_rvalue(rhs),\n-                    _ => {\n-                        span_bug!(\n-                            statement.source_info.span,\n-                            \"{:?} is not an assignment\",\n-                            statement\n-                        );\n-                    }\n-                }\n-            } else {\n-                let terminator = block.terminator();\n-                match &terminator.kind {\n-                    TerminatorKind::Call { func, args, .. } => self.validate_call(func, args),\n-                    TerminatorKind::Yield { .. } => Err(Unpromotable),\n-                    kind => {\n-                        span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);\n-                    }\n+    fn validate_local(&mut self, local: Local) -> Result<(), Unpromotable> {\n+        if let TempState::Defined { location: loc, uses, valid } = self.temps[local] {\n+            match valid {\n+                Valid::InValid => Err(Unpromotable),\n+                Valid::Validated => Ok(()),\n+                Valid::Unknown => {\n+                    let ok = {\n+                        let block = &self.body[loc.block];\n+                        let num_stmts = block.statements.len();\n+\n+                        if loc.statement_index < num_stmts {\n+                            let statement = &block.statements[loc.statement_index];\n+                            match &statement.kind {\n+                                StatementKind::Assign(box (_, rhs)) => self.validate_rvalue(rhs),\n+                                _ => {\n+                                    span_bug!(\n+                                        statement.source_info.span,\n+                                        \"{:?} is not an assignment\",\n+                                        statement\n+                                    );\n+                                }\n+                            }\n+                        } else {\n+                            let terminator = block.terminator();\n+                            match &terminator.kind {\n+                                TerminatorKind::Call { func, args, .. } => {\n+                                    self.validate_call(func, args)\n+                                }\n+                                TerminatorKind::Yield { .. } => Err(Unpromotable),\n+                                kind => {\n+                                    span_bug!(\n+                                        terminator.source_info.span,\n+                                        \"{:?} not promotable\",\n+                                        kind\n+                                    );\n+                                }\n+                            }\n+                        }\n+                    };\n+                    self.temps[local] = TempState::Defined {\n+                        location: loc,\n+                        uses,\n+                        valid: match ok {\n+                            Ok(()) => Valid::Validated,\n+                            Err(_) => Valid::InValid,\n+                        },\n+                    };\n+                    ok\n                 }\n             }\n         } else {\n             Err(Unpromotable)\n         }\n     }\n \n-    fn validate_place(&self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_place(&mut self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n         match place.last_projection() {\n             None => self.validate_local(place.local),\n             Some((place_base, elem)) => {\n@@ -417,7 +446,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_operand(&self, operand: &Operand<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_operand(&mut self, operand: &Operand<'tcx>) -> Result<(), Unpromotable> {\n         match operand {\n             Operand::Copy(place) | Operand::Move(place) => self.validate_place(place.as_ref()),\n \n@@ -447,7 +476,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         }\n     }\n \n-    fn validate_ref(&self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_ref(&mut self, kind: BorrowKind, place: &Place<'tcx>) -> Result<(), Unpromotable> {\n         match kind {\n             // Reject these borrow types just to be safe.\n             // FIXME(RalfJung): could we allow them? Should we? No point in it until we have a usecase.\n@@ -480,7 +509,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n         Ok(())\n     }\n \n-    fn validate_rvalue(&self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n+    fn validate_rvalue(&mut self, rvalue: &Rvalue<'tcx>) -> Result<(), Unpromotable> {\n         match rvalue {\n             Rvalue::Use(operand) | Rvalue::Repeat(operand, _) => {\n                 self.validate_operand(operand)?;\n@@ -623,7 +652,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n     }\n \n     fn validate_call(\n-        &self,\n+        &mut self,\n         callee: &Operand<'tcx>,\n         args: &[Operand<'tcx>],\n     ) -> Result<(), Unpromotable> {\n@@ -665,10 +694,10 @@ impl<'tcx> Validator<'_, 'tcx> {\n // FIXME(eddyb) remove the differences for promotability in `static`, `const`, `const fn`.\n pub fn validate_candidates(\n     ccx: &ConstCx<'_, '_>,\n-    temps: &IndexVec<Local, TempState>,\n+    temps: &mut IndexVec<Local, TempState>,\n     candidates: &[Candidate],\n ) -> Vec<Candidate> {\n-    let validator = Validator { ccx, temps };\n+    let mut validator = Validator { ccx, temps };\n \n     candidates\n         .iter()\n@@ -720,7 +749,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     fn promote_temp(&mut self, temp: Local) -> Local {\n         let old_keep_original = self.keep_original;\n         let loc = match self.temps[temp] {\n-            TempState::Defined { location, uses } if uses > 0 => {\n+            TempState::Defined { location, uses, .. } if uses > 0 => {\n                 if uses > 1 {\n                     self.keep_original = true;\n                 }"}]}