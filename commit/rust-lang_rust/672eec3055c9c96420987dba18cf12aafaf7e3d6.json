{"sha": "672eec3055c9c96420987dba18cf12aafaf7e3d6", "node_id": "C_kwDOAAsO6NoAKDY3MmVlYzMwNTVjOWM5NjQyMDk4N2RiYTE4Y2YxMmFhZmFmN2UzZDY", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-07-24T21:33:38Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2022-08-03T23:34:47Z"}, "message": "Support symbol visibility", "tree": {"sha": "0e6848fc8162eff73e07b74680640867b5b6dbc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e6848fc8162eff73e07b74680640867b5b6dbc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/672eec3055c9c96420987dba18cf12aafaf7e3d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/672eec3055c9c96420987dba18cf12aafaf7e3d6", "html_url": "https://github.com/rust-lang/rust/commit/672eec3055c9c96420987dba18cf12aafaf7e3d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/672eec3055c9c96420987dba18cf12aafaf7e3d6/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a227994b5399d2ff236f116c4f62e10268ab1f73", "url": "https://api.github.com/repos/rust-lang/rust/commits/a227994b5399d2ff236f116c4f62e10268ab1f73", "html_url": "https://github.com/rust-lang/rust/commit/a227994b5399d2ff236f116c4f62e10268ab1f73"}], "stats": {"total": 156, "additions": 145, "deletions": 11}, "files": [{"sha": "3245f5843e549a9c5405a021b4d51453567ebf77", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/672eec3055c9c96420987dba18cf12aafaf7e3d6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/672eec3055c9c96420987dba18cf12aafaf7e3d6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=672eec3055c9c96420987dba18cf12aafaf7e3d6", "patch": "@@ -41,15 +41,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#a8997afb665dc467c1bdbddf04877143683f0cce\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1a60fe3918a5b3b0983c1ea09f4b9445001a6468\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#a8997afb665dc467c1bdbddf04877143683f0cce\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#1a60fe3918a5b3b0983c1ea09f4b9445001a6468\"\n dependencies = [\n  \"libc 0.1.12\",\n ]"}, {"sha": "60985003a9e01e2915f385195fc7c8e829a8d628", "filename": "src/allocator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fallocator.rs?ref=672eec3055c9c96420987dba18cf12aafaf7e3d6", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_middle::bug;\n@@ -50,7 +52,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n         if tcx.sess.target.options.default_hidden_visibility {\n-            // TODO(antoyo): set visibility.\n+            #[cfg(feature=\"master\")]\n+            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n             // TODO(antoyo): emit unwind tables.\n@@ -61,7 +64,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n             .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n             .collect();\n         let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        // TODO(antoyo): set visibility.\n+        #[cfg(feature=\"master\")]\n+        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n         let block = func.new_block(\"entry\");\n \n@@ -90,6 +94,11 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n+    if tcx.sess.target.default_hidden_visibility {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+    }\n+\n     let kind =\n         if has_alloc_error_handler {\n             AllocatorKind::Global\n@@ -102,7 +111,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();\n     let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n-    //llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+    #[cfg(feature=\"master\")]\n+    callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n     let block = func.new_block(\"entry\");\n "}, {"sha": "243a1a36dd09db20d3d66e9c7b121d54a248d1b6", "filename": "src/attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattributes.rs?ref=672eec3055c9c96420987dba18cf12aafaf7e3d6", "patch": "@@ -1,4 +1,4 @@\n-#[cfg_attr(not(feature=\"master\"), allow(unused_imports))]\n+#[cfg(feature=\"master\")]\n use gccjit::FnAttribute;\n use gccjit::Function;\n use rustc_attr::InstructionSetAttr;\n@@ -107,6 +107,6 @@ pub fn from_fn_attrs<'gcc, 'tcx>(\n     let target_features = function_features.join(\",\");\n     if !target_features.is_empty() {\n         #[cfg(feature=\"master\")]\n-        func.add_attribute(FnAttribute::Target, &target_features);\n+        func.add_attribute(FnAttribute::Target(&target_features));\n     }\n }"}, {"sha": "42194b526e6406c2388c2f2e4a726686e892e8b0", "filename": "src/base.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=672eec3055c9c96420987dba18cf12aafaf7e3d6", "patch": "@@ -8,6 +8,8 @@ use gccjit::{\n };\n use rustc_middle::dep_graph;\n use rustc_middle::ty::TyCtxt;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::mir::mono::Visibility;\n use rustc_middle::mir::mono::Linkage;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -20,6 +22,15 @@ use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n+#[cfg(feature=\"master\")]\n+pub fn visibility_to_gcc(linkage: Visibility) -> gccjit::Visibility {\n+    match linkage {\n+        Visibility::Default => gccjit::Visibility::Default,\n+        Visibility::Hidden => gccjit::Visibility::Hidden,\n+        Visibility::Protected => gccjit::Visibility::Protected,\n+    }\n+}\n+\n pub fn global_linkage_to_gcc(linkage: Linkage) -> GlobalKind {\n     match linkage {\n         Linkage::External => GlobalKind::Imported,"}, {"sha": "d7bbf1d34ef107d3a9ecb7287dd9a6adbdee178c", "filename": "src/callee.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcallee.rs?ref=672eec3055c9c96420987dba18cf12aafaf7e3d6", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{FnAttribute, Visibility};\n use gccjit::{FunctionType, RValue};\n use rustc_codegen_ssa::traits::BaseTypeMethods;\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n@@ -70,8 +72,97 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n \n             attributes::from_fn_attrs(cx, func, instance);\n \n+            let instance_def_id = instance.def_id();\n+\n             // TODO(antoyo): set linkage and attributes.\n \n+            // Apply an appropriate linkage/visibility value to our item that we\n+            // just declared.\n+            //\n+            // This is sort of subtle. Inside our codegen unit we started off\n+            // compilation by predefining all our own `MonoItem` instances. That\n+            // is, everything we're codegenning ourselves is already defined. That\n+            // means that anything we're actually codegenning in this codegen unit\n+            // will have hit the above branch in `get_declared_value`. As a result,\n+            // we're guaranteed here that we're declaring a symbol that won't get\n+            // defined, or in other words we're referencing a value from another\n+            // codegen unit or even another crate.\n+            //\n+            // So because this is a foreign value we blanket apply an external\n+            // linkage directive because it's coming from a different object file.\n+            // The visibility here is where it gets tricky. This symbol could be\n+            // referencing some foreign crate or foreign library (an `extern`\n+            // block) in which case we want to leave the default visibility. We may\n+            // also, though, have multiple codegen units. It could be a\n+            // monomorphization, in which case its expected visibility depends on\n+            // whether we are sharing generics or not. The important thing here is\n+            // that the visibility we apply to the declaration is the same one that\n+            // has been applied to the definition (wherever that definition may be).\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+            if is_generic {\n+                // This is a monomorphization. Its expected visibility depends\n+                // on whether we are in share-generics mode.\n+\n+                if cx.tcx.sess.opts.share_generics() {\n+                    // We are in share_generics mode.\n+\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n+                        // This is a definition from the current crate. If the\n+                        // definition is unreachable for downstream crates or\n+                        // the current crate does not re-export generics, the\n+                        // definition of the instance will have been declared\n+                        // as `hidden`.\n+                        if cx.tcx.is_unreachable_local_definition(instance_def_id)\n+                            || !cx.tcx.local_crate_exports_generics()\n+                        {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a monomorphization of a generic function\n+                        // defined in an upstream crate.\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n+                            // This is instantiated in another crate. It cannot\n+                            // be `hidden`.\n+                        } else {\n+                            // This is a local instantiation of an upstream definition.\n+                            // If the current crate does not re-export it\n+                            // (because it is a C library or an executable), it\n+                            // will have been declared `hidden`.\n+                            if !cx.tcx.local_crate_exports_generics() {\n+                                #[cfg(feature=\"master\")]\n+                                func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // When not sharing generics, all instances are in the same\n+                    // crate and have hidden visibility\n+                    #[cfg(feature=\"master\")]\n+                    func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                }\n+            } else {\n+                // This is a non-generic function\n+                if cx.tcx.is_codegened_item(instance_def_id) {\n+                    // This is a function that is instantiated in the local crate\n+\n+                    if instance_def_id.is_local() {\n+                        // This is function that is defined in the local crate.\n+                        // If it is not reachable, it is hidden.\n+                        if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a function from an upstream crate that has\n+                        // been instantiated here. These are always hidden.\n+                        #[cfg(feature=\"master\")]\n+                        func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                    }\n+                }\n+            }\n+\n             // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n             unsafe { std::mem::transmute(func) }\n         };"}, {"sha": "d0d6b9b5bfe3c0a9ffe2da0fe88e772add23dbf9", "filename": "src/mono_item.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/672eec3055c9c96420987dba18cf12aafaf7e3d6/src%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmono_item.rs?ref=672eec3055c9c96420987dba18cf12aafaf7e3d6", "patch": "@@ -1,30 +1,36 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{VarAttribute, FnAttribute};\n use rustc_codegen_ssa::traits::PreDefineMethods;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n-use rustc_span::def_id::DefId;\n \n use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n+        #[cfg(feature=\"master\")]\n+        global.add_attribute(VarAttribute::Visibility(base::visibility_to_gcc(visibility)));\n \n-        // TODO(antoyo): set linkage and visibility.\n+        // TODO(antoyo): set linkage.\n         self.instances.borrow_mut().insert(instance, global);\n     }\n \n-    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         assert!(!instance.substs.needs_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n@@ -34,6 +40,22 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n         attributes::from_fn_attrs(self, decl, instance);\n \n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != Linkage::Internal\n+            && linkage != Linkage::Private\n+            && self.tcx.is_compiler_builtins(LOCAL_CRATE)\n+        {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+        }\n+        else {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(base::visibility_to_gcc(visibility)));\n+        }\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above."}]}