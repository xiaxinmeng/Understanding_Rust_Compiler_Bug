{"sha": "b2c8719341edaade2d8ccccf8e3db7ef4c208ca5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyYzg3MTkzNDFlZGFhZGUyZDhjY2NjZjhlM2RiN2VmNGMyMDhjYTU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-25T22:35:53Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-28T05:25:50Z"}, "message": "save-analysis: move another couple of things to the API", "tree": {"sha": "b1a61a4ce92695b53e09995d9e05306fb286c7cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1a61a4ce92695b53e09995d9e05306fb286c7cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5", "html_url": "https://github.com/rust-lang/rust/commit/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6770253c67979012295a2e6ec8be18567ac674f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6770253c67979012295a2e6ec8be18567ac674f7", "html_url": "https://github.com/rust-lang/rust/commit/6770253c67979012295a2e6ec8be18567ac674f7"}], "stats": {"total": 149, "additions": 109, "deletions": 40}, "files": [{"sha": "5c630533ec33d6a8e2c93445f4bf4a86d28004cd", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=b2c8719341edaade2d8ccccf8e3db7ef4c208ca5", "patch": "@@ -508,7 +508,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             self.process_formals(&decl.inputs, &fn_data.qualname);\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n         } else {\n-            unreachable!();\n+            self.sess.span_bug(item.span, \"expected FunctionData\");\n         }\n \n         for arg in &decl.inputs {\n@@ -538,7 +538,7 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                 &var_data.type_value,\n                                 var_data.scope);\n         } else {\n-            unreachable!();\n+            self.sess.span_bug(item.span, \"expected VariableData\");\n         }\n \n         self.visit_ty(&typ);\n@@ -768,22 +768,18 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn process_mod(&mut self,\n-                   item: &ast::Item,  // The module in question, represented as an item.\n-                   m: &ast::Mod) {\n-        let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n-\n-        let cm = self.sess.codemap();\n-        let filename = cm.span_to_filename(m.inner);\n-\n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Mod);\n-        self.fmt.mod_str(item.span,\n-                         sub_span,\n-                         item.id,\n-                         &qualname[..],\n-                         self.cur_scope,\n-                         &filename[..]);\n-\n-        self.nest(item.id, |v| visit::walk_mod(v, m));\n+                   item: &ast::Item) {  // The module in question, represented as an item.\n+        let mod_data = self.save_ctxt.get_item_data(item);\n+        if let super::Data::ModData(mod_data) = mod_data {\n+            self.fmt.mod_str(item.span,\n+                             Some(mod_data.span),\n+                             mod_data.id,\n+                             &mod_data.qualname,\n+                             mod_data.scope,\n+                             &mod_data.filename);\n+        } else {\n+            self.sess.span_bug(item.span, \"expected ModData\");\n+        }\n     }\n \n     fn process_path(&mut self,\n@@ -1188,7 +1184,10 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             }\n             ast::ItemTrait(_, ref generics, ref trait_refs, ref methods) =>\n                 self.process_trait(item, generics, trait_refs, methods),\n-            ast::ItemMod(ref m) => self.process_mod(item, m),\n+            ast::ItemMod(ref m) => {\n+                self.process_mod(item);\n+                self.nest(item.id, |v| visit::walk_mod(v, m));\n+            }\n             ast::ItemTy(ref ty, ref ty_params) => {\n                 let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n                 let value = ty_to_string(&**ty);\n@@ -1295,30 +1294,22 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n             ast::ExprStruct(ref path, ref fields, ref base) =>\n                 self.process_struct_lit(ex, path, fields, base),\n             ast::ExprMethodCall(_, _, ref args) => self.process_method_call(ex, args),\n-            ast::ExprField(ref sub_ex, ident) => {\n+            ast::ExprField(ref sub_ex, _) => {\n                 if generated_code(sub_ex.span) {\n                     return\n                 }\n \n-                self.visit_expr(&**sub_ex);\n-                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &**sub_ex).sty;\n-                match *ty {\n-                    ty::ty_struct(def_id, _) => {\n-                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n-                        for f in &fields {\n-                            if f.name == ident.node.name {\n-                                let sub_span = self.span.span_for_last_ident(ex.span);\n-                                self.fmt.ref_str(recorder::VarRef,\n-                                                 ex.span,\n-                                                 sub_span,\n-                                                 f.id,\n-                                                 self.cur_scope);\n-                                break;\n-                            }\n-                        }\n-                    }\n-                    _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct type, found {:?}\", ty)),\n+                self.visit_expr(&sub_ex);\n+\n+                let field_data = self.save_ctxt.get_expr_data(ex);\n+                if let super::Data::VariableRefData(field_data) = field_data {\n+                    self.fmt.ref_str(recorder::VarRef,\n+                                     ex.span,\n+                                     Some(field_data.span),\n+                                     field_data.ref_id,\n+                                     field_data.scope);\n+                } else {\n+                    self.sess.span_bug(ex.span, \"expected VariableRefData\");\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {"}, {"sha": "27297d8aa8d94c6840294a17de32b070809162d2", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b2c8719341edaade2d8ccccf8e3db7ef4c208ca5/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=b2c8719341edaade2d8ccccf8e3db7ef4c208ca5", "patch": "@@ -49,6 +49,12 @@ pub enum Data {\n     FunctionData(FunctionData),\n     /// Data for local and global variables (consts and statics).\n     VariableData(VariableData),\n+    /// Data for modules.\n+    ModData(ModData),\n+\n+    /// Data for the use of some variable (e.g., the use of a local variable, which\n+    /// will refere to that variables declaration).\n+    VariableRefData(VariableRefData),\n }\n \n /// Data for all kinds of functions and methods.\n@@ -72,6 +78,26 @@ pub struct VariableData {\n     pub type_value: String,\n }\n \n+/// Data for modules.\n+pub struct ModData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub filename: String,\n+}\n+\n+/// Data for the use of some item (e.g., the use of a local variable, which\n+/// will refere to that variables declaration (by ref_id)).\n+pub struct VariableRefData {\n+    pub name: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n+\n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn new(sess: &'l Session,\n                analysis: &'l ty::CrateAnalysis<'tcx>,\n@@ -97,7 +123,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_item_data(&self, item: &ast::Item) -> Data {\n         match item.node {\n-            ast::Item_::ItemFn(..) => {\n+            ast::ItemFn(..) => {\n                 let name = self.analysis.ty_cx.map.path_to_string(item.id);\n                 let qualname = format!(\"::{}\", name);\n                 let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Fn);\n@@ -146,6 +172,58 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     type_value: ty_to_string(&typ),\n                 })\n             }\n+            ast::ItemMod(ref m) => {\n+                let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n+\n+                let cm = self.sess.codemap();\n+                let filename = cm.span_to_filename(m.inner);\n+\n+                let sub_span = self.span_utils.sub_span_after_keyword(item.span, keywords::Mod);\n+\n+                Data::ModData(ModData {\n+                    id: item.id,\n+                    name: get_ident(item.ident).to_string(),\n+                    qualname: qualname,\n+                    span: sub_span.unwrap(),\n+                    scope: self.analysis.ty_cx.map.get_parent(item.id),\n+                    filename: filename,\n+                })\n+            }\n+            _ => {\n+                // FIXME\n+                unimplemented!();\n+            }\n+        }\n+    }\n+\n+    pub fn get_expr_data(&self, expr: &ast::Expr) -> Data {\n+        match expr.node {\n+            ast::ExprField(ref sub_ex, ident) => {\n+                let ty = &ty::expr_ty_adjusted(&self.analysis.ty_cx, &sub_ex).sty;\n+                match *ty {\n+                    ty::ty_struct(def_id, _) => {\n+                        let fields = ty::lookup_struct_fields(&self.analysis.ty_cx, def_id);\n+                        for f in &fields {\n+                            if f.name == ident.node.name {\n+                                let sub_span = self.span_utils.span_for_last_ident(expr.span);\n+                                return Data::VariableRefData(VariableRefData {\n+                                    name: get_ident(ident.node).to_string(),\n+                                    span: sub_span.unwrap(),\n+                                    scope: self.analysis.ty_cx.map.get_parent(expr.id),\n+                                    ref_id: f.id,\n+                                });\n+                            }\n+                        }\n+\n+                        self.sess.span_bug(expr.span,\n+                                           &format!(\"Couldn't find field {} on {:?}\",\n+                                                    &get_ident(ident.node),\n+                                                    ty))\n+                    }\n+                    _ => self.sess.span_bug(expr.span,\n+                                            &format!(\"Expected struct type, found {:?}\", ty)),\n+                }\n+            }\n             _ => {\n                 // FIXME\n                 unimplemented!();"}]}