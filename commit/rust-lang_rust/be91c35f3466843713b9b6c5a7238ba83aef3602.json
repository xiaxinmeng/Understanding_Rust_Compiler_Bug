{"sha": "be91c35f3466843713b9b6c5a7238ba83aef3602", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlOTFjMzVmMzQ2Njg0MzcxM2I5YjZjNWE3MjM4YmE4M2FlZjM2MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T12:33:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T12:33:54Z"}, "message": "Auto merge of #54380 - RalfJung:miri-snapshot, r=eddyb\n\nmove CTFE engine snapshot state out of miri engine into CTFE machine instance\n\nIt still lives in the `interpret` module as it needs access to all sorts of private stuff. Also rename a thing to make @eddyb happy :D\n\nThe goal was not to change any behavior.", "tree": {"sha": "3c126bc90a1963cc0adc517c99cfcd019058525b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c126bc90a1963cc0adc517c99cfcd019058525b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be91c35f3466843713b9b6c5a7238ba83aef3602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be91c35f3466843713b9b6c5a7238ba83aef3602", "html_url": "https://github.com/rust-lang/rust/commit/be91c35f3466843713b9b6c5a7238ba83aef3602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be91c35f3466843713b9b6c5a7238ba83aef3602/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2287a7a6e293cfcb3bbbdaf3ce2dca5dd2d3184a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2287a7a6e293cfcb3bbbdaf3ce2dca5dd2d3184a", "html_url": "https://github.com/rust-lang/rust/commit/2287a7a6e293cfcb3bbbdaf3ce2dca5dd2d3184a"}, {"sha": "8e74ee0998a5b11f28d61600dbb881c7168a4a40", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e74ee0998a5b11f28d61600dbb881c7168a4a40", "html_url": "https://github.com/rust-lang/rust/commit/8e74ee0998a5b11f28d61600dbb881c7168a4a40"}], "stats": {"total": 600, "additions": 286, "deletions": 314}, "files": [{"sha": "ce18f31da6907f440a25a5772bf0fcdf8e000b50", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use rustc::mir::interpret::{ConstEvalErr, read_target_uint};\n-use rustc_mir::interpret::{const_field};\n+use rustc_mir::const_eval::const_field;\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "a169736d85310f94d5b7971f870b564dd5aa4cee", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -1612,7 +1612,7 @@ fn validate_const<'a, 'tcx>(\n     gid: ::rustc::mir::interpret::GlobalId<'tcx>,\n     what: &str,\n ) {\n-    let ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n+    let ecx = ::rustc_mir::const_eval::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n         let op = ecx.const_to_op(constant)?;\n         let mut todo = vec![(op, Vec::new())];"}, {"sha": "99a49122ef7e6171567106490040714cbc6e0641", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 78, "deletions": 27, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::IndexVec;\n \n use syntax::ast::Mutability;\n-use syntax::source_map::Span;\n+use syntax::source_map::{Span, DUMMY_SP};\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n@@ -31,17 +31,25 @@ use rustc::mir::interpret::{\n use interpret::{self,\n     Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n     EvalContext, StackPopCleanup, MemoryKind,\n+    snapshot,\n };\n \n+/// Number of steps until the detector even starts doing anything.\n+/// Also, a warning is shown to the user when this number is reached.\n+const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n+/// The number of steps between loop detector snapshots.\n+/// Should be a power of two for performance reasons.\n+const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n+\n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     span: Span,\n-) -> EvalResult<'tcx, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>> {\n+) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n     debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n     let param_env = tcx.param_env(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n     // insert a stack frame so any queries have the correct substs\n     ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n@@ -60,10 +68,10 @@ pub fn mk_eval_cx<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     instance: Instance<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, EvalContext<'a, 'tcx, 'tcx, CompileTimeEvaluator>> {\n+) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'tcx, 'tcx>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n     let span = tcx.def_span(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n     let mir = ecx.load_mir(instance.def)?;\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n@@ -76,19 +84,18 @@ pub fn mk_eval_cx<'a, 'tcx>(\n     Ok(ecx)\n }\n \n-pub fn eval_promoted<'a, 'mir, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n+pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    ecx.with_fresh_body(|ecx| {\n-        eval_body_using_ecx(ecx, cid, Some(mir), param_env)\n-    })\n+    let mut ecx = mk_borrowck_eval_cx(tcx, cid.instance, mir, DUMMY_SP).unwrap();\n+    eval_body_using_ecx(&mut ecx, cid, Some(mir), param_env)\n }\n \n pub fn op_to_const<'tcx>(\n-    ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n+    ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n     normalize: bool,\n ) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n@@ -128,19 +135,19 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, OpTy<'tcx>>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, OpTy<'tcx>>, CompileTimeEvalContext<'a, 'mir, 'tcx>) {\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n     let span = mir.map(|mir| mir.span).unwrap_or(span);\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n     let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n     (r, ecx)\n }\n \n // Returns a pointer to where the result lives\n-fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n+fn eval_body_using_ecx<'mir, 'tcx>(\n+    ecx: &mut CompileTimeEvalContext<'_, 'mir, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -187,17 +194,12 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     Ok(ret.into())\n }\n \n-#[derive(Debug, Clone, Eq, PartialEq, Hash)]\n-pub struct CompileTimeEvaluator;\n-\n impl<'tcx> Into<EvalError<'tcx>> for ConstEvalError {\n     fn into(self) -> EvalError<'tcx> {\n         EvalErrorKind::MachineError(self.to_string()).into()\n     }\n }\n \n-impl_stable_hash_for!(struct CompileTimeEvaluator {});\n-\n #[derive(Clone, Debug)]\n enum ConstEvalError {\n     NeedsRfc(String),\n@@ -234,14 +236,39 @@ impl Error for ConstEvalError {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n+// Extra machine state for CTFE, and the Machine instance\n+pub struct CompileTimeInterpreter<'a, 'mir, 'tcx: 'a+'mir> {\n+    /// When this value is negative, it indicates the number of interpreter\n+    /// steps *until* the loop detector is enabled. When it is positive, it is\n+    /// the number of steps after the detector has been enabled modulo the loop\n+    /// detector period.\n+    pub(super) steps_since_detector_enabled: isize,\n+\n+    /// Extra state to detect loops.\n+    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'a, 'mir, 'tcx>,\n+}\n+\n+impl<'a, 'mir, 'tcx> CompileTimeInterpreter<'a, 'mir, 'tcx> {\n+    fn new() -> Self {\n+        CompileTimeInterpreter {\n+            loop_detector: Default::default(),\n+            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n+        }\n+    }\n+}\n+\n+type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n+    EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n+\n+impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n+    for CompileTimeInterpreter<'a, 'mir, 'tcx>\n+{\n     type MemoryData = ();\n     type MemoryKinds = !;\n \n     const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n-    const DETECT_LOOPS: bool = true;\n \n-    fn find_fn<'a>(\n+    fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -275,7 +302,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         }))\n     }\n \n-    fn call_intrinsic<'a>(\n+    fn call_intrinsic(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -291,7 +318,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         )\n     }\n \n-    fn ptr_op<'a>(\n+    fn ptr_op(\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: Scalar,\n@@ -304,21 +331,45 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         )\n     }\n \n-    fn find_foreign_static<'a>(\n+    fn find_foreign_static(\n         _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         _def_id: DefId,\n     ) -> EvalResult<'tcx, &'tcx Allocation> {\n         err!(ReadForeignStatic)\n     }\n \n-    fn box_alloc<'a>(\n+    fn box_alloc(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n+\n+    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n+        {\n+            let steps = &mut ecx.machine.steps_since_detector_enabled;\n+\n+            *steps += 1;\n+            if *steps < 0 {\n+                return Ok(());\n+            }\n+\n+            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n+            if *steps != 0 {\n+                return Ok(());\n+            }\n+        }\n+\n+        let span = ecx.frame().span;\n+        ecx.machine.loop_detector.observe_and_analyze(\n+            &ecx.tcx,\n+            span,\n+            &ecx.memory,\n+            &ecx.stack[..],\n+        )\n+    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "c72f87836855036ed8f0fbbca97a6fd39c0c8e21", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -16,7 +16,7 @@ mod check_match;\n pub use self::check_match::check_crate;\n pub(crate) use self::check_match::check_match;\n \n-use interpret::{const_field, const_variant_index};\n+use const_eval::{const_field, const_variant_index};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};"}, {"sha": "c6b527f42294c1134535272da53f0774ca17338b", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -21,7 +21,7 @@ use rustc_apfloat::Float;\n \n use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "6cbe8065c7e2453517313130bd5e0dd09d427df3", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 20, "deletions": 89, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -14,7 +14,6 @@ use std::mem;\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n-use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n@@ -23,7 +22,6 @@ use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc::mir::interpret::{\n     GlobalId, Scalar, FrameInfo, AllocId,\n     EvalResult, EvalErrorKind,\n@@ -38,36 +36,21 @@ use super::{\n     Memory, Machine\n };\n \n-use super::snapshot::InfiniteLoopDetector;\n-\n-pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n     /// The results of the type checker, from rustc.\n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n \n     /// Bounds in scope for polymorphic evaluations.\n-    pub param_env: ty::ParamEnv<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n \n     /// The virtual memory system.\n     pub memory: Memory<'a, 'mir, 'tcx, M>,\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n-\n-    /// The maximum number of stack frames allowed\n-    pub(super) stack_limit: usize,\n-\n-    /// When this value is negative, it indicates the number of interpreter\n-    /// steps *until* the loop detector is enabled. When it is positive, it is\n-    /// the number of steps after the detector has been enabled modulo the loop\n-    /// detector period.\n-    pub(super) steps_since_detector_enabled: isize,\n-\n-    /// Extra state to detect loops.\n-    /// FIXME: Move this to the CTFE machine's state, out of the general miri engine.\n-    pub(super) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n /// A stack frame.\n@@ -112,29 +95,6 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub stmt: usize,\n }\n \n-// Not using the macro because that does not support types depending on 'tcx\n-impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>) {\n-\n-        let Frame {\n-            mir,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-        } = self;\n-\n-        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n-        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n-    }\n-}\n-\n #[derive(Clone, Debug, Eq, PartialEq, Hash)]\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n@@ -147,21 +107,6 @@ pub enum StackPopCleanup {\n     None { cleanup: bool },\n }\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self,\n-        hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n-            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n-        }\n-    }\n-}\n-\n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue<Id=AllocId> {\n@@ -189,19 +134,16 @@ impl<'tcx> LocalValue {\n     }\n }\n \n-impl_stable_hash_for!(enum self::LocalValue {\n-    Dead,\n-    Live(x),\n-});\n-\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n+    for &'b EvalContext<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n     for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n@@ -210,24 +152,27 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'a EvalContext<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n+impl<'b, 'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for &'b EvalContext<'a, 'mir, 'tcx, M>\n+    where M: Machine<'a, 'mir, 'tcx>\n {\n     #[inline]\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+    fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n         *self.tcx\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> layout::HasTyCtxt<'tcx>\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn tcx<'d>(&'d self) -> TyCtxt<'d, 'tcx, 'tcx> {\n         *self.tcx\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for &'a EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n+    for &'b EvalContext<'a, 'mir, 'tcx, M>\n+{\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n@@ -238,8 +183,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for &'a EvalContext<'a, 'm\n     }\n }\n \n-impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n-    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n+    for &'c &'b mut EvalContext<'a, 'mir, 'tcx, M>\n+{\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n \n@@ -249,9 +195,7 @@ impl<'c, 'b, 'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf\n     }\n }\n \n-const STEPS_UNTIL_DETECTOR_ENABLED: isize = 1_000_000;\n-\n-impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -264,22 +208,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             param_env,\n             memory: Memory::new(tcx, memory_data),\n             stack: Vec::new(),\n-            stack_limit: tcx.sess.const_eval_stack_frame_limit,\n-            loop_detector: Default::default(),\n-            steps_since_detector_enabled: -STEPS_UNTIL_DETECTOR_ENABLED,\n         }\n     }\n \n-    pub(crate) fn with_fresh_body<F: FnOnce(&mut Self) -> R, R>(&mut self, f: F) -> R {\n-        let stack = mem::replace(&mut self.stack, Vec::new());\n-        let steps = mem::replace(&mut self.steps_since_detector_enabled,\n-                                 -STEPS_UNTIL_DETECTOR_ENABLED);\n-        let r = f(self);\n-        self.stack = stack;\n-        self.steps_since_detector_enabled = steps;\n-        r\n-    }\n-\n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n@@ -553,7 +484,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n             self.frame_mut().locals = locals;\n         }\n \n-        if self.stack.len() > self.stack_limit {\n+        if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n             err!(StackFrameLimitReached)\n         } else {\n             Ok(())"}, {"sha": "d2f274231c17049806e69b1ac1a26e4735fc510d", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -46,7 +46,7 @@ fn numeric_intrinsic<'tcx>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Returns whether emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "1eb0280409527cec262f2bcf527bfde73c5d829a", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -20,20 +20,22 @@ use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n-/// and some use case dependent behaviour can instead be applied\n-pub trait Machine<'mir, 'tcx>: Clone + Eq {\n+/// and some use case dependent behaviour can instead be applied.\n+/// FIXME: We should be able to get rid of the 'a here if we can get rid of the 'a in\n+/// `snapshot::EvalSnapshot`.\n+pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n-    type MemoryData: Clone + Eq;\n+    type MemoryData;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq;\n+    type MemoryKinds: ::std::fmt::Debug + Copy + Eq;\n \n     /// The memory kind to use for mutated statics -- or None if those are not supported.\n     const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n-    /// Whether to attempt to detect infinite loops (any kind of infinite\n-    /// execution, really).\n-    const DETECT_LOOPS: bool;\n+    /// Called before a basic block terminator is executed.\n+    /// You can use this to detect endlessly running programs.\n+    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -45,7 +47,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// nor just jump to `ret`, but instead push their own stack frame.)\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n-    fn find_fn<'a>(\n+    fn find_fn(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -55,7 +57,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n \n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n-    fn call_intrinsic<'a>(\n+    fn call_intrinsic(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n@@ -66,7 +68,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// This can be called multiple times for the same static item and should return consistent\n     /// results.  Once the item is *written* the first time, as usual for statics a copy is\n     /// made and this function is not called again.\n-    fn find_foreign_static<'a>(\n+    fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n     ) -> EvalResult<'tcx, &'tcx Allocation>;\n@@ -75,7 +77,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n-    fn ptr_op<'a>(\n+    fn ptr_op(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n@@ -87,13 +89,13 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq {\n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory\n-    fn box_alloc<'a>(\n+    fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx>;\n \n     /// Execute a validation operation\n-    fn validation_op<'a>(\n+    fn validation_op(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,\n         _operand: &::rustc::mir::ValidationOperand<'tcx, ::rustc::mir::Place<'tcx>>,"}, {"sha": "b5eb06b82ff75b180bea4904d2e624abeaa30ec5", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -39,8 +39,9 @@ pub enum MemoryKind<T> {\n     Machine(T),\n }\n \n-#[derive(Clone)]\n-pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+// `Memory` has to depend on the `Machine` because some of its operations\n+// (e.g. `get`) call a `Machine` hook.\n+pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n@@ -56,16 +57,19 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// that do not exist any more.\n     dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n-    pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    /// Lets us implement `HasDataLayout`, which is awfully convenient.\n+    pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n+impl<'b, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n+    for &'b Memory<'a, 'mir, 'tcx, M>\n+{\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n-impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n+impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n     for &'b &'c mut Memory<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n@@ -74,7 +78,23 @@ impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+// FIXME: Really we shouldnt clone memory, ever. Snapshot machinery should instad\n+// carefully copy only the reachable parts.\n+impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n+    Clone for Memory<'a, 'mir, 'tcx, M>\n+    where M::MemoryData: Clone\n+{\n+    fn clone(&self) -> Self {\n+        Memory {\n+            data: self.data.clone(),\n+            alloc_map: self.alloc_map.clone(),\n+            dead_alloc_map: self.dead_alloc_map.clone(),\n+            tcx: self.tcx,\n+        }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n@@ -279,7 +299,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Helper function to obtain the global (tcx) allocation for a static\n     fn get_static_alloc(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n@@ -491,7 +511,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Byte accessors\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes.  You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n@@ -564,7 +584,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Reading and writing\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn intern_static(\n         &mut self,\n@@ -877,7 +897,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Relocations\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     /// Return all relocations overlapping with the given ptr-offset pair.\n     fn relocations(\n         &self,\n@@ -950,7 +970,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Undefined bytes\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(\n         &mut self,"}, {"sha": "6f07c2996b9cb72f0fddd273c009fd530845a7b7", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -17,7 +17,7 @@ mod operand;\n mod machine;\n mod memory;\n mod operator;\n-mod snapshot;\n+pub(crate) mod snapshot; // for const_eval\n mod step;\n mod terminator;\n mod traits;\n@@ -35,16 +35,3 @@ pub use self::memory::{Memory, MemoryKind};\n pub use self::machine::Machine;\n \n pub use self::operand::{Value, ValTy, Operand, OpTy};\n-\n-// reexports for compatibility\n-pub use const_eval::{\n-    eval_promoted,\n-    mk_borrowck_eval_cx,\n-    mk_eval_cx,\n-    CompileTimeEvaluator,\n-    const_to_allocation_provider,\n-    const_eval_provider,\n-    const_field,\n-    const_variant_index,\n-    op_to_const,\n-};"}, {"sha": "a11150c47836e11bc11c591c326cfe132eb48c1f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -82,11 +82,6 @@ impl<'tcx> Value {\n     }\n }\n \n-impl_stable_hash_for!(enum ::interpret::Value {\n-    Scalar(x),\n-    ScalarPair(x, y),\n-});\n-\n // ScalarPair needs a type to interpret, so we often have a value and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n@@ -132,11 +127,6 @@ impl Operand {\n     }\n }\n \n-impl_stable_hash_for!(enum ::interpret::Operand {\n-    Immediate(x),\n-    Indirect(x),\n-});\n-\n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n     crate op: Operand, // ideally we'd make this private, but const_prop needs this\n@@ -206,7 +196,7 @@ fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Try reading a value in memory; this is interesting particularily for ScalarPair.\n     /// Return None if the layout does not permit loading this as a value.\n     pub(super) fn try_read_value_from_mplace("}, {"sha": "dd6ee374c0facc9f4b4370f5577fb62f8c7b6636", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -18,7 +18,7 @@ use rustc::mir::interpret::{EvalResult, Scalar};\n use super::{EvalContext, PlaceTy, Value, Machine, ValTy};\n \n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -47,7 +47,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "27765558258b3ab1f214a9433f179d7d005d9285", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -13,13 +13,10 @@\n //! All high-level functions to write to memory work on places as destinations.\n \n use std::convert::TryFrom;\n-use std::mem;\n \n-use rustc::ich::StableHashingContext;\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n \n use rustc::mir::interpret::{\n     GlobalId, AllocId, Scalar, EvalResult, Pointer, ScalarMaybeUndef, PointerArithmetic\n@@ -39,12 +36,6 @@ pub struct MemPlace<Id=AllocId> {\n     pub extra: Option<Scalar<Id>>,\n }\n \n-impl_stable_hash_for!(struct ::interpret::MemPlace {\n-    ptr,\n-    align,\n-    extra,\n-});\n-\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place<Id=AllocId> {\n     /// A place referring to a value allocated in the `Memory` system.\n@@ -58,23 +49,6 @@ pub enum Place<Id=AllocId> {\n     },\n }\n \n-// Can't use the macro here because that does not support named enum fields.\n-impl<'a> HashStable<StableHashingContext<'a>> for Place {\n-    fn hash_stable<W: StableHasherResult>(\n-        &self, hcx: &mut StableHashingContext<'a>,\n-        hasher: &mut StableHasher<W>)\n-    {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match self {\n-            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n-\n-            Place::Local { frame, local } => {\n-                frame.hash_stable(hcx, hasher);\n-                local.hash_stable(hcx, hasher);\n-            },\n-        }\n-    }\n-}\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx> {\n     place: Place,\n@@ -255,7 +229,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n     pub fn ref_to_mplace("}, {"sha": "18ca284811080625e20397f26a8a8e3bf52fa0f6", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 117, "deletions": 62, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -2,7 +2,11 @@\n //! during const-evaluation by taking snapshots of the state of the interpreter\n //! at regular intervals.\n \n+// This lives in `interpret` because it needs access to all sots of private state.  However,\n+// it is not used by the general miri engine, just by CTFE.\n+\n use std::hash::{Hash, Hasher};\n+use std::mem;\n \n use rustc::ich::{StableHashingContext, StableHashingContextProvider};\n use rustc::mir;\n@@ -21,9 +25,11 @@ use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n use super::eval_context::{LocalValue, StackPopCleanup};\n-use super::{Frame, Memory, Machine, Operand, MemPlace, Place, Value};\n+use super::{Frame, Memory, Operand, MemPlace, Place, Value};\n+use const_eval::CompileTimeInterpreter;\n \n-pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+#[derive(Default)]\n+pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n     /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n@@ -35,47 +41,36 @@ pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mi\n     /// An `EvalSnapshot` will only be fully cloned once it has caused a\n     /// collision in `hashes`. As a result, the detector must observe at least\n     /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx, M>>,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Default for InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n-{\n-    fn default() -> Self {\n-        InfiniteLoopDetector {\n-            hashes: FxHashSet::default(),\n-            snapshots: FxHashSet::default(),\n-        }\n-    }\n+    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-          'tcx: 'a + 'mir,\n+impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n {\n-    /// Returns `true` if the loop detector has not yet observed a snapshot.\n-    pub fn is_empty(&self) -> bool {\n-        self.hashes.is_empty()\n-    }\n-\n-    pub fn observe_and_analyze(\n+    pub fn observe_and_analyze<'b>(\n         &mut self,\n         tcx: &TyCtxt<'b, 'tcx, 'tcx>,\n-        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        span: Span,\n+        memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>],\n     ) -> EvalResult<'tcx, ()> {\n-\n+        // Compute stack's hash before copying anything\n         let mut hcx = tcx.get_stable_hashing_context();\n         let mut hasher = StableHasher::<u64>::new();\n         stack.hash_stable(&mut hcx, &mut hasher);\n         let hash = hasher.finish();\n \n+        // Check if we know that hash already\n+        if self.hashes.is_empty() {\n+            // FIXME(#49980): make this warning a lint\n+            tcx.sess.span_warn(span,\n+                \"Constant evaluating a complex constant, this might take some time\");\n+        }\n         if self.hashes.insert(hash) {\n             // No collision\n             return Ok(())\n         }\n \n+        // We need to make a full copy. NOW things that to get really expensive.\n         info!(\"snapshotting the state of the interpreter\");\n \n         if self.snapshots.insert(EvalSnapshot::new(memory, stack)) {\n@@ -179,7 +174,7 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n \n impl_snapshot_for!(struct Pointer {\n     alloc_id,\n-    offset -> *offset,\n+    offset -> *offset, // just copy offset verbatim\n });\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n@@ -203,12 +198,34 @@ impl_snapshot_for!(enum ScalarMaybeUndef {\n     Undef,\n });\n \n+impl_stable_hash_for!(struct ::interpret::MemPlace {\n+    ptr,\n+    align,\n+    extra,\n+});\n impl_snapshot_for!(struct MemPlace {\n     ptr,\n     extra,\n-    align -> *align,\n+    align -> *align, // just copy alignment verbatim\n });\n \n+// Can't use the macro here because that does not support named enum fields.\n+impl<'a> HashStable<StableHashingContext<'a>> for Place {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self, hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>)\n+    {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            Place::Ptr(mem_place) => mem_place.hash_stable(hcx, hasher),\n+\n+            Place::Local { frame, local } => {\n+                frame.hash_stable(hcx, hasher);\n+                local.hash_stable(hcx, hasher);\n+            },\n+        }\n+    }\n+}\n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -226,16 +243,28 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     }\n }\n \n+impl_stable_hash_for!(enum ::interpret::Value {\n+    Scalar(x),\n+    ScalarPair(x, y),\n+});\n impl_snapshot_for!(enum Value {\n     Scalar(s),\n     ScalarPair(s, t),\n });\n \n+impl_stable_hash_for!(enum ::interpret::Operand {\n+    Immediate(x),\n+    Indirect(x),\n+});\n impl_snapshot_for!(enum Operand {\n     Immediate(v),\n     Indirect(m),\n });\n \n+impl_stable_hash_for!(enum ::interpret::LocalValue {\n+    Dead,\n+    Live(x),\n+});\n impl_snapshot_for!(enum LocalValue {\n     Live(v),\n     Dead,\n@@ -280,6 +309,21 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     }\n }\n \n+// Can't use the macro here because that does not support named enum fields.\n+impl<'a> HashStable<StableHashingContext<'a>> for StackPopCleanup {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>)\n+    {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match self {\n+            StackPopCleanup::Goto(ref block) => block.hash_stable(hcx, hasher),\n+            StackPopCleanup::None { cleanup } => cleanup.hash_stable(hcx, hasher),\n+        }\n+    }\n+}\n+\n #[derive(Eq, PartialEq)]\n struct FrameSnapshot<'a, 'tcx: 'a> {\n     instance: &'a ty::Instance<'tcx>,\n@@ -291,6 +335,28 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     stmt: usize,\n }\n \n+// Not using the macro because that does not support types depending on two lifetimes\n+impl<'a, 'mir, 'tcx: 'mir> HashStable<StableHashingContext<'a>> for Frame<'mir, 'tcx> {\n+    fn hash_stable<W: StableHasherResult>(\n+        &self,\n+        hcx: &mut StableHashingContext<'a>,\n+        hasher: &mut StableHasher<W>) {\n+\n+        let Frame {\n+            mir,\n+            instance,\n+            span,\n+            return_to_block,\n+            return_place,\n+            locals,\n+            block,\n+            stmt,\n+        } = self;\n+\n+        (mir, instance, span, return_to_block).hash_stable(hcx, hasher);\n+        (return_place, locals, block, stmt).hash_stable(hcx, hasher);\n+    }\n+}\n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     where Ctx: SnapshotContext<'a>,\n {\n@@ -320,39 +386,26 @@ impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n     }\n }\n \n-#[derive(Eq, PartialEq)]\n-struct MemorySnapshot<'a, 'mir: 'a, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx> + 'a> {\n-    data: &'a M::MemoryData,\n-}\n-\n-impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n-{\n-    fn snapshot<'b: 'a>(&'b self) -> MemorySnapshot<'b, 'mir, 'tcx, M> {\n-        let Memory { data, .. } = self;\n-        MemorySnapshot { data }\n-    }\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx, M> SnapshotContext<'b> for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n+    for Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>\n {\n     fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n         self.get(*id).ok()\n     }\n }\n \n /// The virtual machine state during const-evaluation at a given point in time.\n-struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    memory: Memory<'a, 'mir, 'tcx, M>,\n+/// We assume the `CompileTimeInterpreter` has no interesting extra state that\n+/// is worth considering here.\n+struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n+    memory: Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx: 'a + 'mir> EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn new(\n-        memory: &Memory<'a, 'mir, 'tcx, M>,\n+        memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>]\n     ) -> Self {\n         EvalSnapshot {\n@@ -361,16 +414,17 @@ impl<'a, 'mir, 'tcx, M> EvalSnapshot<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    fn snapshot<'b: 'a>(&'b self)\n-        -> (MemorySnapshot<'b, 'mir, 'tcx, M>, Vec<FrameSnapshot<'a, 'tcx>>)\n+    // Used to compare two snapshots\n+    fn snapshot(&'b self)\n+        -> Vec<FrameSnapshot<'b, 'tcx>>\n     {\n-        let EvalSnapshot{ memory, stack } = self;\n-        (memory.snapshot(), stack.iter().map(|frame| frame.snapshot(memory)).collect())\n+        // Start with the stack, iterate and recursively snapshot\n+        self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n     }\n+\n }\n \n-impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n@@ -383,28 +437,29 @@ impl<'a, 'mir, 'tcx, M> Hash for EvalSnapshot<'a, 'mir, 'tcx, M>\n \n // Not using the macro because we need special handling for `memory`, which the macro\n // does not support at the same time as the extra bounds on the type.\n-impl<'a, 'b, 'mir, 'tcx, M> HashStable<StableHashingContext<'b>>\n-    for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'b, 'mir, 'tcx> HashStable<StableHashingContext<'b>>\n+    for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'b>,\n         hasher: &mut StableHasher<W>)\n     {\n+        // Not hashing memory: Avoid hashing memory all the time during execution\n         let EvalSnapshot{ memory: _, stack } = self;\n         stack.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> Eq for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n {}\n \n-impl<'a, 'mir, 'tcx, M> PartialEq for EvalSnapshot<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>,\n+impl<'a, 'mir, 'tcx> PartialEq for EvalSnapshot<'a, 'mir, 'tcx>\n {\n     fn eq(&self, other: &Self) -> bool {\n+        // FIXME: This looks to be a *ridicolously expensive* comparison operation.\n+        // Doesn't this make tons of copies?  Either `snapshot` is very badly named,\n+        // or it does!\n         self.snapshot() == other.snapshot()\n     }\n }"}, {"sha": "d5e87154480256b99a521da1df89a81c1f163ab0", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -45,45 +45,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn inc_step_counter_and_detect_loops(&mut self) -> EvalResult<'tcx, ()> {\n-        /// The number of steps between loop detector snapshots.\n-        /// Should be a power of two for performance reasons.\n-        const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n-\n-        {\n-            let steps = &mut self.steps_since_detector_enabled;\n-\n-            *steps += 1;\n-            if *steps < 0 {\n-                return Ok(());\n-            }\n-\n-            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n-            if *steps != 0 {\n-                return Ok(());\n-            }\n-        }\n-\n-        if !M::DETECT_LOOPS {\n-            return Ok(());\n-        }\n-\n-        if self.loop_detector.is_empty() {\n-            // First run of the loop detector\n-\n-            // FIXME(#49980): make this warning a lint\n-            self.tcx.sess.span_warn(self.frame().span,\n-                \"Constant evaluating a complex constant, this might take some time\");\n-        }\n-\n-        self.loop_detector.observe_and_analyze(\n-            &self.tcx,\n-            &self.memory,\n-            &self.stack[..],\n-        )\n-    }\n-\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn run(&mut self) -> EvalResult<'tcx> {\n         while self.step()? {}\n         Ok(())\n@@ -108,7 +70,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             return Ok(true);\n         }\n \n-        self.inc_step_counter_and_detect_loops()?;\n+        M::before_terminator(self)?;\n \n         let terminator = basic_block.terminator();\n         assert_eq!(old_frames, self.cur_frame());"}, {"sha": "c7ed69e0cb66d882a01ba78fc599b96d9bc675ba", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -20,7 +20,7 @@ use super::{\n     EvalContext, Machine, Value, OpTy, Place, PlaceTy, Operand, StackPopCleanup\n };\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "5ea588b957a4ffed98f4a25d3424e301b2d1f2a4", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -16,7 +16,7 @@ use syntax::ast::Mutability;\n \n use super::{EvalContext, Machine, MemoryKind};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "f816983ab47a2bbb37c0c4cfe972d92d0a411d7e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -95,7 +95,7 @@ fn path_format(path: &Vec<PathElem>) -> String {\n     out\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn validate_scalar(\n         &self,\n         value: ScalarMaybeUndef,"}, {"sha": "4546e0bf253c37c133eeed9d2fd7eb1aac80e320", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -95,7 +95,7 @@ pub fn provide(providers: &mut Providers) {\n     borrow_check::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n-    providers.const_eval = interpret::const_eval_provider;\n+    providers.const_eval = const_eval::const_eval_provider;\n     providers.check_match = hair::pattern::check_match;\n }\n "}, {"sha": "e2a6cee0549708f6c314b8d1a465a2aab2c987a0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be91c35f3466843713b9b6c5a7238ba83aef3602/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=be91c35f3466843713b9b6c5a7238ba83aef3602", "patch": "@@ -21,8 +21,8 @@ use rustc::mir::interpret::{\n     ConstEvalErr, EvalErrorKind, ScalarMaybeUndef, Scalar, GlobalId, EvalResult\n };\n use rustc::ty::{TyCtxt, self, Instance};\n-use interpret::{EvalContext, CompileTimeEvaluator, eval_promoted, mk_borrowck_eval_cx};\n-use interpret::{self, Value, OpTy, MemoryKind};\n+use interpret::{self, EvalContext, Value, OpTy, MemoryKind};\n+use const_eval::{CompileTimeInterpreter, eval_promoted, mk_borrowck_eval_cx};\n use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n@@ -68,9 +68,9 @@ impl MirPass for ConstProp {\n type Const<'tcx> = (OpTy<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n-struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n-    ecx: EvalContext<'a, 'b, 'tcx, CompileTimeEvaluator>,\n-    mir: &'b Mir<'tcx>,\n+struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n+    ecx: EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    mir: &'mir Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n@@ -101,12 +101,12 @@ impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for &'a ConstPropagator<'a, 'b, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n+impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn new(\n-        mir: &'b Mir<'tcx>,\n+        mir: &'mir Mir<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         source: MirSource,\n-    ) -> ConstPropagator<'b, 'a, 'tcx> {\n+    ) -> ConstPropagator<'a, 'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id);\n         let substs = Substs::identity_for_item(tcx, source.def_id);\n         let instance = Instance::new(source.def_id, substs);\n@@ -310,7 +310,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n                 let res = self.use_ecx(source_info, |this| {\n-                    eval_promoted(&mut this.ecx, cid, this.mir, this.param_env)\n+                    eval_promoted(this.tcx, cid, this.mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n                 Some((res, source_info.span))"}]}