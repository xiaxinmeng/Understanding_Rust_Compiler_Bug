{"sha": "7c8f5457d26055b26210fdd69c5ded1ecdde144a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOGY1NDU3ZDI2MDU1YjI2MjEwZmRkNjljNWRlZDFlY2RkZTE0NGE=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-28T09:29:54Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-09-05T04:28:52Z"}, "message": "Undo unnecessary bookkeeping from last commit", "tree": {"sha": "e077eab5ac939203ce229f7251dbdb02fb98fcd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e077eab5ac939203ce229f7251dbdb02fb98fcd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c8f5457d26055b26210fdd69c5ded1ecdde144a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8f5457d26055b26210fdd69c5ded1ecdde144a", "html_url": "https://github.com/rust-lang/rust/commit/7c8f5457d26055b26210fdd69c5ded1ecdde144a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c8f5457d26055b26210fdd69c5ded1ecdde144a/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "180534f398b18aea5d7740153eab026074396013", "url": "https://api.github.com/repos/rust-lang/rust/commits/180534f398b18aea5d7740153eab026074396013", "html_url": "https://github.com/rust-lang/rust/commit/180534f398b18aea5d7740153eab026074396013"}], "stats": {"total": 26, "additions": 9, "deletions": 17}, "files": [{"sha": "c67b98761aa6ed50bbe10aba761117fdf82647ab", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7c8f5457d26055b26210fdd69c5ded1ecdde144a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8f5457d26055b26210fdd69c5ded1ecdde144a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7c8f5457d26055b26210fdd69c5ded1ecdde144a", "patch": "@@ -420,13 +420,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => result_ty\n         };\n \n-        let mut arm_tys = Vec::new();\n         for (i, arm) in arms.iter().enumerate() {\n             if let Some(ref e) = arm.guard {\n                 self.check_expr_has_type(e, tcx.types.bool);\n             }\n             let arm_ty = self.check_expr_with_expectation(&arm.body, expected);\n-            arm_tys.push(arm_ty);\n \n             if result_ty.references_error() || arm_ty.references_error() {\n                 result_ty = tcx.types.err;\n@@ -458,8 +456,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Special-case the first arm, as it has no \"previous expressions\".\n                 self.try_coerce(&arm.body, arm_ty, coerce_first)\n             } else {\n-                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body)\n-                                            .zip(arm_tys.iter().cloned());\n+                let prev_arms = || arms[..i].iter().map(|arm| &*arm.body);\n                 self.try_find_coercion_lub(origin, prev_arms, result_ty, &arm.body, arm_ty)\n             };\n "}, {"sha": "98a05989b140d97881b25adddeb5bb9bd6e6df90", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7c8f5457d26055b26210fdd69c5ded1ecdde144a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8f5457d26055b26210fdd69c5ded1ecdde144a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7c8f5457d26055b26210fdd69c5ded1ecdde144a", "patch": "@@ -664,7 +664,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                            -> RelateResult<'tcx, Ty<'tcx>>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=(&'b hir::Expr, Ty<'tcx>)> {\n+              I: IntoIterator<Item=&'b hir::Expr> {\n \n         let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n         let new_ty = self.resolve_type_vars_with_obligations(new_ty);\n@@ -703,7 +703,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 // Reify both sides and return the reified fn pointer type.\n-                for (expr, _) in exprs().into_iter().chain(Some((new, new_ty))) {\n+                for expr in exprs().into_iter().chain(Some(new)) {\n                     // No adjustments can produce a fn item, so this should never trip.\n                     assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n                     self.write_adjustment(expr.id, AdjustReifyFnPointer);\n@@ -737,13 +737,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Then try to coerce the previous expressions to the type of the new one.\n         // This requires ensuring there are no coercions applied to *any* of the\n         // previous expressions, other than noop reborrows (ignoring lifetimes).\n-        for (expr, expr_ty) in exprs() {\n+        for expr in exprs() {\n             let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n                 Some(&AdjustDerefRef(AutoDerefRef {\n                     autoderefs: 1,\n                     autoref: Some(AutoPtr(_, mutbl_adj)),\n                     unsize: None\n-                })) => match expr_ty.sty {\n+                })) => match self.node_ty(expr.id).sty {\n                     ty::TyRef(_, mt_orig) => {\n                         // Reborrow that we can safely ignore.\n                         mutbl_adj == mt_orig.mutbl\n@@ -767,9 +767,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        match self.commit_if_ok(|_| apply(&mut coerce,\n-                                          &|| exprs().into_iter().map(|(e, _)| e),\n-                                          prev_ty, new_ty)) {\n+        match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n             Err(_) => {\n                 // Avoid giving strange errors on failed attempts.\n                 if let Some(e) = first_error {\n@@ -787,7 +785,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             Ok((ty, adjustment)) => {\n                 if !adjustment.is_identity() {\n-                    for (expr, _) in exprs() {\n+                    for expr in exprs() {\n                         let previous = self.tables.borrow().adjustments.get(&expr.id).cloned();\n                         if let Some(AdjustNeverToAny(_)) = previous {\n                             self.write_adjustment(expr.id, AdjustNeverToAny(ty));"}, {"sha": "1e57cc5d6c847e5bd189be2731b72cfb5364b043", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c8f5457d26055b26210fdd69c5ded1ecdde144a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c8f5457d26055b26210fdd69c5ded1ecdde144a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7c8f5457d26055b26210fdd69c5ded1ecdde144a", "patch": "@@ -2861,7 +2861,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Only try to coerce-unify if we have a then expression\n             // to assign coercions to, otherwise it's () or diverging.\n             let result = if let Some(ref then) = then_blk.expr {\n-                let res = self.try_find_coercion_lub(origin, || Some((&**then, then_ty)),\n+                let res = self.try_find_coercion_lub(origin, || Some(&**then),\n                                                      then_ty, else_expr, else_ty);\n \n                 // In case we did perform an adjustment, we have to update\n@@ -3594,18 +3594,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut unified = self.next_ty_var();\n             let coerce_to = uty.unwrap_or(unified);\n \n-            let mut arg_tys = Vec::new();\n             for (i, e) in args.iter().enumerate() {\n                 let e_ty = self.check_expr_with_hint(e, coerce_to);\n-                arg_tys.push(e_ty);\n                 let origin = TypeOrigin::Misc(e.span);\n \n                 // Special-case the first element, as it has no \"previous expressions\".\n                 let result = if i == 0 {\n                     self.try_coerce(e, e_ty, coerce_to)\n                 } else {\n-                    let prev_elems = || args[..i].iter().map(|e| &**e)\n-                                                 .zip(arg_tys.iter().cloned());\n+                    let prev_elems = || args[..i].iter().map(|e| &**e);\n                     self.try_find_coercion_lub(origin, prev_elems, unified, e, e_ty)\n                 };\n "}]}