{"sha": "a1e29daf1a9ca4e26719887b0c934de5d1695031", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZTI5ZGFmMWE5Y2E0ZTI2NzE5ODg3YjBjOTM0ZGU1ZDE2OTUwMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-25T22:53:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-25T22:53:16Z"}, "message": "Auto merge of #32167 - jseyfried:refactor_prelude, r=nikomatsakis\n\nresolve: Refactor how the prelude is handled\n\nThis PR refactors how the prelude is handled in `resolve`.\n\nInstead of importing names from the prelude into each module's `resolutions`, this PR adds a new field `prelude: RefCell<Option<Module>>` to `ModuleS` that is set during import resolution but used only when resolving in a lexical scope (i.e. the scope of an initial segment of a relative path).\n\nr? @nikomatsakis", "tree": {"sha": "5da1402523312269a5fb7c7e5e7aa48abdfd8f60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5da1402523312269a5fb7c7e5e7aa48abdfd8f60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1e29daf1a9ca4e26719887b0c934de5d1695031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e29daf1a9ca4e26719887b0c934de5d1695031", "html_url": "https://github.com/rust-lang/rust/commit/a1e29daf1a9ca4e26719887b0c934de5d1695031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1e29daf1a9ca4e26719887b0c934de5d1695031/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf9274b727423306121c223681022ac0531c6091", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9274b727423306121c223681022ac0531c6091", "html_url": "https://github.com/rust-lang/rust/commit/cf9274b727423306121c223681022ac0531c6091"}, {"sha": "54cd4d1472508af604e2fed328951dd5c622ecbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/54cd4d1472508af604e2fed328951dd5c622ecbc", "html_url": "https://github.com/rust-lang/rust/commit/54cd4d1472508af604e2fed328951dd5c622ecbc"}], "stats": {"total": 160, "additions": 70, "deletions": 90}, "files": [{"sha": "479fc5ebf907e74133683f4f045166f51d33b0a6", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a1e29daf1a9ca4e26719887b0c934de5d1695031/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e29daf1a9ca4e26719887b0c934de5d1695031/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a1e29daf1a9ca4e26719887b0c934de5d1695031", "patch": "@@ -22,7 +22,6 @@ use {NameBinding, NameBindingKind};\n use module_to_string;\n use ParentLink::{ModuleParentLink, BlockParentLink};\n use Resolver;\n-use resolve_imports::Shadowable;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::{CrateStore, ChildItem, DlDef, DlField, DlImpl};\n@@ -161,14 +160,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 };\n \n                 // Build up the import directives.\n-                let shadowable = item.attrs.iter().any(|attr| {\n+                let is_prelude = item.attrs.iter().any(|attr| {\n                     attr.name() == special_idents::prelude_import.name.as_str()\n                 });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n \n                 match view_path.node {\n                     ViewPathSimple(binding, ref full_path) => {\n@@ -186,7 +180,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                     view_path.span,\n                                                     item.id,\n                                                     is_public,\n-                                                    shadowable);\n+                                                    is_prelude);\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n@@ -237,7 +231,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                         source_item.span,\n                                                         source_item.node.id(),\n                                                         is_public,\n-                                                        shadowable);\n+                                                        is_prelude);\n                         }\n                     }\n                     ViewPathGlob(_) => {\n@@ -247,7 +241,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                                     view_path.span,\n                                                     item.id,\n                                                     is_public,\n-                                                    shadowable);\n+                                                    is_prelude);\n                     }\n                 }\n                 parent\n@@ -631,7 +625,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                               span: Span,\n                               id: NodeId,\n                               is_public: bool,\n-                              shadowable: Shadowable) {\n+                              is_prelude: bool) {\n         // Bump the reference count on the name. Or, if this is a glob, set\n         // the appropriate flag.\n \n@@ -640,15 +634,18 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 module_.increment_outstanding_references_for(target, ValueNS, is_public);\n                 module_.increment_outstanding_references_for(target, TypeNS, is_public);\n             }\n-            GlobImport => {\n+            GlobImport if !is_prelude => {\n                 // Set the glob flag. This tells us that we don't know the\n                 // module's exports ahead of time.\n                 module_.inc_glob_count(is_public)\n             }\n+            // Prelude imports are not included in the glob counts since they do not get added to\n+            // `resolved_globs` -- they are handled separately in `resolve_imports`.\n+            GlobImport => {}\n         }\n \n         let directive =\n-            ImportDirective::new(module_path, subclass, span, id, is_public, shadowable);\n+            ImportDirective::new(module_path, subclass, span, id, is_public, is_prelude);\n         module_.add_import_directive(directive);\n         self.unresolved_imports += 1;\n     }"}, {"sha": "77fdc657b886fa7ec55d8e4086284a01ef1a7bcc", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a1e29daf1a9ca4e26719887b0c934de5d1695031/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e29daf1a9ca4e26719887b0c934de5d1695031/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a1e29daf1a9ca4e26719887b0c934de5d1695031", "patch": "@@ -349,7 +349,8 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n             if let Some(sp) = resolver.ast_map.span_if_local(did) {\n                 err.span_note(sp, \"constant defined here\");\n             }\n-            if let Success(binding) = resolver.current_module.resolve_name(name, ValueNS, true) {\n+            if let Some(binding) = resolver.current_module\n+                                           .resolve_name_in_lexical_scope(name, ValueNS) {\n                 if binding.is_import() {\n                     err.span_note(binding.span.unwrap(), \"constant imported here\");\n                 }\n@@ -820,7 +821,7 @@ pub struct ModuleS<'a> {\n     // entry block for `f`.\n     module_children: RefCell<NodeMap<Module<'a>>>,\n \n-    shadowed_traits: RefCell<Vec<&'a NameBinding<'a>>>,\n+    prelude: RefCell<Option<Module<'a>>>,\n \n     glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective)>>,\n     resolved_globs: RefCell<(Vec<Module<'a>> /* public */, Vec<Module<'a>> /* private */)>,\n@@ -855,7 +856,7 @@ impl<'a> ModuleS<'a> {\n             resolutions: RefCell::new(HashMap::new()),\n             unresolved_imports: RefCell::new(Vec::new()),\n             module_children: RefCell::new(NodeMap()),\n-            shadowed_traits: RefCell::new(Vec::new()),\n+            prelude: RefCell::new(None),\n             glob_importers: RefCell::new(Vec::new()),\n             resolved_globs: RefCell::new((Vec::new(), Vec::new())),\n             public_glob_count: Cell::new(0),\n@@ -932,8 +933,7 @@ bitflags! {\n         // Variants are considered `PUBLIC`, but some of them live in private enums.\n         // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n         const PRIVATE_VARIANT = 1 << 2,\n-        const PRELUDE = 1 << 3,\n-        const GLOB_IMPORTED = 1 << 4,\n+        const GLOB_IMPORTED = 1 << 3,\n     }\n }\n \n@@ -1537,13 +1537,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               module: Module<'a>,\n                               name: Name,\n                               namespace: Namespace,\n-                              allow_private_imports: bool,\n+                              use_lexical_scope: bool,\n                               record_used: bool)\n                               -> ResolveResult<&'a NameBinding<'a>> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n \n         build_reduced_graph::populate_module_if_necessary(self, module);\n-        module.resolve_name(name, namespace, allow_private_imports).and_then(|binding| {\n+        match use_lexical_scope {\n+            true => module.resolve_name_in_lexical_scope(name, namespace)\n+                          .map(Success).unwrap_or(Failed(None)),\n+            false => module.resolve_name(name, namespace, false),\n+        }.and_then(|binding| {\n             if record_used {\n                 self.record_use(name, namespace, binding);\n             }\n@@ -2962,7 +2966,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if name_path.len() == 1 {\n                 match this.primitive_type_table.primitive_types.get(last_name) {\n                     Some(_) => None,\n-                    None => this.current_module.resolve_name(*last_name, TypeNS, true).success()\n+                    None => this.current_module.resolve_name_in_lexical_scope(*last_name, TypeNS)\n                                                .and_then(NameBinding::module)\n                 }\n             } else {\n@@ -3019,7 +3023,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Look for a method in the current self type's impl module.\n         if let Some(module) = get_module(self, path.span, &name_path) {\n-            if let Success(binding) = module.resolve_name(name, ValueNS, true) {\n+            if let Some(binding) = module.resolve_name_in_lexical_scope(name, ValueNS) {\n                 if let Some(Def::Method(did)) = binding.def() {\n                     if is_static_method(self, did) {\n                         return StaticMethod(path_names_to_string(&path, 0));\n@@ -3336,33 +3340,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n \n             // Look for trait children.\n-            build_reduced_graph::populate_module_if_necessary(self, &search_module);\n-\n-            search_module.for_each_child(|_, ns, name_binding| {\n+            let mut search_in_module = |module: Module<'a>| module.for_each_child(|_, ns, binding| {\n                 if ns != TypeNS { return }\n-                let trait_def_id = match name_binding.def() {\n+                let trait_def_id = match binding.def() {\n                     Some(Def::Trait(trait_def_id)) => trait_def_id,\n                     Some(..) | None => return,\n                 };\n                 if self.trait_item_map.contains_key(&(name, trait_def_id)) {\n                     add_trait_info(&mut found_traits, trait_def_id, name);\n                     let trait_name = self.get_trait_name(trait_def_id);\n-                    self.record_use(trait_name, TypeNS, name_binding);\n-                }\n-            });\n-\n-            // Look for shadowed traits.\n-            for binding in search_module.shadowed_traits.borrow().iter() {\n-                let did = binding.def().unwrap().def_id();\n-                if self.trait_item_map.contains_key(&(name, did)) {\n-                    add_trait_info(&mut found_traits, did, name);\n-                    let trait_name = self.get_trait_name(did);\n                     self.record_use(trait_name, TypeNS, binding);\n                 }\n-            }\n+            });\n+            search_in_module(search_module);\n \n             match search_module.parent_link {\n-                NoParentLink | ModuleParentLink(..) => break,\n+                NoParentLink | ModuleParentLink(..) => {\n+                    search_module.prelude.borrow().map(search_in_module);\n+                    break;\n+                }\n                 BlockParentLink(parent_module, _) => {\n                     search_module = parent_module;\n                 }"}, {"sha": "3af5031cc47cc3f53ed2302dec8c1f5f423c2197", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 39, "deletions": 52, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/a1e29daf1a9ca4e26719887b0c934de5d1695031/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e29daf1a9ca4e26719887b0c934de5d1695031/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a1e29daf1a9ca4e26719887b0c934de5d1695031", "patch": "@@ -57,13 +57,6 @@ impl ImportDirectiveSubclass {\n     }\n }\n \n-/// Whether an import can be shadowed by another import.\n-#[derive(Debug,PartialEq,Clone,Copy)]\n-pub enum Shadowable {\n-    Always,\n-    Never,\n-}\n-\n /// One import directive.\n #[derive(Debug,Clone)]\n pub struct ImportDirective {\n@@ -72,7 +65,7 @@ pub struct ImportDirective {\n     pub span: Span,\n     pub id: NodeId,\n     pub is_public: bool, // see note in ImportResolutionPerNamespace about how to use this\n-    pub shadowable: Shadowable,\n+    pub is_prelude: bool,\n }\n \n impl ImportDirective {\n@@ -81,15 +74,15 @@ impl ImportDirective {\n                span: Span,\n                id: NodeId,\n                is_public: bool,\n-               shadowable: Shadowable)\n+               is_prelude: bool)\n                -> ImportDirective {\n         ImportDirective {\n             module_path: module_path,\n             subclass: subclass,\n             span: span,\n             id: id,\n             is_public: is_public,\n-            shadowable: shadowable,\n+            is_prelude: is_prelude,\n         }\n     }\n \n@@ -105,9 +98,6 @@ impl ImportDirective {\n         if let GlobImport = self.subclass {\n             modifiers = modifiers | DefModifiers::GLOB_IMPORTED;\n         }\n-        if self.shadowable == Shadowable::Always {\n-            modifiers = modifiers | DefModifiers::PRELUDE;\n-        }\n \n         NameBinding {\n             kind: NameBindingKind::Import {\n@@ -135,44 +125,36 @@ pub struct NameResolution<'a> {\n \n impl<'a> NameResolution<'a> {\n     fn try_define(&mut self, binding: &'a NameBinding<'a>) -> Result<(), &'a NameBinding<'a>> {\n-        match self.binding {\n-            Some(old_binding) if !old_binding.defined_with(DefModifiers::PRELUDE) => {\n-                if binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n-                    self.duplicate_globs.push(binding);\n-                } else if old_binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n-                    self.duplicate_globs.push(old_binding);\n-                    self.binding = Some(binding);\n-                } else {\n-                    return Err(old_binding);\n-                }\n+        if let Some(old_binding) = self.binding {\n+            if binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+                self.duplicate_globs.push(binding);\n+            } else if old_binding.defined_with(DefModifiers::GLOB_IMPORTED) {\n+                self.duplicate_globs.push(old_binding);\n+                self.binding = Some(binding);\n+            } else {\n+                return Err(old_binding);\n             }\n-            _ => self.binding = Some(binding),\n+        } else {\n+            self.binding = Some(binding);\n         }\n \n         Ok(())\n     }\n \n-    // Returns the resolution of the name assuming no more globs will define it.\n-    fn result(&self, allow_private_imports: bool) -> ResolveResult<&'a NameBinding<'a>> {\n-        match self.binding {\n-            Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) => Success(binding),\n-            // If we don't allow private imports and no public imports can define the name, fail.\n-            _ if !allow_private_imports && self.pub_outstanding_references == 0 &&\n-                 !self.binding.map(NameBinding::is_public).unwrap_or(false) => Failed(None),\n-            _ if self.outstanding_references > 0 => Indeterminate,\n-            Some(binding) => Success(binding),\n-            None => Failed(None),\n-        }\n-    }\n-\n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n     fn try_result(&self, allow_private_imports: bool)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n-        match self.result(allow_private_imports) {\n-            Success(binding) if binding.defined_with(DefModifiers::PRELUDE) => None,\n-            Failed(_) => None,\n-            result @ _ => Some(result),\n+        match self.binding {\n+            Some(binding) if !binding.defined_with(DefModifiers::GLOB_IMPORTED) =>\n+                Some(Success(binding)),\n+            // If (1) we don't allow private imports, (2) no public single import can define the\n+            // name, and (3) no public glob has defined the name, the resolution depends on globs.\n+            _ if !allow_private_imports && self.pub_outstanding_references == 0 &&\n+                 !self.binding.map(NameBinding::is_public).unwrap_or(false) => None,\n+            _ if self.outstanding_references > 0 => Some(Indeterminate),\n+            Some(binding) => Some(Success(binding)),\n+            None => None,\n         }\n     }\n \n@@ -202,8 +184,6 @@ impl<'a> NameResolution<'a> {\n         };\n \n         for duplicate_glob in self.duplicate_globs.iter() {\n-            if duplicate_glob.defined_with(DefModifiers::PRELUDE) { continue }\n-\n             // FIXME #31337: We currently allow items to shadow glob-imported re-exports.\n             if !binding.is_import() {\n                 if let NameBindingKind::Import { binding, .. } = duplicate_glob.kind {\n@@ -259,7 +239,16 @@ impl<'a> ::ModuleS<'a> {\n             }\n         }\n \n-        resolution.result(true)\n+        Failed(None)\n+    }\n+\n+    // Invariant: this may not be called until import resolution is complete.\n+    pub fn resolve_name_in_lexical_scope(&self, name: Name, ns: Namespace)\n+                                         -> Option<&'a NameBinding<'a>> {\n+        self.resolutions.borrow().get(&(name, ns)).and_then(|resolution| resolution.binding)\n+            .or_else(|| self.prelude.borrow().and_then(|prelude| {\n+                prelude.resolve_name(name, ns, false).success()\n+            }))\n     }\n \n     // Define the name or return the existing binding if there is a collision.\n@@ -369,7 +358,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         // resolution for it so that later resolve stages won't complain.\n         if let SingleImport { target, .. } = e.import_directive.subclass {\n             let dummy_binding = self.resolver.arenas.alloc_name_binding(NameBinding {\n-                modifiers: DefModifiers::PRELUDE,\n+                modifiers: DefModifiers::GLOB_IMPORTED,\n                 kind: NameBindingKind::Def(Def::Err),\n                 span: None,\n             });\n@@ -623,6 +612,11 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         }\n         build_reduced_graph::populate_module_if_necessary(self.resolver, target_module);\n \n+        if directive.is_prelude {\n+            *module_.prelude.borrow_mut() = Some(target_module);\n+            return Success(());\n+        }\n+\n         // Add to target_module's glob_importers and module_'s resolved_globs\n         target_module.glob_importers.borrow_mut().push((module_, directive));\n         match *module_.resolved_globs.borrow_mut() {\n@@ -685,13 +679,6 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     self.resolver.session.add_lint(lint, id, binding.span.unwrap(), msg);\n                 }\n             }\n-\n-            // We can always use methods from the prelude traits\n-            for glob_binding in resolution.duplicate_globs.iter() {\n-                if glob_binding.defined_with(DefModifiers::PRELUDE) {\n-                    module.shadowed_traits.borrow_mut().push(glob_binding);\n-                }\n-            }\n         }\n \n         if reexports.len() > 0 {"}]}