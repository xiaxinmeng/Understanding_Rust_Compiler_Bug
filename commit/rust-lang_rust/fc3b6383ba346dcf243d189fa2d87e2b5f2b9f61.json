{"sha": "fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjM2I2MzgzYmEzNDZkY2YyNDNkMTg5ZmEyZDg3ZTJiNWYyYjlmNjE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-09-05T01:45:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-09-05T01:49:59Z"}, "message": "Update fannkuchredux benchmark\n\nFrom the discussion on reddit:\nhttp://www.reddit.com/r/rust/comments/2fenlg/benchmark_improvement_fannkuchredux/\n\nThis adds two variants: the primary, that uses an unsafe block, and a secondary\nthat is completely safe.\n\nThe one with the unsafe block matches clang's performance and beats gcc's.", "tree": {"sha": "0a4af21fad2a72c894cfee1d7579229000e5ec0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a4af21fad2a72c894cfee1d7579229000e5ec0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "html_url": "https://github.com/rust-lang/rust/commit/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e024017f60c93b6ff4f37bd4bd580f30deafb107", "url": "https://api.github.com/repos/rust-lang/rust/commits/e024017f60c93b6ff4f37bd4bd580f30deafb107", "html_url": "https://github.com/rust-lang/rust/commit/e024017f60c93b6ff4f37bd4bd580f30deafb107"}], "stats": {"total": 374, "additions": 326, "deletions": 48}, "files": [{"sha": "1a8101c76caf8020c3701e38f1d975f0f7db457e", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "patch": "@@ -44,6 +44,7 @@\n     \"libsync/mpsc_intrusive.rs\", # BSD\n     \"test/bench/shootout-binarytrees.rs\", # BSD\n     \"test/bench/shootout-fannkuch-redux.rs\", # BSD\n+    \"test/bench/shootout-fannkuch-redux-safe.rs\", # BSD\n     \"test/bench/shootout-k-nucleotide.rs\", # BSD\n     \"test/bench/shootout-mandelbrot.rs\", # BSD\n     \"test/bench/shootout-meteor.rs\", # BSD"}, {"sha": "f0798a9e7e82fe1d4f5158005e5803a1d7d24ff6", "filename": "src/test/bench/shootout-fannkuch-redux-safe.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux-safe.rs?ref=fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "patch": "@@ -0,0 +1,188 @@\n+// The Computer Language Benchmarks Game\n+// http://benchmarksgame.alioth.debian.org/\n+//\n+// contributed by the Rust Project Developers\n+\n+// Copyright (c) 2014 The Rust Project Developers\n+//\n+// All rights reserved.\n+//\n+// Redistribution and use in source and binary forms, with or without\n+// modification, are permitted provided that the following conditions\n+// are met:\n+//\n+// - Redistributions of source code must retain the above copyright\n+//   notice, this list of conditions and the following disclaimer.\n+//\n+// - Redistributions in binary form must reproduce the above copyright\n+//   notice, this list of conditions and the following disclaimer in\n+//   the documentation and/or other materials provided with the\n+//   distribution.\n+//\n+// - Neither the name of \"The Computer Language Benchmarks Game\" nor\n+//   the name of \"The Computer Language Shootout Benchmarks\" nor the\n+//   names of its contributors may be used to endorse or promote\n+//   products derived from this software without specific prior\n+//   written permission.\n+//\n+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+// FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+// COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+// OF THE POSSIBILITY OF SUCH DAMAGE.\n+\n+use std::{cmp, iter, mem};\n+use std::sync::Future;\n+\n+fn rotate(x: &mut [i32]) {\n+    let mut prev = x[0];\n+    for place in x.mut_iter().rev() {\n+        prev = mem::replace(place, prev)\n+    }\n+}\n+\n+fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n+    for i in range(1, perm.len()) {\n+        rotate(perm.mut_slice_to(i + 1));\n+        let count_i = &mut count[i];\n+        if *count_i >= i as i32 {\n+            *count_i = 0;\n+        } else {\n+            *count_i += 1;\n+            break\n+        }\n+    }\n+}\n+\n+struct P {\n+    p: [i32, .. 16],\n+}\n+\n+struct Perm {\n+    cnt: [i32, .. 16],\n+    fact: [u32, .. 16],\n+    n: u32,\n+    permcount: u32,\n+    perm: P,\n+}\n+\n+impl Perm {\n+    fn new(n: u32) -> Perm {\n+        let mut fact = [1, .. 16];\n+        for i in range(1, n as uint + 1) {\n+            fact[i] = fact[i - 1] * i as u32;\n+        }\n+        Perm {\n+            cnt: [0, .. 16],\n+            fact: fact,\n+            n: n,\n+            permcount: 0,\n+            perm: P { p: [0, .. 16 ] }\n+        }\n+    }\n+\n+    fn get(&mut self, mut idx: i32) -> P {\n+        let mut pp = [0u8, .. 16];\n+        self.permcount = idx as u32;\n+        for (i, place) in self.perm.p.mut_iter().enumerate() {\n+            *place = i as i32 + 1;\n+        }\n+\n+        for i in range(1, self.n as uint).rev() {\n+            let d = idx / self.fact[i] as i32;\n+            self.cnt[i] = d;\n+            idx %= self.fact[i] as i32;\n+            for (place, val) in pp.mut_iter().zip(self.perm.p.slice_to(i + 1).iter()) {\n+                *place = (*val) as u8\n+            }\n+\n+            let d = d as uint;\n+            for j in range(0, i + 1) {\n+                self.perm.p[j] = if j + d <= i {pp[j + d]} else {pp[j+d-i-1]} as i32;\n+            }\n+        }\n+\n+        self.perm\n+    }\n+\n+    fn count(&self) -> u32 { self.permcount }\n+    fn max(&self) -> u32 { self.fact[self.n as uint] }\n+\n+    fn next(&mut self) -> P {\n+        next_permutation(self.perm.p, self.cnt);\n+        self.permcount += 1;\n+\n+        self.perm\n+    }\n+}\n+\n+\n+fn reverse(tperm: &mut [i32], mut k: uint) {\n+    tperm.mut_slice_to(k).reverse()\n+}\n+\n+fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {\n+    let mut checksum = 0;\n+    let mut maxflips = 0;\n+\n+    let mut p = perm.get(n as i32);\n+\n+    while perm.count() < max as u32 {\n+        let mut flips = 0;\n+\n+        while p.p[0] != 1 {\n+            let k = p.p[0] as uint;\n+            reverse(p.p, k);\n+            flips += 1;\n+        }\n+\n+        checksum += if perm.count() % 2 == 0 {flips} else {-flips};\n+        maxflips = cmp::max(maxflips, flips);\n+\n+        p = perm.next();\n+    }\n+\n+    (checksum, maxflips)\n+}\n+\n+fn fannkuch(n: i32) -> (i32, i32) {\n+    let perm = Perm::new(n as u32);\n+\n+    let N = 4;\n+    let mut futures = vec![];\n+    let k = perm.max() / N;\n+\n+    for (i, j) in range(0, N).zip(iter::count(0, k)) {\n+        let max = cmp::min(j+k, perm.max());\n+\n+        futures.push(Future::spawn(proc() {\n+            work(perm, j as uint, max as uint)\n+        }))\n+    }\n+\n+    let mut checksum = 0;\n+    let mut maxflips = 0;\n+    for fut in futures.mut_iter() {\n+        let (cs, mf) = fut.get();\n+        checksum += cs;\n+        maxflips = cmp::max(maxflips, mf);\n+    }\n+    (checksum, maxflips)\n+}\n+\n+fn main() {\n+    let n = std::os::args().as_slice()\n+        .get(1)\n+        .and_then(|arg| from_str(arg.as_slice()))\n+        .unwrap_or(2i32);\n+\n+    let (checksum, maxflips) = fannkuch(n);\n+    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, maxflips);\n+}"}, {"sha": "9307ae51f78551d82d90f3dd6f270627e5de1d2d", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 137, "deletions": 48, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=fc3b6383ba346dcf243d189fa2d87e2b5f2b9f61", "patch": "@@ -38,68 +38,157 @@\n // ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n-use std::cmp::max;\n+use std::{cmp, iter, mem};\n+use std::sync::Future;\n \n-fn fact(n: uint) -> uint {\n-    range(1, n + 1).fold(1, |accu, i| accu * i)\n+fn rotate(x: &mut [i32]) {\n+    let mut prev = x[0];\n+    for place in x.mut_iter().rev() {\n+        prev = mem::replace(place, prev)\n+    }\n }\n \n-fn fannkuch(n: uint, i: uint) -> (int, int) {\n-    let mut perm = Vec::from_fn(n, |e| ((n + e - i) % n + 1) as i32);\n-    let mut tperm = perm.clone();\n-    let mut count = Vec::from_elem(n, 0u);\n-    let mut perm_count = 0i;\n-    let mut checksum = 0;\n+fn next_permutation(perm: &mut [i32], count: &mut [i32]) {\n+    for i in range(1, perm.len()) {\n+        rotate(perm.mut_slice_to(i + 1));\n+        let count_i = &mut count[i];\n+        if *count_i >= i as i32 {\n+            *count_i = 0;\n+        } else {\n+            *count_i += 1;\n+            break\n+        }\n+    }\n+}\n+\n+struct P {\n+    p: [i32, .. 16],\n+}\n+\n+struct Perm {\n+    cnt: [i32, .. 16],\n+    fact: [u32, .. 16],\n+    n: u32,\n+    permcount: u32,\n+    perm: P,\n+}\n \n-    for countdown in range(1, fact(n - 1) + 1).rev() {\n-        for i in range(1, n) {\n-            let perm0 = *perm.get(0);\n-            for j in range(0, i) {\n-                *perm.get_mut(j) = *perm.get(j + 1);\n+impl Perm {\n+    fn new(n: u32) -> Perm {\n+        let mut fact = [1, .. 16];\n+        for i in range(1, n as uint + 1) {\n+            fact[i] = fact[i - 1] * i as u32;\n+        }\n+        Perm {\n+            cnt: [0, .. 16],\n+            fact: fact,\n+            n: n,\n+            permcount: 0,\n+            perm: P { p: [0, .. 16 ] }\n+        }\n+    }\n+\n+    fn get(&mut self, mut idx: i32) -> P {\n+        let mut pp = [0u8, .. 16];\n+        self.permcount = idx as u32;\n+        for (i, place) in self.perm.p.mut_iter().enumerate() {\n+            *place = i as i32 + 1;\n+        }\n+\n+        for i in range(1, self.n as uint).rev() {\n+            let d = idx / self.fact[i] as i32;\n+            self.cnt[i] = d;\n+            idx %= self.fact[i] as i32;\n+            for (place, val) in pp.mut_iter().zip(self.perm.p.slice_to(i + 1).iter()) {\n+                *place = (*val) as u8\n             }\n-            *perm.get_mut(i) = perm0;\n-\n-            let count_i = count.get_mut(i);\n-            if *count_i >= i {\n-                *count_i = 0;\n-            } else {\n-                *count_i += 1;\n-                break;\n+\n+            let d = d as uint;\n+            for j in range(0, i + 1) {\n+                self.perm.p[j] = if j + d <= i {pp[j + d]} else {pp[j+d-i-1]} as i32;\n             }\n         }\n \n-        tperm.clone_from(&perm);\n-        let mut flips_count = 0;\n-        loop {\n-            let k = *tperm.get(0);\n-            if k == 1 { break; }\n-            tperm.mut_slice_to(k as uint).reverse();\n-            flips_count += 1;\n+        self.perm\n+    }\n+\n+    fn count(&self) -> u32 { self.permcount }\n+    fn max(&self) -> u32 { self.fact[self.n as uint] }\n+\n+    fn next(&mut self) -> P {\n+        next_permutation(self.perm.p, self.cnt);\n+        self.permcount += 1;\n+\n+        self.perm\n+    }\n+}\n+\n+\n+fn reverse(tperm: &mut [i32], mut k: uint) {\n+    let p = tperm.as_mut_ptr();\n+\n+    unsafe {\n+        for off in range(0, k as int / 2) {\n+            std::ptr::swap(p.offset(off), p.offset(k as int - 1 - off));\n+        }\n+    }\n+}\n+\n+fn work(mut perm: Perm, n: uint, max: uint) -> (i32, i32) {\n+    let mut checksum = 0;\n+    let mut maxflips = 0;\n+\n+    let mut p = perm.get(n as i32);\n+\n+    while perm.count() < max as u32 {\n+        let mut flips = 0;\n+\n+        while p.p[0] != 1 {\n+            let k = p.p[0] as uint;\n+            reverse(p.p, k);\n+            flips += 1;\n         }\n-        perm_count = max(perm_count, flips_count);\n-        checksum += if countdown & 1 == 1 {flips_count} else {-flips_count}\n+\n+        checksum += if perm.count() % 2 == 0 {flips} else {-flips};\n+        maxflips = cmp::max(maxflips, flips);\n+\n+        p = perm.next();\n     }\n-    (checksum, perm_count)\n+\n+    (checksum, maxflips)\n }\n \n-fn main() {\n-    let n = std::os::args().as_slice()\n-                           .get(1)\n-                           .and_then(|arg| from_str(arg.as_slice()))\n-                           .unwrap_or(2u);\n-\n-    let (tx, rx) = channel();\n-    for i in range(0, n) {\n-        let tx = tx.clone();\n-        spawn(proc() tx.send(fannkuch(n, i)));\n+fn fannkuch(n: i32) -> (i32, i32) {\n+    let perm = Perm::new(n as u32);\n+\n+    let N = 4;\n+    let mut futures = vec![];\n+    let k = perm.max() / N;\n+\n+    for (i, j) in range(0, N).zip(iter::count(0, k)) {\n+        let max = cmp::min(j+k, perm.max());\n+\n+        futures.push(Future::spawn(proc() {\n+            work(perm, j as uint, max as uint)\n+        }))\n     }\n-    drop(tx);\n \n     let mut checksum = 0;\n-    let mut perm = 0;\n-    for (cur_cks, cur_perm) in rx.iter() {\n-        checksum += cur_cks;\n-        perm = max(perm, cur_perm);\n+    let mut maxflips = 0;\n+    for fut in futures.mut_iter() {\n+        let (cs, mf) = fut.get();\n+        checksum += cs;\n+        maxflips = cmp::max(maxflips, mf);\n     }\n-    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, perm);\n+    (checksum, maxflips)\n+}\n+\n+fn main() {\n+    let n = std::os::args().as_slice()\n+        .get(1)\n+        .and_then(|arg| from_str(arg.as_slice()))\n+        .unwrap_or(2i32);\n+\n+    let (checksum, maxflips) = fannkuch(n);\n+    println!(\"{}\\nPfannkuchen({}) = {}\", checksum, n, maxflips);\n }"}]}