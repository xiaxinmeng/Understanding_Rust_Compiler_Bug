{"sha": "a005d2a614031a18c9a5bf6557789a41f1b25c31", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMDVkMmE2MTQwMzFhMThjOWE1YmY2NTU3Nzg5YTQxZjFiMjVjMzE=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-21T17:38:28Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T18:59:02Z"}, "message": "final iteration, faster a bit simpler\nthe main thing is we iterate over inserted newlines at once for each edit", "tree": {"sha": "517d8b6885ab5a4eacb1d3bc77266aeea14a9a85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/517d8b6885ab5a4eacb1d3bc77266aeea14a9a85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a005d2a614031a18c9a5bf6557789a41f1b25c31", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a005d2a614031a18c9a5bf6557789a41f1b25c31", "html_url": "https://github.com/rust-lang/rust/commit/a005d2a614031a18c9a5bf6557789a41f1b25c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a005d2a614031a18c9a5bf6557789a41f1b25c31/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7299df8409097de67647b371b81da7bcf49112e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7299df8409097de67647b371b81da7bcf49112e6", "html_url": "https://github.com/rust-lang/rust/commit/7299df8409097de67647b371b81da7bcf49112e6"}], "stats": {"total": 380, "additions": 209, "deletions": 171}, "files": [{"sha": "5ce2446c10001d7f85d9ca752aadbe444ca7910e", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "modified", "additions": 209, "deletions": 171, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/a005d2a614031a18c9a5bf6557789a41f1b25c31/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a005d2a614031a18c9a5bf6557789a41f1b25c31/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=a005d2a614031a18c9a5bf6557789a41f1b25c31", "patch": "@@ -1,4 +1,4 @@\n-use ra_text_edit::{AtomTextEdit};\n+use ra_text_edit::AtomTextEdit;\n use ra_syntax::{TextUnit, TextRange};\n use crate::{LineIndex, LineCol};\n use superslice::Ext;\n@@ -24,41 +24,6 @@ impl<'a> Iterator for OffsetNewlineIter<'a> {\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq)]\n-enum TranslatedPos {\n-    Before,\n-    After,\n-}\n-\n-/// None means it was deleted\n-type TranslatedOffset = Option<(TranslatedPos, TextUnit)>;\n-\n-fn translate_offset(offset: TextUnit, edit: &TranslatedAtomEdit) -> TranslatedOffset {\n-    if offset <= edit.delete.start() {\n-        Some((TranslatedPos::Before, offset))\n-    } else if offset <= edit.delete.end() {\n-        None\n-    } else {\n-        let diff = edit.insert.len() as i64 - edit.delete.len().to_usize() as i64;\n-        let after = TextUnit::from((offset.to_usize() as i64 + diff) as u32);\n-        Some((TranslatedPos::After, after))\n-    }\n-}\n-\n-trait TranslatedNewlineIterator {\n-    fn translate(&self, offset: TextUnit) -> TextUnit;\n-    fn translate_range(&self, range: TextRange) -> TextRange {\n-        TextRange::from_to(self.translate(range.start()), self.translate(range.end()))\n-    }\n-    fn next_translated(&mut self) -> Option<TextUnit>;\n-    fn boxed<'a>(self) -> Box<TranslatedNewlineIterator + 'a>\n-    where\n-        Self: 'a + Sized,\n-    {\n-        Box::new(self)\n-    }\n-}\n-\n #[derive(Debug)]\n struct AltEdit<'a> {\n     insert_newlines: OffsetNewlineIter<'a>,\n@@ -156,7 +121,7 @@ fn next_newline(candidate: Option<TextUnit>, edits: &mut [AltEdit]) -> NextNewli\n     return NextNewline::Replace(candidate);\n }\n \n-fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdit]) -> u32 {\n+pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdit]) -> u32 {\n     let mut edits = to_alt_edits(offset, edits);\n     let mut orig_newlines = line_index.newlines().iter().map(|x| *x).peekable();\n \n@@ -189,142 +154,184 @@ fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdi\n     count\n }\n \n-struct TranslatedAtomEdit<'a> {\n+#[derive(Debug)]\n+enum NextNewlines<'a> {\n+    Use,\n+    ReplaceMany(OffsetNewlineIter<'a>),\n+    AddMany(OffsetNewlineIter<'a>),\n+}\n+\n+#[derive(Debug)]\n+struct TranslatedEdit<'a> {\n     delete: TextRange,\n     insert: &'a str,\n+    diff: i64,\n }\n \n-struct TranslatedNewlines<'a, T: TranslatedNewlineIterator> {\n-    inner: T,\n-    next_inner: Option<TranslatedOffset>,\n-    edit: TranslatedAtomEdit<'a>,\n-    insert: OffsetNewlineIter<'a>,\n+struct Edits<'a, 'b> {\n+    edits: &'b [&'a AtomTextEdit],\n+    current: Option<TranslatedEdit<'a>>,\n+    acc_diff: i64,\n }\n \n-impl<'a, T: TranslatedNewlineIterator> TranslatedNewlines<'a, T> {\n-    fn from(inner: T, edit: &'a AtomTextEdit) -> Self {\n-        let delete = inner.translate_range(edit.delete);\n-        let mut res = TranslatedNewlines {\n-            inner,\n-            next_inner: None,\n-            edit: TranslatedAtomEdit {\n-                delete,\n-                insert: &edit.insert,\n-            },\n-            insert: OffsetNewlineIter {\n-                offset: delete.start(),\n-                text: &edit.insert,\n-            },\n+impl<'a, 'b> Edits<'a, 'b> {\n+    fn new(sorted_edits: &'b [&'a AtomTextEdit]) -> Edits<'a, 'b> {\n+        let mut x = Edits {\n+            edits: sorted_edits,\n+            current: None,\n+            acc_diff: 0,\n         };\n-        // prepare next_inner\n-        res.advance_inner();\n-        res\n+        x.advance_edit();\n+        x\n     }\n-\n-    fn advance_inner(&mut self) {\n-        self.next_inner = self\n-            .inner\n-            .next_translated()\n-            .map(|x| translate_offset(x, &self.edit));\n+    fn advance_edit(&mut self) {\n+        self.acc_diff += self.current.as_ref().map_or(0, |x| x.diff);\n+        match self.edits.split_first() {\n+            Some((next, rest)) => {\n+                let delete = translate_range_by(next.delete, self.acc_diff);\n+                let diff = next.insert.len() as i64 - next.delete.len().to_usize() as i64;\n+                self.current = Some(TranslatedEdit {\n+                    delete,\n+                    insert: &next.insert,\n+                    diff,\n+                });\n+                self.edits = rest;\n+            }\n+            None => {\n+                self.current = None;\n+            }\n+        }\n     }\n-}\n \n-impl<'a, T: TranslatedNewlineIterator> TranslatedNewlineIterator for TranslatedNewlines<'a, T> {\n-    fn translate(&self, offset: TextUnit) -> TextUnit {\n-        let offset = self.inner.translate(offset);\n-        let (_, offset) =\n-            translate_offset(offset, &self.edit).expect(\"translate_unit returned None\");\n-        offset\n+    fn next_inserted_newlines(&mut self) -> Option<OffsetNewlineIter<'a>> {\n+        let cur = self.current.as_ref()?;\n+        let res = Some(OffsetNewlineIter {\n+            offset: cur.delete.start(),\n+            text: &cur.insert,\n+        });\n+        self.advance_edit();\n+        res\n     }\n \n-    fn next_translated(&mut self) -> Option<TextUnit> {\n-        match self.next_inner {\n-            None => self.insert.next(),\n-            Some(next) => match next {\n-                None => self.insert.next().or_else(|| {\n-                    self.advance_inner();\n-                    self.next_translated()\n-                }),\n-                Some((TranslatedPos::Before, next)) => {\n-                    self.advance_inner();\n-                    Some(next)\n+    fn next_newlines(&mut self, candidate: TextUnit) -> NextNewlines {\n+        let res = match &mut self.current {\n+            Some(edit) => {\n+                if candidate <= edit.delete.start() {\n+                    NextNewlines::Use\n+                } else if candidate <= edit.delete.end() {\n+                    let iter = OffsetNewlineIter {\n+                        offset: edit.delete.start(),\n+                        text: &edit.insert,\n+                    };\n+                    // empty slice\n+                    edit.insert = &edit.insert[edit.insert.len()..];\n+                    NextNewlines::ReplaceMany(iter)\n+                } else {\n+                    let iter = OffsetNewlineIter {\n+                        offset: edit.delete.start(),\n+                        text: &edit.insert,\n+                    };\n+                    // empty slice\n+                    edit.insert = &edit.insert[edit.insert.len()..];\n+                    self.advance_edit();\n+                    NextNewlines::AddMany(iter)\n                 }\n-                Some((TranslatedPos::After, next)) => self.insert.next().or_else(|| {\n-                    self.advance_inner();\n-                    Some(next)\n-                }),\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a> Iterator for Box<dyn TranslatedNewlineIterator + 'a> {\n-    type Item = TextUnit;\n-    fn next(&mut self) -> Option<TextUnit> {\n-        self.next_translated()\n+            }\n+            None => NextNewlines::Use,\n+        };\n+        res\n     }\n }\n \n-impl<T: TranslatedNewlineIterator + ?Sized> TranslatedNewlineIterator for Box<T> {\n-    fn translate(&self, offset: TextUnit) -> TextUnit {\n-        self.as_ref().translate(offset)\n-    }\n-    fn next_translated(&mut self) -> Option<TextUnit> {\n-        self.as_mut().next_translated()\n+pub fn count_newlines_alt(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdit]) -> u32 {\n+    let mut sorted_edits: Vec<&AtomTextEdit> = Vec::with_capacity(edits.len());\n+    for edit in edits {\n+        let insert_index =\n+            sorted_edits.upper_bound_by_key(&edit.delete.start(), |x| x.delete.start());\n+        sorted_edits.insert(insert_index, &edit);\n     }\n-}\n-\n-struct IteratorWrapper<T: Iterator<Item = TextUnit>>(T);\n \n-impl<T: Iterator<Item = TextUnit>> TranslatedNewlineIterator for IteratorWrapper<T> {\n-    fn translate(&self, offset: TextUnit) -> TextUnit {\n-        offset\n-    }\n-    fn next_translated(&mut self) -> Option<TextUnit> {\n-        self.0.next()\n+    let mut state = Edits::new(&sorted_edits);\n+\n+    let mut lines: u32 = 0;\n+\n+    for &orig_newline in line_index.newlines() {\n+        loop {\n+            let translated_newline = translate_by(orig_newline, state.acc_diff);\n+            match state.next_newlines(translated_newline) {\n+                NextNewlines::Use => {\n+                    if offset < translated_newline {\n+                        return lines;\n+                    } else {\n+                        lines += 1;\n+                    }\n+                    break;\n+                }\n+                NextNewlines::ReplaceMany(ns) => {\n+                    for n in ns {\n+                        if offset < n {\n+                            return lines;\n+                        } else {\n+                            lines += 1;\n+                        }\n+                    }\n+                    break;\n+                }\n+                NextNewlines::AddMany(ns) => {\n+                    for n in ns {\n+                        if offset < n {\n+                            return lines;\n+                        } else {\n+                            lines += 1;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n-}\n \n-impl<T: Iterator<Item = TextUnit>> Iterator for IteratorWrapper<T> {\n-    type Item = TextUnit;\n-    fn next(&mut self) -> Option<TextUnit> {\n-        self.0.next()\n+    loop {\n+        match state.next_inserted_newlines() {\n+            None => break,\n+            Some(ns) => {\n+                for n in ns {\n+                    if offset < n {\n+                        return lines;\n+                    } else {\n+                        lines += 1;\n+                    }\n+                }\n+            }\n+        }\n     }\n-}\n \n-fn translate_newlines<'a>(\n-    mut newlines: Box<TranslatedNewlineIterator + 'a>,\n-    edits: &'a [AtomTextEdit],\n-) -> Box<TranslatedNewlineIterator + 'a> {\n-    for edit in edits {\n-        newlines = TranslatedNewlines::from(newlines, edit).boxed();\n-    }\n-    newlines\n+    lines\n }\n \n-pub fn translate_offset_with_edit(\n-    pre_edit_index: &LineIndex,\n+// for bench\n+pub fn translate_after_edit(\n+    pre_edit_text: &str,\n     offset: TextUnit,\n-    edits: &[AtomTextEdit],\n+    edits: Vec<AtomTextEdit>,\n ) -> LineCol {\n-    let mut newlines: Box<TranslatedNewlineIterator> = Box::new(IteratorWrapper(\n-        pre_edit_index.newlines().iter().map(|x| *x),\n-    ));\n+    let text = edit_text(pre_edit_text, edits);\n+    let line_index = LineIndex::new(&text);\n+    line_index.line_col(offset)\n+}\n \n-    newlines = translate_newlines(newlines, edits);\n+fn edit_text(pre_edit_text: &str, mut edits: Vec<AtomTextEdit>) -> String {\n+    // apply edits ordered from last to first\n+    // since they should not overlap we can just use start()\n+    edits.sort_by_key(|x| -(x.delete.start().to_usize() as isize));\n \n-    let mut line = 0;\n-    for n in newlines {\n-        if n > offset {\n-            break;\n-        }\n-        line += 1;\n-    }\n+    let mut text = pre_edit_text.to_owned();\n \n-    LineCol {\n-        line: line,\n-        col_utf16: 0, // TODO not implemented yet\n+    for edit in &edits {\n+        let range = edit.delete.start().to_usize()..edit.delete.end().to_usize();\n+        text.replace_range(range, &edit.insert);\n     }\n+\n+    text\n }\n \n #[cfg(test)]\n@@ -354,46 +361,77 @@ mod test {\n             .boxed()\n     }\n \n-    fn edit_text(pre_edit_text: &str, mut edits: Vec<AtomTextEdit>) -> String {\n-        // apply edits ordered from last to first\n-        // since they should not overlap we can just use start()\n-        edits.sort_by_key(|x| -(x.delete.start().to_usize() as isize));\n-\n-        let mut text = pre_edit_text.to_owned();\n-\n-        for edit in &edits {\n-            let range = edit.delete.start().to_usize()..edit.delete.end().to_usize();\n-            text.replace_range(range, &edit.insert);\n-        }\n-\n-        text\n-    }\n-\n-    fn translate_after_edit(\n-        pre_edit_text: &str,\n-        offset: TextUnit,\n-        edits: Vec<AtomTextEdit>,\n-    ) -> LineCol {\n-        let text = edit_text(pre_edit_text, edits);\n-        let line_index = LineIndex::new(&text);\n-        line_index.line_col(offset)\n-    }\n-\n     proptest! {\n         #[test]\n         fn test_translate_offset_with_edit(x in arb_text_with_offset_and_edits()) {\n             let line_index = LineIndex::new(&x.text);\n             let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-            let actual = translate_offset_with_edit(&line_index, x.offset, &x.edits);\n-            assert_eq!(actual.line, expected.line);\n+            let actual_lines = count_newlines(x.offset, &line_index, &x.edits);\n+            assert_eq!(actual_lines, expected.line);\n         }\n \n         #[test]\n         fn test_translate_offset_with_edit_alt(x in arb_text_with_offset_and_edits()) {\n             let line_index = LineIndex::new(&x.text);\n             let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-            let actual_lines = count_newlines(x.offset, &line_index, &x.edits);\n+            let actual_lines = count_newlines_alt(x.offset, &line_index, &x.edits);\n             assert_eq!(actual_lines, expected.line);\n         }\n     }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_alt_1() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: String::from(\"aA\\n\"),\n+            offset: 2.into(),\n+            edits: vec![AtomTextEdit::delete(TextRange::from_to(1.into(), 2.into()))],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual_lines = count_newlines_alt(x.offset, &line_index, &x.edits);\n+        assert_eq!(actual_lines, expected.line);\n+    }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_alt_2() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: String::from(\"\\nq\ua038#\"),\n+            offset: 5.into(),\n+            edits: vec![AtomTextEdit::insert(1.into(), \"\\n\".into())],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual_lines = count_newlines_alt(x.offset, &line_index, &x.edits);\n+        assert_eq!(actual_lines, expected.line);\n+    }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_alt_3() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: String::from(\"\\n\\n\\n\"),\n+            offset: 0.into(),\n+            edits: vec![AtomTextEdit::delete(TextRange::from_to(0.into(), 2.into()))],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual_lines = count_newlines_alt(x.offset, &line_index, &x.edits);\n+        assert_eq!(actual_lines, expected.line);\n+    }\n+\n+    #[test]\n+    fn test_translate_offset_with_edit_alt_4() {\n+        let x = ArbTextWithOffsetAndEdits {\n+            text: String::from(\"\u263b54\u7fd1\\\"A\"),\n+            offset: 5.into(),\n+            edits: vec![\n+                AtomTextEdit::delete(TextRange::from_to(0.into(), 8.into())),\n+                AtomTextEdit::insert(9.into(), String::from(\"\\n\")),\n+            ],\n+        };\n+        let line_index = LineIndex::new(&x.text);\n+        let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n+        let actual_lines = count_newlines_alt(x.offset, &line_index, &x.edits);\n+        assert_eq!(actual_lines, expected.line);\n+    }\n+\n }"}]}