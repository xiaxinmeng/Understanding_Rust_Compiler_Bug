{"sha": "bfc696ad8af7d59edd37480aa3aa56e89878fd97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYzY5NmFkOGFmN2Q1OWVkZDM3NDgwYWEzYWE1NmU4OTg3OGZkOTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-30T09:08:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-02T08:40:50Z"}, "message": "add comments to `region_infer`, restructure a bit", "tree": {"sha": "ecbcb6489c3f47e2b0ba0810179e6fb242abb2c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecbcb6489c3f47e2b0ba0810179e6fb242abb2c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfc696ad8af7d59edd37480aa3aa56e89878fd97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfc696ad8af7d59edd37480aa3aa56e89878fd97", "html_url": "https://github.com/rust-lang/rust/commit/bfc696ad8af7d59edd37480aa3aa56e89878fd97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfc696ad8af7d59edd37480aa3aa56e89878fd97/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3", "html_url": "https://github.com/rust-lang/rust/commit/cafbd99c3822f24ca53c3cce79ffe2471e05dbc3"}], "stats": {"total": 91, "additions": 56, "deletions": 35}, "files": [{"sha": "195448226ec1b4c26f18936a93c9ca9ee38cbee3", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bfc696ad8af7d59edd37480aa3aa56e89878fd97/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfc696ad8af7d59edd37480aa3aa56e89878fd97/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=bfc696ad8af7d59edd37480aa3aa56e89878fd97", "patch": "@@ -61,15 +61,16 @@ pub struct Constraint {\n     point: Location,\n }\n \n-impl<'tcx> RegionInferenceContext<'tcx> {\n+impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n     /// Creates a new region inference context with a total of\n     /// `num_region_variables` valid inference variables; the first N\n     /// of those will be constant regions representing the free\n     /// regions defined in `free_regions`.\n-    pub fn new(free_regions: &FreeRegions<'tcx>,\n-               num_region_variables: usize,\n-               mir: &Mir<'tcx>)\n-               -> Self {\n+    pub fn new(\n+        free_regions: &FreeRegions<'tcx>,\n+        num_region_variables: usize,\n+        mir: &Mir<'tcx>,\n+    ) -> Self {\n         let mut result = Self {\n             definitions: (0..num_region_variables)\n                 .map(|_| RegionDefinition::default())\n@@ -83,33 +84,49 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         result\n     }\n \n-    fn init_free_regions(&mut self,\n-                         free_regions: &FreeRegions<'tcx>,\n-                         mir: &Mir<'tcx>)\n-    {\n-        let &FreeRegions { ref indices, ref free_region_map } = free_regions;\n-\n-        // For each free region variable X, it should contain:\n-        //\n-        // (a) the entire CFG\n-        // (b) `end(Y)` for all regions Y such that X: Y (or Y <= X)\n-        //\n-        // we add however the regions for clause (b) somewhat in\n-        // reverse, because of how the data structure in\n-        // `free_regions` is organized.\n+    /// Initializes the region variables for each free region\n+    /// (lifetime parameter). The first N variables always correspond\n+    /// to the free regions appearing in the function signature (both\n+    /// named and anonymous) and where clauses. This function iterates\n+    /// over those regions and initializes them with minimum values.\n+    ///\n+    /// For example:\n+    ///\n+    ///     fn foo<'a, 'b>(..) where 'a: 'b\n+    ///\n+    /// would initialize two variables like so:\n+    ///\n+    ///     R0 = { CFG, R0 } // 'a\n+    ///     R1 = { CFG, R0, R1 } // 'b\n+    ///\n+    /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n+    /// and (b) any free regions that it outlives, which in this case\n+    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n+    /// hence contains R0 and R1.\n+    fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) {\n+        let &FreeRegions {\n+            ref indices,\n+            ref free_region_map,\n+        } = free_regions;\n+\n+        // For each free region X:\n         for (free_region, index) in indices {\n             let variable = RegionIndex::new(*index);\n \n             self.free_regions.push(variable);\n \n+            // Initialize the name and a few other details.\n             self.definitions[variable].name = Some(free_region);\n             self.definitions[variable].constant = true;\n \n             // Add all nodes in the CFG to `definition.value`.\n             for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n                 let definition = &mut self.definitions[variable];\n-                for statement_index in 0 .. block_data.statements.len() + 1 {\n-                    let location = Location { block, statement_index };\n+                for statement_index in 0..block_data.statements.len() + 1 {\n+                    let location = Location {\n+                        block,\n+                        statement_index,\n+                    };\n                     definition.value.add_point(location);\n                 }\n             }\n@@ -121,13 +138,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // Y: X is true). Add `end(X)` into the set for `Y`.\n             for superregion in free_region_map.regions_that_outlive(&free_region) {\n                 let superregion_index = RegionIndex::new(indices[superregion]);\n-                self.definitions[superregion_index].value.add_free_region(variable);\n+                self.definitions[superregion_index]\n+                    .value\n+                    .add_free_region(variable);\n             }\n \n-            debug!(\"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n-                   free_region,\n-                   variable,\n-                   self.definitions[variable].value);\n+            debug!(\n+                \"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n+                free_region,\n+                variable,\n+                self.definitions[variable].value\n+            );\n         }\n     }\n \n@@ -157,15 +178,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Perform region inference.\n-    pub(super) fn solve<'a, 'gcx>(\n-        &mut self,\n-        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Mir<'tcx>,\n-    )\n-    where\n-        'gcx: 'tcx + 'a,\n-        'tcx: 'a,\n-    {\n+    pub(super) fn solve(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n+        self.propagate_constraints(infcx, mir);\n+    }\n+\n+    /// Propagate the region constraints: this will grow the values\n+    /// for each region variable until all the constraints are\n+    /// satisfied. Note that some values may grow **too** large to be\n+    /// feasible, but we check this later.\n+    fn propagate_constraints(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n         let mut changed = true;\n         let mut dfs = Dfs::new(infcx, mir);\n         while changed {"}]}