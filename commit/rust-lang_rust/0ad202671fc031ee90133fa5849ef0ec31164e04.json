{"sha": "0ad202671fc031ee90133fa5849ef0ec31164e04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZDIwMjY3MWZjMDMxZWU5MDEzM2ZhNTg0OWVmMGVjMzExNjRlMDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T13:04:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-12T13:04:14Z"}, "message": "Auto merge of #25171 - quantheory:associated_time_long_paths, r=nikomatsakis\n\nIt is currently broken to use syntax such as `<T as Foo>::U::static_method()` where `<T as Foo>::U` is an associated type. I was able to fix this and simplify the parser a bit at the same time.\r\n\r\nThis also fixes the corresponding issue with associated types (#22139), but that's somewhat irrelevant because #22519 is still open, so this syntax still causes an error in type checking.\r\n\r\nSimilarly, although this fix applies to associated consts, #25046 forbids associated constants from using type parameters or `Self`, while #19559 means that associated types have to always have one of those two. Therefore, I think that you can't use an associated const from an associated type anyway.", "tree": {"sha": "af36d232f138a45b160a67a6bc762059ea7b3619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af36d232f138a45b160a67a6bc762059ea7b3619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ad202671fc031ee90133fa5849ef0ec31164e04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad202671fc031ee90133fa5849ef0ec31164e04", "html_url": "https://github.com/rust-lang/rust/commit/0ad202671fc031ee90133fa5849ef0ec31164e04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ad202671fc031ee90133fa5849ef0ec31164e04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0", "html_url": "https://github.com/rust-lang/rust/commit/67dfc177f3c3236a73c7273dd0bf8be80bf1f5b0"}, {"sha": "efb3872a49df2d4ffe5bdc948d1d12637fa3ebd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/efb3872a49df2d4ffe5bdc948d1d12637fa3ebd1", "html_url": "https://github.com/rust-lang/rust/commit/efb3872a49df2d4ffe5bdc948d1d12637fa3ebd1"}], "stats": {"total": 128, "additions": 83, "deletions": 45}, "files": [{"sha": "447230ada2230fd8e454f6a4b9ed845dce30dd56", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ad202671fc031ee90133fa5849ef0ec31164e04/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad202671fc031ee90133fa5849ef0ec31164e04/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=0ad202671fc031ee90133fa5849ef0ec31164e04", "patch": "@@ -2688,18 +2688,21 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                    check_ribs: bool)\n                                    -> AssocItemResolveResult\n     {\n+        let max_assoc_types;\n+\n         match maybe_qself {\n-            Some(&ast::QSelf { position: 0, .. }) =>\n-                return TypecheckRequired,\n-            _ => {}\n+            Some(qself) => {\n+                if qself.position == 0 {\n+                    return TypecheckRequired;\n+                }\n+                max_assoc_types = path.segments.len() - qself.position;\n+                // Make sure the trait is valid.\n+                let _ = self.resolve_trait_reference(id, path, max_assoc_types);\n+            }\n+            None => {\n+                max_assoc_types = path.segments.len();\n+            }\n         }\n-        let max_assoc_types = if let Some(qself) = maybe_qself {\n-            // Make sure the trait is valid.\n-            let _ = self.resolve_trait_reference(id, path, 1);\n-            path.segments.len() - qself.position\n-        } else {\n-            path.segments.len()\n-        };\n \n         let mut resolution = self.with_no_errors(|this| {\n             this.resolve_path(id, path, 0, namespace, check_ribs)"}, {"sha": "541ec16b415d47ad6c22b1bc994568c0c1af4aaf", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0ad202671fc031ee90133fa5849ef0ec31164e04/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad202671fc031ee90133fa5849ef0ec31164e04/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0ad202671fc031ee90133fa5849ef0ec31164e04", "patch": "@@ -109,15 +109,6 @@ pub enum PathParsingMode {\n     LifetimeAndTypesWithColons,\n }\n \n-/// How to parse a qualified path, whether to allow trailing parameters.\n-#[derive(Copy, Clone, PartialEq)]\n-pub enum QPathParsingMode {\n-    /// No trailing parameters, e.g. `<T as Trait>::Item`\n-    NoParameters,\n-    /// Optional parameters, e.g. `<T as Trait>::item::<'a, U>`\n-    MaybeParameters,\n-}\n-\n /// How to parse a bound, whether to allow bound modifiers such as `?`.\n #[derive(Copy, Clone, PartialEq)]\n pub enum BoundParsingMode {\n@@ -1359,7 +1350,7 @@ impl<'a> Parser<'a> {\n         } else if try!(self.eat_lt()) {\n \n             let (qself, path) =\n-                 try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                 try!(self.parse_qualified_path(NoTypesAllowed));\n \n             TyPath(Some(qself), path)\n         } else if self.check(&token::ModSep) ||\n@@ -1578,7 +1569,7 @@ impl<'a> Parser<'a> {\n \n     // QUALIFIED PATH `<TYPE [as TRAIT_REF]>::IDENT[::<PARAMS>]`\n     // Assumes that the leading `<` has been parsed already.\n-    pub fn parse_qualified_path(&mut self, mode: QPathParsingMode)\n+    pub fn parse_qualified_path(&mut self, mode: PathParsingMode)\n                                 -> PResult<(QSelf, ast::Path)> {\n         let self_type = try!(self.parse_ty_sum());\n         let mut path = if try!(self.eat_keyword(keywords::As)) {\n@@ -1599,29 +1590,18 @@ impl<'a> Parser<'a> {\n         try!(self.expect(&token::Gt));\n         try!(self.expect(&token::ModSep));\n \n-        let item_name = try!(self.parse_ident());\n-        let parameters = match mode {\n-            QPathParsingMode::NoParameters => ast::PathParameters::none(),\n-            QPathParsingMode::MaybeParameters => {\n-                if try!(self.eat(&token::ModSep)) {\n-                    try!(self.expect_lt());\n-                    // Consumed `item::<`, go look for types\n-                    let (lifetimes, types, bindings) =\n-                        try!(self.parse_generic_values_after_lt());\n-                    ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n-                        lifetimes: lifetimes,\n-                        types: OwnedSlice::from_vec(types),\n-                        bindings: OwnedSlice::from_vec(bindings),\n-                    })\n-                } else {\n-                    ast::PathParameters::none()\n-                }\n+        let segments = match mode {\n+            LifetimeAndTypesWithoutColons => {\n+                try!(self.parse_path_segments_without_colons())\n+            }\n+            LifetimeAndTypesWithColons => {\n+                try!(self.parse_path_segments_with_colons())\n+            }\n+            NoTypesAllowed => {\n+                try!(self.parse_path_segments_without_types())\n             }\n         };\n-        path.segments.push(ast::PathSegment {\n-            identifier: item_name,\n-            parameters: parameters\n-        });\n+        path.segments.extend(segments);\n \n         if path.segments.len() == 1 {\n             path.span.lo = self.last_span.lo;\n@@ -2096,7 +2076,7 @@ impl<'a> Parser<'a> {\n                 if try!(self.eat_lt()){\n \n                     let (qself, path) =\n-                        try!(self.parse_qualified_path(QPathParsingMode::MaybeParameters));\n+                        try!(self.parse_qualified_path(LifetimeAndTypesWithColons));\n \n                     return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path)));\n                 }\n@@ -3176,7 +3156,7 @@ impl<'a> Parser<'a> {\n             let (qself, path) = if try!(self.eat_lt()) {\n                 // Parse a qualified path\n                 let (qself, path) =\n-                    try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                    try!(self.parse_qualified_path(NoTypesAllowed));\n                 (Some(qself), path)\n             } else {\n                 // Parse an unqualified path\n@@ -3270,7 +3250,7 @@ impl<'a> Parser<'a> {\n                     let (qself, path) = if try!(self.eat_lt()) {\n                         // Parse a qualified path\n                         let (qself, path) =\n-                            try!(self.parse_qualified_path(QPathParsingMode::NoParameters));\n+                            try!(self.parse_qualified_path(NoTypesAllowed));\n                         (Some(qself), path)\n                     } else {\n                         // Parse an unqualified path"}, {"sha": "4ad0187df7a8f4cea80e21963857ad3eb55a27bd", "filename": "src/test/run-pass/associated-item-long-paths.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0ad202671fc031ee90133fa5849ef0ec31164e04/src%2Ftest%2Frun-pass%2Fassociated-item-long-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ad202671fc031ee90133fa5849ef0ec31164e04/src%2Ftest%2Frun-pass%2Fassociated-item-long-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-item-long-paths.rs?ref=0ad202671fc031ee90133fa5849ef0ec31164e04", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::mem::size_of;\n+\n+// The main point of this test is to ensure that we can parse and resolve\n+// associated items on associated types.\n+\n+trait Foo {\n+    type U;\n+}\n+\n+trait Bar {\n+    // Note 1: Chains of associated items in a path won't type-check.\n+    // Note 2: Associated consts can't depend on type parameters or `Self`,\n+    // which are the only types that an associated type can be referenced on for\n+    // now, so we can only test methods.\n+    fn method() -> u32;\n+    fn generic_method<T>() -> usize;\n+}\n+\n+struct MyFoo;\n+struct MyBar;\n+\n+impl Foo for MyFoo {\n+    type U = MyBar;\n+}\n+\n+impl Bar for MyBar {\n+    fn method() -> u32 {\n+        2u32\n+    }\n+    fn generic_method<T>() -> usize {\n+        size_of::<T>()\n+    }\n+}\n+\n+fn foo<T>()\n+    where T: Foo,\n+          T::U: Bar,\n+{\n+    assert_eq!(2u32, <T as Foo>::U::method());\n+    assert_eq!(8usize, <T as Foo>::U::generic_method::<f64>());\n+}\n+\n+fn main() {\n+    foo::<MyFoo>();\n+}"}]}