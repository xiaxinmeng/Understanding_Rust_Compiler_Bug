{"sha": "b53020a5f4e031371a0f6de4b47b67d822195923", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzAyMGE1ZjRlMDMxMzcxYTBmNmRlNGI0N2I2N2Q4MjIxOTU5MjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-11T05:47:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-11T05:47:13Z"}, "message": "Auto merge of #29744 - sanxiyn:modernize, r=nrc", "tree": {"sha": "e0a8a01a4efd1c5b14130b63a5308e606c746a77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a8a01a4efd1c5b14130b63a5308e606c746a77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b53020a5f4e031371a0f6de4b47b67d822195923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b53020a5f4e031371a0f6de4b47b67d822195923", "html_url": "https://github.com/rust-lang/rust/commit/b53020a5f4e031371a0f6de4b47b67d822195923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b53020a5f4e031371a0f6de4b47b67d822195923/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e82b397680a524b57109490fec0ecefcec5a325", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e82b397680a524b57109490fec0ecefcec5a325", "html_url": "https://github.com/rust-lang/rust/commit/7e82b397680a524b57109490fec0ecefcec5a325"}, {"sha": "dfc314d19b584b0631ab787b613a55f2a73ebe45", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfc314d19b584b0631ab787b613a55f2a73ebe45", "html_url": "https://github.com/rust-lang/rust/commit/dfc314d19b584b0631ab787b613a55f2a73ebe45"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "571f950643792012d4b37a5a6c56a243aa8c7487", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -67,7 +67,7 @@ pub trait AttrMetaMethods {\n     /// containing a string, otherwise None.\n     fn value_str(&self) -> Option<InternedString>;\n     /// Gets a list of inner meta items from a list MetaItem type.\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]>;\n+    fn meta_item_list(&self) -> Option<&[P<MetaItem>]>;\n \n     fn span(&self) -> Span;\n }\n@@ -84,7 +84,7 @@ impl AttrMetaMethods for Attribute {\n     fn value_str(&self) -> Option<InternedString> {\n         self.meta().value_str()\n     }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n+    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n         self.node.value.meta_item_list()\n     }\n     fn span(&self) -> Span { self.meta().span }\n@@ -111,7 +111,7 @@ impl AttrMetaMethods for MetaItem {\n         }\n     }\n \n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n+    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n         match self.node {\n             MetaList(_, ref l) => Some(&l[..]),\n             _ => None\n@@ -124,22 +124,22 @@ impl AttrMetaMethods for MetaItem {\n impl AttrMetaMethods for P<MetaItem> {\n     fn name(&self) -> InternedString { (**self).name() }\n     fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n-    fn meta_item_list<'a>(&'a self) -> Option<&'a [P<MetaItem>]> {\n+    fn meta_item_list(&self) -> Option<&[P<MetaItem>]> {\n         (**self).meta_item_list()\n     }\n     fn span(&self) -> Span { (**self).span() }\n }\n \n \n pub trait AttributeMethods {\n-    fn meta<'a>(&'a self) -> &'a MetaItem;\n+    fn meta(&self) -> &MetaItem;\n     fn with_desugared_doc<T, F>(&self, f: F) -> T where\n         F: FnOnce(&Attribute) -> T;\n }\n \n impl AttributeMethods for Attribute {\n     /// Extract the MetaItem from inside this Attribute.\n-    fn meta<'a>(&'a self) -> &'a MetaItem {\n+    fn meta(&self) -> &MetaItem {\n         &*self.node.value\n     }\n "}, {"sha": "10731178c0610fb85f7d02c62f712b2d8b430430", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -86,7 +86,7 @@ fn filter_foreign_item<F>(cx: &mut Context<F>,\n                           -> Option<P<ast::ForeignItem>> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    if foreign_item_in_cfg(cx, &*item) {\n+    if foreign_item_in_cfg(cx, &item) {\n         Some(item)\n     } else {\n         None\n@@ -109,7 +109,7 @@ fn fold_foreign_mod<F>(cx: &mut Context<F>,\n fn fold_item<F>(cx: &mut Context<F>, item: P<ast::Item>) -> SmallVector<P<ast::Item>> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    if item_in_cfg(cx, &*item) {\n+    if item_in_cfg(cx, &item) {\n         SmallVector::one(item.map(|i| cx.fold_item_simple(i)))\n     } else {\n         SmallVector::zero()\n@@ -189,7 +189,7 @@ fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n         ast::StmtDecl(ref decl, _) => {\n             match decl.node {\n                 ast::DeclItem(ref item) => {\n-                    item_in_cfg(cx, &**item)\n+                    item_in_cfg(cx, item)\n                 }\n                 _ => true\n             }\n@@ -203,7 +203,7 @@ fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n {\n     b.map(|ast::Block {id, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n-            stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n+            stmts.into_iter().filter(|a| retain_stmt(cx, a)).collect();\n         let resulting_stmts = resulting_stmts.into_iter()\n             .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n             .collect();\n@@ -263,7 +263,7 @@ fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attr\n             return true;\n         }\n \n-        attr::cfg_matches(diagnostic, cfg, &*mis[0],\n+        attr::cfg_matches(diagnostic, cfg, &mis[0],\n                           feature_gated_cfgs)\n     })\n }"}, {"sha": "3f925c9d7bae699af3076a72f63d11f528565f9f", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -881,7 +881,7 @@ impl SyntaxEnv {\n         self.chain.pop();\n     }\n \n-    fn find_escape_frame<'a>(&'a mut self) -> &'a mut MapChainFrame {\n+    fn find_escape_frame(&mut self) -> &mut MapChainFrame {\n         for (i, frame) in self.chain.iter_mut().enumerate().rev() {\n             if !frame.info.macros_escape || i == 0 {\n                 return frame\n@@ -904,7 +904,7 @@ impl SyntaxEnv {\n         self.find_escape_frame().map.insert(k, Rc::new(v));\n     }\n \n-    pub fn info<'a>(&'a mut self) -> &'a mut BlockInfo {\n+    pub fn info(&mut self) -> &mut BlockInfo {\n         let last_chain_index = self.chain.len() - 1;\n         &mut self.chain[last_chain_index].info\n     }"}, {"sha": "48199026204c8968789d3bf67feeb1c26bdd701d", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -33,7 +33,7 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &*cfg,\n+    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &cfg,\n                                         cx.feature_gated_cfgs);\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "ba07c452e2a593ad303e81fc3d33ca7f4e94888b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -547,7 +547,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n                     // generate fresh names, push them to a new pending list\n-                    let idents = pattern_bindings(&*expanded_pat);\n+                    let idents = pattern_bindings(&expanded_pat);\n                     let mut new_pending_renames =\n                         idents.iter().map(|ident| (*ident, fresh_name(*ident))).collect();\n                     // rewrite the pattern using the new names (the old\n@@ -634,7 +634,7 @@ fn rename_in_scope<X, F>(pats: Vec<P<ast::Pat>>,\n {\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n-    let idents = pattern_bindings(&*pats[0]);\n+    let idents = pattern_bindings(&pats[0]);\n     let new_renames = idents.into_iter().map(|id| (id, fresh_name(id))).collect();\n     // apply the renaming, but only to the PatIdents:\n     let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n@@ -659,7 +659,7 @@ impl<'v> Visitor<'v> for PatIdentFinder {\n                 self.ident_accumulator.push(path1.node);\n                 // visit optional subpattern of PatIdent:\n                 if let Some(ref subpat) = *inner {\n-                    self.visit_pat(&**subpat)\n+                    self.visit_pat(subpat)\n                 }\n             }\n             // use the default traversal for non-PatIdents\n@@ -679,7 +679,7 @@ fn pattern_bindings(pat: &ast::Pat) -> Vec<ast::Ident> {\n fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n     let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n     for arg in &fn_decl.inputs {\n-        pat_idents.visit_pat(&*arg.pat);\n+        pat_idents.visit_pat(&arg.pat);\n     }\n     pat_idents.ident_accumulator\n }\n@@ -1078,7 +1078,7 @@ fn expand_and_rename_fn_decl_and_block(fn_decl: P<ast::FnDecl>, block: P<ast::Bl\n                                        fld: &mut MacroExpander)\n                                        -> (P<ast::FnDecl>, P<ast::Block>) {\n     let expanded_decl = fld.fold_fn_decl(fn_decl);\n-    let idents = fn_decl_arg_bindings(&*expanded_decl);\n+    let idents = fn_decl_arg_bindings(&expanded_decl);\n     let renames =\n         idents.iter().map(|id| (*id,fresh_name(*id))).collect();\n     // first, a renamer for the PatIdents, for the fn_decl:\n@@ -1807,7 +1807,7 @@ foo_module!();\n     fn pat_idents(){\n         let pat = string_to_pat(\n             \"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\".to_string());\n-        let idents = pattern_bindings(&*pat);\n+        let idents = pattern_bindings(&pat);\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"c\",\"b\",\"d\")));\n     }\n "}, {"sha": "35853256651db11f7d2461c0f1e360b1a0cecbf7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -289,7 +289,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n     };\n \n     for lhs in &lhses {\n-        check_lhs_nt_follows(cx, &**lhs, def.span);\n+        check_lhs_nt_follows(cx, lhs, def.span);\n     }\n \n     let rhses = match **argument_map.get(&rhs_nm.name).unwrap() {"}, {"sha": "284bf46cc3fcd37e37d522fb692e82d254b1b6e2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -673,7 +673,7 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n             token::NtIdent(Box::new(fld.fold_ident(*id)), is_mod_name),\n         token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n         token::NtPath(path) => token::NtPath(Box::new(fld.fold_path(*path))),\n-        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n+        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&tt))),\n         token::NtArm(arm) => token::NtArm(fld.fold_arm(arm)),\n         token::NtImplItem(arm) =>\n             token::NtImplItem(fld.fold_impl_item(arm)"}, {"sha": "8b3faaaca146a9d7d512201b7f4cade3ce3fef65", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -53,7 +53,7 @@ pub fn stmt_ends_with_semi(stmt: &ast::Stmt_) -> bool {\n                 ast::DeclItem(_) => false\n             }\n         }\n-        ast::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(&**e) }\n+        ast::StmtExpr(ref e, _) => { expr_requires_semi_to_be_stmt(e) }\n         ast::StmtSemi(..) => { false }\n         ast::StmtMac(..) => { false }\n     }"}, {"sha": "bf65f82554b0376cbd8ace3d94aa48d88909bfad", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -446,10 +446,10 @@ fn filtered_float_lit(data: token::InternedString, suffix: Option<&str>,\n         Some(suf) => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n-                sd.span_err(sp, &*format!(\"invalid width `{}` for float literal\", &suf[1..]));\n+                sd.span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]));\n                 sd.fileline_help(sp, \"valid widths are 32 and 64\");\n             } else {\n-                sd.span_err(sp, &*format!(\"invalid suffix `{}` for float literal\", suf));\n+                sd.span_err(sp, &format!(\"invalid suffix `{}` for float literal\", suf));\n                 sd.fileline_help(sp, \"valid suffixes are `f32` and `f64`\");\n             }\n \n@@ -619,11 +619,11 @@ pub fn integer_lit(s: &str,\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n-                    sd.span_err(sp, &*format!(\"invalid width `{}` for integer literal\",\n-                                              &suf[1..]));\n+                    sd.span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n+                                             &suf[1..]));\n                     sd.fileline_help(sp, \"valid widths are 8, 16, 32 and 64\");\n                 } else {\n-                    sd.span_err(sp, &*format!(\"invalid suffix `{}` for numeric literal\", suf));\n+                    sd.span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf));\n                     sd.fileline_help(sp, \"the suffix must be one of the integral types \\\n                                       (`u32`, `isize`, etc)\");\n                 }"}, {"sha": "9d53cb969269fa992b79bb499716ce49cbed3751", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53020a5f4e031371a0f6de4b47b67d822195923/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=b53020a5f4e031371a0f6de4b47b67d822195923", "patch": "@@ -58,7 +58,7 @@ impl<T> SmallVector<T> {\n         SmallVector { repr: Many(vs) }\n     }\n \n-    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+    pub fn as_slice(&self) -> &[T] {\n         match self.repr {\n             Zero => {\n                 let result: &[T] = &[];\n@@ -105,7 +105,7 @@ impl<T> SmallVector<T> {\n         }\n     }\n \n-    pub fn get<'a>(&'a self, idx: usize) -> &'a T {\n+    pub fn get(&self, idx: usize) -> &T {\n         match self.repr {\n             One(ref v) if idx == 0 => v,\n             Many(ref vs) => &vs[idx],"}]}