{"sha": "7631b12e3e820f00780fff345019436d36158159", "node_id": "C_kwDOAAsO6NoAKDc2MzFiMTJlM2U4MjBmMDA3ODBmZmYzNDUwMTk0MzZkMzYxNTgxNTk", "commit": {"author": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2022-10-18T16:03:12Z"}, "committer": {"name": "Xiretza", "email": "xiretza@xiretza.xyz", "date": "2023-02-01T20:56:27Z"}, "message": "migrate parser::ty to diagnostic structs", "tree": {"sha": "23f9d21f6ea92c071187e3a53d04016ee3330cb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23f9d21f6ea92c071187e3a53d04016ee3330cb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7631b12e3e820f00780fff345019436d36158159", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7631b12e3e820f00780fff345019436d36158159", "html_url": "https://github.com/rust-lang/rust/commit/7631b12e3e820f00780fff345019436d36158159", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7631b12e3e820f00780fff345019436d36158159/comments", "author": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Xiretza", "id": 3107142, "node_id": "MDQ6VXNlcjMxMDcxNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3107142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Xiretza", "html_url": "https://github.com/Xiretza", "followers_url": "https://api.github.com/users/Xiretza/followers", "following_url": "https://api.github.com/users/Xiretza/following{/other_user}", "gists_url": "https://api.github.com/users/Xiretza/gists{/gist_id}", "starred_url": "https://api.github.com/users/Xiretza/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Xiretza/subscriptions", "organizations_url": "https://api.github.com/users/Xiretza/orgs", "repos_url": "https://api.github.com/users/Xiretza/repos", "events_url": "https://api.github.com/users/Xiretza/events{/privacy}", "received_events_url": "https://api.github.com/users/Xiretza/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9564a30c194ab7324bb528b817c08a8f760d4c71", "url": "https://api.github.com/repos/rust-lang/rust/commits/9564a30c194ab7324bb528b817c08a8f760d4c71", "html_url": "https://github.com/rust-lang/rust/commit/9564a30c194ab7324bb528b817c08a8f760d4c71"}], "stats": {"total": 261, "additions": 176, "deletions": 85}, "files": [{"sha": "91902081d90453c15867f9761939ffe9bb77b10f", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7631b12e3e820f00780fff345019436d36158159/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7631b12e3e820f00780fff345019436d36158159/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=7631b12e3e820f00780fff345019436d36158159", "patch": "@@ -539,3 +539,38 @@ parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `...`\n     .suggestion = to omit remaining fields, use one fewer `.`\n \n parse_expected_comma_after_pattern_field = expected `,`\n+\n+parse_return_types_use_thin_arrow = return types are denoted using `->`\n+    .suggestion = use `->` instead\n+\n+parse_need_plus_after_trait_object_lifetime = lifetime in trait object type must be followed by `+`\n+\n+parse_expected_mut_or_const_in_raw_pointer_type = expected `mut` or `const` keyword in raw pointer type\n+    .suggestion = add `mut` or `const` here\n+\n+parse_lifetime_after_mut = lifetime must precede `mut`\n+    .suggestion = place the lifetime before `mut`\n+\n+parse_dyn_after_mut = `mut` must precede `dyn`\n+    .suggestion = place `mut` before `dyn`\n+\n+parse_fn_pointer_cannot_be_const = an `fn` pointer type cannot be `const`\n+    .label = `const` because of this\n+    .suggestion = remove the `const` qualifier\n+\n+parse_fn_pointer_cannot_be_async = an `fn` pointer type cannot be `async`\n+    .label = `async` because of this\n+    .suggestion = remove the `async` qualifier\n+\n+parse_nested_c_variadic_type = C-variadic type `...` may not be nested inside another type\n+\n+parse_invalid_dyn_keyword = invalid `dyn` keyword\n+    .help = `dyn` is only needed at the start of a trait `+`-separated list\n+    .suggestion = remove this keyword\n+\n+parse_negative_bounds_not_supported = negative bounds are not supported\n+    .label = negative bounds are not supported\n+    .suggestion = {$num_bounds ->\n+            [one] remove the bound\n+           *[other] remove the bounds\n+        }"}, {"sha": "1abd7577d92c9c2557b2d71c2b9a252516cdec0f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7631b12e3e820f00780fff345019436d36158159/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7631b12e3e820f00780fff345019436d36158159/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=7631b12e3e820f00780fff345019436d36158159", "patch": "@@ -1845,3 +1845,106 @@ pub(crate) struct ExpectedCommaAfterPatternField {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_return_types_use_thin_arrow)]\n+pub(crate) struct ReturnTypesUseThinArrow {\n+    #[primary_span]\n+    #[suggestion(style = \"short\", code = \"->\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_need_plus_after_trait_object_lifetime)]\n+pub(crate) struct NeedPlusAfterTraitObjectLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_expected_mut_or_const_in_raw_pointer_type)]\n+pub(crate) struct ExpectedMutOrConstInRawPointerType {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code(\"mut \", \"const \"), applicability = \"has-placeholders\")]\n+    pub after_asterisk: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_lifetime_after_mut)]\n+pub(crate) struct LifetimeAfterMut {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"&{snippet} mut\", applicability = \"maybe-incorrect\")]\n+    pub suggest_lifetime: Option<Span>,\n+    pub snippet: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_dyn_after_mut)]\n+pub(crate) struct DynAfterMut {\n+    #[primary_span]\n+    #[suggestion(code = \"&mut dyn\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_fn_pointer_cannot_be_const)]\n+pub(crate) struct FnPointerCannotBeConst {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    #[label]\n+    pub qualifier: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_fn_pointer_cannot_be_async)]\n+pub(crate) struct FnPointerCannotBeAsync {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    #[label]\n+    pub qualifier: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_nested_c_variadic_type, code = \"E0743\")]\n+pub(crate) struct NestedCVariadicType {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_invalid_dyn_keyword)]\n+#[help]\n+pub(crate) struct InvalidDynKeyword {\n+    #[primary_span]\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_negative_bounds_not_supported)]\n+pub(crate) struct NegativeBoundsNotSupported {\n+    #[primary_span]\n+    pub negative_bounds: Vec<Span>,\n+    #[label]\n+    pub last_span: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<NegativeBoundsNotSupportedSugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(\n+    suggestion,\n+    style = \"tool-only\",\n+    code = \"{fixed}\",\n+    applicability = \"machine-applicable\"\n+)]\n+pub(crate) struct NegativeBoundsNotSupportedSugg {\n+    #[primary_span]\n+    pub bound_list: Span,\n+    pub num_bounds: usize,\n+    pub fixed: String,\n+}"}, {"sha": "306cbcff149f7d5327c66e9cc397142811ad6281", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 38, "deletions": 85, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7631b12e3e820f00780fff345019436d36158159/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7631b12e3e820f00780fff345019436d36158159/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=7631b12e3e820f00780fff345019436d36158159", "patch": "@@ -1,6 +1,12 @@\n use super::{Parser, PathStyle, TokenType};\n \n-use crate::errors::{ExpectedFnPathFoundFnKeyword, FnPtrWithGenerics, FnPtrWithGenericsSugg};\n+use crate::errors::{\n+    DynAfterMut, ExpectedFnPathFoundFnKeyword, ExpectedMutOrConstInRawPointerType,\n+    FnPointerCannotBeAsync, FnPointerCannotBeConst, FnPtrWithGenerics, FnPtrWithGenericsSugg,\n+    InvalidDynKeyword, LifetimeAfterMut, NeedPlusAfterTraitObjectLifetime,\n+    NegativeBoundsNotSupported, NegativeBoundsNotSupportedSugg, NestedCVariadicType,\n+    ReturnTypesUseThinArrow,\n+};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n \n use ast::DUMMY_NODE_ID;\n@@ -12,7 +18,7 @@ use rustc_ast::{\n     MacCall, MutTy, Mutability, PolyTraitRef, TraitBoundModifier, TraitObjectSyntax, Ty, TyKind,\n };\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, PResult};\n+use rustc_errors::{Applicability, PResult};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -233,14 +239,7 @@ impl<'a> Parser<'a> {\n             // Don't `eat` to prevent `=>` from being added as an expected token which isn't\n             // actually expected and could only confuse users\n             self.bump();\n-            self.struct_span_err(self.prev_token.span, \"return types are denoted using `->`\")\n-                .span_suggestion_short(\n-                    self.prev_token.span,\n-                    \"use `->` instead\",\n-                    \"->\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(ReturnTypesUseThinArrow { span: self.prev_token.span });\n             let ty = self.parse_ty_common(\n                 allow_plus,\n                 AllowCVariadic::No,\n@@ -328,7 +327,7 @@ impl<'a> Parser<'a> {\n                 AllowCVariadic::No => {\n                     // FIXME(Centril): Should we just allow `...` syntactically\n                     // anywhere in a type and use semantic restrictions instead?\n-                    self.error_illegal_c_varadic_ty(lo);\n+                    self.sess.emit_err(NestedCVariadicType { span: lo.to(self.prev_token.span) });\n                     TyKind::Err\n                 }\n             }\n@@ -431,8 +430,7 @@ impl<'a> Parser<'a> {\n         let lt_no_plus = self.check_lifetime() && !self.look_ahead(1, |t| t.is_like_plus());\n         let bounds = self.parse_generic_bounds_common(allow_plus, None)?;\n         if lt_no_plus {\n-            self.struct_span_err(lo, \"lifetime in trait object type must be followed by `+`\")\n-                .emit();\n+            self.sess.emit_err(NeedPlusAfterTraitObjectLifetime { span: lo });\n         }\n         Ok(TyKind::TraitObject(bounds, TraitObjectSyntax::None))\n     }\n@@ -466,14 +464,10 @@ impl<'a> Parser<'a> {\n     fn parse_ty_ptr(&mut self) -> PResult<'a, TyKind> {\n         let mutbl = self.parse_const_or_mut().unwrap_or_else(|| {\n             let span = self.prev_token.span;\n-            self.struct_span_err(span, \"expected `mut` or `const` keyword in raw pointer type\")\n-                .span_suggestions(\n-                    span.shrink_to_hi(),\n-                    \"add `mut` or `const` here\",\n-                    [\"mut \".to_string(), \"const \".to_string()],\n-                    Applicability::HasPlaceholders,\n-                )\n-                .emit();\n+            self.sess.emit_err(ExpectedMutOrConstInRawPointerType {\n+                span,\n+                after_asterisk: span.shrink_to_hi(),\n+            });\n             Mutability::Not\n         });\n         let ty = self.parse_ty_no_plus()?;\n@@ -528,16 +522,13 @@ impl<'a> Parser<'a> {\n                 let lifetime_span = self.token.span;\n                 let span = and_span.to(lifetime_span);\n \n-                let mut err = self.struct_span_err(span, \"lifetime must precede `mut`\");\n-                if let Ok(lifetime_src) = self.span_to_snippet(lifetime_span) {\n-                    err.span_suggestion(\n-                        span,\n-                        \"place the lifetime before `mut`\",\n-                        format!(\"&{} mut\", lifetime_src),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n-                err.emit();\n+                let (suggest_lifetime, snippet) =\n+                    if let Ok(lifetime_src) = self.span_to_snippet(lifetime_span) {\n+                        (Some(span), lifetime_src)\n+                    } else {\n+                        (None, String::new())\n+                    };\n+                self.sess.emit_err(LifetimeAfterMut { span, suggest_lifetime, snippet });\n \n                 opt_lifetime = Some(self.expect_lifetime());\n             }\n@@ -547,14 +538,7 @@ impl<'a> Parser<'a> {\n         {\n             // We have `&dyn mut ...`, which is invalid and should be `&mut dyn ...`.\n             let span = and_span.to(self.look_ahead(1, |t| t.span));\n-            let mut err = self.struct_span_err(span, \"`mut` must precede `dyn`\");\n-            err.span_suggestion(\n-                span,\n-                \"place `mut` before `dyn`\",\n-                \"&mut dyn\",\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.sess.emit_err(DynAfterMut { span });\n \n             // Recovery\n             mutbl = Mutability::Mut;\n@@ -608,10 +592,10 @@ impl<'a> Parser<'a> {\n             // If we ever start to allow `const fn()`, then update\n             // feature gating for `#![feature(const_extern_fn)]` to\n             // cover it.\n-            self.error_fn_ptr_bad_qualifier(whole_span, span, \"const\");\n+            self.sess.emit_err(FnPointerCannotBeConst { span: whole_span, qualifier: span });\n         }\n         if let ast::Async::Yes { span, .. } = asyncness {\n-            self.error_fn_ptr_bad_qualifier(whole_span, span, \"async\");\n+            self.sess.emit_err(FnPointerCannotBeAsync { span: whole_span, qualifier: span });\n         }\n         let decl_span = span_start.to(self.token.span);\n         Ok(TyKind::BareFn(P(BareFnTy { ext, unsafety, generic_params: params, decl, decl_span })))\n@@ -659,19 +643,6 @@ impl<'a> Parser<'a> {\n         Ok(())\n     }\n \n-    /// Emit an error for the given bad function pointer qualifier.\n-    fn error_fn_ptr_bad_qualifier(&self, span: Span, qual_span: Span, qual: &str) {\n-        self.struct_span_err(span, &format!(\"an `fn` pointer type cannot be `{}`\", qual))\n-            .span_label(qual_span, format!(\"`{}` because of this\", qual))\n-            .span_suggestion_short(\n-                qual_span,\n-                &format!(\"remove the `{}` qualifier\", qual),\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            )\n-            .emit();\n-    }\n-\n     /// Parses an `impl B0 + ... + Bn` type.\n     fn parse_impl_ty(&mut self, impl_dyn_multi: &mut bool) -> PResult<'a, TyKind> {\n         // Always parse bounds greedily for better error recovery.\n@@ -758,16 +729,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn error_illegal_c_varadic_ty(&self, lo: Span) {\n-        struct_span_err!(\n-            self.sess.span_diagnostic,\n-            lo.to(self.prev_token.span),\n-            E0743,\n-            \"C-variadic type `...` may not be nested inside another type\",\n-        )\n-        .emit();\n-    }\n-\n     pub(super) fn parse_generic_bounds(\n         &mut self,\n         colon_span: Option<Span>,\n@@ -797,15 +758,7 @@ impl<'a> Parser<'a> {\n         {\n             if self.token.is_keyword(kw::Dyn) {\n                 // Account for `&dyn Trait + dyn Other`.\n-                self.struct_span_err(self.token.span, \"invalid `dyn` keyword\")\n-                    .help(\"`dyn` is only needed at the start of a trait `+`-separated list\")\n-                    .span_suggestion(\n-                        self.token.span,\n-                        \"remove this keyword\",\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit();\n+                self.sess.emit_err(InvalidDynKeyword { span: self.token.span });\n                 self.bump();\n             }\n             match self.parse_generic_bound()? {\n@@ -842,11 +795,7 @@ impl<'a> Parser<'a> {\n         bounds: &[GenericBound],\n         negative_bounds: Vec<Span>,\n     ) {\n-        let negative_bounds_len = negative_bounds.len();\n-        let last_span = *negative_bounds.last().expect(\"no negative bounds, but still error?\");\n-        let mut err = self.struct_span_err(negative_bounds, \"negative bounds are not supported\");\n-        err.span_label(last_span, \"negative bounds are not supported\");\n-        if let Some(bound_list) = colon_span {\n+        let sub = if let Some(bound_list) = colon_span {\n             let bound_list = bound_list.to(self.prev_token.span);\n             let mut new_bound_list = String::new();\n             if !bounds.is_empty() {\n@@ -857,14 +806,18 @@ impl<'a> Parser<'a> {\n                 }\n                 new_bound_list = new_bound_list.replacen(\" +\", \":\", 1);\n             }\n-            err.tool_only_span_suggestion(\n+\n+            Some(NegativeBoundsNotSupportedSugg {\n                 bound_list,\n-                &format!(\"remove the bound{}\", pluralize!(negative_bounds_len)),\n-                new_bound_list,\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        err.emit();\n+                num_bounds: negative_bounds.len(),\n+                fixed: new_bound_list,\n+            })\n+        } else {\n+            None\n+        };\n+\n+        let last_span = *negative_bounds.last().expect(\"no negative bounds, but still error?\");\n+        self.sess.emit_err(NegativeBoundsNotSupported { negative_bounds, last_span, sub });\n     }\n \n     /// Parses a bound according to the grammar:"}]}