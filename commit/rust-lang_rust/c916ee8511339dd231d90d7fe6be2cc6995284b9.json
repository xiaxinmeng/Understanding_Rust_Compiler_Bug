{"sha": "c916ee8511339dd231d90d7fe6be2cc6995284b9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTZlZTg1MTEzMzlkZDIzMWQ5MGQ3ZmU2YmUyY2M2OTk1Mjg0Yjk=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-04-05T21:21:47Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-04-30T17:45:18Z"}, "message": "Removed direct field usage of RangeInclusive in rustc itself.", "tree": {"sha": "3764919ae310d2657c4c6e5009dd7c4c8265c7ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3764919ae310d2657c4c6e5009dd7c4c8265c7ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c916ee8511339dd231d90d7fe6be2cc6995284b9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlrnVi4ACgkQ/vbIBR0O\nATwnvw/9EBDx0X6IGbIYv2KNo/tpzeYBDVSOq0xO73L2gYg35j5b8EMqHxMBtDXY\nlnec0DkkL6hRUV/h6NYzUlgZn0WNjdS8lMXBN9ufv7ZSc3UXdB9AMkY+GaAGgCnY\n0tHRgQRk3d8WpV/yLKrTe/W6lKKfLr22VGeSMthz3yNCyPZQMzShkoyeHSUbuZm4\nyxAjVpUnzbmePfpvj/AbcmXo3Bf+HUHIXF/fJe2DuzA2g+rYaT32rIq8Jv/S/Cay\nFnpnngjeapui83z9QRnLHuVPbMwFZGaE+1QDUxMgascOdYgjgG7yqp3P8z9cZAc7\ntSJQHCA8iEwlI0JslzhAzjSInbJ0CBBPYxBGwAglPqw7KYtxtdbeBt/PzL3dtf2b\nx83DEsPwWK3SpMKfNe9JhA0AMd5zy908WsWLvb+IQX1fKIFiLqiZSHpJ4ZBD/IUU\nN5/wvYscm9nkWaejahhBxbo7I73u7QH2Ohec3r7BWNE4IUg+Jo9RDtb+KuCYSSkO\n+9jgDY76Imye80FHFIu5WccGIdV6YtHSbZSGB5QY4hjPhZOGu6OeT1PdstZ9biKw\nwRWybprBHVuTim0bYg6QH3ppM8DmuP7pGDHCS+Hpx9psL9dAc3RqKSqD6qlsgZXg\nU2CNFXmRJ44XbBVaHPSiewtNg7QTX4YhNbbOQqcw5rj9d1xjPt4=\n=Iw8F\n-----END PGP SIGNATURE-----", "payload": "tree 3764919ae310d2657c4c6e5009dd7c4c8265c7ec\nparent fba903a435ea6e0e3736541cb487586262835e48\nauthor kennytm <kennytm@gmail.com> 1522963307 +0800\ncommitter kennytm <kennytm@gmail.com> 1525110318 +0800\n\nRemoved direct field usage of RangeInclusive in rustc itself.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c916ee8511339dd231d90d7fe6be2cc6995284b9", "html_url": "https://github.com/rust-lang/rust/commit/c916ee8511339dd231d90d7fe6be2cc6995284b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c916ee8511339dd231d90d7fe6be2cc6995284b9/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba903a435ea6e0e3736541cb487586262835e48", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba903a435ea6e0e3736541cb487586262835e48", "html_url": "https://github.com/rust-lang/rust/commit/fba903a435ea6e0e3736541cb487586262835e48"}], "stats": {"total": 93, "additions": 45, "deletions": 48}, "files": [{"sha": "5a6e0050835b56a70cecfbf6c28a18d0ddbfeb92", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -103,6 +103,7 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(doc_alias)]\n+#![feature(inclusive_range_methods)]\n \n #![cfg_attr(not(stage0), feature(mmx_target_feature))]\n #![cfg_attr(not(stage0), feature(tbm_target_feature))]"}, {"sha": "59ee40fdda4f6242db5afdbba3e549f018695bb0", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -318,7 +318,7 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// # Examples\n ///\n /// ```\n-/// #![feature(inclusive_range_fields)]\n+/// #![feature(inclusive_range_methods)]\n ///\n /// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());"}, {"sha": "d66193b1687c86c921687f589862cbbf2cd94815", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -50,21 +50,21 @@ fn test_full_range() {\n \n #[test]\n fn test_range_inclusive() {\n-    let mut r = RangeInclusive { start: 1i8, end: 2 };\n+    let mut r = RangeInclusive::new(1i8, 2);\n     assert_eq!(r.next(), Some(1));\n     assert_eq!(r.next(), Some(2));\n     assert_eq!(r.next(), None);\n \n-    r = RangeInclusive { start: 127i8, end: 127 };\n+    r = RangeInclusive::new(127i8, 127);\n     assert_eq!(r.next(), Some(127));\n     assert_eq!(r.next(), None);\n \n-    r = RangeInclusive { start: -128i8, end: -128 };\n+    r = RangeInclusive::new(-128i8, -128);\n     assert_eq!(r.next_back(), Some(-128));\n     assert_eq!(r.next_back(), None);\n \n     // degenerate\n-    r = RangeInclusive { start: 1, end: -1 };\n+    r = RangeInclusive::new(1, -1);\n     assert_eq!(r.size_hint(), (0, Some(0)));\n     assert_eq!(r.next(), None);\n }"}, {"sha": "9dc9fb1144efa07a8ab3db23f0b66de2eca5c0d6", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -69,7 +69,7 @@\n #![feature(trusted_len)]\n #![feature(catch_expr)]\n #![feature(test)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "47b52cacd56bd846e55f8ae7760b5e777082cc69", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -19,7 +19,6 @@ use std::cmp;\n use std::fmt;\n use std::i128;\n use std::mem;\n-use std::ops::RangeInclusive;\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -492,7 +491,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyFloat(FloatTy::F64) => scalar(F64),\n             ty::TyFnPtr(_) => {\n                 let mut ptr = scalar_unit(Pointer);\n-                ptr.valid_range.start = 1;\n+                ptr.valid_range = 1..=*ptr.valid_range.end();\n                 tcx.intern_layout(LayoutDetails::scalar(self, ptr))\n             }\n \n@@ -506,7 +505,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n                 let mut data_ptr = scalar_unit(Pointer);\n                 if !ty.is_unsafe_ptr() {\n-                    data_ptr.valid_range.start = 1;\n+                    data_ptr.valid_range = 1..=*data_ptr.valid_range.end();\n                 }\n \n                 let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n@@ -524,7 +523,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                     ty::TyDynamic(..) => {\n                         let mut vtable = scalar_unit(Pointer);\n-                        vtable.valid_range.start = 1;\n+                        vtable.valid_range = 1..=*vtable.valid_range.end();\n                         vtable\n                     }\n                     _ => return Err(LayoutError::Unknown(unsized_part))\n@@ -751,8 +750,8 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         match st.abi {\n                             Abi::Scalar(ref mut scalar) |\n                             Abi::ScalarPair(ref mut scalar, _) => {\n-                                if scalar.valid_range.start == 0 {\n-                                    scalar.valid_range.start = 1;\n+                                if *scalar.valid_range.start() == 0 {\n+                                    scalar.valid_range = 1..=*scalar.valid_range.end();\n                                 }\n                             }\n                             _ => {}\n@@ -788,18 +787,15 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 }\n                             }\n                         }\n-                        if niche_variants.start > v {\n-                            niche_variants.start = v;\n-                        }\n-                        niche_variants.end = v;\n+                        niche_variants = *niche_variants.start().min(&v)..=v;\n                     }\n \n-                    if niche_variants.start > niche_variants.end {\n+                    if niche_variants.start() > niche_variants.end() {\n                         dataful_variant = None;\n                     }\n \n                     if let Some(i) = dataful_variant {\n-                        let count = (niche_variants.end - niche_variants.start + 1) as u128;\n+                        let count = (niche_variants.end() - niche_variants.start() + 1) as u128;\n                         for (field_index, &field) in variants[i].iter().enumerate() {\n                             let (offset, niche, niche_start) =\n                                 match self.find_niche(field, count)? {\n@@ -1659,22 +1655,22 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n             let max_value = !0u128 >> (128 - bits);\n \n             // Find out how many values are outside the valid range.\n-            let niches = if v.start <= v.end {\n-                v.start + (max_value - v.end)\n+            let niches = if v.start() <= v.end() {\n+                v.start() + (max_value - v.end())\n             } else {\n-                v.start - v.end - 1\n+                v.start() - v.end() - 1\n             };\n \n             // Give up if we can't fit `count` consecutive niches.\n             if count > niches {\n                 return None;\n             }\n \n-            let niche_start = v.end.wrapping_add(1) & max_value;\n-            let niche_end = v.end.wrapping_add(count) & max_value;\n+            let niche_start = v.end().wrapping_add(1) & max_value;\n+            let niche_end = v.end().wrapping_add(count) & max_value;\n             Some((offset, Scalar {\n                 value,\n-                valid_range: v.start..=niche_end\n+                valid_range: *v.start()..=niche_end\n             }, niche_start))\n         };\n \n@@ -1744,14 +1740,14 @@ impl<'a> HashStable<StableHashingContext<'a>> for Variants {\n             }\n             NicheFilling {\n                 dataful_variant,\n-                niche_variants: RangeInclusive { start, end },\n+                ref niche_variants,\n                 ref niche,\n                 niche_start,\n                 ref variants,\n             } => {\n                 dataful_variant.hash_stable(hcx, hasher);\n-                start.hash_stable(hcx, hasher);\n-                end.hash_stable(hcx, hasher);\n+                niche_variants.start().hash_stable(hcx, hasher);\n+                niche_variants.end().hash_stable(hcx, hasher);\n                 niche.hash_stable(hcx, hasher);\n                 niche_start.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n@@ -1814,10 +1810,10 @@ impl<'a> HashStable<StableHashingContext<'a>> for Scalar {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n-        let Scalar { value, valid_range: RangeInclusive { start, end } } = *self;\n+        let Scalar { value, ref valid_range } = *self;\n         value.hash_stable(hcx, hasher);\n-        start.hash_stable(hcx, hasher);\n-        end.hash_stable(hcx, hasher);\n+        valid_range.start().hash_stable(hcx, hasher);\n+        valid_range.end().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "c8cebf8328d59a7a2afbfe429e11814676c8406d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -917,8 +917,8 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 niche_start,\n                 ..\n             } => {\n-                let variants_start = niche_variants.start as u128;\n-                let variants_end = niche_variants.end as u128;\n+                let variants_start = *niche_variants.start() as u128;\n+                let variants_end = *niche_variants.end() as u128;\n                 match raw_discr {\n                     PrimVal::Ptr(_) => {\n                         assert!(niche_start == 0);\n@@ -984,7 +984,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 if variant_index != dataful_variant {\n                     let (niche_dest, niche) =\n                         self.place_field(dest, mir::Field::new(0), layout)?;\n-                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n                     self.write_primval(niche_dest, PrimVal::Bytes(niche_value), niche.ty)?;\n                 }"}, {"sha": "a6dc4c74f36345064226c83407ddcc4fc3fc561f", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -31,7 +31,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(nonzero)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![cfg_attr(stage0, feature(try_trait))]"}, {"sha": "f73085196f4e6f3119a8b6a04705c3261bc6e801", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -555,8 +555,8 @@ impl Scalar {\n         let bits = self.value.size(cx).bits();\n         assert!(bits <= 128);\n         let mask = !0u128 >> (128 - bits);\n-        let start = self.valid_range.start;\n-        let end = self.valid_range.end;\n+        let start = *self.valid_range.start();\n+        let end = *self.valid_range.end();\n         assert_eq!(start, start & mask);\n         assert_eq!(end, end & mask);\n         start..(end.wrapping_add(1) & mask)"}, {"sha": "45f2ee13bbdc94e29f5e5922564f24314351d1ff", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -29,7 +29,7 @@\n #![feature(const_fn)]\n #![feature(fs_read_write)]\n #![feature(inclusive_range)]\n-#![feature(inclusive_range_fields)]\n+#![feature(inclusive_range_methods)]\n #![feature(slice_patterns)]\n \n #[macro_use]"}, {"sha": "1838dae049ad7e1a18cb205ed7ce6648900e4ae0", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -388,8 +388,8 @@ impl<'a, 'tcx> FnTypeExt<'a, 'tcx> for FnType<'tcx, Ty<'tcx>> {\n                 return;\n             }\n \n-            if scalar.valid_range.start < scalar.valid_range.end {\n-                if scalar.valid_range.start > 0 {\n+            if scalar.valid_range.start() < scalar.valid_range.end() {\n+                if *scalar.valid_range.start() > 0 {\n                     attrs.set(ArgAttribute::NonNull);\n                 }\n             }"}, {"sha": "2fc6c9d4433016f74613225759412724916744cd", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -1236,7 +1236,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                                    self.layout,\n                                    self.layout.fields.offset(0),\n                                    self.layout.field(cx, 0).size);\n-                name.push_str(&adt.variants[niche_variants.start].name.as_str());\n+                name.push_str(&adt.variants[*niche_variants.start()].name.as_str());\n \n                 // Create the (singleton) list of descriptions of union members.\n                 vec!["}, {"sha": "79859aee64d874dfddbbb6333e6521d65bf6eaf7", "filename": "src/librustc_trans/mir/place.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fplace.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                         bx.range_metadata(load, range);\n                     }\n                 }\n-                layout::Pointer if vr.start < vr.end && !vr.contains(&0) => {\n+                layout::Pointer if vr.start() < vr.end() && !vr.contains(&0) => {\n                     bx.nonnull_metadata(load);\n                 }\n                 _ => {}\n@@ -287,7 +287,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                 ..\n             } => {\n                 let niche_llty = discr.layout.immediate_llvm_type(bx.cx);\n-                if niche_variants.start == niche_variants.end {\n+                if niche_variants.start() == niche_variants.end() {\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_start == 0 {\n                         // HACK(eddyb) Using `C_null` as it works on all types.\n@@ -296,13 +296,13 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n                         C_uint_big(niche_llty, niche_start)\n                     };\n                     bx.select(bx.icmp(llvm::IntEQ, lldiscr, niche_llval),\n-                        C_uint(cast_to, niche_variants.start as u64),\n+                        C_uint(cast_to, *niche_variants.start() as u64),\n                         C_uint(cast_to, dataful_variant as u64))\n                 } else {\n                     // Rebase from niche values to discriminant values.\n-                    let delta = niche_start.wrapping_sub(niche_variants.start as u128);\n+                    let delta = niche_start.wrapping_sub(*niche_variants.start() as u128);\n                     let lldiscr = bx.sub(lldiscr, C_uint_big(niche_llty, delta));\n-                    let lldiscr_max = C_uint(niche_llty, niche_variants.end as u64);\n+                    let lldiscr_max = C_uint(niche_llty, *niche_variants.end() as u64);\n                     bx.select(bx.icmp(llvm::IntULE, lldiscr, lldiscr_max),\n                         bx.intcast(lldiscr, cast_to, false),\n                         C_uint(cast_to, dataful_variant as u64))\n@@ -352,7 +352,7 @@ impl<'a, 'tcx> PlaceRef<'tcx> {\n \n                     let niche = self.project_field(bx, 0);\n                     let niche_llty = niche.layout.immediate_llvm_type(bx.cx);\n-                    let niche_value = ((variant_index - niche_variants.start) as u128)\n+                    let niche_value = ((variant_index - *niche_variants.start()) as u128)\n                         .wrapping_add(niche_start);\n                     // FIXME(eddyb) Check the actual primitive type here.\n                     let niche_llval = if niche_value == 0 {"}, {"sha": "4fa54dc276d20e127fac876b00fd5407667c6df0", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c916ee8511339dd231d90d7fe6be2cc6995284b9/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c916ee8511339dd231d90d7fe6be2cc6995284b9", "patch": "@@ -301,15 +301,15 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                             if let layout::Int(_, s) = scalar.value {\n                                 signed = s;\n \n-                                if scalar.valid_range.end > scalar.valid_range.start {\n+                                if scalar.valid_range.end() > scalar.valid_range.start() {\n                                     // We want `table[e as usize]` to not\n                                     // have bound checks, and this is the most\n                                     // convenient place to put the `assume`.\n \n                                     base::call_assume(&bx, bx.icmp(\n                                         llvm::IntULE,\n                                         llval,\n-                                        C_uint_big(ll_t_in, scalar.valid_range.end)\n+                                        C_uint_big(ll_t_in, *scalar.valid_range.end())\n                                     ));\n                                 }\n                             }"}]}