{"sha": "9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNTg1OWFlYTE5OWQ1ZjM0YTRkNGI1YWU3MTEyYzVjNDFmM2IyNDI=", "commit": {"author": {"name": "Aidan Hobson Sayers", "email": "aidanhs@cantab.net", "date": "2018-02-18T17:39:40Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-03T09:02:34Z"}, "message": "Remove all unstable placement features\n\nCloses #22181, #27779", "tree": {"sha": "bc74fbacefd74d626e8c43968ab329c7621f4f70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc74fbacefd74d626e8c43968ab329c7621f4f70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "html_url": "https://github.com/rust-lang/rust/commit/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/comments", "author": {"login": "aidanhs", "id": 1050652, "node_id": "MDQ6VXNlcjEwNTA2NTI=", "avatar_url": "https://avatars.githubusercontent.com/u/1050652?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aidanhs", "html_url": "https://github.com/aidanhs", "followers_url": "https://api.github.com/users/aidanhs/followers", "following_url": "https://api.github.com/users/aidanhs/following{/other_user}", "gists_url": "https://api.github.com/users/aidanhs/gists{/gist_id}", "starred_url": "https://api.github.com/users/aidanhs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aidanhs/subscriptions", "organizations_url": "https://api.github.com/users/aidanhs/orgs", "repos_url": "https://api.github.com/users/aidanhs/repos", "events_url": "https://api.github.com/users/aidanhs/events{/privacy}", "received_events_url": "https://api.github.com/users/aidanhs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ee891cfeabc0872624104611cc0a359f46447cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ee891cfeabc0872624104611cc0a359f46447cc", "html_url": "https://github.com/rust-lang/rust/commit/5ee891cfeabc0872624104611cc0a359f46447cc"}], "stats": {"total": 1431, "additions": 39, "deletions": 1392}, "files": [{"sha": "a7da69f65faf2b3532cdc6537cff92a167a139ac", "filename": "src/grammar/parser-lalr.y", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -1400,7 +1400,6 @@ nonblock_expr\n | BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                                         { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                                    { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1463,7 +1462,6 @@ expr\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n@@ -1527,7 +1525,6 @@ expr_nostruct\n | BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n | YIELD                                               { $$ = mk_node(\"ExprYield\", 0); }\n | YIELD expr                                          { $$ = mk_node(\"ExprYield\", 1, $2); }\n-| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n | expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n | expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n | expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }"}, {"sha": "668b61c51d8bc0f8e3a39e496ecc0c79b2d5ed4e", "filename": "src/liballoc/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 65, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbinary_heap.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -155,7 +155,7 @@\n #![allow(missing_docs)]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::ops::{Deref, DerefMut, Place, Placer, InPlace};\n+use core::ops::{Deref, DerefMut};\n use core::iter::{FromIterator, FusedIterator};\n use core::mem::{swap, size_of};\n use core::ptr;\n@@ -1195,67 +1195,3 @@ impl<'a, T: 'a + Ord + Copy> Extend<&'a T> for BinaryHeap<T> {\n         self.extend(iter.into_iter().cloned());\n     }\n }\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-pub struct BinaryHeapPlace<'a, T: 'a>\n-where T: Clone + Ord {\n-    heap: *mut BinaryHeap<T>,\n-    place: vec::PlaceBack<'a, T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: Clone + Ord + fmt::Debug> fmt::Debug for BinaryHeapPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"BinaryHeapPlace\")\n-         .field(&self.place)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a> Placer<T> for &'a mut BinaryHeap<T>\n-where T: Clone + Ord {\n-    type Place = BinaryHeapPlace<'a, T>;\n-\n-    fn make_place(self) -> Self::Place {\n-        let ptr = self as *mut BinaryHeap<T>;\n-        let place = Placer::make_place(self.data.place_back());\n-        BinaryHeapPlace {\n-            heap: ptr,\n-            place,\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for BinaryHeapPlace<'a, T>\n-where T: Clone + Ord {\n-    fn pointer(&mut self) -> *mut T {\n-        self.place.pointer()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for BinaryHeapPlace<'a, T>\n-where T: Clone + Ord {\n-    type Owner = &'a T;\n-\n-    unsafe fn finalize(self) -> &'a T {\n-        self.place.finalize();\n-\n-        let heap: &mut BinaryHeap<T> = &mut *self.heap;\n-        let len = heap.len();\n-        let i = heap.sift_up(0, len - 1);\n-        heap.data.get_unchecked(i)\n-    }\n-}"}, {"sha": "4f9dc61ce196be1306884c2afca4c9b71cdabe31", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 150, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -55,55 +55,21 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use heap::Heap;\n use raw_vec::RawVec;\n \n use core::any::Any;\n use core::borrow;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::heap::{Alloc, Layout};\n use core::iter::FusedIterator;\n-use core::marker::{self, Unpin, Unsize};\n+use core::marker::{Unpin, Unsize};\n use core::mem::{self, Pin};\n use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n-use core::ops::{BoxPlace, Boxed, InPlace, Place, Placer};\n use core::ptr::{self, NonNull, Unique};\n use core::convert::From;\n use str::from_boxed_utf8_unchecked;\n \n-/// A value that represents the heap. This is the default place that the `box`\n-/// keyword allocates into when no place is supplied.\n-///\n-/// The following two examples are equivalent:\n-///\n-/// ```\n-/// #![feature(box_heap)]\n-///\n-/// #![feature(box_syntax, placement_in_syntax)]\n-/// use std::boxed::HEAP;\n-///\n-/// fn main() {\n-///     let foo: Box<i32> = in HEAP { 5 };\n-///     let foo = box 5;\n-/// }\n-/// ```\n-#[unstable(feature = \"box_heap\",\n-           reason = \"may be renamed; uncertain about custom allocator design\",\n-           issue = \"27779\")]\n-pub const HEAP: ExchangeHeapSingleton = ExchangeHeapSingleton { _force_singleton: () };\n-\n-/// This the singleton type used solely for `boxed::HEAP`.\n-#[unstable(feature = \"box_heap\",\n-           reason = \"may be renamed; uncertain about custom allocator design\",\n-           issue = \"27779\")]\n-#[allow(missing_debug_implementations)]\n-#[derive(Copy, Clone)]\n-pub struct ExchangeHeapSingleton {\n-    _force_singleton: (),\n-}\n-\n /// A pointer type for heap allocation.\n ///\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n@@ -112,121 +78,6 @@ pub struct ExchangeHeapSingleton {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Box<T: ?Sized>(Unique<T>);\n \n-/// `IntermediateBox` represents uninitialized backing storage for `Box`.\n-///\n-/// FIXME (pnkfelix): Ideally we would just reuse `Box<T>` instead of\n-/// introducing a separate `IntermediateBox<T>`; but then you hit\n-/// issues when you e.g. attempt to destructure an instance of `Box`,\n-/// since it is a lang item and so it gets special handling by the\n-/// compiler.  Easier just to make this parallel type for now.\n-///\n-/// FIXME (pnkfelix): Currently the `box` protocol only supports\n-/// creating instances of sized types. This IntermediateBox is\n-/// designed to be forward-compatible with a future protocol that\n-/// supports creating instances of unsized types; that is why the type\n-/// parameter has the `?Sized` generalization marker, and is also why\n-/// this carries an explicit size. However, it probably does not need\n-/// to carry the explicit alignment; that is just a work-around for\n-/// the fact that the `align_of` intrinsic currently requires the\n-/// input type to be Sized (which I do not think is strictly\n-/// necessary).\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-#[allow(missing_debug_implementations)]\n-pub struct IntermediateBox<T: ?Sized> {\n-    ptr: *mut u8,\n-    layout: Layout,\n-    marker: marker::PhantomData<*mut T>,\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-unsafe impl<T> Place<T> for IntermediateBox<T> {\n-    fn pointer(&mut self) -> *mut T {\n-        self.ptr as *mut T\n-    }\n-}\n-\n-unsafe fn finalize<T>(b: IntermediateBox<T>) -> Box<T> {\n-    let p = b.ptr as *mut T;\n-    mem::forget(b);\n-    Box::from_raw(p)\n-}\n-\n-fn make_place<T>() -> IntermediateBox<T> {\n-    let layout = Layout::new::<T>();\n-\n-    let p = if layout.size() == 0 {\n-        mem::align_of::<T>() as *mut u8\n-    } else {\n-        unsafe {\n-            Heap.alloc(layout.clone()).unwrap_or_else(|err| {\n-                Heap.oom(err)\n-            })\n-        }\n-    };\n-\n-    IntermediateBox {\n-        ptr: p,\n-        layout,\n-        marker: marker::PhantomData,\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> BoxPlace<T> for IntermediateBox<T> {\n-    fn make_place() -> IntermediateBox<T> {\n-        make_place()\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> InPlace<T> for IntermediateBox<T> {\n-    type Owner = Box<T>;\n-    unsafe fn finalize(self) -> Box<T> {\n-        finalize(self)\n-    }\n-}\n-\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-impl<T> Boxed for Box<T> {\n-    type Data = T;\n-    type Place = IntermediateBox<T>;\n-    unsafe fn finalize(b: IntermediateBox<T>) -> Box<T> {\n-        finalize(b)\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T> Placer<T> for ExchangeHeapSingleton {\n-    type Place = IntermediateBox<T>;\n-\n-    fn make_place(self) -> IntermediateBox<T> {\n-        make_place()\n-    }\n-}\n-\n-#[unstable(feature = \"placement_in\",\n-           reason = \"placement box design is still being worked out.\",\n-           issue = \"27779\")]\n-impl<T: ?Sized> Drop for IntermediateBox<T> {\n-    fn drop(&mut self) {\n-        if self.layout.size() > 0 {\n-            unsafe {\n-                Heap.dealloc(self.ptr, self.layout.clone())\n-            }\n-        }\n-    }\n-}\n-\n impl<T> Box<T> {\n     /// Allocates memory on the heap and then places `x` into it.\n     ///"}, {"sha": "2fad3b0bad4ac154a43d16ef6d3475c1fe13dbdd", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -76,7 +76,6 @@\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand\n-#![cfg_attr(test, feature(placement_in))]\n #![cfg_attr(not(test), feature(core_float))]\n #![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![cfg_attr(not(test), feature(generator_trait))]\n@@ -108,8 +107,6 @@\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n #![feature(pin)]\n-#![feature(placement_in_syntax)]\n-#![feature(placement_new_protocol)]\n #![feature(ptr_internals)]\n #![feature(rustc_attrs)]\n #![feature(slice_get_slice)]\n@@ -128,8 +125,8 @@\n #![feature(pointer_methods)]\n #![feature(inclusive_range_fields)]\n \n-#![cfg_attr(not(test), feature(fn_traits, placement_new_protocol, swap_with_slice, i128))]\n-#![cfg_attr(test, feature(test, box_heap))]\n+#![cfg_attr(not(test), feature(fn_traits, swap_with_slice, i128))]\n+#![cfg_attr(test, feature(test))]\n \n // Allow testing this library\n \n@@ -159,13 +156,12 @@ pub mod heap;\n \n // Need to conditionally define the mod from `boxed.rs` to avoid\n // duplicating the lang-items when building in test cfg; but also need\n-// to allow code to have `use boxed::HEAP;`\n-// and `use boxed::Box;` declarations.\n+// to allow code to have `use boxed::Box;` declarations.\n #[cfg(not(test))]\n pub mod boxed;\n #[cfg(test)]\n mod boxed {\n-    pub use std::boxed::{Box, IntermediateBox, HEAP};\n+    pub use std::boxed::Box;\n }\n #[cfg(test)]\n mod boxed_test;"}, {"sha": "129b3bc676432f058912c01ae3e834467ff34b0d", "filename": "src/liballoc/linked_list.rs", "status": "modified", "additions": 2, "deletions": 176, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flinked_list.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -28,10 +28,9 @@ use core::hash::{Hasher, Hash};\n use core::iter::{FromIterator, FusedIterator};\n use core::marker::PhantomData;\n use core::mem;\n-use core::ops::{BoxPlace, InPlace, Place, Placer};\n-use core::ptr::{self, NonNull};\n+use core::ptr::NonNull;\n \n-use boxed::{Box, IntermediateBox};\n+use boxed::Box;\n use super::SpecExtend;\n \n /// A doubly-linked list with owned nodes.\n@@ -786,62 +785,6 @@ impl<T> LinkedList<T> {\n             old_len: old_len,\n         }\n     }\n-\n-    /// Returns a place for insertion at the front of the list.\n-    ///\n-    /// Using this method with placement syntax is equivalent to\n-    /// [`push_front`](#method.push_front), but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list = LinkedList::new();\n-    /// list.front_place() <- 2;\n-    /// list.front_place() <- 4;\n-    /// assert!(list.iter().eq(&[4, 2]));\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"method name and placement protocol are subject to change\",\n-               issue = \"30172\")]\n-    pub fn front_place(&mut self) -> FrontPlace<T> {\n-        FrontPlace {\n-            list: self,\n-            node: IntermediateBox::make_place(),\n-        }\n-    }\n-\n-    /// Returns a place for insertion at the back of the list.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list = LinkedList::new();\n-    /// list.back_place() <- 2;\n-    /// list.back_place() <- 4;\n-    /// assert!(list.iter().eq(&[2, 4]));\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"method name and placement protocol are subject to change\",\n-               issue = \"30172\")]\n-    pub fn back_place(&mut self) -> BackPlace<T> {\n-        BackPlace {\n-            list: self,\n-            node: IntermediateBox::make_place(),\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1242,123 +1185,6 @@ impl<T: Hash> Hash for LinkedList<T> {\n     }\n }\n \n-unsafe fn finalize<T>(node: IntermediateBox<Node<T>>) -> Box<Node<T>> {\n-    let mut node = node.finalize();\n-    ptr::write(&mut node.next, None);\n-    ptr::write(&mut node.prev, None);\n-    node\n-}\n-\n-/// A place for insertion at the front of a `LinkedList`.\n-///\n-/// See [`LinkedList::front_place`](struct.LinkedList.html#method.front_place) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-pub struct FrontPlace<'a, T: 'a> {\n-    list: &'a mut LinkedList<T>,\n-    node: IntermediateBox<Node<T>>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for FrontPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"FrontPlace\")\n-         .field(&self.list)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for FrontPlace<'a, T> {\n-    type Place = Self;\n-\n-    fn make_place(self) -> Self {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for FrontPlace<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).element }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for FrontPlace<'a, T> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        let FrontPlace { list, node } = self;\n-        list.push_front_node(finalize(node));\n-    }\n-}\n-\n-/// A place for insertion at the back of a `LinkedList`.\n-///\n-/// See [`LinkedList::back_place`](struct.LinkedList.html#method.back_place) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-pub struct BackPlace<'a, T: 'a> {\n-    list: &'a mut LinkedList<T>,\n-    node: IntermediateBox<Node<T>>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for BackPlace<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_tuple(\"BackPlace\")\n-         .field(&self.list)\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for BackPlace<'a, T> {\n-    type Place = Self;\n-\n-    fn make_place(self) -> Self {\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for BackPlace<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { &mut (*self.node.pointer()).element }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for BackPlace<'a, T> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        let BackPlace { list, node } = self;\n-        list.push_back_node(finalize(node));\n-    }\n-}\n-\n // Ensure that `LinkedList` and its read-only iterators are covariant in their type parameters.\n #[allow(dead_code)]\n fn assert_covariance() {"}, {"sha": "8494463463cb941fa7873097ede52783ba4c5910", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -278,26 +278,6 @@ fn test_extend_specialization() {\n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n \n-#[test]\n-fn test_placement() {\n-    let mut a = BinaryHeap::new();\n-    &mut a <- 2;\n-    &mut a <- 4;\n-    &mut a <- 3;\n-    assert_eq!(a.peek(), Some(&4));\n-    assert_eq!(a.len(), 3);\n-    &mut a <- 1;\n-    assert_eq!(a.into_sorted_vec(), vec![1, 2, 3, 4]);\n-}\n-\n-#[test]\n-fn test_placement_panic() {\n-    let mut heap = BinaryHeap::from(vec![1, 2, 3]);\n-    fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { &mut heap <- mkpanic(); }));\n-    assert_eq!(heap.len(), 3);\n-}\n-\n #[allow(dead_code)]\n fn assert_covariance() {\n     fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> {"}, {"sha": "1a49fb9964ad727ef7c765c185f8024c35e56764", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -15,13 +15,11 @@\n #![feature(attr_literals)]\n #![feature(box_syntax)]\n #![cfg_attr(stage0, feature(inclusive_range_syntax))]\n-#![feature(collection_placement)]\n #![feature(const_fn)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(iterator_step_by)]\n #![feature(pattern)]\n-#![feature(placement_in_syntax)]\n #![feature(rand)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(splice)]"}, {"sha": "2895c53009d9ac9fae260e910bb5d148f34fc321", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -10,7 +10,7 @@\n \n use std::borrow::Cow;\n use std::mem::size_of;\n-use std::{usize, isize, panic};\n+use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n use std::collections::CollectionAllocErr::*;\n \n@@ -753,24 +753,6 @@ fn assert_covariance() {\n     }\n }\n \n-#[test]\n-fn test_placement() {\n-    let mut vec = vec![1];\n-    assert_eq!(vec.place_back() <- 2, &2);\n-    assert_eq!(vec.len(), 2);\n-    assert_eq!(vec.place_back() <- 3, &3);\n-    assert_eq!(vec.len(), 3);\n-    assert_eq!(&vec, &[1, 2, 3]);\n-}\n-\n-#[test]\n-fn test_placement_panic() {\n-    let mut vec = vec![1, 2, 3];\n-    fn mkpanic() -> usize { panic!() }\n-    let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { vec.place_back() <- mkpanic(); }));\n-    assert_eq!(vec.len(), 3);\n-}\n-\n #[test]\n fn from_into_inner() {\n     let vec = vec![1, 2, 3];"}, {"sha": "75d3f01f8b601c0a930008dc42d92ef3dc75ac6c", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -1004,28 +1004,6 @@ fn test_is_empty() {\n     assert!(v.into_iter().is_empty());\n }\n \n-#[test]\n-fn test_placement_in() {\n-    let mut buf: VecDeque<isize> = VecDeque::new();\n-    buf.place_back() <- 1;\n-    buf.place_back() <- 2;\n-    assert_eq!(buf, [1,2]);\n-\n-    buf.place_front() <- 3;\n-    buf.place_front() <- 4;\n-    assert_eq!(buf, [4,3,1,2]);\n-\n-    {\n-        let ptr_head = buf.place_front() <- 5;\n-        assert_eq!(*ptr_head, 5);\n-    }\n-    {\n-        let ptr_tail = buf.place_back() <- 6;\n-        assert_eq!(*ptr_tail, 6);\n-    }\n-    assert_eq!(buf, [5,4,3,1,2,6]);\n-}\n-\n #[test]\n fn test_reserve_exact_2() {\n     // This is all the same as test_reserve"}, {"sha": "47c92028b14190976a7feebdae5ca15b0098b11f", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 75, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -76,7 +76,7 @@ use core::mem;\n #[cfg(not(test))]\n use core::num::Float;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{InPlace, Index, IndexMut, Place, Placer, RangeBounds};\n+use core::ops::{Index, IndexMut, RangeBounds};\n use core::ops;\n use core::ptr;\n use core::ptr::NonNull;\n@@ -1065,29 +1065,6 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Returns a place for insertion at the back of the `Vec`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push`](#method.push),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// let mut vec = vec![1, 2];\n-    /// vec.place_back() <- 3;\n-    /// vec.place_back() <- 4;\n-    /// assert_eq!(&vec, &[1, 2, 3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec: self }\n-    }\n-\n     /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n@@ -2492,57 +2469,6 @@ impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}\n \n-/// A place for insertion at the back of a `Vec`.\n-///\n-/// See [`Vec::place_back`](struct.Vec.html#method.place_back) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceBack<'a, T: 'a> {\n-    vec: &'a mut Vec<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n-    type Place = PlaceBack<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        // This will panic or abort if we would allocate > isize::MAX bytes\n-        // or if the length increment would overflow for zero-sized types.\n-        if self.vec.len == self.vec.buf.cap() {\n-            self.vec.buf.double();\n-        }\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { self.vec.as_mut_ptr().offset(self.vec.len as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(mut self) -> &'a mut T {\n-        let ptr = self.pointer();\n-        self.vec.len += 1;\n-        &mut *ptr\n-    }\n-}\n-\n-\n /// A splicing iterator for `Vec`.\n ///\n /// This struct is created by the [`splice()`] method on [`Vec`]. See its"}, {"sha": "f28c8e389967f616e6cff139b74d81c2c03dd4f7", "filename": "src/liballoc/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 143, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Fliballoc%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec_deque.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -22,7 +22,7 @@ use core::fmt;\n use core::iter::{repeat, FromIterator, FusedIterator};\n use core::mem;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{Index, IndexMut, Place, Placer, InPlace, RangeBounds};\n+use core::ops::{Index, IndexMut, RangeBounds};\n use core::ptr;\n use core::ptr::NonNull;\n use core::slice;\n@@ -1885,56 +1885,6 @@ impl<T> VecDeque<T> {\n             debug_assert!(!self.is_full());\n         }\n     }\n-\n-    /// Returns a place for insertion at the back of the `VecDeque`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_back`](#method.push_back),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.place_back() <- 3;\n-    /// buf.place_back() <- 4;\n-    /// assert_eq!(&buf, &[3, 4]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_back(&mut self) -> PlaceBack<T> {\n-        PlaceBack { vec_deque: self }\n-    }\n-\n-    /// Returns a place for insertion at the front of the `VecDeque`.\n-    ///\n-    /// Using this method with placement syntax is equivalent to [`push_front`](#method.push_front),\n-    /// but may be more efficient.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(collection_placement)]\n-    /// #![feature(placement_in_syntax)]\n-    ///\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// buf.place_front() <- 3;\n-    /// buf.place_front() <- 4;\n-    /// assert_eq!(&buf, &[4, 3]);\n-    /// ```\n-    #[unstable(feature = \"collection_placement\",\n-               reason = \"placement protocol is subject to change\",\n-               issue = \"30172\")]\n-    pub fn place_front(&mut self) -> PlaceFront<T> {\n-        PlaceFront { vec_deque: self }\n-    }\n }\n \n impl<T: Clone> VecDeque<T> {\n@@ -2662,98 +2612,6 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     }\n }\n \n-/// A place for insertion at the back of a `VecDeque`.\n-///\n-/// See [`VecDeque::place_back`](struct.VecDeque.html#method.place_back) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceBack<'a, T: 'a> {\n-    vec_deque: &'a mut VecDeque<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceBack<'a, T> {\n-    type Place = PlaceBack<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        self.vec_deque.grow_if_necessary();\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceBack<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        unsafe { self.vec_deque.ptr().offset(self.vec_deque.head as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(self) -> &'a mut T {\n-        let head = self.vec_deque.head;\n-        self.vec_deque.head = self.vec_deque.wrap_add(head, 1);\n-        &mut *(self.vec_deque.ptr().offset(head as isize))\n-    }\n-}\n-\n-/// A place for insertion at the front of a `VecDeque`.\n-///\n-/// See [`VecDeque::place_front`](struct.VecDeque.html#method.place_front) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol are subject to change\",\n-           issue = \"30172\")]\n-#[derive(Debug)]\n-pub struct PlaceFront<'a, T: 'a> {\n-    vec_deque: &'a mut VecDeque<T>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> Placer<T> for PlaceFront<'a, T> {\n-    type Place = PlaceFront<'a, T>;\n-\n-    fn make_place(self) -> Self {\n-        self.vec_deque.grow_if_necessary();\n-        self\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, T> Place<T> for PlaceFront<'a, T> {\n-    fn pointer(&mut self) -> *mut T {\n-        let tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n-        unsafe { self.vec_deque.ptr().offset(tail as isize) }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, T> InPlace<T> for PlaceFront<'a, T> {\n-    type Owner = &'a mut T;\n-\n-    unsafe fn finalize(self) -> &'a mut T {\n-        self.vec_deque.tail = self.vec_deque.wrap_sub(self.vec_deque.tail, 1);\n-        &mut *(self.vec_deque.ptr().offset(self.vec_deque.tail as isize))\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use test;"}, {"sha": "ce4f45762de48d3571a3f8e68660262c6d844a75", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -161,7 +161,6 @@ mod drop;\n mod function;\n mod generator;\n mod index;\n-mod place;\n mod range;\n mod try;\n mod unsize;\n@@ -200,8 +199,5 @@ pub use self::try::Try;\n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n pub use self::generator::{Generator, GeneratorState};\n \n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n-\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n pub use self::unsize::CoerceUnsized;"}, {"sha": "b3dcf4e7ee9578c9e5155d563d332d10fe19e9ff", "filename": "src/libcore/ops/place.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,143 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n-/// that allocate an intermediate \"place\" that holds uninitialized\n-/// state.  The desugaring evaluates EXPR, and writes the result at\n-/// the address returned by the `pointer` method of this trait.\n-///\n-/// A `Place` can be thought of as a special representation for a\n-/// hypothetical `&uninit` reference (which Rust cannot currently\n-/// express directly). That is, it represents a pointer to\n-/// uninitialized storage.\n-///\n-/// The client is responsible for two steps: First, initializing the\n-/// payload (it can access its address via `pointer`). Second,\n-/// converting the agent to an instance of the owning pointer, via the\n-/// appropriate `finalize` method (see the `InPlace`.\n-///\n-/// If evaluating EXPR fails, then it is up to the destructor for the\n-/// implementation of Place to clean up any intermediate state\n-/// (e.g. deallocate box storage, pop a stack, etc).\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub unsafe trait Place<Data: ?Sized> {\n-    /// Returns the address where the input value will be written.\n-    /// Note that the data at this address is generally uninitialized,\n-    /// and thus one should use `ptr::write` for initializing it.\n-    ///\n-    /// This function must return a pointer through which a value\n-    /// of type `Data` can be written.\n-    fn pointer(&mut self) -> *mut Data;\n-}\n-\n-/// Interface to implementations of  `PLACE <- EXPR`.\n-///\n-/// `PLACE <- EXPR` effectively desugars into:\n-///\n-/// ```\n-/// # #![feature(placement_new_protocol, box_heap)]\n-/// # use std::ops::{Placer, Place, InPlace};\n-/// # #[allow(non_snake_case)]\n-/// # fn main() {\n-/// # let PLACE = std::boxed::HEAP;\n-/// # let EXPR = 1;\n-/// let p = PLACE;\n-/// let mut place = Placer::make_place(p);\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// unsafe {\n-///     std::ptr::write(raw_place, value);\n-///     InPlace::finalize(place)\n-/// }\n-/// # ; }\n-/// ```\n-///\n-/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n-/// if the type of `PLACE` is `P`, then the final type of the whole\n-/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n-/// traits).\n-///\n-/// Values for types implementing this trait usually are transient\n-/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n-/// or `Copy`, since the `make_place` method takes `self` by value.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Placer<Data: ?Sized> {\n-    /// `Place` is the intermediate agent guarding the\n-    /// uninitialized state for `Data`.\n-    type Place: InPlace<Data>;\n-\n-    /// Creates a fresh place from `self`.\n-    fn make_place(self) -> Self::Place;\n-}\n-\n-/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait InPlace<Data: ?Sized>: Place<Data> {\n-    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n-    ///\n-    /// Note that when `PLACE <- EXPR` is solely used for\n-    /// side-effecting an existing data-structure,\n-    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n-    /// information at all (e.g. it can be the unit type `()` in that\n-    /// case).\n-    type Owner;\n-\n-    /// Converts self into the final value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// the returned instance of `Owner` and forgetting self.\n-    unsafe fn finalize(self) -> Self::Owner;\n-}\n-\n-/// Core trait for the `box EXPR` form.\n-///\n-/// `box EXPR` effectively desugars into:\n-///\n-/// ```\n-/// # #![feature(placement_new_protocol)]\n-/// # use std::ops::{BoxPlace, Place, Boxed};\n-/// # #[allow(non_snake_case)]\n-/// # fn main() {\n-/// # let EXPR = 1;\n-/// let mut place = BoxPlace::make_place();\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// # let _: Box<_> =\n-/// unsafe {\n-///     ::std::ptr::write(raw_place, value);\n-///     Boxed::finalize(place)\n-/// }\n-/// # ; }\n-/// ```\n-///\n-/// The type of `box EXPR` is supplied from its surrounding\n-/// context; in the above expansion, the result type `T` is used\n-/// to determine which implementation of `Boxed` to use, and that\n-/// `<T as Boxed>` in turn dictates determines which\n-/// implementation of `BoxPlace` to use, namely:\n-/// `<<T as Boxed>::Place as BoxPlace>`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Boxed {\n-    /// The kind of data that is stored in this kind of box.\n-    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n-    /// The place that will negotiate the storage of the data.\n-    type Place: BoxPlace<Self::Data>;\n-\n-    /// Converts filled place into final owning value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// returned instance of `Self` and forgetting `filled`.\n-    unsafe fn finalize(filled: Self::Place) -> Self;\n-}\n-\n-/// Specialization of `Place` trait supporting `box EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n-    /// Creates a globally fresh place.\n-    fn make_place() -> Self;\n-}"}, {"sha": "5f9f37094f579a5bc01c546dcce43f066ba73de8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -2911,118 +2911,8 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n         let kind = match e.node {\n-            // Issue #22181:\n-            // Eventually a desugaring for `box EXPR`\n-            // (similar to the desugaring above for `in PLACE BLOCK`)\n-            // should go here, desugaring\n-            //\n-            // to:\n-            //\n-            // let mut place = BoxPlace::make_place();\n-            // let raw_place = Place::pointer(&mut place);\n-            // let value = $value;\n-            // unsafe {\n-            //     ::std::ptr::write(raw_place, value);\n-            //     Boxed::finalize(place)\n-            // }\n-            //\n-            // But for now there are type-inference issues doing that.\n             ExprKind::Box(ref inner) => hir::ExprBox(P(self.lower_expr(inner))),\n \n-            // Desugar ExprBox: `in (PLACE) EXPR`\n-            ExprKind::InPlace(ref placer, ref value_expr) => {\n-                // to:\n-                //\n-                // let p = PLACE;\n-                // let mut place = Placer::make_place(p);\n-                // let raw_place = Place::pointer(&mut place);\n-                // push_unsafe!({\n-                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                //     InPlace::finalize(place)\n-                // })\n-                let placer_expr = P(self.lower_expr(placer));\n-                let value_expr = P(self.lower_expr(value_expr));\n-\n-                let placer_ident = self.str_to_ident(\"placer\");\n-                let place_ident = self.str_to_ident(\"place\");\n-                let p_ptr_ident = self.str_to_ident(\"p_ptr\");\n-\n-                let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-                let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-                let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-                let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n-\n-                let unstable_span =\n-                    self.allow_internal_unstable(CompilerDesugaringKind::BackArrow, e.span);\n-                let make_call = |this: &mut LoweringContext, p, args| {\n-                    let path = P(this.expr_std_path(unstable_span, p, ThinVec::new()));\n-                    P(this.expr_call(e.span, path, args))\n-                };\n-\n-                let mk_stmt_let = |this: &mut LoweringContext, bind, expr| {\n-                    this.stmt_let(e.span, false, bind, expr)\n-                };\n-\n-                let mk_stmt_let_mut = |this: &mut LoweringContext, bind, expr| {\n-                    this.stmt_let(e.span, true, bind, expr)\n-                };\n-\n-                // let placer = <placer_expr> ;\n-                let (s1, placer_binding) = { mk_stmt_let(self, placer_ident, placer_expr) };\n-\n-                // let mut place = Placer::make_place(placer);\n-                let (s2, place_binding) = {\n-                    let placer = self.expr_ident(e.span, placer_ident, placer_binding);\n-                    let call = make_call(self, &make_place, hir_vec![placer]);\n-                    mk_stmt_let_mut(self, place_ident, call)\n-                };\n-\n-                // let p_ptr = Place::pointer(&mut place);\n-                let (s3, p_ptr_binding) = {\n-                    let agent = P(self.expr_ident(e.span, place_ident, place_binding));\n-                    let args = hir_vec![self.expr_mut_addr_of(e.span, agent)];\n-                    let call = make_call(self, &place_pointer, args);\n-                    mk_stmt_let(self, p_ptr_ident, call)\n-                };\n-\n-                // pop_unsafe!(EXPR));\n-                let pop_unsafe_expr = {\n-                    self.signal_block_expr(\n-                        hir_vec![],\n-                        value_expr,\n-                        e.span,\n-                        hir::PopUnsafeBlock(hir::CompilerGenerated),\n-                        ThinVec::new(),\n-                    )\n-                };\n-\n-                // push_unsafe!({\n-                //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-                //     InPlace::finalize(place)\n-                // })\n-                let expr = {\n-                    let ptr = self.expr_ident(e.span, p_ptr_ident, p_ptr_binding);\n-                    let call_move_val_init = hir::StmtSemi(\n-                        make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n-                        self.next_id().node_id,\n-                    );\n-                    let call_move_val_init = respan(e.span, call_move_val_init);\n-\n-                    let place = self.expr_ident(e.span, place_ident, place_binding);\n-                    let call = make_call(self, &inplace_finalize, hir_vec![place]);\n-                    P(self.signal_block_expr(\n-                        hir_vec![call_move_val_init],\n-                        call,\n-                        e.span,\n-                        hir::PushUnsafeBlock(hir::CompilerGenerated),\n-                        ThinVec::new(),\n-                    ))\n-                };\n-\n-                let block = self.block_all(e.span, hir_vec![s1, s2, s3], Some(expr));\n-                hir::ExprBlock(P(block))\n-            }\n-\n             ExprKind::Array(ref exprs) => {\n                 hir::ExprArray(exprs.iter().map(|x| self.lower_expr(x)).collect())\n             }\n@@ -4069,29 +3959,6 @@ impl<'a> LoweringContext<'a> {\n             .resolve_str_path(span, self.crate_root, components, is_value)\n     }\n \n-    fn signal_block_expr(\n-        &mut self,\n-        stmts: hir::HirVec<hir::Stmt>,\n-        expr: P<hir::Expr>,\n-        span: Span,\n-        rule: hir::BlockCheckMode,\n-        attrs: ThinVec<Attribute>,\n-    ) -> hir::Expr {\n-        let LoweredNodeId { node_id, hir_id } = self.next_id();\n-\n-        let block = P(hir::Block {\n-            rules: rule,\n-            span,\n-            id: node_id,\n-            hir_id,\n-            stmts,\n-            expr: Some(expr),\n-            targeted_by_break: false,\n-            recovered: false,\n-        });\n-        self.expr_block(block, attrs)\n-    }\n-\n     fn ty_path(&mut self, id: LoweredNodeId, span: Span, qpath: hir::QPath) -> P<hir::Ty> {\n         let mut id = id;\n         let node = match qpath {"}, {"sha": "425459f448fad32b7fb6ac1ab26460f2a14c0cb9", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -371,7 +371,6 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n });\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n-    BackArrow,\n     DotFill,\n     QuestionMark\n });"}, {"sha": "aa93b3098e046e8a0d8c0a433c28c50945e37a9c", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -301,7 +301,6 @@ impl EarlyLintPass for UnusedParens {\n             Ret(Some(ref value)) => (value, \"`return` value\", false),\n             Assign(_, ref value) => (value, \"assigned value\", false),\n             AssignOp(.., ref value) => (value, \"assigned value\", false),\n-            InPlace(_, ref value) => (value, \"emplacement value\", false),\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n                 let args_to_check;"}, {"sha": "c50d84c10d86ea8c4568565067148a65ce6f1bc7", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -196,15 +196,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let mut values = Vec::with_capacity(used_variants);\n                 let tcx = self.hir.tcx();\n                 for (idx, discr) in adt_def.discriminants(tcx).enumerate() {\n-                    target_blocks.place_back() <- if variants.contains(idx) {\n+                    target_blocks.push(if variants.contains(idx) {\n                         values.push(discr.val);\n-                        *(targets.place_back() <- self.cfg.start_new_block())\n+                        targets.push(self.cfg.start_new_block());\n+                        *targets.last().unwrap()\n                     } else {\n                         if otherwise_block.is_none() {\n                             otherwise_block = Some(self.cfg.start_new_block());\n                         }\n                         otherwise_block.unwrap()\n-                    };\n+                    });\n                 }\n                 if let Some(otherwise_block) = otherwise_block {\n                     targets.push(otherwise_block);"}, {"sha": "84baa8c541781f8f21240aa2dd07071f51f51c7c", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -34,8 +34,6 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(exhaustive_patterns)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(placement_in_syntax)]\n-#![feature(collection_placement)]\n #![feature(nonzero)]\n #![cfg_attr(stage0, feature(underscore_lifetimes))]\n #![cfg_attr(stage0, feature(never_type))]"}, {"sha": "ca5858299c557f40249584e4023d4a9f12f4639d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -721,16 +721,6 @@ fn main() {\n ```\n \"##,\n \n-E0066: r##\"\n-Box placement expressions (like C++'s \"placement new\") do not yet support any\n-place expression except the exchange heap (i.e. `std::boxed::HEAP`).\n-Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]\n-and [RFC 809] for more details.\n-\n-[RFC 470]: https://github.com/rust-lang/rfcs/pull/470\n-[RFC 809]: https://github.com/rust-lang/rfcs/blob/master/text/0809-box-and-in-for-stdlib.md\n-\"##,\n-\n E0067: r##\"\n The left-hand side of a compound assignment expression must be a place\n expression. A place expression represents a memory location and includes"}, {"sha": "e0b48e565d02a8aadb3e0f13df8793cb214a82a1", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 150, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -22,8 +22,7 @@ use fmt::{self, Debug};\n use hash::{Hash, Hasher, BuildHasher, SipHasher13};\n use iter::{FromIterator, FusedIterator};\n use mem::{self, replace};\n-use ops::{Deref, Index, InPlace, Place, Placer};\n-use ptr;\n+use ops::{Deref, Index};\n use sys;\n \n use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n@@ -2043,80 +2042,6 @@ impl<'a, K, V> fmt::Debug for Drain<'a, K, V>\n     }\n }\n \n-/// A place for insertion to a `Entry`.\n-///\n-/// See [`HashMap::entry`](struct.HashMap.html#method.entry) for details.\n-#[must_use = \"places do nothing unless written to with `<-` syntax\"]\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol is subject to change\",\n-           issue = \"30172\")]\n-pub struct EntryPlace<'a, K: 'a, V: 'a> {\n-    bucket: FullBucketMut<'a, K, V>,\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for EntryPlace<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"EntryPlace\")\n-            .field(\"key\", self.bucket.read().0)\n-            .field(\"value\", self.bucket.read().1)\n-            .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"struct name and placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, K, V> Drop for EntryPlace<'a, K, V> {\n-    fn drop(&mut self) {\n-        // Inplacement insertion failed. Only key need to drop.\n-        // The value is failed to insert into map.\n-        unsafe { self.bucket.remove_key() };\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, K, V> Placer<V> for Entry<'a, K, V> {\n-    type Place = EntryPlace<'a, K, V>;\n-\n-    fn make_place(self) -> EntryPlace<'a, K, V> {\n-        let b = match self {\n-            Occupied(mut o) => {\n-                unsafe { ptr::drop_in_place(o.elem.read_mut().1); }\n-                o.elem\n-            }\n-            Vacant(v) => {\n-                unsafe { v.insert_key() }\n-            }\n-        };\n-        EntryPlace { bucket: b }\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-unsafe impl<'a, K, V> Place<V> for EntryPlace<'a, K, V> {\n-    fn pointer(&mut self) -> *mut V {\n-        self.bucket.read_mut().1\n-    }\n-}\n-\n-#[unstable(feature = \"collection_placement\",\n-           reason = \"placement protocol is subject to change\",\n-           issue = \"30172\")]\n-impl<'a, K, V> InPlace<V> for EntryPlace<'a, K, V> {\n-    type Owner = ();\n-\n-    unsafe fn finalize(self) {\n-        mem::forget(self);\n-    }\n-}\n-\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n@@ -2539,26 +2464,6 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n         };\n         b.into_mut_refs().1\n     }\n-\n-    // Only used for InPlacement insert. Avoid unnecessary value copy.\n-    // The value remains uninitialized.\n-    unsafe fn insert_key(self) -> FullBucketMut<'a, K, V> {\n-        match self.elem {\n-            NeqElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                let uninit = mem::uninitialized();\n-                robin_hood(bucket, disp, self.hash, self.key, uninit)\n-            },\n-            NoElem(mut bucket, disp) => {\n-                if disp >= DISPLACEMENT_THRESHOLD {\n-                    bucket.table_mut().set_tag(true);\n-                }\n-                bucket.put_key(self.hash, self.key)\n-            },\n-        }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2823,7 +2728,6 @@ mod test_map {\n     use super::RandomState;\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n-    use panic;\n     use realstd::collections::CollectionAllocErr::*;\n     use realstd::mem::size_of;\n     use realstd::usize;\n@@ -3709,59 +3613,6 @@ mod test_map {\n         panic!(\"Adaptive early resize failed\");\n     }\n \n-    #[test]\n-    fn test_placement_in() {\n-        let mut map = HashMap::new();\n-        map.extend((0..10).map(|i| (i, i)));\n-\n-        map.entry(100) <- 100;\n-        assert_eq!(map[&100], 100);\n-\n-        map.entry(0) <- 10;\n-        assert_eq!(map[&0], 10);\n-\n-        assert_eq!(map.len(), 11);\n-    }\n-\n-    #[test]\n-    fn test_placement_panic() {\n-        let mut map = HashMap::new();\n-        map.extend((0..10).map(|i| (i, i)));\n-\n-        fn mkpanic() -> usize { panic!() }\n-\n-        // modify existing key\n-        // when panic happens, previous key is removed.\n-        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { map.entry(0) <- mkpanic(); }));\n-        assert_eq!(map.len(), 9);\n-        assert!(!map.contains_key(&0));\n-\n-        // add new key\n-        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { map.entry(100) <- mkpanic(); }));\n-        assert_eq!(map.len(), 9);\n-        assert!(!map.contains_key(&100));\n-    }\n-\n-    #[test]\n-    fn test_placement_drop() {\n-        // correctly drop\n-        struct TestV<'a>(&'a mut bool);\n-        impl<'a> Drop for TestV<'a> {\n-            fn drop(&mut self) {\n-                if !*self.0 { panic!(\"value double drop!\"); } // no double drop\n-                *self.0 = false;\n-            }\n-        }\n-\n-        fn makepanic<'a>() -> TestV<'a> { panic!() }\n-\n-        let mut can_drop = true;\n-        let mut hm = HashMap::new();\n-        hm.insert(0, TestV(&mut can_drop));\n-        let _ = panic::catch_unwind(panic::AssertUnwindSafe(|| { hm.entry(0) <- makepanic(); }));\n-        assert_eq!(hm.len(), 0);\n-    }\n-\n     #[test]\n     fn test_try_reserve() {\n "}, {"sha": "fa6053d3f6d8ea136029c2b15bd2208ae7995c70", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -486,21 +486,6 @@ impl<K, V, M> EmptyBucket<K, V, M>\n             table: self.table,\n         }\n     }\n-\n-    /// Puts given key, remain value uninitialized.\n-    /// It is only used for inplacement insertion.\n-    pub unsafe fn put_key(mut self, hash: SafeHash, key: K) -> FullBucket<K, V, M> {\n-        *self.raw.hash() = hash.inspect();\n-        let pair_ptr = self.raw.pair();\n-        ptr::write(&mut (*pair_ptr).0, key);\n-\n-        self.table.borrow_table_mut().size += 1;\n-\n-        FullBucket {\n-            raw: self.raw,\n-            table: self.table,\n-        }\n-    }\n }\n \n impl<K, V, M: Deref<Target = RawTable<K, V>>> FullBucket<K, V, M> {\n@@ -576,17 +561,6 @@ impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n             v)\n         }\n     }\n-\n-    /// Remove this bucket's `key` from the hashtable.\n-    /// Only used for inplacement insertion.\n-    /// NOTE: `Value` is uninitialized when this function is called, don't try to drop the `Value`.\n-    pub unsafe fn remove_key(&mut self) {\n-        self.table.size -= 1;\n-\n-        *self.raw.hash() = EMPTY_BUCKET;\n-        let pair_ptr = self.raw.pair();\n-        ptr::drop_in_place(&mut (*pair_ptr).0); // only drop key\n-    }\n }\n \n // This use of `Put` is misleading and restrictive, but safe and sufficient for our use cases"}, {"sha": "e18e055654bcb26e855066e5644692fa448361da", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -290,7 +290,6 @@\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n #![feature(peek)]\n-#![feature(placement_in_syntax)]\n #![feature(placement_new_protocol)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]"}, {"sha": "31bb1c88b8712486b6d7ab00f497198a1801a5d9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -1011,7 +1011,6 @@ impl Expr {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.node {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n-            ExprKind::InPlace(..) => ExprPrecedence::InPlace,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n             ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n@@ -1071,8 +1070,6 @@ pub enum RangeLimits {\n pub enum ExprKind {\n     /// A `box x` expression.\n     Box(P<Expr>),\n-    /// First expr is the place; second expr is the value.\n-    InPlace(P<Expr>, P<Expr>),\n     /// An array (`[a, b, c, d]`)\n     Array(Vec<P<Expr>>),\n     /// A function call"}, {"sha": "e734a4e3735342ff5895290d14780c16a7e1885f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -146,7 +146,6 @@ declare_features! (\n     (active, rustc_diagnostic_macros, \"1.0.0\", None, None),\n     (active, rustc_const_unstable, \"1.0.0\", None, None),\n     (active, box_syntax, \"1.0.0\", Some(27779), None),\n-    (active, placement_in_syntax, \"1.0.0\", Some(27779), None),\n     (active, unboxed_closures, \"1.0.0\", Some(29625), None),\n \n     (active, fundamental, \"1.0.0\", Some(29635), None),\n@@ -1287,9 +1286,6 @@ pub const EXPLAIN_VIS_MATCHER: &'static str =\n pub const EXPLAIN_LIFETIME_MATCHER: &'static str =\n     \":lifetime fragment specifier is experimental and subject to change\";\n \n-pub const EXPLAIN_PLACEMENT_IN: &'static str =\n-    \"placement-in expression syntax is experimental and subject to change.\";\n-\n pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n     \"Unsized tuple coercion is not stable enough for use and is subject to change\";\n \n@@ -1636,9 +1632,6 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, type_ascription, e.span,\n                                   \"type ascription is experimental\");\n             }\n-            ast::ExprKind::InPlace(..) => {\n-                gate_feature_post!(&self, placement_in_syntax, e.span, EXPLAIN_PLACEMENT_IN);\n-            }\n             ast::ExprKind::Yield(..) => {\n                 gate_feature_post!(&self, generators,\n                                   e.span,"}, {"sha": "e702bf56e7f83faf69b0cbcfbcfcf52faf1169ca", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -1167,9 +1167,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Box(e) => {\n                 ExprKind::Box(folder.fold_expr(e))\n             }\n-            ExprKind::InPlace(p, e) => {\n-                ExprKind::InPlace(folder.fold_expr(p), folder.fold_expr(e))\n-            }\n             ExprKind::Array(exprs) => {\n                 ExprKind::Array(folder.fold_exprs(exprs))\n             }"}, {"sha": "f5ab023b30e8f0fa4ff8cf12163c43b09dce6c7b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -2850,17 +2850,6 @@ impl<'a> Parser<'a> {\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 (lo.to(span), ExprKind::AddrOf(m, e))\n             }\n-            token::Ident(..) if self.token.is_keyword(keywords::In) => {\n-                self.bump();\n-                let place = self.parse_expr_res(\n-                    Restrictions::NO_STRUCT_LITERAL,\n-                    None,\n-                )?;\n-                let blk = self.parse_block()?;\n-                let span = blk.span;\n-                let blk_expr = self.mk_expr(span, ExprKind::Block(blk), ThinVec::new());\n-                (lo.to(span), ExprKind::InPlace(place, blk_expr))\n-            }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 self.bump();\n                 let e = self.parse_prefix_expr(None);\n@@ -3023,8 +3012,6 @@ impl<'a> Parser<'a> {\n                 }\n                 AssocOp::Assign =>\n                     self.mk_expr(span, ExprKind::Assign(lhs, rhs), ThinVec::new()),\n-                AssocOp::Inplace =>\n-                    self.mk_expr(span, ExprKind::InPlace(lhs, rhs), ThinVec::new()),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BinOpKind::Add,"}, {"sha": "c3785c10f6905bd6f941284ebd3a416e1998b8df", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -1877,16 +1877,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_in_place(&mut self,\n-                           place: &ast::Expr,\n-                           expr: &ast::Expr) -> io::Result<()> {\n-        let prec = AssocOp::Inplace.precedence() as i8;\n-        self.print_expr_maybe_paren(place, prec + 1)?;\n-        self.s.space()?;\n-        self.word_space(\"<-\")?;\n-        self.print_expr_maybe_paren(expr, prec)\n-    }\n-\n     fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n                       attrs: &[Attribute]) -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n@@ -2056,9 +2046,6 @@ impl<'a> State<'a> {\n                 self.word_space(\"box\")?;\n                 self.print_expr_maybe_paren(expr, parser::PREC_PREFIX)?;\n             }\n-            ast::ExprKind::InPlace(ref place, ref expr) => {\n-                self.print_expr_in_place(place, expr)?;\n-            }\n             ast::ExprKind::Array(ref exprs) => {\n                 self.print_expr_vec(&exprs[..], attrs)?;\n             }"}, {"sha": "4770273e8c4a71583050ecef2b135324f4c34962", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -56,8 +56,6 @@ pub enum AssocOp {\n     GreaterEqual,\n     /// `=`\n     Assign,\n-    /// `<-`\n-    Inplace,\n     /// `?=` where ? is one of the BinOpToken\n     AssignOp(BinOpToken),\n     /// `as`\n@@ -86,7 +84,6 @@ impl AssocOp {\n         use self::AssocOp::*;\n         match *t {\n             Token::BinOpEq(k) => Some(AssignOp(k)),\n-            Token::LArrow => Some(Inplace),\n             Token::Eq => Some(Assign),\n             Token::BinOp(BinOpToken::Star) => Some(Multiply),\n             Token::BinOp(BinOpToken::Slash) => Some(Divide),\n@@ -156,7 +153,6 @@ impl AssocOp {\n             LAnd => 6,\n             LOr => 5,\n             DotDot | DotDotEq => 4,\n-            Inplace => 3,\n             Assign | AssignOp(_) => 2,\n         }\n     }\n@@ -166,7 +162,7 @@ impl AssocOp {\n         use self::AssocOp::*;\n         // NOTE: it is a bug to have an operators that has same precedence but different fixities!\n         match *self {\n-            Inplace | Assign | AssignOp(_) => Fixity::Right,\n+            Assign | AssignOp(_) => Fixity::Right,\n             As | Multiply | Divide | Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd |\n             BitXor | BitOr | Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual |\n             LAnd | LOr | Colon => Fixity::Left,\n@@ -178,7 +174,7 @@ impl AssocOp {\n         use self::AssocOp::*;\n         match *self {\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual => true,\n-            Inplace | Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n+            Assign | AssignOp(_) | As | Multiply | Divide | Modulus | Add | Subtract |\n             ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd | LOr |\n             DotDot | DotDotEq | Colon => false\n         }\n@@ -187,7 +183,7 @@ impl AssocOp {\n     pub fn is_assign_like(&self) -> bool {\n         use self::AssocOp::*;\n         match *self {\n-            Assign | AssignOp(_) | Inplace => true,\n+            Assign | AssignOp(_) => true,\n             Less | Greater | LessEqual | GreaterEqual | Equal | NotEqual | As | Multiply | Divide |\n             Modulus | Add | Subtract | ShiftLeft | ShiftRight | BitAnd | BitXor | BitOr | LAnd |\n             LOr | DotDot | DotDotEq | Colon => false\n@@ -215,7 +211,7 @@ impl AssocOp {\n             BitOr => Some(BinOpKind::BitOr),\n             LAnd => Some(BinOpKind::And),\n             LOr => Some(BinOpKind::Or),\n-            Inplace | Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None\n+            Assign | AssignOp(_) | As | DotDot | DotDotEq | Colon => None\n         }\n     }\n }\n@@ -242,7 +238,6 @@ pub enum ExprPrecedence {\n \n     Binary(BinOpKind),\n \n-    InPlace,\n     Cast,\n     Type,\n \n@@ -310,7 +305,6 @@ impl ExprPrecedence {\n \n             // Binop-like expr kinds, handled by `AssocOp`.\n             ExprPrecedence::Binary(op) => AssocOp::from_ast_binop(op).precedence() as i8,\n-            ExprPrecedence::InPlace => AssocOp::Inplace.precedence() as i8,\n             ExprPrecedence::Cast => AssocOp::As.precedence() as i8,\n             ExprPrecedence::Type => AssocOp::Colon.precedence() as i8,\n "}, {"sha": "d8de78054ab6f4ecce75f663503a2572abb5489f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -654,10 +654,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Box(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n-        ExprKind::InPlace(ref place, ref subexpression) => {\n-            visitor.visit_expr(place);\n-            visitor.visit_expr(subexpression)\n-        }\n         ExprKind::Array(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }"}, {"sha": "aba71bd0468311cb67c2aa99db7f47052ed0287e", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -430,7 +430,6 @@ pub enum ExpnFormat {\n /// The kind of compiler desugaring.\n #[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum CompilerDesugaringKind {\n-    BackArrow,\n     DotFill,\n     QuestionMark,\n }\n@@ -439,7 +438,6 @@ impl CompilerDesugaringKind {\n     pub fn as_symbol(&self) -> Symbol {\n         use CompilerDesugaringKind::*;\n         let s = match *self {\n-            BackArrow => \"<-\",\n             DotFill => \"...\",\n             QuestionMark => \"?\",\n         };"}, {"sha": "446514c8dd45fd186322919d4b4bb5b72d8658d2", "filename": "src/test/compile-fail/issue-14084.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(box_syntax)]\n-#![feature(placement_in_syntax)]\n-\n-fn main() {\n-    () <- 0;\n-    //~^ ERROR: `(): std::ops::Placer<_>` is not satisfied\n-}"}, {"sha": "bf6f4c52f1f9ca15f2662bc646076a0da02dfd38", "filename": "src/test/compile-fail/placement-expr-unsafe.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unsafe.rs?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that placement in respects unsafe code checks.\n-\n-#![feature(box_heap)]\n-#![feature(placement_in_syntax)]\n-\n-fn main() {\n-    use std::boxed::HEAP;\n-\n-    let p: *const i32 = &42;\n-    let _ = HEAP <- *p; //~ ERROR requires unsafe\n-\n-    let p: *const _ = &HEAP;\n-    let _ = *p <- 42; //~ ERROR requires unsafe\n-}"}, {"sha": "35695efe1a9b2293fd3d1e3aeed16a8edad06801", "filename": "src/test/compile-fail/placement-expr-unstable.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fplacement-expr-unstable.rs?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that placement in respects unstable code checks.\n-\n-#![feature(placement_in_syntax)]\n-\n-fn main() {\n-    use std::boxed::HEAP; //~ ERROR use of unstable library feature\n-\n-    let _ = HEAP <- { //~ ERROR use of unstable library feature\n-        HEAP //~ ERROR use of unstable library feature\n-    };\n-}"}, {"sha": "63408b76b153e3095843dfaa176939fd981565dd", "filename": "src/test/parse-fail/assoc-oddities-1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Fparse-fail%2Fassoc-oddities-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Fparse-fail%2Fassoc-oddities-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fassoc-oddities-1.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -13,10 +13,9 @@\n fn that_odd_parse() {\n     // following lines below parse and must not fail\n     x = if c { a } else { b }();\n-    x <- if c { a } else { b }[n];\n     x = if true { 1 } else { 0 } as *mut _;\n     // however this does not parse and probably should fail to retain compat?\n-    // NB: `..` here is arbitrary, failure happens/should happen \u2200ops that aren\u2019t `=` or `<-`\n+    // NB: `..` here is arbitrary, failure happens/should happen \u2200ops that aren\u2019t `=`\n     // see assoc-oddities-2 and assoc-oddities-3\n     ..if c { a } else { b }[n]; //~ ERROR expected one of\n }"}, {"sha": "b34e18520793a3f5c4b62f06cfb617268db07d44", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -12,7 +12,6 @@\n \n #![feature(custom_attribute)]\n #![feature(box_syntax)]\n-#![feature(placement_in_syntax)]\n #![feature(stmt_expr_attributes)]\n \n fn main() { }"}, {"sha": "62cb870c7bb47b0010fb23397423bfb86b31b72b", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -126,16 +126,6 @@ fn run() {\n     check_expr_attrs(\"#[attr] box 0\", outer);\n     reject_expr_parse(\"box #![attr] 0\");\n \n-    check_expr_attrs(\"#[attr] 0 <- #[attr] 0\", none);\n-    check_expr_attrs(\"#[attr] (0 <- 0)\", outer);\n-    reject_expr_parse(\"0 #[attr] <- 0\");\n-    reject_expr_parse(\"0 <- #![attr] 0\");\n-\n-    check_expr_attrs(\"in #[attr] 0 {#[attr] 0}\", none);\n-    check_expr_attrs(\"#[attr] (in 0 {0})\", outer);\n-    reject_expr_parse(\"in 0 #[attr] {0}\");\n-    reject_expr_parse(\"in 0 {#![attr] 0}\");\n-\n     check_expr_attrs(\"#[attr] [#![attr]]\", both);\n     check_expr_attrs(\"#[attr] [#![attr] 0]\", both);\n     check_expr_attrs(\"#[attr] [#![attr] 0; 0]\", both);"}, {"sha": "920760cd34ac8d0ecd3eb1ad6f94ed6a1ae38b6c", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -84,18 +84,11 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n \n     let mut g = |e| f(expr(e));\n \n-    for kind in 0 .. 17 {\n+    for kind in 0 .. 16 {\n         match kind {\n             0 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Box(e))),\n-            1 => {\n-                // Note that for binary expressions, we explore each side separately.  The\n-                // parenthesization decisions for the LHS and RHS should be independent, and this\n-                // way produces `O(n)` results instead of `O(n^2)`.\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::InPlace(e, make_x())));\n-                iter_exprs(depth - 1, &mut |e| g(ExprKind::InPlace(make_x(), e)));\n-            },\n-            2 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n-            3 => {\n+            1 => iter_exprs(depth - 1, &mut |e| g(ExprKind::Call(e, vec![]))),\n+            2 => {\n                 let seg = PathSegment {\n                     identifier: Ident::from_str(\"x\"),\n                     span: DUMMY_SP,\n@@ -107,25 +100,25 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::MethodCall(\n                             seg.clone(), vec![make_x(), e])));\n             },\n-            4 => {\n+            3 => {\n                 let op = Spanned { span: DUMMY_SP, node: BinOpKind::Add };\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n             },\n-            5 => {\n+            4 => {\n                 let op = Spanned { span: DUMMY_SP, node: BinOpKind::Mul };\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n             },\n-            6 => {\n+            5 => {\n                 let op = Spanned { span: DUMMY_SP, node: BinOpKind::Shl };\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Binary(op, make_x(), e)));\n             },\n-            7 => {\n+            6 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Unary(UnOp::Deref, e)));\n             },\n-            8 => {\n+            7 => {\n                 let block = P(Block {\n                     stmts: Vec::new(),\n                     id: DUMMY_NODE_ID,\n@@ -135,7 +128,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 });\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::If(e, block.clone(), None)));\n             },\n-            9 => {\n+            8 => {\n                 let decl = P(FnDecl {\n                     inputs: vec![],\n                     output: FunctionRetTy::Default(DUMMY_SP),\n@@ -148,28 +141,28 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                                           e,\n                                           DUMMY_SP)));\n             },\n-            10 => {\n+            9 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(e, make_x())));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Assign(make_x(), e)));\n             },\n-            11 => {\n+            10 => {\n                 let ident = Spanned { span: DUMMY_SP, node: Ident::from_str(\"f\") };\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Field(e, ident)));\n             },\n-            12 => {\n+            11 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n                             Some(e), Some(make_x()), RangeLimits::HalfOpen)));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Range(\n                             Some(make_x()), Some(e), RangeLimits::HalfOpen)));\n             },\n-            13 => {\n+            12 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::AddrOf(Mutability::Immutable, e)));\n             },\n-            14 => {\n+            13 => {\n                 g(ExprKind::Ret(None));\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Ret(Some(e))));\n             },\n-            15 => {\n+            14 => {\n                 let seg = PathSegment {\n                     identifier: Ident::from_str(\"S\"),\n                     span: DUMMY_SP,\n@@ -181,7 +174,7 @@ fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n                 };\n                 g(ExprKind::Struct(path, vec![], Some(make_x())));\n             },\n-            16 => {\n+            15 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));\n             },\n             _ => panic!(\"bad counter value in iter_exprs\"),"}, {"sha": "6598b70b3d5cdc8119edfadfe1d06798b69ce7bd", "filename": "src/test/run-pass/new-box-syntax.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b5859aea199d5f34a4d4b5ae7112c5c41f3b242/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnew-box-syntax.rs?ref=9b5859aea199d5f34a4d4b5ae7112c5c41f3b242", "patch": "@@ -14,24 +14,18 @@\n  * http://creativecommons.org/publicdomain/zero/1.0/ */\n \n #![allow(dead_code, unused_variables)]\n-#![feature(box_syntax, box_heap)]\n-#![feature(placement_in_syntax)]\n-\n-// during check-pretty, the expanded code needs to opt into these\n-// features\n-#![feature(placement_new_protocol, core_intrinsics)]\n+#![feature(box_syntax)]\n \n // Tests that the new `box` syntax works with unique pointers.\n \n-use std::boxed::{Box, HEAP};\n+use std::boxed::Box;\n \n struct Structure {\n     x: isize,\n     y: isize,\n }\n \n pub fn main() {\n-    let x: Box<isize> = in HEAP { 2 };\n     let y: Box<isize> = box 2;\n     let b: Box<isize> = box (1 + 2);\n     let c = box (3 + 4);"}, {"sha": "7bda9ae252439b5cfc27014583bac8e6f8eb9d9b", "filename": "src/test/run-pass/placement-in-syntax.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Frun-pass%2Fplacement-in-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Frun-pass%2Fplacement-in-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fplacement-in-syntax.rs?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,37 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code, unused_variables)]\n-#![feature(box_heap)]\n-#![feature(placement_in_syntax)]\n-\n-// Tests that the new `in` syntax works with unique pointers.\n-//\n-// Compare with new-box-syntax.rs\n-\n-use std::boxed::{Box, HEAP};\n-\n-struct Structure {\n-    x: isize,\n-    y: isize,\n-}\n-\n-pub fn main() {\n-    let x: Box<isize> = in HEAP { 2 };\n-    let b: Box<isize> = in HEAP { 1 + 2 };\n-    let c = in HEAP { 3 + 4 };\n-\n-    let s: Box<Structure> = in HEAP {\n-        Structure {\n-            x: 3,\n-            y: 4,\n-        }\n-    };\n-}"}, {"sha": "e3478876763b4dcffc4eea579be871794ce181ba", "filename": "src/test/ui/feature-gate-placement-expr.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fui%2Ffeature-gate-placement-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fui%2Ffeature-gate-placement-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-placement-expr.rs?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// gate-test-placement_in_syntax\n-\n-// Check that `in PLACE { EXPR }` is feature-gated.\n-//\n-// See also feature-gate-box-expr.rs\n-//\n-// (Note that the two tests are separated since the checks appear to\n-// be performed at distinct phases, with an abort_if_errors call\n-// separating them.)\n-\n-fn main() {\n-    use std::boxed::HEAP;\n-\n-    let x = HEAP <- 'c'; //~ ERROR placement-in expression syntax is experimental\n-    println!(\"x: {}\", x);\n-}"}, {"sha": "b5c091763a1b42f48a24b2356c50bb9a3de2f16e", "filename": "src/test/ui/feature-gate-placement-expr.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fui%2Ffeature-gate-placement-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5ee891cfeabc0872624104611cc0a359f46447cc/src%2Ftest%2Fui%2Ffeature-gate-placement-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-placement-expr.stderr?ref=5ee891cfeabc0872624104611cc0a359f46447cc", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: placement-in expression syntax is experimental and subject to change. (see issue #27779)\n-  --> $DIR/feature-gate-placement-expr.rs:24:13\n-   |\n-LL |     let x = HEAP <- 'c'; //~ ERROR placement-in expression syntax is experimental\n-   |             ^^^^^^^^^^^\n-   |\n-   = help: add #![feature(placement_in_syntax)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}]}