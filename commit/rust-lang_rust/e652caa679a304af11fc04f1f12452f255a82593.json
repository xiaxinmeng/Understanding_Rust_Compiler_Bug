{"sha": "e652caa679a304af11fc04f1f12452f255a82593", "node_id": "C_kwDOAAsO6NoAKGU2NTJjYWE2NzlhMzA0YWYxMWZjMDRmMWYxMjQ1MmYyNTVhODI1OTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T22:32:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-11T22:32:20Z"}, "message": "Auto merge of #97705 - compiler-errors:guide-inference, r=lcnr\n\nFix inference issues with unconstrained base expr in `type_changing_struct_update`\n\nUse fresh infer vars to guide inference along in `type_changing_struct_update`.\n\nFixes #96878", "tree": {"sha": "aa2e1bb0c1cd3214a7f6583d877e3cfadc591b36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa2e1bb0c1cd3214a7f6583d877e3cfadc591b36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e652caa679a304af11fc04f1f12452f255a82593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e652caa679a304af11fc04f1f12452f255a82593", "html_url": "https://github.com/rust-lang/rust/commit/e652caa679a304af11fc04f1f12452f255a82593", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e652caa679a304af11fc04f1f12452f255a82593/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99930ac7f8cbb5d9b319b2e2e92794fd6f24f556", "url": "https://api.github.com/repos/rust-lang/rust/commits/99930ac7f8cbb5d9b319b2e2e92794fd6f24f556", "html_url": "https://github.com/rust-lang/rust/commit/99930ac7f8cbb5d9b319b2e2e92794fd6f24f556"}, {"sha": "50529111f0d8f21573b72029b3b06616b8735b7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/50529111f0d8f21573b72029b3b06616b8735b7f", "html_url": "https://github.com/rust-lang/rust/commit/50529111f0d8f21573b72029b3b06616b8735b7f"}], "stats": {"total": 183, "additions": 116, "deletions": 67}, "files": [{"sha": "bf5bd744f629869d3fc6abe4864c405408c91231", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 85, "deletions": 67, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/e652caa679a304af11fc04f1f12452f255a82593/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e652caa679a304af11fc04f1f12452f255a82593/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=e652caa679a304af11fc04f1f12452f255a82593", "patch": "@@ -41,8 +41,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::InferOk;\n use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n-use rustc_middle::ty::error::ExpectedFound;\n-use rustc_middle::ty::error::TypeError::{FieldMisMatch, Sorts};\n+use rustc_middle::ty::error::TypeError::FieldMisMatch;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TypeFoldable};\n use rustc_session::parse::feature_err;\n@@ -65,7 +64,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        extend_err: impl Fn(&mut Diagnostic),\n+        extend_err: impl FnMut(&mut Diagnostic),\n     ) -> Ty<'tcx> {\n         self.check_expr_meets_expectation_or_error(expr, ExpectHasType(expected), extend_err)\n     }\n@@ -74,7 +73,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n         expected: Expectation<'tcx>,\n-        extend_err: impl Fn(&mut Diagnostic),\n+        mut extend_err: impl FnMut(&mut Diagnostic),\n     ) -> Ty<'tcx> {\n         let expected_ty = expected.to_option(&self).unwrap_or(self.tcx.types.bool);\n         let mut ty = self.check_expr_with_expectation(expr, expected);\n@@ -1480,10 +1479,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // re-link the regions that EIfEO can erase.\n         self.demand_eqtype(span, adt_ty_hint, adt_ty);\n \n-        let (substs, adt_kind, kind_name) = match adt_ty.kind() {\n-            ty::Adt(adt, substs) => (substs, adt.adt_kind(), adt.variant_descr()),\n-            _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\"),\n+        let ty::Adt(adt, substs) = adt_ty.kind() else {\n+            span_bug!(span, \"non-ADT passed to check_expr_struct_fields\");\n         };\n+        let adt_kind = adt.adt_kind();\n \n         let mut remaining_fields = variant\n             .fields\n@@ -1521,7 +1520,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     });\n                 } else {\n                     self.report_unknown_field(\n-                        adt_ty, variant, field, ast_fields, kind_name, expr_span,\n+                        adt_ty,\n+                        variant,\n+                        field,\n+                        ast_fields,\n+                        adt.variant_descr(),\n+                        expr_span,\n                     );\n                 }\n \n@@ -1534,7 +1538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // Make sure the programmer specified correct number of fields.\n-        if kind_name == \"union\" {\n+        if adt_kind == AdtKind::Union {\n             if ast_fields.len() != 1 {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -1557,67 +1561,81 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // FIXME: We are currently creating two branches here in order to maintain\n             // consistency. But they should be merged as much as possible.\n             let fru_tys = if self.tcx.features().type_changing_struct_update {\n-                let base_ty = self.check_expr(base_expr);\n-                match adt_ty.kind() {\n-                    ty::Adt(adt, substs) if adt.is_struct() => {\n-                        match base_ty.kind() {\n-                            ty::Adt(base_adt, base_subs) if adt == base_adt => {\n-                                variant\n-                                    .fields\n-                                    .iter()\n-                                    .map(|f| {\n-                                        let fru_ty = self.normalize_associated_types_in(\n-                                            expr_span,\n-                                            self.field_ty(base_expr.span, f, base_subs),\n-                                        );\n-                                        let ident = self\n-                                            .tcx\n-                                            .adjust_ident(f.ident(self.tcx), variant.def_id);\n-                                        if let Some(_) = remaining_fields.remove(&ident) {\n-                                            let target_ty =\n-                                                self.field_ty(base_expr.span, f, substs);\n-                                            let cause = self.misc(base_expr.span);\n-                                            match self\n-                                                .at(&cause, self.param_env)\n-                                                .sup(target_ty, fru_ty)\n-                                            {\n-                                                Ok(InferOk { obligations, value: () }) => {\n-                                                    self.register_predicates(obligations)\n-                                                }\n-                                                // FIXME: Need better diagnostics for `FieldMisMatch` error\n-                                                Err(_) => {\n-                                                    self.report_mismatched_types(\n-                                                        &cause,\n-                                                        target_ty,\n-                                                        fru_ty,\n-                                                        FieldMisMatch(variant.name, ident.name),\n-                                                    )\n-                                                    .emit();\n-                                                }\n-                                            }\n+                if let ty::Adt(adt, substs) = adt_ty.kind() && adt.is_struct() {\n+                    // Make an ADT with fresh inference substitutions. This\n+                    // will allow us to guide inference along so that, e.g.\n+                    // ```\n+                    // let x = MyStruct<'a, B, const C: usize> {\n+                    //    f: 1,\n+                    //    ..Default::default()\n+                    // };\n+                    // ```\n+                    // will have the default base expression constrained to\n+                    // `MyStruct<'_, _, _>`, as opposed to just `_`... This\n+                    // will allow us to then do a subtyping relation on all\n+                    // of the `remaining_fields` below, per the RFC.\n+                    let fresh_substs = self.fresh_substs_for_item(base_expr.span, adt.did());\n+                    let fresh_base_ty = self.tcx.mk_adt(*adt, fresh_substs);\n+                    let base_ty = self.check_expr_has_type_or_error(\n+                        base_expr,\n+                        fresh_base_ty,\n+                        |_| {\n+                            error_happened = true;\n+                        },\n+                    );\n+                    let base_ty = self.shallow_resolve(base_ty);\n+                    if let ty::Adt(base_adt, base_substs) = base_ty.kind() && adt == base_adt {\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|f| {\n+                                let fru_ty = self.normalize_associated_types_in(\n+                                    expr_span,\n+                                    self.field_ty(base_expr.span, f, base_substs),\n+                                );\n+                                let ident = self\n+                                    .tcx\n+                                    .adjust_ident(f.ident(self.tcx), variant.def_id);\n+                                if let Some(_) = remaining_fields.remove(&ident) {\n+                                    let target_ty =\n+                                        self.field_ty(base_expr.span, f, substs);\n+                                    let cause = self.misc(base_expr.span);\n+                                    match self\n+                                        .at(&cause, self.param_env)\n+                                        .sup(target_ty, fru_ty)\n+                                    {\n+                                        Ok(InferOk { obligations, value: () }) => {\n+                                            self.register_predicates(obligations)\n                                         }\n-                                        fru_ty\n-                                    })\n-                                    .collect()\n-                            }\n-                            _ => {\n-                                self.report_mismatched_types(\n-                                    &self.misc(base_expr.span),\n-                                    adt_ty,\n-                                    base_ty,\n-                                    Sorts(ExpectedFound::new(true, adt_ty, base_ty)),\n-                                )\n-                                .emit();\n-                                return;\n-                            }\n+                                        // FIXME: Need better diagnostics for `FieldMisMatch` error\n+                                        Err(_) => {\n+                                            self.report_mismatched_types(\n+                                                &cause,\n+                                                target_ty,\n+                                                fru_ty,\n+                                                FieldMisMatch(variant.name, ident.name),\n+                                            )\n+                                            .emit();\n+                                        }\n+                                    }\n+                                }\n+                                self.resolve_vars_if_possible(fru_ty)\n+                            })\n+                            .collect()\n+                    } else {\n+                        if !error_happened && !base_ty.references_error() {\n+                            span_bug!(base_expr.span, \"expected an error to have been reported in `check_expr_has_type_or_error`\");\n                         }\n-                    }\n-                    _ => {\n-                        self.tcx\n-                            .sess\n-                            .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n                         return;\n                     }\n+                } else {\n+                    // Check the base_expr, regardless of a bad expected adt_ty, so we can get\n+                    // type errors on that expression, too.\n+                    self.check_expr(base_expr);\n+                    self.tcx\n+                        .sess\n+                        .emit_err(FunctionalRecordUpdateOnNonStruct { span: base_expr.span });\n+                    return;\n                 }\n             } else {\n                 self.check_expr_has_type_or_error(base_expr, adt_ty, |_| {\n@@ -1653,7 +1671,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n             self.typeck_results.borrow_mut().fru_field_types_mut().insert(expr_id, fru_tys);\n-        } else if kind_name != \"union\" && !remaining_fields.is_empty() {\n+        } else if adt_kind != AdtKind::Union && !remaining_fields.is_empty() {\n             let inaccessible_remaining_fields = remaining_fields.iter().any(|(_, (_, field))| {\n                 !field.vis.is_accessible_from(tcx.parent_module(expr_id).to_def_id(), tcx)\n             });"}, {"sha": "3dfbef0ee90fd83b4546e80ac28be86b66f2b4b8", "filename": "src/test/ui/rfcs/rfc-2528-type-changing-struct-update/issue-96878.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e652caa679a304af11fc04f1f12452f255a82593/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Fissue-96878.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e652caa679a304af11fc04f1f12452f255a82593/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Fissue-96878.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2528-type-changing-struct-update%2Fissue-96878.rs?ref=e652caa679a304af11fc04f1f12452f255a82593", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+\n+#![feature(type_changing_struct_update)]\n+#![allow(incomplete_features)]\n+\n+use std::borrow::Cow;\n+use std::marker::PhantomData;\n+\n+#[derive(Default)]\n+struct NonGeneric {\n+    field1: usize,\n+}\n+\n+#[derive(Default)]\n+struct Generic<T, U> {\n+    field1: T,\n+    field2: U,\n+}\n+\n+#[derive(Default)]\n+struct MoreGeneric<'a, const N: usize> {\n+    // If only `for<const N: usize> [u32; N]: Default`...\n+    field1: PhantomData<[u32; N]>,\n+    field2: Cow<'a, str>,\n+}\n+\n+fn main() {\n+    let default1 = NonGeneric { ..Default::default() };\n+    let default2: Generic<i32, f32> = Generic { ..Default::default() };\n+    let default3: MoreGeneric<'static, 12> = MoreGeneric { ..Default::default() };\n+}"}]}