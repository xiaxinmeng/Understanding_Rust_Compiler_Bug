{"sha": "fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMjA2YmYzNGEyNDYzMzE3YjlmYTFlZjNjMGZmMzVkOTIxZjg5MjA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-25T20:06:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-21T15:47:30Z"}, "message": "rustc_trans: evaluate `const fn` function and method calls.", "tree": {"sha": "eb3d1dcfe9ea3861ae5fa83fe278ffb08f059e0e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb3d1dcfe9ea3861ae5fa83fe278ffb08f059e0e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "html_url": "https://github.com/rust-lang/rust/commit/fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bd420555e7eb49c2c9a6ecc68e1797540bef403", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bd420555e7eb49c2c9a6ecc68e1797540bef403", "html_url": "https://github.com/rust-lang/rust/commit/1bd420555e7eb49c2c9a6ecc68e1797540bef403"}], "stats": {"total": 126, "additions": 93, "deletions": 33}, "files": [{"sha": "53a991170c70fb58841adcffbee0cf139e5928c4", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "patch": "@@ -278,14 +278,14 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs);\n+                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs);\n-                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs);\n+                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs, None);\n+                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs, None);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {"}, {"sha": "9310d1e202ab3b9d3b364aa4929f337027dbd7e4", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "patch": "@@ -2307,7 +2307,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs);\n+                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs, None);\n                     ccx.static_values().borrow_mut().insert(id, v);\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,"}, {"sha": "38272ca8bf4e5c007214d38891b0bbd8715e2dd3", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 89, "deletions": 29, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb206bf34a2463317b9fa1ef3c0ff35d921f8920/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=fb206bf34a2463317b9fa1ef3c0ff35d921f8920", "patch": "@@ -33,13 +33,16 @@ use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n+use util::nodemap::NodeMap;\n \n use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n+type FnArgMap<'a> = Option<&'a NodeMap<ValueRef>>;\n+\n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n@@ -163,6 +166,29 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n+fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           node: ExprOrMethodCall,\n+                           def_id: ast::DefId,\n+                           arg_vals: &[ValueRef],\n+                           param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n+    let fn_like = const_eval::lookup_const_fn_by_id(ccx.tcx(), def_id);\n+    let fn_like = fn_like.expect(\"lookup_const_fn_by_id failed in const_fn_call\");\n+\n+    let args = &fn_like.decl().inputs;\n+    assert_eq!(args.len(), arg_vals.len());\n+\n+    let arg_ids = args.iter().map(|arg| arg.pat.id);\n+    let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n+\n+    let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n+    match fn_like.body().expr {\n+        Some(ref expr) => {\n+            const_expr(ccx, &**expr, substs, Some(&fn_args)).0\n+        }\n+        None => C_nil(ccx)\n+    }\n+}\n+\n pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 def_id: ast::DefId,\n                                 ref_expr: &ast::Expr)\n@@ -221,9 +247,9 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n                                                   &ty::expr_ty(ccx.tcx(), expr));\n-        const_expr_unadjusted(ccx, expr, ty, param_substs)\n+        const_expr_unadjusted(ccx, expr, ty, param_substs, None)\n     } else {\n-        const_expr(ccx, expr, param_substs).0\n+        const_expr(ccx, expr, param_substs, None).0\n     };\n \n     // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -243,11 +269,12 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             e: &ast::Expr,\n-                            param_substs: &'tcx Substs<'tcx>)\n+                            param_substs: &'tcx Substs<'tcx>,\n+                            fn_args: FnArgMap)\n                             -> (ValueRef, Ty<'tcx>) {\n     let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                &ty::expr_ty(cx.tcx(), e));\n-    let llconst = const_expr_unadjusted(cx, e, ety, param_substs);\n+    let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args);\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                             &ty::expr_ty_adjusted(cx.tcx(), e));\n@@ -440,17 +467,19 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &ast::Expr,\n                                    ety: Ty<'tcx>,\n-                                   param_substs: &'tcx Substs<'tcx>)\n+                                   param_substs: &'tcx Substs<'tcx>,\n+                                   fn_args: FnArgMap)\n                                    -> ValueRef\n {\n     debug!(\"const_expr_unadjusted(e={}, ety={}, param_substs={})\",\n            e.repr(cx.tcx()),\n            ety.repr(cx.tcx()),\n            param_substs.repr(cx.tcx()));\n \n-    let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n-             .fold(Vec::new(), |mut l, val| { l.push(val); l })\n+    let map_list = |exprs: &[P<ast::Expr>]| -> Vec<ValueRef> {\n+        exprs.iter()\n+             .map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n+             .collect()\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n@@ -461,7 +490,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let (te1, ty) = const_expr(cx, &**e1, param_substs);\n+            let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n             debug!(\"const_expr_unadjusted: te1={}, ty={}\",\n                    cx.tn().val_to_string(te1),\n                    ty.repr(cx.tcx()));\n@@ -474,7 +503,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let is_float = ty::type_is_fp(intype);\n             let signed = ty::type_is_signed(intype);\n \n-            let (te2, _) = const_expr(cx, &**e2, param_substs);\n+            let (te2, _) = const_expr(cx, &**e2, param_substs, fn_args);\n \n             check_binary_expr_validity(cx, e, ty, te1, te2);\n \n@@ -534,7 +563,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           },\n           ast::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = const_expr(cx, &**inner_e, param_substs);\n+            let (te, ty) = const_expr(cx, &**inner_e, param_substs, fn_args);\n \n             check_unary_expr_validity(cx, e, ty, te);\n \n@@ -551,23 +580,23 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprField(ref base, field) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n           ast::ExprTupField(ref base, idx) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n                   adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n                   Ok(const_eval::const_int(i)) => i as u64,\n                   Ok(const_eval::const_uint(u)) => u,\n@@ -619,7 +648,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = const_expr(cx, &**base, param_substs);\n+            let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n             debug!(\"trans_const_cast({} as {})\", t_expr.repr(cx.tcx()), t_cast.repr(cx.tcx()));\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n@@ -707,12 +736,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               } else {\n                   // If this isn't the address of a static, then keep going through\n                   // normal constant evaluation.\n-                  let (v, _) = const_expr(cx, &**sub, param_substs);\n+                  let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n                   addr_of(cx, v, \"ref\")\n               }\n           }\n           ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n-              let (v, _) = const_expr(cx, &**sub, param_substs);\n+              let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n               addr_of_mut(cx, v, \"ref_mut_slice\")\n           }\n           ast::ExprTup(ref es) => {\n@@ -724,15 +753,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               let repr = adt::represent_type(cx, ety);\n \n               let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base, param_substs)),\n+                Some(ref base) => Some(const_expr(cx, &**base, param_substs, fn_args)),\n                 None => None\n               };\n \n               expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr, param_substs).0,\n+                          Some(ref f) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n                           None => {\n                               match base_val {\n                                   Some((bv, _)) => {\n@@ -757,7 +786,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprVec(ref es) => {\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n+            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n                               .collect::<Vec<_>>();\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n@@ -770,7 +799,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = ty::eval_repeat_count(cx.tcx(), count);\n-            let unit_val = const_expr(cx, &**elem, param_substs).0;\n+            let unit_val = const_expr(cx, &**elem, param_substs, fn_args).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[..], false)\n@@ -781,6 +810,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprPath(..) => {\n             let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n+                def::DefLocal(id) => {\n+                    if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n+                        val\n+                    } else {\n+                        cx.sess().span_bug(e.span, \"const fn argument not found\")\n+                    }\n+                }\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n@@ -816,18 +852,32 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprCall(ref callee, ref args) => {\n-              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-              let arg_vals = map_list(&args[..]);\n-              match opt_def {\n-                  Some(def::DefStruct(_)) => {\n+              let mut callee = &**callee;\n+              loop {\n+                  callee = match callee.node {\n+                      ast::ExprParen(ref inner) => &**inner,\n+                      ast::ExprBlock(ref block) => match block.expr {\n+                          Some(ref tail) => &**tail,\n+                          None => break\n+                      },\n+                      _ => break\n+                  };\n+              }\n+              let def = cx.tcx().def_map.borrow()[callee.id].full_def();\n+              let arg_vals = map_list(args);\n+              match def {\n+                  def::DefFn(did, _) | def::DefMethod(did, _) => {\n+                      const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n+                  }\n+                  def::DefStruct(_) => {\n                       if ty::type_is_simd(cx.tcx(), ety) {\n                           C_vector(&arg_vals[..])\n                       } else {\n                           let repr = adt::represent_type(cx, ety);\n                           adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n                       }\n                   }\n-                  Some(def::DefVariant(enum_did, variant_did, _)) => {\n+                  def::DefVariant(enum_did, variant_did, _) => {\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n@@ -837,13 +887,23 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                        vinfo.disr_val,\n                                        &arg_vals[..])\n                   }\n-                  _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n+                  _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\")\n               }\n           }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs).0,\n+          ast::ExprMethodCall(_, _, ref args) => {\n+              let arg_vals = map_list(args);\n+              let method_call = ty::MethodCall::expr(e.id);\n+              let method_did = match cx.tcx().method_map.borrow()[method_call].origin {\n+                  ty::MethodStatic(did) => did,\n+                  _ => cx.sess().span_bug(e.span, \"expected a const method def\")\n+              };\n+              const_fn_call(cx, MethodCallKey(method_call),\n+                            method_did, &arg_vals, param_substs)\n+          }\n+          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs, fn_args).0,\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr, param_substs).0,\n+                Some(ref expr) => const_expr(cx, &**expr, param_substs, fn_args).0,\n                 None => C_nil(cx)\n             }\n           }"}]}