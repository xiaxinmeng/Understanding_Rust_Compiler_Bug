{"sha": "37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YTk5MWFiYzAyNzFiM2RjMTNhYTQ2YmVkOTM4MWVkNmFhYTI2ZDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-21T06:27:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-21T06:27:36Z"}, "message": "Auto merge of #42664 - alexcrichton:moar-crates, r=eddyb\n\nRemove in-tree flate/getopts crates\n\nRemove `src/libflate` in favor of `flate2` on crates.io and `src/libgetopts` in favor of `getopts` on crates.io. The replacements have slightly different APIs and the usage in the compiler has been updated to reflect this.\n\nThis uncovered an unfortunate limitation of the compiler today to deal with linking everything correctly, and the workaround can be found documented in `src/librustc/Cargo.toml`.", "tree": {"sha": "4a7e80d92152c44df5c0100250229737c37da5bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a7e80d92152c44df5c0100250229737c37da5bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "html_url": "https://github.com/rust-lang/rust/commit/37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ccfe68076abc78392ab9e1d81b5c1a2123af657", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ccfe68076abc78392ab9e1d81b5c1a2123af657", "html_url": "https://github.com/rust-lang/rust/commit/6ccfe68076abc78392ab9e1d81b5c1a2123af657"}, {"sha": "5c3d0e6de3ed0d3506cb70737b348ea2113c70d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c3d0e6de3ed0d3506cb70737b348ea2113c70d8", "html_url": "https://github.com/rust-lang/rust/commit/5c3d0e6de3ed0d3506cb70737b348ea2113c70d8"}], "stats": {"total": 2796, "additions": 388, "deletions": 2408}, "files": [{"sha": "3c2786b8f8ee065b0eb957c1bed85f152dae6dbb", "filename": "COPYRIGHT", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -22,12 +22,6 @@ The Rust Project includes packages written by third parties.\n The following third party packages are included, and carry\n their own copyright notices and license terms:\n \n-* The src/rt/miniz.c file, carrying an implementation of\n-  RFC1950/RFC1951 DEFLATE, by Rich Geldreich\n-  <richgel99@gmail.com>. All uses of this file are\n-  permitted by the embedded \"unlicense\" notice\n-  (effectively: public domain with warranty disclaimer).\n-\n * LLVM. Code for this package is found in src/llvm.\n \n     Copyright (c) 2003-2013 University of Illinois at"}, {"sha": "6d7fcb71efa009cc19bb0db0392e54e2396901ef", "filename": "src/Cargo.lock", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -285,6 +285,7 @@ dependencies = [\n  \"diff 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -422,14 +423,6 @@ dependencies = [\n  \"libc 0.2.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"flate\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"build_helper 0.1.0\",\n- \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"flate2\"\n version = \"0.2.19\"\n@@ -463,10 +456,6 @@ name = \"gcc\"\n version = \"0.3.51\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"getopts\"\n-version = \"0.0.0\"\n-\n [[package]]\n name = \"getopts\"\n version = \"0.2.14\"\n@@ -1107,6 +1096,7 @@ name = \"rustc\"\n version = \"0.0.0\"\n dependencies = [\n  \"arena 0.0.0\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1296,7 +1286,7 @@ dependencies = [\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n- \"flate 0.0.0\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n@@ -1404,7 +1394,7 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n- \"flate 0.0.0\",\n+ \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1790,7 +1780,7 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"getopts 0.0.0\",\n+ \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.0.0\",\n ]\n "}, {"sha": "753bd1df0d83f37213015eb7808301971ae67852", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -567,7 +567,6 @@ pub fn rust_src(build: &Build) {\n         \"src/rustc/libc_shim\",\n         \"src/libtest\",\n         \"src/libterm\",\n-        \"src/libgetopts\",\n         \"src/compiler-rt\",\n         \"src/jemalloc\",\n         \"src/libprofiler_builtins\","}, {"sha": "e5c611460f73897ee3986277a60f9f8dd43974e5", "filename": "src/libflate/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibflate%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibflate%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2FCargo.toml?ref=6ccfe68076abc78392ab9e1d81b5c1a2123af657", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"flate\"\n-version = \"0.0.0\"\n-build = \"build.rs\"\n-\n-[lib]\n-name = \"flate\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[build-dependencies]\n-build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.50\""}, {"sha": "78d2ef1e37d2ac16111f4a71a1ea33bf926bfd1a", "filename": "src/libflate/build.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibflate%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibflate%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Fbuild.rs?ref=6ccfe68076abc78392ab9e1d81b5c1a2123af657", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate gcc;\n-\n-fn main() {\n-    println!(\"cargo:rerun-if-changed=../rt/miniz.c\");\n-    gcc::Config::new()\n-        .file(\"../rt/miniz.c\")\n-        .compile(\"libminiz.a\");\n-}"}, {"sha": "bc34e7810be3d7abd895ff51933397494e8a7061", "filename": "src/libflate/lib.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=6ccfe68076abc78392ab9e1d81b5c1a2123af657", "patch": "@@ -1,166 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple [DEFLATE][def]-based compression. This is a wrapper around the\n-//! [`miniz`][mz] library, which is a one-file pure-C implementation of zlib.\n-//!\n-//! [def]: https://en.wikipedia.org/wiki/DEFLATE\n-//! [mz]: https://code.google.com/p/miniz/\n-\n-#![crate_name = \"flate\"]\n-#![crate_type = \"rlib\"]\n-#![crate_type = \"dylib\"]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       test(attr(deny(warnings))))]\n-#![deny(warnings)]\n-\n-#![feature(libc)]\n-#![feature(unique)]\n-#![cfg_attr(test, feature(rand))]\n-\n-extern crate libc;\n-\n-use libc::{c_int, c_void, size_t};\n-use std::fmt;\n-use std::ops::Deref;\n-use std::ptr::Unique;\n-use std::slice;\n-\n-#[derive(Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub struct Error {\n-    _unused: (),\n-}\n-\n-impl Error {\n-    fn new() -> Error {\n-        Error { _unused: () }\n-    }\n-}\n-\n-impl fmt::Debug for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        \"decompression error\".fmt(f)\n-    }\n-}\n-\n-pub struct Bytes {\n-    ptr: Unique<u8>,\n-    len: usize,\n-}\n-\n-impl Deref for Bytes {\n-    type Target = [u8];\n-    fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.ptr.as_ptr(), self.len) }\n-    }\n-}\n-\n-impl Drop for Bytes {\n-    fn drop(&mut self) {\n-        unsafe {\n-            libc::free(self.ptr.as_ptr() as *mut _);\n-        }\n-    }\n-}\n-\n-extern \"C\" {\n-    /// Raw miniz compression function.\n-    fn tdefl_compress_mem_to_heap(psrc_buf: *const c_void,\n-                                  src_buf_len: size_t,\n-                                  pout_len: *mut size_t,\n-                                  flags: c_int)\n-                                  -> *mut c_void;\n-\n-    /// Raw miniz decompression function.\n-    fn tinfl_decompress_mem_to_heap(psrc_buf: *const c_void,\n-                                    src_buf_len: size_t,\n-                                    pout_len: *mut size_t,\n-                                    flags: c_int)\n-                                    -> *mut c_void;\n-}\n-\n-const LZ_FAST: c_int = 0x01;  // LZ with 1 probe, \"fast\"\n-const TDEFL_GREEDY_PARSING_FLAG: c_int = 0x04000; // fast greedy parsing instead of lazy parsing\n-\n-/// Compress a buffer without writing any sort of header on the output. Fast\n-/// compression is used because it is almost twice as fast as default\n-/// compression and the compression ratio is only marginally worse.\n-pub fn deflate_bytes(bytes: &[u8]) -> Bytes {\n-    let flags = LZ_FAST | TDEFL_GREEDY_PARSING_FLAG;\n-    unsafe {\n-        let mut outsz: size_t = 0;\n-        let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *const _,\n-                                             bytes.len() as size_t,\n-                                             &mut outsz,\n-                                             flags);\n-        assert!(!res.is_null());\n-        Bytes {\n-            ptr: Unique::new(res as *mut u8),\n-            len: outsz as usize,\n-        }\n-    }\n-}\n-\n-/// Decompress a buffer without parsing any sort of header on the input.\n-pub fn inflate_bytes(bytes: &[u8]) -> Result<Bytes, Error> {\n-    let flags = 0;\n-    unsafe {\n-        let mut outsz: size_t = 0;\n-        let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *const _,\n-                                               bytes.len() as size_t,\n-                                               &mut outsz,\n-                                               flags);\n-        if !res.is_null() {\n-            Ok(Bytes {\n-                ptr: Unique::new(res as *mut u8),\n-                len: outsz as usize,\n-            })\n-        } else {\n-            Err(Error::new())\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    #![allow(deprecated)]\n-    use super::{deflate_bytes, inflate_bytes};\n-    use std::__rand::{Rng, thread_rng};\n-\n-    #[test]\n-    fn test_flate_round_trip() {\n-        let mut r = thread_rng();\n-        let mut words = vec![];\n-        for _ in 0..20 {\n-            let range = r.gen_range(1, 10);\n-            let v = r.gen_iter::<u8>().take(range).collect::<Vec<u8>>();\n-            words.push(v);\n-        }\n-        for _ in 0..20 {\n-            let mut input = vec![];\n-            for _ in 0..2000 {\n-                input.extend_from_slice(r.choose(&words).unwrap());\n-            }\n-            let cmp = deflate_bytes(&input);\n-            let out = inflate_bytes(&cmp).unwrap();\n-            assert_eq!(&*input, &*out);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_zlib_flate() {\n-        let bytes = vec![1, 2, 3, 4, 5];\n-        let deflated = deflate_bytes(&bytes);\n-        let inflated = inflate_bytes(&deflated).unwrap();\n-        assert_eq!(&*inflated, &*bytes);\n-    }\n-}"}, {"sha": "99e3b892858884705877012ae485117c67459d1d", "filename": "src/libgetopts/Cargo.toml", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibgetopts%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Flibgetopts%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2FCargo.toml?ref=6ccfe68076abc78392ab9e1d81b5c1a2123af657", "patch": "@@ -1,9 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"getopts\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"getopts\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\", \"rlib\"]"}, {"sha": "3d59a4eb882dafc2cd5b79017b8fa6945e99b1d2", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -22,3 +22,32 @@ rustc_errors = { path = \"../librustc_errors\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+\n+# Note that these dependencies are a lie, they're just here to get linkage to\n+# work.\n+#\n+# We're creating a bunch of dylibs for the compiler but we're also compiling a\n+# bunch of crates.io crates. Everything in the compiler is compiled as an\n+# rlib/dylib pair but all crates.io crates tend to just be rlibs. This means\n+# we've got a problem for dependency graphs that look like:\n+#\n+#           foo - rustc_trans\n+#         /                  \\\n+#   rustc                     ---- rustc_driver\n+#         \\                     /\n+#           foo - rustc_metadata\n+#\n+# Here the crate `foo` is linked into the `rustc_trans` and the\n+# `rustc_metadata` dylibs, meaning we've got duplicate copies! When we then\n+# go to link `rustc_driver` the compiler notices this and gives us a compiler\n+# error.\n+#\n+# To work around this problem we just add these crates.io dependencies to the\n+# `rustc` crate which is a shared dependency above. That way the crate `foo`\n+# shows up in the dylib for the `rustc` crate, deduplicating it and allowing\n+# crates like `rustc_trans` to use `foo` *through* the `rustc` crate.\n+#\n+# tl;dr; this is not needed to get `rustc` to compile, but if you remove it then\n+#        later crate stop compiling. If you can remove this and everything\n+#        compiles, then please feel free to do so!\n+flate2 = \"0.2\""}, {"sha": "77a43c5319c5cd4fa97f51e3e4e724db497d1f24", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -41,6 +41,7 @@\n #![feature(discriminant_value)]\n #![feature(sort_unstable)]\n #![feature(trace_macros)]\n+#![feature(test)]\n \n #![recursion_limit=\"256\"]\n \n@@ -63,6 +64,11 @@ extern crate syntax_pos;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+// Note that librustc doesn't actually depend on these crates, see the note in\n+// `Cargo.toml` for this crate about why these are here.\n+extern crate flate2;\n+extern crate test;\n+\n #[macro_use]\n mod macros;\n "}, {"sha": "4f7ad5ea939f1ca4e662a2348df3242e6fddc27f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 72, "deletions": 52, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -1135,9 +1135,9 @@ pub enum OptionStability {\n     Unstable,\n }\n \n-#[derive(Clone, PartialEq, Eq)]\n pub struct RustcOptGroup {\n-    pub opt_group: getopts::OptGroup,\n+    pub apply: Box<Fn(&mut getopts::Options) -> &mut getopts::Options>,\n+    pub name: &'static str,\n     pub stability: OptionStability,\n }\n \n@@ -1146,12 +1146,24 @@ impl RustcOptGroup {\n         self.stability == OptionStability::Stable\n     }\n \n-    pub fn stable(g: getopts::OptGroup) -> RustcOptGroup {\n-        RustcOptGroup { opt_group: g, stability: OptionStability::Stable }\n+    pub fn stable<F>(name: &'static str, f: F) -> RustcOptGroup\n+        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n+    {\n+        RustcOptGroup {\n+            name: name,\n+            apply: Box::new(f),\n+            stability: OptionStability::Stable,\n+        }\n     }\n \n-    pub fn unstable(g: getopts::OptGroup) -> RustcOptGroup {\n-        RustcOptGroup { opt_group: g, stability: OptionStability::Unstable }\n+    pub fn unstable<F>(name: &'static str, f: F) -> RustcOptGroup\n+        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static,\n+    {\n+        RustcOptGroup {\n+            name: name,\n+            apply: Box::new(f),\n+            stability: OptionStability::Unstable,\n+        }\n     }\n }\n \n@@ -1170,55 +1182,65 @@ mod opt {\n     use super::RustcOptGroup;\n \n     pub type R = RustcOptGroup;\n-    pub type S<'a> = &'a str;\n+    pub type S = &'static str;\n+\n+    fn stable<F>(name: S, f: F) -> R\n+        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static\n+    {\n+        RustcOptGroup::stable(name, f)\n+    }\n \n-    fn stable(g: getopts::OptGroup) -> R { RustcOptGroup::stable(g) }\n-    fn unstable(g: getopts::OptGroup) -> R { RustcOptGroup::unstable(g) }\n+    fn unstable<F>(name: S, f: F) -> R\n+        where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static\n+    {\n+        RustcOptGroup::unstable(name, f)\n+    }\n+\n+    fn longer(a: S, b: S) -> S {\n+        if a.len() > b.len() {\n+            a\n+        } else {\n+            b\n+        }\n+    }\n \n     pub fn opt_s(a: S, b: S, c: S, d: S) -> R {\n-        stable(getopts::optopt(a, b, c, d))\n+        stable(longer(a, b), move |opts| opts.optopt(a, b, c, d))\n     }\n     pub fn multi_s(a: S, b: S, c: S, d: S) -> R {\n-        stable(getopts::optmulti(a, b, c, d))\n+        stable(longer(a, b), move |opts| opts.optmulti(a, b, c, d))\n     }\n     pub fn flag_s(a: S, b: S, c: S) -> R {\n-        stable(getopts::optflag(a, b, c))\n+        stable(longer(a, b), move |opts| opts.optflag(a, b, c))\n     }\n     pub fn flagopt_s(a: S, b: S, c: S, d: S) -> R {\n-        stable(getopts::optflagopt(a, b, c, d))\n+        stable(longer(a, b), move |opts| opts.optflagopt(a, b, c, d))\n     }\n     pub fn flagmulti_s(a: S, b: S, c: S) -> R {\n-        stable(getopts::optflagmulti(a, b, c))\n+        stable(longer(a, b), move |opts| opts.optflagmulti(a, b, c))\n     }\n \n     pub fn opt(a: S, b: S, c: S, d: S) -> R {\n-        unstable(getopts::optopt(a, b, c, d))\n+        unstable(longer(a, b), move |opts| opts.optopt(a, b, c, d))\n     }\n     pub fn multi(a: S, b: S, c: S, d: S) -> R {\n-        unstable(getopts::optmulti(a, b, c, d))\n+        unstable(longer(a, b), move |opts| opts.optmulti(a, b, c, d))\n     }\n     pub fn flag(a: S, b: S, c: S) -> R {\n-        unstable(getopts::optflag(a, b, c))\n+        unstable(longer(a, b), move |opts| opts.optflag(a, b, c))\n     }\n     pub fn flagopt(a: S, b: S, c: S, d: S) -> R {\n-        unstable(getopts::optflagopt(a, b, c, d))\n+        unstable(longer(a, b), move |opts| opts.optflagopt(a, b, c, d))\n     }\n     pub fn flagmulti(a: S, b: S, c: S) -> R {\n-        unstable(getopts::optflagmulti(a, b, c))\n+        unstable(longer(a, b), move |opts| opts.optflagmulti(a, b, c))\n     }\n }\n \n /// Returns the \"short\" subset of the rustc command line options,\n /// including metadata for each option, such as whether the option is\n /// part of the stable long-term interface for rustc.\n pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n-    let mut print_opts = vec![\"crate-name\", \"file-names\", \"sysroot\", \"cfg\",\n-                              \"target-list\", \"target-cpus\", \"target-features\",\n-                              \"relocation-models\", \"code-models\"];\n-    if nightly_options::is_nightly_build() {\n-        print_opts.push(\"target-spec-json\");\n-    }\n-\n     vec![\n         opt::flag_s(\"h\", \"help\", \"Display this message\"),\n         opt::multi_s(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n@@ -1238,8 +1260,10 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                               the compiler to emit\",\n                  \"[asm|llvm-bc|llvm-ir|obj|metadata|link|dep-info|mir]\"),\n         opt::multi_s(\"\", \"print\", \"Comma separated list of compiler information to \\\n-                               print on stdout\", &format!(\"[{}]\",\n-                               &print_opts.join(\"|\"))),\n+                               print on stdout\",\n+                     \"[crate-name|file-names|sysroot|cfg|target-list|\\\n+                       target-cpus|target-features|relocation-models|\\\n+                       code-models|target-spec-json]\"),\n         opt::flagmulti_s(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n         opt::opt_s(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n@@ -1267,7 +1291,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n /// long-term interface for rustc.\n pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     let mut opts = rustc_short_optgroups();\n-    opts.extend_from_slice(&[\n+    opts.extend(vec![\n         opt::multi_s(\"\", \"extern\", \"Specify where an external rust library is located\",\n                      \"NAME=PATH\"),\n         opt::opt_s(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n@@ -1680,27 +1704,22 @@ pub mod nightly_options {\n             if opt.stability == OptionStability::Stable {\n                 continue\n             }\n-            let opt_name = if opt.opt_group.long_name.is_empty() {\n-                &opt.opt_group.short_name\n-            } else {\n-                &opt.opt_group.long_name\n-            };\n-            if !matches.opt_present(opt_name) {\n+            if !matches.opt_present(opt.name) {\n                 continue\n             }\n-            if opt_name != \"Z\" && !has_z_unstable_option {\n+            if opt.name != \"Z\" && !has_z_unstable_option {\n                 early_error(ErrorOutputType::default(),\n                             &format!(\"the `-Z unstable-options` flag must also be passed to enable \\\n                                       the flag `{}`\",\n-                                     opt_name));\n+                                     opt.name));\n             }\n             if really_allows_unstable_options {\n                 continue\n             }\n             match opt.stability {\n                 OptionStability::Unstable => {\n                     let msg = format!(\"the option `{}` is only accepted on the \\\n-                                       nightly compiler\", opt_name);\n+                                       nightly compiler\", opt.name);\n                     early_error(ErrorOutputType::default(), &msg);\n                 }\n                 OptionStability::Stable => {}\n@@ -1869,7 +1888,7 @@ mod dep_tracking {\n mod tests {\n     use dep_graph::DepGraph;\n     use errors;\n-    use getopts::{getopts, OptGroup};\n+    use getopts;\n     use lint;\n     use middle::cstore::{self, DummyCrateStore};\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n@@ -1882,10 +1901,12 @@ mod tests {\n     use rustc_back::PanicStrategy;\n     use syntax::symbol::Symbol;\n \n-    fn optgroups() -> Vec<OptGroup> {\n-        super::rustc_optgroups().into_iter()\n-                                .map(|a| a.opt_group)\n-                                .collect()\n+    fn optgroups() -> getopts::Options {\n+        let mut opts = getopts::Options::new();\n+        for group in super::rustc_optgroups() {\n+            (group.apply)(&mut opts);\n+        }\n+        return opts\n     }\n \n     fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n@@ -1901,7 +1922,7 @@ mod tests {\n     fn test_switch_implies_cfg_test() {\n         let dep_graph = DepGraph::new(false);\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], &optgroups()) {\n+            &match optgroups().parse(&[\"--test\".to_string()]) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n@@ -1918,8 +1939,7 @@ mod tests {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let dep_graph = DepGraph::new(false);\n         let matches =\n-            &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           &optgroups()) {\n+            &match optgroups().parse(&[\"--test\".to_string(), \"--cfg=test\".to_string()]) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1939,9 +1959,9 @@ mod tests {\n     fn test_can_print_warnings() {\n         let dep_graph = DepGraph::new(false);\n         {\n-            let matches = getopts(&[\n+            let matches = optgroups().parse(&[\n                 \"-Awarnings\".to_string()\n-            ], &optgroups()).unwrap();\n+            ]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n@@ -1950,10 +1970,10 @@ mod tests {\n         }\n \n         {\n-            let matches = getopts(&[\n+            let matches = optgroups().parse(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], &optgroups()).unwrap();\n+            ]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,\n@@ -1962,9 +1982,9 @@ mod tests {\n         }\n \n         {\n-            let matches = getopts(&[\n+            let matches = optgroups().parse(&[\n                 \"-Adead_code\".to_string()\n-            ], &optgroups()).unwrap();\n+            ]).unwrap();\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, _) = build_session_options_and_crate_config(&matches);\n             let sess = build_session(sessopts, &dep_graph, None, registry,"}, {"sha": "b4a4aaaaf5c81ba5da9949d85615022519ca8c93", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -725,10 +725,10 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     } else {\n         config::rustc_short_optgroups()\n     };\n-    let groups: Vec<_> = groups.into_iter()\n-                               .filter(|x| include_unstable_options || x.is_stable())\n-                               .map(|x| x.opt_group)\n-                               .collect();\n+    let mut options = getopts::Options::new();\n+    for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n+        (option.apply)(&mut options);\n+    }\n     let message = format!(\"Usage: rustc [OPTIONS] INPUT\");\n     let extra_help = if verbose {\n         \"\"\n@@ -741,7 +741,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n               Print 'lint' options and default settings\n     -Z help             Print internal \\\n               options for debugging rustc{}\\n\",\n-             getopts::usage(&message, &groups),\n+             options.usage(&message),\n              extra_help);\n }\n \n@@ -955,11 +955,11 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n \n     // Parse with *all* options defined in the compiler, we don't worry about\n     // option stability here we just want to parse as much as possible.\n-    let all_groups: Vec<getopts::OptGroup> = config::rustc_optgroups()\n-                                                 .into_iter()\n-                                                 .map(|x| x.opt_group)\n-                                                 .collect();\n-    let matches = match getopts::getopts(&args, &all_groups) {\n+    let mut options = getopts::Options::new();\n+    for option in config::rustc_optgroups() {\n+        (option.apply)(&mut options);\n+    }\n+    let matches = match options.parse(args) {\n         Ok(m) => m,\n         Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n     };"}, {"sha": "67b459ea18f4af0ed646bfebff099b7e9dfa8b35", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -9,7 +9,7 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-flate = { path = \"../libflate\" }\n+flate2 = \"0.2\"\n log = \"0.3\"\n owning_ref = \"0.3.3\"\n proc_macro = { path = \"../libproc_macro\" }"}, {"sha": "12997f24c7471ab36b4fbb76bc2532e6282fc103", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -33,7 +33,7 @@ extern crate log;\n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n-extern crate flate;\n+extern crate flate2;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate owning_ref;\n extern crate rustc_errors as errors;"}, {"sha": "7a3575cb50bd72ebfc2e3b8c5dbf7073010969d4", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -242,7 +242,7 @@ use std::io::{self, Read};\n use std::path::{Path, PathBuf};\n use std::time::Instant;\n \n-use flate;\n+use flate2::read::ZlibDecoder;\n use owning_ref::{ErasedBoxRef, OwningRef};\n \n pub struct CrateMismatch {\n@@ -861,8 +861,9 @@ fn get_metadata_section_imp(target: &Target,\n             // Header is okay -> inflate the actual metadata\n             let compressed_bytes = &buf[header_len..];\n             debug!(\"inflating {} bytes of compressed metadata\", compressed_bytes.len());\n-            match flate::inflate_bytes(compressed_bytes) {\n-                Ok(inflated) => {\n+            let mut inflated = Vec::new();\n+            match ZlibDecoder::new(compressed_bytes).read_to_end(&mut inflated) {\n+                Ok(_) => {\n                     let buf = unsafe { OwningRef::new_assert_stable_address(inflated) };\n                     buf.map_owner_box().erase_owner()\n                 }"}, {"sha": "a36c561371187f148b39284e8e291a5b670adeaf", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -10,7 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-flate = { path = \"../libflate\" }\n+flate2 = \"0.2\"\n log = \"0.3\"\n owning_ref = \"0.3.3\"\n rustc = { path = \"../librustc\" }"}, {"sha": "7cd1ef772981e23b281665071e583822cde2f420", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -42,7 +42,8 @@ use std::mem;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::str;\n-use flate;\n+use flate2::Compression;\n+use flate2::write::ZlibEncoder;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::Span;\n@@ -570,7 +571,9 @@ fn link_rlib<'a>(sess: &'a Session,\n                                                  e))\n                 }\n \n-                let bc_data_deflated = flate::deflate_bytes(&bc_data);\n+                let mut bc_data_deflated = Vec::new();\n+                ZlibEncoder::new(&mut bc_data_deflated, Compression::Default)\n+                    .write_all(&bc_data).unwrap();\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,"}, {"sha": "a5f9a41470de48fbf35a6fee2c255538d1b53120", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -21,8 +21,9 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use back::write::{ModuleConfig, with_llvm_pmb};\n \n use libc;\n-use flate;\n+use flate2::read::ZlibDecoder;\n \n+use std::io::Read;\n use std::ffi::CString;\n use std::path::Path;\n \n@@ -112,13 +113,14 @@ pub fn run(sess: &session::Session,\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n                             (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as usize)];\n \n-                        match flate::inflate_bytes(compressed_data) {\n-                            Ok(inflated) => inflated,\n-                            Err(_) => {\n-                                sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                                   name))\n-                            }\n+                        let mut inflated = Vec::new();\n+                        let res = ZlibDecoder::new(compressed_data)\n+                            .read_to_end(&mut inflated);\n+                        if res.is_err() {\n+                            sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n+                                               name))\n                         }\n+                        inflated\n                     } else {\n                         sess.fatal(&format!(\"Unsupported bytecode format version {}\",\n                                            version))\n@@ -129,13 +131,14 @@ pub fn run(sess: &session::Session,\n                     // the object must be in the old, pre-versioning format, so\n                     // simply inflate everything and let LLVM decide if it can\n                     // make sense of it\n-                    match flate::inflate_bytes(bc_encoded) {\n-                        Ok(bc) => bc,\n-                        Err(_) => {\n-                            sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                               name))\n-                        }\n+                    let mut inflated = Vec::new();\n+                    let res = ZlibDecoder::new(bc_encoded)\n+                        .read_to_end(&mut inflated);\n+                    if res.is_err() {\n+                        sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n+                                           name))\n                     }\n+                    inflated\n                 })\n             };\n "}, {"sha": "54bc22963f5f78e42e582ae1bfe78145eba19165", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -727,7 +727,9 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                             link_meta: &LinkMeta,\n                             exported_symbols: &NodeSet)\n                             -> (ContextRef, ModuleRef, EncodedMetadata) {\n-    use flate;\n+    use std::io::Write;\n+    use flate2::Compression;\n+    use flate2::write::ZlibEncoder;\n \n     let (metadata_llcx, metadata_llmod) = unsafe {\n         context::create_context_and_module(tcx.sess, \"metadata\")\n@@ -767,7 +769,8 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n \n     assert!(kind == MetadataKind::Compressed);\n     let mut compressed = cstore.metadata_encoding_version().to_vec();\n-    compressed.extend_from_slice(&flate::deflate_bytes(&metadata.raw_data));\n+    ZlibEncoder::new(&mut compressed, Compression::Default)\n+        .write_all(&metadata.raw_data).unwrap();\n \n     let llmeta = C_bytes_in_context(metadata_llcx, &compressed);\n     let llconst = C_struct_in_context(metadata_llcx, &[llmeta], false);"}, {"sha": "41faf1fa768df2e20966c6cead2c3557136255f3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -39,7 +39,7 @@\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n \n-extern crate flate;\n+extern crate flate2;\n extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;"}, {"sha": "496662f442c41a01ef4c459f97ca0ada4eb800fe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 133, "deletions": 78, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -116,94 +116,149 @@ fn get_args() -> Option<Vec<String>> {\n         .collect()\n }\n \n-fn stable(g: getopts::OptGroup) -> RustcOptGroup { RustcOptGroup::stable(g) }\n-fn unstable(g: getopts::OptGroup) -> RustcOptGroup { RustcOptGroup::unstable(g) }\n+fn stable<F>(name: &'static str, f: F) -> RustcOptGroup\n+    where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static\n+{\n+    RustcOptGroup::stable(name, f)\n+}\n+\n+fn unstable<F>(name: &'static str, f: F) -> RustcOptGroup\n+    where F: Fn(&mut getopts::Options) -> &mut getopts::Options + 'static\n+{\n+    RustcOptGroup::unstable(name, f)\n+}\n \n pub fn opts() -> Vec<RustcOptGroup> {\n-    use getopts::*;\n     vec![\n-        stable(optflag(\"h\", \"help\", \"show this help message\")),\n-        stable(optflag(\"V\", \"version\", \"print rustdoc's version\")),\n-        stable(optflag(\"v\", \"verbose\", \"use verbose output\")),\n-        stable(optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n-                      \"[rust]\")),\n-        stable(optopt(\"w\", \"output-format\", \"the output type to write\",\n-                      \"[html]\")),\n-        stable(optopt(\"o\", \"output\", \"where to place the output\", \"PATH\")),\n-        stable(optopt(\"\", \"crate-name\", \"specify the name of this crate\", \"NAME\")),\n-        stable(optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n-                        \"DIR\")),\n-        stable(optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\")),\n-        stable(optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME=PATH\")),\n-        stable(optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\")),\n-        stable(optmulti(\"\", \"passes\",\n-                        \"list of passes to also run, you might want \\\n-                         to pass it multiple times; a value of `list` \\\n-                         will print available passes\",\n-                        \"PASSES\")),\n-        stable(optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n-                        \"PLUGINS\")),\n-        stable(optflag(\"\", \"no-defaults\", \"don't run the default passes\")),\n-        stable(optflag(\"\", \"test\", \"run code examples as tests\")),\n-        stable(optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n-                        \"ARGS\")),\n-        stable(optopt(\"\", \"target\", \"target triple to document\", \"TRIPLE\")),\n-        stable(optmulti(\"\", \"markdown-css\",\n-                        \"CSS files to include via <link> in a rendered Markdown file\",\n-                        \"FILES\")),\n-        stable(optmulti(\"\", \"html-in-header\",\n-                        \"files to include inline in the <head> section of a rendered Markdown file \\\n-                         or generated documentation\",\n-                        \"FILES\")),\n-        stable(optmulti(\"\", \"html-before-content\",\n-                        \"files to include inline between <body> and the content of a rendered \\\n-                         Markdown file or generated documentation\",\n-                        \"FILES\")),\n-        stable(optmulti(\"\", \"html-after-content\",\n-                        \"files to include inline between the content and </body> of a rendered \\\n-                         Markdown file or generated documentation\",\n-                        \"FILES\")),\n-        unstable(optmulti(\"\", \"markdown-before-content\",\n-                          \"files to include inline between <body> and the content of a rendered \\\n-                           Markdown file or generated documentation\",\n-                          \"FILES\")),\n-        unstable(optmulti(\"\", \"markdown-after-content\",\n-                          \"files to include inline between the content and </body> of a rendered \\\n-                           Markdown file or generated documentation\",\n-                          \"FILES\")),\n-        stable(optopt(\"\", \"markdown-playground-url\",\n-                      \"URL to send code snippets to\", \"URL\")),\n-        stable(optflag(\"\", \"markdown-no-toc\", \"don't include table of contents\")),\n-        stable(optopt(\"e\", \"extend-css\",\n-                      \"To add some CSS rules with a given file to generate doc with your \\\n-                       own theme. However, your theme might break if the rustdoc's generated HTML \\\n-                       changes, so be careful!\", \"PATH\")),\n-        unstable(optmulti(\"Z\", \"\",\n-                          \"internal and debugging options (only on nightly build)\", \"FLAG\")),\n-        stable(optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\")),\n-        unstable(optopt(\"\", \"playground-url\",\n-                        \"URL to send code snippets to, may be reset by --markdown-playground-url \\\n-                         or `#![doc(html_playground_url=...)]`\",\n-                        \"URL\")),\n-        unstable(optflag(\"\", \"enable-commonmark\", \"to enable commonmark doc rendering/testing\")),\n-        unstable(optflag(\"\", \"display-warnings\", \"to print code warnings when testing doc\")),\n+        stable(\"h\", |o| o.optflag(\"h\", \"help\", \"show this help message\")),\n+        stable(\"V\", |o| o.optflag(\"V\", \"version\", \"print rustdoc's version\")),\n+        stable(\"v\", |o| o.optflag(\"v\", \"verbose\", \"use verbose output\")),\n+        stable(\"r\", |o| {\n+            o.optopt(\"r\", \"input-format\", \"the input type of the specified file\",\n+                     \"[rust]\")\n+        }),\n+        stable(\"w\", |o| {\n+            o.optopt(\"w\", \"output-format\", \"the output type to write\", \"[html]\")\n+        }),\n+        stable(\"o\", |o| o.optopt(\"o\", \"output\", \"where to place the output\", \"PATH\")),\n+        stable(\"crate-name\", |o| {\n+            o.optopt(\"\", \"crate-name\", \"specify the name of this crate\", \"NAME\")\n+        }),\n+        stable(\"L\", |o| {\n+            o.optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n+                       \"DIR\")\n+        }),\n+        stable(\"cfg\", |o| o.optmulti(\"\", \"cfg\", \"pass a --cfg to rustc\", \"\")),\n+        stable(\"extern\", |o| {\n+            o.optmulti(\"\", \"extern\", \"pass an --extern to rustc\", \"NAME=PATH\")\n+        }),\n+        stable(\"plugin-path\", |o| {\n+            o.optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\")\n+        }),\n+        stable(\"passes\", |o| {\n+            o.optmulti(\"\", \"passes\",\n+                       \"list of passes to also run, you might want \\\n+                        to pass it multiple times; a value of `list` \\\n+                        will print available passes\",\n+                       \"PASSES\")\n+        }),\n+        stable(\"plugins\", |o| {\n+            o.optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n+                       \"PLUGINS\")\n+        }),\n+        stable(\"no-default\", |o| {\n+            o.optflag(\"\", \"no-defaults\", \"don't run the default passes\")\n+        }),\n+        stable(\"test\", |o| o.optflag(\"\", \"test\", \"run code examples as tests\")),\n+        stable(\"test-args\", |o| {\n+            o.optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n+                       \"ARGS\")\n+        }),\n+        stable(\"target\", |o| o.optopt(\"\", \"target\", \"target triple to document\", \"TRIPLE\")),\n+        stable(\"markdown-css\", |o| {\n+            o.optmulti(\"\", \"markdown-css\",\n+                       \"CSS files to include via <link> in a rendered Markdown file\",\n+                       \"FILES\")\n+        }),\n+        stable(\"html-in-header\", |o|  {\n+            o.optmulti(\"\", \"html-in-header\",\n+                       \"files to include inline in the <head> section of a rendered Markdown file \\\n+                        or generated documentation\",\n+                       \"FILES\")\n+        }),\n+        stable(\"html-before-content\", |o| {\n+            o.optmulti(\"\", \"html-before-content\",\n+                       \"files to include inline between <body> and the content of a rendered \\\n+                        Markdown file or generated documentation\",\n+                       \"FILES\")\n+        }),\n+        stable(\"html-after-content\", |o| {\n+            o.optmulti(\"\", \"html-after-content\",\n+                       \"files to include inline between the content and </body> of a rendered \\\n+                        Markdown file or generated documentation\",\n+                       \"FILES\")\n+        }),\n+        unstable(\"markdown-before-content\", |o| {\n+            o.optmulti(\"\", \"markdown-before-content\",\n+                       \"files to include inline between <body> and the content of a rendered \\\n+                        Markdown file or generated documentation\",\n+                       \"FILES\")\n+        }),\n+        unstable(\"markdown-after-content\", |o| {\n+            o.optmulti(\"\", \"markdown-after-content\",\n+                       \"files to include inline between the content and </body> of a rendered \\\n+                        Markdown file or generated documentation\",\n+                       \"FILES\")\n+        }),\n+        stable(\"markdown-playground-url\", |o| {\n+            o.optopt(\"\", \"markdown-playground-url\",\n+                     \"URL to send code snippets to\", \"URL\")\n+        }),\n+        stable(\"markdown-no-toc\", |o| {\n+            o.optflag(\"\", \"markdown-no-toc\", \"don't include table of contents\")\n+        }),\n+        stable(\"e\", |o| {\n+            o.optopt(\"e\", \"extend-css\",\n+                     \"To add some CSS rules with a given file to generate doc with your \\\n+                      own theme. However, your theme might break if the rustdoc's generated HTML \\\n+                      changes, so be careful!\", \"PATH\")\n+        }),\n+        unstable(\"Z\", |o| {\n+            o.optmulti(\"Z\", \"\",\n+                       \"internal and debugging options (only on nightly build)\", \"FLAG\")\n+        }),\n+        stable(\"sysroot\", |o| {\n+            o.optopt(\"\", \"sysroot\", \"Override the system root\", \"PATH\")\n+        }),\n+        unstable(\"playground-url\", |o| {\n+            o.optopt(\"\", \"playground-url\",\n+                     \"URL to send code snippets to, may be reset by --markdown-playground-url \\\n+                      or `#![doc(html_playground_url=...)]`\",\n+                     \"URL\")\n+        }),\n+        unstable(\"enable-commonmark\", |o| {\n+            o.optflag(\"\", \"enable-commonmark\", \"to enable commonmark doc rendering/testing\")\n+        }),\n+        unstable(\"display-warnings\", |o| {\n+            o.optflag(\"\", \"display-warnings\", \"to print code warnings when testing doc\")\n+        }),\n     ]\n }\n \n pub fn usage(argv0: &str) {\n-    println!(\"{}\",\n-             getopts::usage(&format!(\"{} [options] <input>\", argv0),\n-                            &opts().into_iter()\n-                                   .map(|x| x.opt_group)\n-                                   .collect::<Vec<getopts::OptGroup>>()));\n+    let mut options = getopts::Options::new();\n+    for option in opts() {\n+        (option.apply)(&mut options);\n+    }\n+    println!(\"{}\", options.usage(&format!(\"{} [options] <input>\", argv0)));\n }\n \n pub fn main_args(args: &[String]) -> isize {\n-    let all_groups: Vec<getopts::OptGroup> = opts()\n-                                             .into_iter()\n-                                             .map(|x| x.opt_group)\n-                                             .collect();\n-    let matches = match getopts::getopts(&args[1..], &all_groups) {\n+    let mut options = getopts::Options::new();\n+    for option in opts() {\n+        (option.apply)(&mut options);\n+    }\n+    let matches = match options.parse(&args[1..]) {\n         Ok(m) => m,\n         Err(err) => {\n             print_error(err);"}, {"sha": "ec77f953380813b1d7a98fe1a1b7c507dbd84a0c", "filename": "src/libtest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibtest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibtest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2FCargo.toml?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -9,5 +9,5 @@ path = \"lib.rs\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n-getopts = { path = \"../libgetopts\" }\n+getopts = \"0.2\"\n term = { path = \"../libterm\" }"}, {"sha": "2094fd8898d49a3ebc4ec369557358ea50d483da", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -372,30 +372,31 @@ impl TestOpts {\n /// Result of parsing the options.\n pub type OptRes = Result<TestOpts, String>;\n \n-#[cfg_attr(rustfmt, rustfmt_skip)]\n-fn optgroups() -> Vec<getopts::OptGroup> {\n-    vec![getopts::optflag(\"\", \"ignored\", \"Run ignored tests\"),\n-      getopts::optflag(\"\", \"test\", \"Run tests and not benchmarks\"),\n-      getopts::optflag(\"\", \"bench\", \"Run benchmarks instead of tests\"),\n-      getopts::optflag(\"\", \"list\", \"List all tests and benchmarks\"),\n-      getopts::optflag(\"h\", \"help\", \"Display this message (longer with --help)\"),\n-      getopts::optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n-                          of stdout\", \"PATH\"),\n-      getopts::optflag(\"\", \"nocapture\", \"don't capture stdout/stderr of each \\\n-                                         task, allow printing directly\"),\n-      getopts::optopt(\"\", \"test-threads\", \"Number of threads used for running tests \\\n-                                           in parallel\", \"n_threads\"),\n-      getopts::optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n-                                     be used multiple times)\",\"FILTER\"),\n-      getopts::optflag(\"q\", \"quiet\", \"Display one character per test instead of one line\"),\n-      getopts::optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\"),\n-      getopts::optopt(\"\", \"color\", \"Configure coloring of output:\n+fn optgroups() -> getopts::Options {\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"\", \"ignored\", \"Run ignored tests\")\n+        .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n+        .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n+        .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n+        .optflag(\"h\", \"help\", \"Display this message (longer with --help)\")\n+        .optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n+                                of stdout\", \"PATH\")\n+        .optflag(\"\", \"nocapture\", \"don't capture stdout/stderr of each \\\n+                                   task, allow printing directly\")\n+        .optopt(\"\", \"test-threads\", \"Number of threads used for running tests \\\n+                                     in parallel\", \"n_threads\")\n+        .optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n+                               be used multiple times)\",\"FILTER\")\n+        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line\")\n+        .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n+        .optopt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n             always = always colorize output;\n-            never  = never colorize output;\", \"auto|always|never\")]\n+            never  = never colorize output;\", \"auto|always|never\");\n+    return opts\n }\n \n-fn usage(binary: &str) {\n+fn usage(binary: &str, options: &getopts::Options) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n     println!(r#\"{usage}\n \n@@ -424,19 +425,19 @@ Test Attributes:\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n                      tests.\"#,\n-             usage = getopts::usage(&message, &optgroups()));\n+             usage = options.usage(&message));\n }\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n-    let args_ = &args[1..];\n-    let matches = match getopts::getopts(args_, &optgroups()) {\n+    let opts = optgroups();\n+    let matches = match opts.parse(&args[1..]) {\n         Ok(m) => m,\n         Err(f) => return Some(Err(f.to_string())),\n     };\n \n     if matches.opt_present(\"h\") {\n-        usage(&args[0]);\n+        usage(&args[0], &opts);\n         return None;\n     }\n "}, {"sha": "2daca9378a4a9211af931f2a28ce40330ae99dac", "filename": "src/rt/miniz.c", "status": "removed", "additions": 0, "deletions": 1890, "changes": 1890, "blob_url": "https://github.com/rust-lang/rust/blob/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Frt%2Fminiz.c", "raw_url": "https://github.com/rust-lang/rust/raw/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Frt%2Fminiz.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fminiz.c?ref=6ccfe68076abc78392ab9e1d81b5c1a2123af657", "patch": "@@ -1,1890 +0,0 @@\n-/* miniz.c v1.14 - public domain deflate/inflate, zlib-subset, ZIP reading/writing/appending, PNG writing\n-   See \"unlicense\" statement at the end of this file.\n-   Rich Geldreich <richgel99@gmail.com>, last updated May 20, 2012\n-   Implements RFC 1950: http://www.ietf.org/rfc/rfc1950.txt and RFC 1951: http://www.ietf.org/rfc/rfc1951.txt\n-\n-   Most API's defined in miniz.c are optional. For example, to disable the archive related functions just define\n-   MINIZ_NO_ARCHIVE_APIS, or to get rid of all stdio usage define MINIZ_NO_STDIO (see the list below for more macros).\n-\n-   * Change History\n-     5/20/12 v1.14 - MinGW32/64 GCC 4.6.1 compiler fixes: added MZ_FORCEINLINE, #include <time.h> (thanks fermtect).\n-     5/19/12 v1.13 - From jason@cornsyrup.org and kelwert@mtu.edu - Fix mz_crc32() so it doesn't compute the wrong CRC-32's when mz_ulong is 64-bit.\n-       Temporarily/locally slammed in \"typedef unsigned long mz_ulong\" and re-ran a randomized regression test on ~500k files.\n-       Eliminated a bunch of warnings when compiling with GCC 32-bit/64.\n-       Ran all examples, miniz.c, and tinfl.c through MSVC 2008's /analyze (static analysis) option and fixed all warnings (except for the silly\n-       \"Use of the comma-operator in a tested expression..\" analysis warning, which I purposely use to work around a MSVC compiler warning).\n-       Created 32-bit and 64-bit Codeblocks projects/workspace. Built and tested Linux executables. The codeblocks workspace is compatible with Linux+Win32/x64.\n-       Added miniz_tester solution/project, which is a useful little app derived from LZHAM's tester app that I use as part of the regression test.\n-       Ran miniz.c and tinfl.c through another series of regression testing on ~500,000 files and archives.\n-       Modified example5.c so it purposely disables a bunch of high-level functionality (MINIZ_NO_STDIO, etc.). (Thanks to corysama for the MINIZ_NO_STDIO bug report.)\n-       Fix ftell() usage in examples so they exit with an error on files which are too large (a limitation of the examples, not miniz itself).\n-     4/12/12 v1.12 - More comments, added low-level example5.c, fixed a couple minor level_and_flags issues in the archive API's.\n-      level_and_flags can now be set to MZ_DEFAULT_COMPRESSION. Thanks to Bruce Dawson <bruced@valvesoftware.com> for the feedback/bug report.\n-     5/28/11 v1.11 - Added statement from unlicense.org\n-     5/27/11 v1.10 - Substantial compressor optimizations:\n-      Level 1 is now ~4x faster than before. The L1 compressor's throughput now varies between 70-110MB/sec. on a\n-      Core i7 (actual throughput varies depending on the type of data, and x64 vs. x86).\n-      Improved baseline L2-L9 compression perf. Also, greatly improved compression perf. issues on some file types.\n-      Refactored the compression code for better readability and maintainability.\n-      Added level 10 compression level (L10 has slightly better ratio than level 9, but could have a potentially large\n-      drop in throughput on some files).\n-     5/15/11 v1.09 - Initial stable release.\n-\n-   * Low-level Deflate/Inflate implementation notes:\n-\n-     Compression: Use the \"tdefl\" API's. The compressor supports raw, static, and dynamic blocks, lazy or\n-     greedy parsing, match length filtering, RLE-only, and Huffman-only streams. It performs and compresses\n-     approximately as well as zlib.\n-\n-     Decompression: Use the \"tinfl\" API's. The entire decompressor is implemented as a single function\n-     coroutine: see tinfl_decompress(). It supports decompression into a 32KB (or larger power of 2) wrapping buffer, or into a memory\n-     block large enough to hold the entire file.\n-\n-     The low-level tdefl/tinfl API's do not make any use of dynamic memory allocation.\n-\n-   * Important: For best perf. be sure to customize the below macros for your target platform:\n-     #define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 1\n-     #define MINIZ_LITTLE_ENDIAN 1\n-     #define MINIZ_HAS_64BIT_REGISTERS 1\n-*/\n-\n-#ifndef MINIZ_HEADER_INCLUDED\n-#define MINIZ_HEADER_INCLUDED\n-\n-#include <stdlib.h>\n-\n-// Defines to completely disable specific portions of miniz.c:\n-// If all macros here are defined the only functionality remaining will be CRC-32, adler-32, tinfl, and tdefl.\n-\n-// Define MINIZ_NO_MALLOC to disable all calls to malloc, free, and realloc.\n-// Note if MINIZ_NO_MALLOC is defined then the user must always provide custom user alloc/free/realloc\n-// callbacks to the zlib and archive API's, and a few stand-alone helper API's which don't provide custom user\n-// functions (such as tdefl_compress_mem_to_heap() and tinfl_decompress_mem_to_heap()) won't work.\n-//#define MINIZ_NO_MALLOC\n-\n-#if defined(_M_IX86) || defined(_M_X64) || defined(__i386__) || defined(__i386) || defined(__i486__) || defined(__i486) || defined(i386) || defined(__ia64__) || defined(__x86_64__)\n-// MINIZ_X86_OR_X64_CPU is only used to help set the below macros.\n-#define MINIZ_X86_OR_X64_CPU 1\n-#endif\n-\n-#if (__BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n-// Set MINIZ_LITTLE_ENDIAN to 1 if the processor is little endian.\n-#define MINIZ_LITTLE_ENDIAN 1\n-#endif\n-\n-#if MINIZ_X86_OR_X64_CPU\n-// Set MINIZ_USE_UNALIGNED_LOADS_AND_STORES to 1 on CPU's that permit efficient integer loads and stores from unaligned addresses.\n-#define MINIZ_USE_UNALIGNED_LOADS_AND_STORES 0\n-#endif\n-\n-#if defined(_M_X64) || defined(_WIN64) || defined(__MINGW64__) || defined(_LP64) || defined(__LP64__) || defined(__ia64__) || defined(__x86_64__)\n-// Set MINIZ_HAS_64BIT_REGISTERS to 1 if operations on 64-bit integers are reasonably fast (and don't involve compiler generated calls to helper functions).\n-#define MINIZ_HAS_64BIT_REGISTERS 1\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-// ------------------- zlib-style API Definitions.\n-\n-// For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!\n-typedef unsigned long mz_ulong;\n-\n-// mz_free() internally uses the MZ_FREE() macro (which by default calls free() unless you've modified the MZ_MALLOC macro) to release a block allocated from the heap.\n-void mz_free(void *p);\n-\n-#define MZ_ADLER32_INIT (1)\n-// mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.\n-mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len);\n-\n-#define MZ_CRC32_INIT (0)\n-// mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.\n-mz_ulong mz_crc32(mz_ulong crc, const unsigned char *ptr, size_t buf_len);\n-\n-// Compression strategies.\n-enum { MZ_DEFAULT_STRATEGY = 0, MZ_FILTERED = 1, MZ_HUFFMAN_ONLY = 2, MZ_RLE = 3, MZ_FIXED = 4 };\n-\n-// Method\n-#define MZ_DEFLATED 8\n-\n-// ------------------- Types and macros\n-\n-typedef unsigned char mz_uint8;\n-typedef signed short mz_int16;\n-typedef unsigned short mz_uint16;\n-typedef unsigned int mz_uint32;\n-typedef unsigned int mz_uint;\n-typedef long long mz_int64;\n-typedef unsigned long long mz_uint64;\n-typedef int mz_bool;\n-\n-#define MZ_FALSE (0)\n-#define MZ_TRUE (1)\n-\n-// Works around MSVC's spammy \"warning C4127: conditional expression is constant\" message.\n-#ifdef _MSC_VER\n-   #define MZ_MACRO_END while (0, 0)\n-#else\n-   #define MZ_MACRO_END while (0)\n-#endif\n-\n-// ------------------- Low-level Decompression API Definitions\n-\n-// Decompression flags used by tinfl_decompress().\n-// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it's a valid zlib stream). Otherwise, the input is a raw deflate stream.\n-// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.\n-// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).\n-// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.\n-enum\n-{\n-  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,\n-  TINFL_FLAG_HAS_MORE_INPUT = 2,\n-  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,\n-  TINFL_FLAG_COMPUTE_ADLER32 = 8\n-};\n-\n-// High level decompression functions:\n-// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().\n-// On entry:\n-//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.\n-// On return:\n-//  Function returns a pointer to the decompressed data, or NULL on failure.\n-//  *pOut_len will be set to the decompressed data's size, which could be larger than src_buf_len on uncompressible data.\n-//  The caller must call mz_free() on the returned block when it's no longer needed.\n-void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);\n-\n-// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.\n-// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.\n-#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))\n-size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);\n-\n-// tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.\n-// Returns 1 on success or 0 on failure.\n-typedef int (*tinfl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);\n-int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);\n-\n-struct tinfl_decompressor_tag; typedef struct tinfl_decompressor_tag tinfl_decompressor;\n-\n-// Max size of LZ dictionary.\n-#define TINFL_LZ_DICT_SIZE 32768\n-\n-// Return status.\n-typedef enum\n-{\n-  TINFL_STATUS_BAD_PARAM = -3,\n-  TINFL_STATUS_ADLER32_MISMATCH = -2,\n-  TINFL_STATUS_FAILED = -1,\n-  TINFL_STATUS_DONE = 0,\n-  TINFL_STATUS_NEEDS_MORE_INPUT = 1,\n-  TINFL_STATUS_HAS_MORE_OUTPUT = 2\n-} tinfl_status;\n-\n-// Initializes the decompressor to its initial state.\n-#define tinfl_init(r) do { (r)->m_state = 0; } MZ_MACRO_END\n-#define tinfl_get_adler32(r) (r)->m_check_adler32\n-\n-// Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.\n-// This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.\n-tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags);\n-\n-// Internal/private bits follow.\n-enum\n-{\n-  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,\n-  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 << TINFL_FAST_LOOKUP_BITS\n-};\n-\n-typedef struct\n-{\n-  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];\n-  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];\n-} tinfl_huff_table;\n-\n-#if MINIZ_HAS_64BIT_REGISTERS\n-  #define TINFL_USE_64BIT_BITBUF 1\n-#endif\n-\n-#if TINFL_USE_64BIT_BITBUF\n-  typedef mz_uint64 tinfl_bit_buf_t;\n-  #define TINFL_BITBUF_SIZE (64)\n-#else\n-  typedef mz_uint32 tinfl_bit_buf_t;\n-  #define TINFL_BITBUF_SIZE (32)\n-#endif\n-\n-struct tinfl_decompressor_tag\n-{\n-  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];\n-  tinfl_bit_buf_t m_bit_buf;\n-  size_t m_dist_from_out_buf_start;\n-  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];\n-  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];\n-};\n-\n-// ------------------- Low-level Compression API Definitions\n-\n-// Set TDEFL_LESS_MEMORY to 1 to use less memory (compression will be slightly slower, and raw/dynamic blocks will be output more frequently).\n-#define TDEFL_LESS_MEMORY 0\n-\n-// tdefl_init() compression flags logically OR'd together (low 12 bits contain the max. number of probes per dictionary search):\n-// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).\n-enum\n-{\n-  TDEFL_HUFFMAN_ONLY = 0, TDEFL_DEFAULT_MAX_PROBES = 128, TDEFL_MAX_PROBES_MASK = 0xFFF\n-};\n-\n-// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you'll get raw deflate data.\n-// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).\n-// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.\n-// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor's initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).\n-// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)\n-// TDEFL_FILTER_MATCHES: Discards matches <= 5 chars if enabled.\n-// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.\n-// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.\n-enum\n-{\n-  TDEFL_WRITE_ZLIB_HEADER             = 0x01000,\n-  TDEFL_COMPUTE_ADLER32               = 0x02000,\n-  TDEFL_GREEDY_PARSING_FLAG           = 0x04000,\n-  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,\n-  TDEFL_RLE_MATCHES                   = 0x10000,\n-  TDEFL_FILTER_MATCHES                = 0x20000,\n-  TDEFL_FORCE_ALL_STATIC_BLOCKS       = 0x40000,\n-  TDEFL_FORCE_ALL_RAW_BLOCKS          = 0x80000\n-};\n-\n-// High level compression functions:\n-// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().\n-// On entry:\n-//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.\n-//  flags: The max match finder probes (default is 128) logically OR'd against the above flags. Higher probes are slower but improve compression.\n-// On return:\n-//  Function returns a pointer to the compressed data, or NULL on failure.\n-//  *pOut_len will be set to the compressed data's size, which could be larger than src_buf_len on uncompressible data.\n-//  The caller must free() the returned block when it's no longer needed.\n-void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags);\n-\n-// tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.\n-// Returns 0 on failure.\n-size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags);\n-\n-// Output stream interface. The compressor uses this interface to write compressed data. It'll typically be called TDEFL_OUT_BUF_SIZE at a time.\n-typedef mz_bool (*tdefl_put_buf_func_ptr)(const void* pBuf, int len, void *pUser);\n-\n-// tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.\n-mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);\n-\n-enum { TDEFL_MAX_HUFF_TABLES = 3, TDEFL_MAX_HUFF_SYMBOLS_0 = 288, TDEFL_MAX_HUFF_SYMBOLS_1 = 32, TDEFL_MAX_HUFF_SYMBOLS_2 = 19, TDEFL_LZ_DICT_SIZE = 32768, TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1, TDEFL_MIN_MATCH_LEN = 3, TDEFL_MAX_MATCH_LEN = 258 };\n-\n-// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).\n-#if TDEFL_LESS_MEMORY\n-enum { TDEFL_LZ_CODE_BUF_SIZE = 24 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 12, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };\n-#else\n-enum { TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 << TDEFL_LZ_HASH_BITS };\n-#endif\n-\n-// The low-level tdefl functions below may be used directly if the above helper functions aren't flexible enough. The low-level functions don't make any heap allocations, unlike the above helper functions.\n-typedef enum\n-{\n-  TDEFL_STATUS_BAD_PARAM = -2,\n-  TDEFL_STATUS_PUT_BUF_FAILED = -1,\n-  TDEFL_STATUS_OKAY = 0,\n-  TDEFL_STATUS_DONE = 1,\n-} tdefl_status;\n-\n-// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums\n-typedef enum\n-{\n-  TDEFL_NO_FLUSH = 0,\n-  TDEFL_SYNC_FLUSH = 2,\n-  TDEFL_FULL_FLUSH = 3,\n-  TDEFL_FINISH = 4\n-} tdefl_flush;\n-\n-// tdefl's compression state structure.\n-typedef struct\n-{\n-  tdefl_put_buf_func_ptr m_pPut_buf_func;\n-  void *m_pPut_buf_user;\n-  mz_uint m_flags, m_max_probes[2];\n-  int m_greedy_parsing;\n-  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;\n-  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;\n-  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;\n-  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;\n-  tdefl_status m_prev_return_status;\n-  const void *m_pIn_buf;\n-  void *m_pOut_buf;\n-  size_t *m_pIn_buf_size, *m_pOut_buf_size;\n-  tdefl_flush m_flush;\n-  const mz_uint8 *m_pSrc;\n-  size_t m_src_buf_left, m_out_buf_ofs;\n-  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];\n-  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n-  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n-  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];\n-  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];\n-  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];\n-  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];\n-  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];\n-} tdefl_compressor;\n-\n-// Initializes the compressor.\n-// There is no corresponding deinit() function because the tdefl API's do not dynamically allocate memory.\n-// pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.\n-// If pBut_buf_func is NULL the user should always call the tdefl_compress() API.\n-// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)\n-tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags);\n-\n-// Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.\n-tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush);\n-\n-// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.\n-// tdefl_compress_buffer() always consumes the entire input buffer.\n-tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush);\n-\n-tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d);\n-mz_uint32 tdefl_get_adler32(tdefl_compressor *d);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif // MINIZ_HEADER_INCLUDED\n-\n-// ------------------- End of Header: Implementation follows. (If you only want the header, define MINIZ_HEADER_FILE_ONLY.)\n-\n-#ifndef MINIZ_HEADER_FILE_ONLY\n-\n-typedef unsigned char mz_validate_uint16[sizeof(mz_uint16)==2 ? 1 : -1];\n-typedef unsigned char mz_validate_uint32[sizeof(mz_uint32)==4 ? 1 : -1];\n-typedef unsigned char mz_validate_uint64[sizeof(mz_uint64)==8 ? 1 : -1];\n-\n-#include <string.h>\n-#include <assert.h>\n-\n-#define MZ_ASSERT(x) assert(x)\n-\n-#ifdef MINIZ_NO_MALLOC\n-  #define MZ_MALLOC(x) NULL\n-  #define MZ_FREE(x) (void)x, ((void)0)\n-  #define MZ_REALLOC(p, x) NULL\n-#else\n-  #define MZ_MALLOC(x) malloc(x)\n-  #define MZ_FREE(x) free(x)\n-  #define MZ_REALLOC(p, x) realloc(p, x)\n-#endif\n-\n-#define MZ_MAX(a,b) (((a)>(b))?(a):(b))\n-#define MZ_MIN(a,b) (((a)<(b))?(a):(b))\n-#define MZ_CLEAR_OBJ(obj) memset(&(obj), 0, sizeof(obj))\n-\n-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n-  #define MZ_READ_LE16(p) *((const mz_uint16 *)(p))\n-  #define MZ_READ_LE32(p) *((const mz_uint32 *)(p))\n-#else\n-  #define MZ_READ_LE16(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U))\n-  #define MZ_READ_LE32(p) ((mz_uint32)(((const mz_uint8 *)(p))[0]) | ((mz_uint32)(((const mz_uint8 *)(p))[1]) << 8U) | ((mz_uint32)(((const mz_uint8 *)(p))[2]) << 16U) | ((mz_uint32)(((const mz_uint8 *)(p))[3]) << 24U))\n-#endif\n-\n-#ifdef _MSC_VER\n-  #define MZ_FORCEINLINE __forceinline\n-#elif defined(__GNUC__)\n-  #define MZ_FORCEINLINE inline __attribute__((__always_inline__))\n-#else\n-  #define MZ_FORCEINLINE\n-#endif\n-\n-#ifdef __cplusplus\n-  extern \"C\" {\n-#endif\n-\n-// ------------------- zlib-style API's\n-\n-mz_ulong mz_adler32(mz_ulong adler, const unsigned char *ptr, size_t buf_len)\n-{\n-  mz_uint32 i, s1 = (mz_uint32)(adler & 0xffff), s2 = (mz_uint32)(adler >> 16); size_t block_len = buf_len % 5552;\n-  if (!ptr) return MZ_ADLER32_INIT;\n-  while (buf_len) {\n-    for (i = 0; i + 7 < block_len; i += 8, ptr += 8) {\n-      s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;\n-      s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;\n-    }\n-    for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n-    s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;\n-  }\n-  return (s2 << 16) + s1;\n-}\n-\n-// Karl Malbrain's compact CRC-32. See \"A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed\": http://www.geocities.com/malbrain/\n-mz_ulong mz_crc32(mz_ulong crc, const mz_uint8 *ptr, size_t buf_len)\n-{\n-  static const mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,\n-    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };\n-  mz_uint32 crcu32 = (mz_uint32)crc;\n-  if (!ptr) return MZ_CRC32_INIT;\n-  crcu32 = ~crcu32; while (buf_len--) { mz_uint8 b = *ptr++; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b & 0xF)]; crcu32 = (crcu32 >> 4) ^ s_crc32[(crcu32 & 0xF) ^ (b >> 4)]; }\n-  return ~crcu32;\n-}\n-\n-void mz_free(void *p)\n-{\n-  MZ_FREE(p);\n-}\n-\n-// ------------------- Low-level Decompression (completely independent from all compression API's)\n-\n-#define TINFL_MEMCPY(d, s, l) memcpy(d, s, l)\n-#define TINFL_MEMSET(p, c, l) memset(p, c, l)\n-\n-#define TINFL_CR_BEGIN switch(r->m_state) { case 0:\n-#define TINFL_CR_RETURN(state_index, result) do { status = result; r->m_state = state_index; goto common_exit; case state_index:; } MZ_MACRO_END\n-#define TINFL_CR_RETURN_FOREVER(state_index, result) do { for ( ; ; ) { TINFL_CR_RETURN(state_index, result); } } MZ_MACRO_END\n-#define TINFL_CR_FINISH }\n-\n-// TODO: If the caller has indicated that there's no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never\n-// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0's in this scenario.\n-#define TINFL_GET_BYTE(state_index, c) do { \\\n-  if (pIn_buf_cur >= pIn_buf_end) { \\\n-    for ( ; ; ) { \\\n-      if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT) { \\\n-        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \\\n-        if (pIn_buf_cur < pIn_buf_end) { \\\n-          c = *pIn_buf_cur++; \\\n-          break; \\\n-        } \\\n-      } else { \\\n-        c = 0; \\\n-        break; \\\n-      } \\\n-    } \\\n-  } else c = *pIn_buf_cur++; } MZ_MACRO_END\n-\n-#define TINFL_NEED_BITS(state_index, n) do { mz_uint c; TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; } while (num_bits < (mz_uint)(n))\n-#define TINFL_SKIP_BITS(state_index, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END\n-#define TINFL_GET_BITS(state_index, b, n) do { if (num_bits < (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } b = bit_buf & ((1 << (n)) - 1); bit_buf >>= (n); num_bits -= (n); } MZ_MACRO_END\n-\n-// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.\n-// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a\n-// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the\n-// bit buffer contains >=15 bits (deflate's max. Huffman code size).\n-#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff) \\\n-  do { \\\n-    temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]; \\\n-    if (temp >= 0) { \\\n-      code_len = temp >> 9; \\\n-      if ((code_len) && (num_bits >= code_len)) \\\n-      break; \\\n-    } else if (num_bits > TINFL_FAST_LOOKUP_BITS) { \\\n-       code_len = TINFL_FAST_LOOKUP_BITS; \\\n-       do { \\\n-          temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; \\\n-       } while ((temp < 0) && (num_bits >= (code_len + 1))); if (temp >= 0) break; \\\n-    } TINFL_GET_BYTE(state_index, c); bit_buf |= (((tinfl_bit_buf_t)c) << num_bits); num_bits += 8; \\\n-  } while (num_bits < 15);\n-\n-// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It's more complex than you would initially expect because the zlib API expects the decompressor to never read\n-// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully\n-// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren't followed by a byte aligned adler-32.\n-// The slow path is only executed at the very end of the input buffer.\n-#define TINFL_HUFF_DECODE(state_index, sym, pHuff) do { \\\n-  int temp; mz_uint code_len, c; \\\n-  if (num_bits < 15) { \\\n-    if ((pIn_buf_end - pIn_buf_cur) < 2) { \\\n-       TINFL_HUFF_BITBUF_FILL(state_index, pHuff); \\\n-    } else { \\\n-       bit_buf |= (((tinfl_bit_buf_t)pIn_buf_cur[0]) << num_bits) | (((tinfl_bit_buf_t)pIn_buf_cur[1]) << (num_bits + 8)); pIn_buf_cur += 2; num_bits += 16; \\\n-    } \\\n-  } \\\n-  if ((temp = (pHuff)->m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0) \\\n-    code_len = temp >> 9, temp &= 511; \\\n-  else { \\\n-    code_len = TINFL_FAST_LOOKUP_BITS; do { temp = (pHuff)->m_tree[~temp + ((bit_buf >> code_len++) & 1)]; } while (temp < 0); \\\n-  } sym = temp; bit_buf >>= code_len; num_bits -= code_len; } MZ_MACRO_END\n-\n-tinfl_status tinfl_decompress(tinfl_decompressor *r, const mz_uint8 *pIn_buf_next, size_t *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, size_t *pOut_buf_size, const mz_uint32 decomp_flags)\n-{\n-  static const int s_length_base[31] = { 3,4,5,6,7,8,9,10,11,13, 15,17,19,23,27,31,35,43,51,59, 67,83,99,115,131,163,195,227,258,0,0 };\n-  static const int s_length_extra[31]= { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };\n-  static const int s_dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193, 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};\n-  static const int s_dist_extra[32] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};\n-  static const mz_uint8 s_length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };\n-  static const int s_min_table_sizes[3] = { 257, 1, 4 };\n-\n-  tinfl_status status = TINFL_STATUS_FAILED; mz_uint32 num_bits, dist, counter, num_extra; tinfl_bit_buf_t bit_buf;\n-  const mz_uint8 *pIn_buf_cur = pIn_buf_next, *const pIn_buf_end = pIn_buf_next + *pIn_buf_size;\n-  mz_uint8 *pOut_buf_cur = pOut_buf_next, *const pOut_buf_end = pOut_buf_next + *pOut_buf_size;\n-  size_t out_buf_size_mask = (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (size_t)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;\n-\n-  // Ensure the output buffer's size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn't matter).\n-  if (((out_buf_size_mask + 1) & out_buf_size_mask) || (pOut_buf_next < pOut_buf_start)) { *pIn_buf_size = *pOut_buf_size = 0; return TINFL_STATUS_BAD_PARAM; }\n-\n-  num_bits = r->m_num_bits; bit_buf = r->m_bit_buf; dist = r->m_dist; counter = r->m_counter; num_extra = r->m_num_extra; dist_from_out_buf_start = r->m_dist_from_out_buf_start;\n-  TINFL_CR_BEGIN\n-\n-  bit_buf = num_bits = dist = counter = num_extra = r->m_zhdr0 = r->m_zhdr1 = 0; r->m_z_adler32 = r->m_check_adler32 = 1;\n-  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)\n-  {\n-    TINFL_GET_BYTE(1, r->m_zhdr0); TINFL_GET_BYTE(2, r->m_zhdr1);\n-    counter = (((r->m_zhdr0 * 256 + r->m_zhdr1) % 31 != 0) || (r->m_zhdr1 & 32) || ((r->m_zhdr0 & 15) != 8));\n-    if (!(decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) counter |= (((1U << (8U + (r->m_zhdr0 >> 4))) > 32768U) || ((out_buf_size_mask + 1) < (size_t)(1U << (8U + (r->m_zhdr0 >> 4)))));\n-    if (counter) { TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED); }\n-  }\n-\n-  do\n-  {\n-    TINFL_GET_BITS(3, r->m_final, 3); r->m_type = r->m_final >> 1;\n-    if (r->m_type == 0)\n-    {\n-      TINFL_SKIP_BITS(5, num_bits & 7);\n-      for (counter = 0; counter < 4; ++counter) { if (num_bits) TINFL_GET_BITS(6, r->m_raw_header[counter], 8); else TINFL_GET_BYTE(7, r->m_raw_header[counter]); }\n-      if ((counter = (r->m_raw_header[0] | (r->m_raw_header[1] << 8))) != (mz_uint)(0xFFFF ^ (r->m_raw_header[2] | (r->m_raw_header[3] << 8)))) { TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED); }\n-      while ((counter) && (num_bits))\n-      {\n-        TINFL_GET_BITS(51, dist, 8);\n-        while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT); }\n-        *pOut_buf_cur++ = (mz_uint8)dist;\n-        counter--;\n-      }\n-      while (counter)\n-      {\n-        size_t n; while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT); }\n-        while (pIn_buf_cur >= pIn_buf_end)\n-        {\n-          if (decomp_flags & TINFL_FLAG_HAS_MORE_INPUT)\n-          {\n-            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);\n-          }\n-          else\n-          {\n-            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);\n-          }\n-        }\n-        n = MZ_MIN(MZ_MIN((size_t)(pOut_buf_end - pOut_buf_cur), (size_t)(pIn_buf_end - pIn_buf_cur)), counter);\n-        TINFL_MEMCPY(pOut_buf_cur, pIn_buf_cur, n); pIn_buf_cur += n; pOut_buf_cur += n; counter -= (mz_uint)n;\n-      }\n-    }\n-    else if (r->m_type == 3)\n-    {\n-      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);\n-    }\n-    else\n-    {\n-      if (r->m_type == 1)\n-      {\n-        mz_uint8 *p = r->m_tables[0].m_code_size; mz_uint i;\n-        r->m_table_sizes[0] = 288; r->m_table_sizes[1] = 32; TINFL_MEMSET(r->m_tables[1].m_code_size, 5, 32);\n-        for ( i = 0; i <= 143; ++i) *p++ = 8;\n-        for ( ; i <= 255; ++i) *p++ = 9;\n-        for ( ; i <= 279; ++i) *p++ = 7;\n-        for ( ; i <= 287; ++i) *p++ = 8;\n-      }\n-      else\n-      {\n-        for (counter = 0; counter < 3; counter++) { TINFL_GET_BITS(11, r->m_table_sizes[counter], \"\\05\\05\\04\"[counter]); r->m_table_sizes[counter] += s_min_table_sizes[counter]; }\n-        MZ_CLEAR_OBJ(r->m_tables[2].m_code_size); for (counter = 0; counter < r->m_table_sizes[2]; counter++) { mz_uint s; TINFL_GET_BITS(14, s, 3); r->m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s; }\n-        r->m_table_sizes[2] = 19;\n-      }\n-      for ( ; (int)r->m_type >= 0; r->m_type--)\n-      {\n-        int tree_next, tree_cur; tinfl_huff_table *pTable;\n-        mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16]; pTable = &r->m_tables[r->m_type]; MZ_CLEAR_OBJ(total_syms); MZ_CLEAR_OBJ(pTable->m_look_up); MZ_CLEAR_OBJ(pTable->m_tree);\n-        for (i = 0; i < r->m_table_sizes[r->m_type]; ++i) total_syms[pTable->m_code_size[i]]++;\n-        used_syms = 0, total = 0; next_code[0] = next_code[1] = 0;\n-        for (i = 1; i <= 15; ++i) { used_syms += total_syms[i]; next_code[i + 1] = (total = ((total + total_syms[i]) << 1)); }\n-        if ((65536 != total) && (used_syms > 1))\n-        {\n-          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);\n-        }\n-        for (tree_next = -1, sym_index = 0; sym_index < r->m_table_sizes[r->m_type]; ++sym_index)\n-        {\n-          mz_uint rev_code = 0, l, cur_code, code_size = pTable->m_code_size[sym_index]; if (!code_size) continue;\n-          cur_code = next_code[code_size]++; for (l = code_size; l > 0; l--, cur_code >>= 1) rev_code = (rev_code << 1) | (cur_code & 1);\n-          if (code_size <= TINFL_FAST_LOOKUP_BITS) { mz_int16 k = (mz_int16)((code_size << 9) | sym_index); while (rev_code < TINFL_FAST_LOOKUP_SIZE) { pTable->m_look_up[rev_code] = k; rev_code += (1 << code_size); } continue; }\n-          if (0 == (tree_cur = pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)])) { pTable->m_look_up[rev_code & (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; }\n-          rev_code >>= (TINFL_FAST_LOOKUP_BITS - 1);\n-          for (j = code_size; j > (TINFL_FAST_LOOKUP_BITS + 1); j--)\n-          {\n-            tree_cur -= ((rev_code >>= 1) & 1);\n-            if (!pTable->m_tree[-tree_cur - 1]) { pTable->m_tree[-tree_cur - 1] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; } else tree_cur = pTable->m_tree[-tree_cur - 1];\n-          }\n-          tree_cur -= ((rev_code >>= 1) & 1); pTable->m_tree[-tree_cur - 1] = (mz_int16)sym_index;\n-        }\n-        if (r->m_type == 2)\n-        {\n-          for (counter = 0; counter < (r->m_table_sizes[0] + r->m_table_sizes[1]); )\n-          {\n-            mz_uint s; TINFL_HUFF_DECODE(16, dist, &r->m_tables[2]); if (dist < 16) { r->m_len_codes[counter++] = (mz_uint8)dist; continue; }\n-            if ((dist == 16) && (!counter))\n-            {\n-              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);\n-            }\n-            num_extra = \"\\02\\03\\07\"[dist - 16]; TINFL_GET_BITS(18, s, num_extra); s += \"\\03\\03\\013\"[dist - 16];\n-            TINFL_MEMSET(r->m_len_codes + counter, (dist == 16) ? r->m_len_codes[counter - 1] : 0, s); counter += s;\n-          }\n-          if ((r->m_table_sizes[0] + r->m_table_sizes[1]) != counter)\n-          {\n-            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);\n-          }\n-          TINFL_MEMCPY(r->m_tables[0].m_code_size, r->m_len_codes, r->m_table_sizes[0]); TINFL_MEMCPY(r->m_tables[1].m_code_size, r->m_len_codes + r->m_table_sizes[0], r->m_table_sizes[1]);\n-        }\n-      }\n-      for ( ; ; )\n-      {\n-        mz_uint8 *pSrc;\n-        for ( ; ; )\n-        {\n-          if (((pIn_buf_end - pIn_buf_cur) < 4) || ((pOut_buf_end - pOut_buf_cur) < 2))\n-          {\n-            TINFL_HUFF_DECODE(23, counter, &r->m_tables[0]);\n-            if (counter >= 256)\n-              break;\n-            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT); }\n-            *pOut_buf_cur++ = (mz_uint8)counter;\n-          }\n-          else\n-          {\n-            int sym2; mz_uint code_len;\n-#if TINFL_USE_64BIT_BITBUF\n-            if (num_bits < 30) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE32(pIn_buf_cur)) << num_bits); pIn_buf_cur += 4; num_bits += 32; }\n-#else\n-            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }\n-#endif\n-            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)\n-              code_len = sym2 >> 9;\n-            else\n-            {\n-              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);\n-            }\n-            counter = sym2; bit_buf >>= code_len; num_bits -= code_len;\n-            if (counter & 256)\n-              break;\n-\n-#if !TINFL_USE_64BIT_BITBUF\n-            if (num_bits < 15) { bit_buf |= (((tinfl_bit_buf_t)MZ_READ_LE16(pIn_buf_cur)) << num_bits); pIn_buf_cur += 2; num_bits += 16; }\n-#endif\n-            if ((sym2 = r->m_tables[0].m_look_up[bit_buf & (TINFL_FAST_LOOKUP_SIZE - 1)]) >= 0)\n-              code_len = sym2 >> 9;\n-            else\n-            {\n-              code_len = TINFL_FAST_LOOKUP_BITS; do { sym2 = r->m_tables[0].m_tree[~sym2 + ((bit_buf >> code_len++) & 1)]; } while (sym2 < 0);\n-            }\n-            bit_buf >>= code_len; num_bits -= code_len;\n-\n-            pOut_buf_cur[0] = (mz_uint8)counter;\n-            if (sym2 & 256)\n-            {\n-              pOut_buf_cur++;\n-              counter = sym2;\n-              break;\n-            }\n-            pOut_buf_cur[1] = (mz_uint8)sym2;\n-            pOut_buf_cur += 2;\n-          }\n-        }\n-        if ((counter &= 511) == 256) break;\n-\n-        num_extra = s_length_extra[counter - 257]; counter = s_length_base[counter - 257];\n-        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(25, extra_bits, num_extra); counter += extra_bits; }\n-\n-        TINFL_HUFF_DECODE(26, dist, &r->m_tables[1]);\n-        num_extra = s_dist_extra[dist]; dist = s_dist_base[dist];\n-        if (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(27, extra_bits, num_extra); dist += extra_bits; }\n-\n-        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;\n-        if ((dist > dist_from_out_buf_start) && (decomp_flags & TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))\n-        {\n-          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);\n-        }\n-\n-        pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) & out_buf_size_mask);\n-\n-        if ((MZ_MAX(pOut_buf_cur, pSrc) + counter) > pOut_buf_end)\n-        {\n-          while (counter--)\n-          {\n-            while (pOut_buf_cur >= pOut_buf_end) { TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT); }\n-            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) & out_buf_size_mask];\n-          }\n-          continue;\n-        }\n-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n-        else if ((counter >= 9) && (counter <= dist))\n-        {\n-          const mz_uint8 *pSrc_end = pSrc + (counter & ~7);\n-          do\n-          {\n-            ((mz_uint32 *)pOut_buf_cur)[0] = ((const mz_uint32 *)pSrc)[0];\n-            ((mz_uint32 *)pOut_buf_cur)[1] = ((const mz_uint32 *)pSrc)[1];\n-            pOut_buf_cur += 8;\n-          } while ((pSrc += 8) < pSrc_end);\n-          if ((counter &= 7) < 3)\n-          {\n-            if (counter)\n-            {\n-              pOut_buf_cur[0] = pSrc[0];\n-              if (counter > 1)\n-                pOut_buf_cur[1] = pSrc[1];\n-              pOut_buf_cur += counter;\n-            }\n-            continue;\n-          }\n-        }\n-#endif\n-        do\n-        {\n-          pOut_buf_cur[0] = pSrc[0];\n-          pOut_buf_cur[1] = pSrc[1];\n-          pOut_buf_cur[2] = pSrc[2];\n-          pOut_buf_cur += 3; pSrc += 3;\n-        } while ((int)(counter -= 3) > 2);\n-        if ((int)counter > 0)\n-        {\n-          pOut_buf_cur[0] = pSrc[0];\n-          if ((int)counter > 1)\n-            pOut_buf_cur[1] = pSrc[1];\n-          pOut_buf_cur += counter;\n-        }\n-      }\n-    }\n-  } while (!(r->m_final & 1));\n-  if (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER)\n-  {\n-    TINFL_SKIP_BITS(32, num_bits & 7); for (counter = 0; counter < 4; ++counter) { mz_uint s; if (num_bits) TINFL_GET_BITS(41, s, 8); else TINFL_GET_BYTE(42, s); r->m_z_adler32 = (r->m_z_adler32 << 8) | s; }\n-  }\n-  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);\n-  TINFL_CR_FINISH\n-\n-common_exit:\n-  r->m_num_bits = num_bits; r->m_bit_buf = bit_buf; r->m_dist = dist; r->m_counter = counter; r->m_num_extra = num_extra; r->m_dist_from_out_buf_start = dist_from_out_buf_start;\n-  *pIn_buf_size = pIn_buf_cur - pIn_buf_next; *pOut_buf_size = pOut_buf_cur - pOut_buf_next;\n-  if ((decomp_flags & (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) && (status >= 0))\n-  {\n-    const mz_uint8 *ptr = pOut_buf_next; size_t buf_len = *pOut_buf_size;\n-    mz_uint32 i, s1 = r->m_check_adler32 & 0xffff, s2 = r->m_check_adler32 >> 16; size_t block_len = buf_len % 5552;\n-    while (buf_len)\n-    {\n-      for (i = 0; i + 7 < block_len; i += 8, ptr += 8)\n-      {\n-        s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;\n-        s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;\n-      }\n-      for ( ; i < block_len; ++i) s1 += *ptr++, s2 += s1;\n-      s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;\n-    }\n-    r->m_check_adler32 = (s2 << 16) + s1; if ((status == TINFL_STATUS_DONE) && (decomp_flags & TINFL_FLAG_PARSE_ZLIB_HEADER) && (r->m_check_adler32 != r->m_z_adler32)) status = TINFL_STATUS_ADLER32_MISMATCH;\n-  }\n-  return status;\n-}\n-\n-// Higher level helper functions.\n-void *tinfl_decompress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)\n-{\n-  tinfl_decompressor decomp; void *pBuf = NULL, *pNew_buf; size_t src_buf_ofs = 0, out_buf_capacity = 0;\n-  *pOut_len = 0;\n-  tinfl_init(&decomp);\n-  for ( ; ; )\n-  {\n-    size_t src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;\n-    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf + src_buf_ofs, &src_buf_size, (mz_uint8*)pBuf, pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &dst_buf_size,\n-      (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n-    if ((status < 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))\n-    {\n-      MZ_FREE(pBuf); *pOut_len = 0; return NULL;\n-    }\n-    src_buf_ofs += src_buf_size;\n-    *pOut_len += dst_buf_size;\n-    if (status == TINFL_STATUS_DONE) break;\n-    new_out_buf_capacity = out_buf_capacity * 2; if (new_out_buf_capacity < 128) new_out_buf_capacity = 128;\n-    pNew_buf = MZ_REALLOC(pBuf, new_out_buf_capacity);\n-    if (!pNew_buf)\n-    {\n-      MZ_FREE(pBuf); *pOut_len = 0; return NULL;\n-    }\n-    pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity;\n-  }\n-  return pBuf;\n-}\n-\n-size_t tinfl_decompress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)\n-{\n-  tinfl_decompressor decomp; tinfl_status status; tinfl_init(&decomp);\n-  status = tinfl_decompress(&decomp, (const mz_uint8*)pSrc_buf, &src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &out_buf_len, (flags & ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);\n-  return (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;\n-}\n-\n-int tinfl_decompress_mem_to_callback(const void *pIn_buf, size_t *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)\n-{\n-  int result = 0;\n-  tinfl_decompressor decomp;\n-  mz_uint8 *pDict = (mz_uint8*)MZ_MALLOC(TINFL_LZ_DICT_SIZE); size_t in_buf_ofs = 0, dict_ofs = 0;\n-  if (!pDict)\n-    return TINFL_STATUS_FAILED;\n-  tinfl_init(&decomp);\n-  for ( ; ; )\n-  {\n-    size_t in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;\n-    tinfl_status status = tinfl_decompress(&decomp, (const mz_uint8*)pIn_buf + in_buf_ofs, &in_buf_size, pDict, pDict + dict_ofs, &dst_buf_size,\n-      (flags & ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));\n-    in_buf_ofs += in_buf_size;\n-    if ((dst_buf_size) && (!(*pPut_buf_func)(pDict + dict_ofs, (int)dst_buf_size, pPut_buf_user)))\n-      break;\n-    if (status != TINFL_STATUS_HAS_MORE_OUTPUT)\n-    {\n-      result = (status == TINFL_STATUS_DONE);\n-      break;\n-    }\n-    dict_ofs = (dict_ofs + dst_buf_size) & (TINFL_LZ_DICT_SIZE - 1);\n-  }\n-  MZ_FREE(pDict);\n-  *pIn_buf_size = in_buf_ofs;\n-  return result;\n-}\n-\n-// ------------------- Low-level Compression (independent from all decompression API's)\n-\n-// Purposely making these tables static for faster init and thread safety.\n-static const mz_uint16 s_tdefl_len_sym[256] = {\n-  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,\n-  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,\n-  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,\n-  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,\n-  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,\n-  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,\n-  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,\n-  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };\n-\n-static const mz_uint8 s_tdefl_len_extra[256] = {\n-  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,\n-  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,\n-  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,\n-  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };\n-\n-static const mz_uint8 s_tdefl_small_dist_sym[512] = {\n-  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,\n-  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,\n-  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,\n-  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,\n-  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,\n-  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,\n-  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n-  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n-  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n-  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n-  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n-  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };\n-\n-static const mz_uint8 s_tdefl_small_dist_extra[512] = {\n-  0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,\n-  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n-  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,\n-  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n-  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n-  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n-  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,\n-  7,7,7,7,7,7,7,7 };\n-\n-static const mz_uint8 s_tdefl_large_dist_sym[128] = {\n-  0,0,18,19,20,20,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,\n-  26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,\n-  28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29 };\n-\n-static const mz_uint8 s_tdefl_large_dist_extra[128] = {\n-  0,0,8,8,9,9,9,9,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,\n-  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,\n-  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13 };\n-\n-// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.\n-typedef struct { mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;\n-static tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1)\n-{\n-  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2]; tdefl_sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1; MZ_CLEAR_OBJ(hist);\n-  for (i = 0; i < num_syms; i++) { mz_uint freq = pSyms0[i].m_key; hist[freq & 0xFF]++; hist[256 + ((freq >> 8) & 0xFF)]++; }\n-  while ((total_passes > 1) && (num_syms == hist[(total_passes - 1) * 256])) total_passes--;\n-  for (pass_shift = 0, pass = 0; pass < total_passes; pass++, pass_shift += 8)\n-  {\n-    const mz_uint32* pHist = &hist[pass << 8];\n-    mz_uint offsets[256], cur_ofs = 0;\n-    for (i = 0; i < 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }\n-    for (i = 0; i < num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key >> pass_shift) & 0xFF]++] = pCur_syms[i];\n-    { tdefl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }\n-  }\n-  return pCur_syms;\n-}\n-\n-// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.\n-static void tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, int n)\n-{\n-  int root, leaf, next, avbl, used, dpth;\n-  if (n==0) return; else if (n==1) { A[0].m_key = 1; return; }\n-  A[0].m_key += A[1].m_key; root = 0; leaf = 2;\n-  for (next=1; next < n-1; next++)\n-  {\n-    if (leaf>=n || A[root].m_key<A[leaf].m_key) { A[next].m_key = A[root].m_key; A[root++].m_key = (mz_uint16)next; } else A[next].m_key = A[leaf++].m_key;\n-    if (leaf>=n || (root<next && A[root].m_key<A[leaf].m_key)) { A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key); A[root++].m_key = (mz_uint16)next; } else A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);\n-  }\n-  A[n-2].m_key = 0; for (next=n-3; next>=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;\n-  avbl = 1; used = dpth = 0; root = n-2; next = n-1;\n-  while (avbl>0)\n-  {\n-    while (root>=0 && (int)A[root].m_key==dpth) { used++; root--; }\n-    while (avbl>used) { A[next--].m_key = (mz_uint16)(dpth); avbl--; }\n-    avbl = 2*used; dpth++; used = 0;\n-  }\n-}\n-\n-// Limits canonical Huffman code table's max code size.\n-enum { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };\n-static void tdefl_huffman_enforce_max_code_size(int *pNum_codes, int code_list_len, int max_code_size)\n-{\n-  int i; mz_uint32 total = 0; if (code_list_len <= 1) return;\n-  for (i = max_code_size + 1; i <= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];\n-  for (i = max_code_size; i > 0; i--) total += (((mz_uint32)pNum_codes[i]) << (max_code_size - i));\n-  while (total != (1UL << max_code_size))\n-  {\n-    pNum_codes[max_code_size]--;\n-    for (i = max_code_size - 1; i > 0; i--) if (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; break; }\n-    total--;\n-  }\n-}\n-\n-static void tdefl_optimize_huffman_table(tdefl_compressor *d, int table_num, int table_len, int code_size_limit, int static_table)\n-{\n-  int i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE]; mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; MZ_CLEAR_OBJ(num_codes);\n-  if (static_table)\n-  {\n-    for (i = 0; i < table_len; i++) num_codes[d->m_huff_code_sizes[table_num][i]]++;\n-  }\n-  else\n-  {\n-    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;\n-    int num_used_syms = 0;\n-    const mz_uint16 *pSym_count = &d->m_huff_count[table_num][0];\n-    for (i = 0; i < table_len; i++) if (pSym_count[i]) { syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (mz_uint16)i; }\n-\n-    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1); tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);\n-\n-    for (i = 0; i < num_used_syms; i++) num_codes[pSyms[i].m_key]++;\n-\n-    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);\n-\n-    MZ_CLEAR_OBJ(d->m_huff_code_sizes[table_num]); MZ_CLEAR_OBJ(d->m_huff_codes[table_num]);\n-    for (i = 1, j = num_used_syms; i <= code_size_limit; i++)\n-      for (l = num_codes[i]; l > 0; l--) d->m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);\n-  }\n-\n-  next_code[1] = 0; for (j = 0, i = 2; i <= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) << 1);\n-\n-  for (i = 0; i < table_len; i++)\n-  {\n-    mz_uint rev_code = 0, code, code_size; if ((code_size = d->m_huff_code_sizes[table_num][i]) == 0) continue;\n-    code = next_code[code_size]++; for (l = code_size; l > 0; l--, code >>= 1) rev_code = (rev_code << 1) | (code & 1);\n-    d->m_huff_codes[table_num][i] = (mz_uint16)rev_code;\n-  }\n-}\n-\n-#define TDEFL_PUT_BITS(b, l) do { \\\n-  mz_uint bits = b; mz_uint len = l; MZ_ASSERT(bits <= ((1U << len) - 1U)); \\\n-  d->m_bit_buffer |= (bits << d->m_bits_in); d->m_bits_in += len; \\\n-  while (d->m_bits_in >= 8) { \\\n-    if (d->m_pOutput_buf < d->m_pOutput_buf_end) \\\n-      *d->m_pOutput_buf++ = (mz_uint8)(d->m_bit_buffer); \\\n-      d->m_bit_buffer >>= 8; \\\n-      d->m_bits_in -= 8; \\\n-  } \\\n-} MZ_MACRO_END\n-\n-#define TDEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \\\n-  if (rle_repeat_count < 3) { \\\n-    d->m_huff_count[2][prev_code_size] = (mz_uint16)(d->m_huff_count[2][prev_code_size] + rle_repeat_count); \\\n-    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \\\n-  } else { \\\n-    d->m_huff_count[2][16] = (mz_uint16)(d->m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3); \\\n-} rle_repeat_count = 0; } }\n-\n-#define TDEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \\\n-  if (rle_z_count < 3) { \\\n-    d->m_huff_count[2][0] = (mz_uint16)(d->m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \\\n-  } else if (rle_z_count <= 10) { \\\n-    d->m_huff_count[2][17] = (mz_uint16)(d->m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3); \\\n-  } else { \\\n-    d->m_huff_count[2][18] = (mz_uint16)(d->m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \\\n-} rle_z_count = 0; } }\n-\n-static mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };\n-\n-static void tdefl_start_dynamic_block(tdefl_compressor *d)\n-{\n-  int num_lit_codes, num_dist_codes, num_bit_lengths; mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;\n-  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;\n-\n-  d->m_huff_count[0][256] = 1;\n-\n-  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);\n-  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);\n-\n-  for (num_lit_codes = 286; num_lit_codes > 257; num_lit_codes--) if (d->m_huff_code_sizes[0][num_lit_codes - 1]) break;\n-  for (num_dist_codes = 30; num_dist_codes > 1; num_dist_codes--) if (d->m_huff_code_sizes[1][num_dist_codes - 1]) break;\n-\n-  memcpy(code_sizes_to_pack, &d->m_huff_code_sizes[0][0], num_lit_codes);\n-  memcpy(code_sizes_to_pack + num_lit_codes, &d->m_huff_code_sizes[1][0], num_dist_codes);\n-  total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;\n-\n-  memset(&d->m_huff_count[2][0], 0, sizeof(d->m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);\n-  for (i = 0; i < total_code_sizes_to_pack; i++)\n-  {\n-    mz_uint8 code_size = code_sizes_to_pack[i];\n-    if (!code_size)\n-    {\n-      TDEFL_RLE_PREV_CODE_SIZE();\n-      if (++rle_z_count == 138) { TDEFL_RLE_ZERO_CODE_SIZE(); }\n-    }\n-    else\n-    {\n-      TDEFL_RLE_ZERO_CODE_SIZE();\n-      if (code_size != prev_code_size)\n-      {\n-        TDEFL_RLE_PREV_CODE_SIZE();\n-        d->m_huff_count[2][code_size] = (mz_uint16)(d->m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;\n-      }\n-      else if (++rle_repeat_count == 6)\n-      {\n-        TDEFL_RLE_PREV_CODE_SIZE();\n-      }\n-    }\n-    prev_code_size = code_size;\n-  }\n-  if (rle_repeat_count) { TDEFL_RLE_PREV_CODE_SIZE(); } else { TDEFL_RLE_ZERO_CODE_SIZE(); }\n-\n-  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);\n-\n-  TDEFL_PUT_BITS(2, 2);\n-\n-  TDEFL_PUT_BITS(num_lit_codes - 257, 5);\n-  TDEFL_PUT_BITS(num_dist_codes - 1, 5);\n-\n-  for (num_bit_lengths = 18; num_bit_lengths >= 0; num_bit_lengths--) if (d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) break;\n-  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1)); TDEFL_PUT_BITS(num_bit_lengths - 4, 4);\n-  for (i = 0; (int)i < num_bit_lengths; i++) TDEFL_PUT_BITS(d->m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);\n-\n-  for (packed_code_sizes_index = 0; packed_code_sizes_index < num_packed_code_sizes; )\n-  {\n-    mz_uint code = packed_code_sizes[packed_code_sizes_index++]; MZ_ASSERT(code < TDEFL_MAX_HUFF_SYMBOLS_2);\n-    TDEFL_PUT_BITS(d->m_huff_codes[2][code], d->m_huff_code_sizes[2][code]);\n-    if (code >= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], \"\\02\\03\\07\"[code - 16]);\n-  }\n-}\n-\n-static void tdefl_start_static_block(tdefl_compressor *d)\n-{\n-  mz_uint i;\n-  mz_uint8 *p = &d->m_huff_code_sizes[0][0];\n-\n-  for (i = 0; i <= 143; ++i) *p++ = 8;\n-  for ( ; i <= 255; ++i) *p++ = 9;\n-  for ( ; i <= 279; ++i) *p++ = 7;\n-  for ( ; i <= 287; ++i) *p++ = 8;\n-\n-  memset(d->m_huff_code_sizes[1], 5, 32);\n-\n-  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);\n-  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);\n-\n-  TDEFL_PUT_BITS(1, 2);\n-}\n-\n-static const mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };\n-\n-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS\n-static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)\n-{\n-  mz_uint flags;\n-  mz_uint8 *pLZ_codes;\n-  mz_uint8 *pOutput_buf = d->m_pOutput_buf;\n-  mz_uint8 *pLZ_code_buf_end = d->m_pLZ_code_buf;\n-  mz_uint64 bit_buffer = d->m_bit_buffer;\n-  mz_uint bits_in = d->m_bits_in;\n-\n-#define TDEFL_PUT_BITS_FAST(b, l) { bit_buffer |= (((mz_uint64)(b)) << bits_in); bits_in += (l); }\n-\n-  flags = 1;\n-  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < pLZ_code_buf_end; flags >>= 1)\n-  {\n-    if (flags == 1)\n-      flags = *pLZ_codes++ | 0x100;\n-\n-    if (flags & 1)\n-    {\n-      mz_uint s0, s1, n0, n1, sym, num_extra_bits;\n-      mz_uint match_len = pLZ_codes[0], match_dist = *(const mz_uint16 *)(pLZ_codes + 1); pLZ_codes += 3;\n-\n-      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n-      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n-      TDEFL_PUT_BITS_FAST(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);\n-\n-      // This sequence coaxes MSVC into using cmov's vs. jmp's.\n-      s0 = s_tdefl_small_dist_sym[match_dist & 511];\n-      n0 = s_tdefl_small_dist_extra[match_dist & 511];\n-      s1 = s_tdefl_large_dist_sym[match_dist >> 8];\n-      n1 = s_tdefl_large_dist_extra[match_dist >> 8];\n-      sym = (match_dist < 512) ? s0 : s1;\n-      num_extra_bits = (match_dist < 512) ? n0 : n1;\n-\n-      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n-      TDEFL_PUT_BITS_FAST(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);\n-      TDEFL_PUT_BITS_FAST(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);\n-    }\n-    else\n-    {\n-      mz_uint lit = *pLZ_codes++;\n-      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n-      TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n-\n-      if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))\n-      {\n-        flags >>= 1;\n-        lit = *pLZ_codes++;\n-        MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n-        TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n-\n-        if (((flags & 2) == 0) && (pLZ_codes < pLZ_code_buf_end))\n-        {\n-          flags >>= 1;\n-          lit = *pLZ_codes++;\n-          MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n-          TDEFL_PUT_BITS_FAST(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n-        }\n-      }\n-    }\n-\n-    if (pOutput_buf >= d->m_pOutput_buf_end)\n-      return MZ_FALSE;\n-\n-    *(mz_uint64*)pOutput_buf = bit_buffer;\n-    pOutput_buf += (bits_in >> 3);\n-    bit_buffer >>= (bits_in & ~7);\n-    bits_in &= 7;\n-  }\n-\n-#undef TDEFL_PUT_BITS_FAST\n-\n-  d->m_pOutput_buf = pOutput_buf;\n-  d->m_bits_in = 0;\n-  d->m_bit_buffer = 0;\n-\n-  while (bits_in)\n-  {\n-    mz_uint32 n = MZ_MIN(bits_in, 16);\n-    TDEFL_PUT_BITS((mz_uint)bit_buffer & mz_bitmasks[n], n);\n-    bit_buffer >>= n;\n-    bits_in -= n;\n-  }\n-\n-  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n-\n-  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n-}\n-#else\n-static mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)\n-{\n-  mz_uint flags;\n-  mz_uint8 *pLZ_codes;\n-\n-  flags = 1;\n-  for (pLZ_codes = d->m_lz_code_buf; pLZ_codes < d->m_pLZ_code_buf; flags >>= 1)\n-  {\n-    if (flags == 1)\n-      flags = *pLZ_codes++ | 0x100;\n-    if (flags & 1)\n-    {\n-      mz_uint sym, num_extra_bits;\n-      mz_uint match_len = pLZ_codes[0], match_dist = (pLZ_codes[1] | (pLZ_codes[2] << 8)); pLZ_codes += 3;\n-\n-      MZ_ASSERT(d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n-      TDEFL_PUT_BITS(d->m_huff_codes[0][s_tdefl_len_sym[match_len]], d->m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);\n-      TDEFL_PUT_BITS(match_len & mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);\n-\n-      if (match_dist < 512)\n-      {\n-        sym = s_tdefl_small_dist_sym[match_dist]; num_extra_bits = s_tdefl_small_dist_extra[match_dist];\n-      }\n-      else\n-      {\n-        sym = s_tdefl_large_dist_sym[match_dist >> 8]; num_extra_bits = s_tdefl_large_dist_extra[match_dist >> 8];\n-      }\n-      MZ_ASSERT(d->m_huff_code_sizes[1][sym]);\n-      TDEFL_PUT_BITS(d->m_huff_codes[1][sym], d->m_huff_code_sizes[1][sym]);\n-      TDEFL_PUT_BITS(match_dist & mz_bitmasks[num_extra_bits], num_extra_bits);\n-    }\n-    else\n-    {\n-      mz_uint lit = *pLZ_codes++;\n-      MZ_ASSERT(d->m_huff_code_sizes[0][lit]);\n-      TDEFL_PUT_BITS(d->m_huff_codes[0][lit], d->m_huff_code_sizes[0][lit]);\n-    }\n-  }\n-\n-  TDEFL_PUT_BITS(d->m_huff_codes[0][256], d->m_huff_code_sizes[0][256]);\n-\n-  return (d->m_pOutput_buf < d->m_pOutput_buf_end);\n-}\n-#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN && MINIZ_HAS_64BIT_REGISTERS\n-\n-static mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)\n-{\n-  if (static_block)\n-    tdefl_start_static_block(d);\n-  else\n-    tdefl_start_dynamic_block(d);\n-  return tdefl_compress_lz_codes(d);\n-}\n-\n-static int tdefl_flush_block(tdefl_compressor *d, int flush)\n-{\n-  mz_uint saved_bit_buf, saved_bits_in;\n-  mz_uint8 *pSaved_output_buf;\n-  mz_bool comp_block_succeeded = MZ_FALSE;\n-  int n, use_raw_block = ((d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) && (d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size;\n-  mz_uint8 *pOutput_buf_start = ((d->m_pPut_buf_func == NULL) && ((*d->m_pOut_buf_size - d->m_out_buf_ofs) >= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs) : d->m_output_buf;\n-\n-  d->m_pOutput_buf = pOutput_buf_start;\n-  d->m_pOutput_buf_end = d->m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;\n-\n-  MZ_ASSERT(!d->m_output_flush_remaining);\n-  d->m_output_flush_ofs = 0;\n-  d->m_output_flush_remaining = 0;\n-\n-  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> d->m_num_flags_left);\n-  d->m_pLZ_code_buf -= (d->m_num_flags_left == 8);\n-\n-  if ((d->m_flags & TDEFL_WRITE_ZLIB_HEADER) && (!d->m_block_index))\n-  {\n-    TDEFL_PUT_BITS(0x78, 8); TDEFL_PUT_BITS(0x01, 8);\n-  }\n-\n-  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);\n-\n-  pSaved_output_buf = d->m_pOutput_buf; saved_bit_buf = d->m_bit_buffer; saved_bits_in = d->m_bits_in;\n-\n-  if (!use_raw_block)\n-    comp_block_succeeded = tdefl_compress_block(d, (d->m_flags & TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d->m_total_lz_bytes < 48));\n-\n-  // If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.\n-  if ( ((use_raw_block) || ((d->m_total_lz_bytes) && ((d->m_pOutput_buf - pSaved_output_buf + 1U) >= d->m_total_lz_bytes))) &&\n-       ((d->m_lookahead_pos - d->m_lz_code_buf_dict_pos) <= d->m_dict_size) )\n-  {\n-    mz_uint i; d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n-    TDEFL_PUT_BITS(0, 2);\n-    if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }\n-    for (i = 2; i; --i, d->m_total_lz_bytes ^= 0xFFFF)\n-    {\n-      TDEFL_PUT_BITS(d->m_total_lz_bytes & 0xFFFF, 16);\n-    }\n-    for (i = 0; i < d->m_total_lz_bytes; ++i)\n-    {\n-      TDEFL_PUT_BITS(d->m_dict[(d->m_lz_code_buf_dict_pos + i) & TDEFL_LZ_DICT_SIZE_MASK], 8);\n-    }\n-  }\n-  // Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.\n-  else if (!comp_block_succeeded)\n-  {\n-    d->m_pOutput_buf = pSaved_output_buf; d->m_bit_buffer = saved_bit_buf, d->m_bits_in = saved_bits_in;\n-    tdefl_compress_block(d, MZ_TRUE);\n-  }\n-\n-  if (flush)\n-  {\n-    if (flush == TDEFL_FINISH)\n-    {\n-      if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); }\n-      if (d->m_flags & TDEFL_WRITE_ZLIB_HEADER) { mz_uint i, a = d->m_adler32; for (i = 0; i < 4; i++) { TDEFL_PUT_BITS((a >> 24) & 0xFF, 8); a <<= 8; } }\n-    }\n-    else\n-    {\n-      mz_uint i, z = 0; TDEFL_PUT_BITS(0, 3); if (d->m_bits_in) { TDEFL_PUT_BITS(0, 8 - d->m_bits_in); } for (i = 2; i; --i, z ^= 0xFFFF) { TDEFL_PUT_BITS(z & 0xFFFF, 16); }\n-    }\n-  }\n-\n-  MZ_ASSERT(d->m_pOutput_buf < d->m_pOutput_buf_end);\n-\n-  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n-  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n-\n-  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8; d->m_lz_code_buf_dict_pos += d->m_total_lz_bytes; d->m_total_lz_bytes = 0; d->m_block_index++;\n-\n-  if ((n = (int)(d->m_pOutput_buf - pOutput_buf_start)) != 0)\n-  {\n-    if (d->m_pPut_buf_func)\n-    {\n-      *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n-      if (!(*d->m_pPut_buf_func)(d->m_output_buf, n, d->m_pPut_buf_user))\n-        return (d->m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);\n-    }\n-    else if (pOutput_buf_start == d->m_output_buf)\n-    {\n-      int bytes_to_copy = (int)MZ_MIN((size_t)n, (size_t)(*d->m_pOut_buf_size - d->m_out_buf_ofs));\n-      memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf, bytes_to_copy);\n-      d->m_out_buf_ofs += bytes_to_copy;\n-      if ((n -= bytes_to_copy) != 0)\n-      {\n-        d->m_output_flush_ofs = bytes_to_copy;\n-        d->m_output_flush_remaining = n;\n-      }\n-    }\n-    else\n-    {\n-      d->m_out_buf_ofs += n;\n-    }\n-  }\n-\n-  return d->m_output_flush_remaining;\n-}\n-\n-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n-#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)\n-static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)\n-{\n-  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;\n-  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n-  const mz_uint16 *s = (const mz_uint16*)(d->m_dict + pos), *p, *q;\n-  mz_uint16 c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]), s01 = TDEFL_READ_UNALIGNED_WORD(s);\n-  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;\n-  for ( ; ; )\n-  {\n-    for ( ; ; )\n-    {\n-      if (--num_probes_left == 0) return;\n-      #define TDEFL_PROBE \\\n-        next_probe_pos = d->m_next[probe_pos]; \\\n-        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \\\n-        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \\\n-        if (TDEFL_READ_UNALIGNED_WORD(&d->m_dict[probe_pos + match_len - 1]) == c01) break;\n-      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;\n-    }\n-    if (!dist) break; q = (const mz_uint16*)(d->m_dict + probe_pos); if (TDEFL_READ_UNALIGNED_WORD(q) != s01) continue; p = s; probe_len = 32;\n-    do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n-                   (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );\n-    if (!probe_len)\n-    {\n-      *pMatch_dist = dist; *pMatch_len = MZ_MIN(max_match_len, TDEFL_MAX_MATCH_LEN); break;\n-    }\n-    else if ((probe_len = ((mz_uint)(p - s) * 2) + (mz_uint)(*(const mz_uint8*)p == *(const mz_uint8*)q)) > match_len)\n-    {\n-      *pMatch_dist = dist; if ((*pMatch_len = match_len = MZ_MIN(max_match_len, probe_len)) == max_match_len) break;\n-      c01 = TDEFL_READ_UNALIGNED_WORD(&d->m_dict[pos + match_len - 1]);\n-    }\n-  }\n-}\n-#else\n-static MZ_FORCEINLINE void tdefl_find_match(tdefl_compressor *d, mz_uint lookahead_pos, mz_uint max_dist, mz_uint max_match_len, mz_uint *pMatch_dist, mz_uint *pMatch_len)\n-{\n-  mz_uint dist, pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK, match_len = *pMatch_len, probe_pos = pos, next_probe_pos, probe_len;\n-  mz_uint num_probes_left = d->m_max_probes[match_len >= 32];\n-  const mz_uint8 *s = d->m_dict + pos, *p, *q;\n-  mz_uint8 c0 = d->m_dict[pos + match_len], c1 = d->m_dict[pos + match_len - 1];\n-  MZ_ASSERT(max_match_len <= TDEFL_MAX_MATCH_LEN); if (max_match_len <= match_len) return;\n-  for ( ; ; )\n-  {\n-    for ( ; ; )\n-    {\n-      if (--num_probes_left == 0) return;\n-      #define TDEFL_PROBE \\\n-        next_probe_pos = d->m_next[probe_pos]; \\\n-        if ((!next_probe_pos) || ((dist = (mz_uint16)(lookahead_pos - next_probe_pos)) > max_dist)) return; \\\n-        probe_pos = next_probe_pos & TDEFL_LZ_DICT_SIZE_MASK; \\\n-        if ((d->m_dict[probe_pos + match_len] == c0) && (d->m_dict[probe_pos + match_len - 1] == c1)) break;\n-      TDEFL_PROBE; TDEFL_PROBE; TDEFL_PROBE;\n-    }\n-    if (!dist) break;\n-    p = s; q = d->m_dict + probe_pos;\n-    for (probe_len = 0; probe_len < max_match_len; probe_len++)\n-        if (*p++ != *q++) break;\n-    if (probe_len > match_len)\n-    {\n-      *pMatch_dist = dist; if ((*pMatch_len = match_len = probe_len) == max_match_len) return;\n-      c0 = d->m_dict[pos + match_len]; c1 = d->m_dict[pos + match_len - 1];\n-    }\n-  }\n-}\n-#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES\n-\n-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n-static mz_bool tdefl_compress_fast(tdefl_compressor *d)\n-{\n-  // Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.\n-  mz_uint lookahead_pos = d->m_lookahead_pos, lookahead_size = d->m_lookahead_size, dict_size = d->m_dict_size, total_lz_bytes = d->m_total_lz_bytes, num_flags_left = d->m_num_flags_left;\n-  mz_uint8 *pLZ_code_buf = d->m_pLZ_code_buf, *pLZ_flags = d->m_pLZ_flags;\n-  mz_uint cur_pos = lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n-\n-  while ((d->m_src_buf_left) || ((d->m_flush) && (lookahead_size)))\n-  {\n-    const mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;\n-    mz_uint dst_pos = (lookahead_pos + lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;\n-    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d->m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);\n-    d->m_src_buf_left -= num_bytes_to_process;\n-    lookahead_size += num_bytes_to_process;\n-\n-    while (num_bytes_to_process)\n-    {\n-      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);\n-      memcpy(d->m_dict + dst_pos, d->m_pSrc, n);\n-      if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n-        memcpy(d->m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d->m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));\n-      d->m_pSrc += n;\n-      dst_pos = (dst_pos + n) & TDEFL_LZ_DICT_SIZE_MASK;\n-      num_bytes_to_process -= n;\n-    }\n-\n-    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);\n-    if ((!d->m_flush) && (lookahead_size < TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) break;\n-\n-    while (lookahead_size >= 4)\n-    {\n-      mz_uint cur_match_dist, cur_match_len = 1;\n-      mz_uint8 *pCur_dict = d->m_dict + cur_pos;\n-      mz_uint first_trigram = (*(const mz_uint32 *)pCur_dict) & 0xFFFFFF;\n-      mz_uint hash = (first_trigram ^ (first_trigram >> (24 - (TDEFL_LZ_HASH_BITS - 8)))) & TDEFL_LEVEL1_HASH_SIZE_MASK;\n-      mz_uint probe_pos = d->m_hash[hash];\n-      d->m_hash[hash] = (mz_uint16)lookahead_pos;\n-\n-      if (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) <= dict_size) && ((*(const mz_uint32 *)(d->m_dict + (probe_pos &= TDEFL_LZ_DICT_SIZE_MASK)) & 0xFFFFFF) == first_trigram))\n-      {\n-        const mz_uint16 *p = (const mz_uint16 *)pCur_dict;\n-        const mz_uint16 *q = (const mz_uint16 *)(d->m_dict + probe_pos);\n-        mz_uint32 probe_len = 32;\n-        do { } while ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &&\n-          (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) && (--probe_len > 0) );\n-        cur_match_len = ((mz_uint)(p - (const mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(const mz_uint8 *)p == *(const mz_uint8 *)q);\n-        if (!probe_len)\n-          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;\n-\n-        if ((cur_match_len < TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)))\n-        {\n-          cur_match_len = 1;\n-          *pLZ_code_buf++ = (mz_uint8)first_trigram;\n-          *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n-          d->m_huff_count[0][(mz_uint8)first_trigram]++;\n-        }\n-        else\n-        {\n-          mz_uint32 s0, s1;\n-          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);\n-\n-          MZ_ASSERT((cur_match_len >= TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 1) && (cur_match_dist <= TDEFL_LZ_DICT_SIZE));\n-\n-          cur_match_dist--;\n-\n-          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);\n-          *(mz_uint16 *)(&pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;\n-          pLZ_code_buf += 3;\n-          *pLZ_flags = (mz_uint8)((*pLZ_flags >> 1) | 0x80);\n-\n-          s0 = s_tdefl_small_dist_sym[cur_match_dist & 511];\n-          s1 = s_tdefl_large_dist_sym[cur_match_dist >> 8];\n-          d->m_huff_count[1][(cur_match_dist < 512) ? s0 : s1]++;\n-\n-          d->m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;\n-        }\n-      }\n-      else\n-      {\n-        *pLZ_code_buf++ = (mz_uint8)first_trigram;\n-        *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n-        d->m_huff_count[0][(mz_uint8)first_trigram]++;\n-      }\n-\n-      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }\n-\n-      total_lz_bytes += cur_match_len;\n-      lookahead_pos += cur_match_len;\n-      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);\n-      cur_pos = (cur_pos + cur_match_len) & TDEFL_LZ_DICT_SIZE_MASK;\n-      MZ_ASSERT(lookahead_size >= cur_match_len);\n-      lookahead_size -= cur_match_len;\n-\n-      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])\n-      {\n-        int n;\n-        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;\n-        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;\n-        if ((n = tdefl_flush_block(d, 0)) != 0)\n-          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n-        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;\n-      }\n-    }\n-\n-    while (lookahead_size)\n-    {\n-      mz_uint8 lit = d->m_dict[cur_pos];\n-\n-      total_lz_bytes++;\n-      *pLZ_code_buf++ = lit;\n-      *pLZ_flags = (mz_uint8)(*pLZ_flags >> 1);\n-      if (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }\n-\n-      d->m_huff_count[0][lit]++;\n-\n-      lookahead_pos++;\n-      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);\n-      cur_pos = (cur_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK;\n-      lookahead_size--;\n-\n-      if (pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])\n-      {\n-        int n;\n-        d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;\n-        d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;\n-        if ((n = tdefl_flush_block(d, 0)) != 0)\n-          return (n < 0) ? MZ_FALSE : MZ_TRUE;\n-        total_lz_bytes = d->m_total_lz_bytes; pLZ_code_buf = d->m_pLZ_code_buf; pLZ_flags = d->m_pLZ_flags; num_flags_left = d->m_num_flags_left;\n-      }\n-    }\n-  }\n-\n-  d->m_lookahead_pos = lookahead_pos; d->m_lookahead_size = lookahead_size; d->m_dict_size = dict_size;\n-  d->m_total_lz_bytes = total_lz_bytes; d->m_pLZ_code_buf = pLZ_code_buf; d->m_pLZ_flags = pLZ_flags; d->m_num_flags_left = num_flags_left;\n-  return MZ_TRUE;\n-}\n-#endif // MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n-\n-static MZ_FORCEINLINE void tdefl_record_literal(tdefl_compressor *d, mz_uint8 lit)\n-{\n-  d->m_total_lz_bytes++;\n-  *d->m_pLZ_code_buf++ = lit;\n-  *d->m_pLZ_flags = (mz_uint8)(*d->m_pLZ_flags >> 1); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }\n-  d->m_huff_count[0][lit]++;\n-}\n-\n-static MZ_FORCEINLINE void tdefl_record_match(tdefl_compressor *d, mz_uint match_len, mz_uint match_dist)\n-{\n-  mz_uint32 s0, s1;\n-\n-  MZ_ASSERT((match_len >= TDEFL_MIN_MATCH_LEN) && (match_dist >= 1) && (match_dist <= TDEFL_LZ_DICT_SIZE));\n-\n-  d->m_total_lz_bytes += match_len;\n-\n-  d->m_pLZ_code_buf[0] = (mz_uint8)(match_len - TDEFL_MIN_MATCH_LEN);\n-\n-  match_dist -= 1;\n-  d->m_pLZ_code_buf[1] = (mz_uint8)(match_dist & 0xFF);\n-  d->m_pLZ_code_buf[2] = (mz_uint8)(match_dist >> 8); d->m_pLZ_code_buf += 3;\n-\n-  *d->m_pLZ_flags = (mz_uint8)((*d->m_pLZ_flags >> 1) | 0x80); if (--d->m_num_flags_left == 0) { d->m_num_flags_left = 8; d->m_pLZ_flags = d->m_pLZ_code_buf++; }\n-\n-  s0 = s_tdefl_small_dist_sym[match_dist & 511]; s1 = s_tdefl_large_dist_sym[(match_dist >> 8) & 127];\n-  d->m_huff_count[1][(match_dist < 512) ? s0 : s1]++;\n-\n-  if (match_len >= TDEFL_MIN_MATCH_LEN) d->m_huff_count[0][s_tdefl_len_sym[match_len - TDEFL_MIN_MATCH_LEN]]++;\n-}\n-\n-static mz_bool tdefl_compress_normal(tdefl_compressor *d)\n-{\n-  const mz_uint8 *pSrc = d->m_pSrc; size_t src_buf_left = d->m_src_buf_left;\n-  tdefl_flush flush = d->m_flush;\n-\n-  while ((src_buf_left) || ((flush) && (d->m_lookahead_size)))\n-  {\n-    mz_uint len_to_move, cur_match_dist, cur_match_len, cur_pos;\n-    // Update dictionary and hash chains. Keeps the lookahead size equal to TDEFL_MAX_MATCH_LEN.\n-    if ((d->m_lookahead_size + d->m_dict_size) >= (TDEFL_MIN_MATCH_LEN - 1))\n-    {\n-      mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK, ins_pos = d->m_lookahead_pos + d->m_lookahead_size - 2;\n-      mz_uint hash = (d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK];\n-      mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(src_buf_left, TDEFL_MAX_MATCH_LEN - d->m_lookahead_size);\n-      const mz_uint8 *pSrc_end = pSrc + num_bytes_to_process;\n-      src_buf_left -= num_bytes_to_process;\n-      d->m_lookahead_size += num_bytes_to_process;\n-      while (pSrc != pSrc_end)\n-      {\n-        mz_uint8 c = *pSrc++; d->m_dict[dst_pos] = c; if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1)) d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n-        hash = ((hash << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);\n-        d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);\n-        dst_pos = (dst_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK; ins_pos++;\n-      }\n-    }\n-    else\n-    {\n-      while ((src_buf_left) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))\n-      {\n-        mz_uint8 c = *pSrc++;\n-        mz_uint dst_pos = (d->m_lookahead_pos + d->m_lookahead_size) & TDEFL_LZ_DICT_SIZE_MASK;\n-        src_buf_left--;\n-        d->m_dict[dst_pos] = c;\n-        if (dst_pos < (TDEFL_MAX_MATCH_LEN - 1))\n-          d->m_dict[TDEFL_LZ_DICT_SIZE + dst_pos] = c;\n-        if ((++d->m_lookahead_size + d->m_dict_size) >= TDEFL_MIN_MATCH_LEN)\n-        {\n-          mz_uint ins_pos = d->m_lookahead_pos + (d->m_lookahead_size - 1) - 2;\n-          mz_uint hash = ((d->m_dict[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] << (TDEFL_LZ_HASH_SHIFT * 2)) ^ (d->m_dict[(ins_pos + 1) & TDEFL_LZ_DICT_SIZE_MASK] << TDEFL_LZ_HASH_SHIFT) ^ c) & (TDEFL_LZ_HASH_SIZE - 1);\n-          d->m_next[ins_pos & TDEFL_LZ_DICT_SIZE_MASK] = d->m_hash[hash]; d->m_hash[hash] = (mz_uint16)(ins_pos);\n-        }\n-      }\n-    }\n-    d->m_dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - d->m_lookahead_size, d->m_dict_size);\n-    if ((!flush) && (d->m_lookahead_size < TDEFL_MAX_MATCH_LEN))\n-      break;\n-\n-    // Simple lazy/greedy parsing state machine.\n-    len_to_move = 1; cur_match_dist = 0; cur_match_len = d->m_saved_match_len ? d->m_saved_match_len : (TDEFL_MIN_MATCH_LEN - 1); cur_pos = d->m_lookahead_pos & TDEFL_LZ_DICT_SIZE_MASK;\n-    if (d->m_flags & (TDEFL_RLE_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS))\n-    {\n-      if ((d->m_dict_size) && (!(d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS)))\n-      {\n-        mz_uint8 c = d->m_dict[(cur_pos - 1) & TDEFL_LZ_DICT_SIZE_MASK];\n-        cur_match_len = 0; while (cur_match_len < d->m_lookahead_size) { if (d->m_dict[cur_pos + cur_match_len] != c) break; cur_match_len++; }\n-        if (cur_match_len < TDEFL_MIN_MATCH_LEN) cur_match_len = 0; else cur_match_dist = 1;\n-      }\n-    }\n-    else\n-    {\n-      tdefl_find_match(d, d->m_lookahead_pos, d->m_dict_size, d->m_lookahead_size, &cur_match_dist, &cur_match_len);\n-    }\n-    if (((cur_match_len == TDEFL_MIN_MATCH_LEN) && (cur_match_dist >= 8U*1024U)) || (cur_pos == cur_match_dist) || ((d->m_flags & TDEFL_FILTER_MATCHES) && (cur_match_len <= 5)))\n-    {\n-      cur_match_dist = cur_match_len = 0;\n-    }\n-    if (d->m_saved_match_len)\n-    {\n-      if (cur_match_len > d->m_saved_match_len)\n-      {\n-        tdefl_record_literal(d, (mz_uint8)d->m_saved_lit);\n-        if (cur_match_len >= 128)\n-        {\n-          tdefl_record_match(d, cur_match_len, cur_match_dist);\n-          d->m_saved_match_len = 0; len_to_move = cur_match_len;\n-        }\n-        else\n-        {\n-          d->m_saved_lit = d->m_dict[cur_pos]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;\n-        }\n-      }\n-      else\n-      {\n-        tdefl_record_match(d, d->m_saved_match_len, d->m_saved_match_dist);\n-        len_to_move = d->m_saved_match_len - 1; d->m_saved_match_len = 0;\n-      }\n-    }\n-    else if (!cur_match_dist)\n-      tdefl_record_literal(d, d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]);\n-    else if ((d->m_greedy_parsing) || (d->m_flags & TDEFL_RLE_MATCHES) || (cur_match_len >= 128))\n-    {\n-      tdefl_record_match(d, cur_match_len, cur_match_dist);\n-      len_to_move = cur_match_len;\n-    }\n-    else\n-    {\n-      d->m_saved_lit = d->m_dict[MZ_MIN(cur_pos, sizeof(d->m_dict) - 1)]; d->m_saved_match_dist = cur_match_dist; d->m_saved_match_len = cur_match_len;\n-    }\n-    // Move the lookahead forward by len_to_move bytes.\n-    d->m_lookahead_pos += len_to_move;\n-    MZ_ASSERT(d->m_lookahead_size >= len_to_move);\n-    d->m_lookahead_size -= len_to_move;\n-    d->m_dict_size = MZ_MIN(d->m_dict_size + len_to_move, TDEFL_LZ_DICT_SIZE);\n-    // Check if it's time to flush the current LZ codes to the internal output buffer.\n-    if ( (d->m_pLZ_code_buf > &d->m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8]) ||\n-         ( (d->m_total_lz_bytes > 31*1024) && (((((mz_uint)(d->m_pLZ_code_buf - d->m_lz_code_buf) * 115) >> 7) >= d->m_total_lz_bytes) || (d->m_flags & TDEFL_FORCE_ALL_RAW_BLOCKS))) )\n-    {\n-      int n;\n-      d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;\n-      if ((n = tdefl_flush_block(d, 0)) != 0)\n-        return (n < 0) ? MZ_FALSE : MZ_TRUE;\n-    }\n-  }\n-\n-  d->m_pSrc = pSrc; d->m_src_buf_left = src_buf_left;\n-  return MZ_TRUE;\n-}\n-\n-static tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)\n-{\n-  if (d->m_pIn_buf_size)\n-  {\n-    *d->m_pIn_buf_size = d->m_pSrc - (const mz_uint8 *)d->m_pIn_buf;\n-  }\n-\n-  if (d->m_pOut_buf_size)\n-  {\n-    size_t n = MZ_MIN(*d->m_pOut_buf_size - d->m_out_buf_ofs, d->m_output_flush_remaining);\n-    memcpy((mz_uint8 *)d->m_pOut_buf + d->m_out_buf_ofs, d->m_output_buf + d->m_output_flush_ofs, n);\n-    d->m_output_flush_ofs += (mz_uint)n;\n-    d->m_output_flush_remaining -= (mz_uint)n;\n-    d->m_out_buf_ofs += n;\n-\n-    *d->m_pOut_buf_size = d->m_out_buf_ofs;\n-  }\n-\n-  return (d->m_finished && !d->m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;\n-}\n-\n-tdefl_status tdefl_compress(tdefl_compressor *d, const void *pIn_buf, size_t *pIn_buf_size, void *pOut_buf, size_t *pOut_buf_size, tdefl_flush flush)\n-{\n-  if (!d)\n-  {\n-    if (pIn_buf_size) *pIn_buf_size = 0;\n-    if (pOut_buf_size) *pOut_buf_size = 0;\n-    return TDEFL_STATUS_BAD_PARAM;\n-  }\n-\n-  d->m_pIn_buf = pIn_buf; d->m_pIn_buf_size = pIn_buf_size;\n-  d->m_pOut_buf = pOut_buf; d->m_pOut_buf_size = pOut_buf_size;\n-  d->m_pSrc = (const mz_uint8 *)(pIn_buf); d->m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;\n-  d->m_out_buf_ofs = 0;\n-  d->m_flush = flush;\n-\n-  if ( ((d->m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d->m_prev_return_status != TDEFL_STATUS_OKAY) ||\n-        (d->m_wants_to_finish && (flush != TDEFL_FINISH)) || (pIn_buf_size && *pIn_buf_size && !pIn_buf) || (pOut_buf_size && *pOut_buf_size && !pOut_buf) )\n-  {\n-    if (pIn_buf_size) *pIn_buf_size = 0;\n-    if (pOut_buf_size) *pOut_buf_size = 0;\n-    return (d->m_prev_return_status = TDEFL_STATUS_BAD_PARAM);\n-  }\n-  d->m_wants_to_finish |= (flush == TDEFL_FINISH);\n-\n-  if ((d->m_output_flush_remaining) || (d->m_finished))\n-    return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n-\n-#if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n-  if (((d->m_flags & TDEFL_MAX_PROBES_MASK) == 1) &&\n-      ((d->m_flags & TDEFL_GREEDY_PARSING_FLAG) != 0) &&\n-      ((d->m_flags & (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))\n-  {\n-    if (!tdefl_compress_fast(d))\n-      return d->m_prev_return_status;\n-  }\n-  else\n-#endif // #if MINIZ_USE_UNALIGNED_LOADS_AND_STORES && MINIZ_LITTLE_ENDIAN\n-  {\n-    if (!tdefl_compress_normal(d))\n-      return d->m_prev_return_status;\n-  }\n-\n-  if ((d->m_flags & (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) && (pIn_buf))\n-    d->m_adler32 = (mz_uint32)mz_adler32(d->m_adler32, (const mz_uint8 *)pIn_buf, d->m_pSrc - (const mz_uint8 *)pIn_buf);\n-\n-  if ((flush) && (!d->m_lookahead_size) && (!d->m_src_buf_left) && (!d->m_output_flush_remaining))\n-  {\n-    if (tdefl_flush_block(d, flush) < 0)\n-      return d->m_prev_return_status;\n-    d->m_finished = (flush == TDEFL_FINISH);\n-    if (flush == TDEFL_FULL_FLUSH) { MZ_CLEAR_OBJ(d->m_hash); MZ_CLEAR_OBJ(d->m_next); d->m_dict_size = 0; }\n-  }\n-\n-  return (d->m_prev_return_status = tdefl_flush_output_buffer(d));\n-}\n-\n-tdefl_status tdefl_compress_buffer(tdefl_compressor *d, const void *pIn_buf, size_t in_buf_size, tdefl_flush flush)\n-{\n-  MZ_ASSERT(d->m_pPut_buf_func); return tdefl_compress(d, pIn_buf, &in_buf_size, NULL, NULL, flush);\n-}\n-\n-tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)\n-{\n-  d->m_pPut_buf_func = pPut_buf_func; d->m_pPut_buf_user = pPut_buf_user;\n-  d->m_flags = (mz_uint)(flags); d->m_max_probes[0] = 1 + ((flags & 0xFFF) + 2) / 3; d->m_greedy_parsing = (flags & TDEFL_GREEDY_PARSING_FLAG) != 0;\n-  d->m_max_probes[1] = 1 + (((flags & 0xFFF) >> 2) + 2) / 3;\n-  if (!(flags & TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d->m_hash);\n-  d->m_lookahead_pos = d->m_lookahead_size = d->m_dict_size = d->m_total_lz_bytes = d->m_lz_code_buf_dict_pos = d->m_bits_in = 0;\n-  d->m_output_flush_ofs = d->m_output_flush_remaining = d->m_finished = d->m_block_index = d->m_bit_buffer = d->m_wants_to_finish = 0;\n-  d->m_pLZ_code_buf = d->m_lz_code_buf + 1; d->m_pLZ_flags = d->m_lz_code_buf; d->m_num_flags_left = 8;\n-  d->m_pOutput_buf = d->m_output_buf; d->m_pOutput_buf_end = d->m_output_buf; d->m_prev_return_status = TDEFL_STATUS_OKAY;\n-  d->m_saved_match_dist = d->m_saved_match_len = d->m_saved_lit = 0; d->m_adler32 = 1;\n-  d->m_pIn_buf = NULL; d->m_pOut_buf = NULL;\n-  d->m_pIn_buf_size = NULL; d->m_pOut_buf_size = NULL;\n-  d->m_flush = TDEFL_NO_FLUSH; d->m_pSrc = NULL; d->m_src_buf_left = 0; d->m_out_buf_ofs = 0;\n-  memset(&d->m_huff_count[0][0], 0, sizeof(d->m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);\n-  memset(&d->m_huff_count[1][0], 0, sizeof(d->m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);\n-  return TDEFL_STATUS_OKAY;\n-}\n-\n-tdefl_status tdefl_get_prev_return_status(tdefl_compressor *d)\n-{\n-  return d->m_prev_return_status;\n-}\n-\n-mz_uint32 tdefl_get_adler32(tdefl_compressor *d)\n-{\n-  return d->m_adler32;\n-}\n-\n-mz_bool tdefl_compress_mem_to_output(const void *pBuf, size_t buf_len, tdefl_put_buf_func_ptr pPut_buf_func, void *pPut_buf_user, int flags)\n-{\n-  tdefl_compressor *pComp; mz_bool succeeded; if (((buf_len) && (!pBuf)) || (!pPut_buf_func)) return MZ_FALSE;\n-  pComp = (tdefl_compressor*)MZ_MALLOC(sizeof(tdefl_compressor)); if (!pComp) return MZ_FALSE;\n-  succeeded = (tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags) == TDEFL_STATUS_OKAY);\n-  succeeded = succeeded && (tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH) == TDEFL_STATUS_DONE);\n-  MZ_FREE(pComp); return succeeded;\n-}\n-\n-typedef struct\n-{\n-  size_t m_size, m_capacity;\n-  mz_uint8 *m_pBuf;\n-  mz_bool m_expandable;\n-} tdefl_output_buffer;\n-\n-static mz_bool tdefl_output_buffer_putter(const void *pBuf, int len, void *pUser)\n-{\n-  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;\n-  size_t new_size = p->m_size + len;\n-  if (new_size > p->m_capacity)\n-  {\n-    size_t new_capacity = p->m_capacity; mz_uint8 *pNew_buf; if (!p->m_expandable) return MZ_FALSE;\n-    do { new_capacity = MZ_MAX(128U, new_capacity << 1U); } while (new_size > new_capacity);\n-    pNew_buf = (mz_uint8*)MZ_REALLOC(p->m_pBuf, new_capacity); if (!pNew_buf) return MZ_FALSE;\n-    p->m_pBuf = pNew_buf; p->m_capacity = new_capacity;\n-  }\n-  memcpy((mz_uint8*)p->m_pBuf + p->m_size, pBuf, len); p->m_size = new_size;\n-  return MZ_TRUE;\n-}\n-\n-void *tdefl_compress_mem_to_heap(const void *pSrc_buf, size_t src_buf_len, size_t *pOut_len, int flags)\n-{\n-  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);\n-  if (!pOut_len) return MZ_FALSE; else *pOut_len = 0;\n-  out_buf.m_expandable = MZ_TRUE;\n-  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return NULL;\n-  *pOut_len = out_buf.m_size; return out_buf.m_pBuf;\n-}\n-\n-size_t tdefl_compress_mem_to_mem(void *pOut_buf, size_t out_buf_len, const void *pSrc_buf, size_t src_buf_len, int flags)\n-{\n-  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);\n-  if (!pOut_buf) return 0;\n-  out_buf.m_pBuf = (mz_uint8*)pOut_buf; out_buf.m_capacity = out_buf_len;\n-  if (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &out_buf, flags)) return 0;\n-  return out_buf.m_size;\n-}\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif // MINIZ_HEADER_FILE_ONLY\n-\n-/*\n-  This is free and unencumbered software released into the public domain.\n-\n-  Anyone is free to copy, modify, publish, use, compile, sell, or\n-  distribute this software, either in source code form or as a compiled\n-  binary, for any purpose, commercial or non-commercial, and by any\n-  means.\n-\n-  In jurisdictions that recognize copyright laws, the author or authors\n-  of this software dedicate any and all copyright interest in the\n-  software to the public domain. We make this dedication for the benefit\n-  of the public at large and to the detriment of our heirs and\n-  successors. We intend this dedication to be an overt act of\n-  relinquishment in perpetuity of all present and future rights to this\n-  software under copyright law.\n-\n-  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n-  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n-  OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n-  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-  OTHER DEALINGS IN THE SOFTWARE.\n-\n-  For more information, please refer to <http://unlicense.org/>\n-*/"}, {"sha": "cb1c88689a89d0e37c53fe9509cfb35ed37e7744", "filename": "src/test/run-make/no-duplicate-libs/bar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, libc, compiler_builtins_lib)]\n+#![feature(lang_items, alloc_system, compiler_builtins_lib)]\n #![crate_type = \"dylib\"]\n #![no_std]\n \n-extern crate libc;\n+extern crate alloc_system;\n extern crate compiler_builtins;\n \n #[no_mangle]"}, {"sha": "214fb156c2d6309f50bc848acf9bd76960d71b6d", "filename": "src/test/run-make/no-duplicate-libs/foo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, libc, compiler_builtins_lib)]\n+#![feature(lang_items, alloc_system, compiler_builtins_lib)]\n #![no_std]\n #![crate_type = \"dylib\"]\n \n-extern crate libc;\n+extern crate alloc_system;\n extern crate compiler_builtins;\n \n #[no_mangle]"}, {"sha": "8a1b57939894685261d0149ed4571b92a912a40c", "filename": "src/test/run-make/save-analysis-fail/foo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis-fail%2Ffoo.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -17,7 +17,6 @@ extern crate graphviz;\n \n extern crate krate2;\n extern crate krate2 as krate3;\n-extern crate flate as myflate;\n \n use graphviz::RenderOption;\n use std::collections::{HashMap,HashSet};\n@@ -51,7 +50,6 @@ fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n \n     krate2::hello();\n     krate3::hello();\n-    myflate::deflate_bytes(&[]);\n \n     let x = (3isize, 4usize);\n     let y = x.1;"}, {"sha": "5cb363ac34435719f0c493518753cbbad34195e3", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -18,7 +18,6 @@ extern crate graphviz;\n \n extern crate krate2;\n extern crate krate2 as krate3;\n-extern crate flate as myflate;\n \n use graphviz::RenderOption;\n use std::collections::{HashMap,HashSet};\n@@ -52,7 +51,6 @@ fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n \n     krate2::hello();\n     krate3::hello();\n-    myflate::deflate_bytes(&[]);\n \n     let x = (3isize, 4usize);\n     let y = x.1;"}, {"sha": "a54233535a466ff077ce06850a6b0a88640e5d23", "filename": "src/test/run-pass/auxiliary/allocator-dummy.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -10,41 +10,48 @@\n \n // no-prefer-dynamic\n \n-#![feature(allocator, core_intrinsics, libc)]\n+#![feature(allocator, core_intrinsics)]\n #![allocator]\n #![crate_type = \"rlib\"]\n #![no_std]\n \n-extern crate libc;\n-\n pub static mut HITS: usize = 0;\n \n+type size_t = usize;\n+\n+extern {\n+    fn malloc(size: usize) -> *mut u8;\n+    fn free(ptr: *mut u8);\n+    fn calloc(size: usize, amt: usize) -> *mut u8;\n+    fn realloc(ptr: *mut u8, size: usize) -> *mut u8;\n+}\n+\n #[no_mangle]\n pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     unsafe {\n         HITS += 1;\n-        libc::malloc(size as libc::size_t) as *mut u8\n+        malloc(size as size_t) as *mut u8\n     }\n }\n \n #[no_mangle]\n pub extern fn __rust_allocate_zeroed(size: usize, _align: usize) -> *mut u8 {\n-    unsafe { libc::calloc(size as libc::size_t, 1) as *mut u8 }\n+    unsafe { calloc(size as size_t, 1) as *mut u8 }\n }\n \n #[no_mangle]\n pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     unsafe {\n         HITS += 1;\n-        libc::free(ptr as *mut _)\n+        free(ptr as *mut _)\n     }\n }\n \n #[no_mangle]\n pub extern fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize,\n                                 align: usize) -> *mut u8 {\n     unsafe {\n-        libc::realloc(ptr as *mut _, size as libc::size_t) as *mut u8\n+        realloc(ptr as *mut _, size as size_t) as *mut u8\n     }\n }\n "}, {"sha": "90726c21fac472db923f21dfc92c42f93ad175e9", "filename": "src/test/run-pass/getopts_ref.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ccfe68076abc78392ab9e1d81b5c1a2123af657/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgetopts_ref.rs?ref=6ccfe68076abc78392ab9e1d81b5c1a2123af657", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#![feature(rustc_private)]\n-\n-extern crate getopts;\n-\n-use getopts::{optopt, getopts};\n-\n-pub fn main() {\n-    let args = Vec::new();\n-    let opts = vec![optopt(\"b\", \"\", \"something\", \"SMTHNG\")];\n-\n-    match getopts(&args, &opts) {\n-        Ok(ref m)  =>\n-            assert!(!m.opt_present(\"b\")),\n-        Err(ref f) => panic!(\"{}\", *f)\n-    };\n-\n-}"}, {"sha": "053ee8ee42ed60a57c434d812ac1396b3b40a033", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -11,11 +11,12 @@\n // Smallest \"hello world\" with a libc runtime\n \n // pretty-expanded FIXME #23616\n+// ignore-windows\n \n-#![feature(intrinsics, lang_items, start, no_core, libc)]\n+#![feature(intrinsics, lang_items, start, no_core, alloc_system)]\n #![no_core]\n \n-extern crate libc;\n+extern crate alloc_system;\n \n extern { fn puts(s: *const u8); }\n extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }"}, {"sha": "543e6784a72ac4ed7628261765295c238aa77caf", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -4,8 +4,9 @@ name = \"compiletest\"\n version = \"0.0.0\"\n \n [dependencies]\n-log = \"0.3\"\n+diff = \"0.1.10\"\n env_logger = { version = \"0.4\", default-features = false }\n-rustc-serialize = \"0.3\"\n filetime = \"0.1\"\n-diff = \"0.1.10\"\n+getopts = \"0.2\"\n+log = \"0.3\"\n+rustc-serialize = \"0.3\""}, {"sha": "c88ffba357a70f777d3cc728568e6ccc5bebfaab", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -11,7 +11,6 @@\n #![crate_name = \"compiletest\"]\n \n #![feature(box_syntax)]\n-#![feature(rustc_private)]\n #![feature(test)]\n #![feature(libc)]\n \n@@ -34,7 +33,7 @@ use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n use filetime::FileTime;\n-use getopts::{optopt, optflag, reqopt};\n+use getopts::Options;\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Mode};\n use test::{TestPaths, ColorConfig};\n@@ -66,68 +65,68 @@ fn main() {\n \n pub fn parse_config(args: Vec<String> ) -> Config {\n \n-    let groups : Vec<getopts::OptGroup> =\n-        vec![reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\"),\n-          reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\"),\n-          reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\"),\n-          reqopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\"),\n-          reqopt(\"\", \"lldb-python\", \"path to python to use for doc tests\", \"PATH\"),\n-          reqopt(\"\", \"docck-python\", \"path to python to use for doc tests\", \"PATH\"),\n-          optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\"),\n-          optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\"),\n-          optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\"),\n-          reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\"),\n-          reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\"),\n-          reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\"),\n-          reqopt(\"\", \"mode\", \"which sort of compile tests to run\",\n-                 \"(compile-fail|parse-fail|run-fail|run-pass|\\\n-                  run-pass-valgrind|pretty|debug-info|incremental|mir-opt)\"),\n-          optflag(\"\", \"ignored\", \"run tests marked as ignored\"),\n-          optflag(\"\", \"exact\", \"filters match exactly\"),\n-          optopt(\"\", \"runtool\", \"supervisor program to run tests under \\\n-                                 (eg. emulator, valgrind)\", \"PROGRAM\"),\n-          optopt(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\"),\n-          optopt(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\"),\n-          optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\"),\n-          optflag(\"\", \"quiet\", \"print one character per test instead of one line\"),\n-          optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\"),\n-          optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\"),\n-          optopt(\"\", \"target\", \"the target to build for\", \"TARGET\"),\n-          optopt(\"\", \"host\", \"the host to build for\", \"HOST\"),\n-          optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\"),\n-          optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\"),\n-          optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\"),\n-          optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\"),\n-          optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\"),\n-          optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\"),\n-          optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\"),\n-          optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\"),\n-          reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\"),\n-          reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\"),\n-          reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\"),\n-          reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\"),\n-          reqopt(\"\", \"llvm-cxxflags\", \"C++ flags for LLVM\", \"FLAGS\"),\n-          optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\"),\n-          optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\"),\n-          optflag(\"h\", \"help\", \"show this message\")];\n+    let mut opts = Options::new();\n+    opts.reqopt(\"\", \"compile-lib-path\", \"path to host shared libraries\", \"PATH\")\n+        .reqopt(\"\", \"run-lib-path\", \"path to target shared libraries\", \"PATH\")\n+        .reqopt(\"\", \"rustc-path\", \"path to rustc to use for compiling\", \"PATH\")\n+        .reqopt(\"\", \"rustdoc-path\", \"path to rustdoc to use for compiling\", \"PATH\")\n+        .reqopt(\"\", \"lldb-python\", \"path to python to use for doc tests\", \"PATH\")\n+        .reqopt(\"\", \"docck-python\", \"path to python to use for doc tests\", \"PATH\")\n+        .optopt(\"\", \"valgrind-path\", \"path to Valgrind executable for Valgrind tests\", \"PROGRAM\")\n+        .optflag(\"\", \"force-valgrind\", \"fail if Valgrind tests cannot be run under Valgrind\")\n+        .optopt(\"\", \"llvm-filecheck\", \"path to LLVM's FileCheck binary\", \"DIR\")\n+        .reqopt(\"\", \"src-base\", \"directory to scan for test files\", \"PATH\")\n+        .reqopt(\"\", \"build-base\", \"directory to deposit test outputs\", \"PATH\")\n+        .reqopt(\"\", \"stage-id\", \"the target-stage identifier\", \"stageN-TARGET\")\n+        .reqopt(\"\", \"mode\", \"which sort of compile tests to run\",\n+                \"(compile-fail|parse-fail|run-fail|run-pass|\\\n+                 run-pass-valgrind|pretty|debug-info|incremental|mir-opt)\")\n+        .optflag(\"\", \"ignored\", \"run tests marked as ignored\")\n+        .optflag(\"\", \"exact\", \"filters match exactly\")\n+        .optopt(\"\", \"runtool\", \"supervisor program to run tests under \\\n+                                (eg. emulator, valgrind)\", \"PROGRAM\")\n+        .optopt(\"\", \"host-rustcflags\", \"flags to pass to rustc for host\", \"FLAGS\")\n+        .optopt(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\")\n+        .optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\")\n+        .optflag(\"\", \"quiet\", \"print one character per test instead of one line\")\n+        .optopt(\"\", \"color\", \"coloring: auto, always, never\", \"WHEN\")\n+        .optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\")\n+        .optopt(\"\", \"target\", \"the target to build for\", \"TARGET\")\n+        .optopt(\"\", \"host\", \"the host to build for\", \"HOST\")\n+        .optopt(\"\", \"gdb\", \"path to GDB to use for GDB debuginfo tests\", \"PATH\")\n+        .optopt(\"\", \"lldb-version\", \"the version of LLDB used\", \"VERSION STRING\")\n+        .optopt(\"\", \"llvm-version\", \"the version of LLVM used\", \"VERSION STRING\")\n+        .optflag(\"\", \"system-llvm\", \"is LLVM the system LLVM\")\n+        .optopt(\"\", \"android-cross-path\", \"Android NDK standalone path\", \"PATH\")\n+        .optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\")\n+        .optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\")\n+        .optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\")\n+        .reqopt(\"\", \"cc\", \"path to a C compiler\", \"PATH\")\n+        .reqopt(\"\", \"cxx\", \"path to a C++ compiler\", \"PATH\")\n+        .reqopt(\"\", \"cflags\", \"flags for the C compiler\", \"FLAGS\")\n+        .reqopt(\"\", \"llvm-components\", \"list of LLVM components built in\", \"LIST\")\n+        .reqopt(\"\", \"llvm-cxxflags\", \"C++ flags for LLVM\", \"FLAGS\")\n+        .optopt(\"\", \"nodejs\", \"the name of nodejs\", \"PATH\")\n+        .optopt(\"\", \"remote-test-client\", \"path to the remote test client\", \"PATH\")\n+        .optflag(\"h\", \"help\", \"show this message\");\n \n     let (argv0, args_) = args.split_first().unwrap();\n     if args.len() == 1 || args[1] == \"-h\" || args[1] == \"--help\" {\n         let message = format!(\"Usage: {} [OPTIONS] [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(&message, &groups));\n+        println!(\"{}\", opts.usage(&message));\n         println!(\"\");\n         panic!()\n     }\n \n     let matches =\n-        &match getopts::getopts(args_, &groups) {\n+        &match opts.parse(args_) {\n           Ok(m) => m,\n           Err(f) => panic!(\"{:?}\", f)\n         };\n \n     if matches.opt_present(\"h\") || matches.opt_present(\"help\") {\n         let message = format!(\"Usage: {} [OPTIONS]  [TESTNAME...]\", argv0);\n-        println!(\"{}\", getopts::usage(&message, &groups));\n+        println!(\"{}\", opts.usage(&message));\n         println!(\"\");\n         panic!()\n     }"}, {"sha": "f5f1abc4b12a977a93b98360fd9b821c16078054", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37a991abc0271b3dc13aa46bed9381ed6aaa26d4/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=37a991abc0271b3dc13aa46bed9381ed6aaa26d4", "patch": "@@ -101,9 +101,6 @@ pub fn check(path: &Path, bad: &mut bool) {\n            filename.starts_with(\".#\") {\n             return\n         }\n-        if filename == \"miniz.c\" {\n-            return\n-        }\n \n         contents.truncate(0);\n         t!(t!(File::open(file), file).read_to_string(&mut contents));"}]}