{"sha": "b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YmFlOGZlYTU5NDNhMGI5NWExYTliZTEzYTgxNTVlZTQ1NDE4Yjc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T11:32:50Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-10-10T13:59:16Z"}, "message": "Make vectors and strings immediates again\n\nThere's no good reason to force them to be spilled anymore. Some\npieces of trans become more elegant this way, and less stack allocs\nand load/stores are needed.\n\nIssue #1021", "tree": {"sha": "fb1ebdf8465f626dee6ffb508155f267280cd5e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb1ebdf8465f626dee6ffb508155f267280cd5e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "html_url": "https://github.com/rust-lang/rust/commit/b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c53959f203272c94095c8b6b2271b127d01be6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c53959f203272c94095c8b6b2271b127d01be6f", "html_url": "https://github.com/rust-lang/rust/commit/5c53959f203272c94095c8b6b2271b127d01be6f"}], "stats": {"total": 221, "additions": 100, "deletions": 121}, "files": [{"sha": "6f7270f4396f8a652ff0df2262ebf2d5ab1d0443", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -284,7 +284,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n-        {mode: ast::by_ref,\n+        {mode: ast::by_val,\n          ty: @args_ty,\n          ident: \"args\",\n          id: cx.next_node_id()};"}, {"sha": "4e20543bc0b764dac6f07d2a80d49cfd8c0dc979", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -1327,8 +1327,9 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n     } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n         bcx = iter_structural_ty(bcx, v, t, take_ty);\n     } else if ty::type_is_vec(bcx_tcx(bcx), t) {\n-        bcx = tvec::duplicate(bcx, v);\n-        bcx = tvec::iter_vec(bcx, v, t, take_ty);\n+        let {bcx: cx, val} = tvec::duplicate(bcx, Load(bcx, v), t);\n+        bcx = cx;\n+        Store(bcx, val, v);\n     }\n \n     build_return(bcx);\n@@ -1361,6 +1362,9 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         v = PointerCast(bcx, v, type_of_1(bcx, t));\n         trans_uniq::make_free_glue(bcx, v, t)\n       }\n+      ty::ty_vec(_) | ty::ty_str. {\n+        tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of_1(bcx, t)), t)\n+      }\n       ty::ty_obj(_) {\n         // Call through the obj's own fields-drop glue first.\n         // Then free the body.\n@@ -1404,10 +1408,10 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n     let ccx = bcx_ccx(bcx);\n     let bcx =\n         alt ty::struct(ccx.tcx, t) {\n-          ty::ty_vec(_) { tvec::make_drop_glue(bcx, v0, t) }\n-          ty::ty_str. { tvec::make_drop_glue(bcx, v0, t) }\n           ty::ty_box(_) { decr_refcnt_maybe_free(bcx, Load(bcx, v0), t) }\n-          ty::ty_uniq(_) { free_ty(bcx, Load(bcx, v0), t) }\n+          ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. {\n+            free_ty(bcx, Load(bcx, v0), t)\n+          }\n           ty::ty_obj(_) {\n             let box_cell =\n                 GEP(bcx, v0, [C_int(0), C_int(abi::obj_field_box)]);\n@@ -1958,8 +1962,10 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n \n fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     alt ty::struct(bcx_tcx(bcx), t) {\n+      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. {\n+        ret free_ty(bcx, v, t);\n+      }\n       ty::ty_box(_) { ret decr_refcnt_maybe_free(bcx, v, t); }\n-      ty::ty_uniq(_) { ret free_ty(bcx, v, t); }\n       // FIXME A ty_ptr pointing at something that needs drop glue is somehow\n       // marked as needing drop glue. This is probably a mistake.\n       ty::ty_ptr(_) { ret bcx; }\n@@ -1973,6 +1979,7 @@ fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n         check trans_uniq::type_is_unique_box(bcx, t);\n         ret trans_uniq::duplicate(bcx, v, t);\n       }\n+      ty::ty_str. | ty::ty_vec(_) { ret tvec::duplicate(bcx, v, t); }\n       _ { ret rslt(bcx, v); }\n     }\n }\n@@ -2068,30 +2075,32 @@ fn copy_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     ret copy_val_no_check(cx, action, dst, src, t);\n }\n \n-fn copy_val_no_check(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n+fn copy_val_no_check(bcx: @block_ctxt, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> @block_ctxt {\n-    let ccx = bcx_ccx(cx);\n+    let ccx = bcx_ccx(bcx);\n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n-        Store(cx, src, dst);\n-        ret cx;\n+        Store(bcx, src, dst);\n+        ret bcx;\n     }\n-    if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) { ret cx; }\n+    if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) { ret bcx; }\n     if ty::type_is_boxed(ccx.tcx, t) {\n-        let bcx = cx;\n-        if action == DROP_EXISTING { bcx = drop_ty(cx, dst, t); }\n+        if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         Store(bcx, src, dst);\n         ret take_ty(bcx, dst, t);\n     }\n+    if ty::type_is_vec(ccx.tcx, t) {\n+        if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n+        let {bcx, val} = tvec::duplicate(bcx, src, t);\n+        Store(bcx, val, dst);\n+        ret bcx;\n+    }\n     if ty::type_is_unique_box(ccx.tcx, t) {\n-        let bcx = cx;\n-        if action == DROP_EXISTING { bcx = drop_ty(cx, dst, t); }\n+        if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         check trans_uniq::type_is_unique_box(bcx, t);\n         ret trans_uniq::copy_val(bcx, dst, src, t);\n     }\n-    if type_is_structural_or_param(ccx.tcx, t) || ty::type_is_vec(ccx.tcx, t)\n-        {\n-        let bcx = cx;\n-        if action == DROP_EXISTING { bcx = drop_ty(cx, dst, t); }\n+    if type_is_structural_or_param(ccx.tcx, t) {\n+        if action == DROP_EXISTING { bcx = drop_ty(bcx, dst, t); }\n         bcx = memmove_ty(bcx, dst, src, t);\n         ret take_ty(bcx, dst, t);\n     }\n@@ -2115,15 +2124,14 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         ret cx;\n     } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n         ret cx;\n-    } else if ty::type_is_boxed(tcx, t) || ty::type_is_unique_box(tcx, t) {\n+    } else if ty::type_is_boxed(tcx, t) || ty::type_is_unique(tcx, t) {\n         if src.kind == owned { src_val = Load(cx, src_val); }\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         Store(cx, src_val, dst);\n         if src.kind == owned { ret zero_alloca(cx, src.val, t); }\n         // If we're here, it must be a temporary.\n         ret revoke_clean(cx, src_val);\n-    } else if ty::type_is_unique(tcx, t) ||\n-                  type_is_structural_or_param(tcx, t) {\n+    } else if type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t); }\n         cx = memmove_ty(cx, dst, src_val, t);\n         if src.kind == owned { ret zero_alloca(cx, src_val, t); }\n@@ -2270,6 +2278,7 @@ fn trans_expr_fn(bcx: @block_ctxt, f: ast::_fn, sp: span,\n         let upvars = get_freevars(ccx.tcx, id);\n         let env_r = build_closure(bcx, upvars, copying);\n         env = env_r.ptr;\n+        bcx = env_r.bcx;\n         trans_closure(sub_cx, sp, f, llfn, none, [], id, {|fcx|\n             load_environment(bcx, fcx, env_r.ptrty, upvars, copying);\n         });\n@@ -2600,14 +2609,13 @@ fn trans_for(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     let next_cx = new_sub_block_ctxt(cx, \"next\");\n     let seq_ty = ty::expr_ty(bcx_tcx(cx), seq);\n     let {bcx: bcx, val: seq} = trans_temp_expr(cx, seq);\n-    let seq = PointerCast(bcx, seq, T_ptr(T_ptr(T_opaque_vec())));\n+    let seq = PointerCast(bcx, seq, T_ptr(T_opaque_vec()));\n     let fill = tvec::get_fill(bcx, seq);\n     if ty::type_is_str(bcx_tcx(bcx), seq_ty) {\n         fill = Sub(bcx, fill, C_int(1));\n     }\n-    let bcx =\n-        tvec::iter_vec_raw(bcx, seq, seq_ty, fill,\n-                           bind inner(_, local, _, _, body, next_cx));\n+    let bcx = tvec::iter_vec_raw(bcx, seq, seq_ty, fill,\n+                                 bind inner(_, local, _, _, body, next_cx));\n     Br(bcx, next_cx.llbb);\n     ret next_cx;\n }\n@@ -3183,15 +3191,14 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n                id: ast::node_id) -> lval_result {\n     // Is this an interior vector?\n-\n     let base_ty = ty::expr_ty(bcx_tcx(cx), base);\n     let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, exp.val, base_ty);\n     let ix = trans_temp_expr(lv.bcx, idx);\n     let v = lv.val;\n     let bcx = ix.bcx;\n-    // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n \n+    // Cast to an LLVM integer. Rust is less strict than LLVM in this regard.\n     let ix_val;\n     let ix_size = llsize_of_real(bcx_ccx(cx), val_ty(ix.val));\n     let int_size = llsize_of_real(bcx_ccx(cx), T_int());\n@@ -3200,6 +3207,7 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     } else if ix_size > int_size {\n         ix_val = Trunc(bcx, ix.val, T_int());\n     } else { ix_val = ix.val; }\n+\n     let unit_ty = node_id_type(bcx_ccx(cx), id);\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n@@ -4444,18 +4452,11 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         if kind == temporary {\n             revoke_clean(bcx, val);\n             *cell = val;\n-        } else if kind == owned_imm {\n+        } else if ty::type_is_immediate(bcx_tcx(bcx), ty) {\n+            if kind == owned { val = Load(bcx, val); }\n             let {bcx: cx, val} = take_ty_immediate(bcx, val, ty);\n             *cell = val;\n             bcx = cx;\n-        } else if ty::type_is_unique(bcx_tcx(bcx), ty) {\n-            // FIXME make vectors immediate again, lose this hack\n-            // Do a song and a dance to work around the fact that take_ty\n-            // for unique boxes overwrites the pointer.\n-            let oldval = Load(bcx, val);\n-            bcx = take_ty(bcx, val, ty);\n-            *cell = Load(bcx, val);\n-            Store(bcx, oldval, val);\n         } else {\n             bcx = take_ty(bcx, val, ty);\n             *cell = Load(bcx, val);\n@@ -5469,21 +5470,13 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         // If this argument to this function is a tag, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-\n-        let llargptr = alt fcx.llargs.find(va.id) {\n-          some(local_mem(x)) { PointerCast(bcx, x, val_ty(lldestptr)) }\n-        };\n+        let llarg = alt fcx.llargs.find(va.id) { some(local_mem(x)) { x } };\n         let arg_ty = arg_tys[i].ty;\n-        let llargval;\n-        if ty::type_is_structural(cx.ccx.tcx, arg_ty) ||\n-            ty::type_has_dynamic_size(cx.ccx.tcx, arg_ty) ||\n-            (ty::type_is_unique(cx.ccx.tcx, arg_ty)\n-             && !ty::type_is_unique_box(cx.ccx.tcx, arg_ty)) {\n-            // FIXME: Why do we do this for other unique pointer types but not\n-            // unique boxes? Something's not quite right.\n-            llargval = llargptr;\n-        } else { llargval = Load(bcx, llargptr); }\n-        bcx = copy_val(bcx, INIT, lldestptr, llargval, arg_ty);\n+        if ty::type_contains_params(bcx_tcx(bcx), arg_ty) {\n+            lldestptr = PointerCast(bcx, lldestptr, val_ty(llarg));\n+        }\n+        llarg = load_if_immediate(bcx, llarg, arg_ty);\n+        bcx = copy_val(bcx, INIT, lldestptr, llarg, arg_ty);\n         i += 1u;\n     }\n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n@@ -5899,9 +5892,6 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     let i = arg_n;\n     for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n-        if arg.mode == ast::by_ref {\n-            llarg = load_if_immediate(bcx, llarg, arg.ty);\n-        }\n         assert (llarg as int != 0);\n         if cast_to_i32 {\n             let llarg_i32 = convert_arg_to_i32(bcx, llarg, arg.ty, arg.mode);"}, {"sha": "29b903c3f89e9f6fa5ef76c3fee76f4bf2c48566", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -49,10 +49,10 @@ fn trans_opt(bcx: @block_ctxt, o: opt) -> opt_result {\n         alt l.node {\n           ast::lit_str(s) {\n             let strty = ty::mk_str(bcx_tcx(bcx));\n-            let {bcx, val: dst} = trans::alloc_ty(bcx, strty);\n-            bcx = trans_vec::trans_str(bcx, s, trans::save_in(dst));\n-            add_clean_temp(bcx, dst, strty);\n-            ret single_result(rslt(bcx, dst));\n+            let cell = trans::empty_dest_cell();\n+            bcx = trans_vec::trans_str(bcx, s, trans::by_val(cell));\n+            add_clean_temp(bcx, *cell, strty);\n+            ret single_result(rslt(bcx, *cell));\n           }\n           _ {\n             ret single_result(\n@@ -473,8 +473,9 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n           }\n           lit(l) {\n             kind = alt l.node {\n-              ast::lit_str(_) { compare }\n-              ast::lit_nil. { test_val = Load(bcx, val); compare }\n+              ast::lit_str(_) | ast::lit_nil. {\n+                test_val = Load(bcx, val); compare\n+              }\n               _ { test_val = Load(bcx, val); switch }\n             };\n           }"}, {"sha": "eddbda3f6a257392e3f62e1473c95bc016b884ba", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -12,17 +12,10 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n import trans_build::*;\n import trans_common::*;\n \n-fn get_fill(bcx: @block_ctxt, vptrptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_fill as int]))\n+fn get_fill(bcx: @block_ctxt, vptr: ValueRef) -> ValueRef {\n+    Load(bcx, GEPi(bcx, vptr, [0, abi::vec_elt_fill as int]))\n }\n-fn get_alloc(bcx: @block_ctxt, vptrptr: ValueRef) -> ValueRef {\n-    Load(bcx, GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_alloc as int]))\n-}\n-fn get_dataptr(bcx: @block_ctxt, vptrptr: ValueRef, unit_ty: TypeRef) ->\n-   ValueRef {\n-    ret get_dataptr_simple(bcx, Load(bcx, vptrptr), unit_ty);\n-}\n-fn get_dataptr_simple(bcx: @block_ctxt, vptr: ValueRef, unit_ty: TypeRef)\n+fn get_dataptr(bcx: @block_ctxt, vptr: ValueRef, unit_ty: TypeRef)\n     -> ValueRef {\n     let ptr = GEPi(bcx, vptr, [0, abi::vec_elt_elems as int]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n@@ -71,31 +64,31 @@ fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n          llunitty: llunitty};\n }\n \n-fn duplicate(bcx: @block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n-    let fill = get_fill(bcx, vptrptr);\n-    let vptr = Load(bcx, vptrptr);\n+fn duplicate(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) -> result {\n+    let fill = get_fill(bcx, vptr);\n     let size = Add(bcx, fill, llsize_of(T_opaque_vec()));\n     let {bcx: bcx, val: newptr} =\n         trans_shared_malloc(bcx, val_ty(vptr), size);\n     let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     Store(bcx, fill,\n           InBoundsGEP(bcx, newptr, [C_int(0), C_uint(abi::vec_elt_alloc)]));\n-    Store(bcx, newptr, vptrptr);\n-    ret bcx;\n+    if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n+        bcx = iter_vec(bcx, newptr, vec_ty, trans::take_ty);\n+    }\n+    ret rslt(bcx, newptr);\n }\n-fn make_drop_glue(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t) ->\n+fn make_free_glue(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t) ->\n    @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-    let vptr = Load(bcx, vptrptr);\n     let drop_cx = new_sub_block_ctxt(bcx, \"drop\");\n     let next_cx = new_sub_block_ctxt(bcx, \"next\");\n     let null_test = IsNull(bcx, vptr);\n     CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n     if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n-        drop_cx = iter_vec(drop_cx, vptrptr, vec_ty, trans::drop_ty);\n+        drop_cx = iter_vec(drop_cx, vptr, vec_ty, trans::drop_ty);\n     }\n     drop_cx = trans::trans_shared_free(drop_cx, vptr);\n-    Store(drop_cx, C_null(val_ty(vptr)), vptrptr);\n     Br(drop_cx, next_cx.llbb);\n     ret next_cx;\n }\n@@ -118,7 +111,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n \n     add_clean_free(bcx, vptr, true);\n     // Store the individual elements.\n-    let dataptr = get_dataptr_simple(bcx, vptr, llunitty);\n+    let dataptr = get_dataptr(bcx, vptr, llunitty);\n     let i = 0u, temp_cleanups = [vptr];\n     for e in args {\n         let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n@@ -130,8 +123,7 @@ fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id,\n         i += 1u;\n     }\n     for clean in temp_cleanups { revoke_clean(bcx, clean); }\n-    Store(bcx, vptr, trans::get_dest_addr(dest));\n-    ret bcx;\n+    ret trans::store_in_dest(bcx, vptr, dest);\n }\n \n fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n@@ -141,50 +133,47 @@ fn trans_str(bcx: @block_ctxt, s: str, dest: dest) -> @block_ctxt {\n \n     let llcstr = C_cstr(bcx_ccx(bcx), s);\n     let bcx =\n-        call_memmove(bcx, get_dataptr_simple(bcx, sptr, T_i8()), llcstr,\n+        call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()), llcstr,\n                      C_uint(veclen)).bcx;\n-    Store(bcx, sptr, trans::get_dest_addr(dest));\n-    ret bcx;\n+    ret trans::store_in_dest(bcx, sptr, dest);\n }\n \n fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-                rhsptr: ValueRef) -> @block_ctxt {\n+                rhs: ValueRef) -> @block_ctxt {\n     // Cast to opaque interior vector types if necessary.\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n     let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n     if dynamic {\n         lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n-        rhsptr = PointerCast(cx, rhsptr, T_ptr(T_ptr(T_opaque_vec())));\n+        rhs = PointerCast(cx, rhs, T_ptr(T_opaque_vec()));\n     }\n-    let strings =\n-        alt ty::struct(bcx_tcx(cx), vec_ty) {\n-          ty::ty_str. { true }\n-          ty::ty_vec(_) { false }\n-        };\n+    let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n+      ty::ty_str. { true }\n+      ty::ty_vec(_) { false }\n+    };\n \n     let {bcx: bcx, val: unit_sz} = size_of(cx, unit_ty);\n     let llunitty = type_of_or_i8(cx, unit_ty);\n \n-    let rhs = Load(bcx, rhsptr);\n     let lhs = Load(bcx, lhsptr);\n     let self_append = ICmp(bcx, lib::llvm::LLVMIntEQ, lhs, rhs);\n-    let lfill = get_fill(bcx, lhsptr);\n-    let rfill = get_fill(bcx, rhsptr);\n+    let lfill = get_fill(bcx, lhs);\n+    let rfill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lfill, rfill);\n     if strings { new_fill = Sub(bcx, new_fill, C_int(1)); }\n     let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_vec())));\n     Call(bcx, bcx_ccx(cx).upcalls.vec_grow,\n          [cx.fcx.lltaskptr, opaque_lhs, new_fill]);\n     // Was overwritten if we resized\n-    rhsptr = Select(bcx, self_append, lhsptr, rhsptr);\n+    let lhs = Load(bcx, lhsptr);\n+    rhs = Select(bcx, self_append, lhs, rhs);\n \n-    let lhs_data = get_dataptr(bcx, lhsptr, llunitty);\n+    let lhs_data = get_dataptr(bcx, lhs, llunitty);\n     let lhs_off = lfill;\n     if strings { lhs_off = Sub(bcx, lhs_off, C_int(1)); }\n     let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n     let write_ptr_ptr = do_spill_noroot(bcx, write_ptr);\n-    let bcx =\n-        iter_vec_raw(bcx, rhsptr, vec_ty, rfill,\n+    let bcx = iter_vec_raw(bcx, rhs, vec_ty, rfill,\n                      // We have to increment by the dynamically-computed size.\n                      {|bcx, addr, _ty|\n                          let write_ptr = Load(bcx, write_ptr_ptr);\n@@ -221,8 +210,8 @@ fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     ret bcx;\n }\n \n-fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-             rhsptr: ValueRef, dest: dest) -> @block_ctxt {\n+fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n+             rhs: ValueRef, dest: dest) -> @block_ctxt {\n     let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n       ty::ty_str. { true }\n       ty::ty_vec(_) { false }\n@@ -231,15 +220,15 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: llunitsz} = size_of(bcx, unit_ty);\n \n-    let lhs_fill = get_fill(bcx, lhsptr);\n+    let lhs_fill = get_fill(bcx, lhs);\n     if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(1)); }\n-    let rhs_fill = get_fill(bcx, rhsptr);\n+    let rhs_fill = get_fill(bcx, rhs);\n     let new_fill = Add(bcx, lhs_fill, rhs_fill);\n     let {bcx: bcx, val: new_vec_ptr} = alloc_raw(bcx, new_fill, new_fill);\n     new_vec_ptr = PointerCast(bcx, new_vec_ptr, T_ptr(T_vec(llunitty)));\n \n     let write_ptr_ptr = do_spill_noroot\n-        (bcx, get_dataptr_simple(bcx, new_vec_ptr, llunitty));\n+        (bcx, get_dataptr(bcx, new_vec_ptr, llunitty));\n     let copy_fn =\n         bind fn (bcx: @block_ctxt, addr: ValueRef, _ty: ty::t,\n                  write_ptr_ptr: ValueRef, unit_ty: ty::t, llunitsz: ValueRef)\n@@ -256,23 +245,22 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                  ret bcx;\n              }(_, _, _, write_ptr_ptr, unit_ty, llunitsz);\n \n-    let bcx = iter_vec_raw(bcx, lhsptr, vec_ty, lhs_fill, copy_fn);\n-    bcx = iter_vec_raw(bcx, rhsptr, vec_ty, rhs_fill, copy_fn);\n-    Store(bcx, new_vec_ptr, trans::get_dest_addr(dest));\n-    ret bcx;\n+    let bcx = iter_vec_raw(bcx, lhs, vec_ty, lhs_fill, copy_fn);\n+    bcx = iter_vec_raw(bcx, rhs, vec_ty, rhs_fill, copy_fn);\n+    ret trans::store_in_dest(bcx, new_vec_ptr, dest);\n }\n \n type val_and_ty_fn = fn(@block_ctxt, ValueRef, ty::t) -> result;\n \n type iter_vec_block = block(@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n-fn iter_vec_raw(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+fn iter_vec_raw(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n                 fill: ValueRef, f: iter_vec_block) -> @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n-    vptrptr = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_vec(llunitty))));\n-    let data_ptr = get_dataptr(bcx, vptrptr, llunitty);\n+    vptr = PointerCast(bcx, vptr, T_ptr(T_vec(llunitty)));\n+    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n \n     // Calculate the last pointer address we want to handle.\n     // TODO: Optimize this when the size of the unit type is statically\n@@ -299,10 +287,10 @@ fn iter_vec_raw(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     ret next_cx;\n }\n \n-fn iter_vec(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+fn iter_vec(bcx: @block_ctxt, vptr: ValueRef, vec_ty: ty::t,\n             f: iter_vec_block) -> @block_ctxt {\n-    vptrptr = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n-    ret iter_vec_raw(bcx, vptrptr, vec_ty, get_fill(bcx, vptrptr), f);\n+    vptr = PointerCast(bcx, vptr, T_ptr(T_opaque_vec()));\n+    ret iter_vec_raw(bcx, vptr, vec_ty, get_fill(bcx, vptr), f);\n }\n \n //"}, {"sha": "428278b4132415baafcc558ebe16a4b85ded14e7", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -920,7 +920,7 @@ pure fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n // FIXME maybe inline this for speed?\n fn type_is_immediate(cx: ctxt, ty: t) -> bool {\n     ret type_is_scalar(cx, ty) || type_is_boxed(cx, ty) ||\n-        type_is_unique_box(cx, ty) || type_is_native(cx, ty);\n+        type_is_unique(cx, ty) || type_is_native(cx, ty);\n }\n \n fn type_has_pointers(cx: ctxt, ty: t) -> bool {"}, {"sha": "5ebebc2748a35f9dcbac1bfe038e19b71764719c", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -1,6 +1,6 @@\n \n native \"rust\" mod rustrt {\n-    fn rust_list_files(path: str) -> [str];\n+    fn rust_list_files(&&path: str) -> [str];\n }\n \n fn list_dir(path: str) -> [str] {"}, {"sha": "bf21e056f6c849bab3460f4b27f5a1cb858db0de", "filename": "src/lib/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -5,7 +5,7 @@ import uint::next_power_of_two;\n import ptr::addr_of;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn vec_len<T>(v: [T]) -> uint;\n+    fn vec_len<T>(&&v: [T]) -> uint;\n }\n \n native \"rust\" mod rustrt {"}, {"sha": "e1bfb24b6d1829bad06ccbe15338d9613c1071f5", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -1,8 +1,8 @@\n \n \n native \"rust\" mod rustrt {\n-    fn rust_list_files(path: str) -> [str];\n-    fn rust_file_is_dir(path: str) -> int;\n+    fn rust_list_files(&&path: str) -> [str];\n+    fn rust_file_is_dir(&&path: str) -> int;\n }\n \n fn list_dir(path: str) -> [str] {"}, {"sha": "0c0a3c17179b40306e82d63c102c8c65f88f5443", "filename": "src/test/run-pass/interior-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bae8fea5943a0b95a1a9be13a8155ee45418b7/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finterior-vec.rs?ref=b4bae8fea5943a0b95a1a9be13a8155ee45418b7", "patch": "@@ -1,7 +1,7 @@\n import rusti::vec_len;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn vec_len<T>(v: [T]) -> uint;\n+    fn vec_len<T>(&&v: [T]) -> uint;\n }\n \n fn main() {"}]}