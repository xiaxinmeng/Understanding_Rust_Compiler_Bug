{"sha": "f58a8c9d760aead49e138fa8045e229a47217644", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1OGE4YzlkNzYwYWVhZDQ5ZTEzOGZhODA0NWUyMjlhNDcyMTc2NDQ=", "commit": {"author": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-04-21T02:28:38Z"}, "committer": {"name": "Jonathan S", "email": "gereeter@gmail.com", "date": "2014-04-28T21:45:36Z"}, "message": "Provide an implementation of DoubleEndedIterator for the results of &[T]::split and &[T]::rsplit\n\nThis makes the splitting functions in std::slice return DoubleEndedIterators. Unfortunately,\nsplitn and rsplitn cannot provide such an interface and so must return different types. As a\nresult, the following changes were made:\n\n* RevSplits was removed in favor of explicitly using Rev\n* Splits can no longer bound the number of splits done\n* Splits now implements DoubleEndedIterator\n* SplitsN was added, taking the role of what both Splits and RevSplits used to be\n* rsplit returns Rev<Splits<'a, T>> instead of RevSplits<'a, T>\n* splitn returns SplitsN<'a, T> instead of Splits<'a, T>\n* rsplitn returns SplitsN<'a, T> instead of RevSplits<'a, T>\n\nAll functions that were previously implemented on each return value still are, so outside of changing\nof type annotations, existing code should work out of the box. In the rare case that code relied\non the return types of split and splitn or of rsplit and rsplitn being the same, the previous\nbehavior can be emulated by calling splitn or rsplitn with a bount of uint::MAX.\n\nThe value of this change comes in multiple parts:\n\n* Consistency. The splitting code in std::str is structured similarly to the new slice splitting code,\n  having separate CharSplits and CharSplitsN types.\n* Smaller API. Although this commit doesn't implement it, using a DoubleEndedIterator for splitting\n  means that rsplit, path::RevComponents, path::RevStrComponents, Path::rev_components, and\n  Path::rev_str_components are no longer needed - they can be emulated simply with .rev().\n* Power. DoubleEndedIterators are able to traverse the list from both sides at once instead of only\n  forwards or backwards.\n* Efficiency. For the common case of using split instead of splitn, the iterator is slightly smaller\n  and slightly faster.\n\n[breaking-change]", "tree": {"sha": "38becfafd8f09f0da6bb227b4024894f3d6d7584", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38becfafd8f09f0da6bb227b4024894f3d6d7584"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f58a8c9d760aead49e138fa8045e229a47217644", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f58a8c9d760aead49e138fa8045e229a47217644", "html_url": "https://github.com/rust-lang/rust/commit/f58a8c9d760aead49e138fa8045e229a47217644", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f58a8c9d760aead49e138fa8045e229a47217644/comments", "author": null, "committer": null, "parents": [{"sha": "23262a83909392f88fdc8031ebd754f8d9b94525", "url": "https://api.github.com/repos/rust-lang/rust/commits/23262a83909392f88fdc8031ebd754f8d9b94525", "html_url": "https://github.com/rust-lang/rust/commit/23262a83909392f88fdc8031ebd754f8d9b94525"}], "stats": {"total": 148, "additions": 64, "deletions": 84}, "files": [{"sha": "eceeb73a0157e362531ab349262368925f25f57b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f58a8c9d760aead49e138fa8045e229a47217644/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58a8c9d760aead49e138fa8045e229a47217644/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=f58a8c9d760aead49e138fa8045e229a47217644", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -16,11 +16,11 @@ use clone::Clone;\n use cmp::{Eq, TotalEq};\n use from_str::FromStr;\n use io::Writer;\n-use iter::{AdditiveIterator, Extendable, Iterator, Map};\n+use iter::{DoubleEndedIterator, Rev, AdditiveIterator, Extendable, Iterator, Map};\n use option::{Option, None, Some};\n use str;\n use str::Str;\n-use slice::{CloneableVector, RevSplits, Splits, Vector, VectorVector,\n+use slice::{CloneableVector, Splits, Vector, VectorVector,\n             ImmutableEqVector, OwnedVector, ImmutableVector};\n use vec::Vec;\n \n@@ -29,14 +29,13 @@ use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> = Splits<'a, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponents<'a> = RevSplits<'a, u8>;\n+pub type RevComponents<'a> = Rev<Components<'a>>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n                                        Components<'a>>;\n /// Iterator that yields components of a Path in reverse as Option<&str>\n-pub type RevStrComponents<'a> = Map<'a, &'a [u8], Option<&'a str>,\n-                                          RevComponents<'a>>;\n+pub type RevStrComponents<'a> = Rev<StrComponents<'a>>;\n \n /// Represents a POSIX file path\n #[deriving(Clone)]\n@@ -397,15 +396,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse.\n     /// See components() for details.\n     pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        let v = if *self.repr.get(0) == SEP_BYTE {\n-            self.repr.slice_from(1)\n-        } else { self.repr.as_slice() };\n-        let mut ret = v.rsplit(is_sep_byte);\n-        if v.is_empty() {\n-            // consume the empty \"\" component\n-            ret.next();\n-        }\n-        ret\n+        self.components().rev()\n     }\n \n     /// Returns an iterator that yields each component of the path as Option<&str>.\n@@ -417,7 +408,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse as Option<&str>.\n     /// See components() for details.\n     pub fn rev_str_components<'a>(&'a self) -> RevStrComponents<'a> {\n-        self.rev_components().map(str::from_utf8)\n+        self.str_components().rev()\n     }\n }\n "}, {"sha": "679075fe6ca06dbcfe325cf248d5021d1716f63e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f58a8c9d760aead49e138fa8045e229a47217644/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58a8c9d760aead49e138fa8045e229a47217644/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=f58a8c9d760aead49e138fa8045e229a47217644", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -37,15 +37,13 @@ pub type StrComponents<'a> = Map<'a, &'a str, Option<&'a str>,\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type RevStrComponents<'a> = Rev<Map<'a, &'a str, Option<&'a str>,\n-                                                 CharSplits<'a, char>>>;\n+pub type RevStrComponents<'a> = Rev<StrComponents<'a>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n pub type Components<'a> = Map<'a, Option<&'a str>, &'a [u8],\n                                     StrComponents<'a>>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponents<'a> = Map<'a, Option<&'a str>, &'a [u8],\n-                                       RevStrComponents<'a>>;\n+pub type RevComponents<'a> = Rev<Components<'a>>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:\n@@ -650,11 +648,7 @@ impl Path {\n     /// Returns an iterator that yields each component of the path in reverse as a &[u8].\n     /// See str_components() for details.\n     pub fn rev_components<'a>(&'a self) -> RevComponents<'a> {\n-        fn convert<'a>(x: Option<&'a str>) -> &'a [u8] {\n-            #![inline]\n-            x.unwrap().as_bytes()\n-        }\n-        self.rev_str_components().map(convert)\n+        self.components().rev()\n     }\n \n     fn equiv_prefix(&self, other: &Path) -> bool {"}, {"sha": "180a142dea1f64a65ed550cf9aa483991a21374b", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 53, "deletions": 58, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/f58a8c9d760aead49e138fa8045e229a47217644/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f58a8c9d760aead49e138fa8045e229a47217644/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=f58a8c9d760aead49e138fa8045e229a47217644", "patch": "@@ -119,7 +119,6 @@ use result::{Ok, Err};\n use mem;\n use mem::size_of;\n use kinds::marker;\n-use uint;\n use unstable::finally::try_finally;\n use raw::{Repr, Slice};\n use RawVec = raw::Vec;\n@@ -148,7 +147,6 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// match a predicate function.\n pub struct Splits<'a, T> {\n     v: &'a [T],\n-    n: uint,\n     pred: |t: &T|: 'a -> bool,\n     finished: bool\n }\n@@ -158,11 +156,6 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n \n-        if self.n == 0 {\n-            self.finished = true;\n-            return Some(self.v);\n-        }\n-\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n@@ -171,7 +164,6 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n             Some(idx) => {\n                 let ret = Some(self.v.slice(0, idx));\n                 self.v = self.v.slice(idx + 1, self.v.len());\n-                self.n -= 1;\n                 ret\n             }\n         }\n@@ -180,38 +172,18 @@ impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         if self.finished {\n-            return (0, Some(0))\n-        }\n-        // if the predicate doesn't match anything, we yield one slice\n-        // if it matches every element, we yield N+1 empty slices where\n-        // N is either the number of elements or the number of splits.\n-        match (self.v.len(), self.n) {\n-            (0,_) => (1, Some(1)),\n-            (_,0) => (1, Some(1)),\n-            (l,n) => (1, cmp::min(l,n).checked_add(&1u))\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n         }\n     }\n }\n \n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, from back to front.\n-pub struct RevSplits<'a, T> {\n-    v: &'a [T],\n-    n: uint,\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n \n-        if self.n == 0 {\n-            self.finished = true;\n-            return Some(self.v);\n-        }\n-\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => {\n                 self.finished = true;\n@@ -220,21 +192,42 @@ impl<'a, T> Iterator<&'a [T]> for RevSplits<'a, T> {\n             Some(idx) => {\n                 let ret = Some(self.v.slice(idx + 1, self.v.len()));\n                 self.v = self.v.slice(0, idx);\n-                self.n -= 1;\n                 ret\n             }\n         }\n     }\n+}\n \n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, splitting at most a fixed number of times.\n+pub struct SplitsN<'a, T> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            return (0, Some(0))\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.count == 0 {\n+            if self.iter.finished {\n+                None\n+            } else {\n+                self.iter.finished = true;\n+                Some(self.iter.v)\n+            }\n+        } else {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n         }\n-        match (self.v.len(), self.n) {\n-            (0,_) => (1, Some(1)),\n-            (_,0) => (1, Some(1)),\n-            (l,n) => (1, cmp::min(l,n).checked_add(&1u))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.iter.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n         }\n     }\n }\n@@ -747,18 +740,18 @@ pub trait ImmutableVector<'a, T> {\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.  The matched element is\n     /// not contained in the subslices.\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> RevSplits<'a, T>;\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> RevSplits<'a, T>;\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n \n     /**\n      * Returns an iterator over all contiguous windows of length\n@@ -936,31 +929,33 @@ impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n \n     #[inline]\n     fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        self.splitn(uint::MAX, pred)\n-    }\n-\n-    #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n         Splits {\n             v: self,\n-            n: n,\n             pred: pred,\n             finished: false\n         }\n     }\n \n     #[inline]\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> RevSplits<'a, T> {\n-        self.rsplitn(uint::MAX, pred)\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n+        }\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> RevSplits<'a, T> {\n-        RevSplits {\n-            v: self,\n-            n: n,\n-            pred: pred,\n-            finished: false\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n+        self.split(pred).rev()\n+    }\n+\n+    #[inline]\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n         }\n     }\n "}]}