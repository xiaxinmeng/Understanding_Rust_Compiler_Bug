{"sha": "83667d64a2ae9c85722930f02d05e7b2efa8d853", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNjY3ZDY0YTJhZTljODU3MjI5MzBmMDJkMDVlN2IyZWZhOGQ4NTM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-05T13:13:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-10T08:08:17Z"}, "message": "abstract mono_hash_map through a trait, only miri actually needs the fancy one", "tree": {"sha": "e65492462af102ffd56a453229353ad4e4f3e72a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e65492462af102ffd56a453229353ad4e4f3e72a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83667d64a2ae9c85722930f02d05e7b2efa8d853", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83667d64a2ae9c85722930f02d05e7b2efa8d853", "html_url": "https://github.com/rust-lang/rust/commit/83667d64a2ae9c85722930f02d05e7b2efa8d853", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83667d64a2ae9c85722930f02d05e7b2efa8d853/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ea7c7fc27e2ca306d7a5c7b92a2a531b262600", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ea7c7fc27e2ca306d7a5c7b92a2a531b262600", "html_url": "https://github.com/rust-lang/rust/commit/75ea7c7fc27e2ca306d7a5c7b92a2a531b262600"}], "stats": {"total": 303, "additions": 167, "deletions": 136}, "files": [{"sha": "fd18d9feeea91e12b123b30dd2ad23fef05843f2", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 68, "deletions": 2, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=83667d64a2ae9c85722930f02d05e7b2efa8d853", "patch": "@@ -12,7 +12,9 @@\n \n use std::fmt;\n use std::error::Error;\n-use std::borrow::Cow;\n+use std::borrow::{Borrow, Cow};\n+use std::hash::Hash;\n+use std::collections::hash_map::Entry;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir::interpret::ConstEvalErr;\n@@ -21,13 +23,14 @@ use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, TyLayout};\n use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::FxHashMap;\n \n use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Scalar, Allocation, ConstValue,\n+    Scalar, Allocation, AllocId, ConstValue,\n };\n use interpret::{self,\n     Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n@@ -265,6 +268,67 @@ impl<'a, 'mir, 'tcx> CompileTimeInterpreter<'a, 'mir, 'tcx> {\n     }\n }\n \n+impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n+    #[inline(always)]\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+        where K: Borrow<Q>\n+    {\n+        FxHashMap::contains_key(self, k)\n+    }\n+\n+    #[inline(always)]\n+    fn insert(&mut self, k: K, v: V) -> Option<V>\n+    {\n+        FxHashMap::insert(self, k, v)\n+    }\n+\n+    #[inline(always)]\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+        where K: Borrow<Q>\n+    {\n+        FxHashMap::remove(self, k)\n+    }\n+\n+    #[inline(always)]\n+    fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n+        self.iter()\n+            .filter_map(move |(k, v)| f(k, &*v))\n+            .collect()\n+    }\n+\n+    #[inline(always)]\n+    fn get_or<E>(\n+        &self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&V, E>\n+    {\n+        match self.get(&k) {\n+            Some(v) => Ok(v),\n+            None => {\n+                vacant()?;\n+                bug!(\"The CTFE machine shouldn't ever need to extend the alloc_map when reading\")\n+            }\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn get_mut_or<E>(\n+        &mut self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&mut V, E>\n+    {\n+        match self.entry(k) {\n+            Entry::Occupied(e) => Ok(e.into_mut()),\n+            Entry::Vacant(e) => {\n+                let v = vacant()?;\n+                Ok(e.insert(v))\n+            }\n+        }\n+    }\n+}\n+\n type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n     EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n \n@@ -275,6 +339,8 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     type MemoryKinds = !;\n     type PointerTag = ();\n \n+    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation<()>)>;\n+\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n     const ENFORCE_VALIDITY: bool = false; // for now, we don't\n "}, {"sha": "650349cc38c50c107ecc25203ba9ec77b36c73bb", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=83667d64a2ae9c85722930f02d05e7b2efa8d853", "patch": "@@ -12,27 +12,68 @@\n //! This separation exists to ensure that no fancy miri features like\n //! interpreting common C functions leak into CTFE.\n \n-use std::borrow::Cow;\n+use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n+use rustc::mir::interpret::{Allocation, AllocId, EvalResult, Scalar};\n use rustc::mir;\n use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n \n-use super::{EvalContext, PlaceTy, OpTy};\n+use super::{EvalContext, PlaceTy, OpTy, MemoryKind};\n+\n+/// The functionality needed by memory to manage its allocations\n+pub trait AllocMap<K: Hash + Eq, V> {\n+    /// Test if the map contains the given key.\n+    /// Deliberately takes `&mut` because that is sufficient, and some implementations\n+    /// can be more efficient then (using `RefCell::get_mut`).\n+    fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n+        where K: Borrow<Q>;\n+\n+    /// Insert new entry into the map.\n+    fn insert(&mut self, k: K, v: V) -> Option<V>;\n+\n+    /// Remove entry from the map.\n+    fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n+        where K: Borrow<Q>;\n+\n+    /// Return data based the keys and values in the map.\n+    fn filter_map_collect<T>(&self, f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T>;\n+\n+    /// Return a reference to entry `k`.  If no such entry exists, call\n+    /// `vacant` and either forward its error, or add its result to the map\n+    /// and return a reference to *that*.\n+    fn get_or<E>(\n+        &self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&V, E>;\n+\n+    /// Return a mutable reference to entry `k`.  If no such entry exists, call\n+    /// `vacant` and either forward its error, or add its result to the map\n+    /// and return a reference to *that*.\n+    fn get_mut_or<E>(\n+        &mut self,\n+        k: K,\n+        vacant: impl FnOnce() -> Result<V, E>\n+    ) -> Result<&mut V, E>;\n+}\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied.\n-/// FIXME: We should be able to get rid of the 'a here if we can get rid of the 'a in\n-/// `snapshot::EvalSnapshot`.\n pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Additional data that can be accessed via the Memory\n     type MemoryData;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     type MemoryKinds: ::std::fmt::Debug + Copy + Eq;\n \n+    /// Memory's allocation map\n+    type MemoryMap:\n+        AllocMap<AllocId, (MemoryKind<Self::MemoryKinds>, Allocation<Self::PointerTag>)> +\n+        Default +\n+        Clone;\n+\n     /// Tag tracked alongside every pointer.  This is inert for now, in preparation for\n     /// a future implementation of \"Stacked Borrows\"\n     /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>."}, {"sha": "cb0ff25b4f22b9ae3a8c8f6adc016361166ac586", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=83667d64a2ae9c85722930f02d05e7b2efa8d853", "patch": "@@ -16,22 +16,23 @@\n //! integer.  It is crucial that these operations call `check_align` *before*\n //! short-circuiting the empty case!\n \n-use std::collections::hash_map::Entry;\n use std::collections::VecDeque;\n use std::ptr;\n use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n-use rustc::mir::interpret::{Pointer, AllocId, Allocation, ConstValue, GlobalId,\n-                            EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n-                            truncate};\n+use rustc::mir::interpret::{\n+    Pointer, AllocId, Allocation, ConstValue, GlobalId,\n+    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+    truncate\n+};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n-use super::{Machine, MonoHashMap, ScalarMaybeUndef};\n+use super::{Machine, AllocMap, ScalarMaybeUndef};\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n@@ -52,13 +53,13 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Allocations local to this instance of the miri engine.  The kind\n     /// helps ensure that the same mechanism is used for allocation and\n     /// deallocation.  When an allocation is not found here, it is a\n-    /// static and looked up in the `tcx` for read access.  If this machine\n-    /// does pointer provenance tracking, the type of alloctions in `tcx`\n-    /// and here do not match, so we have a `MonoHashMap` to be able to\n-    /// put the \"mapped\" allocation into `alloc_map` even on a read access.\n+    /// static and looked up in the `tcx` for read access.  Some machines may\n+    /// have to mutate this map even on a read-only access to a static (because\n+    /// they do pointer provenance tracking and the allocations in `tcx` have\n+    /// the wrong type), so we let the machine override this type.\n     /// Either way, if the machine allows writing to a static, doing so will\n     /// create a copy of the static allocation here.\n-    alloc_map: MonoHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<M::PointerTag>)>,\n+    alloc_map: M::MemoryMap,\n \n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n@@ -106,7 +107,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n-            alloc_map: MonoHashMap::default(),\n+            alloc_map: Default::default(),\n             dead_alloc_map: FxHashMap::default(),\n             tcx,\n         }\n@@ -419,30 +420,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &mut self,\n         id: AllocId,\n     ) -> EvalResult<'tcx, &mut Allocation<M::PointerTag>> {\n-        Ok(match self.alloc_map.entry(id) {\n-            // Normal alloc?\n-            Entry::Occupied(alloc) => {\n-                let alloc = &mut alloc.into_mut().1;\n-                if alloc.mutability == Mutability::Immutable {\n-                    return err!(ModifiedConstantMemory);\n-                }\n-                alloc\n+        let tcx = self.tcx;\n+        let a = self.alloc_map.get_mut_or(id, || {\n+            // Need to make a copy, even if `get_static_alloc` is able\n+            // to give us a cheap reference.\n+            let alloc = Self::get_static_alloc(tcx, id)?;\n+            if alloc.mutability == Mutability::Immutable {\n+                return err!(ModifiedConstantMemory);\n             }\n-            // Static.\n-            Entry::Vacant(entry) => {\n-                // Need to make a copy, even if `get_static_alloc` is able\n-                // to give us a cheap reference.\n-                let alloc = Self::get_static_alloc(self.tcx, id)?;\n-                if alloc.mutability == Mutability::Immutable {\n+            let kind = M::STATIC_KIND.expect(\n+                \"I got an owned allocation that I have to copy but the machine does \\\n+                    not expect that to happen\"\n+            );\n+            Ok((MemoryKind::Machine(kind), alloc.into_owned()))\n+        });\n+        // Unpack the error type manually because type inference doesn't\n+        // work otherwise (and we cannot help it because `impl Trait`)\n+        match a {\n+            Err(e) => Err(e),\n+            Ok(a) => {\n+                let a = &mut a.1;\n+                if a.mutability == Mutability::Immutable {\n                     return err!(ModifiedConstantMemory);\n                 }\n-                let kind = M::STATIC_KIND.expect(\n-                    \"I got an owned allocation that I have to copy but the machine does \\\n-                        not expect that to happen\"\n-                );\n-                &mut entry.insert(Box::new((MemoryKind::Machine(kind), alloc.into_owned()))).1\n+                Ok(a)\n             }\n-        })\n+        }\n     }\n \n     pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> EvalResult<'tcx, Instance<'tcx>> {\n@@ -534,8 +537,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             let msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));\n \n             // normal alloc?\n-            match self.alloc_map.get(&id) {\n-                Some((kind, alloc)) => {\n+            match self.alloc_map.get_or(id, || Err(())) {\n+                Ok((kind, alloc)) => {\n                     let extra = match kind {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Vtable => \" (vtable)\".to_owned(),\n@@ -546,7 +549,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                         msg, alloc, extra\n                     );\n                 },\n-                None => {\n+                Err(()) => {\n                     // static alloc?\n                     match self.tcx.alloc_map.lock().get(id) {\n                         Some(AllocType::Memory(alloc)) => {\n@@ -664,7 +667,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n }\n \n /// Interning (for CTFE)\n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx, PointerTag=()>> Memory<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n+where\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<()>)>,\n+{\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn intern_static(\n         &mut self,"}, {"sha": "39628598ef31cd1d1172d9fa35e16e0ce22bb964", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=83667d64a2ae9c85722930f02d05e7b2efa8d853", "patch": "@@ -23,7 +23,6 @@ mod terminator;\n mod traits;\n mod validity;\n mod intrinsics;\n-mod mono_hash_map;\n \n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n@@ -33,10 +32,8 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind};\n \n-pub use self::machine::Machine;\n+pub use self::machine::{Machine, AllocMap};\n \n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n \n pub use self::validity::RefTracking;\n-\n-pub use self::mono_hash_map::MonoHashMap;"}, {"sha": "ef9a84fd98d4f14893db85326fb51a70e259f5eb", "filename": "src/librustc_mir/interpret/mono_hash_map.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/75ea7c7fc27e2ca306d7a5c7b92a2a531b262600/src%2Flibrustc_mir%2Finterpret%2Fmono_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75ea7c7fc27e2ca306d7a5c7b92a2a531b262600/src%2Flibrustc_mir%2Finterpret%2Fmono_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmono_hash_map.rs?ref=75ea7c7fc27e2ca306d7a5c7b92a2a531b262600", "patch": "@@ -1,82 +0,0 @@\n-//! This is a \"monotonic HashMap\": A HashMap that, when shared, can be pushed to but not\n-//! otherwise mutated.  We also Box items in the map. This means we can safely provide\n-//! shared references into existing items in the HashMap, because they will not be dropped\n-//! (from being removed) or moved (because they are boxed).\n-//! The API is is completely tailored to what `memory.rs` needs. It is still in\n-//! a separate file to minimize the amount of code that has to care about the unsafety.\n-\n-use std::collections::hash_map::Entry;\n-use std::cell::RefCell;\n-use std::hash::Hash;\n-use std::borrow::Borrow;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-\n-#[derive(Debug, Clone)]\n-pub struct MonoHashMap<K: Hash + Eq, V>(RefCell<FxHashMap<K, Box<V>>>);\n-\n-impl<K: Hash + Eq, V> Default for MonoHashMap<K, V> {\n-    fn default() -> Self {\n-        MonoHashMap(RefCell::new(Default::default()))\n-    }\n-}\n-\n-impl<K: Hash + Eq, V> MonoHashMap<K, V> {\n-    pub fn contains_key<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> bool\n-        where K: Borrow<Q>\n-    {\n-        self.0.get_mut().contains_key(k)\n-    }\n-\n-    pub fn insert(&mut self, k: K, v: V) -> Option<V>\n-    {\n-        self.0.get_mut().insert(k, Box::new(v)).map(|x| *x)\n-    }\n-\n-    pub fn remove<Q: ?Sized + Hash + Eq>(&mut self, k: &Q) -> Option<V>\n-        where K: Borrow<Q>\n-    {\n-        self.0.get_mut().remove(k).map(|x| *x)\n-    }\n-\n-    pub fn entry(&mut self, k: K) -> Entry<K, Box<V>>\n-    {\n-        self.0.get_mut().entry(k)\n-    }\n-\n-    pub fn filter_map_collect<T>(&self, mut f: impl FnMut(&K, &V) -> Option<T>) -> Vec<T> {\n-        self.0.borrow()\n-            .iter()\n-            .filter_map(move |(k, v)| f(k, &*v))\n-            .collect()\n-    }\n-\n-    /// The most interesting method: Providing a shared ref without\n-    /// holding the `RefCell` open, and inserting new data if the key\n-    /// is not used yet.\n-    /// `vacant` is called if the key is not found in the map;\n-    /// if it returns a reference, that is used directly, if it\n-    /// returns owned data, that is put into the map and returned.\n-    pub fn get_or<E>(\n-        &self,\n-        k: K,\n-        vacant: impl FnOnce() -> Result<V, E>\n-    ) -> Result<&V, E> {\n-        let val: *const V = match self.0.borrow_mut().entry(k) {\n-            Entry::Occupied(entry) => &**entry.get(),\n-            Entry::Vacant(entry) => &**entry.insert(Box::new(vacant()?)),\n-        };\n-        // This is safe because `val` points into a `Box`, that we know will not move and\n-        // will also not be dropped as long as the shared reference `self` is live.\n-        unsafe { Ok(&*val) }\n-    }\n-\n-    pub fn get<Q: ?Sized + Hash + Eq>(&self, k: &Q) -> Option<&V>\n-        where K: Borrow<Q>\n-    {\n-        let val: *const V = &**self.0.borrow().get(k)?;\n-        // This is safe because `val` points into a `Box`, that we know will not move and\n-        // will also not be dropped as long as the shared reference `self` is live.\n-        unsafe { Some(&*val) }\n-    }\n-}"}, {"sha": "8b9c6a5a270537fdaec0cff1e9e4c4c711ccf876", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83667d64a2ae9c85722930f02d05e7b2efa8d853/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=83667d64a2ae9c85722930f02d05e7b2efa8d853", "patch": "@@ -20,9 +20,12 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout};\n \n use rustc::mir::interpret::{\n-    GlobalId, AllocId, Scalar, EvalResult, Pointer, PointerArithmetic\n+    GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic\n+};\n+use super::{\n+    EvalContext, Machine, AllocMap,\n+    Value, ValTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n };\n-use super::{EvalContext, Machine, Value, ValTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind};\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub struct MemPlace<Tag=(), Id=AllocId> {\n@@ -266,12 +269,11 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl\n-    <'a, 'mir, 'tcx,\n-        Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n-        M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>\n-    >\n-    EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, Tag, M> EvalContext<'a, 'mir, 'tcx, M>\n+where\n+    Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag>)>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`."}]}