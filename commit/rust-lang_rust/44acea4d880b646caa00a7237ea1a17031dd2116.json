{"sha": "44acea4d880b646caa00a7237ea1a17031dd2116", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0YWNlYTRkODgwYjY0NmNhYTAwYTcyMzdlYTFhMTcwMzFkZDIxMTY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-01T18:48:39Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-12T20:02:09Z"}, "message": "AST/HIR: Merge field access expressions for named and numeric fields", "tree": {"sha": "f109f2beda49e7972c2c6e562944c1a2c810c3d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f109f2beda49e7972c2c6e562944c1a2c810c3d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44acea4d880b646caa00a7237ea1a17031dd2116", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44acea4d880b646caa00a7237ea1a17031dd2116", "html_url": "https://github.com/rust-lang/rust/commit/44acea4d880b646caa00a7237ea1a17031dd2116", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44acea4d880b646caa00a7237ea1a17031dd2116/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c537493d01694cc6e0a614dff12c475055aa2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c537493d01694cc6e0a614dff12c475055aa2b4", "html_url": "https://github.com/rust-lang/rust/commit/6c537493d01694cc6e0a614dff12c475055aa2b4"}], "stats": {"total": 537, "additions": 105, "deletions": 432}, "files": [{"sha": "118125a19ddef673865af95fe944f6039a2b28d3", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -389,7 +389,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprType(ref e, _) |\n             hir::ExprUnary(_, ref e) |\n             hir::ExprField(ref e, _) |\n-            hir::ExprTupField(ref e, _) |\n             hir::ExprYield(ref e) |\n             hir::ExprRepeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())"}, {"sha": "0a7f0e4dc4c6cebf9348c61dda2c15ac5b2cb4d5", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1025,9 +1025,6 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_name(name.span, name.node);\n         }\n-        ExprTupField(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n         ExprIndex(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)"}, {"sha": "262c307feedcd91d3453fdc693c651f45ed7c265", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -3095,7 +3095,6 @@ impl<'a> LoweringContext<'a> {\n                 P(self.lower_expr(el)),\n                 respan(ident.span, self.lower_ident(ident)),\n             ),\n-            ExprKind::TupField(ref el, ident) => hir::ExprTupField(P(self.lower_expr(el)), ident),\n             ExprKind::Index(ref el, ref er) => {\n                 hir::ExprIndex(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }"}, {"sha": "79b39be3eb20885a7e95e7bd4fa8c22e55eebeea", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1276,7 +1276,6 @@ impl Expr {\n             ExprAssign(..) => ExprPrecedence::Assign,\n             ExprAssignOp(..) => ExprPrecedence::AssignOp,\n             ExprField(..) => ExprPrecedence::Field,\n-            ExprTupField(..) => ExprPrecedence::TupField,\n             ExprIndex(..) => ExprPrecedence::Index,\n             ExprPath(..) => ExprPrecedence::Path,\n             ExprAddrOf(..) => ExprPrecedence::AddrOf,\n@@ -1363,12 +1362,8 @@ pub enum Expr_ {\n     ///\n     /// For example, `a += 1`.\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named struct field (`obj.foo`)\n+    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct or tuple field\n     ExprField(P<Expr>, Spanned<Name>),\n-    /// Access of an unnamed field of a struct or tuple-struct\n-    ///\n-    /// For example, `foo.0`.\n-    ExprTupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n "}, {"sha": "d3f2458ef87c7d2667d35946379b7aacfce9ec34", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1201,8 +1201,7 @@ impl<'a> State<'a> {\n     fn print_expr_call(&mut self, func: &hir::Expr, args: &[hir::Expr]) -> io::Result<()> {\n         let prec =\n             match func.node {\n-                hir::ExprField(..) |\n-                hir::ExprTupField(..) => parser::PREC_FORCE_PAREN,\n+                hir::ExprField(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n \n@@ -1405,11 +1404,6 @@ impl<'a> State<'a> {\n                 self.s.word(\".\")?;\n                 self.print_name(name.node)?;\n             }\n-            hir::ExprTupField(ref expr, id) => {\n-                self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n-                self.s.word(\".\")?;\n-                self.print_usize(id.node)?;\n-            }\n             hir::ExprIndex(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(&expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;\n@@ -2376,7 +2370,6 @@ fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n         hir::ExprCast(ref x, _) |\n         hir::ExprType(ref x, _) |\n         hir::ExprField(ref x, _) |\n-        hir::ExprTupField(ref x, _) |\n         hir::ExprIndex(ref x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)"}, {"sha": "ec573e3d681055b062d78a6a3c75726648ed4d7b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -569,7 +569,6 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprAssign(lhs, rhs),\n     ExprAssignOp(op, lhs, rhs),\n     ExprField(owner, field_name),\n-    ExprTupField(owner, idx),\n     ExprIndex(lhs, rhs),\n     ExprPath(path),\n     ExprAddrOf(mutability, sub),"}, {"sha": "5800988344ad0e52068f895c7e0cabc19796e0f2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -104,17 +104,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n             ty::TyAdt(def, _) => {\n                 self.insert_def_id(def.non_enum_variant().field_named(name).did);\n             }\n-            _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n-        }\n-    }\n-\n-    fn handle_tup_field_access(&mut self, lhs: &hir::Expr, idx: usize) {\n-        match self.tables.expr_ty_adjusted(lhs).sty {\n-            ty::TyAdt(def, _) => {\n-                self.insert_def_id(def.non_enum_variant().fields[idx].did);\n-            }\n             ty::TyTuple(..) => {}\n-            _ => span_bug!(lhs.span, \"numeric field access on non-ADT\"),\n+            _ => span_bug!(lhs.span, \"named field access on non-ADT\"),\n         }\n     }\n \n@@ -245,9 +236,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::ExprField(ref lhs, ref name) => {\n                 self.handle_field_access(&lhs, name.node);\n             }\n-            hir::ExprTupField(ref lhs, idx) => {\n-                self.handle_tup_field_access(&lhs, idx.node);\n-            }\n             hir::ExprStruct(_, ref fields, _) => {\n                 if let ty::TypeVariants::TyAdt(ref def, _) = self.tables.expr_ty(expr).sty {\n                     if def.is_union() {"}, {"sha": "fb83e563ffcd28e5488ff826589aba7bb410586c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -404,10 +404,6 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.select_from_expr(&base);\n             }\n \n-            hir::ExprTupField(ref base, _) => {         // base.<n>\n-                self.select_from_expr(&base);\n-            }\n-\n             hir::ExprIndex(ref lhs, ref rhs) => {       // lhs[rhs]\n                 self.select_from_expr(&lhs);\n                 self.consume_expr(&rhs);"}, {"sha": "11dc2a8188505119ac6a3a4d9ca58ec7ffff00ce", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -476,7 +476,7 @@ fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n       }\n \n       // otherwise, live nodes are not required:\n-      hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n+      hir::ExprIndex(..) | hir::ExprField(..) |\n       hir::ExprArray(..) | hir::ExprCall(..) | hir::ExprMethodCall(..) |\n       hir::ExprTup(..) | hir::ExprBinary(..) | hir::ExprAddrOf(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprBreak(..) |\n@@ -912,10 +912,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprTupField(ref e, _) => {\n-              self.propagate_through_expr(&e, succ)\n-          }\n-\n           hir::ExprClosure(.., blk_id, _, _) => {\n               debug!(\"{} is an ExprClosure\", self.ir.tcx.hir.node_to_pretty_string(expr.id));\n \n@@ -1226,7 +1222,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n             hir::ExprPath(_) => succ,\n             hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n-            hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n         }\n     }\n@@ -1419,7 +1414,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n       // no correctness conditions related to liveness\n       hir::ExprCall(..) | hir::ExprMethodCall(..) | hir::ExprIf(..) |\n       hir::ExprMatch(..) | hir::ExprWhile(..) | hir::ExprLoop(..) |\n-      hir::ExprIndex(..) | hir::ExprField(..) | hir::ExprTupField(..) |\n+      hir::ExprIndex(..) | hir::ExprField(..) |\n       hir::ExprArray(..) | hir::ExprTup(..) | hir::ExprBinary(..) |\n       hir::ExprCast(..) | hir::ExprUnary(..) | hir::ExprRet(..) |\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |"}, {"sha": "c7449325f756166d142b1a9fd22f90a1a8d844de", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 51, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -62,7 +62,6 @@\n \n pub use self::PointerKind::*;\n pub use self::InteriorKind::*;\n-pub use self::FieldName::*;\n pub use self::MutabilityCategory::*;\n pub use self::AliasableReason::*;\n pub use self::Note::*;\n@@ -81,7 +80,7 @@ use ty::fold::TypeFoldable;\n use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n use hir;\n-use syntax::ast;\n+use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n use std::fmt;\n@@ -129,15 +128,13 @@ pub enum PointerKind<'tcx> {\n // base without a pointer dereference\", e.g. a field\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n-    InteriorField(FieldName),\n+    InteriorField(FieldIndex),\n     InteriorElement(InteriorOffsetKind),\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n-pub enum FieldName {\n-    NamedField(ast::Name),\n-    PositionalField(usize)\n-}\n+// FIXME: Use actual index instead of `ast::Name` with questionable hygiene\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FieldIndex(pub ast::Name);\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum InteriorOffsetKind {\n@@ -198,7 +195,7 @@ pub enum ImmutabilityBlame<'tcx> {\n }\n \n impl<'tcx> cmt_<'tcx> {\n-    fn resolve_field(&self, field_name: FieldName) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n+    fn resolve_field(&self, field_name: Name) -> Option<(&'tcx ty::AdtDef, &'tcx ty::FieldDef)>\n     {\n         let adt_def = match self.ty.sty {\n             ty::TyAdt(def, _) => def,\n@@ -215,11 +212,7 @@ impl<'tcx> cmt_<'tcx> {\n                 &adt_def.variants[0]\n             }\n         };\n-        let field_def = match field_name {\n-            NamedField(name) => variant_def.field_named(name),\n-            PositionalField(idx) => &variant_def.fields[idx]\n-        };\n-        Some((adt_def, field_def))\n+        Some((adt_def, variant_def.field_named(field_name)))\n     }\n \n     pub fn immutability_blame(&self) -> Option<ImmutabilityBlame<'tcx>> {\n@@ -230,8 +223,8 @@ impl<'tcx> cmt_<'tcx> {\n                 match base_cmt.cat {\n                     Categorization::Local(node_id) =>\n                         Some(ImmutabilityBlame::LocalDeref(node_id)),\n-                    Categorization::Interior(ref base_cmt, InteriorField(field_name)) => {\n-                        base_cmt.resolve_field(field_name).map(|(adt_def, field_def)| {\n+                    Categorization::Interior(ref base_cmt, InteriorField(field_index)) => {\n+                        base_cmt.resolve_field(field_index.0).map(|(adt_def, field_def)| {\n                             ImmutabilityBlame::AdtFieldDeref(adt_def, field_def)\n                         })\n                     }\n@@ -649,11 +642,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             Ok(self.cat_field(expr, base_cmt, f_name.node, expr_ty))\n           }\n \n-          hir::ExprTupField(ref base, idx) => {\n-            let base_cmt = self.cat_expr(&base)?;\n-            Ok(self.cat_tup_field(expr, base_cmt, idx.node, expr_ty))\n-          }\n-\n           hir::ExprIndex(ref base, _) => {\n             if self.tables.is_method_call(expr) {\n                 // If this is an index implemented by a method call, then it\n@@ -979,39 +967,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt<'tcx>,\n-                                 f_name: ast::Name,\n+                                 f_name: Name,\n                                  f_ty: Ty<'tcx>)\n                                  -> cmt<'tcx> {\n         let ret = Rc::new(cmt_ {\n             id: node.id(),\n             span: node.span(),\n             mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, InteriorField(NamedField(f_name))),\n+            cat: Categorization::Interior(base_cmt, InteriorField(FieldIndex(f_name))),\n             ty: f_ty,\n             note: NoteNone\n         });\n         debug!(\"cat_field ret {:?}\", ret);\n         ret\n     }\n \n-    pub fn cat_tup_field<N:ast_node>(&self,\n-                                     node: &N,\n-                                     base_cmt: cmt<'tcx>,\n-                                     f_idx: usize,\n-                                     f_ty: Ty<'tcx>)\n-                                     -> cmt<'tcx> {\n-        let ret = Rc::new(cmt_ {\n-            id: node.id(),\n-            span: node.span(),\n-            mutbl: base_cmt.mutbl.inherit(),\n-            cat: Categorization::Interior(base_cmt, InteriorField(PositionalField(f_idx))),\n-            ty: f_ty,\n-            note: NoteNone\n-        });\n-        debug!(\"cat_tup_field ret {:?}\", ret);\n-        ret\n-    }\n-\n     fn cat_overloaded_place(&self,\n                              expr: &hir::Expr,\n                              base: &hir::Expr,\n@@ -1292,8 +1262,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n-                                                   InteriorField(PositionalField(i)));\n+                let interior = InteriorField(FieldIndex(Name::intern(&i.to_string())));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1332,8 +1302,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(expected_len, ddpos) {\n                 let subpat_ty = self.pat_ty(&subpat)?; // see (*2)\n-                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty,\n-                                                   InteriorField(PositionalField(i)));\n+                let interior = InteriorField(FieldIndex(Name::intern(&i.to_string())));\n+                let subcmt = self.cat_imm_interior(pat, cmt.clone(), subpat_ty, interior);\n                 self.cat_pattern_(subcmt, &subpat, op)?;\n             }\n           }\n@@ -1516,12 +1486,9 @@ impl<'tcx> cmt_<'tcx> {\n                     }\n                 }\n             }\n-            Categorization::Interior(_, InteriorField(NamedField(_))) => {\n+            Categorization::Interior(_, InteriorField(..)) => {\n                 \"field\".to_string()\n             }\n-            Categorization::Interior(_, InteriorField(PositionalField(_))) => {\n-                \"anonymous field\".to_string()\n-            }\n             Categorization::Interior(_, InteriorElement(InteriorOffsetKind::Index)) => {\n                 \"indexed content\".to_string()\n             }\n@@ -1554,8 +1521,7 @@ pub fn ptr_sigil(ptr: PointerKind) -> &'static str {\n impl fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(NamedField(fld)) => write!(f, \"{}\", fld),\n-            InteriorField(PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorField(FieldIndex(name)) => write!(f, \"{}\", name),\n             InteriorElement(..) => write!(f, \"[]\"),\n         }\n     }"}, {"sha": "42483c83f4ba27f4b277133da09ba329bb7dd2ab", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1307,7 +1307,6 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                 hir::ExprAddrOf(_, ref subexpr) |\n                 hir::ExprUnary(hir::UnDeref, ref subexpr) |\n                 hir::ExprField(ref subexpr, _) |\n-                hir::ExprTupField(ref subexpr, _) |\n                 hir::ExprIndex(ref subexpr, _) => {\n                     expr = &subexpr;\n                 }"}, {"sha": "2bd40890ca3a409d66f5ed73c35491b4d124f2d6", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                         RestrictionResult::Safe => RestrictionResult::Safe,\n                         RestrictionResult::SafeIf(base_lp, mut base_vec) => {\n                             for field in &adt_def.non_enum_variant().fields {\n-                                let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                                let field = InteriorKind::InteriorField(mc::FieldIndex(field.name));\n                                 let field_ty = if field == interior {\n                                     cmt.ty\n                                 } else {"}, {"sha": "12c5fcdf13df26dc08e595596280141e5f060541", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -370,7 +370,7 @@ const DOWNCAST_PRINTED_OPERATOR: &'static str = \" as \";\n // is tracked is irrelevant here.)\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n pub enum InteriorKind {\n-    InteriorField(mc::FieldName),\n+    InteriorField(mc::FieldIndex),\n     InteriorElement,\n }\n \n@@ -1336,18 +1336,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push(')');\n             }\n \n-            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(fname))) => {\n+            LpExtend(ref lp_base, _, LpInterior(_, InteriorField(mc::FieldIndex(fname)))) => {\n                 self.append_autoderefd_loan_path_to_string(&lp_base, out);\n-                match fname {\n-                    mc::NamedField(fname) => {\n-                        out.push('.');\n-                        out.push_str(&fname.as_str());\n-                    }\n-                    mc::PositionalField(idx) => {\n-                        out.push('.');\n-                        out.push_str(&idx.to_string());\n-                    }\n-                }\n+                out.push('.');\n+                out.push_str(&fname.as_str());\n             }\n \n             LpExtend(ref lp_base, _, LpInterior(_, InteriorElement)) => {\n@@ -1422,8 +1414,7 @@ impl DataFlowOperator for LoanDataFlowOperator {\n impl<'tcx> fmt::Debug for InteriorKind {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            InteriorField(mc::NamedField(fld)) => write!(f, \"{}\", fld),\n-            InteriorField(mc::PositionalField(i)) => write!(f, \"#{}\", i),\n+            InteriorField(mc::FieldIndex(name)) => write!(f, \"{}\", name),\n             InteriorElement => write!(f, \"[]\"),\n         }\n     }"}, {"sha": "a69b9dc0d4f5209f40bd58b3c2bad28846a50d35", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -21,7 +21,6 @@ use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::expr_use_visitor::MutateMode;\n-use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -344,7 +343,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n                     = (&base_lp.ty.sty, lp_elem) {\n                 if adt_def.is_union() {\n                     for field in &adt_def.non_enum_variant().fields {\n-                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                        let field = InteriorKind::InteriorField(mc::FieldIndex(field.name));\n                         if field != interior {\n                             let sibling_lp_kind =\n                                 LpExtend(base_lp.clone(), mutbl, LpInterior(opt_variant_id, field));\n@@ -396,7 +395,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             if let ty::TyAdt(adt_def, _) = base_lp.ty.sty {\n                 if adt_def.is_union() {\n                     for field in &adt_def.non_enum_variant().fields {\n-                        let field = InteriorKind::InteriorField(mc::NamedField(field.name));\n+                        let field = InteriorKind::InteriorField(mc::FieldIndex(field.name));\n                         let field_ty = if field == interior {\n                             lp.ty\n                         } else {"}, {"sha": "efe88c6789ff5dbc68a3279b3efd54fa45078c16", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -584,6 +584,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprField(ref source, name) => {\n             let index = match cx.tables().expr_ty_adjusted(source).sty {\n                 ty::TyAdt(adt_def, _) => adt_def.variants[0].index_of_field_named(name.node),\n+                ty::TyTuple(..) => name.node.as_str().parse::<usize>().ok(),\n                 ref ty => span_bug!(expr.span, \"field of non-ADT: {:?}\", ty),\n             };\n             let index =\n@@ -595,12 +596,6 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 name: Field::new(index),\n             }\n         }\n-        hir::ExprTupField(ref source, index) => {\n-            ExprKind::Field {\n-                lhs: source.to_ref(),\n-                name: Field::new(index.node as usize),\n-            }\n-        }\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op)."}, {"sha": "c5d2f0041a0f2867b9aa41c4e2a92a20238e04f4", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -407,7 +407,6 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         hir::ExprBlock(_) |\n         hir::ExprIndex(..) |\n         hir::ExprField(..) |\n-        hir::ExprTupField(..) |\n         hir::ExprArray(_) |\n         hir::ExprType(..) |\n         hir::ExprTup(..) => {}"}, {"sha": "811ebe576694971810b876e76a48d2e386164b25", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -25,7 +25,6 @@\n \n use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map::Node;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n@@ -1638,52 +1637,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     }\n                 }\n             }\n-            ast::ExprKind::TupField(ref sub_ex, idx) => {\n-                self.visit_expr(&sub_ex);\n-\n-                let hir_node = match self.save_ctxt.tcx.hir.find(sub_ex.id) {\n-                    Some(Node::NodeExpr(expr)) => expr,\n-                    _ => {\n-                        debug!(\n-                            \"Missing or weird node for sub-expression {} in {:?}\",\n-                            sub_ex.id,\n-                            ex\n-                        );\n-                        return;\n-                    }\n-                };\n-                let ty = match self.save_ctxt.tables.expr_ty_adjusted_opt(&hir_node) {\n-                    Some(ty) => &ty.sty,\n-                    None => {\n-                        visit::walk_expr(self, ex);\n-                        return;\n-                    }\n-                };\n-                match *ty {\n-                    ty::TyAdt(def, _) => {\n-                        let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                        if !self.span.filter_generated(sub_span, ex.span) {\n-                            let span =\n-                                self.span_from_span(sub_span.expect(\"No span found for var ref\"));\n-                            if let Some(field) = def.non_enum_variant().fields.get(idx.node) {\n-                                let ref_id = ::id_from_def_id(field.did);\n-                                self.dumper.dump_ref(Ref {\n-                                    kind: RefKind::Variable,\n-                                    span,\n-                                    ref_id,\n-                                });\n-                            } else {\n-                                return;\n-                            }\n-                        }\n-                    }\n-                    ty::TyTuple(..) => {}\n-                    _ => {\n-                        debug!(\"Expected struct or tuple type, found {:?}\", ty);\n-                        return;\n-                    }\n-                }\n-            }\n             ast::ExprKind::Closure(_, _, ref decl, ref body, _fn_decl_span) => {\n                 let mut id = String::from(\"$\");\n                 id.push_str(&ex.id.to_string());"}, {"sha": "9da692851d9d830375c23009a2d65791602359da", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -563,6 +563,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             ref_id: id_from_def_id(f.did),\n                         }));\n                     }\n+                    ty::TyTuple(..) => None,\n                     _ => {\n                         debug!(\"Expected struct or union type, found {:?}\", ty);\n                         None"}, {"sha": "4d93e81a78fa128b09bb66cb10d594ff203b6976", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -202,10 +202,6 @@ impl<'a> SpanUtils<'a> {\n         self.sub_span_after(span, |t| t.is_keyword(keyword))\n     }\n \n-    pub fn sub_span_after_token(&self, span: Span, tok: Token) -> Option<Span> {\n-        self.sub_span_after(span, |t| t == tok)\n-    }\n-\n     fn sub_span_after<F: Fn(Token) -> bool>(&self, span: Span, f: F) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {"}, {"sha": "7569bdccd5a107a1e26edf416730a749df866014", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -433,7 +433,6 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let last = exprs[exprs.len() - 1];\n             match last.node {\n                 hir::ExprField(ref expr, _) |\n-                hir::ExprTupField(ref expr, _) |\n                 hir::ExprIndex(ref expr, _) |\n                 hir::ExprUnary(hir::UnDeref, ref expr) => exprs.push(&expr),\n                 _ => break,"}, {"sha": "9d0e0191ffba3bd81c13cde586884b714adacd32", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 78, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -85,7 +85,7 @@ use self::method::MethodCallee;\n use self::TupleArgumentsFlag::*;\n \n use astconv::AstConv;\n-use hir::def::{Def, CtorKind};\n+use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use std::slice;\n use namespace::Namespace;\n@@ -121,7 +121,7 @@ use std::ops::{self, Deref};\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n-use syntax::codemap::{self, original_sp, Spanned};\n+use syntax::codemap::{original_sp, Spanned};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, InternedString, keywords};\n@@ -2266,7 +2266,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             hir::ExprUnary(hir::UnDeref, _) |\n             hir::ExprField(..) |\n-            hir::ExprTupField(..) |\n             hir::ExprIndex(..) => {\n                 true\n             }\n@@ -3084,6 +3083,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n                 }\n+                ty::TyTuple(ref tys) => {\n+                    let fstr = field.node.as_str();\n+                    if let Ok(index) = fstr.parse::<usize>() {\n+                        if fstr == index.to_string() {\n+                            if let Some(field_ty) = tys.get(index) {\n+                                let adjustments = autoderef.adjust_steps(needs);\n+                                self.apply_adjustments(base, adjustments);\n+                                autoderef.finalize();\n+\n+                                return field_ty;\n+                            }\n+                        }\n+                    }\n+                }\n                 _ => {}\n             }\n         }\n@@ -3189,78 +3202,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         display\n     }\n \n-    // Check tuple index expressions\n-    fn check_tup_field(&self,\n-                       expr: &'gcx hir::Expr,\n-                       needs: Needs,\n-                       base: &'gcx hir::Expr,\n-                       idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_needs(base, needs);\n-        let expr_t = self.structurally_resolved_type(expr.span,\n-                                                     expr_t);\n-        let mut private_candidate = None;\n-        let mut tuple_like = false;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            let field = match base_t.sty {\n-                ty::TyAdt(base_def, substs) if base_def.is_struct() => {\n-                    tuple_like = base_def.non_enum_variant().ctor_kind == CtorKind::Fn;\n-                    if !tuple_like { continue }\n-\n-                    debug!(\"tuple struct named {:?}\",  base_t);\n-                    let ident =\n-                        ast::Ident::new(Symbol::intern(&idx.node.to_string()), idx.span.modern());\n-                    let (ident, def_scope) =\n-                        self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n-                    let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n-                        let field_ty = self.field_ty(expr.span, field, substs);\n-                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            self.tcx.check_stability(field.did, Some(expr.id), expr.span);\n-                            Some(field_ty)\n-                        } else {\n-                            private_candidate = Some((base_def.did, field_ty));\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                }\n-                ty::TyTuple(ref v) => {\n-                    tuple_like = true;\n-                    v.get(idx.node).cloned()\n-                }\n-                _ => continue\n-            };\n-\n-            if let Some(field_ty) = field {\n-                let adjustments = autoderef.adjust_steps(needs);\n-                self.apply_adjustments(base, adjustments);\n-                autoderef.finalize();\n-                return field_ty;\n-            }\n-        }\n-        autoderef.unambiguous_final_ty();\n-\n-        if let Some((did, field_ty)) = private_candidate {\n-            let struct_path = self.tcx().item_path_str(did);\n-            struct_span_err!(self.tcx().sess, expr.span, E0611,\n-                             \"field `{}` of tuple-struct `{}` is private\",\n-                             idx.node, struct_path).emit();\n-            return field_ty;\n-        }\n-\n-        if tuple_like {\n-            type_error_struct!(self.tcx().sess, expr.span, expr_t, E0612,\n-                \"attempted out-of-bounds tuple index `{}` on type `{}`\",\n-                idx.node, expr_t).emit();\n-        } else {\n-            self.no_such_field_err(expr.span, idx.node, expr_t).emit();\n-        }\n-\n-        self.tcx().types.err\n-    }\n-\n     fn no_such_field_err<T: Display>(&self, span: Span, field: T, expr_t: &ty::TyS)\n         -> DiagnosticBuilder {\n         type_error_struct!(self.tcx().sess, span, expr_t, E0609,\n@@ -4121,9 +4062,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprField(ref base, ref field) => {\n             self.check_field(expr, needs, &base, field)\n           }\n-          hir::ExprTupField(ref base, idx) => {\n-            self.check_tup_field(expr, needs, &base, idx)\n-          }\n           hir::ExprIndex(ref base, ref idx) => {\n               let base_t = self.check_expr_with_needs(&base, needs);\n               let idx_t = self.check_expr(&idx);"}, {"sha": "946fbfd82a48adda41baa3b107190fd0c9e67d89", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 80, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -4138,86 +4138,6 @@ https://doc.rust-lang.org/book/first-edition/primitive-types.html\n https://doc.rust-lang.org/book/first-edition/structs.html\n \"##,\n \n-E0611: r##\"\n-Attempted to access a private field on a tuple-struct.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0611\n-mod some_module {\n-    pub struct Foo(u32);\n-\n-    impl Foo {\n-        pub fn new() -> Foo { Foo(0) }\n-    }\n-}\n-\n-let y = some_module::Foo::new();\n-println!(\"{}\", y.0); // error: field `0` of tuple-struct `some_module::Foo`\n-                     //        is private\n-```\n-\n-Since the field is private, you have two solutions:\n-\n-1) Make the field public:\n-\n-```\n-mod some_module {\n-    pub struct Foo(pub u32); // The field is now public.\n-\n-    impl Foo {\n-        pub fn new() -> Foo { Foo(0) }\n-    }\n-}\n-\n-let y = some_module::Foo::new();\n-println!(\"{}\", y.0); // So we can access it directly.\n-```\n-\n-2) Add a getter function to keep the field private but allow for accessing its\n-value:\n-\n-```\n-mod some_module {\n-    pub struct Foo(u32);\n-\n-    impl Foo {\n-        pub fn new() -> Foo { Foo(0) }\n-\n-        // We add the getter function.\n-        pub fn get(&self) -> &u32 { &self.0 }\n-    }\n-}\n-\n-let y = some_module::Foo::new();\n-println!(\"{}\", y.get()); // So we can get the value through the function.\n-```\n-\"##,\n-\n-E0612: r##\"\n-Attempted out-of-bounds tuple index.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0612\n-struct Foo(u32);\n-\n-let y = Foo(0);\n-println!(\"{}\", y.1); // error: attempted out-of-bounds tuple index `1`\n-                     //        on type `Foo`\n-```\n-\n-If a tuple/tuple-struct type has n fields, you can only try to access these n\n-fields from 0 to (n - 1). So in this case, you can only index `0`. Example:\n-\n-```\n-struct Foo(u32);\n-\n-let y = Foo(0);\n-println!(\"{}\", y.0); // ok!\n-```\n-\"##,\n-\n E0614: r##\"\n Attempted to dereference a variable which cannot be dereferenced.\n \n@@ -4839,6 +4759,8 @@ register_diagnostics! {\n     E0587, // type has conflicting packed and align representation hints\n     E0588, // packed type cannot transitively contain a `[repr(align)]` type\n     E0592, // duplicate definitions with name `{}`\n+//  E0611, // merged into E0616\n+//  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n     E0640, // infer outlives\n     E0627, // yield statement outside of generator literal"}, {"sha": "91c9a1524e1442274235a80e90a0533abe67fa32", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1018,7 +1018,6 @@ impl Expr {\n             ExprKind::Assign(..) => ExprPrecedence::Assign,\n             ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n             ExprKind::Field(..) => ExprPrecedence::Field,\n-            ExprKind::TupField(..) => ExprPrecedence::TupField,\n             ExprKind::Index(..) => ExprPrecedence::Index,\n             ExprKind::Range(..) => ExprPrecedence::Range,\n             ExprKind::Path(..) => ExprPrecedence::Path,\n@@ -1133,12 +1132,8 @@ pub enum ExprKind {\n     ///\n     /// For example, `a += 1`.\n     AssignOp(BinOp, P<Expr>, P<Expr>),\n-    /// Access of a named struct field (`obj.foo`)\n+    /// Access of a named (`obj.foo`) or unnamed (`obj.0`) struct field\n     Field(P<Expr>, Ident),\n-    /// Access of an unnamed field of a struct or tuple-struct\n-    ///\n-    /// For example, `foo.0`.\n-    TupField(P<Expr>, Spanned<usize>),\n     /// An indexing operation (`foo[2]`)\n     Index(P<Expr>, P<Expr>),\n     /// A range (`1..2`, `1..`, `..2`, `1...2`, `1...`, `...2`)"}, {"sha": "2e1a4ee5851572df0a946b7fd177dbbb797da394", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -636,8 +636,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Field(expr, ident.with_span_pos(sp)))\n     }\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n-        let id = Spanned { node: idx, span: sp };\n-        self.expr(sp, ast::ExprKind::TupField(expr, id))\n+        let id = Spanned { node: Ident::from_str(&idx.to_string()), span: sp };\n+        self.expr(sp, ast::ExprKind::Field(expr, id))\n     }\n     fn expr_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprKind::AddrOf(ast::Mutability::Immutable, e))"}, {"sha": "a0cd831a9ba080cb5ae532fa869c0ec9e0739036", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1267,11 +1267,6 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n             ExprKind::Field(el, ident) => {\n                 ExprKind::Field(folder.fold_expr(el), folder.fold_ident(ident))\n             }\n-            ExprKind::TupField(el, index) => {\n-                ExprKind::TupField(folder.fold_expr(el),\n-                             respan(folder.new_span(index.span),\n-                                    folder.fold_usize(index.node)))\n-            }\n             ExprKind::Index(el, er) => {\n                 ExprKind::Index(folder.fold_expr(el), folder.fold_expr(er))\n             }"}, {"sha": "33a602a26fcf75f533f25921878cedcc2e44487c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -2144,10 +2144,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn mk_tup_field(&mut self, expr: P<Expr>, idx: codemap::Spanned<usize>) -> ast::ExprKind {\n-        ExprKind::TupField(expr, idx)\n-    }\n-\n     pub fn mk_assign_op(&mut self, binop: ast::BinOp,\n                         lhs: P<Expr>, rhs: P<Expr>) -> ast::ExprKind {\n         ExprKind::AssignOp(binop, lhs, rhs)\n@@ -2605,35 +2601,12 @@ impl<'a> Parser<'a> {\n                   token::Ident(..) => {\n                     e = self.parse_dot_suffix(e, lo)?;\n                   }\n-                  token::Literal(token::Integer(index_ident), suf) => {\n-                    let sp = self.span;\n-\n-                    // A tuple index may not have a suffix\n-                    self.expect_no_suffix(sp, \"tuple index\", suf);\n-\n-                    let idx_span = self.span;\n+                  token::Literal(token::Integer(name), _) => {\n+                    let span = self.span;\n                     self.bump();\n-\n-                    let invalid_msg = \"invalid tuple or struct index\";\n-\n-                    let index = index_ident.as_str().parse::<usize>().ok();\n-                    match index {\n-                        Some(n) => {\n-                            if n.to_string() != index_ident.as_str() {\n-                                let mut err = self.struct_span_err(self.prev_span, invalid_msg);\n-                                err.span_suggestion(self.prev_span,\n-                                                    \"try simplifying the index\",\n-                                                    n.to_string());\n-                                err.emit();\n-                            }\n-                            let field = self.mk_tup_field(e, respan(idx_span, n));\n-                            e = self.mk_expr(lo.to(idx_span), field, ThinVec::new());\n-                        }\n-                        None => {\n-                            let prev_span = self.prev_span;\n-                            self.span_err(prev_span, invalid_msg);\n-                        }\n-                    }\n+                    let ident = Ident { name, ctxt: span.ctxt() };\n+                    let field = ExprKind::Field(e, respan(span, ident));\n+                    e = self.mk_expr(lo.to(span), field, ThinVec::new());\n                   }\n                   token::Literal(token::Float(n), _suf) => {\n                     self.bump();"}, {"sha": "3741850b8a974a7e78fac7583a9b94efd9d712b4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1966,8 +1966,7 @@ impl<'a> State<'a> {\n                        args: &[P<ast::Expr>]) -> io::Result<()> {\n         let prec =\n             match func.node {\n-                ast::ExprKind::Field(..) |\n-                ast::ExprKind::TupField(..) => parser::PREC_FORCE_PAREN,\n+                ast::ExprKind::Field(..) => parser::PREC_FORCE_PAREN,\n                 _ => parser::PREC_POSTFIX,\n             };\n \n@@ -2203,11 +2202,6 @@ impl<'a> State<'a> {\n                 self.s.word(\".\")?;\n                 self.print_ident(ident)?;\n             }\n-            ast::ExprKind::TupField(ref expr, id) => {\n-                self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n-                self.s.word(\".\")?;\n-                self.print_usize(id.node)?;\n-            }\n             ast::ExprKind::Index(ref expr, ref index) => {\n                 self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n                 self.s.word(\"[\")?;"}, {"sha": "524f9f127f57b1abbd60a796fe8143a7916cdcee", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -251,7 +251,6 @@ pub enum ExprPrecedence {\n     Call,\n     MethodCall,\n     Field,\n-    TupField,\n     Index,\n     Try,\n     InlineAsm,\n@@ -320,7 +319,6 @@ impl ExprPrecedence {\n             ExprPrecedence::Call |\n             ExprPrecedence::MethodCall |\n             ExprPrecedence::Field |\n-            ExprPrecedence::TupField |\n             ExprPrecedence::Index |\n             ExprPrecedence::Try |\n             ExprPrecedence::InlineAsm |\n@@ -365,7 +363,6 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n         ast::ExprKind::Cast(ref x, _) |\n         ast::ExprKind::Type(ref x, _) |\n         ast::ExprKind::Field(ref x, _) |\n-        ast::ExprKind::TupField(ref x, _) |\n         ast::ExprKind::Index(ref x, _) => {\n             // &X { y: 1 }, X { y: 1 }.y\n             contains_exterior_struct_lit(&x)"}, {"sha": "8743840e44393977795ee065a042aa841c848ec2", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -749,9 +749,6 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n             visitor.visit_expr(subexpression);\n             visitor.visit_ident(ident);\n         }\n-        ExprKind::TupField(ref subexpression, _) => {\n-            visitor.visit_expr(subexpression);\n-        }\n         ExprKind::Index(ref main_expression, ref index_expression) => {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)"}, {"sha": "df34aab4b8f6683e6de1c3a64fdaba3585637dbe", "filename": "src/test/compile-fail/issue-19244-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19244-1.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -12,5 +12,5 @@ const TUP: (usize,) = (42,);\n \n fn main() {\n     let a: [isize; TUP.1];\n-    //~^ ERROR attempted out-of-bounds tuple index\n+    //~^ ERROR no field `1` on type `(usize,)`\n }"}, {"sha": "f487ef62aa435d22887b120fc595ceca5fb80436", "filename": "src/test/compile-fail/struct-field-privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-field-privacy.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -42,7 +42,7 @@ fn test(a: A, b: inner::A, c: inner::B, d: xc::A, e: xc::B, z: inner::Z) {\n     e.b; //~ ERROR: field `b` of struct `xc::B` is private\n \n     z.0;\n-    z.1; //~ ERROR: field `1` of tuple-struct `inner::Z` is private\n+    z.1; //~ ERROR: field `1` of struct `inner::Z` is private\n }\n \n fn main() {}"}, {"sha": "35b843676b4f1d79c8e3cc8edc644309e3bba811", "filename": "src/test/compile-fail/tuple-index-out-of-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftuple-index-out-of-bounds.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -15,10 +15,10 @@ fn main() {\n     origin.0;\n     origin.1;\n     origin.2;\n-    //~^ ERROR attempted out-of-bounds tuple index `2` on type `Point`\n+    //~^ ERROR no field `2` on type `Point`\n     let tuple = (0, 0);\n     tuple.0;\n     tuple.1;\n     tuple.2;\n-    //~^ ERROR attempted out-of-bounds tuple index `2` on type `({integer}, {integer})`\n+    //~^ ERROR no field `2` on type `({integer}, {integer})`\n }"}, {"sha": "dd793b29febef4a063f63a5b81d5639c119ca517", "filename": "src/test/ui/error-codes/E0609.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2FE0609.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2FE0609.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0609.stderr?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -7,10 +7,10 @@ LL |     let _ = x.foo; //~ ERROR E0609\n    = note: available fields are: `x`\n \n error[E0609]: no field `1` on type `Bar`\n-  --> $DIR/E0609.rs:21:5\n+  --> $DIR/E0609.rs:21:7\n    |\n LL |     y.1; //~ ERROR E0609\n-   |     ^^^\n+   |       ^ unknown field\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c4b86e76c14e49039e54047e0547d64b9105e0a2", "filename": "src/test/ui/error-codes/E0611.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Ftest%2Fui%2Ferror-codes%2FE0611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Ftest%2Fui%2Ferror-codes%2FE0611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0611.stderr?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -1,9 +0,0 @@\n-error[E0611]: field `0` of tuple-struct `a::Foo` is private\n-  --> $DIR/E0611.rs:21:4\n-   |\n-LL |    y.0; //~ ERROR E0611\n-   |    ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0611`."}, {"sha": "18013697a83384cdd2557a8ebd3a308db63b7b87", "filename": "src/test/ui/error-codes/E0612.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Ftest%2Fui%2Ferror-codes%2FE0612.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c537493d01694cc6e0a614dff12c475055aa2b4/src%2Ftest%2Fui%2Ferror-codes%2FE0612.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0612.stderr?ref=6c537493d01694cc6e0a614dff12c475055aa2b4", "patch": "@@ -1,9 +0,0 @@\n-error[E0612]: attempted out-of-bounds tuple index `1` on type `Foo`\n-  --> $DIR/E0612.rs:15:4\n-   |\n-LL |    y.1; //~ ERROR E0612\n-   |    ^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0612`."}, {"sha": "4e580242e641e4432348c09f597599344be98682", "filename": "src/test/ui/error-codes/ex-E0611.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -18,5 +18,5 @@ mod a {\n \n fn main() {\n    let y = a::Foo::new();\n-   y.0; //~ ERROR E0611\n+   y.0; //~ ERROR field `0` of struct `a::Foo` is private\n }", "previous_filename": "src/test/ui/error-codes/E0611.rs"}, {"sha": "2f5066542db76f9d384947075b268800b50a4d33", "filename": "src/test/ui/error-codes/ex-E0611.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0611.stderr?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -0,0 +1,9 @@\n+error[E0616]: field `0` of struct `a::Foo` is private\n+  --> $DIR/ex-E0611.rs:21:4\n+   |\n+LL |    y.0; //~ ERROR field `0` of struct `a::Foo` is private\n+   |    ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0616`."}, {"sha": "46e26c87e5f340321a00385771fc094f6c2c090d", "filename": "src/test/ui/error-codes/ex-E0612.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -12,5 +12,5 @@ struct Foo(u32);\n \n fn main() {\n    let y = Foo(0);\n-   y.1; //~ ERROR E0612\n+   y.1; //~ ERROR no field `1` on type `Foo`\n }", "previous_filename": "src/test/ui/error-codes/E0612.rs"}, {"sha": "a07efc939ab470d0b7325fbd352ac1fa8287f6dd", "filename": "src/test/ui/error-codes/ex-E0612.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2Fex-E0612.stderr?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -0,0 +1,9 @@\n+error[E0609]: no field `1` on type `Foo`\n+  --> $DIR/ex-E0612.rs:15:6\n+   |\n+LL |    y.1; //~ ERROR no field `1` on type `Foo`\n+   |      ^ did you mean `0`?\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "c59a9bc4170bd51a6691eee676de73a8702f3fea", "filename": "src/test/ui/issue-47073-zero-padded-tuple-struct-indices.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -16,7 +16,7 @@ struct Verdict(Guilty, Option<FineDollars>);\n fn main() {\n     let justice = Verdict(true, Some(2718));\n     let _condemned = justice.00;\n-    //~^ ERROR invalid tuple or struct index\n+    //~^ ERROR no field `00` on type `Verdict`\n     let _punishment = justice.001;\n-    //~^ ERROR invalid tuple or struct index\n+    //~^ ERROR no field `001` on type `Verdict`\n }"}, {"sha": "4a1c9b554a9319adcbecfe5f4584b1e122a72aaa", "filename": "src/test/ui/issue-47073-zero-padded-tuple-struct-indices.stderr", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-47073-zero-padded-tuple-struct-indices.stderr?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -1,14 +1,17 @@\n-error: invalid tuple or struct index\n+error[E0609]: no field `00` on type `Verdict`\n   --> $DIR/issue-47073-zero-padded-tuple-struct-indices.rs:18:30\n    |\n LL |     let _condemned = justice.00;\n-   |                              ^^ help: try simplifying the index: `0`\n+   |                              ^^ did you mean `0`?\n \n-error: invalid tuple or struct index\n+error[E0609]: no field `001` on type `Verdict`\n   --> $DIR/issue-47073-zero-padded-tuple-struct-indices.rs:20:31\n    |\n LL |     let _punishment = justice.001;\n-   |                               ^^^ help: try simplifying the index: `1`\n+   |                               ^^^ unknown field\n+   |\n+   = note: available fields are: `0`, `1`\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0609`."}, {"sha": "bff64ad489210a0f1fd33f55194da91921c86624", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.rs?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -24,7 +24,7 @@ macro_rules! fake_field_stmt {\n \n macro_rules! fake_anon_field_stmt {\n      () => {\n-          (1).0 //~ ERROR no field\n+          (1).0 //~ ERROR doesn't have fields\n      }\n }\n \n@@ -42,7 +42,7 @@ macro_rules! fake_field_expr {\n \n macro_rules! fake_anon_field_expr {\n      () => {\n-          (1).0 //~ ERROR no field\n+          (1).0 //~ ERROR doesn't have fields\n      }\n }\n "}, {"sha": "cb7d422b7f3ed73d3d82339b572cd4fc9dd2cc20", "filename": "src/test/ui/macros/macro-backtrace-invalid-internals.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44acea4d880b646caa00a7237ea1a17031dd2116/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-backtrace-invalid-internals.stderr?ref=44acea4d880b646caa00a7237ea1a17031dd2116", "patch": "@@ -16,11 +16,11 @@ LL |           1.fake //~ ERROR doesn't have fields\n LL |     fake_field_stmt!();\n    |     ------------------- in this macro invocation\n \n-error[E0609]: no field `0` on type `{integer}`\n-  --> $DIR/macro-backtrace-invalid-internals.rs:27:11\n+error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n+  --> $DIR/macro-backtrace-invalid-internals.rs:27:15\n    |\n-LL |           (1).0 //~ ERROR no field\n-   |           ^^^^^\n+LL |           (1).0 //~ ERROR doesn't have fields\n+   |               ^\n ...\n LL |     fake_anon_field_stmt!();\n    |     ------------------------ in this macro invocation\n@@ -56,11 +56,11 @@ LL |           1.fake //~ ERROR doesn't have fields\n LL |     let _ = fake_field_expr!();\n    |             ------------------ in this macro invocation\n \n-error[E0609]: no field `0` on type `{integer}`\n-  --> $DIR/macro-backtrace-invalid-internals.rs:45:11\n+error[E0610]: `{integer}` is a primitive type and therefore doesn't have fields\n+  --> $DIR/macro-backtrace-invalid-internals.rs:45:15\n    |\n-LL |           (1).0 //~ ERROR no field\n-   |           ^^^^^\n+LL |           (1).0 //~ ERROR doesn't have fields\n+   |               ^\n ...\n LL |     let _ = fake_anon_field_expr!();\n    |             ----------------------- in this macro invocation\n@@ -80,5 +80,5 @@ LL |           2.0_f32.powi(2) //~ ERROR can't call method `powi` on ambiguous n\n \n error: aborting due to 8 previous errors\n \n-Some errors occurred: E0599, E0609, E0610, E0689.\n+Some errors occurred: E0599, E0610, E0689.\n For more information about an error, try `rustc --explain E0599`."}]}