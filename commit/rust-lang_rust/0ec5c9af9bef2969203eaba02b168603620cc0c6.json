{"sha": "0ec5c9af9bef2969203eaba02b168603620cc0c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlYzVjOWFmOWJlZjI5NjkyMDNlYWJhMDJiMTY4NjAzNjIwY2MwYzY=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-03T14:51:05Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-03T14:51:05Z"}, "message": "Add cleanup code so the the array remains in a valid state if a comparison fails", "tree": {"sha": "bf5fbc7e3e755a4a48ae220db08e8e9f630c2540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf5fbc7e3e755a4a48ae220db08e8e9f630c2540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ec5c9af9bef2969203eaba02b168603620cc0c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec5c9af9bef2969203eaba02b168603620cc0c6", "html_url": "https://github.com/rust-lang/rust/commit/0ec5c9af9bef2969203eaba02b168603620cc0c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ec5c9af9bef2969203eaba02b168603620cc0c6/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "579c7e3ef18089825edc52316745c71b2664217a", "url": "https://api.github.com/repos/rust-lang/rust/commits/579c7e3ef18089825edc52316745c71b2664217a", "html_url": "https://github.com/rust-lang/rust/commit/579c7e3ef18089825edc52316745c71b2664217a"}], "stats": {"total": 75, "additions": 74, "deletions": 1}, "files": [{"sha": "75331d5a4c4462505234d3daac227e1644edf569", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0ec5c9af9bef2969203eaba02b168603620cc0c6/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ec5c9af9bef2969203eaba02b168603620cc0c6/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=0ec5c9af9bef2969203eaba02b168603620cc0c6", "patch": "@@ -187,6 +187,7 @@ fn tim_sort<T: Ord>(array: &[mut T]) {\n     }\n \n     let ms = &MergeState();\n+    ms.array = array;\n     let min_run = min_run_length(size);\n \n     let mut idx = 0;\n@@ -401,10 +402,23 @@ struct RunState {\n struct MergeState<T> {\n     mut min_gallop: uint,\n     mut tmp: ~[T],\n+    mut last_hi: bool,\n+    mut mergePt: uint,\n+    mut tmpPt: uint,\n+    mut array: &[mut T],\n     runs: DVec<RunState>,\n \n     drop {\n         unsafe {\n+            let size = self.tmp.len();\n+            // Move tmp back into invalid part of array\n+            if self.last_hi && size > 0 {\n+                self.mergePt -= self.tmpPt;\n+                move_vec(self.array, self.mergePt, self.tmp, 0, self.tmpPt);\n+            } else if !self.last_hi && size > 0 {\n+                move_vec(self.array, self.mergePt,\n+                        self.tmp, self.tmpPt, size-self.tmpPt);\n+            }\n             vec::raw::set_len(self.tmp, 0);\n         }\n     }\n@@ -416,6 +430,10 @@ fn MergeState<T>() -> MergeState<T> {\n     MergeState {\n         min_gallop: MIN_GALLOP,\n         tmp: tmp,\n+        last_hi: false,\n+        mergePt: 0,\n+        tmpPt: 0,\n+        array: &[mut],\n         runs: DVec(),\n     }\n }\n@@ -448,11 +466,13 @@ impl<T: Ord> &MergeState<T> {\n             }\n \n             let slice = vec::mut_view(array, b1, b1+l1);\n+            self.mergePt = b1;\n             let k = gallop_right(&const array[b2], slice, 0);\n             b1 += k;\n             l1 -= k;\n             if l1 != 0 {\n                 let slice = vec::mut_view(array, b2, b2+l2);\n+                self.mergePt = b2;\n                 let l2 = gallop_left(\n                     &const array[b1+l1-1],slice,l2-1);\n                 if l2 > 0 {\n@@ -465,18 +485,22 @@ impl<T: Ord> &MergeState<T> {\n             }\n         }\n         self.runs.pop();\n+        self.mergePt = 0;\n     }\n \n     fn merge_lo(array: &[mut T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n         vec::reserve(&mut self.tmp, len1);\n+        self.last_hi = false;\n \n         unsafe {\n             vec::raw::set_len(self.tmp, len1);\n             move_vec(self.tmp, 0, array, base1, len1);\n         }\n+        self.tmpPt = 0;\n+        self.mergePt = base1;\n \n         let mut c1 = 0;\n         let mut c2 = base2;\n@@ -486,6 +510,7 @@ impl<T: Ord> &MergeState<T> {\n \n         array[dest] <-> array[c2];\n         dest += 1; c2 += 1; len2 -= 1;\n+        self.mergePt += 1;\n \n         if len2 == 0 {\n             unsafe {\n@@ -514,13 +539,16 @@ impl<T: Ord> &MergeState<T> {\n                 if array[c2] < self.tmp[c1] {\n                     array[dest] <-> array[c2];\n                     dest += 1; c2 += 1; len2 -= 1;\n+                    self.mergePt += 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n                     array[dest] <-> self.tmp[c1];\n                     dest += 1; c1 += 1; len1 -= 1;\n+                    self.mergePt += 1;\n+                    self.tmpPt += 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 1 {\n                         break_outer = true;\n@@ -536,17 +564,19 @@ impl<T: Ord> &MergeState<T> {\n             loop {\n                 assert len1 > 1 && len2 != 0;\n \n-                let tmp_view = vec::mut_view(self.tmp, c1, c1+len1);\n+                let tmp_view = vec::const_view(self.tmp, c1, c1+len1);\n                 count1 = gallop_right(&const array[c2], tmp_view, 0);\n                 if count1 != 0 {\n                     unsafe {\n                         move_vec(array, dest, self.tmp, c1, count1);\n                     }\n                     dest += count1; c1 += count1; len1 -= count1;\n+                    self.mergePt += count1; self.tmpPt += count1;\n                     if len1 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c2];\n                 dest += 1; c2 += 1; len2 -= 1;\n+                self.mergePt += 1;\n                 if len2 == 0 { break_outer = true; break; }\n \n                 let tmp_view = vec::mut_view(array, c2, c2+len2);\n@@ -556,10 +586,12 @@ impl<T: Ord> &MergeState<T> {\n                         move_vec(array, dest, array, c2, count2);\n                     }\n                     dest += count2; c2 += count2; len2 -= count2;\n+                    self.mergePt += count2;\n                     if len2 == 0 { break_outer = true; break; }\n                 }\n                 array[dest] <-> self.tmp[c1];\n                 dest += 1; c1 += 1; len1 -= 1;\n+                self.mergePt += 1; self.tmpPt += 1;\n                 if len1 == 1 { break_outer = true; break; }\n                 min_gallop -= 1;\n                 if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n@@ -587,6 +619,7 @@ impl<T: Ord> &MergeState<T> {\n                 move_vec(array, dest, self.tmp, c1, len1);\n             }\n         }\n+        self.tmpPt = 0;\n         unsafe { vec::raw::set_len(self.tmp, 0); }\n     }\n \n@@ -595,6 +628,7 @@ impl<T: Ord> &MergeState<T> {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n         vec::reserve(&mut self.tmp, len2);\n+        self.last_hi = true;\n \n         unsafe {\n             vec::raw::set_len(self.tmp, len2);\n@@ -607,6 +641,9 @@ impl<T: Ord> &MergeState<T> {\n         let mut len1 = len1;\n         let mut len2 = len2;\n \n+        self.mergePt = dest;\n+        self.tmpPt = len2 - 1;\n+\n         array[dest] <-> array[c1];\n         dest -= 1; c1 -= 1; len1 -= 1;\n \n@@ -639,13 +676,15 @@ impl<T: Ord> &MergeState<T> {\n                 if self.tmp[c2] < array[c1] {\n                     array[dest] <-> array[c1];\n                     dest -= 1; c1 -= 1; len1 -= 1;\n+                    self.mergePt -= 1;\n                     count1 += 1; count2 = 0;\n                     if len1 == 0 {\n                         break_outer = true;\n                     }\n                 } else {\n                     array[dest] <-> self.tmp[c2];\n                     dest -= 1; c2 -= 1; len2 -= 1;\n+                    self.mergePt -= 1; self.tmpPt -= 1;\n                     count2 += 1; count1 = 0;\n                     if len2 == 1 {\n                         break_outer = true;\n@@ -667,6 +706,7 @@ impl<T: Ord> &MergeState<T> {\n \n                 if count1 != 0 {\n                     dest -= count1; c1 -= count1; len1 -= count1;\n+                    self.mergePt -= count1;\n                     unsafe {\n                         move_vec(array, dest+1, array, c1+1, count1);\n                     }\n@@ -675,20 +715,23 @@ impl<T: Ord> &MergeState<T> {\n \n                 array[dest] <-> self.tmp[c2];\n                 dest -= 1; c2 -= 1; len2 -= 1;\n+                self.mergePt -= 1; self.tmpPt -= 1;\n                 if len2 == 1 { break_outer = true; break; }\n \n                 let tmp_view = vec::mut_view(self.tmp, 0, len2);\n                 let count2 = len2 - gallop_left(\n                     &const array[c1], tmp_view, len2-1);\n                 if count2 != 0 {\n                     dest -= count2; c2 -= count2; len2 -= count2;\n+                    self.mergePt -= count2; self.tmpPt -= count2;\n                     unsafe {\n                         move_vec(array, dest+1, self.tmp, c2+1, count2);\n                     }\n                     if len2 <= 1 { break_outer = true; break; }\n                 }\n                 array[dest] <-> array[c1];\n                 dest -= 1; c1 -= 1; len1 -= 1;\n+                self.mergePt -= 1;\n                 if len1 == 0 { break_outer = true; break; }\n                 min_gallop -= 1;\n                 if !(count1 >= MIN_GALLOP || count2 >= MIN_GALLOP) {\n@@ -719,6 +762,7 @@ impl<T: Ord> &MergeState<T> {\n                 move_vec(array, dest-(len2-1), self.tmp, 0, len2);\n             }\n         }\n+        self.tmpPt = 0;\n         unsafe { vec::raw::set_len(self.tmp, 0); }\n     }\n \n@@ -941,6 +985,23 @@ mod tests {\n #[cfg(test)]\n mod test_timsort {\n     #[legacy_exports];\n+    struct CVal {\n+        val: ~float,\n+    }\n+\n+    impl CVal: Ord {\n+        pure fn lt(other: &CVal) -> bool {\n+            unsafe {\n+                let rng = rand::Rng();\n+                if rng.gen_float() > 0.995 { fail ~\"It's happening!!!\"; }\n+            }\n+            self.val < other.val\n+        }\n+        pure fn le(other: &CVal) -> bool { self.val <= other.val }\n+        pure fn gt(other: &CVal) -> bool { self.val > other.val }\n+        pure fn ge(other: &CVal) -> bool { self.val >= other.val }\n+    }\n+\n     fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         timsort::<int>(v1);\n@@ -976,6 +1037,18 @@ mod test_timsort {\n             check_sort(v1, v2);\n         }\n     }\n+\n+    #[test]\n+    #[should_fail]\n+    fn crash_test() {\n+        let arr = do vec::from_fn |_i| {\n+            let randVal = rng.gen_float();\n+            CVal { val: ~randVal }\n+        };\n+\n+        tim_sort(arr);\n+        fail ~\"Guarantee the fail\";\n+    }\n }\n \n // Local Variables:"}]}