{"sha": "432460a6fc92e8baecbc4fa175345e78232fe2ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzMjQ2MGE2ZmM5MmU4YmFlY2JjNGZhMTc1MzQ1ZTc4MjMyZmUyZWQ=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-01-28T21:59:00Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2016-02-04T13:56:01Z"}, "message": "Synthesize calls to box_free language item\n\nThis gets rid of Drop(Free, _) MIR construct by synthesizing a call to language item which\ntakes care of dropping instead.", "tree": {"sha": "d59c70df2e2c0c9234f8134be320a5932be8d792", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d59c70df2e2c0c9234f8134be320a5932be8d792"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/432460a6fc92e8baecbc4fa175345e78232fe2ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/432460a6fc92e8baecbc4fa175345e78232fe2ed", "html_url": "https://github.com/rust-lang/rust/commit/432460a6fc92e8baecbc4fa175345e78232fe2ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/432460a6fc92e8baecbc4fa175345e78232fe2ed/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b9d6d3bc8730aa565dbb5e285027443696aef0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b9d6d3bc8730aa565dbb5e285027443696aef0c", "html_url": "https://github.com/rust-lang/rust/commit/7b9d6d3bc8730aa565dbb5e285027443696aef0c"}], "stats": {"total": 196, "additions": 127, "deletions": 69}, "files": [{"sha": "b948567ac5b74a565a55d6136081e763aec8d997", "filename": "src/doc/book/lang-items.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Fdoc%2Fbook%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Fdoc%2Fbook%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flang-items.md?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -39,11 +39,17 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n \n     p\n }\n+\n #[lang = \"exchange_free\"]\n unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {\n     libc::free(ptr as *mut libc::c_void)\n }\n \n+#[lang = \"box_free\"]\n+unsafe fn box_free<T>(ptr: *mut T) {\n+    deallocate(ptr as *mut u8, ::core::mem::size_of::<T>(), ::core::mem::align_of::<T>());\n+}\n+\n #[start]\n fn main(argc: isize, argv: *const *const u8) -> isize {\n     let x = box 1;"}, {"sha": "08b403a60f3819d7ee07e9186141d237ac0fadab", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -16,6 +16,8 @@\n             issue = \"27700\")]\n \n use core::{isize, usize};\n+#[cfg(not(test))]\n+use core::intrinsics::{size_of, min_align_of};\n \n #[allow(improper_ctypes)]\n extern \"C\" {\n@@ -147,6 +149,17 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: usize, align: usize) {\n     deallocate(ptr, old_size, align);\n }\n \n+#[cfg(not(test))]\n+#[lang = \"box_free\"]\n+#[inline]\n+unsafe fn box_free<T>(ptr: *mut T) {\n+    let size = size_of::<T>();\n+    // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n+    if size != 0 {\n+        deallocate(ptr as *mut u8, size, min_align_of::<T>());\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "7ed931265f22cea910118d353b2a56250087934c", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -435,7 +435,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n         let is_named = node.name().is_some();\n         let field_type = self.tcx.node_id_to_type(node.id);\n         let is_marker_field = match field_type.ty_to_def_id() {\n-            Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n+            Some(def_id) => self.tcx.lang_items.items().iter().any(|item| *item == Some(def_id)),\n             _ => false\n         };\n         is_named"}, {"sha": "b445f549ba2ba81634208a5f1f3cf436edf25dc0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -36,9 +36,6 @@ use syntax::parse::token::InternedString;\n use rustc_front::intravisit::Visitor;\n use rustc_front::hir;\n \n-use std::iter::Enumerate;\n-use std::slice;\n-\n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! lets_do_this {\n@@ -69,8 +66,8 @@ impl LanguageItems {\n         }\n     }\n \n-    pub fn items<'a>(&'a self) -> Enumerate<slice::Iter<'a, Option<DefId>>> {\n-        self.items.iter().enumerate()\n+    pub fn items(&self) -> &[Option<DefId>] {\n+        &*self.items\n     }\n \n     pub fn item_name(index: usize) -> &'static str {\n@@ -334,6 +331,7 @@ lets_do_this! {\n \n     ExchangeMallocFnLangItem,        \"exchange_malloc\",         exchange_malloc_fn;\n     ExchangeFreeFnLangItem,          \"exchange_free\",           exchange_free_fn;\n+    BoxFreeFnLangItem,               \"box_free\",                box_free_fn;\n     StrDupUniqFnLangItem,            \"strdup_uniq\",             strdup_uniq_fn;\n \n     StartFnLangItem,                 \"start\",                   start_fn;"}, {"sha": "6dd447e3b6860c68ec4e567b68406c80c423ab56", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -362,7 +362,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     for (id, _) in &access_levels.map {\n         reachable_context.worklist.push(*id);\n     }\n-    for (_, item) in tcx.lang_items.items() {\n+    for item in tcx.lang_items.items().iter() {\n         if let Some(did) = *item {\n             if let Some(node_id) = tcx.map.as_local_node_id(did) {\n                 reachable_context.worklist.push(node_id);"}, {"sha": "b9a94ad006848ea00f87684e7aa8b3e02602ae50", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -490,23 +490,15 @@ pub struct Statement<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub enum StatementKind<'tcx> {\n     Assign(Lvalue<'tcx>, Rvalue<'tcx>),\n-    Drop(DropKind, Lvalue<'tcx>),\n-}\n-\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n-pub enum DropKind {\n-    /// free a partially constructed box, should go away eventually\n-    Free,\n-    Deep\n+    Drop(Lvalue<'tcx>),\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n-            Drop(DropKind::Free, ref lv) => write!(fmt, \"free {:?}\", lv),\n-            Drop(DropKind::Deep, ref lv) => write!(fmt, \"drop {:?}\", lv),\n+            Drop(ref lv) => write!(fmt, \"drop {:?}\", lv),\n         }\n     }\n }"}, {"sha": "494eac44b1ad64255061231f4eff5719b7666fde", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -124,7 +124,7 @@ macro_rules! make_mir_visitor {\n                                           ref $($mutability)* rvalue) => {\n                         self.visit_assign(block, lvalue, rvalue);\n                     }\n-                    StatementKind::Drop(_, ref $($mutability)* lvalue) => {\n+                    StatementKind::Drop(ref $($mutability)* lvalue) => {\n                         self.visit_lvalue(lvalue, LvalueContext::Drop);\n                     }\n                 }"}, {"sha": "8df72016078e6330de3050afb4276e62fd400a9f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -1649,7 +1649,7 @@ fn encode_crate_deps(rbml_w: &mut Encoder, cstore: &cstore::CStore) {\n fn encode_lang_items(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n     rbml_w.start_tag(tag_lang_items);\n \n-    for (i, &opt_def_id) in ecx.tcx.lang_items.items() {\n+    for (i, &opt_def_id) in ecx.tcx.lang_items.items().iter().enumerate() {\n         if let Some(def_id) = opt_def_id {\n             if def_id.is_local() {\n                 rbml_w.start_tag(tag_lang_items_item);"}, {"sha": "5be2b8394eebd18383a525ec175a50c1e7118f72", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -32,16 +32,21 @@ impl<'tcx> CFG<'tcx> {\n         BasicBlock::new(node_index)\n     }\n \n+    pub fn start_new_cleanup_block(&mut self) -> BasicBlock {\n+        let bb = self.start_new_block();\n+        self.block_data_mut(bb).is_cleanup = true;\n+        bb\n+    }\n+\n     pub fn push(&mut self, block: BasicBlock, statement: Statement<'tcx>) {\n         debug!(\"push({:?}, {:?})\", block, statement);\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n-    pub fn push_drop(&mut self, block: BasicBlock, span: Span,\n-                     kind: DropKind, lvalue: &Lvalue<'tcx>) {\n+    pub fn push_drop(&mut self, block: BasicBlock, span: Span, lvalue: &Lvalue<'tcx>) {\n         self.push(block, Statement {\n             span: span,\n-            kind: StatementKind::Drop(kind, lvalue.clone())\n+            kind: StatementKind::Drop(lvalue.clone())\n         });\n     }\n "}, {"sha": "dea2d750b981bed47801d3cdfd3ece92713a5316", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -59,25 +59,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let arg = unpack!(block = this.as_operand(block, arg));\n                 block.and(Rvalue::UnaryOp(op, arg))\n             }\n-            ExprKind::Box { value } => {\n+            ExprKind::Box { value, value_extents } => {\n                 let value = this.hir.mirror(value);\n                 let result = this.temp(expr.ty);\n-\n                 // to start, malloc some memory of suitable type (thus far, uninitialized):\n-                let rvalue = Rvalue::Box(value.ty);\n-                this.cfg.push_assign(block, expr_span, &result, rvalue);\n-\n-                // schedule a shallow free of that memory, lest we unwind:\n-                let extent = this.extent_of_innermost_scope();\n-                this.schedule_drop(expr_span, extent, DropKind::Free, &result, value.ty);\n-\n-                // initialize the box contents:\n-                let contents = result.clone().deref();\n-                unpack!(block = this.into(&contents, block, value));\n-\n-                // now that the result is fully initialized, cancel the drop\n-                // by \"using\" the result (which is linear):\n-                block.and(Rvalue::Use(Operand::Consume(result)))\n+                this.cfg.push_assign(block, expr_span, &result, Rvalue::Box(value.ty));\n+                this.in_scope(value_extents, block, |this| {\n+                    // schedule a shallow free of that memory, lest we unwind:\n+                    this.schedule_box_free(expr_span, value_extents, &result, value.ty);\n+                    // initialize the box contents:\n+                    unpack!(block = this.into(&result.clone().deref(), block, value));\n+                    block.and(Rvalue::Use(Operand::Consume(result)))\n+                })\n             }\n             ExprKind::Cast { source } => {\n                 let source = unpack!(block = this.as_operand(block, source));"}, {"sha": "27c374e1ac2c468591118dcb40e0654fd73115cf", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -41,7 +41,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 this.hir.span_bug(expr.span, \"no temp_lifetime for expr\");\n             }\n         };\n-        this.schedule_drop(expr.span, temp_lifetime, DropKind::Deep, &temp, expr_ty);\n+        this.schedule_drop(expr.span, temp_lifetime, &temp, expr_ty);\n \n         // Careful here not to cause an infinite cycle. If we always\n         // called `into`, then for lvalues like `x.f`, it would"}, {"sha": "7ecd8a26507f8a217ac8f7af872e68c96bdacda1", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -188,7 +188,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // operators like x[j] = x[i].\n                 let rhs = unpack!(block = this.as_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                this.cfg.push_drop(block, expr_span, DropKind::Deep, &lhs);\n+                this.cfg.push_drop(block, expr_span, &lhs);\n                 this.cfg.push_assign(block, expr_span, &lhs, Rvalue::Use(rhs));\n                 block.unit()\n             }"}, {"sha": "e6430b7d63404cbff54f12d8543b37f7bc0cedc6", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -601,7 +601,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ty: var_ty.clone(),\n         });\n         let index = index as u32;\n-        self.schedule_drop(span, var_extent, DropKind::Deep, &Lvalue::Var(index), var_ty);\n+        self.schedule_drop(span, var_extent, &Lvalue::Var(index), var_ty);\n         self.var_indices.insert(var_id, index);\n \n         debug!(\"declare_binding: index={:?}\", index);"}, {"sha": "35153bc8a90efe83e6dfcd1cc4b0e4bd37124318", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -89,15 +89,16 @@ should go to.\n use build::{BlockAnd, BlockAndExtension, Builder};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n-use rustc::middle::subst::Substs;\n+use rustc::middle::subst::{Substs, VecPerParamSpace};\n use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr::*;\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::parse::token::intern_and_get_ident;\n \n pub struct Scope<'tcx> {\n     extent: CodeExtent,\n-    drops: Vec<(DropKind, Span, Lvalue<'tcx>)>,\n+    drops: Vec<(Span, Lvalue<'tcx>)>,\n+    frees: Vec<(Span, Lvalue<'tcx>, Ty<'tcx>)>,\n     cached_block: Option<BasicBlock>,\n }\n \n@@ -164,6 +165,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.scopes.push(Scope {\n             extent: extent.clone(),\n             drops: vec![],\n+            frees: vec![],\n             cached_block: None,\n         });\n     }\n@@ -180,8 +182,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // add in any drops needed on the fallthrough path (any other\n         // exiting paths, such as those that arise from `break`, will\n         // have drops already)\n-        for (kind, span, lvalue) in scope.drops {\n-            self.cfg.push_drop(block, span, kind, &lvalue);\n+        for (span, lvalue) in scope.drops {\n+            self.cfg.push_drop(block, span, &lvalue);\n         }\n     }\n \n@@ -225,8 +227,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         });\n \n         for scope in scopes.iter_mut().rev().take(scope_count) {\n-            for &(kind, drop_span, ref lvalue) in &scope.drops {\n-                cfg.push_drop(block, drop_span, kind, lvalue);\n+            for &(drop_span, ref lvalue) in &scope.drops {\n+                cfg.push_drop(block, drop_span, lvalue);\n             }\n         }\n         cfg.terminate(block, Terminator::Goto { target: target });\n@@ -242,23 +244,55 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             return None;\n         }\n \n+        let tcx = self.hir.tcx();\n+        let unit_tmp = self.get_unit_temp();\n         let mut terminator = Terminator::Resume;\n         // Given an array of scopes, we generate these from the outermost scope to the innermost\n         // one. Thus for array [S0, S1, S2] with corresponding cleanup blocks [B0, B1, B2], we will\n         // generate B0 <- B1 <- B2 in left-to-right order. The outermost scope (B0) will always\n         // terminate with a Resume terminator.\n-        for scope in self.scopes.iter_mut().filter(|s| !s.drops.is_empty()) {\n+        for scope in self.scopes.iter_mut().filter(|s| !s.drops.is_empty() || !s.frees.is_empty()) {\n             if let Some(b) = scope.cached_block {\n                 terminator = Terminator::Goto { target: b };\n                 continue;\n             } else {\n-                let new_block = self.cfg.start_new_block();\n-                self.cfg.block_data_mut(new_block).is_cleanup = true;\n+                let mut new_block = self.cfg.start_new_cleanup_block();\n                 self.cfg.terminate(new_block, terminator);\n                 terminator = Terminator::Goto { target: new_block };\n-                for &(kind, span, ref lvalue) in scope.drops.iter().rev() {\n-                    self.cfg.push_drop(new_block, span, kind, lvalue);\n+\n+                for &(span, ref lvalue) in scope.drops.iter().rev() {\n+                    self.cfg.push_drop(new_block, span, lvalue);\n+                }\n+\n+                for &(_, ref lvalue, ref item_ty) in scope.frees.iter().rev() {\n+                    let item = lang_items::SpannedLangItems::box_free_fn(&tcx.lang_items)\n+                        .expect(\"box_free language item required\");\n+                    let substs = tcx.mk_substs(Substs::new(\n+                        VecPerParamSpace::new(vec![], vec![], vec![item_ty]),\n+                        VecPerParamSpace::new(vec![], vec![], vec![])\n+                    ));\n+                    let func = Constant {\n+                        span: item.1,\n+                        ty: tcx.lookup_item_type(item.0).ty.subst(substs),\n+                        literal: Literal::Item {\n+                            def_id: item.0,\n+                            kind: ItemKind::Function,\n+                            substs: substs\n+                        }\n+                    };\n+                    let old_block = new_block;\n+                    new_block = self.cfg.start_new_cleanup_block();\n+                    self.cfg.terminate(new_block, Terminator::Call {\n+                        func: Operand::Constant(func),\n+                        args: vec![Operand::Consume(lvalue.clone())],\n+                        kind: CallKind::Converging {\n+                            target: old_block,\n+                            destination: unit_tmp.clone()\n+                        }\n+                    });\n+                    terminator = Terminator::Goto { target: new_block };\n                 }\n+\n                 scope.cached_block = Some(new_block);\n             }\n         }\n@@ -272,7 +306,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn schedule_drop(&mut self,\n                          span: Span,\n                          extent: CodeExtent,\n-                         kind: DropKind,\n                          lvalue: &Lvalue<'tcx>,\n                          lvalue_ty: Ty<'tcx>) {\n         if self.hir.needs_drop(lvalue_ty) {\n@@ -282,7 +315,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 // incorrect (i.e. they still are pointing at old cached_block).\n                 scope.cached_block = None;\n                 if scope.extent == extent {\n-                    scope.drops.push((kind, span, lvalue.clone()));\n+                    scope.drops.push((span, lvalue.clone()));\n                     return;\n                 }\n             }\n@@ -291,6 +324,27 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n \n+    /// Schedule dropping of a not yet fully initialised box. This cleanup will (and should) only\n+    /// be translated into unwind branch. The extent should be for the `EXPR` inside `box EXPR`.\n+    pub fn schedule_box_free(&mut self,\n+                             span: Span,\n+                             extent: CodeExtent,\n+                             lvalue: &Lvalue<'tcx>,\n+                             item_ty: Ty<'tcx>) {\n+        for scope in self.scopes.iter_mut().rev() {\n+            // We must invalidate all the cached_blocks leading up to the scope we\u2019re looking\n+            // for, because otherwise some/most of the blocks in the chain might become\n+            // incorrect (i.e. they still are pointing at old cached_block).\n+            scope.cached_block = None;\n+            if scope.extent == extent {\n+                scope.frees.push((span, lvalue.clone(), item_ty));\n+                return;\n+            }\n+        }\n+        self.hir.span_bug(span,\n+                          &format!(\"extent {:?} not in scope to drop {:?}\", extent, lvalue));\n+    }\n+\n     pub fn extent_of_innermost_scope(&self) -> CodeExtent {\n         self.scopes.last().map(|scope| scope.extent).unwrap()\n     }\n@@ -299,6 +353,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.scopes.first().map(|scope| scope.extent).unwrap()\n     }\n \n+\n     pub fn panic_bounds_check(&mut self,\n                              block: BasicBlock,\n                              index: Operand<'tcx>,\n@@ -405,4 +460,5 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             literal: self.hir.usize_literal(span_lines.line)\n         })\n     }\n+\n }"}, {"sha": "3a50acec94f0201a9ea52e7db0adf008c30d52e5", "filename": "src/librustc_mir/build/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fstmt.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -72,7 +72,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         let expr = this.hir.mirror(expr);\n                         let temp = this.temp(expr.ty.clone());\n                         unpack!(block = this.into(&temp, block, expr));\n-                        this.cfg.push_drop(block, span, DropKind::Deep, &temp);\n+                        this.cfg.push_drop(block, span, &temp);\n                         block.unit()\n                     }));\n                 }"}, {"sha": "f9a9c99f63d5e23fad2b3033c6e1343632b0277d", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -375,7 +375,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             hir::ExprType(ref source, _) =>\n                 return source.make_mirror(cx),\n             hir::ExprBox(ref value) =>\n-                ExprKind::Box { value: value.to_ref() },\n+                ExprKind::Box {\n+                    value: value.to_ref(),\n+                    value_extents: cx.tcx.region_maps.node_extent(value.id)\n+                },\n             hir::ExprVec(ref fields) =>\n                 ExprKind::Vec { fields: fields.to_ref() },\n             hir::ExprTup(ref fields) =>"}, {"sha": "0891c2845b0ba66537a2ca868b6a153a673f8036", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -123,6 +123,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Box {\n         value: ExprRef<'tcx>,\n+        value_extents: CodeExtent,\n     },\n     Call {\n         ty: ty::Ty<'tcx>,"}, {"sha": "3cd1bd76c54ebb20ca8feafe1c181ded641c2156", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> EraseRegions<'a, 'tcx> {\n                 self.erase_regions_lvalue(lvalue);\n                 self.erase_regions_rvalue(rvalue);\n             }\n-            StatementKind::Drop(_, ref mut lvalue) => {\n+            StatementKind::Drop(ref mut lvalue) => {\n                 self.erase_regions_lvalue(lvalue);\n             }\n         }"}, {"sha": "3b763599f777290e4ab90b8f21dbea56383439bb", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -82,13 +82,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           constant: &mir::Constant<'tcx>)\n                           -> OperandRef<'tcx>\n     {\n-        let ty = bcx.monomorphize(&constant.ty);\n         match constant.literal {\n             mir::Literal::Item { def_id, kind, substs } => {\n                 let substs = bcx.tcx().mk_substs(bcx.monomorphize(&substs));\n-                self.trans_item_ref(bcx, ty, kind, substs, def_id)\n+                self.trans_item_ref(bcx, constant.ty, kind, substs, def_id)\n             }\n             mir::Literal::Value { ref value } => {\n+                let ty = bcx.monomorphize(&constant.ty);\n                 self.trans_constval(bcx, value, ty)\n             }\n         }"}, {"sha": "cd186de7ca08b3a82d838643e3c90b7a746dd218", "filename": "src/librustc_trans/trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/432460a6fc92e8baecbc4fa175345e78232fe2ed/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fstatement.rs?ref=432460a6fc92e8baecbc4fa175345e78232fe2ed", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::middle::ty::LvaluePreference;\n use rustc::mir::repr as mir;\n use trans::common::Block;\n use trans::debuginfo::DebugLoc;\n@@ -52,19 +51,11 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 }\n             }\n \n-            mir::StatementKind::Drop(mir::DropKind::Deep, ref lvalue) => {\n+            mir::StatementKind::Drop(ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n                 glue::drop_ty(bcx, tr_lvalue.llval, ty, DebugLoc::None)\n             }\n-\n-            mir::StatementKind::Drop(mir::DropKind::Free, ref lvalue) => {\n-                let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                let content_ty = ty.builtin_deref(true, LvaluePreference::NoPreference);\n-                let content_ty = content_ty.unwrap().ty;\n-                glue::trans_exchange_free_ty(bcx, tr_lvalue.llval, content_ty, DebugLoc::None)\n-            }\n         }\n     }\n }"}]}