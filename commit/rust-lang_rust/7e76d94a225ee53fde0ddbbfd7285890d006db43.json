{"sha": "7e76d94a225ee53fde0ddbbfd7285890d006db43", "node_id": "C_kwDOAAsO6NoAKDdlNzZkOTRhMjI1ZWU1M2ZkZTBkZGJiZmQ3Mjg1ODkwZDAwNmRiNDM", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-23T17:31:35Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-23T22:28:41Z"}, "message": "effective visibility: Always add table entries for nodes used as parents\n\nPreviously if the parent was not in the table, and there was nothing to inherit from, the child's private visibility was used, but that's not correct - the parent may have a larger visibility so we should set it to at least the parent's private visibility.\nThat parent's private visibility is also inserted into the table for caching, so it's not recalculated later if used again.", "tree": {"sha": "b02c6caeba997db44451d65d3b1915ed62de51ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b02c6caeba997db44451d65d3b1915ed62de51ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e76d94a225ee53fde0ddbbfd7285890d006db43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e76d94a225ee53fde0ddbbfd7285890d006db43", "html_url": "https://github.com/rust-lang/rust/commit/7e76d94a225ee53fde0ddbbfd7285890d006db43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e76d94a225ee53fde0ddbbfd7285890d006db43/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a45a302be536126accf29764b6a3dca39d57d0fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/a45a302be536126accf29764b6a3dca39d57d0fe", "html_url": "https://github.com/rust-lang/rust/commit/a45a302be536126accf29764b6a3dca39d57d0fe"}], "stats": {"total": 91, "additions": 51, "deletions": 40}, "files": [{"sha": "fc08d58cc40687765dbf33fa580b95a17dcbe1fc", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7e76d94a225ee53fde0ddbbfd7285890d006db43/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e76d94a225ee53fde0ddbbfd7285890d006db43/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=7e76d94a225ee53fde0ddbbfd7285890d006db43", "patch": "@@ -213,14 +213,21 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         self.map.get(&id)\n     }\n \n-    // `parent_id` is not necessarily a parent in source code tree,\n-    // it is the node from which the maximum effective visibility is inherited.\n+    // FIXME: Share code with `fn update`.\n+    pub fn effective_vis_or_private(\n+        &mut self,\n+        id: Id,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n+    ) -> &EffectiveVisibility {\n+        self.map.entry(id).or_insert_with(|| EffectiveVisibility::from_vis(lazy_private_vis()))\n+    }\n+\n     pub fn update<T: IntoDefIdTree>(\n         &mut self,\n         id: Id,\n         nominal_vis: Visibility,\n         lazy_private_vis: impl FnOnce(T) -> (Visibility, T),\n-        inherited_eff_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n         mut into_tree: T,\n     ) -> bool {\n@@ -235,39 +242,36 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         };\n         let tree = into_tree.tree();\n \n-        if let Some(inherited_effective_vis) = inherited_eff_vis {\n-            let mut inherited_effective_vis_at_prev_level =\n-                *inherited_effective_vis.at_level(level);\n-            let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n-            for l in Level::all_levels() {\n-                if level >= l {\n-                    let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n-                    let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n-                    // effective visibility for id shouldn't be recalculated if\n-                    // inherited from parent_id effective visibility isn't changed at next level\n-                    if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n-                        && level != l)\n-                    {\n-                        calculated_effective_vis =\n-                            if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n-                                inherited_effective_vis_at_level\n-                            } else {\n-                                nominal_vis\n-                            };\n-                    }\n-                    // effective visibility can't be decreased at next update call for the\n-                    // same id\n-                    if *current_effective_vis_at_level != calculated_effective_vis\n-                        && calculated_effective_vis\n-                            .is_at_least(*current_effective_vis_at_level, tree)\n-                    {\n-                        changed = true;\n-                        *current_effective_vis_at_level = calculated_effective_vis;\n-                    }\n-                    inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n+        let mut inherited_effective_vis_at_prev_level = *inherited_effective_vis.at_level(level);\n+        let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n+        for l in Level::all_levels() {\n+            if level >= l {\n+                let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n+                let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n+                // effective visibility for id shouldn't be recalculated if\n+                // inherited from parent_id effective visibility isn't changed at next level\n+                if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n+                    && level != l)\n+                {\n+                    calculated_effective_vis =\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n+                            inherited_effective_vis_at_level\n+                        } else {\n+                            nominal_vis\n+                        };\n+                }\n+                // effective visibility can't be decreased at next update call for the\n+                // same id\n+                if *current_effective_vis_at_level != calculated_effective_vis\n+                    && calculated_effective_vis.is_at_least(*current_effective_vis_at_level, tree)\n+                {\n+                    changed = true;\n+                    *current_effective_vis_at_level = calculated_effective_vis;\n                 }\n+                inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n             }\n         }\n+\n         self.map.insert(id, current_effective_vis);\n         changed\n     }"}, {"sha": "0f6db93c779c80f2d0c4af25ecb262936226cf9e", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e76d94a225ee53fde0ddbbfd7285890d006db43/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e76d94a225ee53fde0ddbbfd7285890d006db43/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=7e76d94a225ee53fde0ddbbfd7285890d006db43", "patch": "@@ -155,32 +155,39 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         }\n     }\n \n-    fn effective_vis(&self, parent_id: ParentId<'a>) -> Option<EffectiveVisibility> {\n-        match parent_id {\n-            ParentId::Def(def_id) => self.def_effective_visibilities.effective_vis(def_id),\n-            ParentId::Import(binding) => self.import_effective_visibilities.effective_vis(binding),\n+    fn effective_vis_or_private(&mut self, parent_id: ParentId<'a>) -> EffectiveVisibility {\n+        // Private nodes are only added to the table for caching, they could be added or removed at\n+        // any moment without consequences, so we don't set `changed` to true when adding them.\n+        *match parent_id {\n+            ParentId::Def(def_id) => self\n+                .def_effective_visibilities\n+                .effective_vis_or_private(def_id, || self.r.private_vis_def(def_id)),\n+            ParentId::Import(binding) => self\n+                .import_effective_visibilities\n+                .effective_vis_or_private(binding, || self.r.private_vis_import(binding)),\n         }\n-        .copied()\n     }\n \n     fn update_import(&mut self, binding: ImportId<'a>, parent_id: ParentId<'a>) {\n         let nominal_vis = binding.vis.expect_local();\n+        let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n             nominal_vis,\n             |r| (r.private_vis_import(binding), r),\n-            self.effective_vis(parent_id),\n+            inherited_eff_vis,\n             parent_id.level(),\n             &mut *self.r,\n         );\n     }\n \n     fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n+        let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n         self.changed |= self.def_effective_visibilities.update(\n             def_id,\n             nominal_vis,\n             |r| (r.private_vis_def(def_id), r),\n-            self.effective_vis(parent_id),\n+            inherited_eff_vis,\n             parent_id.level(),\n             &mut *self.r,\n         );"}]}