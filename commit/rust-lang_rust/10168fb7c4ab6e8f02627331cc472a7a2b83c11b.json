{"sha": "10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "node_id": "C_kwDOAAsO6NoAKDEwMTY4ZmI3YzRhYjZlOGYwMjYyNzMzMWNjNDcyYTdhMmI4M2MxMWI", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-09-15T04:59:03Z"}, "committer": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-10-11T20:18:59Z"}, "message": "Add new swizzle API\n\nExpand swizzle API and migrate existing functions. Add rotate_left, rotate_right.\n\nHide implementation details\n\nAdd simd_shuffle macro", "tree": {"sha": "40fbf2318a5f35bf93110eea3b72f9d34c574e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40fbf2318a5f35bf93110eea3b72f9d34c574e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "html_url": "https://github.com/rust-lang/rust/commit/10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a16b481a08a3d7560f9c92370f18f6ee8c006c9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16b481a08a3d7560f9c92370f18f6ee8c006c9e", "html_url": "https://github.com/rust-lang/rust/commit/a16b481a08a3d7560f9c92370f18f6ee8c006c9e"}], "stats": {"total": 752, "additions": 491, "deletions": 261}, "files": [{"sha": "ee8c477b838615ae52ca3a93412f17a0f08546f0", "filename": "crates/core_simd/examples/matrix_inversion.rs", "status": "modified", "additions": 59, "deletions": 63, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs?ref=10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "patch": "@@ -2,6 +2,7 @@\n // Code ported from the `packed_simd` crate\n // Run this code with `cargo test --example matrix_inversion`\n #![feature(array_chunks, portable_simd)]\n+use core_simd::Which::*;\n use core_simd::*;\n \n // Gotta define our own 4x4 matrix since Rust doesn't ship multidim arrays yet :^)\n@@ -163,86 +164,81 @@ pub fn simd_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n     let m_2 = f32x4::from_array(m[2]);\n     let m_3 = f32x4::from_array(m[3]);\n \n-    // 2 argument shuffle, returns an f32x4\n-    // the first f32x4 is indexes 0..=3\n-    // the second f32x4 is indexed 4..=7\n-    let tmp1 = f32x4::shuffle::<{ [0, 1, 4, 5] }>(m_0, m_1);\n-    let row1 = f32x4::shuffle::<{ [0, 1, 4, 5] }>(m_2, m_3);\n+    const SHUFFLE01: [Which; 4] = [First(0), First(1), Second(0), Second(1)];\n+    const SHUFFLE02: [Which; 4] = [First(0), First(2), Second(0), Second(2)];\n+    const SHUFFLE13: [Which; 4] = [First(1), First(3), Second(1), Second(3)];\n+    const SHUFFLE23: [Which; 4] = [First(2), First(3), Second(2), Second(3)];\n \n-    let row0 = f32x4::shuffle::<{ [0, 2, 4, 6] }>(tmp1, row1);\n-    let row1 = f32x4::shuffle::<{ [1, 3, 5, 7] }>(row1, tmp1);\n+    let tmp = simd_shuffle!(m_0, m_1, SHUFFLE01);\n+    let row1 = simd_shuffle!(m_2, m_3, SHUFFLE01);\n \n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 6, 7] }>(m_0, m_1);\n-    let row3 = f32x4::shuffle::<{ [2, 3, 6, 7] }>(m_2, m_3);\n-    let row2 = f32x4::shuffle::<{ [0, 2, 4, 6] }>(tmp1, row3);\n-    let row3 = f32x4::shuffle::<{ [1, 3, 5, 7] }>(row3, tmp1);\n+    let row0 = simd_shuffle!(tmp, row1, SHUFFLE02);\n+    let row1 = simd_shuffle!(row1, tmp, SHUFFLE13);\n \n-    let tmp1 = row2 * row3;\n-    // there's no syntax for a 1 arg shuffle yet,\n-    // so we just pass the same f32x4 twice\n-    let tmp1 = f32x4::shuffle::<{ [1, 0, 3, 2] }>(tmp1, tmp1);\n+    let tmp = simd_shuffle!(m_0, m_1, SHUFFLE23);\n+    let row3 = simd_shuffle!(m_2, m_3, SHUFFLE23);\n+    let row2 = simd_shuffle!(tmp, row3, SHUFFLE02);\n+    let row3 = simd_shuffle!(row3, tmp, SHUFFLE13);\n \n-    let minor0 = row1 * tmp1;\n-    let minor1 = row0 * tmp1;\n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(tmp1, tmp1);\n-    let minor0 = (row1 * tmp1) - minor0;\n-    let minor1 = (row0 * tmp1) - minor1;\n-    let minor1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(minor1, minor1);\n+    let tmp = (row2 * row3).reverse().rotate_right::<2>();\n+    let minor0 = row1 * tmp;\n+    let minor1 = row0 * tmp;\n+    let tmp = tmp.rotate_right::<2>();\n+    let minor0 = (row1 * tmp) - minor0;\n+    let minor1 = (row0 * tmp) - minor1;\n+    let minor1 = minor1.rotate_right::<2>();\n \n-    let tmp1 = row1 * row2;\n-    let tmp1 = f32x4::shuffle::<{ [1, 0, 3, 2] }>(tmp1, tmp1);\n-    let minor0 = (row3 * tmp1) + minor0;\n-    let minor3 = row0 * tmp1;\n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(tmp1, tmp1);\n+    let tmp = (row1 * row2).reverse().rotate_right::<2>();\n+    let minor0 = (row3 * tmp) + minor0;\n+    let minor3 = row0 * tmp;\n+    let tmp = tmp.rotate_right::<2>();\n \n-    let minor0 = minor0 - row3 * tmp1;\n-    let minor3 = row0 * tmp1 - minor3;\n-    let minor3 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(minor3, minor3);\n+    let minor0 = minor0 - row3 * tmp;\n+    let minor3 = row0 * tmp - minor3;\n+    let minor3 = minor3.rotate_right::<2>();\n \n-    let tmp1 = row3 * f32x4::shuffle::<{ [2, 3, 0, 1] }>(row1, row1);\n-    let tmp1 = f32x4::shuffle::<{ [1, 0, 3, 2] }>(tmp1, tmp1);\n-    let row2 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(row2, row2);\n-    let minor0 = row2 * tmp1 + minor0;\n-    let minor2 = row0 * tmp1;\n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(tmp1, tmp1);\n-    let minor0 = minor0 - row2 * tmp1;\n-    let minor2 = row0 * tmp1 - minor2;\n-    let minor2 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(minor2, minor2);\n+    let tmp = (row3 * row1.rotate_right::<2>())\n+        .reverse()\n+        .rotate_right::<2>();\n+    let row2 = row2.rotate_right::<2>();\n+    let minor0 = row2 * tmp + minor0;\n+    let minor2 = row0 * tmp;\n+    let tmp = tmp.rotate_right::<2>();\n+    let minor0 = minor0 - row2 * tmp;\n+    let minor2 = row0 * tmp - minor2;\n+    let minor2 = minor2.rotate_right::<2>();\n \n-    let tmp1 = row0 * row1;\n-    let tmp1 = f32x4::shuffle::<{ [1, 0, 3, 2] }>(tmp1, tmp1);\n-    let minor2 = minor2 + row3 * tmp1;\n-    let minor3 = row2 * tmp1 - minor3;\n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(tmp1, tmp1);\n-    let minor2 = row3 * tmp1 - minor2;\n-    let minor3 = minor3 - row2 * tmp1;\n+    let tmp = (row0 * row1).reverse().rotate_right::<2>();\n+    let minor2 = minor2 + row3 * tmp;\n+    let minor3 = row2 * tmp - minor3;\n+    let tmp = tmp.rotate_right::<2>();\n+    let minor2 = row3 * tmp - minor2;\n+    let minor3 = minor3 - row2 * tmp;\n \n-    let tmp1 = row0 * row3;\n-    let tmp1 = f32x4::shuffle::<{ [1, 0, 3, 2] }>(tmp1, tmp1);\n-    let minor1 = minor1 - row2 * tmp1;\n-    let minor2 = row1 * tmp1 + minor2;\n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(tmp1, tmp1);\n-    let minor1 = row2 * tmp1 + minor1;\n-    let minor2 = minor2 - row1 * tmp1;\n+    let tmp = (row0 * row3).reverse().rotate_right::<2>();\n+    let minor1 = minor1 - row2 * tmp;\n+    let minor2 = row1 * tmp + minor2;\n+    let tmp = tmp.rotate_right::<2>();\n+    let minor1 = row2 * tmp + minor1;\n+    let minor2 = minor2 - row1 * tmp;\n \n-    let tmp1 = row0 * row2;\n-    let tmp1 = f32x4::shuffle::<{ [1, 0, 3, 2] }>(tmp1, tmp1);\n-    let minor1 = row3 * tmp1 + minor1;\n-    let minor3 = minor3 - row1 * tmp1;\n-    let tmp1 = f32x4::shuffle::<{ [2, 3, 0, 1] }>(tmp1, tmp1);\n-    let minor1 = minor1 - row3 * tmp1;\n-    let minor3 = row1 * tmp1 + minor3;\n+    let tmp = (row0 * row2).reverse().rotate_right::<2>();\n+    let minor1 = row3 * tmp + minor1;\n+    let minor3 = minor3 - row1 * tmp;\n+    let tmp = tmp.rotate_right::<2>();\n+    let minor1 = minor1 - row3 * tmp;\n+    let minor3 = row1 * tmp + minor3;\n \n     let det = row0 * minor0;\n-    let det = f32x4::shuffle::<{ [2, 3, 0, 1] }>(det, det) + det;\n-    let det = f32x4::shuffle::<{ [1, 0, 3, 2] }>(det, det) + det;\n+    let det = det.rotate_right::<2>() + det;\n+    let det = det.reverse().rotate_right::<2>() + det;\n \n     if det.horizontal_sum() == 0. {\n         return None;\n     }\n     // calculate the reciprocal\n-    let tmp1 = f32x4::splat(1.0) / det;\n-    let det = tmp1 + tmp1 - det * tmp1 * tmp1;\n+    let tmp = f32x4::splat(1.0) / det;\n+    let det = tmp + tmp - det * tmp * tmp;\n \n     let res0 = minor0 * det;\n     let res1 = minor1 * det;"}, {"sha": "5f55cdf0399e35278bff22b34f79c47e2dfd1485", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "patch": "@@ -54,11 +54,7 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_ge<T, U>(x: T, y: T) -> U;\n \n     // shufflevector\n-    pub(crate) fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n-    pub(crate) fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n-    pub(crate) fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n-    pub(crate) fn simd_shuffle16<T, U>(x: T, y: T, idx: [u32; 16]) -> U;\n-    pub(crate) fn simd_shuffle32<T, U>(x: T, y: T, idx: [u32; 32]) -> U;\n+    pub(crate) fn simd_shuffle<T, U, V>(x: T, y: T, idx: U) -> V;\n \n     pub(crate) fn simd_gather<T, U, V>(val: T, ptr: U, mask: V) -> T;\n     pub(crate) fn simd_scatter<T, U, V>(val: T, ptr: U, mask: V);"}, {"sha": "55b8be97e0eed6aefb57de47378bfb4b438804fb", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "patch": "@@ -3,6 +3,7 @@\n #![feature(\n     adt_const_params,\n     const_fn_trait_bound,\n+    const_panic,\n     platform_intrinsics,\n     repr_simd,\n     simd_ffi,"}, {"sha": "ec874a22389d4e789281a2b15e2afe893b341de0", "filename": "crates/core_simd/src/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmod.rs?ref=10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "patch": "@@ -1,8 +1,9 @@\n #[macro_use]\n-mod permute;\n-#[macro_use]\n mod reduction;\n \n+#[macro_use]\n+mod swizzle;\n+\n pub(crate) mod intrinsics;\n \n #[cfg(feature = \"generic_const_exprs\")]\n@@ -27,5 +28,6 @@ pub mod simd {\n     pub use crate::core_simd::lane_count::{LaneCount, SupportedLaneCount};\n     pub use crate::core_simd::masks::*;\n     pub use crate::core_simd::select::Select;\n+    pub use crate::core_simd::swizzle::*;\n     pub use crate::core_simd::vector::*;\n }"}, {"sha": "3e31c3365e884f6948bf90e3431cd9cd4b4bd7a2", "filename": "crates/core_simd/src/permute.rs", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/a16b481a08a3d7560f9c92370f18f6ee8c006c9e/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16b481a08a3d7560f9c92370f18f6ee8c006c9e/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=a16b481a08a3d7560f9c92370f18f6ee8c006c9e", "patch": "@@ -1,154 +0,0 @@\n-use crate::simd::intrinsics;\n-use crate::simd::{Simd, SimdElement};\n-\n-macro_rules! impl_shuffle_lane {\n-    { $fn:ident, $n:literal } => {\n-        impl<T> Simd<T, $n>\n-        where\n-            T: SimdElement,\n-        {\n-            /// A const SIMD shuffle that takes 2 SIMD vectors and produces another vector, using\n-            /// the indices in the const parameter. The first or \"self\" vector will have its lanes\n-            /// indexed from 0, and the second vector will have its first lane indexed at $n.\n-            /// Indices must be in-bounds of either vector at compile time.\n-            ///\n-            /// Some SIMD shuffle instructions can be quite slow, so avoiding them by loading data\n-            /// into the desired patterns in advance is preferred, but shuffles are still faster\n-            /// than storing and reloading from memory.\n-            ///\n-            /// ```\n-            /// #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n-            /// let a = Simd::from_array([1.0, 2.0, 3.0, 4.0]);\n-            /// let b = Simd::from_array([5.0, 6.0, 7.0, 8.0]);\n-            /// const IDXS: [u32; 4] = [4,0,3,7];\n-            /// let c = Simd::<_, 4>::shuffle::<IDXS>(a,b);\n-            /// assert_eq!(Simd::from_array([5.0, 1.0, 4.0, 8.0]), c);\n-            /// ```\n-            #[inline]\n-            pub fn shuffle<const IDX: [u32; $n]>(self, second: Self) -> Self {\n-                unsafe { intrinsics::$fn(self, second, IDX) }\n-            }\n-\n-            /// Reverse the order of the lanes in the vector.\n-            #[inline]\n-            pub fn reverse(self) -> Self {\n-                const fn idx() -> [u32; $n] {\n-                    let mut idx = [0u32; $n];\n-                    let mut i = 0;\n-                    while i < $n {\n-                        idx[i] = ($n - i - 1) as u32;\n-                        i += 1;\n-                    }\n-                    idx\n-                }\n-                self.shuffle::<{ idx() }>(self)\n-            }\n-\n-            /// Interleave two vectors.\n-            ///\n-            /// Produces two vectors with lanes taken alternately from `self` and `other`.\n-            ///\n-            /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n-            /// alternating, starting with the first lane of `self`.\n-            ///\n-            /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n-            /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n-            ///\n-            /// This particular permutation is efficient on many architectures.\n-            ///\n-            /// ```\n-            /// #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n-            /// let a = Simd::from_array([0, 1, 2, 3]);\n-            /// let b = Simd::from_array([4, 5, 6, 7]);\n-            /// let (x, y) = a.interleave(b);\n-            /// assert_eq!(x.to_array(), [0, 4, 1, 5]);\n-            /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n-            /// ```\n-            #[inline]\n-            pub fn interleave(self, other: Self) -> (Self, Self) {\n-                const fn lo() -> [u32; $n] {\n-                    let mut idx = [0u32; $n];\n-                    let mut i = 0;\n-                    while i < $n {\n-                        let offset = i / 2;\n-                        idx[i] = if i % 2 == 0 {\n-                            offset\n-                        } else {\n-                            $n + offset\n-                        } as u32;\n-                        i += 1;\n-                    }\n-                    idx\n-                }\n-                const fn hi() -> [u32; $n] {\n-                    let mut idx = [0u32; $n];\n-                    let mut i = 0;\n-                    while i < $n {\n-                        let offset = ($n + i) / 2;\n-                        idx[i] = if i % 2 == 0 {\n-                            offset\n-                        } else {\n-                            $n + offset\n-                        } as u32;\n-                        i += 1;\n-                    }\n-                    idx\n-                }\n-                (self.shuffle::<{ lo() }>(other), self.shuffle::<{ hi() }>(other))\n-            }\n-\n-            /// Deinterleave two vectors.\n-            ///\n-            /// The first result takes every other lane of `self` and then `other`, starting with\n-            /// the first lane.\n-            ///\n-            /// The second result takes every other lane of `self` and then `other`, starting with\n-            /// the second lane.\n-            ///\n-            /// This particular permutation is efficient on many architectures.\n-            ///\n-            /// ```\n-            /// #![feature(portable_simd)]\n-            /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n-            /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n-            /// let a = Simd::from_array([0, 4, 1, 5]);\n-            /// let b = Simd::from_array([2, 6, 3, 7]);\n-            /// let (x, y) = a.deinterleave(b);\n-            /// assert_eq!(x.to_array(), [0, 1, 2, 3]);\n-            /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n-            /// ```\n-            #[inline]\n-            pub fn deinterleave(self, other: Self) -> (Self, Self) {\n-                const fn even() -> [u32; $n] {\n-                    let mut idx = [0u32; $n];\n-                    let mut i = 0;\n-                    while i < $n {\n-                        idx[i] = 2 * i as u32;\n-                        i += 1;\n-                    }\n-                    idx\n-                }\n-                const fn odd() -> [u32; $n] {\n-                    let mut idx = [0u32; $n];\n-                    let mut i = 0;\n-                    while i < $n {\n-                        idx[i] = 1 + 2 * i as u32;\n-                        i += 1;\n-                    }\n-                    idx\n-                }\n-                (self.shuffle::<{ even() }>(other), self.shuffle::<{ odd() }>(other))\n-            }\n-        }\n-    }\n-}\n-\n-impl_shuffle_lane! { simd_shuffle2, 2 }\n-impl_shuffle_lane! { simd_shuffle4, 4 }\n-impl_shuffle_lane! { simd_shuffle8, 8 }\n-impl_shuffle_lane! { simd_shuffle16, 16 }\n-impl_shuffle_lane! { simd_shuffle32, 32 }"}, {"sha": "048945ddffa86afbc94b7b96503b368e7c24b8d7", "filename": "crates/core_simd/src/swizzle.rs", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fswizzle.rs?ref=10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "patch": "@@ -0,0 +1,364 @@\n+use crate::simd::intrinsics;\n+use crate::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+\n+/// Rearrange vector elements.\n+///\n+/// A new vector is constructed by specifying the the lanes of the source vector or vectors to use.\n+///\n+/// When shuffling one vector, the indices of the result vector are indicated by a `const` array\n+/// of `usize`, like [`Swizzle`].\n+/// When shuffling two vectors, the indices are indicated by a `const` array of [`Which`], like\n+/// [`Swizzle2`].\n+///\n+/// # Examples\n+/// ## One source vector\n+/// ```\n+/// # #![feature(portable_simd)]\n+/// # use core_simd::{Simd, simd_shuffle};\n+/// let v = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n+/// let v = simd_shuffle!(v, [3, 0, 1, 2]);\n+/// assert_eq!(v.to_array(), [3., 0., 1., 2.]);\n+/// ```\n+///\n+/// ## Two source vectors\n+/// ```\n+/// # #![feature(portable_simd)]\n+/// # use core_simd::{Simd, simd_shuffle, Which};\n+/// use Which::*;\n+/// let a = Simd::<f32, 4>::from_array([0., 1., 2., 3.]);\n+/// let b = Simd::<f32, 4>::from_array([4., 5., 6., 7.]);\n+/// let v = simd_shuffle!(a, b, [First(0), First(1), Second(2), Second(3)]);\n+/// assert_eq!(v.to_array(), [0., 1., 6., 7.]);\n+/// ```\n+#[macro_export]\n+macro_rules! simd_shuffle {\n+    {\n+        $vector:expr, $index:expr $(,)?\n+    } => {\n+        {\n+            // FIXME this won't work when we are in `core`!\n+            use $crate::Swizzle;\n+            struct Shuffle;\n+            impl Swizzle<{$index.len()}, {$index.len()}> for Shuffle {\n+                const INDEX: [usize; {$index.len()}] = $index;\n+            }\n+            Shuffle::swizzle($vector)\n+        }\n+    };\n+    {\n+        $first:expr, $second:expr, $index:expr $(,)?\n+    } => {\n+        {\n+            // FIXME this won't work when we are in `core`!\n+            use $crate::{Which, Swizzle2};\n+            struct Shuffle;\n+            impl Swizzle2<{$index.len()}, {$index.len()}> for Shuffle {\n+                const INDEX: [Which; {$index.len()}] = $index;\n+            }\n+            Shuffle::swizzle2($first, $second)\n+        }\n+    }\n+}\n+\n+/// An index into one of two vectors.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Which {\n+    /// Indexes the first vector.\n+    First(usize),\n+    /// Indexes the second vector.\n+    Second(usize),\n+}\n+\n+/// Create a vector from the elements of another vector.\n+pub trait Swizzle<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    /// Map from the lanes of the input vector to the output vector.\n+    const INDEX: [usize; OUTPUT_LANES];\n+\n+    /// Create a new vector from the lanes of `vector`.\n+    ///\n+    /// Lane `i` of the output is `vector[Self::INDEX[i]]`.\n+    fn swizzle<T>(vector: Simd<T, INPUT_LANES>) -> Simd<T, OUTPUT_LANES>\n+    where\n+        T: SimdElement,\n+        LaneCount<INPUT_LANES>: SupportedLaneCount,\n+        LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n+    {\n+        unsafe { intrinsics::simd_shuffle(vector, vector, Self::INDEX_IMPL) }\n+    }\n+}\n+\n+/// Create a vector from the elements of two other vectors.\n+pub trait Swizzle2<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    /// Map from the lanes of the input vectors to the output vector\n+    const INDEX: [Which; OUTPUT_LANES];\n+\n+    /// Create a new vector from the lanes of `first` and `second`.\n+    ///\n+    /// Lane `i` is `first[j]` when `Self::INDEX[i]` is `First(j)`, or `second[j]` when it is\n+    /// `Second(j)`.\n+    fn swizzle2<T>(\n+        first: Simd<T, INPUT_LANES>,\n+        second: Simd<T, INPUT_LANES>,\n+    ) -> Simd<T, OUTPUT_LANES>\n+    where\n+        T: SimdElement,\n+        LaneCount<INPUT_LANES>: SupportedLaneCount,\n+        LaneCount<OUTPUT_LANES>: SupportedLaneCount,\n+    {\n+        unsafe { intrinsics::simd_shuffle(first, second, Self::INDEX_IMPL) }\n+    }\n+}\n+\n+/// The `simd_shuffle` intrinsic expects `u32`, so do error checking and conversion here.\n+trait SwizzleImpl<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    const INDEX_IMPL: [u32; OUTPUT_LANES];\n+}\n+\n+impl<T, const INPUT_LANES: usize, const OUTPUT_LANES: usize> SwizzleImpl<INPUT_LANES, OUTPUT_LANES>\n+    for T\n+where\n+    T: Swizzle<INPUT_LANES, OUTPUT_LANES> + ?Sized,\n+{\n+    const INDEX_IMPL: [u32; OUTPUT_LANES] = {\n+        let mut output = [0; OUTPUT_LANES];\n+        let mut i = 0;\n+        while i < OUTPUT_LANES {\n+            let index = Self::INDEX[i];\n+            assert!(index as u32 as usize == index);\n+            assert!(index < INPUT_LANES, \"source lane exceeds input lane count\",);\n+            output[i] = index as u32;\n+            i += 1;\n+        }\n+        output\n+    };\n+}\n+\n+/// The `simd_shuffle` intrinsic expects `u32`, so do error checking and conversion here.\n+trait Swizzle2Impl<const INPUT_LANES: usize, const OUTPUT_LANES: usize> {\n+    const INDEX_IMPL: [u32; OUTPUT_LANES];\n+}\n+\n+impl<T, const INPUT_LANES: usize, const OUTPUT_LANES: usize> Swizzle2Impl<INPUT_LANES, OUTPUT_LANES>\n+    for T\n+where\n+    T: Swizzle2<INPUT_LANES, OUTPUT_LANES> + ?Sized,\n+{\n+    const INDEX_IMPL: [u32; OUTPUT_LANES] = {\n+        let mut output = [0; OUTPUT_LANES];\n+        let mut i = 0;\n+        while i < OUTPUT_LANES {\n+            let (offset, index) = match Self::INDEX[i] {\n+                Which::First(index) => (false, index),\n+                Which::Second(index) => (true, index),\n+            };\n+            assert!(index < INPUT_LANES, \"source lane exceeds input lane count\",);\n+\n+            // lanes are indexed by the first vector, then second vector\n+            let index = if offset { index + INPUT_LANES } else { index };\n+            assert!(index as u32 as usize == index);\n+            output[i] = index as u32;\n+            i += 1;\n+        }\n+        output\n+    };\n+}\n+\n+impl<T, const LANES: usize> Simd<T, LANES>\n+where\n+    T: SimdElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+    /// Reverse the order of the lanes in the vector.\n+    #[inline]\n+    pub fn reverse(self) -> Self {\n+        const fn reverse_index<const LANES: usize>() -> [usize; LANES] {\n+            let mut index = [0; LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                index[i] = LANES - i - 1;\n+                i += 1;\n+            }\n+            index\n+        }\n+\n+        struct Reverse;\n+\n+        impl<const LANES: usize> Swizzle<LANES, LANES> for Reverse {\n+            const INDEX: [usize; LANES] = reverse_index::<LANES>();\n+        }\n+\n+        Reverse::swizzle(self)\n+    }\n+\n+    /// Rotates the vector such that the first `OFFSET` elements of the slice move to the end\n+    /// while the last `LANES - OFFSET` elements move to the front. After calling `rotate_left`, the\n+    /// element previously in lane `OFFSET` will become the first element in the slice.\n+    #[inline]\n+    pub fn rotate_left<const OFFSET: usize>(self) -> Self {\n+        const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n+            let offset = OFFSET % LANES;\n+            let mut index = [0; LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                index[i] = (i + offset) % LANES;\n+                i += 1;\n+            }\n+            index\n+        }\n+\n+        struct Rotate<const OFFSET: usize>;\n+\n+        impl<const OFFSET: usize, const LANES: usize> Swizzle<LANES, LANES> for Rotate<OFFSET> {\n+            const INDEX: [usize; LANES] = rotate_index::<OFFSET, LANES>();\n+        }\n+\n+        Rotate::<OFFSET>::swizzle(self)\n+    }\n+\n+    /// Rotates the vector such that the first `LANES - OFFSET` elements of the vector move to\n+    /// the end while the last `OFFSET` elements move to the front. After calling `rotate_right`, the\n+    /// element previously at index `LANES - OFFSET` will become the first element in the slice.\n+    #[inline]\n+    pub fn rotate_right<const OFFSET: usize>(self) -> Self {\n+        const fn rotate_index<const OFFSET: usize, const LANES: usize>() -> [usize; LANES] {\n+            let offset = LANES - OFFSET % LANES;\n+            let mut index = [0; LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                index[i] = (i + offset) % LANES;\n+                i += 1;\n+            }\n+            index\n+        }\n+\n+        struct Rotate<const OFFSET: usize>;\n+\n+        impl<const OFFSET: usize, const LANES: usize> Swizzle<LANES, LANES> for Rotate<OFFSET> {\n+            const INDEX: [usize; LANES] = rotate_index::<OFFSET, LANES>();\n+        }\n+\n+        Rotate::<OFFSET>::swizzle(self)\n+    }\n+\n+    /// Interleave two vectors.\n+    ///\n+    /// Produces two vectors with lanes taken alternately from `self` and `other`.\n+    ///\n+    /// The first result contains the first `LANES / 2` lanes from `self` and `other`,\n+    /// alternating, starting with the first lane of `self`.\n+    ///\n+    /// The second result contains the last `LANES / 2` lanes from `self` and `other`,\n+    /// alternating, starting with the lane `LANES / 2` from the start of `self`.\n+    ///\n+    /// This particular permutation is efficient on many architectures.\n+    ///\n+    /// ```\n+    /// #![feature(portable_simd)]\n+    /// # use core_simd::Simd;\n+    /// let a = Simd::from_array([0, 1, 2, 3]);\n+    /// let b = Simd::from_array([4, 5, 6, 7]);\n+    /// let (x, y) = a.interleave(b);\n+    /// assert_eq!(x.to_array(), [0, 4, 1, 5]);\n+    /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n+    /// ```\n+    #[inline]\n+    pub fn interleave(self, other: Self) -> (Self, Self) {\n+        const fn lo<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                let offset = i / 2;\n+                idx[i] = if i % 2 == 0 {\n+                    Which::First(offset)\n+                } else {\n+                    Which::Second(offset)\n+                };\n+                i += 1;\n+            }\n+            idx\n+        }\n+        const fn hi<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES {\n+                let offset = (LANES + i) / 2;\n+                idx[i] = if i % 2 == 0 {\n+                    Which::First(offset)\n+                } else {\n+                    Which::Second(offset)\n+                };\n+                i += 1;\n+            }\n+            idx\n+        }\n+\n+        struct Lo;\n+        struct Hi;\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Lo {\n+            const INDEX: [Which; LANES] = lo::<LANES>();\n+        }\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Hi {\n+            const INDEX: [Which; LANES] = hi::<LANES>();\n+        }\n+\n+        (Lo::swizzle2(self, other), Hi::swizzle2(self, other))\n+    }\n+\n+    /// Deinterleave two vectors.\n+    ///\n+    /// The first result takes every other lane of `self` and then `other`, starting with\n+    /// the first lane.\n+    ///\n+    /// The second result takes every other lane of `self` and then `other`, starting with\n+    /// the second lane.\n+    ///\n+    /// This particular permutation is efficient on many architectures.\n+    ///\n+    /// ```\n+    /// #![feature(portable_simd)]\n+    /// # use core_simd::Simd;\n+    /// let a = Simd::from_array([0, 4, 1, 5]);\n+    /// let b = Simd::from_array([2, 6, 3, 7]);\n+    /// let (x, y) = a.deinterleave(b);\n+    /// assert_eq!(x.to_array(), [0, 1, 2, 3]);\n+    /// assert_eq!(y.to_array(), [4, 5, 6, 7]);\n+    /// ```\n+    #[inline]\n+    pub fn deinterleave(self, other: Self) -> (Self, Self) {\n+        const fn even<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES / 2 {\n+                idx[i] = Which::First(2 * i);\n+                idx[i + LANES / 2] = Which::Second(2 * i);\n+                i += 1;\n+            }\n+            idx\n+        }\n+        const fn odd<const LANES: usize>() -> [Which; LANES] {\n+            let mut idx = [Which::First(0); LANES];\n+            let mut i = 0;\n+            while i < LANES / 2 {\n+                idx[i] = Which::First(2 * i + 1);\n+                idx[i + LANES / 2] = Which::Second(2 * i + 1);\n+                i += 1;\n+            }\n+            idx\n+        }\n+\n+        struct Even;\n+        struct Odd;\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Even {\n+            const INDEX: [Which; LANES] = even::<LANES>();\n+        }\n+\n+        impl<const LANES: usize> Swizzle2<LANES, LANES> for Odd {\n+            const INDEX: [Which; LANES] = odd::<LANES>();\n+        }\n+\n+        (Even::swizzle2(self, other), Odd::swizzle2(self, other))\n+    }\n+}"}, {"sha": "ea52e8f5ca7348dff1baa1054432f92279a30b34", "filename": "crates/core_simd/tests/permute.rs", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a16b481a08a3d7560f9c92370f18f6ee8c006c9e/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a16b481a08a3d7560f9c92370f18f6ee8c006c9e/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fpermute.rs?ref=a16b481a08a3d7560f9c92370f18f6ee8c006c9e", "patch": "@@ -1,37 +0,0 @@\n-#![feature(portable_simd)]\n-\n-use core_simd::Simd;\n-\n-#[cfg(target_arch = \"wasm32\")]\n-use wasm_bindgen_test::*;\n-\n-#[cfg(target_arch = \"wasm32\")]\n-wasm_bindgen_test_configure!(run_in_browser);\n-\n-#[test]\n-#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-fn simple_shuffle() {\n-    let a = Simd::from_array([2, 4, 1, 9]);\n-    let b = a;\n-    assert_eq!(a.shuffle::<{ [3, 1, 4, 6] }>(b).to_array(), [9, 4, 2, 1]);\n-}\n-\n-#[test]\n-#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-fn reverse() {\n-    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n-    assert_eq!(a.reverse().to_array(), [7, 6, 5, 4, 3, 2, 1, 0]);\n-}\n-\n-#[test]\n-#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n-fn interleave() {\n-    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n-    let b = Simd::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n-    let (lo, hi) = a.interleave(b);\n-    assert_eq!(lo.to_array(), [0, 8, 1, 9, 2, 10, 3, 11]);\n-    assert_eq!(hi.to_array(), [4, 12, 5, 13, 6, 14, 7, 15]);\n-    let (even, odd) = lo.deinterleave(hi);\n-    assert_eq!(even, a);\n-    assert_eq!(odd, b);\n-}"}, {"sha": "d4abc46b9327448f33f8829359754d0e093e5909", "filename": "crates/core_simd/tests/swizzle.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Ftests%2Fswizzle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10168fb7c4ab6e8f02627331cc472a7a2b83c11b/crates%2Fcore_simd%2Ftests%2Fswizzle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fswizzle.rs?ref=10168fb7c4ab6e8f02627331cc472a7a2b83c11b", "patch": "@@ -0,0 +1,62 @@\n+#![feature(portable_simd)]\n+use core_simd::{Simd, Swizzle};\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn swizzle() {\n+    struct Index;\n+    impl Swizzle<4, 4> for Index {\n+        const INDEX: [usize; 4] = [2, 1, 3, 0];\n+    }\n+    impl Swizzle<4, 2> for Index {\n+        const INDEX: [usize; 2] = [1, 1];\n+    }\n+\n+    let vector = Simd::from_array([2, 4, 1, 9]);\n+    assert_eq!(Index::swizzle(vector).to_array(), [1, 4, 9, 2]);\n+    assert_eq!(Index::swizzle(vector).to_array(), [4, 4]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn reverse() {\n+    let a = Simd::from_array([1, 2, 3, 4]);\n+    assert_eq!(a.reverse().to_array(), [4, 3, 2, 1]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn rotate() {\n+    let a = Simd::from_array([1, 2, 3, 4]);\n+    assert_eq!(a.rotate_left::<0>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_left::<1>().to_array(), [2, 3, 4, 1]);\n+    assert_eq!(a.rotate_left::<2>().to_array(), [3, 4, 1, 2]);\n+    assert_eq!(a.rotate_left::<3>().to_array(), [4, 1, 2, 3]);\n+    assert_eq!(a.rotate_left::<4>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_left::<5>().to_array(), [2, 3, 4, 1]);\n+    assert_eq!(a.rotate_right::<0>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_right::<1>().to_array(), [4, 1, 2, 3]);\n+    assert_eq!(a.rotate_right::<2>().to_array(), [3, 4, 1, 2]);\n+    assert_eq!(a.rotate_right::<3>().to_array(), [2, 3, 4, 1]);\n+    assert_eq!(a.rotate_right::<4>().to_array(), [1, 2, 3, 4]);\n+    assert_eq!(a.rotate_right::<5>().to_array(), [4, 1, 2, 3]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn interleave() {\n+    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let b = Simd::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n+    let (lo, hi) = a.interleave(b);\n+    assert_eq!(lo.to_array(), [0, 8, 1, 9, 2, 10, 3, 11]);\n+    assert_eq!(hi.to_array(), [4, 12, 5, 13, 6, 14, 7, 15]);\n+    let (even, odd) = lo.deinterleave(hi);\n+    assert_eq!(even, a);\n+    assert_eq!(odd, b);\n+}"}]}