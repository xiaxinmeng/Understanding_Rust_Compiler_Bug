{"sha": "eb0a34c39865d456a776fc8e81ba780dd383f315", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMGEzNGMzOTg2NWQ0NTZhNzc2ZmM4ZTgxYmE3ODBkZDM4M2YzMTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-18T17:17:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-18T18:48:58Z"}, "message": "iterate only over immutable vectors; use newer region notation\n\nUnfortunately, right now iterating over const vectors is\nnot safe.  This is because the callback expects an *immutable*\nreference (in region terms: &T), not a const reference (&const T).\nThis was not being caught by the type system due to the use of\nunsafe operations.  To fix this, we need to either (1) find a way\nto parameterize over mutability or (2) add each_const, each_mut\netc", "tree": {"sha": "1e5144370e3b2efe267eb6d34a09ba827dc8caf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e5144370e3b2efe267eb6d34a09ba827dc8caf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb0a34c39865d456a776fc8e81ba780dd383f315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb0a34c39865d456a776fc8e81ba780dd383f315", "html_url": "https://github.com/rust-lang/rust/commit/eb0a34c39865d456a776fc8e81ba780dd383f315", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb0a34c39865d456a776fc8e81ba780dd383f315/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f3bbd57c08bc29cb95f84a764f85d07b14899f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3bbd57c08bc29cb95f84a764f85d07b14899f6", "html_url": "https://github.com/rust-lang/rust/commit/7f3bbd57c08bc29cb95f84a764f85d07b14899f6"}], "stats": {"total": 41, "additions": 21, "deletions": 20}, "files": [{"sha": "28f0726441055e8489c8ed713d10c188d9b0ea15", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=eb0a34c39865d456a776fc8e81ba780dd383f315", "patch": "@@ -56,7 +56,7 @@ fn arc<T: const send>(-data: T) -> arc<T> {\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-fn get<T: const send>(rc: &a.arc<T>) -> &a.T {\n+fn get<T: const send>(rc: &arc<T>) -> &T {\n     unsafe {\n         let ptr: ~arc_data<T> = unsafe::reinterpret_cast((*rc).data);\n         // Cast us back into the correct region"}, {"sha": "e9a6f4f16945a818e1cc6b0829e004a347925fe2", "filename": "src/libcore/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=eb0a34c39865d456a776fc8e81ba780dd383f315", "patch": "@@ -229,7 +229,7 @@ pure fn from_char(ch: char) -> ~str {\n }\n \n /// Convert a vector of chars to a string\n-pure fn from_chars(chs: &[const char]) -> ~str {\n+pure fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n     unchecked {\n         reserve(buf, chs.len());\n@@ -283,14 +283,14 @@ pure fn append(+lhs: ~str, rhs: &str) -> ~str {\n \n \n /// Concatenate a vector of strings\n-pure fn concat(v: &[const ~str]) -> ~str {\n+pure fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| { unchecked { push_str(s, ss) }; }\n     ret s;\n }\n \n /// Concatenate a vector of strings, placing a given separator between each\n-pure fn connect(v: &[const ~str], sep: ~str) -> ~str {\n+pure fn connect(v: &[~str], sep: ~str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n         if first { first = false; } else { unchecked { push_str(s, sep); } }\n@@ -1288,7 +1288,7 @@ Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pure fn is_utf8(v: &[const u8]) -> bool {\n+pure fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -1306,7 +1306,7 @@ pure fn is_utf8(v: &[const u8]) -> bool {\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n-pure fn is_utf16(v: &[const u16]) -> bool {\n+pure fn is_utf16(v: &[u16]) -> bool {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len) {\n@@ -1349,7 +1349,7 @@ pure fn to_utf16(s: &str) -> ~[u16] {\n     ret u;\n }\n \n-pure fn utf16_chars(v: &[const u16], f: fn(char)) {\n+pure fn utf16_chars(v: &[u16], f: fn(char)) {\n     let len = vec::len(v);\n     let mut i = 0u;\n     while (i < len && v[i] != 0u16) {\n@@ -1374,7 +1374,7 @@ pure fn utf16_chars(v: &[const u16], f: fn(char)) {\n }\n \n \n-pure fn from_utf16(v: &[const u16]) -> ~str {\n+pure fn from_utf16(v: &[u16]) -> ~str {\n     let mut buf = ~\"\";\n     unchecked {\n         reserve(buf, vec::len(v));"}, {"sha": "c4e8ad6425cd709d0612e0a576b19678500d2f36", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=eb0a34c39865d456a776fc8e81ba780dd383f315", "patch": "@@ -314,7 +314,7 @@ pure fn slice<T: copy>(v: &[const T], start: uint, end: uint) -> ~[T] {\n }\n \n #[doc = \"Return a slice that points into another slice.\"]\n-pure fn view<T>(v: &a.[T], start: uint, end: uint) -> &a.[T] {\n+pure fn view<T>(v: &[T], start: uint, end: uint) -> &[T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     do unpack_slice(v) |p, _len| {\n@@ -1054,7 +1054,7 @@ pure fn iter_between<T>(v: &[T], start: uint, end: uint, f: fn(T)) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n+pure fn each<T>(v: &[T], f: fn(T) -> bool) {\n     do vec::unpack_slice(v) |p, n| {\n         let mut n = n;\n         let mut p = p;\n@@ -1074,7 +1074,7 @@ pure fn each<T>(v: &[const T], f: fn(T) -> bool) {\n  * Return true to continue, false to break.\n  */\n #[inline(always)]\n-pure fn eachi<T>(v: &[const T], f: fn(uint, T) -> bool) {\n+pure fn eachi<T>(v: &[T], f: fn(uint, T) -> bool) {\n     do vec::unpack_slice(v) |p, n| {\n         let mut i = 0u;\n         let mut p = p;\n@@ -1331,7 +1331,7 @@ impl extensions/&<T: copy> of copyable_vector<T> for &[const T] {\n     pure fn tail() -> ~[T] { tail(self) }\n }\n \n-trait immutable_vector/&<T> {\n+trait immutable_vector<T> {\n     pure fn foldr<U: copy>(z: U, p: fn(T, U) -> U) -> U;\n     pure fn iter(f: fn(T));\n     pure fn iteri(f: fn(uint, T));\n@@ -1343,7 +1343,7 @@ trait immutable_vector/&<T> {\n     pure fn rposition_elem(x: T) -> option<uint>;\n     pure fn map<U>(f: fn(T) -> U) -> ~[U];\n     pure fn mapi<U>(f: fn(uint, T) -> U) -> ~[U];\n-    fn map_r<U>(f: fn(x: &self.T) -> U) -> ~[U];\n+    fn map_r<U>(f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(f: fn(uint, T) -> bool) -> bool;\n     pure fn flat_map<U>(f: fn(T) -> ~[U]) -> ~[U];\n     pure fn filter_map<U: copy>(f: fn(T) -> option<U>) -> ~[U];\n@@ -1422,7 +1422,7 @@ impl extensions/&<T> of immutable_vector<T> for &[T] {\n     }\n \n     #[inline]\n-    fn map_r<U>(f: fn(x: &self.T) -> U) -> ~[U] {\n+    fn map_r<U>(f: fn(x: &T) -> U) -> ~[U] {\n         let mut r = ~[];\n         let mut i = 0;\n         while i < self.len() {\n@@ -1570,7 +1570,7 @@ mod unsafe {\n     #[inline(always)]\n     unsafe fn form_slice<T,U>(p: *T, len: uint, f: fn(&& &[T]) -> U) -> U {\n         let pair = (p, len * sys::size_of::<T>());\n-        let v : *(&blk.[T]) =\n+        let v : *(&blk/[T]) =\n             ::unsafe::reinterpret_cast(ptr::addr_of(pair));\n         f(*v)\n     }\n@@ -1638,12 +1638,13 @@ mod u8 {\n //\n // This cannot be used with iter-trait.rs because of the region pointer\n // required in the slice.\n-impl extensions/&<A> of iter::base_iter<A> for &[const A] {\n+\n+impl extensions/&<A> of iter::base_iter<A> for &[A] {\n     fn each(blk: fn(A) -> bool) { each(self, blk) }\n     fn size_hint() -> option<uint> { some(len(self)) }\n }\n \n-impl extensions/&<A> of iter::extended_iter<A> for &[const A] {\n+impl extensions/&<A> of iter::extended_iter<A> for &[A] {\n     fn eachi(blk: fn(uint, A) -> bool) { iter::eachi(self, blk) }\n     fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n@@ -1663,7 +1664,7 @@ trait iter_trait_extensions<A> {\n     fn max() -> A;\n }\n \n-impl extensions/&<A:copy> of iter_trait_extensions<A> for &[const A] {\n+impl extensions/&<A:copy> of iter_trait_extensions<A> for &[A] {\n     fn filter_to_vec(pred: fn(A) -> bool) -> ~[A] {\n         iter::filter_to_vec(self, pred)\n     }"}, {"sha": "b0d0f3074d0edb1686375bb4cefe1ba9ef63970f", "filename": "src/test/run-pass/assignability-iface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb0a34c39865d456a776fc8e81ba780dd383f315/src%2Ftest%2Frun-pass%2Fassignability-iface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-iface.rs?ref=eb0a34c39865d456a776fc8e81ba780dd383f315", "patch": "@@ -6,13 +6,13 @@ iface iterable<A> {\n     fn iterate(blk: fn(A) -> bool);\n }\n \n-impl vec<A> of iterable<A> for &[const A] {\n+impl vec<A> of iterable<A> for &[A] {\n     fn iterate(f: fn(A) -> bool) {\n         vec::each(self, f);\n     }\n }\n \n-impl vec<A> of iterable<A> for ~[const A] {\n+impl vec<A> of iterable<A> for ~[A] {\n     fn iterate(f: fn(A) -> bool) {\n         vec::each(self, f);\n     }"}]}