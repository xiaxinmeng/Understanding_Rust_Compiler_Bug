{"sha": "6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYTRlYWNkZGYyYTA3ZTEzZjY1ODlmMDQzMDNjZTdmYjRjNGQ3MGM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-01T12:35:00Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-01T14:32:44Z"}, "message": "Make resolve recognize upvars\n\nUpvars are now marked with def_upvar throughout, not just when going\nthrough freevars::lookup_def. This makes things less error-prone. One\nthing to watch out for is that def_upvar is used in `for each` bodies\ntoo, when they refer to a local outside the body.", "tree": {"sha": "eaf81d69cf68aa58a97c148df9b9678ad5ff0957", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaf81d69cf68aa58a97c148df9b9678ad5ff0957"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "html_url": "https://github.com/rust-lang/rust/commit/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0", "html_url": "https://github.com/rust-lang/rust/commit/2d1dec78e7fd2fa0a569f797d147d5940e81f3d0"}], "stats": {"total": 476, "additions": 221, "deletions": 255}, "files": [{"sha": "6096695eb2cb869c1aefb76b3e5f185536a8f303", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -155,7 +155,7 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &istr,\n              bind resolve::resolve_crate(sess, ast_map, crate));\n     let freevars =\n         time(time_passes, ~\"freevar finding\",\n-             bind freevars::annotate_freevars(sess, def_map, crate));\n+             bind freevars::annotate_freevars(def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n     time(time_passes, ~\"typechecking\",\n          bind typeck::check_crate(ty_cx, crate));\n@@ -240,7 +240,7 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n         let amap = middle::ast_map::map_crate(*crate);\n         let {def_map: def_map, ext_map: ext_map} =\n             resolve::resolve_crate(sess, amap, crate);\n-        let freevars = freevars::annotate_freevars(sess, def_map, crate);\n+        let freevars = freevars::annotate_freevars(def_map, crate);\n         let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, amap, freevars);\n         typeck::check_crate(ty_cx, crate);\n         ann = {pre: ann_paren_for_expr, post: bind ann_typed_post(ty_cx, _)};"}, {"sha": "f43ab93d4c1fe1ca1c357dc1c40dff5dd3ea9bd9", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 11, "deletions": 34, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -51,47 +51,23 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n     let cx = @{tcx: tcx,\n                local_map: std::map::new_int_hash(),\n                mutable next_local: 0u};\n-    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n+    let v = @{visit_fn: visit_fn,\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_decl: bind visit_decl(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n     visit::visit_crate(*crate, @[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n }\n \n-fn visit_fn(cx: &@ctx, f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n-            _name: &fn_ident, id: ast::node_id, sc: &scope, v: &vt<scope>) {\n+fn visit_fn(f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n+            _name: &fn_ident, _id: ast::node_id, sc: &scope, v: &vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n-    let scope =\n-        alt f.proto {\n-\n-          // Blocks need to obey any restrictions from the enclosing scope.\n-          ast::proto_block. {\n-            sc\n-          }\n-\n-          // Closures need to prohibit writing to any of the upvars.\n-          // This doesn't seem like a particularly clean way to do this.\n-          ast::proto_closure. {\n-            let dnums = [];\n-            for each nid in freevars::get_freevar_defs(cx.tcx, id).keys() {\n-                dnums += [nid];\n-            };\n-            // I'm not sure if there is anything sensical to put here\n-            @[@{root_var: none,\n-                local_id: cx.next_local,\n-                bindings: dnums,\n-                unsafe_ty: none,\n-                depends_on: [],\n-                mutable ok: valid}]\n-          }\n-\n-          // Non capturing functions start out fresh.\n-          _ {\n-            @[]\n-          }\n-        };\n-\n+    let scope = alt f.proto {\n+      // Blocks need to obey any restrictions from the enclosing scope.\n+      ast::proto_block. | ast::proto_closure. { sc }\n+      // Non capturing functions start out fresh.\n+      _ { @[] }\n+    };\n     v.visit_block(f.body, scope, v);\n }\n \n@@ -489,7 +465,8 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n \n fn def_is_local(d: &ast::def, objfields_count: bool) -> bool {\n     ret alt d {\n-      ast::def_local(_) | ast::def_arg(_, _) | ast::def_binding(_) { true }\n+      ast::def_local(_) | ast::def_arg(_, _) | ast::def_binding(_) |\n+      ast::def_upvar(_, _, _) { true }\n       ast::def_obj_field(_, _) { objfields_count }\n       _ { false }\n     };"}, {"sha": "a449c7e34391cb3bb5beb8a5d10f6aa80e29ee10", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 67, "deletions": 117, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -15,127 +15,99 @@ import middle::resolve;\n import syntax::codemap::span;\n \n export annotate_freevars;\n-export freevar_set;\n export freevar_map;\n-export get_freevar_info;\n export get_freevars;\n-export get_freevar_defs;\n export has_freevars;\n-export is_freevar_of;\n-export def_lookup;\n \n-// Throughout the compiler, variables are generally dealt with using the\n-// node_ids of the reference sites and not the def_id of the definition\n-// site. Thus we store a set are the definitions along with a vec of one\n-// \"canonical\" referencing node_id per free variable. The set is useful for\n-// testing membership, the list of referencing sites is what you want for most\n-// other things.\n-type freevar_set = hashset<ast::node_id>;\n-type freevar_info = {defs: freevar_set, refs: @[ast::node_id]};\n+// A vector of defs representing the free variables referred to in a function.\n+// (The def_upvar will already have been stripped).\n+type freevar_info = @[ast::def];\n type freevar_map = hashmap<ast::node_id, freevar_info>;\n \n // Searches through part of the AST for all references to locals or\n // upvars in this frame and returns the list of definition IDs thus found.\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: &resolve::def_map, sess: &session::session,\n-                    walker: &fn(&visit::vt<()>),\n-                    initial_decls: [ast::node_id]) -> freevar_info {\n-    let decls = new_int_hash();\n-    for decl: ast::node_id in initial_decls { set_add(decls, decl); }\n+fn collect_freevars(def_map: &resolve::def_map,\n+                    walker: &fn(&visit::vt<int>)) -> freevar_info {\n+    let seen = new_int_hash();\n     let refs = @mutable [];\n \n-    let walk_fn =\n-        lambda (f: &ast::_fn, _tps: &[ast::ty_param], _sp: &span,\n-                _i: &ast::fn_ident, _nid: ast::node_id) {\n-            for a: ast::arg in f.decl.inputs { set_add(decls, a.id); }\n-        };\n-    let walk_expr =\n-        lambda (expr: &@ast::expr) {\n-            alt expr.node {\n-              ast::expr_path(path) {\n-                if !def_map.contains_key(expr.id) {\n-                    sess.span_fatal(expr.span,\n-                                    ~\"internal error in collect_freevars\");\n-                }\n-                alt def_map.get(expr.id) {\n-                  ast::def_arg(did, _) { *refs += [expr.id]; }\n-                  ast::def_local(did) { *refs += [expr.id]; }\n-                  ast::def_binding(did) { *refs += [expr.id]; }\n-                  _ {/* no-op */ }\n+    fn ignore_item(_i: &@ast::item, _depth: &int, _v: &visit::vt<int>) {}\n+\n+    let walk_expr = lambda(expr: &@ast::expr, depth: &int,\n+                           v: &visit::vt<int>) {\n+        alt expr.node {\n+          ast::expr_fn(f) {\n+            if f.proto == ast::proto_block ||\n+               f.proto == ast::proto_closure {\n+                visit::visit_expr(expr, depth + 1, v);\n+            }\n+          }\n+          ast::expr_for_each(dcl, x, b) {\n+            v.visit_local(dcl, depth, v);\n+            v.visit_expr(x, depth, v);\n+            v.visit_block(b, depth + 1, v);\n+          }\n+          ast::expr_path(path) {\n+            let def = def_map.get(expr.id), i = 0;\n+            while i < depth {\n+                alt {def} {\n+                  ast::def_upvar(_, inner, _) {\n+                    def = *inner;\n+                  }\n+                  _ { break; }\n                 }\n-              }\n-              _ { }\n+                i += 1;\n             }\n-        };\n-    let walk_local =\n-        lambda (local: &@ast::local) {\n-            for each b: @ast::pat in ast_util::pat_bindings(local.node.pat) {\n-                set_add(decls, b.id);\n+            if i == depth { // Made it to end of loop\n+                let dnum = ast_util::def_id_of_def(def).node;\n+                if !seen.contains_key(dnum) {\n+                    *refs += [def];\n+                    seen.insert(dnum, ());\n+                }\n             }\n-        };\n-    let walk_pat =\n-        lambda (p: &@ast::pat) {\n-            alt p.node { ast::pat_bind(_) { set_add(decls, p.id); } _ { } }\n-        };\n-\n-    walker(visit::mk_simple_visitor(@{visit_local: walk_local,\n-                                      visit_pat: walk_pat,\n-                                      visit_expr: walk_expr,\n-                                      visit_fn: walk_fn\n-                                         with\n-                                         *visit::default_simple_visitor()}));\n-    // Calculate (refs - decls). This is the set of captured upvars.\n-    // We build a vec of the node ids of the uses and a set of the\n-    // node ids of the definitions.\n-    let canonical_refs = [];\n-    let defs = new_int_hash();\n-    for ref_id_: ast::node_id in *refs {\n-        let ref_id = ref_id_;\n-        let def_id = ast_util::def_id_of_def(def_map.get(ref_id)).node;\n-        if !decls.contains_key(def_id) && !defs.contains_key(def_id) {\n-            canonical_refs += [ref_id];\n-            set_add(defs, def_id);\n+          }\n+          _ { visit::visit_expr(expr, depth, v); }\n         }\n-    }\n-    ret {defs: defs, refs: @canonical_refs};\n+    };\n+\n+    walker(visit::mk_vt(@{visit_item: ignore_item,\n+                          visit_expr: walk_expr\n+                          with *visit::default_visitor()}));\n+    ret @*refs;\n }\n \n // Build a map from every function and for-each body to a set of the\n // freevars contained in it. The implementation is not particularly\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n+fn annotate_freevars(def_map: &resolve::def_map,\n                      crate: &@ast::crate) -> freevar_map {\n     let freevars = new_int_hash();\n \n-    let walk_fn =\n-        lambda (f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n-                i: &ast::fn_ident, nid: ast::node_id) {\n-            let start_walk =\n-                lambda (v: &visit::vt<()>) {\n-                    v.visit_fn(f, tps, sp, i, nid, (), v);\n-                };\n-            let vars = collect_freevars(def_map, sess, start_walk, []);\n-            freevars.insert(nid, vars);\n-        };\n-    let walk_expr =\n-        lambda (expr: &@ast::expr) {\n-            alt expr.node {\n-              ast::expr_for_each(local, _, body) {\n-                let start_walk =\n-                    lambda (v: &visit::vt<()>) {\n-                        v.visit_block(body, (), v);\n-                    };\n-                let bound = ast_util::pat_binding_ids(local.node.pat);\n-                let vars = collect_freevars(def_map, sess, start_walk, bound);\n-                freevars.insert(body.node.id, vars);\n-              }\n-              _ { }\n-            }\n+    let walk_fn = lambda (f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n+                          i: &ast::fn_ident, nid: ast::node_id) {\n+        let start_walk = lambda (v: &visit::vt<int>) {\n+            v.visit_fn(f, tps, sp, i, nid, 1, v);\n         };\n+        let vars = collect_freevars(def_map, start_walk);\n+        freevars.insert(nid, vars);\n+    };\n+    let walk_expr = lambda (expr: &@ast::expr) {\n+        alt expr.node {\n+          ast::expr_for_each(local, _, body) {\n+            let start_walk = lambda (v: &visit::vt<int>) {\n+                v.visit_block(body, 1, v);\n+            };\n+            let vars = collect_freevars(def_map, start_walk);\n+            freevars.insert(body.node.id, vars);\n+          }\n+          _ { }\n+        }\n+    };\n \n     let visitor =\n         visit::mk_simple_visitor(@{visit_fn: walk_fn, visit_expr: walk_expr\n@@ -145,7 +117,7 @@ fn annotate_freevars(sess: &session::session, def_map: &resolve::def_map,\n     ret freevars;\n }\n \n-fn get_freevar_info(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n+fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n     alt tcx.freevars.find(fid) {\n       none. {\n         fail \"get_freevars: \" + istr::to_estr(int::str(fid))\n@@ -154,31 +126,9 @@ fn get_freevar_info(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n       some(d) { ret d; }\n     }\n }\n-fn get_freevar_defs(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_set {\n-    ret get_freevar_info(tcx, fid).defs;\n-}\n-fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> @[ast::node_id] {\n-    ret get_freevar_info(tcx, fid).refs;\n-}\n fn has_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> bool {\n-    ret get_freevar_defs(tcx, fid).size() != 0u;\n+    ret std::vec::len(*get_freevars(tcx, fid)) != 0u;\n }\n-fn is_freevar_of(tcx: &ty::ctxt, def: ast::node_id, f: ast::node_id) -> bool {\n-    ret get_freevar_defs(tcx, f).contains_key(def);\n-}\n-fn def_lookup(tcx: &ty::ctxt, f: ast::node_id, id: ast::node_id) ->\n-   option::t<ast::def> {\n-    alt tcx.def_map.find(id) {\n-      none. { ret none; }\n-      some(d) {\n-        let did = ast_util::def_id_of_def(d);\n-        if f != -1 && is_freevar_of(tcx, did.node, f) {\n-            ret some(ast::def_upvar(did, @d));\n-        } else { ret some(d); }\n-      }\n-    }\n-}\n-\n \n // Local Variables:\n // mode: rust"}, {"sha": "b2420252efa873e69f6180a136f9fb7295a0cfd4", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -238,14 +238,18 @@ fn check_call(cx: &@ctx, f: &@expr, args: &[@expr]) {\n }\n \n fn is_immutable_def(def: &def) -> option::t<istr> {\n-    ret alt def {\n+    alt def {\n       def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n       def_use(_) { some(~\"static item\") }\n       def_obj_field(_, imm.) { some(~\"immutable object field\") }\n       def_arg(_, alias(false)) { some(~\"immutable alias\") }\n+      def_upvar(_, inner, mut) {\n+        if !mut { some(~\"upvar\") }\n+        else { is_immutable_def(*inner) }\n+      }\n       def_binding(_) { some(~\"binding\") }\n       _ { none }\n-    };\n+    }\n }\n \n // Local Variables:"}, {"sha": "ca688f533ecb634d03c9cf16461d1e42e3746658", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 41, "deletions": 22, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -55,7 +55,7 @@ tag scope {\n     scope_item(@ast::item);\n     scope_fn(ast::fn_decl, ast::proto, [ast::ty_param]);\n     scope_native_item(@ast::native_item);\n-    scope_loop(@ast::local); // there's only 1 decl per loop.\n+    scope_loop(@ast::local, bool); // there's only 1 decl per loop.\n \n     scope_block(ast::blk, @mutable uint, @mutable uint);\n     scope_arm(ast::arm);\n@@ -404,14 +404,12 @@ fn visit_arm_with_scope(a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n     alt x.node {\n       ast::expr_for(decl, coll, blk) | ast::expr_for_each(decl, coll, blk) {\n-        let new_sc = cons::<scope>(scope_loop(decl), @sc);\n+        let f_e = alt x.node { expr_for_each(_, _, _) { true } _ { false } };\n+        let new_sc = cons(scope_loop(decl, f_e), @sc);\n         v.visit_expr(coll, sc, v);\n         v.visit_local(decl, new_sc, v);\n         v.visit_block(blk, new_sc, v);\n       }\n-      ast::expr_fn(f) {\n-        visit::visit_expr(x, cons(scope_fn(f.decl, f.proto, []), @sc), v);\n-      }\n       _ { visit::visit_expr(x, sc, v); }\n     }\n }\n@@ -622,9 +620,18 @@ fn scope_is_fn(sc: &scope) -> bool {\n         };\n }\n \n+fn scope_closes(sc: &scope) -> option::t<bool> {\n+    alt sc {\n+      scope_fn(_, ast::proto_block., _) | scope_loop(_, true) { some(true) }\n+      scope_fn(_, ast::proto_closure., _) { some(false) }\n+      _ { none }\n+    }\n+}\n+\n fn def_is_local(d: &def) -> bool {\n     ret alt d {\n-      ast::def_arg(_, _) | ast::def_local(_) | ast::def_binding(_) { true }\n+      ast::def_arg(_, _) | ast::def_local(_) | ast::def_binding(_) |\n+      ast::def_upvar(_, _, _) { true }\n       _ { false }\n     };\n }\n@@ -675,7 +682,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n           scope_fn(decl, _, ty_params) {\n             ret lookup_in_fn(name, decl, ty_params, ns);\n           }\n-          scope_loop(local) {\n+          scope_loop(local, _) {\n             if ns == ns_value {\n                 alt lookup_in_pat(name, local.node.pat) {\n                   some(did) { ret some(ast::def_binding(did)); }\n@@ -698,8 +705,8 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n         ret none::<def>;\n     }\n     let left_fn = false;\n+    let closing = [];\n     // Used to determine whether obj fields are in scope\n-\n     let left_fn_level2 = false;\n     while true {\n         alt { sc } {\n@@ -708,27 +715,38 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n             let fnd = in_scope(e, sp, name, hd, ns);\n             if !is_none(fnd) {\n                 let df = option::get(fnd);\n-                if left_fn && def_is_local(df) ||\n+                let local = def_is_local(df);\n+                if left_fn && local ||\n                        left_fn_level2 && def_is_obj_field(df) ||\n                        scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n-                    let msg =\n-                        alt ns {\n-                          ns_type. {\n-                            ~\"Attempt to use a type \\\n-                                argument out of scope\"\n-                          }\n-                          _ {\n-                            ~\"attempted dynamic \\\n-                                       environment-capture\"\n-                          }\n-                        };\n+                    let msg = alt ns {\n+                      ns_type. {\n+                        ~\"Attempt to use a type argument out of scope\"\n+                      }\n+                      _ {\n+                        ~\"attempted dynamic environment-capture\"\n+                      }\n+                    };\n                     e.sess.span_fatal(sp, msg);\n+                } else if local {\n+                    let i = vec::len(closing);\n+                    while i > 0u {\n+                        i -= 1u;\n+                        df = ast::def_upvar(ast_util::def_id_of_def(df),\n+                                            @df, closing[i]);\n+                        fnd = some(df);\n+                    }\n                 }\n                 ret fnd;\n             }\n-            if left_fn { left_fn_level2 = true; }\n-            if (ns == ns_value || ns == ns_type) && !left_fn {\n+            if left_fn {\n+                left_fn_level2 = true;\n+            } else if ns == ns_value || ns == ns_type {\n                 left_fn = scope_is_fn(hd);\n+                alt scope_closes(hd) {\n+                  some(mut) { closing += [mut]; }\n+                  _ {}\n+                }\n             }\n             sc = *tl;\n           }\n@@ -1177,6 +1195,7 @@ fn ns_for_def(d: def) -> namespace {\n           ast::def_const(_) { ns_value }\n           ast::def_arg(_, _) { ns_value }\n           ast::def_local(_) { ns_value }\n+          ast::def_upvar(_, _, _) { ns_value }\n           ast::def_variant(_, _) { ns_value }\n           ast::def_ty(_) { ns_type }\n           ast::def_binding(_) { ns_type }"}, {"sha": "699c23d4fa275c9e8bb7e75d00524aa5ef73bafb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -2824,8 +2824,8 @@ fn build_environment(bcx: @block_ctxt, lltydescs: [ValueRef],\n \n // Given a context and a list of upvars, build a closure. This just\n // collects the upvars and packages them up for build_environment.\n-fn build_closure(cx: &@block_ctxt, upvars: &@[ast::node_id], copying: bool) ->\n-   {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n+fn build_closure(cx: &@block_ctxt, upvars: &@[ast::def], copying: bool)\n+    -> {ptr: ValueRef, ptrty: ty::t, bcx: @block_ctxt} {\n     let closure_vals: [lval_result] = [];\n     let closure_tys: [ty::t] = [];\n     // If we need to, package up the iterator body to call\n@@ -2834,8 +2834,9 @@ fn build_closure(cx: &@block_ctxt, upvars: &@[ast::node_id], copying: bool) ->\n         closure_tys += [option::get(cx.fcx.iterbodyty)];\n     }\n     // Package up the upvars\n-    for nid: ast::node_id in *upvars {\n-        closure_vals += [trans_var(cx, cx.sp, nid)];\n+    for def in *upvars {\n+        closure_vals += [trans_local_var(cx, def)];\n+        let nid = ast_util::def_id_of_def(def).node;\n         let ty = ty::node_id_to_monotype(bcx_tcx(cx), nid);\n         if !copying { ty = ty::mk_mut_ptr(bcx_tcx(cx), ty); }\n         closure_tys += [ty];\n@@ -2882,7 +2883,7 @@ fn find_environment_tydescs(bcx: &@block_ctxt, envty: ty::t,\n // and a list of upvars, generate code to load and populate the environment\n // with the upvars and type descriptors.\n fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n-                    upvars: &@[ast::node_id], copying: bool) {\n+                    upvars: &@[ast::def], copying: bool) {\n     let bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n     let ty = ty::mk_imm_box(bcx_tcx(bcx), envty);\n@@ -2913,14 +2914,13 @@ fn load_environment(enclosing_cx: &@block_ctxt, fcx: &@fn_ctxt, envty: ty::t,\n         i += 1u;\n     }\n \n-    // Load the acutal upvars.\n-    for upvar_id: ast::node_id in *upvars {\n+    // Load the actual upvars.\n+    for upvar_def in *upvars {\n         let upvarptr = GEP_tup_like(bcx, ty, llclosure, path + [i as int]);\n         bcx = upvarptr.bcx;\n         let llupvarptr = upvarptr.val;\n         if !copying { llupvarptr = Load(bcx, llupvarptr); }\n-        let def_id = ast_util::def_id_of_def(bcx_tcx(bcx).\n-                                             def_map.get(upvar_id));\n+        let def_id = ast_util::def_id_of_def(upvar_def);\n         fcx.llupvars.insert(def_id.node, llupvarptr);\n         i += 1u;\n     }\n@@ -3134,34 +3134,44 @@ fn lookup_discriminant(lcx: &@local_ctxt, vid: &ast::def_id) -> ValueRef {\n     }\n }\n \n-fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) -> lval_result {\n-    let ccx = bcx_ccx(cx);\n-    alt freevars::def_lookup(bcx_tcx(cx), cx.fcx.id, id) {\n-      some(ast::def_upvar(did, _)) {\n+fn trans_local_var(cx: &@block_ctxt, def: &ast::def) -> lval_result {\n+    alt def {\n+      ast::def_upvar(did, _, _) {\n         assert (cx.fcx.llupvars.contains_key(did.node));\n         ret lval_mem(cx, cx.fcx.llupvars.get(did.node));\n       }\n-      some(ast::def_arg(did, _)) {\n+      ast::def_arg(did, _) {\n         assert (cx.fcx.llargs.contains_key(did.node));\n         ret lval_mem(cx, cx.fcx.llargs.get(did.node));\n       }\n-      some(ast::def_local(did)) {\n+      ast::def_local(did) {\n         assert (cx.fcx.lllocals.contains_key(did.node));\n         ret lval_mem(cx, cx.fcx.lllocals.get(did.node));\n       }\n-      some(ast::def_binding(did)) {\n+      ast::def_binding(did) {\n         assert (cx.fcx.lllocals.contains_key(did.node));\n         ret lval_mem(cx, cx.fcx.lllocals.get(did.node));\n       }\n-      some(ast::def_obj_field(did, _)) {\n+      ast::def_obj_field(did, _) {\n         assert (cx.fcx.llobjfields.contains_key(did.node));\n         ret lval_mem(cx, cx.fcx.llobjfields.get(did.node));\n       }\n-      some(ast::def_fn(did, _)) {\n+      _ {\n+        bcx_ccx(cx).sess.span_unimpl\n+            (cx.sp, ~\"unsupported def type in trans_local_def\");\n+      }\n+    }\n+}\n+\n+fn trans_var(cx: &@block_ctxt, sp: &span, def: &ast::def,\n+             id: ast::node_id) -> lval_result {\n+    let ccx = bcx_ccx(cx);\n+    alt def {\n+      ast::def_fn(did, _) {\n         let tyt = ty::lookup_item_type(ccx.tcx, did);\n         ret lval_generic_fn(cx, tyt, did, id);\n       }\n-      some(ast::def_variant(tid, vid)) {\n+      ast::def_variant(tid, vid) {\n         let v_tyt = ty::lookup_item_type(ccx.tcx, vid);\n         alt ty::struct(ccx.tcx, v_tyt.ty) {\n           ty::ty_fn(_, _, _, _, _) {\n@@ -3188,7 +3198,7 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) -> lval_result {\n           }\n         }\n       }\n-      some(ast::def_const(did)) {\n+      ast::def_const(did) {\n         if did.crate == ast::local_crate {\n             assert (ccx.consts.contains_key(did.node));\n             ret lval_mem(cx, ccx.consts.get(did.node));\n@@ -3203,17 +3213,17 @@ fn trans_var(cx: &@block_ctxt, sp: &span, id: ast::node_id) -> lval_result {\n                                            tp));\n         }\n       }\n-      some(ast::def_native_fn(did)) {\n+      ast::def_native_fn(did) {\n         let tyt = ty::lookup_item_type(ccx.tcx, did);\n         ret lval_generic_fn(cx, tyt, did, id);\n       }\n-      _ { ccx.sess.span_unimpl(cx.sp, ~\"def variant in trans\"); }\n+      _ { ret trans_local_var(cx, def); }\n     }\n }\n \n fn trans_path(cx: &@block_ctxt, p: &ast::path, id: ast::node_id) ->\n    lval_result {\n-    ret trans_var(cx, p.span, id);\n+    ret trans_var(cx, p.span, bcx_tcx(cx).def_map.get(id), id);\n }\n \n fn trans_field(cx: &@block_ctxt, sp: &span, v: ValueRef, t0: ty::t,"}, {"sha": "4f4af857374954ddffb5dc881f57cf7fd8075dca", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -531,16 +531,6 @@ fn constraints_expr(cx: &ty::ctxt, e: @expr) -> [@ty::constr] {\n     }\n }\n \n-fn node_id_to_def_upvar_strict(cx: &fn_ctxt, id: node_id) -> def {\n-    alt freevars::def_lookup(cx.ccx.tcx, cx.id, id) {\n-      none. {\n-        log_err \"node_id_to_def: node_id \"\n-            + istr::to_estr(int::str(id)) + \" has no def\";\n-        fail;\n-      }\n-      some(d) { ret d; }\n-    }\n-}\n fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n     alt cx.def_map.find(id) {\n       none. {\n@@ -555,9 +545,6 @@ fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n fn node_id_to_def(ccx: &crate_ctxt, id: node_id) -> option::t<def> {\n     ret ccx.tcx.def_map.find(id);\n }\n-fn node_id_to_def_upvar(cx: &fn_ctxt, id: node_id) -> option::t<def> {\n-    ret freevars::def_lookup(cx.ccx.tcx, cx.id, id);\n-}\n \n fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n     alt c {\n@@ -620,21 +607,11 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n     alt e.node {\n       expr_path(p) {\n         alt tcx.def_map.find(e.id) {\n-          some(def_local(l_id)) {\n-            ret @respan(p.span,\n-                        carg_ident({ident: p.node.idents[0],\n-                                    node: l_id.node}));\n-          }\n-          some(def_arg(a_id, _)) {\n+          some(def_local(id)) | some(def_arg(id, _)) | some(def_binding(id)) |\n+          some(def_upvar(id, _, _)) {\n             ret @respan(p.span,\n-                        carg_ident({ident: p.node.idents[0],\n-                                    node: a_id.node}));\n+                        carg_ident({ident: p.node.idents[0], node: id.node}));\n           }\n-          some (def_binding(b_id)) {\n-            ret @respan(p.span,\n-                        carg_ident({ident: p.node.idents[0],\n-                                    node: b_id.node}));\n-           }\n           some(_) {\n             tcx.sess.bug(~\"exprs_to_constr_args: non-local variable \" +\n                              ~\"as pred arg\");\n@@ -848,8 +825,9 @@ tag if_ty { if_check; plain_if; }\n fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n    def_id {\n     alt local_node_id_to_def(fcx, i) {\n-      some(def_local(d_id)) { ret d_id; }\n-      some(def_arg(a_id, _)) { ret a_id; }\n+      some(def_local(id)) | some(def_arg(id, _)) | some(def_upvar(id, _, _)) {\n+        ret id;\n+      }\n       some(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp,\n                                     ~\"local_node_id_to_def_id: id \\\n@@ -870,17 +848,16 @@ fn local_node_id_to_def(fcx: &fn_ctxt, i: &node_id) -> option::t<def> {\n \n fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t<def_id> {\n     alt local_node_id_to_def(fcx, i) {\n-      some(def_local(d_id)) { some(d_id) }\n-      some(def_arg(a_id, _)) { some(a_id) }\n+      some(def_local(id)) | some(def_arg(id, _)) | some(def_binding(id)) |\n+      some(def_upvar(id, _, _)) { some(id) }\n       _ { none }\n     }\n }\n \n fn local_node_id_to_local_def_id(fcx: &fn_ctxt, i: &node_id) ->\n    option::t<node_id> {\n-    alt local_node_id_to_def(fcx, i) {\n-      some(def_local(d_id)) { some(d_id.node) }\n-      some(def_arg(a_id, _)) { some(a_id.node) }\n+    alt local_node_id_to_def_id(fcx, i) {\n+      some(did) { some(did.node) }\n       _ { none }\n     }\n }"}, {"sha": "189b5249143435121914c2718c7d34b3d6955dd7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -210,7 +210,7 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n \n fn gen_if_local(fcx: &fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n                 new_var: node_id, pth: &path) {\n-    alt node_id_to_def_upvar(fcx, new_var) {\n+    alt node_id_to_def(fcx.ccx, new_var) {\n       some(d) {\n         alt d {\n           def_local(d_id) {\n@@ -249,7 +249,7 @@ fn handle_update(fcx: &fn_ctxt, parent: &@expr, lhs: &@expr, rhs: &@expr,\n           }\n           _ {\n             // pure and assign_op require the lhs to be init'd\n-            let df = node_id_to_def_upvar_strict(fcx, lhs.id);\n+            let df = node_id_to_def_strict(fcx.ccx.tcx, lhs.id);\n             alt df {\n               def_local(d_id) {\n                 let i =\n@@ -291,13 +291,16 @@ fn handle_update(fcx: &fn_ctxt, parent: &@expr, lhs: &@expr, rhs: &@expr,\n     }\n }\n \n-/* FIXME: Can't deinitialize an upvar -- tests for that? */\n fn handle_var(fcx: &fn_ctxt, rslt: &pre_and_post, id: node_id, name: ident) {\n-    let df = node_id_to_def_upvar_strict(fcx, id);\n-    alt df {\n+    handle_var_def(fcx, rslt, node_id_to_def_strict(fcx.ccx.tcx, id), name);\n+}\n+\n+fn handle_var_def(fcx: &fn_ctxt, rslt: &pre_and_post, def: &def,\n+                  name: ident) {\n+    alt def {\n       def_local(d_id) | def_arg(d_id, _) {\n-        let i = bit_num(fcx, ninit(d_id.node, name));\n         use_var(fcx, d_id.node);\n+        let i = bit_num(fcx, ninit(d_id.node, name));\n         require_and_preserve(i, rslt);\n       }\n       _ {/* nothing to check */ }\n@@ -369,8 +372,9 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       expr_fn(f) {\n         let rslt = expr_pp(fcx.ccx, e);\n         clear_pp(rslt);\n-        let upvars = freevars::get_freevars(fcx.ccx.tcx, e.id);\n-        for id: node_id in *upvars { handle_var(fcx, rslt, id, ~\"upvar\"); }\n+        for def in *freevars::get_freevars(fcx.ccx.tcx, e.id) {\n+            handle_var_def(fcx, rslt, def, ~\"upvar\");\n+        }\n       }\n       expr_block(b) {\n         find_pre_post_block(fcx, b);\n@@ -474,6 +478,11 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       }\n       expr_for_each(d, index, body) {\n         find_pre_post_loop(fcx, d, index, body, e.id);\n+        let rslt = expr_pp(fcx.ccx, e);\n+        clear_pp(rslt);\n+        for def in *freevars::get_freevars(fcx.ccx.tcx, body.node.id) {\n+            handle_var_def(fcx, rslt, def, ~\"upvar\");\n+        }\n       }\n       expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub], e.id); }\n       expr_alt(ex, alts) {"}, {"sha": "fc65961d692825f4d7b983fcba8c19804cffe0b0", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -228,7 +228,7 @@ fn find_pre_post_state_loop(fcx: &fn_ctxt, pres: prestate, l: &@local,\n fn gen_if_local(fcx: &fn_ctxt, p: &poststate, e: &@expr) -> bool {\n     alt e.node {\n       expr_path(pth) {\n-        alt freevars::def_lookup(fcx.ccx.tcx, fcx.id, e.id) {\n+        alt fcx.ccx.tcx.def_map.find(e.id) {\n           some(def_local(loc)) {\n             ret set_in_poststate_ident(fcx, loc.node,\n                                        path_to_ident(fcx.ccx.tcx, pth), p);"}, {"sha": "f24eee8123c3924cb7d09469af6f8c7347d1df6c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -1790,11 +1790,7 @@ mod unify {\n     tag union_result { unres_ok; unres_err(type_err); }\n     tag fixup_result {\n         fix_ok(t); // fixup succeeded\n-\n-\n-\n         fix_err(int); // fixup failed because a type variable was unresolved\n-\n     }\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n@@ -2605,6 +2601,7 @@ fn def_has_ty_params(def: &ast::def) -> bool {\n       ast::def_const(_) { ret false; }\n       ast::def_arg(_, _) { ret false; }\n       ast::def_local(_) { ret false; }\n+      ast::def_upvar(_, _, _) { ret false; }\n       ast::def_variant(_, _) { ret true; }\n       ast::def_ty(_) { ret false; }\n       ast::def_ty_arg(_, _) { ret false; }"}, {"sha": "21137bdb6523d9b638db3663200c322c8017fa0e", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -148,6 +148,9 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n       ast::def_ty(_) {\n         fcx.ccx.tcx.sess.span_fatal(sp, ~\"expected value but found type\");\n       }\n+      ast::def_upvar(_, inner, _) {\n+        ret ty_param_kinds_and_ty_for_def(fcx, sp, *inner);\n+      }\n       _ {\n         // FIXME: handle other names.\n         fcx.ccx.tcx.sess.unimpl(~\"definition variant\");\n@@ -1128,6 +1131,14 @@ mod writeback {\n     fn visit_expr(e: &@ast::expr, wbcx: &wb_ctxt, v: &wb_vt) {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n+        alt e.node {\n+          ast::expr_fn(f) {\n+            for input in f.decl.inputs {\n+                resolve_type_vars_for_node(wbcx, e.span, input.id);\n+            }\n+          }\n+          _ {}\n+        }\n         visit::visit_expr(e, wbcx, v);\n     }\n     fn visit_block(b: &ast::blk, wbcx: &wb_ctxt, v: &wb_vt) {\n@@ -2683,6 +2694,7 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n           next_var_id: gather_result.next_var_id,\n           mutable fixups: fixups,\n           ccx: ccx};\n+\n     check_constraints(fcx, decl.constraints, decl.inputs);\n     check_block(fcx, body);\n \n@@ -2700,6 +2712,13 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n       none. {}\n     }\n \n+    let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n+    let i = 0u;\n+    for arg: ty::arg in args {\n+        write::ty_only_fixup(fcx, f.decl.inputs[i].id, arg.ty);\n+        i += 1u;\n+    }\n+\n     // If we don't have any enclosing function scope, it is time to\n     // force any remaining type vars to be resolved.\n     // If we have an enclosing function scope, our type variables will be"}, {"sha": "582da17f465ae95f40f68375da37cc39b9fc13e8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -44,11 +44,7 @@ tag def {\n     def_use(def_id);\n     def_native_ty(def_id);\n     def_native_fn(def_id);\n-\n-    /* A \"fake\" def for upvars. This never appears in the def_map, but\n-     * freevars::def_lookup will return it for a def that is an upvar.\n-     * It contains the actual def. */\n-    def_upvar(def_id, @def);\n+    def_upvar(def_id, @def, bool /* writable */);\n }\n \n // The set of meta_items that define the compilation environment of the crate,"}, {"sha": "1052ef195fa7d986cd2357cfc140f64d1a3cb414", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -42,7 +42,7 @@ fn def_id_of_def(d: def) -> def_id {\n       def_use(id) { ret id; }\n       def_native_ty(id) { ret id; }\n       def_native_fn(id) { ret id; }\n-      def_upvar(id, _) { ret id; }\n+      def_upvar(id, _, _) { ret id; }\n     }\n }\n \n@@ -216,3 +216,12 @@ fn ternary_to_if(e: &@expr) -> @expr {\n       _ { fail; }\n     }\n }\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "369e07080f4ddce0d756b6387f410ecda2b78358", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -173,7 +173,6 @@ fn bad_expr_word_table() -> hashmap<istr, ()> {\n     words.insert(~\"prove\", ());\n     words.insert(~\"native\", ());\n     words.insert(~\"fn\", ());\n-    words.insert(~\"block\", ());\n     words.insert(~\"lambda\", ());\n     words.insert(~\"pure\", ());\n     words.insert(~\"iter\", ());"}, {"sha": "05a3cc95e20870ced64bd350f83dbda1afe5358a", "filename": "src/test/compile-fail/lambda-mutate-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate-nested.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:assigning to immutable alias\n+// error-pattern:assigning to upvar\n // Make sure that nesting a block within a lambda doesn't let us\n // mutate upvars from a lambda.\n fn main() {"}, {"sha": "3d7199e4b1d87d1aba6cef404e89a697bc55e646", "filename": "src/test/compile-fail/lambda-mutate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flambda-mutate.rs?ref=6ba4eacddf2a07e13f6589f04303ce7fb4c4d70c", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:assigning to immutable alias\n+// error-pattern:assigning to upvar\n // Make sure we can't write to upvars from lambdas\n fn main() {\n     let i = 0;"}]}