{"sha": "f1d02c307348057fd0554ad934006b186f8b6826", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxZDAyYzMwNzM0ODA1N2ZkMDU1NGFkOTM0MDA2YjE4NmY4YjY4MjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-29T00:02:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-29T00:02:37Z"}, "message": "Auto merge of #53671 - RalfJung:miri-refactor, r=oli-obk\n\nMiri engine cleanup\n\n* Unify the two maps in memory to store the allocation and its kind together.\n* Share the handling of statics between CTFE and miri: The miri engine always\n      uses \"lazy\" `AllocType::Static` when encountering a static.  Acessing that\n      static invokes CTFE (no matter the machine).  The machine only has any\n      influence when writing to a static, which CTFE outright rejects (but miri\n      makes a copy-on-write).\n* Add an `AllocId` to by-ref consts so miri can use them as operands without\n      making copies.\n* Move responsibilities around for the `eval_fn_call` machine hook: The hook\n      just has to find the MIR (or entirely take care of everything); pushing the\n      new stack frame is taken care of by the miri engine.\n* Expose the intrinsics and lang items implemented by CTFE so miri does not\n      have to reimplement them.\n* Allow Machine to hook into foreign statics (used by miri to get rid of some other hacks).\n* Clean up function calling.\n* Switch const sanity check to work on operands, not mplaces.\n* Move const_eval out of rustc_mir::interpret, to make sure that it does not access private implementation details.\n\nIn particular, we can finally make `eval_operand` take `&self`. :-)\n\nShould be merged after https://github.com/rust-lang/rust/pull/53609, across which I will rebase.", "tree": {"sha": "0ed67d0fa7379a89dba8bc8afbcc35f8d0b4c503", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ed67d0fa7379a89dba8bc8afbcc35f8d0b4c503"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1d02c307348057fd0554ad934006b186f8b6826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d02c307348057fd0554ad934006b186f8b6826", "html_url": "https://github.com/rust-lang/rust/commit/f1d02c307348057fd0554ad934006b186f8b6826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1d02c307348057fd0554ad934006b186f8b6826/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7061b2775782bb48c0a70d3c79ec711134396687", "url": "https://api.github.com/repos/rust-lang/rust/commits/7061b2775782bb48c0a70d3c79ec711134396687", "html_url": "https://github.com/rust-lang/rust/commit/7061b2775782bb48c0a70d3c79ec711134396687"}, {"sha": "c9b5fac7da34eaf027ba5dc62b5f7f9605e0b2e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9b5fac7da34eaf027ba5dc62b5f7f9605e0b2e9", "html_url": "https://github.com/rust-lang/rust/commit/c9b5fac7da34eaf027ba5dc62b5f7f9605e0b2e9"}], "stats": {"total": 3000, "additions": 1595, "deletions": 1405}, "files": [{"sha": "c598f99a2b54dfed9785ef4b1b741373c9dc0c56", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -384,7 +384,8 @@ for ::mir::interpret::ConstValue<'gcx> {\n                 a.hash_stable(hcx, hasher);\n                 b.hash_stable(hcx, hasher);\n             }\n-            ByRef(alloc, offset) => {\n+            ByRef(id, alloc, offset) => {\n+                id.hash_stable(hcx, hasher);\n                 alloc.hash_stable(hcx, hasher);\n                 offset.hash_stable(hcx, hasher);\n             }\n@@ -446,7 +447,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n         }\n         self.undef_mask.hash_stable(hcx, hasher);\n         self.align.hash_stable(hcx, hasher);\n-        self.runtime_mutability.hash_stable(hcx, hasher);\n+        self.mutability.hash_stable(hcx, hasher);\n     }\n }\n \n@@ -516,7 +517,6 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             InvalidMemoryAccess |\n             InvalidFunctionPointer |\n             InvalidBool |\n-            InvalidDiscriminant |\n             InvalidNullPointerUsage |\n             ReadPointerAsBytes |\n             ReadBytesAsPointer |\n@@ -549,6 +549,7 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             GeneratorResumedAfterReturn |\n             GeneratorResumedAfterPanic |\n             InfiniteLoop => {}\n+            InvalidDiscriminant(val) => val.hash_stable(hcx, hasher),\n             Panic { ref msg, ref file, line, col } => {\n                 msg.hash_stable(hcx, hasher);\n                 file.hash_stable(hcx, hasher);"}, {"sha": "ab38f8fa72135dbb12054024c23a65fee2e8ae5b", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -190,7 +190,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidMemoryAccess,\n     InvalidFunctionPointer,\n     InvalidBool,\n-    InvalidDiscriminant,\n+    InvalidDiscriminant(u128),\n     PointerOutOfBounds {\n         ptr: Pointer,\n         access: bool,\n@@ -302,7 +302,7 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n                 \"tried to use a function pointer after offsetting it\",\n             InvalidBool =>\n                 \"invalid boolean value read\",\n-            InvalidDiscriminant =>\n+            InvalidDiscriminant(..) =>\n                 \"invalid enum discriminant value read\",\n             PointerOutOfBounds { .. } =>\n                 \"pointer offset outside bounds of allocation\",\n@@ -488,6 +488,8 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for EvalErrorKind<'tcx, O> {\n                        align {}\", size.bytes(), align.abi(), size2.bytes(), align2.abi()),\n             Panic { ref msg, line, col, ref file } =>\n                 write!(f, \"the evaluated program panicked at '{}', {}:{}:{}\", msg, file, line, col),\n+            InvalidDiscriminant(val) =>\n+                write!(f, \"encountered invalid enum discriminant {}\", val),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "147f9ccad7c38fbd87544ac1f2aab37512b148e2", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -393,7 +393,8 @@ impl fmt::Display for AllocId {\n pub enum AllocType<'tcx, M> {\n     /// The alloc id is used as a function pointer\n     Function(Instance<'tcx>),\n-    /// The alloc id points to a static variable\n+    /// The alloc id points to a \"lazy\" static variable that did not get computed (yet).\n+    /// This is also used to break the cycle in recursive statics.\n     Static(DefId),\n     /// The alloc id points to memory\n     Memory(M)\n@@ -496,13 +497,14 @@ pub struct Allocation {\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n-    /// Whether the allocation (of a static) should be put into mutable memory when codegenning\n-    ///\n-    /// Only happens for `static mut` or `static` with interior mutability\n-    pub runtime_mutability: Mutability,\n+    /// Whether the allocation is mutable.\n+    /// Also used by codegen to determine if a static should be put into mutable memory,\n+    /// which happens for `static mut` and `static` with interior mutability.\n+    pub mutability: Mutability,\n }\n \n impl Allocation {\n+    /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n         let mut undef_mask = UndefMask::new(Size::ZERO);\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n@@ -511,7 +513,7 @@ impl Allocation {\n             relocations: Relocations::new(),\n             undef_mask,\n             align,\n-            runtime_mutability: Mutability::Immutable,\n+            mutability: Mutability::Immutable,\n         }\n     }\n \n@@ -526,7 +528,7 @@ impl Allocation {\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n-            runtime_mutability: Mutability::Immutable,\n+            mutability: Mutability::Mutable,\n         }\n     }\n }"}, {"sha": "d793bb1cc63ca7a9702d009b319afac180015a18", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 94, "deletions": 3, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -14,7 +14,7 @@ use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n use hir::def_id::DefId;\n \n-use super::{EvalResult, Pointer, PointerArithmetic, Allocation};\n+use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend};\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n@@ -32,8 +32,9 @@ pub enum ConstValue<'tcx> {\n     ///\n     /// The second field may be undef in case of `Option<usize>::None`\n     ScalarPair(Scalar, ScalarMaybeUndef),\n-    /// Used only for the remaining cases. An allocation + offset into the allocation\n-    ByRef(&'tcx Allocation, Size),\n+    /// Used only for the remaining cases. An allocation + offset into the allocation.\n+    /// Invariant: The AllocId matches the allocation.\n+    ByRef(AllocId, &'tcx Allocation, Size),\n }\n \n impl<'tcx> ConstValue<'tcx> {\n@@ -185,6 +186,57 @@ impl<'tcx> Scalar {\n             _ => err!(InvalidBool),\n         }\n     }\n+\n+    pub fn to_char(self) -> EvalResult<'tcx, char> {\n+        let val = self.to_u32()?;\n+        match ::std::char::from_u32(val) {\n+            Some(c) => Ok(c),\n+            None => err!(InvalidChar(val as u128)),\n+        }\n+    }\n+\n+    pub fn to_u8(self) -> EvalResult<'static, u8> {\n+        let sz = Size::from_bits(8);\n+        let b = self.to_bits(sz)?;\n+        assert_eq!(b as u8 as u128, b);\n+        Ok(b as u8)\n+    }\n+\n+    pub fn to_u32(self) -> EvalResult<'static, u32> {\n+        let sz = Size::from_bits(32);\n+        let b = self.to_bits(sz)?;\n+        assert_eq!(b as u32 as u128, b);\n+        Ok(b as u32)\n+    }\n+\n+    pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n+        let b = self.to_bits(cx.data_layout().pointer_size)?;\n+        assert_eq!(b as u64 as u128, b);\n+        Ok(b as u64)\n+    }\n+\n+    pub fn to_i8(self) -> EvalResult<'static, i8> {\n+        let sz = Size::from_bits(8);\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n+        assert_eq!(b as i8 as i128, b);\n+        Ok(b as i8)\n+    }\n+\n+    pub fn to_i32(self) -> EvalResult<'static, i32> {\n+        let sz = Size::from_bits(32);\n+        let b = self.to_bits(sz)?;\n+        let b = sign_extend(b, sz) as i128;\n+        assert_eq!(b as i32 as i128, b);\n+        Ok(b as i32)\n+    }\n+\n+    pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n+        let b = self.to_bits(cx.data_layout().pointer_size)?;\n+        let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n+        assert_eq!(b as i64 as i128, b);\n+        Ok(b as i64)\n+    }\n }\n \n impl From<Pointer> for Scalar {\n@@ -228,22 +280,61 @@ impl From<Scalar> for ScalarMaybeUndef {\n }\n \n impl<'tcx> ScalarMaybeUndef {\n+    #[inline]\n     pub fn not_undef(self) -> EvalResult<'static, Scalar> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n+    #[inline(always)]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n         self.not_undef()?.to_ptr()\n     }\n \n+    #[inline(always)]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         self.not_undef()?.to_bits(target_size)\n     }\n \n+    #[inline(always)]\n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         self.not_undef()?.to_bool()\n     }\n+\n+    #[inline(always)]\n+    pub fn to_char(self) -> EvalResult<'tcx, char> {\n+        self.not_undef()?.to_char()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_u8(self) -> EvalResult<'tcx, u8> {\n+        self.not_undef()?.to_u8()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_u32(self) -> EvalResult<'tcx, u32> {\n+        self.not_undef()?.to_u32()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+        self.not_undef()?.to_usize(cx)\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_i8(self) -> EvalResult<'tcx, i8> {\n+        self.not_undef()?.to_i8()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_i32(self) -> EvalResult<'tcx, i32> {\n+        self.not_undef()?.to_i32()\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'tcx, i64> {\n+        self.not_undef()?.to_isize(cx)\n+    }\n }"}, {"sha": "b10e9f14158696be4707abefdd536e17c18aa1f6", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -1043,13 +1043,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let interned = self.global_arenas.const_allocs.alloc(alloc);\n-        if let Some(prev) = allocs.replace(interned) {\n+        if let Some(prev) = allocs.replace(interned) { // insert into interner\n             bug!(\"Tried to overwrite interned Allocation: {:#?}\", prev)\n         }\n         interned\n     }\n \n-    /// Allocates a byte or string literal for `mir::interpret`\n+    /// Allocates a byte or string literal for `mir::interpret`, read-only\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);"}, {"sha": "1f3c31405043502312ac5182a313b6b0220e682a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n             InvalidMemoryAccess => InvalidMemoryAccess,\n             InvalidFunctionPointer => InvalidFunctionPointer,\n             InvalidBool => InvalidBool,\n-            InvalidDiscriminant => InvalidDiscriminant,\n+            InvalidDiscriminant(val) => InvalidDiscriminant(val),\n             PointerOutOfBounds {\n                 ptr,\n                 access,\n@@ -1139,7 +1139,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n         match *self {\n             ConstValue::Scalar(v) => ConstValue::Scalar(v),\n             ConstValue::ScalarPair(a, b) => ConstValue::ScalarPair(a, b),\n-            ConstValue::ByRef(alloc, offset) => ConstValue::ByRef(alloc, offset),\n+            ConstValue::ByRef(id, alloc, offset) => ConstValue::ByRef(id, alloc, offset),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 ConstValue::Unevaluated(def_id, substs.fold_with(folder))\n             }\n@@ -1150,7 +1150,7 @@ impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n         match *self {\n             ConstValue::Scalar(_) |\n             ConstValue::ScalarPair(_, _) |\n-            ConstValue::ByRef(_, _) => false,\n+            ConstValue::ByRef(_, _, _) => false,\n             ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }"}, {"sha": "b6c9658dd6fc36f67fe5c0cef76e43d7464c4a62", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -57,7 +57,7 @@ pub fn scalar_to_llvm(\n             let base_addr = match alloc_type {\n                 Some(AllocType::Memory(alloc)) => {\n                     let init = const_alloc_to_llvm(cx, alloc);\n-                    if alloc.runtime_mutability == Mutability::Mutable {\n+                    if alloc.mutability == Mutability::Mutable {\n                         consts::addr_of_mut(cx, init, alloc.align, None)\n                     } else {\n                         consts::addr_of(cx, init, alloc.align, None)\n@@ -134,7 +134,7 @@ pub fn codegen_static_initializer(\n     let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n     let alloc = match static_.val {\n-        ConstValue::ByRef(alloc, n) if n.bytes() == 0 => alloc,\n+        ConstValue::ByRef(_, alloc, n) if n.bytes() == 0 => alloc,\n         _ => bug!(\"static const eval returned {:#?}\", static_),\n     };\n     Ok((const_alloc_to_llvm(cx, alloc), alloc))"}, {"sha": "419e7298588c595f95aad5a2d2e70fa2da1b65b8", "filename": "src/librustc_codegen_llvm/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Foperand.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -126,7 +126,7 @@ impl OperandRef<'ll, 'tcx> {\n                 };\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef(alloc, offset) => {\n+            ConstValue::ByRef(_, alloc, offset) => {\n                 return Ok(PlaceRef::from_const_alloc(bx, layout, alloc, offset).load(bx));\n             },\n         };"}, {"sha": "833dca8c75fd52ed4dc753f83e346e163a36b801", "filename": "src/librustc_codegen_llvm/mir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fplace.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -458,7 +458,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef(alloc, offset) => {\n+                        mir::interpret::ConstValue::ByRef(_, alloc, offset) => {\n                             PlaceRef::from_const_alloc(bx, layout, alloc, offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),"}, {"sha": "c497627415f1ac3abde1a981ec437911f926b076", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -1612,21 +1612,15 @@ fn validate_const<'a, 'tcx>(\n     gid: ::rustc::mir::interpret::GlobalId<'tcx>,\n     what: &str,\n ) {\n-    let mut ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n+    let ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n-        use rustc_target::abi::LayoutOf;\n-        use rustc_mir::interpret::OpTy;\n-\n-        let op = ecx.const_value_to_op(constant.val)?;\n-        let layout = ecx.layout_of(constant.ty)?;\n-        let place = ecx.allocate_op(OpTy { op, layout })?.into();\n-\n-        let mut todo = vec![(place, Vec::new())];\n+        let op = ecx.const_to_op(constant)?;\n+        let mut todo = vec![(op, Vec::new())];\n         let mut seen = FxHashSet();\n-        seen.insert(place);\n-        while let Some((place, mut path)) = todo.pop() {\n-            ecx.validate_mplace(\n-                place,\n+        seen.insert(op);\n+        while let Some((op, mut path)) = todo.pop() {\n+            ecx.validate_operand(\n+                op,\n                 &mut path,\n                 &mut seen,\n                 &mut todo,"}, {"sha": "295fca839c812bd43c11ec858749a84eb863a999", "filename": "src/librustc_mir/const_eval.rs", "status": "renamed", "additions": 75, "deletions": 274, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -8,29 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Not in interpret to make sure we do not use private implementation details\n+\n use std::fmt;\n use std::error::Error;\n \n-use rustc::hir;\n+use rustc::hir::{self, def_id::DefId};\n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Instance};\n-use rustc::ty::layout::{LayoutOf, Primitive, TyLayout, Size};\n+use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n-use syntax::source_map::DUMMY_SP;\n-use syntax::symbol::Symbol;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Scalar, AllocId, Allocation, ConstValue,\n+    Scalar, Allocation, ConstValue,\n };\n-use super::{\n-    Place, PlaceExtra, PlaceTy, MemPlace, OpTy, Operand, Value,\n-    EvalContext, StackPopCleanup, Memory, MemoryKind, MPlaceTy,\n+use interpret::{self,\n+    Place, PlaceTy, MemPlace, OpTy, Operand, Value,\n+    EvalContext, StackPopCleanup, MemoryKind,\n };\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n@@ -43,14 +43,14 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     let param_env = tcx.param_env(instance.def_id());\n     let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeEvaluator, ());\n     // insert a stack frame so any queries have the correct substs\n-    ecx.stack.push(super::eval_context::Frame {\n+    ecx.stack.push(interpret::Frame {\n         block: mir::START_BLOCK,\n         locals: IndexVec::new(),\n         instance,\n         span,\n         mir,\n         return_place: Place::null(tcx),\n-        return_to_block: StackPopCleanup::None,\n+        return_to_block: StackPopCleanup::Goto(None), // never pop\n         stmt: 0,\n     });\n     Ok(ecx)\n@@ -71,7 +71,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n         mir.span,\n         mir,\n         Place::null(tcx),\n-        StackPopCleanup::None,\n+        StackPopCleanup::Goto(None), // never pop\n     )?;\n     Ok(ecx)\n }\n@@ -103,15 +103,17 @@ pub fn op_to_const<'tcx>(\n     let val = match normalized_op {\n         Err(MemPlace { ptr, align, extra }) => {\n             // extract alloc-offset pair\n-            assert_eq!(extra, PlaceExtra::None);\n+            assert!(extra.is_none());\n             let ptr = ptr.to_ptr()?;\n             let alloc = ecx.memory.get(ptr.alloc_id)?;\n             assert!(alloc.align.abi() >= align.abi());\n             assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n             let mut alloc = alloc.clone();\n             alloc.align = align;\n+            // FIXME shouldnt it be the case that `mark_static_initialized` has already\n+            // interned this?  I thought that is the entire point of that `FinishStatic` stuff?\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n-            ConstValue::ByRef(alloc, ptr.offset)\n+            ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)\n         },\n         Ok(Value::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef()?),\n@@ -120,21 +122,13 @@ pub fn op_to_const<'tcx>(\n     };\n     Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n }\n-pub fn const_to_op<'tcx>(\n-    ecx: &mut EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n-    cnst: &'tcx ty::Const<'tcx>,\n-) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    let op = ecx.const_value_to_op(cnst.val)?;\n-    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n-}\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> (EvalResult<'tcx, OpTy<'tcx>>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n-    debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n@@ -151,7 +145,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n+    debug!(\"eval_body_using_ecx: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n         Some(mir) => mir,\n@@ -163,29 +157,33 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n     let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n-    let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n-    let is_static = tcx.is_static(cid.instance.def_id());\n-    let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n-        Mutability::Mutable\n-    } else {\n-        Mutability::Immutable\n-    };\n-    let cleanup = StackPopCleanup::MarkStatic(mutability);\n+\n     let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n     let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-    trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n+    trace!(\"eval_body_using_ecx: pushing stack frame for global: {}{}\", name, prom);\n     assert!(mir.arg_count == 0);\n     ecx.push_stack_frame(\n         cid.instance,\n         mir.span,\n         mir,\n         Place::Ptr(*ret),\n-        cleanup,\n+        StackPopCleanup::None { cleanup: false },\n     )?;\n \n     // The main interpreter loop.\n-    while ecx.step()? {}\n+    ecx.run()?;\n \n+    // Intern the result\n+    let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n+    let is_static = tcx.is_static(cid.instance.def_id());\n+    let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n+        Mutability::Mutable\n+    } else {\n+        Mutability::Immutable\n+    };\n+    ecx.memory.intern_static(ret.ptr.to_ptr()?.alloc_id, mutability)?;\n+\n+    debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret.into())\n }\n \n@@ -234,72 +232,33 @@ impl Error for ConstEvalError {\n     }\n }\n \n-impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     type MemoryData = ();\n     type MemoryKinds = !;\n-    fn eval_fn_call<'a>(\n+\n+    const MUT_STATIC_KIND: Option<!> = None; // no mutating of statics allowed\n+\n+    fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool> {\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         if !ecx.tcx.is_const_fn(instance.def_id()) {\n-            let def_id = instance.def_id();\n-            // Some fn calls are actually BinOp intrinsics\n-            let _: ! = if let Some((op, oflo)) = ecx.tcx.is_binop_lang_item(def_id) {\n-                let (dest, bb) = destination.expect(\"128 lowerings can't diverge\");\n-                let l = ecx.read_value(args[0])?;\n-                let r = ecx.read_value(args[1])?;\n-                if oflo {\n-                    ecx.binop_with_overflow(op, l, r, dest)?;\n-                } else {\n-                    ecx.binop_ignore_overflow(op, l, r, dest)?;\n-                }\n-                ecx.goto_block(bb);\n-                return Ok(true);\n-            } else if Some(def_id) == ecx.tcx.lang_items().panic_fn() {\n-                assert!(args.len() == 1);\n-                // &(&'static str, &'static str, u32, u32)\n-                let ptr = ecx.read_value(args[0])?;\n-                let place = ecx.ref_to_mplace(ptr)?;\n-                let (msg, file, line, col) = (\n-                    place_field(ecx, 0, place)?,\n-                    place_field(ecx, 1, place)?,\n-                    place_field(ecx, 2, place)?,\n-                    place_field(ecx, 3, place)?,\n-                );\n-\n-                let msg = to_str(ecx, msg)?;\n-                let file = to_str(ecx, file)?;\n-                let line = to_u32(line)?;\n-                let col = to_u32(col)?;\n-                return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n-            } else if Some(def_id) == ecx.tcx.lang_items().begin_panic_fn() {\n-                assert!(args.len() == 2);\n-                // &'static str, &(&'static str, u32, u32)\n-                let msg = ecx.read_value(args[0])?;\n-                let ptr = ecx.read_value(args[1])?;\n-                let place = ecx.ref_to_mplace(ptr)?;\n-                let (file, line, col) = (\n-                    place_field(ecx, 0, place)?,\n-                    place_field(ecx, 1, place)?,\n-                    place_field(ecx, 2, place)?,\n-                );\n-\n-                let msg = to_str(ecx, msg.value)?;\n-                let file = to_str(ecx, file)?;\n-                let line = to_u32(line)?;\n-                let col = to_u32(col)?;\n-                return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n-            } else {\n-                return Err(\n-                    ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n-                );\n-            };\n+            // Some functions we support even if they are non-const -- but avoid testing\n+            // that for const fn!\n+            if ecx.hook_fn(instance, args, dest)? {\n+                ecx.goto_block(ret)?; // fully evaluated and done\n+                return Ok(None);\n+            }\n+            return Err(\n+                ConstEvalError::NotConst(format!(\"calling non-const fn `{}`\", instance)).into(),\n+            );\n         }\n-        let mir = match ecx.load_mir(instance.def) {\n+        // This is a const fn. Call it.\n+        Ok(Some(match ecx.load_mir(instance.def) {\n             Ok(mir) => mir,\n             Err(err) => {\n                 if let EvalErrorKind::NoMirFor(ref path) = err.kind {\n@@ -310,94 +269,23 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 }\n                 return Err(err);\n             }\n-        };\n-        let (return_place, return_to_block) = match destination {\n-            Some((place, block)) => (*place, StackPopCleanup::Goto(block)),\n-            None => (Place::null(&ecx), StackPopCleanup::None),\n-        };\n-\n-        ecx.push_stack_frame(\n-            instance,\n-            span,\n-            mir,\n-            return_place,\n-            return_to_block,\n-        )?;\n-\n-        Ok(false)\n+        }))\n     }\n \n-\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n-        let substs = instance.substs;\n-\n-        let intrinsic_name = &ecx.tcx.item_name(instance.def_id()).as_str()[..];\n-        match intrinsic_name {\n-            \"min_align_of\" => {\n-                let elem_ty = substs.type_at(0);\n-                let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n-                let align_val = Scalar::Bits {\n-                    bits: elem_align as u128,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n-                ecx.write_scalar(align_val, dest)?;\n-            }\n-\n-            \"size_of\" => {\n-                let ty = substs.type_at(0);\n-                let size = ecx.layout_of(ty)?.size.bytes() as u128;\n-                let size_val = Scalar::Bits {\n-                    bits: size,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n-                ecx.write_scalar(size_val, dest)?;\n-            }\n-\n-            \"type_id\" => {\n-                let ty = substs.type_at(0);\n-                let type_id = ecx.tcx.type_id_hash(ty) as u128;\n-                let id_val = Scalar::Bits {\n-                    bits: type_id,\n-                    size: dest.layout.size.bytes() as u8,\n-                };\n-                ecx.write_scalar(id_val, dest)?;\n-            }\n-            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n-                let ty = substs.type_at(0);\n-                let layout_of = ecx.layout_of(ty)?;\n-                let bits = ecx.read_scalar(args[0])?.to_bits(layout_of.size)?;\n-                let kind = match layout_of.abi {\n-                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n-                };\n-                let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n-                    if bits == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n-                    }\n-                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), bits, kind)?\n-                } else {\n-                    numeric_intrinsic(intrinsic_name, bits, kind)?\n-                };\n-                ecx.write_scalar(out_val, dest)?;\n-            }\n-\n-            name => return Err(\n-                ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", name)).into()\n-            ),\n+        if ecx.emulate_intrinsic(instance, args, dest)? {\n+            return Ok(());\n         }\n-\n-        ecx.goto_block(target);\n-\n-        // Since we pushed no stack frame, the main loop will act\n-        // as if the call just completed and it's returning to the\n-        // current frame.\n-        Ok(())\n+        // An intrinsic that we do not support\n+        let intrinsic_name = &ecx.tcx.item_name(instance.def_id()).as_str()[..];\n+        Err(\n+            ConstEvalError::NeedsRfc(format!(\"calling intrinsic `{}`\", intrinsic_name)).into()\n+        )\n     }\n \n     fn try_ptr_op<'a>(\n@@ -417,23 +305,11 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         }\n     }\n \n-    fn mark_static_initialized<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool> {\n-        Ok(false)\n-    }\n-\n-    fn init_static<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        cid: GlobalId<'tcx>,\n-    ) -> EvalResult<'tcx, AllocId> {\n-        Ok(ecx\n-            .tcx\n-            .alloc_map\n-            .lock()\n-            .intern_static(cid.instance.def_id()))\n+    fn find_foreign_static<'a>(\n+        _tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        _def_id: DefId,\n+    ) -> EvalResult<'tcx, &'tcx Allocation> {\n+        err!(ReadForeignStatic)\n     }\n \n     fn box_alloc<'a>(\n@@ -444,50 +320,6 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n-\n-    fn global_item_with_linkage<'a>(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _instance: ty::Instance<'tcx>,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        Err(\n-            ConstEvalError::NotConst(\"statics with `linkage` attribute\".to_string()).into(),\n-        )\n-    }\n-}\n-\n-fn place_field<'a, 'tcx, 'mir>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n-    i: u64,\n-    place: MPlaceTy<'tcx>,\n-) -> EvalResult<'tcx, Value> {\n-    let place = ecx.mplace_field(place, i)?;\n-    Ok(ecx.try_read_value_from_mplace(place)?.expect(\"bad panic arg layout\"))\n-}\n-\n-fn to_str<'a, 'tcx, 'mir>(\n-    ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n-    val: Value,\n-) -> EvalResult<'tcx, Symbol> {\n-    if let Value::ScalarPair(ptr, len) = val {\n-        let len = len.not_undef()?.to_bits(ecx.memory.pointer_size())?;\n-        let bytes = ecx.memory.read_bytes(ptr.not_undef()?, Size::from_bytes(len as u64))?;\n-        let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n-        Ok(Symbol::intern(str))\n-    } else {\n-        bug!(\"panic arg is not a str\")\n-    }\n-}\n-\n-fn to_u32<'a, 'tcx, 'mir>(\n-    val: Value,\n-) -> EvalResult<'tcx, u32> {\n-    if let Value::Scalar(n) = val {\n-        Ok(n.not_undef()?.to_bits(Size::from_bits(32))? as u32)\n-    } else {\n-        bug!(\"panic arg is not a str\")\n-    }\n }\n \n /// Project to a field of a (variant of a) const\n@@ -500,10 +332,10 @@ pub fn const_field<'a, 'tcx>(\n     value: &'tcx ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n-    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n         // get the operand again\n-        let op = const_to_op(&mut ecx, value)?;\n+        let op = ecx.const_to_op(value)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -532,36 +364,25 @@ pub fn const_variant_index<'a, 'tcx>(\n     val: &'tcx ty::Const<'tcx>,\n ) -> EvalResult<'tcx, usize> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n-    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let op = const_to_op(&mut ecx, val)?;\n-    ecx.read_discriminant_as_variant_index(op)\n+    let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n+    let op = ecx.const_to_op(val)?;\n+    Ok(ecx.read_discriminant(op)?.1)\n }\n \n pub fn const_to_allocation_provider<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n ) -> &'tcx Allocation {\n+    // FIXME: This really does not need to be a query.  Instead, we should have a query for statics\n+    // that returns an allocation directly (or an `AllocId`?), after doing a sanity check of the\n+    // value and centralizing error reporting.\n     match val.val {\n-        ConstValue::ByRef(alloc, offset) => {\n+        ConstValue::ByRef(_, alloc, offset) => {\n             assert_eq!(offset.bytes(), 0);\n             return alloc;\n         },\n-        _ => ()\n+        _ => bug!(\"const_to_allocation called on non-static\"),\n     }\n-    let result = || -> EvalResult<'tcx, &'tcx Allocation> {\n-        let mut ecx = EvalContext::new(\n-            tcx.at(DUMMY_SP),\n-            ty::ParamEnv::reveal_all(),\n-            CompileTimeEvaluator,\n-            ());\n-        let op = const_to_op(&mut ecx, val)?;\n-        // Make a new allocation, copy things there\n-        let ptr = ecx.allocate(op.layout, MemoryKind::Stack)?;\n-        ecx.copy_op(op, ptr.into())?;\n-        let alloc = ecx.memory.get(ptr.to_ptr()?.alloc_id)?;\n-        Ok(tcx.intern_const_alloc(alloc.clone()))\n-    };\n-    result().expect(\"unable to convert ConstValue to Allocation\")\n }\n \n pub fn const_eval_provider<'a, 'tcx>(\n@@ -626,23 +447,3 @@ pub fn const_eval_provider<'a, 'tcx>(\n         err.into()\n     })\n }\n-\n-fn numeric_intrinsic<'tcx>(\n-    name: &str,\n-    bits: u128,\n-    kind: Primitive,\n-) -> EvalResult<'tcx, Scalar> {\n-    let size = match kind {\n-        Primitive::Int(integer, _) => integer.size(),\n-        _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n-    };\n-    let extra = 128 - size.bits() as u128;\n-    let bits_out = match name {\n-        \"ctpop\" => bits.count_ones() as u128,\n-        \"ctlz\" => bits.leading_zeros() as u128 - extra,\n-        \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n-        \"bswap\" => (bits << extra).swap_bytes(),\n-        _ => bug!(\"not a numeric intrinsic: {}\", name),\n-    };\n-    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n-}", "previous_filename": "src/librustc_mir/interpret/const_eval.rs"}, {"sha": "d0d1c5d6610d08ded9306981689927cc589863c6", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    crate fn cast(\n+    pub fn cast(\n         &mut self,\n         src: OpTy<'tcx>,\n         kind: CastKind,"}, {"sha": "455c3fc281a6be45b1be6da6d55ffcea13155375", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 109, "deletions": 114, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -32,10 +32,9 @@ use rustc::mir::interpret::{\n };\n \n use syntax::source_map::{self, Span};\n-use syntax::ast::Mutability;\n \n use super::{\n-    Value, Operand, MemPlace, MPlaceTy, Place, PlaceExtra,\n+    Value, Operand, MemPlace, MPlaceTy, Place,\n     Memory, Machine\n };\n \n@@ -56,15 +55,15 @@ pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub(crate) stack: Vec<Frame<'mir, 'tcx>>,\n \n     /// The maximum number of stack frames allowed\n-    pub(crate) stack_limit: usize,\n+    pub(super) stack_limit: usize,\n \n     /// When this value is negative, it indicates the number of interpreter\n     /// steps *until* the loop detector is enabled. When it is positive, it is\n     /// the number of steps after the detector has been enabled modulo the loop\n     /// detector period.\n-    pub(crate) steps_since_detector_enabled: isize,\n+    pub(super) steps_since_detector_enabled: isize,\n \n-    pub(crate) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n+    pub(super) loop_detector: InfiniteLoopDetector<'a, 'mir, 'tcx, M>,\n }\n \n /// A stack frame.\n@@ -85,7 +84,7 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Return place and locals\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// The block to return to when returning from the current stack frame\n+    /// Work to perform when returning from this function\n     pub return_to_block: StackPopCleanup,\n \n     /// The location where the result of the current stack frame should be written to.\n@@ -157,6 +156,18 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n     }\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n+pub enum StackPopCleanup {\n+    /// Jump to the next block in the caller, or cause UB if None (that's a function\n+    /// that may never return).\n+    Goto(Option<mir::BasicBlock>),\n+    /// Just do nohing: Used by Main and for the box_alloc hook in miri.\n+    /// `cleanup` says whether locals are deallocated.  Static computation\n+    /// wants them leaked to intern what they need (and just throw away\n+    /// the entire `ecx` when it is done).\n+    None { cleanup: bool },\n+}\n+\n // State of a local variable\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub enum LocalValue {\n@@ -188,7 +199,7 @@ impl<'tcx> LocalValue {\n type EvalSnapshot<'a, 'mir, 'tcx, M>\n     = (M, Vec<Frame<'mir, 'tcx>>, Memory<'a, 'mir, 'tcx, M>);\n \n-pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n+pub(super) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n@@ -251,20 +262,6 @@ impl<'a, 'mir, 'tcx, M> InfiniteLoopDetector<'a, 'mir, 'tcx, M>\n     }\n }\n \n-#[derive(Clone, Debug, Eq, PartialEq, Hash)]\n-pub enum StackPopCleanup {\n-    /// The stackframe existed to compute the initial value of a static/constant, make sure it\n-    /// isn't modifyable afterwards in case of constants.\n-    /// In case of `static mut`, mark the memory to ensure it's never marked as immutable through\n-    /// references or deallocated\n-    MarkStatic(Mutability),\n-    /// A regular stackframe added due to a function call will need to get forwarded to the next\n-    /// block\n-    Goto(mir::BasicBlock),\n-    /// The main function and diverging functions have nowhere to return to\n-    None,\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n@@ -388,7 +385,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_bytes(s.as_bytes());\n+        let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n         Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n \n@@ -465,90 +462,94 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type.\n-    /// Note that the value does not matter if the type is sized. For unsized types,\n-    /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n-    pub fn size_and_align_of_mplace(\n+    /// Only the \"extra\" (metadata) part of the place matters.\n+    pub(super) fn size_and_align_of(\n         &self,\n-        mplace: MPlaceTy<'tcx>,\n+        metadata: Option<Scalar>,\n+        layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        if let PlaceExtra::None = mplace.extra {\n-            assert!(!mplace.layout.is_unsized());\n-            Ok(mplace.layout.size_and_align())\n-        } else {\n-            let layout = mplace.layout;\n-            assert!(layout.is_unsized());\n-            match layout.ty.sty {\n-                ty::Adt(..) | ty::Tuple(..) => {\n-                    // First get the size of all statically known fields.\n-                    // Don't use type_of::sizing_type_of because that expects t to be sized,\n-                    // and it also rounds up to alignment, which we want to avoid,\n-                    // as the unsized field's alignment could be smaller.\n-                    assert!(!layout.ty.is_simd());\n-                    debug!(\"DST layout: {:?}\", layout);\n-\n-                    let sized_size = layout.fields.offset(layout.fields.count() - 1);\n-                    let sized_align = layout.align;\n-                    debug!(\n-                        \"DST {} statically sized prefix size: {:?} align: {:?}\",\n-                        layout.ty,\n-                        sized_size,\n-                        sized_align\n-                    );\n-\n-                    // Recurse to get the size of the dynamically sized field (must be\n-                    // the last field).\n-                    let field = self.mplace_field(mplace, layout.fields.count() as u64 - 1)?;\n-                    let (unsized_size, unsized_align) = self.size_and_align_of_mplace(field)?;\n-\n-                    // FIXME (#26403, #27023): We should be adding padding\n-                    // to `sized_size` (to accommodate the `unsized_align`\n-                    // required of the unsized field that follows) before\n-                    // summing it with `sized_size`. (Note that since #26403\n-                    // is unfixed, we do not yet add the necessary padding\n-                    // here. But this is where the add would go.)\n-\n-                    // Return the sum of sizes and max of aligns.\n-                    let size = sized_size + unsized_size;\n-\n-                    // Choose max of two known alignments (combined value must\n-                    // be aligned according to more restrictive of the two).\n-                    let align = sized_align.max(unsized_align);\n-\n-                    // Issue #27023: must add any necessary padding to `size`\n-                    // (to make it a multiple of `align`) before returning it.\n-                    //\n-                    // Namely, the returned size should be, in C notation:\n-                    //\n-                    //   `size + ((size & (align-1)) ? align : 0)`\n-                    //\n-                    // emulated via the semi-standard fast bit trick:\n-                    //\n-                    //   `(size + (align-1)) & -align`\n-\n-                    Ok((size.abi_align(align), align))\n-                }\n-                ty::Dynamic(..) => {\n-                    let vtable = match mplace.extra {\n-                        PlaceExtra::Vtable(vtable) => vtable,\n-                        _ => bug!(\"Expected vtable\"),\n-                    };\n-                    // the second entry in the vtable is the dynamic size of the object.\n-                    self.read_size_and_align_from_vtable(vtable)\n-                }\n-\n-                ty::Slice(_) | ty::Str => {\n-                    let len = match mplace.extra {\n-                        PlaceExtra::Length(len) => len,\n-                        _ => bug!(\"Expected length\"),\n-                    };\n-                    let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                    Ok((elem_size * len, align))\n-                }\n+        let metadata = match metadata {\n+            None => {\n+                assert!(!layout.is_unsized());\n+                return Ok(layout.size_and_align())\n+            }\n+            Some(metadata) => {\n+                assert!(layout.is_unsized());\n+                metadata\n+            }\n+        };\n+        match layout.ty.sty {\n+            ty::Adt(..) | ty::Tuple(..) => {\n+                // First get the size of all statically known fields.\n+                // Don't use type_of::sizing_type_of because that expects t to be sized,\n+                // and it also rounds up to alignment, which we want to avoid,\n+                // as the unsized field's alignment could be smaller.\n+                assert!(!layout.ty.is_simd());\n+                debug!(\"DST layout: {:?}\", layout);\n+\n+                let sized_size = layout.fields.offset(layout.fields.count() - 1);\n+                let sized_align = layout.align;\n+                debug!(\n+                    \"DST {} statically sized prefix size: {:?} align: {:?}\",\n+                    layout.ty,\n+                    sized_size,\n+                    sized_align\n+                );\n+\n+                // Recurse to get the size of the dynamically sized field (must be\n+                // the last field).\n+                let field = layout.field(self, layout.fields.count() - 1)?;\n+                let (unsized_size, unsized_align) = self.size_and_align_of(Some(metadata), field)?;\n+\n+                // FIXME (#26403, #27023): We should be adding padding\n+                // to `sized_size` (to accommodate the `unsized_align`\n+                // required of the unsized field that follows) before\n+                // summing it with `sized_size`. (Note that since #26403\n+                // is unfixed, we do not yet add the necessary padding\n+                // here. But this is where the add would go.)\n+\n+                // Return the sum of sizes and max of aligns.\n+                let size = sized_size + unsized_size;\n+\n+                // Choose max of two known alignments (combined value must\n+                // be aligned according to more restrictive of the two).\n+                let align = sized_align.max(unsized_align);\n+\n+                // Issue #27023: must add any necessary padding to `size`\n+                // (to make it a multiple of `align`) before returning it.\n+                //\n+                // Namely, the returned size should be, in C notation:\n+                //\n+                //   `size + ((size & (align-1)) ? align : 0)`\n+                //\n+                // emulated via the semi-standard fast bit trick:\n+                //\n+                //   `(size + (align-1)) & -align`\n+\n+                Ok((size.abi_align(align), align))\n+            }\n+            ty::Dynamic(..) => {\n+                let vtable = metadata.to_ptr()?;\n+                // the second entry in the vtable is the dynamic size of the object.\n+                self.read_size_and_align_from_vtable(vtable)\n+            }\n \n-                _ => bug!(\"size_of_val::<{:?}> not supported\", layout.ty),\n+            ty::Slice(_) | ty::Str => {\n+                let len = metadata.to_usize(self)?;\n+                let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n+                Ok((elem_size * len, align))\n             }\n+\n+            _ => bug!(\"size_and_align_of::<{:?}> not supported\", layout.ty),\n         }\n     }\n+    #[inline]\n+    pub fn size_and_align_of_mplace(\n+        &self,\n+        mplace: MPlaceTy<'tcx>\n+    ) -> EvalResult<'tcx, (Size, Align)> {\n+        self.size_and_align_of(mplace.extra, mplace.layout)\n+    }\n \n     pub fn push_stack_frame(\n         &mut self,\n@@ -628,25 +629,19 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation -= 1;\n-        M::end_region(self, None)?;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n         );\n         match frame.return_to_block {\n-            StackPopCleanup::MarkStatic(mutable) => {\n-                if let Place::Ptr(MemPlace { ptr, .. }) = frame.return_place {\n-                    // FIXME: to_ptr()? might be too extreme here,\n-                    // static zsts might reach this under certain conditions\n-                    self.memory.mark_static_initialized(\n-                        ptr.to_ptr()?.alloc_id,\n-                        mutable,\n-                    )?\n-                } else {\n-                    bug!(\"StackPopCleanup::MarkStatic on: {:?}\", frame.return_place);\n+            StackPopCleanup::Goto(block) => {\n+                self.goto_block(block)?;\n+            }\n+            StackPopCleanup::None { cleanup } => {\n+                if !cleanup {\n+                    // Leak the locals\n+                    return Ok(());\n                 }\n             }\n-            StackPopCleanup::Goto(target) => self.goto_block(target),\n-            StackPopCleanup::None => {}\n         }\n         // deallocate all locals that are backed by an allocation\n         for local in frame.locals {\n@@ -656,7 +651,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    crate fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n+    pub(super) fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");"}, {"sha": "35e3253ca7f8e8414c1092a5afb40ecfc9e13878", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -0,0 +1,175 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Intrinsics and other functions that the miri engine executes without\n+//! looking at their MIR.  Intrinsics/functions supported here are shared by CTFE\n+//! and miri.\n+\n+use syntax::symbol::Symbol;\n+use rustc::ty;\n+use rustc::ty::layout::{LayoutOf, Primitive};\n+use rustc::mir::interpret::{\n+    EvalResult, EvalErrorKind, Scalar,\n+};\n+\n+use super::{\n+    Machine, PlaceTy, OpTy, EvalContext,\n+};\n+\n+\n+fn numeric_intrinsic<'tcx>(\n+    name: &str,\n+    bits: u128,\n+    kind: Primitive,\n+) -> EvalResult<'tcx, Scalar> {\n+    let size = match kind {\n+        Primitive::Int(integer, _) => integer.size(),\n+        _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n+    };\n+    let extra = 128 - size.bits() as u128;\n+    let bits_out = match name {\n+        \"ctpop\" => bits.count_ones() as u128,\n+        \"ctlz\" => bits.leading_zeros() as u128 - extra,\n+        \"cttz\" => (bits << extra).trailing_zeros() as u128 - extra,\n+        \"bswap\" => (bits << extra).swap_bytes(),\n+        _ => bug!(\"not a numeric intrinsic: {}\", name),\n+    };\n+    Ok(Scalar::Bits { bits: bits_out, size: size.bytes() as u8 })\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    /// Returns whether emulation happened.\n+    pub fn emulate_intrinsic(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, bool> {\n+        let substs = instance.substs;\n+\n+        let intrinsic_name = &self.tcx.item_name(instance.def_id()).as_str()[..];\n+        match intrinsic_name {\n+            \"min_align_of\" => {\n+                let elem_ty = substs.type_at(0);\n+                let elem_align = self.layout_of(elem_ty)?.align.abi();\n+                let align_val = Scalar::Bits {\n+                    bits: elem_align as u128,\n+                    size: dest.layout.size.bytes() as u8,\n+                };\n+                self.write_scalar(align_val, dest)?;\n+            }\n+\n+            \"size_of\" => {\n+                let ty = substs.type_at(0);\n+                let size = self.layout_of(ty)?.size.bytes() as u128;\n+                let size_val = Scalar::Bits {\n+                    bits: size,\n+                    size: dest.layout.size.bytes() as u8,\n+                };\n+                self.write_scalar(size_val, dest)?;\n+            }\n+\n+            \"type_id\" => {\n+                let ty = substs.type_at(0);\n+                let type_id = self.tcx.type_id_hash(ty) as u128;\n+                let id_val = Scalar::Bits {\n+                    bits: type_id,\n+                    size: dest.layout.size.bytes() as u8,\n+                };\n+                self.write_scalar(id_val, dest)?;\n+            }\n+            \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n+                let ty = substs.type_at(0);\n+                let layout_of = self.layout_of(ty)?;\n+                let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n+                let kind = match layout_of.abi {\n+                    ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n+                    _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n+                };\n+                let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n+                    if bits == 0 {\n+                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n+                    }\n+                    numeric_intrinsic(intrinsic_name.trim_right_matches(\"_nonzero\"), bits, kind)?\n+                } else {\n+                    numeric_intrinsic(intrinsic_name, bits, kind)?\n+                };\n+                self.write_scalar(out_val, dest)?;\n+            }\n+\n+            _ => return Ok(false),\n+        }\n+\n+        Ok(true)\n+    }\n+\n+    /// \"Intercept\" a function call because we have something special to do for it.\n+    /// Returns whether an intercept happened.\n+    pub fn hook_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: Option<PlaceTy<'tcx>>,\n+    ) -> EvalResult<'tcx, bool> {\n+        let def_id = instance.def_id();\n+        // Some fn calls are actually BinOp intrinsics\n+        if let Some((op, oflo)) = self.tcx.is_binop_lang_item(def_id) {\n+            let dest = dest.expect(\"128 lowerings can't diverge\");\n+            let l = self.read_value(args[0])?;\n+            let r = self.read_value(args[1])?;\n+            if oflo {\n+                self.binop_with_overflow(op, l, r, dest)?;\n+            } else {\n+                self.binop_ignore_overflow(op, l, r, dest)?;\n+            }\n+            return Ok(true);\n+        } else if Some(def_id) == self.tcx.lang_items().panic_fn() {\n+            assert!(args.len() == 1);\n+            // &(&'static str, &'static str, u32, u32)\n+            let ptr = self.read_value(args[0])?;\n+            let place = self.ref_to_mplace(ptr)?;\n+            let (msg, file, line, col) = (\n+                self.mplace_field(place, 0)?,\n+                self.mplace_field(place, 1)?,\n+                self.mplace_field(place, 2)?,\n+                self.mplace_field(place, 3)?,\n+            );\n+\n+            let msg_place = self.ref_to_mplace(self.read_value(msg.into())?)?;\n+            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let file_place = self.ref_to_mplace(self.read_value(file.into())?)?;\n+            let file = Symbol::intern(self.read_str(file_place)?);\n+            let line = self.read_scalar(line.into())?.to_u32()?;\n+            let col = self.read_scalar(col.into())?.to_u32()?;\n+            return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n+        } else if Some(def_id) == self.tcx.lang_items().begin_panic_fn() {\n+            assert!(args.len() == 2);\n+            // &'static str, &(&'static str, u32, u32)\n+            let msg = args[0];\n+            let ptr = self.read_value(args[1])?;\n+            let place = self.ref_to_mplace(ptr)?;\n+            let (file, line, col) = (\n+                self.mplace_field(place, 0)?,\n+                self.mplace_field(place, 1)?,\n+                self.mplace_field(place, 2)?,\n+            );\n+\n+            let msg_place = self.ref_to_mplace(self.read_value(msg.into())?)?;\n+            let msg = Symbol::intern(self.read_str(msg_place)?);\n+            let file_place = self.ref_to_mplace(self.read_value(file.into())?)?;\n+            let file = Symbol::intern(self.read_str(file_place)?);\n+            let line = self.read_scalar(line.into())?.to_u32()?;\n+            let col = self.read_scalar(col.into())?.to_u32()?;\n+            return Err(EvalErrorKind::Panic { msg, file, line, col }.into());\n+        } else {\n+            return Ok(false);\n+        }\n+    }\n+}"}, {"sha": "a8fae2b4871ed7a13d07666fbca0197e3a798516", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 33, "deletions": 68, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -14,14 +14,12 @@\n \n use std::hash::Hash;\n \n-use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n-use super::{EvalContext, PlaceTy, OpTy, Memory};\n-\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::interpret::{Allocation, EvalResult, Scalar};\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout};\n-use rustc::ty::layout::Size;\n-use syntax::source_map::Span;\n-use syntax::ast::Mutability;\n+use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+\n+use super::{EvalContext, PlaceTy, OpTy};\n \n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied\n@@ -30,31 +28,47 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     type MemoryData: Clone + Eq + Hash;\n \n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + PartialEq + Copy + Clone;\n+    type MemoryKinds: ::std::fmt::Debug + Copy + Clone + Eq + Hash;\n+\n+    /// The memory kind to use for mutated statics -- or None if those are not supported.\n+    const MUT_STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Entry point to all function calls.\n     ///\n-    /// Returns Ok(true) when the function was handled completely\n-    /// e.g. due to missing mir\n-    ///\n-    /// Returns Ok(false) if a new stack frame was pushed\n-    fn eval_fn_call<'a>(\n+    /// Returns either the mir to use for the call, or `None` if execution should\n+    /// just proceed (which usually means this hook did all the work that the\n+    /// called function should usually have done).  In the latter case, it is\n+    /// this hook's responsibility to call `goto_block(ret)` to advance the instruction pointer!\n+    /// (This is to support functions like `__rust_maybe_catch_panic` that neither find a MIR\n+    /// nor just jump to `ret`, but instead push their own stack frame.)\n+    /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n+    /// was used.\n+    fn find_fn<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n-        span: Span,\n-    ) -> EvalResult<'tcx, bool>;\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> EvalResult<'tcx, Option<&'mir mir::Mir<'tcx>>>;\n \n-    /// directly process an intrinsic without pushing a stack frame.\n+    /// Directly process an intrinsic without pushing a stack frame.\n+    /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n-        target: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n+    /// Called for read access to a foreign static item.\n+    /// This can be called multiple times for the same static item and should return consistent\n+    /// results.  Once the item is *written* the first time, as usual for statics a copy is\n+    /// made and this function is not called again.\n+    fn find_foreign_static<'a>(\n+        tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+        def_id: DefId,\n+    ) -> EvalResult<'tcx, &'tcx Allocation>;\n+\n     /// Called for all binary operations except on float types.\n     ///\n     /// Returns `None` if the operation should be handled by the integer\n@@ -70,20 +84,6 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n-    /// Called when trying to mark machine defined `MemoryKinds` as static\n-    fn mark_static_initialized<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _mutability: Mutability,\n-    ) -> EvalResult<'tcx, bool>;\n-\n-    /// Called when requiring a pointer to a static. Non const eval can\n-    /// create a mutable memory location for `static mut`\n-    fn init_static<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        cid: GlobalId<'tcx>,\n-    ) -> EvalResult<'tcx, AllocId>;\n-\n     /// Heap allocations via the `box` keyword\n     ///\n     /// Returns a pointer to the allocated memory\n@@ -92,42 +92,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Called when trying to access a global declared with a `linkage` attribute\n-    fn global_item_with_linkage<'a>(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        instance: ty::Instance<'tcx>,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx>;\n-\n-    fn check_locks<'a>(\n-        _mem: &Memory<'a, 'mir, 'tcx, Self>,\n-        _ptr: Pointer,\n-        _size: Size,\n-        _access: AccessKind,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn add_lock<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-    ) {}\n-\n-    fn free_lock<'a>(\n-        _mem: &mut Memory<'a, 'mir, 'tcx, Self>,\n-        _id: AllocId,\n-        _len: u64,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn end_region<'a>(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _reg: Option<::rustc::middle::region::Scope>,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n+    /// Execute a validation operation\n     fn validation_op<'a>(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,"}, {"sha": "240f977a5a0e8ddfc045260fae96090ee575e4ab", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 158, "deletions": 223, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -20,51 +20,47 @@ use std::collections::VecDeque;\n use std::hash::{Hash, Hasher};\n use std::ptr;\n \n-use rustc::hir::def_id::DefId;\n-use rustc::ty::Instance;\n-use rustc::ty::ParamEnv;\n-use rustc::ty::query::TyCtxtAt;\n-use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n-use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, ScalarMaybeUndef,\n-                            EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType, truncate};\n+use rustc::ty::{self, Instance, query::TyCtxtAt};\n+use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, ScalarMaybeUndef, GlobalId,\n+                            EvalResult, Scalar, EvalErrorKind, AllocType, truncate};\n pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n \n use syntax::ast::Mutability;\n \n-use super::{EvalContext, Machine};\n+use super::Machine;\n \n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Allocations and pointers\n-////////////////////////////////////////////////////////////////////////////////\n-\n-#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n     /// Error if deallocated except during a stack pop\n     Stack,\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n     Machine(T),\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Top-level interpreter memory\n-////////////////////////////////////////////////////////////////////////////////\n-\n #[derive(Clone)]\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     /// Additional data required by the Machine\n     pub data: M::MemoryData,\n \n-    /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    alloc_kind: FxHashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n-\n-    /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: FxHashMap<AllocId, Allocation>,\n+    /// Allocations local to this instance of the miri engine.  The kind\n+    /// helps ensure that the same mechanism is used for allocation and\n+    /// deallocation.  When an allocation is not found here, it is a\n+    /// static and looked up in the `tcx` for read access.  Writing to\n+    /// a static creates a copy here, in the machine.\n+    alloc_map: FxHashMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n \n     pub tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n \n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M> {\n+    #[inline]\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx, M> Eq for Memory<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n           'tcx: 'a + 'mir,\n@@ -77,13 +73,11 @@ impl<'a, 'mir, 'tcx, M> PartialEq for Memory<'a, 'mir, 'tcx, M>\n     fn eq(&self, other: &Self) -> bool {\n         let Memory {\n             data,\n-            alloc_kind,\n             alloc_map,\n             tcx: _,\n         } = self;\n \n         *data == other.data\n-            && *alloc_kind == other.alloc_kind\n             && *alloc_map == other.alloc_map\n     }\n }\n@@ -95,7 +89,6 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         let Memory {\n             data,\n-            alloc_kind: _,\n             alloc_map: _,\n             tcx: _,\n         } = self;\n@@ -108,62 +101,91 @@ impl<'a, 'mir, 'tcx, M> Hash for Memory<'a, 'mir, 'tcx, M>\n         // iteration orders, we use a commutative operation (in this case\n         // addition, but XOR would also work), to combine the hash of each\n         // `Allocation`.\n-        self.allocations()\n-            .map(|allocs| {\n+        self.alloc_map.iter()\n+            .map(|(&id, alloc)| {\n                 let mut h = FxHasher::default();\n-                allocs.hash(&mut h);\n+                id.hash(&mut h);\n+                alloc.hash(&mut h);\n                 h.finish()\n             })\n             .fold(0u64, |hash, x| hash.wrapping_add(x))\n             .hash(state);\n     }\n }\n \n+/// Helper function to obtain the global (tcx) allocation for a static\n+fn const_eval_static<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>>(\n+    tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n+    id: AllocId\n+) -> EvalResult<'tcx, &'tcx Allocation> {\n+    let alloc = tcx.alloc_map.lock().get(id);\n+    let def_id = match alloc {\n+        Some(AllocType::Memory(mem)) => {\n+            return Ok(mem)\n+        }\n+        Some(AllocType::Function(..)) => {\n+            return err!(DerefFunctionPointer)\n+        }\n+        Some(AllocType::Static(did)) => {\n+            did\n+        }\n+        None =>\n+            return err!(DanglingPointerDeref),\n+    };\n+    // We got a \"lazy\" static that has not been computed yet, do some work\n+    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n+    if tcx.is_foreign_item(def_id) {\n+        return M::find_foreign_static(tcx, def_id);\n+    }\n+    let instance = Instance::mono(tcx.tcx, def_id);\n+    let gid = GlobalId {\n+        instance,\n+        promoted: None,\n+    };\n+    tcx.const_eval(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+        // no need to report anything, the const_eval call takes care of that for statics\n+        assert!(tcx.is_static(def_id).is_some());\n+        EvalErrorKind::ReferencedConstant(err).into()\n+    }).map(|val| {\n+        // FIXME We got our static (will be a ByRef), now we make a *copy*?!?\n+        tcx.const_to_allocation(val)\n+    })\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n-            alloc_kind: FxHashMap::default(),\n             alloc_map: FxHashMap::default(),\n             tcx,\n         }\n     }\n \n-    pub fn allocations<'x>(\n-        &'x self,\n-    ) -> impl Iterator<Item = (AllocId, &'x Allocation)> {\n-        self.alloc_map.iter().map(|(&id, alloc)| (id, alloc))\n-    }\n-\n     pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer {\n         self.tcx.alloc_map.lock().create_fn_alloc(instance).into()\n     }\n \n-    pub fn allocate_bytes(&mut self, bytes: &[u8]) -> Pointer {\n+    pub fn allocate_static_bytes(&mut self, bytes: &[u8]) -> Pointer {\n         self.tcx.allocate_bytes(bytes).into()\n     }\n \n-    /// kind is `None` for statics\n-    pub fn allocate_value(\n+    pub fn allocate_with(\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, AllocId> {\n         let id = self.tcx.alloc_map.lock().reserve();\n-        M::add_lock(self, id);\n-        self.alloc_map.insert(id, alloc);\n-        self.alloc_kind.insert(id, kind);\n+        self.alloc_map.insert(id, (kind, alloc));\n         Ok(id)\n     }\n \n-    /// kind is `None` for statics\n     pub fn allocate(\n         &mut self,\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n-        self.allocate_value(Allocation::undef(size, align), kind).map(Pointer::from)\n+        self.allocate_with(Allocation::undef(size, align), kind).map(Pointer::from)\n     }\n \n     pub fn reallocate(\n@@ -178,15 +200,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n-        if self.alloc_map.contains_key(&ptr.alloc_id) {\n-            let alloc_kind = self.alloc_kind[&ptr.alloc_id];\n-            if alloc_kind != kind {\n-                return err!(ReallocatedWrongMemoryKind(\n-                    format!(\"{:?}\", alloc_kind),\n-                    format!(\"{:?}\", kind),\n-                ));\n-            }\n-        }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\"\n         let new_ptr = self.allocate(new_size, new_align, kind)?;\n@@ -196,20 +209,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             new_ptr.into(),\n             new_align,\n             old_size.min(new_size),\n-            /*nonoverlapping*/\n-            true,\n+            /*nonoverlapping*/ true,\n         )?;\n         self.deallocate(ptr, Some((old_size, old_align)), kind)?;\n \n         Ok(new_ptr)\n     }\n \n+    /// Deallocate a local, or do nothing if that local has been made into a static\n     pub fn deallocate_local(&mut self, ptr: Pointer) -> EvalResult<'tcx> {\n-        match self.alloc_kind.get(&ptr.alloc_id).cloned() {\n-            Some(MemoryKind::Stack) => self.deallocate(ptr, None, MemoryKind::Stack),\n-            // Happens if the memory was interned into immutable memory\n-            None => Ok(()),\n-            other => bug!(\"local contained non-stack memory: {:?}\", other),\n+        // The allocation might be already removed by static interning.\n+        // This can only really happen in the CTFE instance, not in miri.\n+        if self.alloc_map.contains_key(&ptr.alloc_id) {\n+            self.deallocate(ptr, None, MemoryKind::Stack)\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -223,9 +237,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let (alloc_kind, alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n+                // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n                     Some(AllocType::Function(..)) => err!(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n@@ -241,18 +256,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         };\n \n-        let alloc_kind = self.alloc_kind\n-                        .remove(&ptr.alloc_id)\n-                        .expect(\"alloc_map out of sync with alloc_kind\");\n-\n-        // It is okay for us to still holds locks on deallocation -- for example, we could store\n-        // data we own in a local, and the local could be deallocated (from StorageDead) before the\n-        // function returns. However, we should check *something*.  For now, we make sure that there\n-        // is no conflicting write lock by another frame.  We *have* to permit deallocation if we\n-        // hold a read lock.\n-        // FIXME: Figure out the exact rules here.\n-        M::free_lock(self, ptr.alloc_id, alloc.bytes.len() as u64)?;\n-\n         if alloc_kind != kind {\n             return err!(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n@@ -339,63 +342,37 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    fn const_eval_static(&self, def_id: DefId) -> EvalResult<'tcx, &'tcx Allocation> {\n-        if self.tcx.is_foreign_item(def_id) {\n-            return err!(ReadForeignStatic);\n-        }\n-        let instance = Instance::mono(self.tcx.tcx, def_id);\n-        let gid = GlobalId {\n-            instance,\n-            promoted: None,\n-        };\n-        self.tcx.const_eval(ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-            // no need to report anything, the const_eval call takes care of that for statics\n-            assert!(self.tcx.is_static(def_id).is_some());\n-            EvalErrorKind::ReferencedConstant(err).into()\n-        }).map(|val| {\n-            self.tcx.const_to_allocation(val)\n-        })\n-    }\n-\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n-        // normal alloc?\n         match self.alloc_map.get(&id) {\n-            Some(alloc) => Ok(alloc),\n-            // uninitialized static alloc?\n-            None => {\n-                // static alloc?\n-                let alloc = self.tcx.alloc_map.lock().get(id);\n-                match alloc {\n-                    Some(AllocType::Memory(mem)) => Ok(mem),\n-                    Some(AllocType::Function(..)) => {\n-                        Err(EvalErrorKind::DerefFunctionPointer.into())\n-                    }\n-                    Some(AllocType::Static(did)) => {\n-                        self.const_eval_static(did)\n-                    }\n-                    None => Err(EvalErrorKind::DanglingPointerDeref.into()),\n-                }\n-            },\n+            // Normal alloc?\n+            Some(alloc) => Ok(&alloc.1),\n+            // Static. No need to make any copies, just provide read access to the global static\n+            // memory in tcx.\n+            None => const_eval_static::<M>(self.tcx, id),\n         }\n     }\n \n-    fn get_mut(\n+    pub fn get_mut(\n         &mut self,\n         id: AllocId,\n     ) -> EvalResult<'tcx, &mut Allocation> {\n-        // normal alloc?\n-        match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => Ok(alloc),\n-            // uninitialized static alloc?\n-            None => {\n-                // no alloc or immutable alloc? produce an error\n-                match self.tcx.alloc_map.lock().get(id) {\n-                    Some(AllocType::Memory(..)) |\n-                    Some(AllocType::Static(..)) => err!(ModifiedConstantMemory),\n-                    Some(AllocType::Function(..)) => err!(DerefFunctionPointer),\n-                    None => err!(DanglingPointerDeref),\n-                }\n-            },\n+        // Static?\n+        if !self.alloc_map.contains_key(&id) {\n+            // Ask the machine for what to do\n+            if let Some(kind) = M::MUT_STATIC_KIND {\n+                // The machine supports mutating statics.  Make a copy, use that.\n+                self.deep_copy_static(id, MemoryKind::Machine(kind))?;\n+            } else {\n+                return err!(ModifiedConstantMemory)\n+            }\n+        }\n+        // If we come here, we know the allocation is in our map\n+        let alloc = &mut self.alloc_map.get_mut(&id).unwrap().1;\n+        // See if we are allowed to mutate this\n+        if alloc.mutability == Mutability::Immutable {\n+            err!(ModifiedConstantMemory)\n+        } else {\n+            Ok(alloc)\n         }\n     }\n \n@@ -410,10 +387,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_alloc_kind(&self, id: AllocId) -> Option<MemoryKind<M::MemoryKinds>> {\n-        self.alloc_kind.get(&id).cloned()\n-    }\n-\n     /// For debugging, print an allocation and all allocations it points to, recursively.\n     pub fn dump_alloc(&self, id: AllocId) {\n         if !log_enabled!(::log::Level::Trace) {\n@@ -441,14 +414,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             let (alloc, immutable) =\n                 // normal alloc?\n                 match self.alloc_map.get(&id) {\n-                    Some(a) => (a, match self.alloc_kind[&id] {\n+                    Some((kind, alloc)) => (alloc, match kind {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n                     }),\n                     None => {\n                         // static alloc?\n                         match self.tcx.alloc_map.lock().get(id) {\n-                            Some(AllocType::Memory(a)) => (a, \"(immutable)\".to_owned()),\n+                            Some(AllocType::Memory(a)) => (a, \" (immutable)\".to_owned()),\n                             Some(AllocType::Function(func)) => {\n                                 trace!(\"{} {}\", msg, func);\n                                 continue;\n@@ -509,9 +482,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n+        let mut_static_kind = M::MUT_STATIC_KIND.map(|k| MemoryKind::Machine(k));\n         let leaks: Vec<_> = self.alloc_map\n-            .keys()\n-            .cloned()\n+            .iter()\n+            .filter_map(|(&id, &(kind, _))|\n+                // exclude mutable statics\n+                if Some(kind) == mut_static_kind { None } else { Some(id) } )\n             .collect();\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n@@ -534,7 +510,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if size.bytes() == 0 {\n             return Ok(&[]);\n         }\n-        M::check_locks(self, ptr, size, AccessKind::Read)?;\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_bounds(ptr.offset(size, self)?, true)?;\n         let alloc = self.get(ptr.alloc_id)?;\n@@ -557,7 +532,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         if size.bytes() == 0 {\n             return Ok(&mut []);\n         }\n-        M::check_locks(self, ptr, size, AccessKind::Write)?;\n         // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         self.check_bounds(ptr.offset(size, &*self)?, true)?;\n         let alloc = self.get_mut(ptr.alloc_id)?;\n@@ -591,22 +565,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n /// Reading and writing\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    /// mark an allocation pointed to by a static as static and initialized\n-    fn mark_inner_allocation_initialized(\n-        &mut self,\n-        alloc: AllocId,\n-        mutability: Mutability,\n-    ) -> EvalResult<'tcx> {\n-        match self.alloc_kind.get(&alloc) {\n-            // do not go into statics\n-            None => Ok(()),\n-            // just locals and machine allocs\n-            Some(_) => self.mark_static_initialized(alloc, mutability),\n-        }\n-    }\n-\n     /// mark an allocation as static and initialized, either mutable or not\n-    pub fn mark_static_initialized(\n+    pub fn intern_static(\n         &mut self,\n         alloc_id: AllocId,\n         mutability: Mutability,\n@@ -616,31 +576,48 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             alloc_id,\n             mutability\n         );\n-        // The machine handled it\n-        if M::mark_static_initialized(self, alloc_id, mutability)? {\n-            return Ok(())\n-        }\n-        let alloc = self.alloc_map.remove(&alloc_id);\n-        match self.alloc_kind.remove(&alloc_id) {\n-            None => {},\n-            Some(MemoryKind::Machine(_)) => bug!(\"machine didn't handle machine alloc\"),\n-            Some(MemoryKind::Stack) => {},\n-        }\n-        if let Some(mut alloc) = alloc {\n-            // ensure llvm knows not to put this into immutable memory\n-            alloc.runtime_mutability = mutability;\n-            let alloc = self.tcx.intern_const_alloc(alloc);\n-            self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n-            // recurse into inner allocations\n-            for &alloc in alloc.relocations.values() {\n-                self.mark_inner_allocation_initialized(alloc, mutability)?;\n+        // remove allocation\n+        let (kind, mut alloc) = self.alloc_map.remove(&alloc_id).unwrap();\n+        match kind {\n+            MemoryKind::Machine(_) => bug!(\"Static cannot refer to machine memory\"),\n+            MemoryKind::Stack => {},\n+        }\n+        // ensure llvm knows not to put this into immutable memory\n+        alloc.mutability = mutability;\n+        let alloc = self.tcx.intern_const_alloc(alloc);\n+        self.tcx.alloc_map.lock().set_id_memory(alloc_id, alloc);\n+        // recurse into inner allocations\n+        for &alloc in alloc.relocations.values() {\n+            // FIXME: Reusing the mutability here is likely incorrect.  It is originally\n+            // determined via `is_freeze`, and data is considered frozen if there is no\n+            // `UnsafeCell` *immediately* in that data -- however, this search stops\n+            // at references.  So whenever we follow a reference, we should likely\n+            // assume immutability -- and we should make sure that the compiler\n+            // does not permit code that would break this!\n+            if self.alloc_map.contains_key(&alloc) {\n+                // Not yet interned, so proceed recursively\n+                self.intern_static(alloc, mutability)?;\n             }\n-        } else {\n-            bug!(\"no allocation found for {:?}\", alloc_id);\n         }\n         Ok(())\n     }\n \n+    /// The alloc_id must refer to a (mutable) static; a deep copy of that\n+    /// static is made into this memory.\n+    fn deep_copy_static(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx> {\n+        let alloc = const_eval_static::<M>(self.tcx, id)?;\n+        if alloc.mutability == Mutability::Immutable {\n+            return err!(ModifiedConstantMemory);\n+        }\n+        let old = self.alloc_map.insert(id, (kind, alloc.clone()));\n+        assert!(old.is_none(), \"deep_copy_static: must not overwrite existing memory\");\n+        Ok(())\n+    }\n+\n     pub fn copy(\n         &mut self,\n         src: Scalar,\n@@ -745,7 +722,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                     return err!(ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, p1)?;\n-                M::check_locks(self, ptr, p1, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             }\n             None => err!(UnterminatedCString(ptr)),\n@@ -802,9 +778,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let bytes = self.get_bytes_unchecked(ptr, size, ptr_align.min(self.int_align(size)))?;\n         // Undef check happens *after* we established that the alignment is correct.\n         // We must not return Ok() for unaligned pointers!\n-        if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar,\n-            // even if only a few bytes are undefined\n+        if !self.is_defined(ptr, size)? {\n+            // this inflates undefined bytes to the entire scalar, even if only a few\n+            // bytes are undefined\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n         // Now we do the actual reading\n@@ -990,16 +966,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+    fn is_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx, bool> {\n         let alloc = self.get(ptr.alloc_id)?;\n-        if !alloc.undef_mask.is_range_defined(\n+        Ok(alloc.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        )\n-        {\n-            return err!(ReadUndefBytes);\n+        ))\n+    }\n+\n+    #[inline]\n+    fn check_defined(&self, ptr: Pointer, size: Size) -> EvalResult<'tcx> {\n+        if self.is_defined(ptr, size)? {\n+            Ok(())\n+        } else {\n+            err!(ReadUndefBytes)\n         }\n-        Ok(())\n     }\n \n     pub fn mark_definedness(\n@@ -1020,49 +1001,3 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         Ok(())\n     }\n }\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Unaligned accesses\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M>;\n-    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n-}\n-\n-impl<'a, 'mir, 'tcx, M> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n-{\n-    #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n-        self\n-    }\n-\n-    #[inline]\n-    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n-        self\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> HasMemory<'a, 'mir, 'tcx, M> for EvalContext<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n-{\n-    #[inline]\n-    fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n-        &mut self.memory\n-    }\n-\n-    #[inline]\n-    fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n-        &self.memory\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M> layout::HasDataLayout for &'a Memory<'a, 'mir, 'tcx, M>\n-    where M: Machine<'mir, 'tcx>\n-{\n-    #[inline]\n-    fn data_layout(&self) -> &TargetDataLayout {\n-        &self.tcx.data_layout\n-    }\n-}"}, {"sha": "462c4b8889dd1977dc06c8154a388ac92fe56c6e", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -20,18 +20,23 @@ mod operator;\n mod step;\n mod terminator;\n mod traits;\n-mod const_eval;\n mod validity;\n+mod intrinsics;\n \n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n };\n \n-pub use self::place::{Place, PlaceExtra, PlaceTy, MemPlace, MPlaceTy};\n+pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n-pub use self::memory::{Memory, MemoryKind, HasMemory};\n+pub use self::memory::{Memory, MemoryKind};\n \n-pub use self::const_eval::{\n+pub use self::machine::Machine;\n+\n+pub use self::operand::{Value, ValTy, Operand, OpTy};\n+\n+// reexports for compatibility\n+pub use const_eval::{\n     eval_promoted,\n     mk_borrowck_eval_cx,\n     mk_eval_cx,\n@@ -42,7 +47,3 @@ pub use self::const_eval::{\n     const_variant_index,\n     op_to_const,\n };\n-\n-pub use self::machine::Machine;\n-\n-pub use self::operand::{Value, ValTy, Operand, OpTy};"}, {"sha": "9681b705d7eba1d28f8e2a5efee2fb4025ccd6be", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 94, "deletions": 91, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -11,16 +11,17 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n+use std::hash::{Hash, Hasher};\n use std::convert::TryInto;\n \n-use rustc::mir;\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc::{mir, ty};\n+use rustc::ty::layout::{self, Size, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n use rustc_data_structures::indexed_vec::Idx;\n \n use rustc::mir::interpret::{\n     GlobalId, ConstValue, Scalar, EvalResult, Pointer, ScalarMaybeUndef, EvalErrorKind\n };\n-use super::{EvalContext, Machine, MemPlace, MPlaceTy, PlaceExtra, MemoryKind};\n+use super::{EvalContext, Machine, MemPlace, MPlaceTy, MemoryKind};\n \n /// A `Value` represents a single immediate self-contained Rust value.\n ///\n@@ -64,6 +65,14 @@ impl<'tcx> Value {\n         self.to_scalar_or_undef().not_undef()\n     }\n \n+    #[inline]\n+    pub fn to_scalar_pair(self) -> EvalResult<'tcx, (Scalar, Scalar)> {\n+        match self {\n+            Value::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n+            Value::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n+        }\n+    }\n+\n     /// Convert the value into a pointer (or a pointer-sized integer).\n     /// Throws away the second half of a ScalarPair!\n     #[inline]\n@@ -73,24 +82,6 @@ impl<'tcx> Value {\n             Value::ScalarPair(ptr, _) => ptr.not_undef(),\n         }\n     }\n-\n-    pub fn to_scalar_dyn_trait(self) -> EvalResult<'tcx, (Scalar, Pointer)> {\n-        match self {\n-            Value::ScalarPair(ptr, vtable) =>\n-                Ok((ptr.not_undef()?, vtable.to_ptr()?)),\n-            _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n-        }\n-    }\n-\n-    pub fn to_scalar_slice(self, cx: impl HasDataLayout) -> EvalResult<'tcx, (Scalar, u64)> {\n-        match self {\n-            Value::ScalarPair(ptr, val) => {\n-                let len = val.to_bits(cx.data_layout().pointer_size)?;\n-                Ok((ptr.not_undef()?, len as u64))\n-            }\n-            _ => bug!(\"expected ptr and length, got {:?}\", self),\n-        }\n-    }\n }\n \n // ScalarPair needs a type to interpret, so we often have a value and a type together\n@@ -150,7 +141,7 @@ impl Operand {\n \n #[derive(Copy, Clone, Debug)]\n pub struct OpTy<'tcx> {\n-    pub op: Operand,\n+    crate op: Operand, // ideally we'd make this private, but we are not there yet\n     pub layout: TyLayout<'tcx>,\n }\n \n@@ -182,6 +173,20 @@ impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n     }\n }\n \n+// Validation needs to hash OpTy, but we cannot hash Layout -- so we just hash the type\n+impl<'tcx> Hash for OpTy<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.op.hash(state);\n+        self.layout.ty.hash(state);\n+    }\n+}\n+impl<'tcx> PartialEq for OpTy<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.op == other.op && self.layout.ty == other.layout.ty\n+    }\n+}\n+impl<'tcx> Eq for OpTy<'tcx> {}\n+\n impl<'tcx> OpTy<'tcx> {\n     #[inline]\n     pub fn from_ptr(ptr: Pointer, align: Align, layout: TyLayout<'tcx>) -> Self {\n@@ -227,7 +232,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         mplace: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, Option<Value>> {\n-        if mplace.extra != PlaceExtra::None {\n+        if mplace.layout.is_unsized() {\n+            // Dont touch unsized\n             return Ok(None);\n         }\n         let (ptr, ptr_align) = mplace.to_scalar_ptr_align();\n@@ -266,7 +272,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n     /// in a `Value`, not on which data is stored there currently.\n-    pub(super) fn try_read_value(\n+    pub(crate) fn try_read_value(\n         &self,\n         src: OpTy<'tcx>,\n     ) -> EvalResult<'tcx, Result<Value, MemPlace>> {\n@@ -300,6 +306,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    // Turn the MPlace into a string (must already be dereferenced!)\n+    pub fn read_str(\n+        &self,\n+        mplace: MPlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, &str> {\n+        let len = mplace.len(self)?;\n+        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n+        let str = ::std::str::from_utf8(bytes)\n+            .map_err(|err| EvalErrorKind::ValidationFailure(err.to_string()))?;\n+        Ok(str)\n+    }\n+\n     pub fn uninit_operand(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Operand> {\n         // This decides which types we will use the Immediate optimization for, and hence should\n         // match what `try_read_value` and `eval_place_to_op` support.\n@@ -360,7 +378,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(OpTy { op: Operand::Immediate(value), layout: field_layout })\n     }\n \n-    pub(super) fn operand_downcast(\n+    pub fn operand_downcast(\n         &self,\n         op: OpTy<'tcx>,\n         variant: usize,\n@@ -411,12 +429,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     // avoid allocations.  If you already know the layout, you can pass it in\n     // to avoid looking it up again.\n     fn eval_place_to_op(\n-        &mut self,\n+        &self,\n         mir_place: &mir::Place<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx>> {\n         use rustc::mir::Place::*;\n-        Ok(match *mir_place {\n+        let op = match *mir_place {\n             Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n             Local(local) => {\n                 let op = *self.frame().locals[local].access()?;\n@@ -430,21 +448,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.operand_projection(op, &proj.elem)?\n             }\n \n-            // Everything else is an mplace, so we just call `eval_place`.\n-            // Note that getting an mplace for a static aways requires `&mut`,\n-            // so this does not \"cost\" us anything in terms if mutability.\n-            Promoted(_) | Static(_) => {\n-                let place = self.eval_place(mir_place)?;\n-                place.to_mem_place().into()\n-            }\n-        })\n+            _ => self.eval_place_to_mplace(mir_place)?.into(),\n+        };\n+\n+        trace!(\"eval_place_to_op: got {:?}\", *op);\n+        Ok(op)\n     }\n \n     /// Evaluate the operand, returning a place where you can then find the data.\n     /// if you already know the layout, you can save two some table lookups\n     /// by passing it in here.\n     pub fn eval_operand(\n-        &mut self,\n+        &self,\n         mir_op: &mir::Operand<'tcx>,\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx>> {\n@@ -469,8 +484,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     /// Evaluate a bunch of operands at once\n-    pub(crate) fn eval_operands(\n-        &mut self,\n+    pub(super) fn eval_operands(\n+        &self,\n         ops: &[mir::Operand<'tcx>],\n     ) -> EvalResult<'tcx, Vec<OpTy<'tcx>>> {\n         ops.into_iter()\n@@ -479,12 +494,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     }\n \n     // Also used e.g. when miri runs into a constant.\n-    // Unfortunately, this needs an `&mut` to be able to allocate a copy of a `ByRef`\n-    // constant.  This bleeds up to `eval_operand` needing `&mut`.\n-    pub fn const_value_to_op(\n-        &mut self,\n+    pub(super) fn const_value_to_op(\n+        &self,\n         val: ConstValue<'tcx>,\n     ) -> EvalResult<'tcx, Operand> {\n+        trace!(\"const_value_to_op: {:?}\", val);\n         match val {\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n@@ -493,9 +507,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     promoted: None,\n                 })\n             }\n-            ConstValue::ByRef(alloc, offset) => {\n-                // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n+            ConstValue::ByRef(id, alloc, offset) => {\n+                // We rely on mutability being set correctly in that allocation to prevent writes\n+                // where none should happen -- and for `static mut`, we copy on demand anyway.\n                 Ok(Operand::from_ptr(Pointer::new(id, offset), alloc.align))\n             },\n             ConstValue::ScalarPair(a, b) =>\n@@ -504,52 +518,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 Ok(Operand::Immediate(Value::Scalar(x.into()))),\n         }\n     }\n+    pub fn const_to_op(\n+        &self,\n+        cnst: &ty::Const<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = self.const_value_to_op(cnst.val)?;\n+        Ok(OpTy { op, layout: self.layout_of(cnst.ty)? })\n+    }\n \n-    pub(super) fn global_to_op(&mut self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n+    pub(super) fn global_to_op(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n         let cv = self.const_eval(gid)?;\n         self.const_value_to_op(cv.val)\n     }\n \n-    /// We cannot do self.read_value(self.eval_operand) due to eval_operand taking &mut self,\n-    /// so this helps avoid unnecessary let.\n-    #[inline]\n-    pub fn eval_operand_and_read_value(\n-        &mut self,\n-        op: &mir::Operand<'tcx>,\n-        layout: Option<TyLayout<'tcx>>,\n-    ) -> EvalResult<'tcx, ValTy<'tcx>> {\n-        let op = self.eval_operand(op, layout)?;\n-        self.read_value(op)\n-    }\n-\n-    /// reads a tag and produces the corresponding variant index\n-    pub fn read_discriminant_as_variant_index(\n+    /// Read discriminant, return the runtime value as well as the variant index.\n+    pub fn read_discriminant(\n         &self,\n         rval: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, usize> {\n-        match rval.layout.variants {\n-            layout::Variants::Single { index } => Ok(index),\n-            layout::Variants::Tagged { .. } => {\n-                let discr_val = self.read_discriminant_value(rval)?;\n-                rval.layout.ty\n-                    .ty_adt_def()\n-                    .expect(\"tagged layout for non adt\")\n-                    .discriminants(self.tcx.tcx)\n-                    .position(|var| var.val == discr_val)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n-            }\n-            layout::Variants::NicheFilling { .. } => {\n-                let discr_val = self.read_discriminant_value(rval)?;\n-                assert_eq!(discr_val as usize as u128, discr_val);\n-                Ok(discr_val as usize)\n-            },\n-        }\n-    }\n-\n-    pub fn read_discriminant_value(\n-        &self,\n-        rval: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, u128> {\n+    ) -> EvalResult<'tcx, (u128, usize)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n         if rval.layout.abi == layout::Abi::Uninhabited {\n             return err!(Unreachable);\n@@ -560,20 +546,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let discr_val = rval.layout.ty.ty_adt_def().map_or(\n                     index as u128,\n                     |def| def.discriminant_for_variant(*self.tcx, index).val);\n-                return Ok(discr_val);\n+                return Ok((discr_val, index));\n             }\n             layout::Variants::Tagged { .. } |\n             layout::Variants::NicheFilling { .. } => {},\n         }\n+        // read raw discriminant value\n         let discr_op = self.operand_field(rval, 0)?;\n         let discr_val = self.read_value(discr_op)?;\n-        trace!(\"discr value: {:?}\", discr_val);\n         let raw_discr = discr_val.to_scalar()?;\n+        trace!(\"discr value: {:?}\", raw_discr);\n+        // post-process\n         Ok(match rval.layout.variants {\n             layout::Variants::Single { .. } => bug!(),\n-            // FIXME: We should catch invalid discriminants here!\n             layout::Variants::Tagged { .. } => {\n-                if discr_val.layout.ty.is_signed() {\n+                let real_discr = if discr_val.layout.ty.is_signed() {\n                     let i = raw_discr.to_bits(discr_val.layout.size)? as i128;\n                     // going from layout tag type to typeck discriminant type\n                     // requires first sign extending with the layout discriminant\n@@ -590,7 +577,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     (truncatee << shift) >> shift\n                 } else {\n                     raw_discr.to_bits(discr_val.layout.size)?\n-                }\n+                };\n+                // Make sure we catch invalid discriminants\n+                let index = rval.layout.ty\n+                    .ty_adt_def()\n+                    .expect(\"tagged layout for non adt\")\n+                    .discriminants(self.tcx.tcx)\n+                    .position(|var| var.val == real_discr)\n+                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant(real_discr))?;\n+                (real_discr, index)\n             },\n             layout::Variants::NicheFilling {\n                 dataful_variant,\n@@ -600,8 +595,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             } => {\n                 let variants_start = *niche_variants.start() as u128;\n                 let variants_end = *niche_variants.end() as u128;\n-                match raw_discr {\n+                let real_discr = match raw_discr {\n                     Scalar::Ptr(_) => {\n+                        // The niche must be just 0 (which a pointer value never is)\n                         assert!(niche_start == 0);\n                         assert!(variants_start == variants_end);\n                         dataful_variant as u128\n@@ -616,7 +612,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             dataful_variant as u128\n                         }\n                     },\n-                }\n+                };\n+                let index = real_discr as usize;\n+                assert_eq!(index as u128, real_discr);\n+                assert!(index < rval.layout.ty\n+                    .ty_adt_def()\n+                    .expect(\"tagged layout for non adt\")\n+                    .variants.len());\n+                (real_discr, index)\n             }\n         })\n     }"}, {"sha": "13ed527e3496b6e6929ee1828aad9b4d66a014a9", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 188, "deletions": 89, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::mir;\n-use rustc::ty::{self, layout::{self, TyLayout}};\n+use rustc::ty::{self, layout::TyLayout};\n use syntax::ast::FloatTy;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -48,44 +48,103 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Returns the result of the specified operation and whether it overflowed.\n-    pub fn binary_op(\n+    fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,\n-        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n-        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n+        l: char,\n+        r: char,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        let left = left.to_scalar()?;\n-        let right = right.to_scalar()?;\n-\n-        let left_kind = match left_layout.abi {\n-            layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(left_layout.ty)),\n+        let res = match bin_op {\n+            Eq => l == r,\n+            Ne => l != r,\n+            Lt => l < r,\n+            Le => l <= r,\n+            Gt => l > r,\n+            Ge => l >= r,\n+            _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        let right_kind = match right_layout.abi {\n-            layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(right_layout.ty)),\n+        return Ok((Scalar::from_bool(res), false));\n+    }\n+\n+    fn binary_bool_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        l: bool,\n+        r: bool,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n+        let res = match bin_op {\n+            Eq => l == r,\n+            Ne => l != r,\n+            Lt => l < r,\n+            Le => l <= r,\n+            Gt => l > r,\n+            Ge => l >= r,\n+            BitAnd => l & r,\n+            BitOr => l | r,\n+            BitXor => l ^ r,\n+            _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n-        bin_op, left, left_kind, right, right_kind);\n+        return Ok((Scalar::from_bool(res), false));\n+    }\n \n-        // I: Handle operations that support pointers\n-        if !left_kind.is_float() && !right_kind.is_float() {\n-            if let Some(handled) =\n-                M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n-            {\n-                return Ok(handled);\n-            }\n+    fn binary_float_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        fty: FloatTy,\n+        // passing in raw bits\n+        l: u128,\n+        r: u128,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n+\n+        macro_rules! float_math {\n+            ($ty:path, $size:expr) => {{\n+                let l = <$ty>::from_bits(l);\n+                let r = <$ty>::from_bits(r);\n+                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n+                    bits: res.value.to_bits(),\n+                    size: $size,\n+                };\n+                let val = match bin_op {\n+                    Eq => Scalar::from_bool(l == r),\n+                    Ne => Scalar::from_bool(l != r),\n+                    Lt => Scalar::from_bool(l < r),\n+                    Le => Scalar::from_bool(l <= r),\n+                    Gt => Scalar::from_bool(l > r),\n+                    Ge => Scalar::from_bool(l >= r),\n+                    Add => bitify(l + r),\n+                    Sub => bitify(l - r),\n+                    Mul => bitify(l * r),\n+                    Div => bitify(l / r),\n+                    Rem => bitify(l % r),\n+                    _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+                };\n+                return Ok((val, false));\n+            }};\n+        }\n+        match fty {\n+            FloatTy::F32 => float_math!(Single, 4),\n+            FloatTy::F64 => float_math!(Double, 8),\n         }\n+    }\n \n-        // II: From now on, everything must be bytes, no pointers\n-        let l = left.to_bits(left_layout.size)?;\n-        let r = right.to_bits(right_layout.size)?;\n+    fn binary_int_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        // passing in raw bits\n+        l: u128,\n+        left_layout: TyLayout<'tcx>,\n+        r: u128,\n+        right_layout: TyLayout<'tcx>,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        use rustc::mir::BinOp::*;\n \n-        // These ops can have an RHS with a different numeric type.\n-        if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n+        // Shift ops can have an RHS with a different numeric type.\n+        if bin_op == Shl || bin_op == Shr {\n             let signed = left_layout.abi.is_signed();\n             let mut oflo = (r as u32 as u128) != r;\n             let mut r = r as u32;\n@@ -116,18 +175,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }, oflo));\n         }\n \n-        if left_kind != right_kind {\n+        // For the remaining ops, the types must be the same on both sides\n+        if left_layout.ty != right_layout.ty {\n             let msg = format!(\n-                \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+                \"unimplemented asymmetric binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                 bin_op,\n-                left,\n-                left_kind,\n-                right,\n-                right_kind\n+                l,\n+                left_layout.ty,\n+                r,\n+                right_layout.ty\n             );\n             return err!(Unimplemented(msg));\n         }\n \n+        // Operations that need special treatment for signed integers\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n                 Lt => Some(i128::lt),\n@@ -180,38 +241,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        if let ty::Float(fty) = left_layout.ty.sty {\n-            macro_rules! float_math {\n-                ($ty:path, $size:expr) => {{\n-                    let l = <$ty>::from_bits(l);\n-                    let r = <$ty>::from_bits(r);\n-                    let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n-                        bits: res.value.to_bits(),\n-                        size: $size,\n-                    };\n-                    let val = match bin_op {\n-                        Eq => Scalar::from_bool(l == r),\n-                        Ne => Scalar::from_bool(l != r),\n-                        Lt => Scalar::from_bool(l < r),\n-                        Le => Scalar::from_bool(l <= r),\n-                        Gt => Scalar::from_bool(l > r),\n-                        Ge => Scalar::from_bool(l >= r),\n-                        Add => bitify(l + r),\n-                        Sub => bitify(l - r),\n-                        Mul => bitify(l * r),\n-                        Div => bitify(l / r),\n-                        Rem => bitify(l % r),\n-                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n-                    };\n-                    return Ok((val, false));\n-                }};\n-            }\n-            match fty {\n-                FloatTy::F32 => float_math!(Single, 4),\n-                FloatTy::F64 => float_math!(Double, 8),\n-            }\n-        }\n-\n         let size = left_layout.size.bytes() as u8;\n \n         // only ints left\n@@ -249,11 +278,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             _ => {\n                 let msg = format!(\n-                    \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+                    \"unimplemented binary op {:?}: {:?}, {:?} (both {:?})\",\n                     bin_op,\n-                    left,\n-                    left_layout.ty,\n-                    right,\n+                    l,\n+                    r,\n                     right_layout.ty,\n                 );\n                 return err!(Unimplemented(msg));\n@@ -263,6 +291,60 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok((val, false))\n     }\n \n+    /// Returns the result of the specified operation and whether it overflowed.\n+    pub fn binary_op(\n+        &self,\n+        bin_op: mir::BinOp,\n+        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n+        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n+    ) -> EvalResult<'tcx, (Scalar, bool)> {\n+        let left = left.to_scalar()?;\n+        let right = right.to_scalar()?;\n+\n+        trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n+            bin_op, left, left_layout.ty, right, right_layout.ty);\n+\n+        match left_layout.ty.sty {\n+            ty::Char => {\n+                assert_eq!(left_layout.ty, right_layout.ty);\n+                let left = left.to_char()?;\n+                let right = right.to_char()?;\n+                self.binary_char_op(bin_op, left, right)\n+            }\n+            ty::Bool => {\n+                assert_eq!(left_layout.ty, right_layout.ty);\n+                let left = left.to_bool()?;\n+                let right = right.to_bool()?;\n+                self.binary_bool_op(bin_op, left, right)\n+            }\n+            ty::Float(fty) => {\n+                assert_eq!(left_layout.ty, right_layout.ty);\n+                let left = left.to_bits(left_layout.size)?;\n+                let right = right.to_bits(right_layout.size)?;\n+                self.binary_float_op(bin_op, fty, left, right)\n+            }\n+            _ => {\n+                // Must be integer(-like) types.  Don't forget about == on fn pointers.\n+                assert!(left_layout.ty.is_integral() || left_layout.ty.is_unsafe_ptr() ||\n+                    left_layout.ty.is_fn());\n+                assert!(right_layout.ty.is_integral() || right_layout.ty.is_unsafe_ptr() ||\n+                    right_layout.ty.is_fn());\n+\n+                // Handle operations that support pointer values\n+                if let Some(handled) =\n+                    M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n+                {\n+                    return Ok(handled);\n+                }\n+\n+                // Everything else only works with \"proper\" bits\n+                let left = left.to_bits(left_layout.size)?;\n+                let right = right.to_bits(right_layout.size)?;\n+                self.binary_int_op(bin_op, left, left_layout, right, right_layout)\n+            }\n+        }\n+    }\n+\n     pub fn unary_op(\n         &self,\n         un_op: mir::UnOp,\n@@ -273,25 +355,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         use rustc_apfloat::ieee::{Single, Double};\n         use rustc_apfloat::Float;\n \n-        let size = layout.size;\n-        let bytes = val.to_bits(size)?;\n-\n-        let result_bytes = match (un_op, &layout.ty.sty) {\n-\n-            (Not, ty::Bool) => !val.to_bool()? as u128,\n-\n-            (Not, _) => !bytes,\n-\n-            (Neg, ty::Float(FloatTy::F32)) => Single::to_bits(-Single::from_bits(bytes)),\n-            (Neg, ty::Float(FloatTy::F64)) => Double::to_bits(-Double::from_bits(bytes)),\n-\n-            (Neg, _) if bytes == (1 << (size.bits() - 1)) => return err!(OverflowNeg),\n-            (Neg, _) => (-(bytes as i128)) as u128,\n-        };\n+        trace!(\"Running unary op {:?}: {:?} ({:?})\", un_op, val, layout.ty.sty);\n \n-        Ok(Scalar::Bits {\n-            bits: self.truncate(result_bytes, layout),\n-            size: size.bytes() as u8,\n-        })\n+        match layout.ty.sty {\n+            ty::Bool => {\n+                let val = val.to_bool()?;\n+                let res = match un_op {\n+                    Not => !val,\n+                    _ => bug!(\"Invalid bool op {:?}\", un_op)\n+                };\n+                Ok(Scalar::from_bool(res))\n+            }\n+            ty::Float(fty) => {\n+                let val = val.to_bits(layout.size)?;\n+                let res = match (un_op, fty) {\n+                    (Neg, FloatTy::F32) => Single::to_bits(-Single::from_bits(val)),\n+                    (Neg, FloatTy::F64) => Double::to_bits(-Double::from_bits(val)),\n+                    _ => bug!(\"Invalid float op {:?}\", un_op)\n+                };\n+                Ok(Scalar::Bits { bits: res, size: layout.size.bytes() as u8 })\n+            }\n+            _ => {\n+                assert!(layout.ty.is_integral());\n+                let val = val.to_bits(layout.size)?;\n+                let res = match un_op {\n+                    Not => !val,\n+                    Neg => {\n+                        assert!(layout.abi.is_signed());\n+                        (-(val as i128)) as u128\n+                    }\n+                };\n+                // res needs tuncating\n+                Ok(Scalar::Bits {\n+                    bits: self.truncate(res, layout),\n+                    size: layout.size.bytes() as u8,\n+                })\n+            }\n+        }\n     }\n }"}, {"sha": "0a6fef3008433c04283d247bbba0d41a357cf315", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 155, "deletions": 186, "changes": 341, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -12,7 +12,6 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n-use std::hash::{Hash, Hasher};\n use std::convert::TryFrom;\n \n use rustc::mir;\n@@ -32,7 +31,10 @@ pub struct MemPlace {\n     /// However, it may never be undef.\n     pub ptr: Scalar,\n     pub align: Align,\n-    pub extra: PlaceExtra,\n+    /// Metadata for unsized places.  Interpretation is up to the type.\n+    /// Must not be present for sized types, but can be missing for unsized types\n+    /// (e.g. `extern type`).\n+    pub extra: Option<Scalar>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -48,14 +50,6 @@ pub enum Place {\n     },\n }\n \n-// Extra information for fat pointers / places\n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum PlaceExtra {\n-    None,\n-    Length(u64),\n-    Vtable(Pointer),\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub struct PlaceTy<'tcx> {\n     place: Place,\n@@ -101,7 +95,7 @@ impl MemPlace {\n         MemPlace {\n             ptr,\n             align,\n-            extra: PlaceExtra::None,\n+            extra: None,\n         }\n     }\n \n@@ -112,7 +106,7 @@ impl MemPlace {\n \n     #[inline(always)]\n     pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n-        assert_eq!(self.extra, PlaceExtra::None);\n+        assert_eq!(self.extra, None);\n         (self.ptr, self.align)\n     }\n \n@@ -127,13 +121,12 @@ impl MemPlace {\n \n     /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n     /// This is the inverse of `ref_to_mplace`.\n-    pub fn to_ref(self, cx: impl HasDataLayout) -> Value {\n+    pub fn to_ref(self) -> Value {\n         // We ignore the alignment of the place here -- special handling for packed structs ends\n         // at the `&` operator.\n         match self.extra {\n-            PlaceExtra::None => Value::Scalar(self.ptr.into()),\n-            PlaceExtra::Length(len) => Value::new_slice(self.ptr.into(), len, cx),\n-            PlaceExtra::Vtable(vtable) => Value::new_dyn_trait(self.ptr.into(), vtable),\n+            None => Value::Scalar(self.ptr.into()),\n+            Some(extra) => Value::ScalarPair(self.ptr.into(), extra.into()),\n         }\n     }\n }\n@@ -145,33 +138,32 @@ impl<'tcx> MPlaceTy<'tcx> {\n     }\n \n     #[inline]\n-    pub(super) fn len(self) -> u64 {\n-        // Sanity check\n-        let ty_len = match self.layout.fields {\n-            layout::FieldPlacement::Array { count, .. } => count,\n-            _ => bug!(\"Length for non-array layout {:?} requested\", self.layout),\n-        };\n-        if let PlaceExtra::Length(len) = self.extra {\n-            len\n+    pub(super) fn len(self, cx: impl HasDataLayout) -> EvalResult<'tcx, u64> {\n+        if self.layout.is_unsized() {\n+            // We need to consult `extra` metadata\n+            match self.layout.ty.sty {\n+                ty::Slice(..) | ty::Str =>\n+                    return self.extra.unwrap().to_usize(cx),\n+                _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n+            }\n         } else {\n-            ty_len\n+            // Go through the layout.  There are lots of types that support a length,\n+            // e.g. SIMD types.\n+            match self.layout.fields {\n+                layout::FieldPlacement::Array { count, .. } => Ok(count),\n+                _ => bug!(\"len not supported on sized type {:?}\", self.layout.ty),\n+            }\n         }\n     }\n-}\n \n-// Validation needs to hash MPlaceTy, but we cannot hash Layout -- so we just hash the type\n-impl<'tcx> Hash for MPlaceTy<'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.mplace.hash(state);\n-        self.layout.ty.hash(state);\n-    }\n-}\n-impl<'tcx> PartialEq for MPlaceTy<'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.mplace == other.mplace && self.layout.ty == other.layout.ty\n+    #[inline]\n+    pub(super) fn vtable(self) -> EvalResult<'tcx, Pointer> {\n+        match self.layout.ty.sty {\n+            ty::Dynamic(..) => self.extra.unwrap().to_ptr(),\n+            _ => bug!(\"vtable not supported on type {:?}\", self.layout.ty),\n+        }\n     }\n }\n-impl<'tcx> Eq for MPlaceTy<'tcx> {}\n \n impl<'tcx> OpTy<'tcx> {\n     #[inline(always)]\n@@ -246,28 +238,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n-        let mplace = match self.tcx.struct_tail(pointee_type).sty {\n-            ty::Dynamic(..) => {\n-                let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n-                MemPlace {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Vtable(vtable),\n-                }\n-            }\n-            ty::Str | ty::Slice(_) => {\n-                let (ptr, len) = val.to_scalar_slice(self)?;\n-                MemPlace {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Length(len),\n-                }\n-            }\n-            _ => MemPlace {\n-                ptr: val.to_scalar()?,\n-                align: layout.align,\n-                extra: PlaceExtra::None,\n-            },\n+        let align = layout.align;\n+        let mplace = match *val {\n+            Value::Scalar(ptr) =>\n+                MemPlace { ptr: ptr.not_undef()?, align, extra: None },\n+            Value::ScalarPair(ptr, extra) =>\n+                MemPlace { ptr: ptr.not_undef()?, align, extra: Some(extra.not_undef()?) },\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n@@ -286,9 +262,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n                 offsets[usize::try_from(field).unwrap()],\n             layout::FieldPlacement::Array { stride, .. } => {\n-                let len = base.len();\n-                assert!(field < len,\n-                        \"Tried to access element {} of array/slice with length {}\", field, len);\n+                let len = base.len(self)?;\n+                assert!(field < len, \"Tried to access element {} of array/slice with length {}\",\n+                    field, len);\n                 stride * field\n             }\n             layout::FieldPlacement::Union(count) => {\n@@ -302,29 +278,21 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // above). In that case, all fields are equal.\n         let field_layout = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n \n-        // Adjust offset\n-        let offset = match base.extra {\n-            PlaceExtra::Vtable(vtable) => {\n-                let (_, align) = self.read_size_and_align_from_vtable(vtable)?;\n-                // FIXME: Is this right? Should we always do this, or only when actually\n-                // accessing the field to which the vtable applies?\n-                offset.abi_align(align)\n-            }\n-            _ => {\n-                // No adjustment needed\n-                offset\n-            }\n-        };\n+        // Offset may need adjustment for unsized fields\n+        let (extra, offset) = if field_layout.is_unsized() {\n+            // re-use parent metadata to determine dynamic field layout\n+            let (_, align) = self.size_and_align_of(base.extra, field_layout)?;\n+            (base.extra, offset.abi_align(align))\n \n-        let ptr = base.ptr.ptr_offset(offset, self)?;\n-        let align = base.align.min(field_layout.align);\n-        let extra = if !field_layout.is_unsized() {\n-            PlaceExtra::None\n         } else {\n-            assert!(base.extra != PlaceExtra::None, \"Expected fat ptr\");\n-            base.extra\n+            // base.extra could be present; we might be accessing a sized field of an unsized\n+            // struct.\n+            (None, offset)\n         };\n \n+        let ptr = base.ptr.ptr_offset(offset, self)?;\n+        let align = base.align.min(field_layout.align); // only use static information\n+\n         Ok(MPlaceTy { mplace: MemPlace { ptr, align, extra }, layout: field_layout })\n     }\n \n@@ -334,7 +302,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         &self,\n         base: MPlaceTy<'tcx>,\n     ) -> EvalResult<'tcx, impl Iterator<Item=EvalResult<'tcx, MPlaceTy<'tcx>>> + 'a> {\n-        let len = base.len();\n+        let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         let stride = match base.layout.fields {\n             layout::FieldPlacement::Array { stride, .. } => stride,\n             _ => bug!(\"mplace_array_fields: expected an array layout\"),\n@@ -344,7 +312,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok((0..len).map(move |i| {\n             let ptr = base.ptr.ptr_offset(i * stride, dl)?;\n             Ok(MPlaceTy {\n-                mplace: MemPlace { ptr, align: base.align, extra: PlaceExtra::None },\n+                mplace: MemPlace { ptr, align: base.align, extra: None },\n                 layout\n             })\n         }))\n@@ -356,7 +324,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         from: u64,\n         to: u64,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-        let len = base.len();\n+        let len = base.len(self)?; // also asserts that we have a type where this makes sense\n         assert!(from <= len - to);\n \n         // Not using layout method because that works with usize, and does not work with slices\n@@ -371,10 +339,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         // Compute extra and new layout\n         let inner_len = len - to - from;\n         let (extra, ty) = match base.layout.ty.sty {\n+            // It is not nice to match on the type, but that seems to be the only way to\n+            // implement this.\n             ty::Array(inner, _) =>\n-                (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n-            ty::Slice(..) =>\n-                (PlaceExtra::Length(inner_len), base.layout.ty),\n+                (None, self.tcx.mk_array(inner, inner_len)),\n+            ty::Slice(..) => {\n+                let len = Scalar::Bits {\n+                    bits: inner_len.into(),\n+                    size: self.memory.pointer_size().bytes() as u8\n+                };\n+                (Some(len), base.layout.ty)\n+            }\n             _ =>\n                 bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n         };\n@@ -392,7 +367,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         variant: usize,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         // Downcasts only change the layout\n-        assert_eq!(base.extra, PlaceExtra::None);\n+        assert_eq!(base.extra, None);\n         Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n@@ -421,7 +396,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 min_length,\n                 from_end,\n             } => {\n-                let n = base.len();\n+                let n = base.len(self)?;\n                 assert!(n >= min_length as u64);\n \n                 let index = if from_end {\n@@ -487,33 +462,24 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         })\n     }\n \n-    /// Compute a place.  You should only use this if you intend to write into this\n-    /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n-    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+    /// Evaluate statics and promoteds to an `MPlace`.  Used to share some code between\n+    /// `eval_place` and `eval_place_to_op`.\n+    pub(super) fn eval_place_to_mplace(\n+        &self,\n+        mir_place: &mir::Place<'tcx>\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         use rustc::mir::Place::*;\n-        let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => PlaceTy {\n-                place: self.frame().return_place,\n-                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n-            },\n-            Local(local) => PlaceTy {\n-                place: Place::Local {\n-                    frame: self.cur_frame(),\n-                    local,\n-                },\n-                layout: self.layout_of_local(self.cur_frame(), local)?,\n-            },\n-\n+        Ok(match *mir_place {\n             Promoted(ref promoted) => {\n                 let instance = self.frame().instance;\n                 let op = self.global_to_op(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n                 })?;\n-                let mplace = op.to_mem_place();\n+                let mplace = op.to_mem_place(); // these are always in memory\n                 let ty = self.monomorphize(promoted.1, self.substs());\n-                PlaceTy {\n-                    place: Place::Ptr(mplace),\n+                MPlaceTy {\n+                    mplace,\n                     layout: self.layout_of(ty)?,\n                 }\n             }\n@@ -526,18 +492,51 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     instance,\n                     promoted: None\n                 };\n-                let alloc = Machine::init_static(self, cid)?;\n-                MPlaceTy::from_aligned_ptr(alloc.into(), layout).into()\n+                // Just create a lazy reference, so we can support recursive statics.\n+                // tcx takes are of assigning every static one and only one unique AllocId.\n+                // When the data here is ever actually used, memory will notice,\n+                // and it knows how to deal with alloc_id that are present in the\n+                // global table but not in its local memory: It calls back into tcx through\n+                // a query, triggering the CTFE machinery to actually turn this lazy reference\n+                // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n+                // this EvalContext uses another Machine (e.g., in miri).  This is what we\n+                // want!  This way, computing statics works concistently between codegen\n+                // and miri: They use the same query to eventually obtain a `ty::Const`\n+                // and use that for further computation.\n+                let alloc = self.tcx.alloc_map.lock().intern_static(cid.instance.def_id());\n+                MPlaceTy::from_aligned_ptr(alloc.into(), layout)\n             }\n \n+            _ => bug!(\"eval_place_to_mplace called on {:?}\", mir_place),\n+        })\n+    }\n+\n+    /// Compute a place.  You should only use this if you intend to write into this\n+    /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n+    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        use rustc::mir::Place::*;\n+        let place = match *mir_place {\n+            Local(mir::RETURN_PLACE) => PlaceTy {\n+                place: self.frame().return_place,\n+                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+            },\n+            Local(local) => PlaceTy {\n+                place: Place::Local {\n+                    frame: self.cur_frame(),\n+                    local,\n+                },\n+                layout: self.layout_of_local(self.cur_frame(), local)?,\n+            },\n+\n             Projection(ref proj) => {\n                 let place = self.eval_place(&proj.base)?;\n                 self.place_projection(place, &proj.elem)?\n             }\n+\n+            _ => self.eval_place_to_mplace(mir_place)?.into(),\n         };\n \n         self.dump_place(place.place);\n-\n         Ok(place)\n     }\n \n@@ -656,20 +655,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         let mplace = match place.place {\n             Place::Local { frame, local } => {\n-                // FIXME: Consider not doing anything for a ZST, and just returning\n-                // a fake pointer?\n-\n-                // We need the layout of the local.  We can NOT use the layout we got,\n-                // that might e.g. be a downcast variant!\n-                let local_layout = self.layout_of_local(frame, local)?;\n-                // Make sure it has a place\n-                let rval = *self.stack[frame].locals[local].access()?;\n-                let mplace = self.allocate_op(OpTy { op: rval, layout: local_layout })?.mplace;\n-                // This might have allocated the flag\n-                *self.stack[frame].locals[local].access_mut()? =\n-                    Operand::Indirect(mplace);\n-                // done\n-                mplace\n+                match *self.stack[frame].locals[local].access()? {\n+                    Operand::Indirect(mplace) => mplace,\n+                    Operand::Immediate(value) => {\n+                        // We need to make an allocation.\n+                        // FIXME: Consider not doing anything for a ZST, and just returning\n+                        // a fake pointer?  Are we even called for ZST?\n+\n+                        // We need the layout of the local.  We can NOT use the layout we got,\n+                        // that might e.g. be an inner field of a struct with `Scalar` layout,\n+                        // that has different alignment than the outer field.\n+                        let local_layout = self.layout_of_local(frame, local)?;\n+                        let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n+                        self.write_value_to_mplace(value, ptr)?;\n+                        let mplace = ptr.mplace;\n+                        // Update the local\n+                        *self.stack[frame].locals[local].access_mut()? =\n+                            Operand::Indirect(mplace);\n+                        mplace\n+                    }\n+                }\n             }\n             Place::Ptr(mplace) => mplace\n         };\n@@ -687,38 +692,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n     }\n \n-    /// Make a place for an operand, allocating if needed\n-    pub fn allocate_op(\n-        &mut self,\n-        OpTy { op, layout }: OpTy<'tcx>,\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-        Ok(match op {\n-            Operand::Indirect(mplace) => MPlaceTy { mplace, layout },\n-            Operand::Immediate(value) => {\n-                // FIXME: Is stack always right here?\n-                let ptr = self.allocate(layout, MemoryKind::Stack)?;\n-                self.write_value_to_mplace(value, ptr)?;\n-                ptr\n-            },\n-        })\n-    }\n-\n-    pub fn write_discriminant_value(\n+    pub fn write_discriminant_index(\n         &mut self,\n         variant_index: usize,\n         dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         match dest.layout.variants {\n             layout::Variants::Single { index } => {\n-                if index != variant_index {\n-                    // If the layout of an enum is `Single`, all\n-                    // other variants are necessarily uninhabited.\n-                    assert_eq!(dest.layout.for_variant(&self, variant_index).abi,\n-                               layout::Abi::Uninhabited);\n-                }\n+                assert_eq!(index, variant_index);\n             }\n             layout::Variants::Tagged { ref tag, .. } => {\n-                let discr_val = dest.layout.ty.ty_adt_def().unwrap()\n+                let adt_def = dest.layout.ty.ty_adt_def().unwrap();\n+                assert!(variant_index < adt_def.variants.len());\n+                let discr_val = adt_def\n                     .discriminant_for_variant(*self.tcx, variant_index)\n                     .val;\n \n@@ -741,6 +727,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 niche_start,\n                 ..\n             } => {\n+                assert!(variant_index < dest.layout.ty.ty_adt_def().unwrap().variants.len());\n                 if variant_index != dataful_variant {\n                     let niche_dest =\n                         self.place_field(dest, 0)?;\n@@ -770,43 +757,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         Ok(OpTy { op, layout: place.layout })\n     }\n \n-    /// Turn a place that is a dyn trait (i.e., PlaceExtra::Vtable and the appropriate layout)\n-    /// or a slice into the specific fixed-size place and layout that is given by the vtable/len.\n-    /// This \"unpacks\" the existential quantifier, so to speak.\n-    pub fn unpack_unsized_mplace(\n-        &self,\n-        mplace: MPlaceTy<'tcx>\n-    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n-        trace!(\"Unpacking {:?} ({:?})\", *mplace, mplace.layout.ty);\n-        let layout = match mplace.extra {\n-            PlaceExtra::Vtable(vtable) => {\n-                // the drop function signature\n-                let drop_instance = self.read_drop_type_from_vtable(vtable)?;\n-                trace!(\"Found drop fn: {:?}\", drop_instance);\n-                let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n-                let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n-                // the drop function takes *mut T where T is the type being dropped, so get that\n-                let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n-                let layout = self.layout_of(ty)?;\n-                // Sanity checks\n-                let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n-                assert_eq!(size, layout.size);\n-                assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n-                // FIXME: More checks for the vtable? We could make sure it is exactly\n-                // the one one would expect for this type.\n-                // Done!\n-                layout\n-            },\n-            PlaceExtra::Length(len) => {\n-                let ty = self.tcx.mk_array(mplace.layout.field(self, 0)?.ty, len);\n-                self.layout_of(ty)?\n-            }\n-            PlaceExtra::None => bug!(\"Expected a fat pointer\"),\n-        };\n-        trace!(\"Unpacked type: {:?}\", layout.ty);\n-        Ok(MPlaceTy {\n-            mplace: MemPlace { extra: PlaceExtra::None, ..*mplace },\n+    /// Turn a place with a `dyn Trait` type into a place with the actual dynamic type.\n+    /// Also return some more information so drop doesn't have to run the same code twice.\n+    pub(super) fn unpack_dyn_trait(&self, mplace: MPlaceTy<'tcx>)\n+    -> EvalResult<'tcx, (ty::Instance<'tcx>, MPlaceTy<'tcx>)> {\n+        let vtable = mplace.vtable()?; // also sanity checks the type\n+        let (instance, ty) = self.read_drop_type_from_vtable(vtable)?;\n+        let layout = self.layout_of(ty)?;\n+\n+        // More sanity checks\n+        let (size, align) = self.read_size_and_align_from_vtable(vtable)?;\n+        assert_eq!(size, layout.size);\n+        assert_eq!(align.abi(), layout.align.abi()); // only ABI alignment is preserved\n+        // FIXME: More checks for the vtable? We could make sure it is exactly\n+        // the one one would expect for this type.\n+\n+        let mplace = MPlaceTy {\n+            mplace: MemPlace { extra: None, ..*mplace },\n             layout\n-        })\n+        };\n+        Ok((instance, mplace))\n     }\n }"}, {"sha": "933f06d3d10a0b9da935d2f70ec44c769913fdc2", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -76,8 +76,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         self.loop_detector.observe_and_analyze(&self.machine, &self.stack, &self.memory)\n     }\n \n+    pub fn run(&mut self) -> EvalResult<'tcx> {\n+        while self.step()? {}\n+        Ok(())\n+    }\n+\n     /// Returns true as long as there are more things to do.\n-    pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n+    fn step(&mut self) -> EvalResult<'tcx, bool> {\n         if self.stack.is_empty() {\n             return Ok(false);\n         }\n@@ -122,7 +127,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 variant_index,\n             } => {\n                 let dest = self.eval_place(place)?;\n-                self.write_discriminant_value(variant_index, dest)?;\n+                self.write_discriminant_index(variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -147,10 +152,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     M::validation_op(self, op, operand)?;\n                 }\n             }\n-            EndRegion(ce) => {\n-                M::end_region(self, Some(ce))?;\n-            }\n \n+            EndRegion(..) => {}\n             UserAssertTy(..) => {}\n \n             // Defined to do nothing. These are added by optimization passes, to avoid changing the\n@@ -185,9 +188,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 let layout = if binop_left_homogeneous(bin_op) { Some(dest.layout) } else { None };\n-                let left = self.eval_operand_and_read_value(left, layout)?;\n+                let left = self.read_value(self.eval_operand(left, layout)?)?;\n                 let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n-                let right = self.eval_operand_and_read_value(right, layout)?;\n+                let right = self.read_value(self.eval_operand(right, layout)?)?;\n                 self.binop_ignore_overflow(\n                     bin_op,\n                     left,\n@@ -198,9 +201,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n-                let left = self.eval_operand_and_read_value(left, None)?;\n+                let left = self.read_value(self.eval_operand(left, None)?)?;\n                 let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n-                let right = self.eval_operand_and_read_value(right, layout)?;\n+                let right = self.read_value(self.eval_operand(right, layout)?)?;\n                 self.binop_with_overflow(\n                     bin_op,\n                     left,\n@@ -211,15 +214,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n-                let val = self.eval_operand_and_read_value(operand, Some(dest.layout))?;\n+                let val = self.read_value(self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n                 self.write_scalar(val, dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, _, active_field_index) => {\n-                        self.write_discriminant_value(variant_index, dest)?;\n+                        self.write_discriminant_index(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)\n                         } else {\n@@ -243,7 +246,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Repeat(ref operand, _) => {\n                 let op = self.eval_operand(operand, None)?;\n                 let dest = self.force_allocation(dest)?;\n-                let length = dest.len();\n+                let length = dest.len(&self)?;\n \n                 if length > 0 {\n                     // write the first\n@@ -265,7 +268,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n                 let mplace = self.force_allocation(src)?;\n-                let len = mplace.len();\n+                let len = mplace.len(&self)?;\n                 let size = self.memory.pointer_size().bytes() as u8;\n                 self.write_scalar(\n                     Scalar::Bits {\n@@ -278,7 +281,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?.to_ref(&self);\n+                let val = self.force_allocation(src)?.to_ref();\n                 self.write_value(val, dest)?;\n             }\n \n@@ -309,7 +312,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             Discriminant(ref place) => {\n                 let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant_value(self.place_to_op(place)?)?;\n+                let discr_val = self.read_discriminant(self.place_to_op(place)?)?.0;\n                 let size = dest.layout.size.bytes() as u8;\n                 self.write_scalar(Scalar::Bits {\n                     bits: discr_val,\n@@ -327,8 +330,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         debug!(\"{:?}\", terminator.kind);\n         self.tcx.span = terminator.source_info.span;\n         self.memory.tcx.span = terminator.source_info.span;\n+\n+        let old_stack = self.cur_frame();\n+        let old_bb = self.frame().block;\n         self.eval_terminator(terminator)?;\n         if !self.stack.is_empty() {\n+            // This should change *something*\n+            debug_assert!(self.cur_frame() != old_stack || self.frame().block != old_bb);\n             debug!(\"// {:?}\", self.frame().block);\n         }\n         Ok(())"}, {"sha": "11826e0ce0c25897a31a1d2748905df7cc0a8f9e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "renamed", "additions": 191, "deletions": 139, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -8,23 +8,29 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::borrow::Cow;\n+\n use rustc::mir;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::LayoutOf;\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, Scalar};\n-use super::{EvalContext, Machine, Value, OpTy, PlaceTy, ValTy, Operand};\n-\n-use rustc_data_structures::indexed_vec::Idx;\n-\n-mod drop;\n+use super::{\n+    EvalContext, Machine, Value, OpTy, Place, PlaceTy, ValTy, Operand, StackPopCleanup\n+};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn goto_block(&mut self, target: mir::BasicBlock) {\n-        self.frame_mut().block = target;\n-        self.frame_mut().stmt = 0;\n+    #[inline]\n+    pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n+        if let Some(target) = target {\n+            self.frame_mut().block = target;\n+            self.frame_mut().stmt = 0;\n+            Ok(())\n+        } else {\n+            err!(Unreachable)\n+        }\n     }\n \n     pub(super) fn eval_terminator(\n@@ -38,16 +44,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.pop_stack_frame()?\n             }\n \n-            Goto { target } => self.goto_block(target),\n+            Goto { target } => self.goto_block(Some(target))?,\n \n             SwitchInt {\n                 ref discr,\n                 ref values,\n                 ref targets,\n                 ..\n             } => {\n-                let discr_val = self.eval_operand(discr, None)?;\n-                let discr = self.read_value(discr_val)?;\n+                let discr = self.read_value(self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n@@ -69,7 +74,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                 }\n \n-                self.goto_block(target_block);\n+                self.goto_block(Some(target_block))?;\n             }\n \n             Call {\n@@ -78,9 +83,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ref destination,\n                 ..\n             } => {\n-                let destination = match *destination {\n-                    Some((ref lv, target)) => Some((self.eval_place(lv)?, target)),\n-                    None => None,\n+                let (dest, ret) = match *destination {\n+                    Some((ref lv, target)) => (Some(self.eval_place(lv)?), Some(target)),\n+                    None => (None, None),\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n@@ -91,43 +96,44 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n                             ty::FnDef(..) => {\n-                                let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    ty::ParamEnv::reveal_all(),\n+                                    self.param_env,\n                                     &sig,\n                                 );\n+                                let real_sig = instance_ty.fn_sig(*self.tcx);\n                                 let real_sig = self.tcx.normalize_erasing_late_bound_regions(\n-                                    ty::ParamEnv::reveal_all(),\n+                                    self.param_env,\n                                     &real_sig,\n                                 );\n                                 if !self.check_sig_compat(sig, real_sig)? {\n                                     return err!(FunctionPointerTyMismatch(real_sig, sig));\n                                 }\n+                                (instance, sig)\n                             }\n-                            ref other => bug!(\"instance def ty: {:?}\", other),\n+                            _ => bug!(\"unexpected fn ptr to ty: {:?}\", instance_ty),\n                         }\n-                        (instance, sig)\n                     }\n-                    ty::FnDef(def_id, substs) => (\n-                        self.resolve(def_id, substs)?,\n-                        func.layout.ty.fn_sig(*self.tcx),\n-                    ),\n+                    ty::FnDef(def_id, substs) => {\n+                        let sig = func.layout.ty.fn_sig(*self.tcx);\n+                        let sig = self.tcx.normalize_erasing_late_bound_regions(\n+                            self.param_env,\n+                            &sig,\n+                        );\n+                        (self.resolve(def_id, substs)?, sig)\n+                    },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n-                let sig = self.tcx.normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &sig,\n-                );\n                 self.eval_fn_call(\n                     fn_def,\n-                    destination,\n                     &args[..],\n+                    dest,\n+                    ret,\n                     terminator.source_info.span,\n-                    sig,\n+                    Some(sig),\n                 )?;\n             }\n \n@@ -157,19 +163,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_and_read_value(cond, None)?\n-                    .to_scalar()?\n-                    .to_bool()?;\n+                let cond_val = self.read_value(self.eval_operand(cond, None)?)?\n+                    .to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n-                    self.goto_block(target);\n+                    self.goto_block(Some(target))?;\n                 } else {\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand_and_read_value(len, None)\n+                            let len = self.read_value(self.eval_operand(len, None)?)\n                                 .expect(\"can't eval len\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.eval_operand_and_read_value(index, None)\n+                            let index = self.read_value(self.eval_operand(index, None)?)\n                                 .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })\n@@ -270,138 +275,146 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         return Ok(false);\n     }\n \n+    /// Call this function -- pushing the stack frame and initializing the arguments.\n+    /// `sig` is optional in case of FnPtr/FnDef -- but mandatory for closures!\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n         args: &[OpTy<'tcx>],\n+        dest: Option<PlaceTy<'tcx>>,\n+        ret: Option<mir::BasicBlock>,\n         span: Span,\n-        sig: ty::FnSig<'tcx>,\n+        sig: Option<ty::FnSig<'tcx>>,\n     ) -> EvalResult<'tcx> {\n         trace!(\"eval_fn_call: {:#?}\", instance);\n-        if let Some((place, _)) = destination {\n-            assert_eq!(place.layout.ty, sig.output());\n-        }\n+\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n-                let (ret, target) = match destination {\n+                // The intrinsic itself cannot diverge, so if we got here without a return\n+                // place... (can happen e.g. for transmute returning `!`)\n+                let dest = match dest {\n                     Some(dest) => dest,\n-                    _ => return err!(Unreachable),\n+                    None => return err!(Unreachable)\n                 };\n-                M::call_intrinsic(self, instance, args, ret, target)?;\n-                self.dump_place(*ret);\n-                Ok(())\n-            }\n-            // FIXME: figure out why we can't just go through the shim\n-            ty::InstanceDef::ClosureOnceShim { .. } => {\n-                if M::eval_fn_call(self, instance, destination, args, span)? {\n-                    return Ok(());\n-                }\n-                let mut arg_locals = self.frame().mir.args_iter();\n-                match sig.abi {\n-                    // closure as closure once\n-                    Abi::RustCall => {\n-                        for (arg_local, &op) in arg_locals.zip(args) {\n-                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.copy_op(op, dest)?;\n-                        }\n-                    }\n-                    // non capture closure as fn ptr\n-                    // need to inject zst ptr for closure object (aka do nothing)\n-                    // and need to pack arguments\n-                    Abi::Rust => {\n-                        trace!(\n-                            \"args: {:#?}\",\n-                            self.frame().mir.args_iter().zip(args.iter())\n-                                .map(|(local, arg)| (local, **arg, arg.layout.ty))\n-                                .collect::<Vec<_>>()\n-                        );\n-                        let local = arg_locals.nth(1).unwrap();\n-                        for (i, &op) in args.into_iter().enumerate() {\n-                            let dest = self.eval_place(&mir::Place::Local(local).field(\n-                                mir::Field::new(i),\n-                                op.layout.ty,\n-                            ))?;\n-                            self.copy_op(op, dest)?;\n-                        }\n-                    }\n-                    _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n-                }\n+                M::call_intrinsic(self, instance, args, dest)?;\n+                // No stack frame gets pushed, the main loop will just act as if the\n+                // call completed.\n+                self.goto_block(ret)?;\n+                self.dump_place(*dest);\n                 Ok(())\n             }\n+            ty::InstanceDef::ClosureOnceShim { .. } |\n             ty::InstanceDef::FnPtrShim(..) |\n             ty::InstanceDef::DropGlue(..) |\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n-                // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if M::eval_fn_call(self, instance, destination, args, span)? {\n-                    // FIXME: Can we make it return the frame to push, instead\n-                    // of the hook doing half of the work and us doing the argument\n-                    // initialization?\n-                    return Ok(());\n-                }\n+                let mir = match M::find_fn(self, instance, args, dest, ret)? {\n+                    Some(mir) => mir,\n+                    None => return Ok(()),\n+                };\n+\n+                let return_place = match dest {\n+                    Some(place) => *place,\n+                    None => Place::null(&self),\n+                };\n+                self.push_stack_frame(\n+                    instance,\n+                    span,\n+                    mir,\n+                    return_place,\n+                    StackPopCleanup::Goto(ret),\n+                )?;\n \n-                // Pass the arguments\n-                let mut arg_locals = self.frame().mir.args_iter();\n-                trace!(\"ABI: {:?}\", sig.abi);\n+                // If we didn't get a signture, ask `fn_sig`\n+                let sig = sig.unwrap_or_else(|| {\n+                    let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n+                    self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig)\n+                });\n+                assert_eq!(sig.inputs().len(), args.len());\n+                // We can't test the types, as it is fine if the types are ABI-compatible but\n+                // not equal.\n+\n+                // Figure out how to pass which arguments.\n+                // FIXME: Somehow this is horribly full of special cases here, and codegen has\n+                // none of that.  What is going on?\n                 trace!(\n-                    \"args: {:#?}\",\n-                    self.frame().mir.args_iter().zip(args.iter())\n-                        .map(|(local, arg)| (local, **arg, arg.layout.ty)).collect::<Vec<_>>()\n+                    \"ABI: {:?}, args: {:#?}\",\n+                    sig.abi,\n+                    args.iter()\n+                        .map(|arg| (arg.layout.ty, format!(\"{:?}\", **arg)))\n+                        .collect::<Vec<_>>()\n+                );\n+                trace!(\n+                    \"spread_arg: {:?}, locals: {:#?}\",\n+                    mir.spread_arg,\n+                    mir.args_iter()\n+                        .map(|local|\n+                            (local, self.layout_of_local(self.cur_frame(), local).unwrap().ty)\n+                        )\n+                        .collect::<Vec<_>>()\n                 );\n-                match sig.abi {\n-                    Abi::RustCall => {\n-                        assert_eq!(args.len(), 2);\n-\n-                        {\n-                            // write first argument\n-                            let first_local = arg_locals.next().unwrap();\n-                            let dest = self.eval_place(&mir::Place::Local(first_local))?;\n-                            self.copy_op(args[0], dest)?;\n-                        }\n \n-                        // unpack and write all other args\n-                        let layout = args[1].layout;\n-                        if let ty::Tuple(_) = layout.ty.sty {\n-                            if layout.is_zst() {\n-                                // Nothing to do, no need to unpack zsts\n-                                return Ok(());\n-                            }\n-                            if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n-                                for (i, arg_local) in arg_locals.enumerate() {\n-                                    let arg = self.operand_field(args[1], i as u64)?;\n-                                    let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                                    self.copy_op(arg, dest)?;\n-                                }\n-                            } else {\n-                                trace!(\"manual impl of rust-call ABI\");\n-                                // called a manual impl of a rust-call function\n-                                let dest = self.eval_place(\n-                                    &mir::Place::Local(arg_locals.next().unwrap()),\n-                                )?;\n-                                self.copy_op(args[1], dest)?;\n-                            }\n-                        } else {\n-                            bug!(\n-                                \"rust-call ABI tuple argument was {:#?}\",\n-                                layout\n-                            );\n-                        }\n+                // We have two iterators: Where the arguments come from,\n+                // and where they go to.\n+\n+                // For where they come from: If the ABI is RustCall, we untuple the\n+                // last incoming argument.  These do not have the same type,\n+                // so to keep the code paths uniform we accept an allocation\n+                // (for RustCall ABI only).\n+                let args_effective : Cow<[OpTy<'tcx>]> =\n+                    if sig.abi == Abi::RustCall && !args.is_empty() {\n+                        // Untuple\n+                        let (&untuple_arg, args) = args.split_last().unwrap();\n+                        trace!(\"eval_fn_call: Will pass last argument by untupling\");\n+                        Cow::from(args.iter().map(|&a| Ok(a))\n+                            .chain((0..untuple_arg.layout.fields.count()).into_iter()\n+                                .map(|i| self.operand_field(untuple_arg, i as u64))\n+                            )\n+                            .collect::<EvalResult<Vec<OpTy<'tcx>>>>()?)\n+                    } else {\n+                        // Plain arg passing\n+                        Cow::from(args)\n+                    };\n+\n+                // Now we have to spread them out across the callee's locals,\n+                // taking into account the `spread_arg`.\n+                let mut args_iter = args_effective.iter();\n+                let mut local_iter = mir.args_iter();\n+                // HACK: ClosureOnceShim calls something that expects a ZST as\n+                // first argument, but the callers do not actually pass that ZST.\n+                // Codegen doesn't care because ZST arguments do not even exist there.\n+                match instance.def {\n+                    ty::InstanceDef::ClosureOnceShim { .. } if sig.abi == Abi::Rust => {\n+                        let local = local_iter.next().unwrap();\n+                        let dest = self.eval_place(&mir::Place::Local(local))?;\n+                        assert!(dest.layout.is_zst());\n                     }\n-                    _ => {\n-                        for (arg_local, &op) in arg_locals.zip(args) {\n-                            let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.copy_op(op, dest)?;\n+                    _ => {}\n+                }\n+                // Now back to norml argument passing.\n+                while let Some(local) = local_iter.next() {\n+                    let dest = self.eval_place(&mir::Place::Local(local))?;\n+                    if Some(local) == mir.spread_arg {\n+                        // Must be a tuple\n+                        for i in 0..dest.layout.fields.count() {\n+                            let dest = self.place_field(dest, i as u64)?;\n+                            self.copy_op(*args_iter.next().unwrap(), dest)?;\n                         }\n+                    } else {\n+                        // Normal argument\n+                        self.copy_op(*args_iter.next().unwrap(), dest)?;\n                     }\n                 }\n+                // Now we should be done\n+                assert!(args_iter.next().is_none());\n                 Ok(())\n             }\n             // cannot use the shim here, because that will only result in infinite recursion\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let (ptr, vtable) = self.read_value(args[0])?.to_scalar_dyn_trait()?;\n+                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n@@ -415,11 +428,50 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n                 args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(&self, 0)?;\n-                args[0].op = Operand::Immediate(Value::Scalar(ptr.into())); // strip vtable\n+                args[0].op = Operand::Immediate(Value::Scalar(ptr.ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, destination, &args, span, sig)\n+                self.eval_fn_call(instance, &args, dest, ret, span, sig)\n             }\n         }\n     }\n+\n+    fn drop_in_place(\n+        &mut self,\n+        place: PlaceTy<'tcx>,\n+        instance: ty::Instance<'tcx>,\n+        span: Span,\n+        target: mir::BasicBlock,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n+        // We take the address of the object.  This may well be unaligned, which is fine\n+        // for us here.  However, unaligned accesses will probably make the actual drop\n+        // implementation fail -- a problem shared by rustc.\n+        let place = self.force_allocation(place)?;\n+\n+        let (instance, place) = match place.layout.ty.sty {\n+            ty::Dynamic(..) => {\n+                // Dropping a trait object.\n+                self.unpack_dyn_trait(place)?\n+            }\n+            _ => (instance, place),\n+        };\n+\n+        let arg = OpTy {\n+            op: Operand::Immediate(place.to_ref()),\n+            layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n+        };\n+\n+        let ty = self.tcx.mk_nil(); // return type is ()\n+        let dest = PlaceTy::null(&self, self.layout_of(ty)?);\n+\n+        self.eval_fn_call(\n+            instance,\n+            &[arg],\n+            Some(dest),\n+            Some(target),\n+            span,\n+            None,\n+        )\n+    }\n }", "previous_filename": "src/librustc_mir/interpret/terminator/mod.rs"}, {"sha": "8e413aa8284fb6c584a5f00e7c83e38359bc8c2b", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7061b2775782bb48c0a70d3c79ec711134396687/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7061b2775782bb48c0a70d3c79ec711134396687/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=7061b2775782bb48c0a70d3c79ec711134396687", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::mir::BasicBlock;\n-use rustc::ty::{self, layout::LayoutOf};\n-use syntax::source_map::Span;\n-\n-use rustc::mir::interpret::EvalResult;\n-use interpret::{Machine, EvalContext, PlaceTy, PlaceExtra, OpTy, Operand};\n-\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub(crate) fn drop_in_place(\n-        &mut self,\n-        place: PlaceTy<'tcx>,\n-        instance: ty::Instance<'tcx>,\n-        span: Span,\n-        target: BasicBlock,\n-    ) -> EvalResult<'tcx> {\n-        trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n-        // We take the address of the object.  This may well be unaligned, which is fine for us\n-        // here. However, unaligned accesses will probably make the actual drop implementation fail\n-        // -- a problem shared by rustc.\n-        let place = self.force_allocation(place)?;\n-\n-        let (instance, place) = match place.layout.ty.sty {\n-            ty::Dynamic(..) => {\n-                // Dropping a trait object.\n-                let vtable = match place.extra {\n-                    PlaceExtra::Vtable(vtable) => vtable,\n-                    _ => bug!(\"Expected vtable when dropping {:#?}\", place),\n-                };\n-                let place = self.unpack_unsized_mplace(place)?;\n-                let instance = self.read_drop_type_from_vtable(vtable)?;\n-                (instance, place)\n-            }\n-            _ => (instance, place),\n-        };\n-\n-        let fn_sig = instance.ty(*self.tcx).fn_sig(*self.tcx);\n-        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n-\n-        let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref(&self)),\n-            layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n-        };\n-\n-        // This should always be (), but getting it from the sig seems\n-        // easier than creating a layout of ().\n-        let dest = PlaceTy::null(&self, self.layout_of(fn_sig.output())?);\n-\n-        self.eval_fn_call(\n-            instance,\n-            Some((dest, target)),\n-            &[arg],\n-            span,\n-            fn_sig,\n-        )\n-    }\n-}"}, {"sha": "74567b429749175bbfd6f3a17df1d03a41903290", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -68,22 +68,29 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        self.memory.mark_static_initialized(\n+        self.memory.intern_static(\n             vtable.alloc_id,\n             Mutability::Immutable,\n         )?;\n \n         Ok(vtable)\n     }\n \n+    /// Return the drop fn instance as well as the actual dynamic type\n     pub fn read_drop_type_from_vtable(\n         &self,\n         vtable: Pointer,\n-    ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    ) -> EvalResult<'tcx, (ty::Instance<'tcx>, ty::Ty<'tcx>)> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n         let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n-        self.memory.get_fn(drop_fn)\n+        let drop_instance = self.memory.get_fn(drop_fn)?;\n+        trace!(\"Found drop fn: {:?}\", drop_instance);\n+        let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n+        let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);\n+        // the drop function takes *mut T where T is the type being dropped, so get that\n+        let ty = fn_sig.inputs()[0].builtin_deref(true).unwrap().ty;\n+        Ok((drop_instance, ty))\n     }\n \n     pub fn read_size_and_align_from_vtable("}, {"sha": "d50fd6e13c1069b137cf35c4ea443747436ea7c2", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 136, "deletions": 57, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    MPlaceTy, Machine, EvalContext\n+    OpTy, Machine, EvalContext\n };\n \n macro_rules! validation_failure{\n@@ -187,39 +187,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n-    /// This function checks the memory where `dest` points to.  The place must be sized\n-    /// (i.e., dest.extra == PlaceExtra::None).\n+    /// This function checks the data at `op`.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n     /// The `path` may be pushed to, but the part that is present when the function\n     /// starts must not be changed!\n-    pub fn validate_mplace(\n+    pub fn validate_operand(\n         &self,\n-        dest: MPlaceTy<'tcx>,\n+        dest: OpTy<'tcx>,\n         path: &mut Vec<PathElem>,\n-        seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n-        todo: &mut Vec<(MPlaceTy<'tcx>, Vec<PathElem>)>,\n+        seen: &mut FxHashSet<(OpTy<'tcx>)>,\n+        todo: &mut Vec<(OpTy<'tcx>, Vec<PathElem>)>,\n     ) -> EvalResult<'tcx> {\n-        self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n-        trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n+        trace!(\"validate_operand: {:?}, {:#?}\", *dest, dest.layout);\n \n         // Find the right variant.  We have to handle this as a prelude, not via\n         // proper recursion with the new inner layout, to be able to later nicely\n         // print the field names of the enum field that is being accessed.\n         let (variant, dest) = match dest.layout.variants {\n-            layout::Variants::NicheFilling { niche: ref tag, .. } |\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let size = tag.value.size(self);\n-                // we first read the tag value as scalar, to be able to validate it\n-                let tag_mplace = self.mplace_field(dest, 0)?;\n-                let tag_value = self.read_scalar(tag_mplace.into())?;\n-                path.push(PathElem::Tag);\n-                self.validate_scalar(\n-                    tag_value, size, tag, &path, tag_mplace.layout.ty\n-                )?;\n-                path.pop(); // remove the element again\n-                // then we read it again to get the index, to continue\n-                let variant = self.read_discriminant_as_variant_index(dest.into())?;\n-                let inner_dest = self.mplace_downcast(dest, variant)?;\n+            layout::Variants::NicheFilling { .. } |\n+            layout::Variants::Tagged { .. } => {\n+                let variant = match self.read_discriminant(dest) {\n+                    Ok(res) => res.1,\n+                    Err(err) => match err.kind {\n+                        EvalErrorKind::InvalidDiscriminant(val) =>\n+                            return validation_failure!(\n+                                format!(\"invalid enum discriminant {}\", val), path\n+                            ),\n+                        _ =>\n+                            return validation_failure!(\n+                                format!(\"non-integer enum discriminant\"), path\n+                            ),\n+                    }\n+                };\n+                let inner_dest = self.operand_downcast(dest, variant)?;\n                 // Put the variant projection onto the path, as a field\n                 path.push(PathElem::Field(dest.layout.ty\n                                           .ty_adt_def()\n@@ -229,6 +229,23 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 (variant, inner_dest)\n             },\n             layout::Variants::Single { index } => {\n+                // Pre-processing for trait objects: Treat them at their real type.\n+                // (We do not do this for slices and strings: For slices it is not needed,\n+                // `mplace_array_fields` does the right thing, and for strings there is no\n+                // real type that would show the actual length.)\n+                let dest = match dest.layout.ty.sty {\n+                    ty::Dynamic(..) => {\n+                        let dest = dest.to_mem_place(); // immediate trait objects are not a thing\n+                        match self.unpack_dyn_trait(dest) {\n+                            Ok(res) => res.1.into(),\n+                            Err(_) =>\n+                                return validation_failure!(\n+                                    \"invalid vtable in fat pointer\", path\n+                                ),\n+                        }\n+                    }\n+                    _ => dest\n+                };\n                 (index, dest)\n             }\n         };\n@@ -251,7 +268,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar_layout) => {\n                         let size = scalar_layout.value.size(self);\n-                        let value = self.read_value(dest.into())?;\n+                        let value = match self.read_value(dest) {\n+                            Ok(val) => val,\n+                            Err(err) => match err.kind {\n+                                EvalErrorKind::PointerOutOfBounds { .. } |\n+                                EvalErrorKind::ReadUndefBytes =>\n+                                    return validation_failure!(\n+                                        \"uninitialized or out-of-bounds memory\", path\n+                                    ),\n+                                _ =>\n+                                    return validation_failure!(\n+                                        \"unrepresentable data\", path\n+                                    ),\n+                            }\n+                        };\n                         let scalar = value.to_scalar_or_undef();\n                         self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n                         if scalar_layout.value == Primitive::Pointer {\n@@ -260,18 +290,18 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                                 if let Some(AllocType::Static(did)) = alloc_kind {\n                                     // statics from other crates are already checked.\n-                                    // extern statics should not be validated as they have no body.\n+                                    // extern statics cannot be validated as they have no body.\n                                     if !did.is_local() || self.tcx.is_foreign_item(did) {\n                                         return Ok(());\n                                     }\n                                 }\n                                 if value.layout.ty.builtin_deref(false).is_some() {\n-                                    trace!(\"Recursing below ptr {:#?}\", value);\n-                                    let ptr_place = self.ref_to_mplace(value)?;\n-                                    // we have not encountered this pointer+layout\n-                                    // combination before\n-                                    if seen.insert(ptr_place) {\n-                                        todo.push((ptr_place, path_clone_and_deref(path)));\n+                                    let ptr_op = self.ref_to_mplace(value)?.into();\n+                                    // we have not encountered this pointer+layout combination\n+                                    // before.\n+                                    if seen.insert(ptr_op) {\n+                                        trace!(\"Recursing below ptr {:#?}\", *value);\n+                                        todo.push((ptr_op, path_clone_and_deref(path)));\n                                     }\n                                 }\n                             }\n@@ -285,49 +315,98 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n             },\n-            layout::FieldPlacement::Array { .. } => {\n-                for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n-                    let field = field?;\n-                    path.push(PathElem::ArrayElem(i));\n-                    self.validate_mplace(field, path, seen, todo)?;\n-                    path.truncate(path_len);\n+            layout::FieldPlacement::Array { .. } if !dest.layout.is_zst() => {\n+                let dest = dest.to_mem_place(); // non-ZST array/slice/str cannot be immediate\n+                // Special handling for strings to verify UTF-8\n+                match dest.layout.ty.sty {\n+                    ty::Str => {\n+                        match self.read_str(dest) {\n+                            Ok(_) => {},\n+                            Err(err) => match err.kind {\n+                                EvalErrorKind::PointerOutOfBounds { .. } |\n+                                EvalErrorKind::ReadUndefBytes =>\n+                                    // The error here looks slightly different than it does\n+                                    // for slices, because we do not report the index into the\n+                                    // str at which we are OOB.\n+                                    return validation_failure!(\n+                                        \"uninitialized or out-of-bounds memory\", path\n+                                    ),\n+                                _ =>\n+                                    return validation_failure!(\n+                                        \"non-UTF-8 data in str\", path\n+                                    ),\n+                            }\n+                        }\n+                    }\n+                    _ => {\n+                        // This handles the unsized case correctly as well, as well as\n+                        // SIMD an all sorts of other array-like types.\n+                        for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n+                            let field = field?;\n+                            path.push(PathElem::ArrayElem(i));\n+                            self.validate_operand(field.into(), path, seen, todo)?;\n+                            path.truncate(path_len);\n+                        }\n+                    }\n                 }\n             },\n+            layout::FieldPlacement::Array { .. } => {\n+                // An empty array.  Nothing to do.\n+            }\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                // Fat pointers need special treatment.\n+                // Fat pointers are treated like pointers, not aggregates.\n                 if dest.layout.ty.builtin_deref(true).is_some() {\n                     // This is a fat pointer.\n-                    let ptr = match self.ref_to_mplace(self.read_value(dest.into())?) {\n+                    let ptr = match self.read_value(dest.into())\n+                        .and_then(|val| self.ref_to_mplace(val))\n+                    {\n                         Ok(ptr) => ptr,\n-                        Err(err) => match err.kind {\n-                            EvalErrorKind::ReadPointerAsBytes =>\n-                                return validation_failure!(\n-                                    \"fat pointer length is not a valid integer\", path\n-                                ),\n-                            EvalErrorKind::ReadBytesAsPointer =>\n-                                return validation_failure!(\n-                                    \"fat pointer vtable is not a valid pointer\", path\n-                                ),\n-                            _ => return Err(err),\n-                        }\n+                        Err(_) =>\n+                            return validation_failure!(\n+                                \"undefined location or metadata in fat pointer\", path\n+                            ),\n                     };\n-                    let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n+                    // check metadata early, for better diagnostics\n+                    match self.tcx.struct_tail(ptr.layout.ty).sty {\n+                        ty::Dynamic(..) => {\n+                            match ptr.extra.unwrap().to_ptr() {\n+                                Ok(_) => {},\n+                                Err(_) =>\n+                                    return validation_failure!(\n+                                        \"non-pointer vtable in fat pointer\", path\n+                                    ),\n+                            }\n+                        }\n+                        ty::Slice(..) | ty::Str => {\n+                            match ptr.extra.unwrap().to_usize(self) {\n+                                Ok(_) => {},\n+                                Err(_) =>\n+                                    return validation_failure!(\n+                                        \"non-integer slice length in fat pointer\", path\n+                                    ),\n+                            }\n+                        }\n+                        _ =>\n+                            bug!(\"Unexpected unsized type tail: {:?}\",\n+                                self.tcx.struct_tail(ptr.layout.ty)\n+                            ),\n+                    }\n                     // for safe ptrs, recursively check it\n                     if !dest.layout.ty.is_unsafe_ptr() {\n-                        trace!(\"Recursing below fat ptr {:?} (unpacked: {:?})\", ptr, unpacked_ptr);\n-                        if seen.insert(unpacked_ptr) {\n-                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n+                        let ptr = ptr.into();\n+                        if seen.insert(ptr) {\n+                            trace!(\"Recursing below fat ptr {:?}\", ptr);\n+                            todo.push((ptr, path_clone_and_deref(path)));\n                         }\n                     }\n                 } else {\n                     // Not a pointer, perform regular aggregate handling below\n                     for i in 0..offsets.len() {\n-                        let field = self.mplace_field(dest, i as u64)?;\n+                        let field = self.operand_field(dest, i as u64)?;\n                         path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n-                        self.validate_mplace(field, path, seen, todo)?;\n+                        self.validate_operand(field, path, seen, todo)?;\n                         path.truncate(path_len);\n                     }\n-                    // FIXME: For a TyStr, check that this is valid UTF-8.\n                 }\n             }\n         }"}, {"sha": "f91ff3642cd10638149313a876f1f11f4f19386c", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -83,6 +83,7 @@ pub mod transform;\n pub mod util;\n pub mod interpret;\n pub mod monomorphize;\n+pub mod const_eval;\n \n pub use hair::pattern::check_crate as matchck_crate;\n use rustc::ty::query::Providers;"}, {"sha": "52bbffa7519df069a687358e9f75b1aee345a58b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -1271,7 +1271,7 @@ fn collect_const<'a, 'tcx>(\n         ConstValue::ScalarPair(Scalar::Ptr(ptr), _) |\n         ConstValue::Scalar(Scalar::Ptr(ptr)) =>\n             collect_miri(tcx, ptr.alloc_id, output),\n-        ConstValue::ByRef(alloc, _offset) => {\n+        ConstValue::ByRef(_id, alloc, _offset) => {\n             for &id in alloc.relocations.values() {\n                 collect_miri(tcx, id, output);\n             }"}, {"sha": "1715930dbb61cc6ab276edfca09b7f71ca07db58", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::hir::def::Def;\n use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n-use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n+use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext};\n use rustc::mir::interpret::{\n@@ -170,7 +170,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     | DoubleFree\n                     | InvalidFunctionPointer\n                     | InvalidBool\n-                    | InvalidDiscriminant\n+                    | InvalidDiscriminant(..)\n                     | PointerOutOfBounds { .. }\n                     | InvalidNullPointerUsage\n                     | MemoryLockViolation { .. }\n@@ -257,10 +257,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.const_value_to_op(c.literal.val) {\n+        match self.ecx.const_to_op(c.literal) {\n             Ok(op) => {\n-                let layout = self.tcx.layout_of(self.param_env.and(c.literal.ty)).ok()?;\n-                Some((OpTy { op, layout }, c.span))\n+                Some((op, c.span))\n             },\n             Err(error) => {\n                 let (stacktrace, span) = self.ecx.generate_stacktrace(None);\n@@ -382,6 +381,20 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 let (arg, _) = self.eval_operand(arg, source_info)?;\n                 let val = self.use_ecx(source_info, |this| {\n                     let prim = this.ecx.read_scalar(arg)?.not_undef()?;\n+                    match op {\n+                        UnOp::Neg => {\n+                            // Need to do overflow check here: For actual CTFE, MIR\n+                            // generation emits code that does this before calling the op.\n+                            let size = arg.layout.size;\n+                            if prim.to_bits(size)? == (1 << (size.bits() - 1)) {\n+                                return err!(OverflowNeg);\n+                            }\n+                        }\n+                        UnOp::Not => {\n+                            // Cannot overflow\n+                        }\n+                    }\n+                    // Now run the actual operation.\n                     this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n                 Some((OpTy::from_scalar_value(val, place_layout), span))"}, {"sha": "28b876c308b64544b2156bb79b5b84138b5b5161", "filename": "src/test/run-pass/ctfe/promotion.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Frun-pass%2Fctfe%2Fpromotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Frun-pass%2Fctfe%2Fpromotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fctfe%2Fpromotion.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -8,10 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -O\n+\n fn foo(_: &'static [&'static str]) {}\n fn bar(_: &'static [&'static str; 3]) {}\n+fn baz_i32(_: &'static i32) {}\n+fn baz_u32(_: &'static u32) {}\n \n fn main() {\n     foo(&[\"a\", \"b\", \"c\"]);\n     bar(&[\"d\", \"e\", \"f\"]);\n+\n+    // make sure that these do not cause trouble despite overflowing\n+    baz_u32(&(0-1));\n+    baz_i32(&-std::i32::MIN);\n }"}, {"sha": "21025877340eabd482f19268d2a2535b003577bf", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n LL | |     Union { usize: &BAR }.foo,\n LL | |     Union { usize: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 5 at .1.<deref>.<enum-tag>, but expected something in the range 42..=99\n+   | |___^ type validation failed: encountered invalid enum discriminant 5 at .1.<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "572d08ddfeebd0958d9db040dc249c98ac783ed2", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -2,15 +2,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:22:1\n    |\n LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .<enum-tag>, but expected something in the range 0..=0\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/ub-enum.rs:35:1\n    |\n LL | const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0 at .<enum-tag>, but expected something in the range 2..=2\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid enum discriminant 0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "0c42d28eb00f49d148cd8fcb5929a932b2e06539", "filename": "src/test/ui/union-ub-fat-ptr.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.rs?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(unused)]\n+\n // normalize-stderr-test \"alignment \\d+\" -> \"alignment N\"\n // normalize-stderr-test \"offset \\d+\" -> \"offset N\"\n // normalize-stderr-test \"allocation \\d+\" -> \"allocation N\"\n@@ -37,7 +39,8 @@ union SliceTransmute {\n     bad: BadSliceRepr,\n     slice: &'static [u8],\n     str: &'static str,\n-    my_str: &'static Str,\n+    my_str: &'static MyStr,\n+    my_slice: &'static MySliceBool,\n }\n \n #[repr(C)]\n@@ -71,7 +74,12 @@ union DynTransmute {\n trait Trait {}\n impl Trait for bool {}\n \n-struct Str(str);\n+// custom unsized type\n+struct MyStr(str);\n+\n+// custom unsized type with sized fields\n+struct MySlice<T: ?Sized>(bool, T);\n+type MySliceBool = MySlice<[bool]>;\n \n // OK\n const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n@@ -81,8 +89,8 @@ const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 }\n // bad str\n const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n //~^ ERROR this constant likely exhibits undefined behavior\n-// bad str in Str\n-const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+// bad str in user-defined unsized type\n+const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n //~^ ERROR this constant likely exhibits undefined behavior\n \n // OK\n@@ -107,10 +115,25 @@ const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3\n // bad data *inside* the trait object\n const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n //~^ ERROR this constant likely exhibits undefined behavior\n-\n // bad data *inside* the slice\n const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n //~^ ERROR this constant likely exhibits undefined behavior\n \n+// good MySliceBool\n+const I1: &MySliceBool = &MySlice(true, [false]);\n+// bad: sized field is not okay\n+const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// bad: unsized part is not okay\n+const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// invalid UTF-8\n+const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+// invalid UTF-8 in user-defined str-like\n+const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n fn main() {\n }"}, {"sha": "5d817dce205b15091e6829790629ec3ab9cd1c0c", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 52, "deletions": 20, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1d02c307348057fd0554ad934006b186f8b6826/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=f1d02c307348057fd0554ad934006b186f8b6826", "patch": "@@ -1,83 +1,115 @@\n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:79:1\n+  --> $DIR/union-ub-fat-ptr.rs:87:1\n    |\n LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:82:1\n+  --> $DIR/union-ub-fat-ptr.rs:90:1\n    |\n LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:85:1\n+  --> $DIR/union-ub-fat-ptr.rs:93:1\n    |\n-LL | const C2: &Str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+LL | const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:91:1\n+  --> $DIR/union-ub-fat-ptr.rs:99:1\n    |\n LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ memory access at offset N, outside bounds of allocation N which has size N\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or out-of-bounds memory at .<deref>[1]\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:94:1\n+  --> $DIR/union-ub-fat-ptr.rs:102:1\n    |\n LL | const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer length is not a valid integer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:98:1\n+  --> $DIR/union-ub-fat-ptr.rs:106:1\n    |\n LL | const D: &Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ tried to access memory with alignment N, but alignment N is required\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:101:1\n+  --> $DIR/union-ub-fat-ptr.rs:109:1\n    |\n LL | const E: &Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ a memory access tried to interpret some bytes as a pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered invalid vtable in fat pointer at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:104:1\n+  --> $DIR/union-ub-fat-ptr.rs:112:1\n    |\n LL | const F: &Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered fat pointer vtable is not a valid pointer\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-pointer vtable in fat pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:108:1\n+  --> $DIR/union-ub-fat-ptr.rs:116:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/union-ub-fat-ptr.rs:112:1\n+  --> $DIR/union-ub-fat-ptr.rs:119:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 10 previous errors\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:125:1\n+   |\n+LL | const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something in the range 0..=1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:128:1\n+   |\n+LL | const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something in the range 0..=1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:132:1\n+   |\n+LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/union-ub-fat-ptr.rs:135:1\n+   |\n+LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-UTF-8 data in str at .<deref>.0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}