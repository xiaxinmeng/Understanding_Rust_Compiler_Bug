{"sha": "dab6e70e03b569c72ad74328ad91f48a2e00e44f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYjZlNzBlMDNiNTY5YzcyYWQ3NDMyOGFkOTFmNDhhMmUwMGU0NGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-15T10:44:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-19T08:29:31Z"}, "message": "Convert gigantic comment away from `//!` form. It is annoying to\nread (`//!` is intrusive) and annoying to edit (must maintain a prefix\non every line). Since the only purpose of a `doc.rs` file is to have a\nbunch of text, using `/*!` and `*/` without indentations seems\nappropriate.", "tree": {"sha": "c51f50ed60afff3ff91499f24190bef9df239f86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c51f50ed60afff3ff91499f24190bef9df239f86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dab6e70e03b569c72ad74328ad91f48a2e00e44f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dab6e70e03b569c72ad74328ad91f48a2e00e44f", "html_url": "https://github.com/rust-lang/rust/commit/dab6e70e03b569c72ad74328ad91f48a2e00e44f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dab6e70e03b569c72ad74328ad91f48a2e00e44f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f45c0ef51e342c552021a80ddd343b0c7175111e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f45c0ef51e342c552021a80ddd343b0c7175111e", "html_url": "https://github.com/rust-lang/rust/commit/f45c0ef51e342c552021a80ddd343b0c7175111e"}], "stats": {"total": 798, "additions": 402, "deletions": 396}, "files": [{"sha": "b0addfa0bd9adf896917c72f383f496ef13ee542", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 402, "deletions": 396, "changes": 798, "blob_url": "https://github.com/rust-lang/rust/blob/dab6e70e03b569c72ad74328ad91f48a2e00e44f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dab6e70e03b569c72ad74328ad91f48a2e00e44f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=dab6e70e03b569c72ad74328ad91f48a2e00e44f", "patch": "@@ -8,399 +8,405 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # TRAIT RESOLUTION\n-//!\n-//! This document describes the general process and points out some non-obvious\n-//! things.\n-//!\n-//! ## Major concepts\n-//!\n-//! Trait resolution is the process of pairing up an impl with each\n-//! reference to a trait. So, for example, if there is a generic function like:\n-//!\n-//!     fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n-//!\n-//! and then a call to that function:\n-//!\n-//!     let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n-//!\n-//! it is the job of trait resolution to figure out (in which case)\n-//! whether there exists an impl of `int : Clone`\n-//!\n-//! Note that in some cases, like generic functions, we may not be able to\n-//! find a specific impl, but we can figure out that the caller must\n-//! provide an impl. To see what I mean, consider the body of `clone_slice`:\n-//!\n-//!     fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n-//!         let mut v = Vec::new();\n-//!         for e in x.iter() {\n-//!             v.push((*e).clone()); // (*)\n-//!         }\n-//!     }\n-//!\n-//! The line marked `(*)` is only legal if `T` (the type of `*e`)\n-//! implements the `Clone` trait. Naturally, since we don't know what `T`\n-//! is, we can't find the specific impl; but based on the bound `T:Clone`,\n-//! we can say that there exists an impl which the caller must provide.\n-//!\n-//! We use the term *obligation* to refer to a trait reference in need of\n-//! an impl.\n-//!\n-//! ## Overview\n-//!\n-//! Trait resolution consists of three major parts:\n-//!\n-//! - SELECTION: Deciding how to resolve a specific obligation. For\n-//!   example, selection might decide that a specific obligation can be\n-//!   resolved by employing an impl which matches the self type, or by\n-//!   using a parameter bound. In the case of an impl, Selecting one\n-//!   obligation can create *nested obligations* because of where clauses\n-//!   on the impl itself. It may also require evaluating those nested\n-//!   obligations to resolve ambiguities.\n-//!\n-//! - FULFILLMENT: The fulfillment code is what tracks that obligations\n-//!   are completely fulfilled. Basically it is a worklist of obligations\n-//!   to be selected: once selection is successful, the obligation is\n-//!   removed from the worklist and any nested obligations are enqueued.\n-//!\n-//! - COHERENCE: The coherence checks are intended to ensure that there\n-//!   are never overlapping impls, where two impls could be used with\n-//!   equal precedence.\n-//!\n-//! ## Selection\n-//!\n-//! Selection is the process of deciding whether an obligation can be\n-//! resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n-//! The main interface is the `select()` function, which takes an obligation\n-//! and returns a `SelectionResult`. There are three possible outcomes:\n-//!\n-//! - `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n-//!   `selection` indicates how. If the impl was resolved via an impl,\n-//!   then `selection` may also indicate nested obligations that are required\n-//!   by the impl.\n-//!\n-//! - `Ok(None)` -- we are not yet sure whether the obligation can be\n-//!   resolved or not. This happens most commonly when the obligation\n-//!   contains unbound type variables.\n-//!\n-//! - `Err(err)` -- the obligation definitely cannot be resolved due to a\n-//!   type error, or because there are no impls that could possibly apply,\n-//!   etc.\n-//!\n-//! The basic algorithm for selection is broken into two big phases:\n-//! candidate assembly and confirmation.\n-//!\n-//! ### Candidate assembly\n-//!\n-//! Searches for impls/where-clauses/etc that might\n-//! possibly be used to satisfy the obligation. Each of those is called\n-//! a candidate. To avoid ambiguity, we want to find exactly one\n-//! candidate that is definitively applicable. In some cases, we may not\n-//! know whether an impl/where-clause applies or not -- this occurs when\n-//! the obligation contains unbound inference variables.\n-//!\n-//! The basic idea for candidate assembly is to do a first pass in which\n-//! we identify all possible candidates. During this pass, all that we do\n-//! is try and unify the type parameters. (In particular, we ignore any\n-//! nested where clauses.) Presuming that this unification succeeds, the\n-//! impl is added as a candidate.\n-//!\n-//! Once this first pass is done, we can examine the set of candidates. If\n-//! it is a singleton set, then we are done: this is the only impl in\n-//! scope that could possibly apply. Otherwise, we can winnow down the set\n-//! of candidates by using where clauses and other conditions. If this\n-//! reduced set yields a single, unambiguous entry, we're good to go,\n-//! otherwise the result is considered ambiguous.\n-//!\n-//! #### The basic process: Inferring based on the impls we see\n-//!\n-//! This process is easier if we work through some examples. Consider\n-//! the following trait:\n-//!\n-//! ```\n-//! trait Convert<Target> {\n-//!     fn convert(&self) -> Target;\n-//! }\n-//! ```\n-//!\n-//! This trait just has one method. It's about as simple as it gets. It\n-//! converts from the (implicit) `Self` type to the `Target` type. If we\n-//! wanted to permit conversion between `int` and `uint`, we might\n-//! implement `Convert` like so:\n-//!\n-//! ```rust\n-//! impl Convert<uint> for int { ... } // int -> uint\n-//! impl Convert<int> for uint { ... } // uint -> uint\n-//! ```\n-//!\n-//! Now imagine there is some code like the following:\n-//!\n-//! ```rust\n-//! let x: int = ...;\n-//! let y = x.convert();\n-//! ```\n-//!\n-//! The call to convert will generate a trait reference `Convert<$Y> for\n-//! int`, where `$Y` is the type variable representing the type of\n-//! `y`. When we match this against the two impls we can see, we will find\n-//! that only one remains: `Convert<uint> for int`. Therefore, we can\n-//! select this impl, which will cause the type of `$Y` to be unified to\n-//! `uint`. (Note that while assembling candidates, we do the initial\n-//! unifications in a transaction, so that they don't affect one another.)\n-//!\n-//! There are tests to this effect in src/test/run-pass:\n-//!\n-//!    traits-multidispatch-infer-convert-source-and-target.rs\n-//!    traits-multidispatch-infer-convert-target.rs\n-//!\n-//! #### Winnowing: Resolving ambiguities\n-//!\n-//! But what happens if there are multiple impls where all the types\n-//! unify? Consider this example:\n-//!\n-//! ```rust\n-//! trait Get {\n-//!     fn get(&self) -> Self;\n-//! }\n-//!\n-//! impl<T:Copy> Get for T {\n-//!     fn get(&self) -> T { *self }\n-//! }\n-//!\n-//! impl<T:Get> Get for Box<T> {\n-//!     fn get(&self) -> Box<T> { box get_it(&**self) }\n-//! }\n-//! ```\n-//!\n-//! What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n-//! case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n-//! because the first applies to all types, and the second to all\n-//! boxes. In the olden days we'd have called this ambiguous. But what we\n-//! do now is do a second *winnowing* pass that considers where clauses\n-//! and attempts to remove candidates -- in this case, the first impl only\n-//! applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n-//! then, we are left with just one candidate, so we can proceed. There is\n-//! a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n-//!\n-//! #### Matching\n-//!\n-//! The subroutines that decide whether a particular impl/where-clause/etc\n-//! applies to a particular obligation. At the moment, this amounts to\n-//! unifying the self types, but in the future we may also recursively\n-//! consider some of the nested obligations, in the case of an impl.\n-//!\n-//! #### Lifetimes and selection\n-//!\n-//! Because of how that lifetime inference works, it is not possible to\n-//! give back immediate feedback as to whether a unification or subtype\n-//! relationship between lifetimes holds or not. Therefore, lifetime\n-//! matching is *not* considered during selection. This is reflected in\n-//! the fact that subregion assignment is infallible. This may yield\n-//! lifetime constraints that will later be found to be in error (in\n-//! contrast, the non-lifetime-constraints have already been checked\n-//! during selection and can never cause an error, though naturally they\n-//! may lead to other errors downstream).\n-//!\n-//! #### Where clauses\n-//!\n-//! Besides an impl, the other major way to resolve an obligation is via a\n-//! where clause. The selection process is always given a *parameter\n-//! environment* which contains a list of where clauses, which are\n-//! basically obligations that can assume are satisfiable. We will iterate\n-//! over that list and check whether our current obligation can be found\n-//! in that list, and if so it is considered satisfied. More precisely, we\n-//! want to check whether there is a where-clause obligation that is for\n-//! the same trait (or some subtrait) and for which the self types match,\n-//! using the definition of *matching* given above.\n-//!\n-//! Consider this simple example:\n-//!\n-//!      trait A1 { ... }\n-//!      trait A2 : A1 { ... }\n-//!\n-//!      trait B { ... }\n-//!\n-//!      fn foo<X:A2+B> { ... }\n-//!\n-//! Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n-//! body of `foo`. In each case, that will incur an obligation like `X :\n-//! A1` or `X : A2`. The parameter environment will contain two\n-//! where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n-//! search this list of where-clauses.  To resolve an obligation `X:A1`,\n-//! we would note that `X:A2` implies that `X:A1`.\n-//!\n-//! ### Confirmation\n-//!\n-//! Confirmation unifies the output type parameters of the trait with the\n-//! values found in the obligation, possibly yielding a type error.  If we\n-//! return to our example of the `Convert` trait from the previous\n-//! section, confirmation is where an error would be reported, because the\n-//! impl specified that `T` would be `uint`, but the obligation reported\n-//! `char`. Hence the result of selection would be an error.\n-//!\n-//! ### Selection during translation\n-//!\n-//! During type checking, we do not store the results of trait selection.\n-//! We simply wish to verify that trait selection will succeed. Then\n-//! later, at trans time, when we have all concrete types available, we\n-//! can repeat the trait selection.  In this case, we do not consider any\n-//! where-clauses to be in scope. We know that therefore each resolution\n-//! will resolve to a particular impl.\n-//!\n-//! One interesting twist has to do with nested obligations. In general, in trans,\n-//! we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n-//! identify which impl applies, but we do not (yet) need to decide how to select\n-//! any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n-//! and that is because it can sometimes inform the results of type inference. That is,\n-//! we do not have the full substitutions in terms of the type varibales of the impl available\n-//! to us, so we must run trait selection to figure everything out.\n-//!\n-//! Here is an example:\n-//!\n-//!     trait Foo { ... }\n-//!     impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n-//!\n-//!     impl Bar<uint> for int { ... }\n-//!\n-//! After one shallow round of selection for an obligation like `Vec<int>\n-//! : Foo`, we would know which impl we want, and we would know that\n-//! `T=int`, but we do not know the type of `U`.  We must select the\n-//! nested obligation `int : Bar<U>` to find out that `U=uint`.\n-//!\n-//! It would be good to only do *just as much* nested resolution as\n-//! necessary. Currently, though, we just do a full resolution.\n-//!\n-//! ## Method matching\n-//!\n-//! Method dispach follows a slightly different path than normal trait\n-//! selection. This is because it must account for the transformed self\n-//! type of the receiver and various other complications. The procedure is\n-//! described in `select.rs` in the \"METHOD MATCHING\" section.\n-//!\n-//! # Caching and subtle considerations therewith\n-//!\n-//! In general we attempt to cache the results of trait selection.  This\n-//! is a somewhat complex process. Part of the reason for this is that we\n-//! want to be able to cache results even when all the types in the trait\n-//! reference are not fully known. In that case, it may happen that the\n-//! trait selection process is also influencing type variables, so we have\n-//! to be able to not only cache the *result* of the selection process,\n-//! but *replay* its effects on the type variables.\n-//!\n-//! ## An example\n-//!\n-//! The high-level idea of how the cache works is that we first replace\n-//! all unbound inference variables with skolemized versions. Therefore,\n-//! if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n-//! inference variable, we might replace it with `uint : Foo<%0>`, where\n-//! `%n` is a skolemized type. We would then look this up in the cache.\n-//! If we found a hit, the hit would tell us the immediate next step to\n-//! take in the selection process: i.e., apply impl #22, or apply where\n-//! clause `X : Foo<Y>`. Let's say in this case there is no hit.\n-//! Therefore, we search through impls and where clauses and so forth, and\n-//! we come to the conclusion that the only possible impl is this one,\n-//! with def-id 22:\n-//!\n-//!     impl Foo<int> for uint { ... } // Impl #22\n-//!\n-//! We would then record in the cache `uint : Foo<%0> ==>\n-//! ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n-//! would (as a side-effect) unify `$1` with `int`.\n-//!\n-//! Now, at some later time, we might come along and see a `uint :\n-//! Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n-//! before, and hence the cache lookup would succeed, yielding\n-//! `ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n-//! (as a side-effect) unify `$3` with `int`.\n-//!\n-//! ## Where clauses and the local vs global cache\n-//!\n-//! One subtle interaction is that the results of trait lookup will vary\n-//! depending on what where clauses are in scope. Therefore, we actually\n-//! have *two* caches, a local and a global cache. The local cache is\n-//! attached to the `ParameterEnvironment` and the global cache attached\n-//! to the `tcx`. We use the local cache whenever the result might depend\n-//! on the where clauses that are in scope. The determination of which\n-//! cache to use is done by the method `pick_candidate_cache` in\n-//! `select.rs`.\n-//!\n-//! There are two cases where we currently use the local cache. The\n-//! current rules are probably more conservative than necessary.\n-//!\n-//! ### Trait references that involve parameter types\n-//!\n-//! The most obvious case where you need the local environment is\n-//! when the trait reference includes parameter types. For example,\n-//! consider the following function:\n-//!\n-//!     impl<T> Vec<T> {\n-//!         fn foo(x: T)\n-//!             where T : Foo\n-//!         { ... }\n-//!\n-//!         fn bar(x: T)\n-//!         { ... }\n-//!     }\n-//!\n-//! If there is an obligation `T : Foo`, or `int : Bar<T>`, or whatever,\n-//! clearly the results from `foo` and `bar` are potentially different,\n-//! since the set of where clauses in scope are different.\n-//!\n-//! ### Trait references with unbound variables when where clauses are in scope\n-//!\n-//! There is another less obvious interaction which involves unbound variables\n-//! where *only* where clauses are in scope (no impls). This manifested as\n-//! issue #18209 (`run-pass/trait-cache-issue-18209.rs`). Consider\n-//! this snippet:\n-//!\n-//! ```\n-//! pub trait Foo {\n-//!     fn load_from() -> Box<Self>;\n-//!     fn load() -> Box<Self> {\n-//!         Foo::load_from()\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! The default method will incur an obligation `$0 : Foo` from the call\n-//! to `load_from`. If there are no impls, this can be eagerly resolved to\n-//! `VtableParam(Self : Foo)` and cached. Because the trait reference\n-//! doesn't involve any parameters types (only the resolution does), this\n-//! result was stored in the global cache, causing later calls to\n-//! `Foo::load_from()` to get nonsense.\n-//!\n-//! To fix this, we always use the local cache if there are unbound\n-//! variables and where clauses in scope. This is more conservative than\n-//! necessary as far as I can tell. However, it still seems to be a simple\n-//! rule and I observe ~99% hit rate on rustc, so it doesn't seem to hurt\n-//! us in particular.\n-//!\n-//! Here is an example of the kind of subtle case that I would be worried\n-//! about with a more complex rule (although this particular case works\n-//! out ok). Imagine the trait reference doesn't directly reference a\n-//! where clause, but the where clause plays a role in the winnowing\n-//! phase. Something like this:\n-//!\n-//! ```\n-//! pub trait Foo<T> { ... }\n-//! pub trait Bar { ... }\n-//! impl<U,T:Bar> Foo<U> for T { ... } // Impl A\n-//! impl Foo<char> for uint { ... }    // Impl B\n-//! ```\n-//!\n-//! Now, in some function, we have no where clauses in scope, and we have\n-//! an obligation `$1 : Foo<$0>`. We might then conclude that `$0=char`\n-//! and `$1=uint`: this is because for impl A to apply, `uint:Bar` would\n-//! have to hold, and we know it does not or else the coherence check\n-//! would have failed.  So we might enter into our global cache: `$1 :\n-//! Foo<$0> => Impl B`.  Then we come along in a different scope, where a\n-//! generic type `A` is around with the bound `A:Bar`. Now suddenly the\n-//! impl is viable.\n-//!\n-//! The flaw in this imaginary DOOMSDAY SCENARIO is that we would not\n-//! currently conclude that `$1 : Foo<$0>` implies that `$0 == uint` and\n-//! `$1 == char`, even though it is true that (absent type parameters)\n-//! there is no other type the user could enter. However, it is not\n-//! *completely* implausible that we *could* draw this conclusion in the\n-//! future; we wouldn't have to guess types, in particular, we could be\n-//! led by the impls.\n+/*!\n+\n+# TRAIT RESOLUTION\n+\n+This document describes the general process and points out some non-obvious\n+things.\n+\n+## Major concepts\n+\n+Trait resolution is the process of pairing up an impl with each\n+reference to a trait. So, for example, if there is a generic function like:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n+\n+and then a call to that function:\n+\n+    let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n+\n+it is the job of trait resolution to figure out (in which case)\n+whether there exists an impl of `int : Clone`\n+\n+Note that in some cases, like generic functions, we may not be able to\n+find a specific impl, but we can figure out that the caller must\n+provide an impl. To see what I mean, consider the body of `clone_slice`:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n+        let mut v = Vec::new();\n+        for e in x.iter() {\n+            v.push((*e).clone()); // (*)\n+        }\n+    }\n+\n+The line marked `(*)` is only legal if `T` (the type of `*e`)\n+implements the `Clone` trait. Naturally, since we don't know what `T`\n+is, we can't find the specific impl; but based on the bound `T:Clone`,\n+we can say that there exists an impl which the caller must provide.\n+\n+We use the term *obligation* to refer to a trait reference in need of\n+an impl.\n+\n+## Overview\n+\n+Trait resolution consists of three major parts:\n+\n+- SELECTION: Deciding how to resolve a specific obligation. For\n+  example, selection might decide that a specific obligation can be\n+  resolved by employing an impl which matches the self type, or by\n+  using a parameter bound. In the case of an impl, Selecting one\n+  obligation can create *nested obligations* because of where clauses\n+  on the impl itself. It may also require evaluating those nested\n+  obligations to resolve ambiguities.\n+\n+- FULFILLMENT: The fulfillment code is what tracks that obligations\n+  are completely fulfilled. Basically it is a worklist of obligations\n+  to be selected: once selection is successful, the obligation is\n+  removed from the worklist and any nested obligations are enqueued.\n+\n+- COHERENCE: The coherence checks are intended to ensure that there\n+  are never overlapping impls, where two impls could be used with\n+  equal precedence.\n+\n+## Selection\n+\n+Selection is the process of deciding whether an obligation can be\n+resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n+The main interface is the `select()` function, which takes an obligation\n+and returns a `SelectionResult`. There are three possible outcomes:\n+\n+- `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n+  `selection` indicates how. If the impl was resolved via an impl,\n+  then `selection` may also indicate nested obligations that are required\n+  by the impl.\n+\n+- `Ok(None)` -- we are not yet sure whether the obligation can be\n+  resolved or not. This happens most commonly when the obligation\n+  contains unbound type variables.\n+\n+- `Err(err)` -- the obligation definitely cannot be resolved due to a\n+  type error, or because there are no impls that could possibly apply,\n+  etc.\n+\n+The basic algorithm for selection is broken into two big phases:\n+candidate assembly and confirmation.\n+\n+### Candidate assembly\n+\n+Searches for impls/where-clauses/etc that might\n+possibly be used to satisfy the obligation. Each of those is called\n+a candidate. To avoid ambiguity, we want to find exactly one\n+candidate that is definitively applicable. In some cases, we may not\n+know whether an impl/where-clause applies or not -- this occurs when\n+the obligation contains unbound inference variables.\n+\n+The basic idea for candidate assembly is to do a first pass in which\n+we identify all possible candidates. During this pass, all that we do\n+is try and unify the type parameters. (In particular, we ignore any\n+nested where clauses.) Presuming that this unification succeeds, the\n+impl is added as a candidate.\n+\n+Once this first pass is done, we can examine the set of candidates. If\n+it is a singleton set, then we are done: this is the only impl in\n+scope that could possibly apply. Otherwise, we can winnow down the set\n+of candidates by using where clauses and other conditions. If this\n+reduced set yields a single, unambiguous entry, we're good to go,\n+otherwise the result is considered ambiguous.\n+\n+#### The basic process: Inferring based on the impls we see\n+\n+This process is easier if we work through some examples. Consider\n+the following trait:\n+\n+```\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+```\n+\n+This trait just has one method. It's about as simple as it gets. It\n+converts from the (implicit) `Self` type to the `Target` type. If we\n+wanted to permit conversion between `int` and `uint`, we might\n+implement `Convert` like so:\n+\n+```rust\n+impl Convert<uint> for int { ... } // int -> uint\n+impl Convert<int> for uint { ... } // uint -> uint\n+```\n+\n+Now imagine there is some code like the following:\n+\n+```rust\n+let x: int = ...;\n+let y = x.convert();\n+```\n+\n+The call to convert will generate a trait reference `Convert<$Y> for\n+int`, where `$Y` is the type variable representing the type of\n+`y`. When we match this against the two impls we can see, we will find\n+that only one remains: `Convert<uint> for int`. Therefore, we can\n+select this impl, which will cause the type of `$Y` to be unified to\n+`uint`. (Note that while assembling candidates, we do the initial\n+unifications in a transaction, so that they don't affect one another.)\n+\n+There are tests to this effect in src/test/run-pass:\n+\n+   traits-multidispatch-infer-convert-source-and-target.rs\n+   traits-multidispatch-infer-convert-target.rs\n+\n+#### Winnowing: Resolving ambiguities\n+\n+But what happens if there are multiple impls where all the types\n+unify? Consider this example:\n+\n+```rust\n+trait Get {\n+    fn get(&self) -> Self;\n+}\n+\n+impl<T:Copy> Get for T {\n+    fn get(&self) -> T { *self }\n+}\n+\n+impl<T:Get> Get for Box<T> {\n+    fn get(&self) -> Box<T> { box get_it(&**self) }\n+}\n+```\n+\n+What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n+case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n+because the first applies to all types, and the second to all\n+boxes. In the olden days we'd have called this ambiguous. But what we\n+do now is do a second *winnowing* pass that considers where clauses\n+and attempts to remove candidates -- in this case, the first impl only\n+applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n+then, we are left with just one candidate, so we can proceed. There is\n+a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n+\n+#### Matching\n+\n+The subroutines that decide whether a particular impl/where-clause/etc\n+applies to a particular obligation. At the moment, this amounts to\n+unifying the self types, but in the future we may also recursively\n+consider some of the nested obligations, in the case of an impl.\n+\n+#### Lifetimes and selection\n+\n+Because of how that lifetime inference works, it is not possible to\n+give back immediate feedback as to whether a unification or subtype\n+relationship between lifetimes holds or not. Therefore, lifetime\n+matching is *not* considered during selection. This is reflected in\n+the fact that subregion assignment is infallible. This may yield\n+lifetime constraints that will later be found to be in error (in\n+contrast, the non-lifetime-constraints have already been checked\n+during selection and can never cause an error, though naturally they\n+may lead to other errors downstream).\n+\n+#### Where clauses\n+\n+Besides an impl, the other major way to resolve an obligation is via a\n+where clause. The selection process is always given a *parameter\n+environment* which contains a list of where clauses, which are\n+basically obligations that can assume are satisfiable. We will iterate\n+over that list and check whether our current obligation can be found\n+in that list, and if so it is considered satisfied. More precisely, we\n+want to check whether there is a where-clause obligation that is for\n+the same trait (or some subtrait) and for which the self types match,\n+using the definition of *matching* given above.\n+\n+Consider this simple example:\n+\n+     trait A1 { ... }\n+     trait A2 : A1 { ... }\n+\n+     trait B { ... }\n+\n+     fn foo<X:A2+B> { ... }\n+\n+Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n+body of `foo`. In each case, that will incur an obligation like `X :\n+A1` or `X : A2`. The parameter environment will contain two\n+where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n+search this list of where-clauses.  To resolve an obligation `X:A1`,\n+we would note that `X:A2` implies that `X:A1`.\n+\n+### Confirmation\n+\n+Confirmation unifies the output type parameters of the trait with the\n+values found in the obligation, possibly yielding a type error.  If we\n+return to our example of the `Convert` trait from the previous\n+section, confirmation is where an error would be reported, because the\n+impl specified that `T` would be `uint`, but the obligation reported\n+`char`. Hence the result of selection would be an error.\n+\n+### Selection during translation\n+\n+During type checking, we do not store the results of trait selection.\n+We simply wish to verify that trait selection will succeed. Then\n+later, at trans time, when we have all concrete types available, we\n+can repeat the trait selection.  In this case, we do not consider any\n+where-clauses to be in scope. We know that therefore each resolution\n+will resolve to a particular impl.\n+\n+One interesting twist has to do with nested obligations. In general, in trans,\n+we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n+identify which impl applies, but we do not (yet) need to decide how to select\n+any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n+and that is because it can sometimes inform the results of type inference. That is,\n+we do not have the full substitutions in terms of the type varibales of the impl available\n+to us, so we must run trait selection to figure everything out.\n+\n+Here is an example:\n+\n+    trait Foo { ... }\n+    impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n+\n+    impl Bar<uint> for int { ... }\n+\n+After one shallow round of selection for an obligation like `Vec<int>\n+: Foo`, we would know which impl we want, and we would know that\n+`T=int`, but we do not know the type of `U`.  We must select the\n+nested obligation `int : Bar<U>` to find out that `U=uint`.\n+\n+It would be good to only do *just as much* nested resolution as\n+necessary. Currently, though, we just do a full resolution.\n+\n+## Method matching\n+\n+Method dispach follows a slightly different path than normal trait\n+selection. This is because it must account for the transformed self\n+type of the receiver and various other complications. The procedure is\n+described in `select.rs` in the \"METHOD MATCHING\" section.\n+\n+# Caching and subtle considerations therewith\n+\n+In general we attempt to cache the results of trait selection.  This\n+is a somewhat complex process. Part of the reason for this is that we\n+want to be able to cache results even when all the types in the trait\n+reference are not fully known. In that case, it may happen that the\n+trait selection process is also influencing type variables, so we have\n+to be able to not only cache the *result* of the selection process,\n+but *replay* its effects on the type variables.\n+\n+## An example\n+\n+The high-level idea of how the cache works is that we first replace\n+all unbound inference variables with skolemized versions. Therefore,\n+if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n+inference variable, we might replace it with `uint : Foo<%0>`, where\n+`%n` is a skolemized type. We would then look this up in the cache.\n+If we found a hit, the hit would tell us the immediate next step to\n+take in the selection process: i.e., apply impl #22, or apply where\n+clause `X : Foo<Y>`. Let's say in this case there is no hit.\n+Therefore, we search through impls and where clauses and so forth, and\n+we come to the conclusion that the only possible impl is this one,\n+with def-id 22:\n+\n+    impl Foo<int> for uint { ... } // Impl #22\n+\n+We would then record in the cache `uint : Foo<%0> ==>\n+ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n+would (as a side-effect) unify `$1` with `int`.\n+\n+Now, at some later time, we might come along and see a `uint :\n+Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n+before, and hence the cache lookup would succeed, yielding\n+`ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n+(as a side-effect) unify `$3` with `int`.\n+\n+## Where clauses and the local vs global cache\n+\n+One subtle interaction is that the results of trait lookup will vary\n+depending on what where clauses are in scope. Therefore, we actually\n+have *two* caches, a local and a global cache. The local cache is\n+attached to the `ParameterEnvironment` and the global cache attached\n+to the `tcx`. We use the local cache whenever the result might depend\n+on the where clauses that are in scope. The determination of which\n+cache to use is done by the method `pick_candidate_cache` in\n+`select.rs`.\n+\n+There are two cases where we currently use the local cache. The\n+current rules are probably more conservative than necessary.\n+\n+### Trait references that involve parameter types\n+\n+The most obvious case where you need the local environment is\n+when the trait reference includes parameter types. For example,\n+consider the following function:\n+\n+    impl<T> Vec<T> {\n+        fn foo(x: T)\n+            where T : Foo\n+        { ... }\n+\n+        fn bar(x: T)\n+        { ... }\n+    }\n+\n+If there is an obligation `T : Foo`, or `int : Bar<T>`, or whatever,\n+clearly the results from `foo` and `bar` are potentially different,\n+since the set of where clauses in scope are different.\n+\n+### Trait references with unbound variables when where clauses are in scope\n+\n+There is another less obvious interaction which involves unbound variables\n+where *only* where clauses are in scope (no impls). This manifested as\n+issue #18209 (`run-pass/trait-cache-issue-18209.rs`). Consider\n+this snippet:\n+\n+```\n+pub trait Foo {\n+    fn load_from() -> Box<Self>;\n+    fn load() -> Box<Self> {\n+        Foo::load_from()\n+    }\n+}\n+```\n+\n+The default method will incur an obligation `$0 : Foo` from the call\n+to `load_from`. If there are no impls, this can be eagerly resolved to\n+`VtableParam(Self : Foo)` and cached. Because the trait reference\n+doesn't involve any parameters types (only the resolution does), this\n+result was stored in the global cache, causing later calls to\n+`Foo::load_from()` to get nonsense.\n+\n+To fix this, we always use the local cache if there are unbound\n+variables and where clauses in scope. This is more conservative than\n+necessary as far as I can tell. However, it still seems to be a simple\n+rule and I observe ~99% hit rate on rustc, so it doesn't seem to hurt\n+us in particular.\n+\n+Here is an example of the kind of subtle case that I would be worried\n+about with a more complex rule (although this particular case works\n+out ok). Imagine the trait reference doesn't directly reference a\n+where clause, but the where clause plays a role in the winnowing\n+phase. Something like this:\n+\n+```\n+pub trait Foo<T> { ... }\n+pub trait Bar { ... }\n+impl<U,T:Bar> Foo<U> for T { ... } // Impl A\n+impl Foo<char> for uint { ... }    // Impl B\n+```\n+\n+Now, in some function, we have no where clauses in scope, and we have\n+an obligation `$1 : Foo<$0>`. We might then conclude that `$0=char`\n+and `$1=uint`: this is because for impl A to apply, `uint:Bar` would\n+have to hold, and we know it does not or else the coherence check\n+would have failed.  So we might enter into our global cache: `$1 :\n+Foo<$0> => Impl B`.  Then we come along in a different scope, where a\n+generic type `A` is around with the bound `A:Bar`. Now suddenly the\n+impl is viable.\n+\n+The flaw in this imaginary DOOMSDAY SCENARIO is that we would not\n+currently conclude that `$1 : Foo<$0>` implies that `$0 == uint` and\n+`$1 == char`, even though it is true that (absent type parameters)\n+there is no other type the user could enter. However, it is not\n+*completely* implausible that we *could* draw this conclusion in the\n+future; we wouldn't have to guess types, in particular, we could be\n+led by the impls.\n+\n+\n+\n+*/"}]}