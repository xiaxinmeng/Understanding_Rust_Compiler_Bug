{"sha": "14c32bfd8b22a625e3224202470e49ff250f7a61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0YzMyYmZkOGIyMmE2MjVlMzIyNDIwMjQ3MGU0OWZmMjUwZjdhNjE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-04-25T09:32:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-25T09:32:07Z"}, "message": "Merge pull request #978 from bjorn3/simple_debuginfo_for_arguments\n\nGenerate simple debuginfo for arguments", "tree": {"sha": "3342c225fd9420eb917313b7b953946dad309fd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3342c225fd9420eb917313b7b953946dad309fd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14c32bfd8b22a625e3224202470e49ff250f7a61", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJepAOXCRBK7hj4Ov3rIwAAdHIIAHdWHuocuO3dMKlR5pFYSf9+\nuku1sWBzm6s7j0MDb8V0FsQYL2+CtWEOr67LGd0DsmY1L7aGZJMGr539dfMmTAEs\nmuXDrMO6G4GhFBkkh5ObSjUDwWagr+tf0QiXYT2M9iZyFm0yenh+GUYAtNJ5x/tQ\ngUPWw9RxnuIiCu99TnEHifn38zymX4UKZmyWMX53q0+iurKuO5rqUnp5U/PMh76b\nFRfSdNptqRU9RCOlaAZORVoEnxh7y/ocLfGNrlWB15eZ2qTsW2CbaZKSM3jg9L8v\n8yRmf+15axf831YRJMBFJYpYUDkUIoQV8Lgy21PM7Y/lhd8BrsDxGvqfPdm6gQE=\n=fbeY\n-----END PGP SIGNATURE-----\n", "payload": "tree 3342c225fd9420eb917313b7b953946dad309fd0\nparent 169140506366d5aa96967a71b6af98563a9c2988\nparent c3180f3bd724d11600b2bb8b3b98fb61d78aa46f\nauthor bjorn3 <bjorn3@users.noreply.github.com> 1587807127 +0200\ncommitter GitHub <noreply@github.com> 1587807127 +0200\n\nMerge pull request #978 from bjorn3/simple_debuginfo_for_arguments\n\nGenerate simple debuginfo for arguments"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14c32bfd8b22a625e3224202470e49ff250f7a61", "html_url": "https://github.com/rust-lang/rust/commit/14c32bfd8b22a625e3224202470e49ff250f7a61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14c32bfd8b22a625e3224202470e49ff250f7a61/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "169140506366d5aa96967a71b6af98563a9c2988", "url": "https://api.github.com/repos/rust-lang/rust/commits/169140506366d5aa96967a71b6af98563a9c2988", "html_url": "https://github.com/rust-lang/rust/commit/169140506366d5aa96967a71b6af98563a9c2988"}, {"sha": "c3180f3bd724d11600b2bb8b3b98fb61d78aa46f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3180f3bd724d11600b2bb8b3b98fb61d78aa46f", "html_url": "https://github.com/rust-lang/rust/commit/c3180f3bd724d11600b2bb8b3b98fb61d78aa46f"}], "stats": {"total": 220, "additions": 213, "deletions": 7}, "files": [{"sha": "502b1b03623101aed67066eff4c4a98ea37ac13f", "filename": "docs/dwarf.md", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/14c32bfd8b22a625e3224202470e49ff250f7a61/docs%2Fdwarf.md", "raw_url": "https://github.com/rust-lang/rust/raw/14c32bfd8b22a625e3224202470e49ff250f7a61/docs%2Fdwarf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdwarf.md?ref=14c32bfd8b22a625e3224202470e49ff250f7a61", "patch": "@@ -19,3 +19,135 @@ debugger won't find the line number information. On macOS the debuginfo relocati\n section relative and not symbol relative.\n See [#303 (comment)](https://github.com/bjorn3/rustc_codegen_cranelift/issues/303#issuecomment-457825535)\n for more information.\n+\n+# Function debuginfo\n+\n+## Tips\n+\n+`DW_TAG_subprogram` requires `DW_AT_name`, `DW_AT_low_pc` and `DW_AT_high_pc` **or** `DW_AT_ranges`.\n+Otherwise gdb will silently skip it. When `DW_AT_high_pc` is a length instead of an address, the\n+DWARF version must be at least 4.\n+\n+<details>\n+<summary>IRC log of #gdb on irc.freenode.org at 2020-04-23</summary>\n+\n+```\n+(13:46:11) bjorn3: i am writing a backend for a compiler that uses DWARF for debuginfo. for some reason gdb seems to completely ignore all DW_TAG_subprogram, while lldb works fine. any idea what the problem could be?\n+(13:47:49) bjorn3: this is the output of llvm-dwarfdump: https://gist.github.com/bjorn3/8a34e333c80f13cb048381e94b4a3756\n+(13:47:50) osa1: luispm: why is that problem not exists in 'commands'? (the target vs. host)\n+(13:52:16) luispm: osa1, commands is a bit more high level. It executes isolated commands. Breakpoint conditions need to be evaluated in the context of a valid expression. That expression may involve variables, symbols etc.\n+(13:52:36) luispm: osa1, Oh, i see your point now. Commands is only executed on the host.\n+(13:53:18) luispm: osa1, The commands are not tied to the execution context of the debugged program. The breakpoint conditions determine if execution must stop or continue etc.\n+(13:55:00) luispm: bjorn3, Likely something GDB thinks is wrong. Does enabling \"set debug dwarf*\" show anything?\n+(13:56:01) bjorn3: luispm: no\n+(13:56:12) bjorn3: for more context: https://github.com/bjorn3/rustc_codegen_cranelift/pull/978\n+(13:58:16) osa1 verliet de ruimte (quit: Quit: osa1).\n+(13:58:28) bjorn3: luispm: wait, for b m<TAB> it shows nothing, but when stepping into a new function it does\n+(13:58:45) bjorn3: it still doesn't show anything for `info args` though\n+(13:58:50) bjorn3: No symbol table info available.\n+(14:00:50) luispm: bjorn3, Is that expected given the nature of the binary?\n+(14:01:17) bjorn3: b main<TAB> may show nothing as I only set DW_AT_linkage_name and not DW_AT_name\n+(14:01:24) bjorn3: info args should work though\n+(14:03:26) luispm: Sorry, I'm not sure what's up. There may be a genuine bug there.\n+(14:03:41) luispm: tromey (not currently in the channel, but maybe later today) may have more input.\n+(14:04:08) bjorn3: okay, thanks luispm!\n+(14:04:27) luispm: In the worst case, reporting a bug may prompt someone to look into that as well.\n+(14:04:48) luispm: Or send an e-mail to the gdb@sourceware.org mailing list.\n+(14:05:11) bjorn3: I don't know if it is a bug in gdb, or just me producing (slightly) wrong DWARF\n+(14:39:40) irker749: gdb: tom binutils-gdb.git:master * 740480b88af / gdb/ChangeLog gdb/darwin-nat.c gdb/inferior.c gdb/inferior.h: Remove iterate_over_inferiors\n+(15:22:45) irker749: gdb: tromey binutils-gdb.git:master * ecc6c6066b5 / gdb/ChangeLog gdb/dwarf2/read.c gdb/unittests/lookup_name_info-selftests.c: Fix Ada crash with .debug_names\n+(15:23:13) bjorn3: tromey: ping\n+(15:23:29) tromey: bjorn3: hey\n+(15:24:16) bjorn3: I am writing a backend for a compiler which uses DWARF for debuginfo. I unfortunately can't get gdb to show arguments. lldb works fine.\n+(15:25:13) bjorn3: it just says: No symbol table info available.\n+(15:25:21) bjorn3: any idea what it could be?\n+(15:25:34) bjorn3: dwarfdump output: https://gist.github.com/bjorn3/8a34e333c80f13cb048381e94b4a3756\n+(15:26:48) bjorn3: more context: https://github.com/bjorn3/rustc_codegen_cranelift/pull/978\n+(15:28:05) tromey: offhand I don't know, but if you can send me an executable I can look\n+(15:28:17) bjorn3: how should I send it?\n+(15:29:26) tromey: good question\n+(15:29:41) tromey: you could try emailing it to tromey at adacore.com\n+(15:29:47) tromey: dunno if that will work or not\n+(15:30:26) bjorn3: i will try\n+(15:37:27) bjorn3: tromey: i sent an email with the subject \"gdb args not showing\"\n+(15:38:29) tromey: will check now\n+(15:38:40) bjorn3: thanks!\n+(15:42:51) irker749: gdb: tdevries binutils-gdb.git:master * de82891ce5b / gdb/ChangeLog gdb/block.c gdb/block.h gdb/symtab.c gdb/testsuite/ChangeLog gdb/testsuite/gdb.base/decl-before-def-decl.c gdb/testsuite/gdb.base/decl-before-def-def.c gdb/testsuite/gdb.base/decl-before-def.exp: [gdb/symtab] Prefer def over decl (inter-CU case)\n+(15:42:52) irker749: gdb: tdevries binutils-gdb.git:master * 70bc38f5138 / gdb/ChangeLog gdb/symtab.c gdb/testsuite/ChangeLog gdb/testsuite/gdb.base/decl-before-def.exp: [gdb/symtab] Prefer def over decl (inter-CU case, with context)\n+(15:43:36) tromey: bjorn3: sorry, got distracted.  I have the file now\n+(15:45:35) tromey: my first thing when investigating was to enable complaints\n+(15:45:37) tromey: so I did\n+(15:45:40) tromey: set complaints 1000\n+(15:45:42) tromey: then\n+(15:45:51) tromey: file -readnow mini_core_hello_world\n+(15:46:00) tromey: gdb printed just one style of complaint\n+(15:46:07) tromey: During symbol reading: missing name for subprogram DIE at 0x3f7\n+(15:46:18) tromey: (which is really pretty good, most compilers manage to generate a bunch)\n+(15:46:29) tromey: and then the gdb DWARF reader says\n+(15:46:34) tromey:   /* Ignore functions with missing or empty names.  These are actually\n+(15:46:34) tromey:      illegal according to the DWARF standard.  */\n+(15:46:34) tromey:   if (name == NULL)\n+(15:46:34) tromey:     {\n+(15:46:37) tromey:       complaint (_(\"missing name for subprogram DIE at %s\"),\n+(15:46:40) tromey: \t\t sect_offset_str (die->sect_off));\n+(15:46:47) tromey: I wonder if that comment is correct though\n+(15:47:34) tromey: I guess pedantically maybe it is, DWARF 5 3.3.1 says\n+(15:47:43) tromey: The subroutine or entry point entry has a DW_AT_name attribute whose value is\n+(15:47:43) tromey: a null-terminated string containing the subroutine or entry point name.\n+(15:48:14) bjorn3: i tried set complaints, but it returned complaints for system files. i didn't know about file -readnow.\n+(15:48:21) tromey: cool\n+(15:48:26) bjorn3: i will try adding DW_AT_name\n+(15:48:45) tromey: without readnow unfortunately you get less stuff, because for whatever reason gdb has 2 separate DWARF scanners\n+(15:49:02) tromey: sort of anyway\n+(15:49:43) tromey: this seems kind of pedantic of gdb, like if there's a linkage name but no DW_AT_name, then why bail?\n+(15:50:01) tromey: also what about anonymous functions\n+(15:50:17) tromey: but anyway this explains the current situation and if you don't mind adding DW_AT_name, then that's probably simplest\n+(15:51:47) bjorn3: i added DW_AT_name.\n+(15:51:54) bjorn3: now it says cannot get low and high bounds for subprogram DIE at ...\n+(15:52:01) tromey: ugh\n+(15:52:10) bjorn3: i will add DW_AT_low_pc and DW_AT_high_pc\n+(15:52:15) tromey:   /* Ignore functions with missing or invalid low and high pc attributes.  */\n+(15:52:37) tromey: you can also use DW_AT_ranges\n+(15:52:55) tromey: if you'd prefer\n+(15:53:08) bjorn3: already using DW_AT_ranges for DW_TAG_compilation_unit\n+(15:53:19) bjorn3: for individual functions, there are no gaps\n+(15:57:07) bjorn3: still the same error with DW_AT_low_pc and DW_AT_high_pc\n+(15:57:24) bjorn3: tromey: ^\n+(15:58:08) tromey: hmmm\n+(15:58:30) bjorn3: should i send the new executable?\n+(15:58:31) tromey: send me another executable & I will debug\n+(15:58:33) tromey: yep\n+(15:59:23) bjorn3: sent as repy of the previous mail\n+(16:03:23) tromey: the low PC has DW_FORM_addr, but the high PC has DW_FORM_udata, which seems weird\n+(16:03:50) mjw: no\n+(16:03:54) tromey: no?\n+(16:04:00) mjw: I suggested that for the DWARF standard...\n+(16:04:05) mjw: sorry\n+(16:04:58) mjw: The idea was that instead of two relocations and two address wide fields, you have one address and a constant offset.\n+(16:05:05) tromey: ahh, I see the code now\n+(16:05:07) tromey: I forgot about this\n+(16:05:18) tromey: \t  if (cu->header.version >= 4 && attr_high->form_is_constant ())\n+(16:05:18) tromey: \t    high += low;\n+(16:05:36) mjw: that second offset doesn't need a relocation and can often be packed in something small, like an uleb128\n+(16:05:51) mjw: using udata might not be ideal though, but is allowed\n+(16:05:51) tromey: bjorn3: the problem is that this CU claims to be DWARF 3 but is using a DWARF 4 feature\n+(16:05:58) mjw: aha\n+(16:05:59) bjorn3: which one?\n+(16:06:03) ryoshu: hi\n+(16:06:08) tromey:              high_pc              (udata) 107 (+0x00000000000011b0 <_ZN21mini_core_hello_world5start17hec55b7ca64fc434eE>)\n+(16:06:08) tromey:\n+(16:06:12) ryoshu: just soft ping, I have a queue of patches :)\n+(16:06:22) tromey: using this as a length requires DWARF 4\n+(16:06:36) tromey: for gdb at least it's fine to always emit DWARF 4\n+(16:06:44) bjorn3: trying dwarf 4 now\n+(16:06:48) tromey: I think there are some DWARF 5 features still in the works but DWARF 4 should be solid AFAIK\n+(16:07:03) tromey: fini\n+(16:07:08) tromey: lol wrong window\n+(16:07:56) mjw: Maybe you can accept it for DWARF < 4. But if I remember correctly it might be that people might have been using udata as if it was an address...\n+(16:08:13) tromey: yeah, I vaguely recall this as well, though I'd expect there to be a comment\n+(16:08:21) mjw: Cannot really remember why it needed version >= 4. Maybe there was no good reason?\n+(16:08:32) bjorn3: tromey: it works!!!! thanks for all the help!\n+(16:08:41) tromey: my pleasure bjorn3\n+```\n+\n+</details>"}, {"sha": "21618d2ded82860d7f7ff248462473ec0c22109c", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 81, "deletions": 7, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/14c32bfd8b22a625e3224202470e49ff250f7a61/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14c32bfd8b22a625e3224202470e49ff250f7a61/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=14c32bfd8b22a625e3224202470e49ff250f7a61", "patch": "@@ -35,6 +35,7 @@ pub(crate) struct DebugContext<'tcx> {\n     dwarf: DwarfUnit,\n     unit_range_list: RangeList,\n \n+    clif_types: FxHashMap<Type, UnitEntryId>,\n     types: FxHashMap<Ty<'tcx>, UnitEntryId>,\n }\n \n@@ -116,10 +117,45 @@ impl<'tcx> DebugContext<'tcx> {\n             dwarf,\n             unit_range_list: RangeList(Vec::new()),\n \n+            clif_types: FxHashMap::default(),\n             types: FxHashMap::default(),\n         }\n     }\n \n+    fn dwarf_ty_for_clif_ty(&mut self, ty: Type) -> UnitEntryId {\n+        if let Some(type_id) = self.clif_types.get(&ty) {\n+            return *type_id;\n+        }\n+\n+        let new_entry = |dwarf: &mut DwarfUnit, tag| dwarf.unit.add(dwarf.unit.root(), tag);\n+\n+        let primitive = |dwarf: &mut DwarfUnit, ate| {\n+            let type_id = new_entry(dwarf, gimli::DW_TAG_base_type);\n+            let type_entry = dwarf.unit.get_mut(type_id);\n+            type_entry.set(gimli::DW_AT_encoding, AttributeValue::Encoding(ate));\n+            type_id\n+        };\n+\n+        let type_id = if ty.is_bool() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_boolean)\n+        } else if ty.is_int() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_address)\n+        } else if ty.is_float() {\n+            primitive(&mut self.dwarf, gimli::DW_ATE_float)\n+        } else {\n+            new_entry(&mut self.dwarf, gimli::DW_TAG_structure_type)\n+        };\n+\n+        let type_entry = self.dwarf.unit.get_mut(type_id);\n+        type_entry.set(gimli::DW_AT_name, AttributeValue::String(format!(\"{}\", ty).replace('i', \"u\").into_bytes()));\n+        type_entry.set(\n+            gimli::DW_AT_byte_size,\n+            AttributeValue::Udata(u64::from(ty.bytes())),\n+        );\n+\n+        type_id\n+    }\n+\n     fn dwarf_ty(&mut self, ty: Ty<'tcx>) -> UnitEntryId {\n         if let Some(type_id) = self.types.get(ty) {\n             return *type_id;\n@@ -234,6 +270,11 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n             .add(scope, gimli::DW_TAG_subprogram);\n         let entry = debug_context.dwarf.unit.get_mut(entry_id);\n         let name_id = debug_context.dwarf.strings.add(name);\n+        // Gdb requires DW_AT_name. Otherwise the DW_TAG_subprogram is skipped.\n+        entry.set(\n+            gimli::DW_AT_name,\n+            AttributeValue::StringRef(name_id),\n+        );\n         entry.set(\n             gimli::DW_AT_linkage_name,\n             AttributeValue::StringRef(name_id),\n@@ -249,11 +290,6 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n     }\n \n     fn define_local(&mut self, name: String, ty: Ty<'tcx>) -> UnitEntryId {\n-        let ty = self.debug_context.tcx.subst_and_normalize_erasing_regions(\n-            self.instance.substs,\n-            ty::ParamEnv::reveal_all(),\n-            &ty,\n-        );\n         let dw_ty = self.debug_context.dwarf_ty(ty);\n \n         let var_id = self\n@@ -290,15 +326,53 @@ impl<'a, 'tcx> FunctionDebugContext<'a, 'tcx> {\n                     symbol: self.symbol,\n                     addend: 0,\n                 },\n-                length: end as u64,\n+                length: u64::from(end),\n             });\n \n+        let func_entry = self.debug_context.dwarf.unit.get_mut(self.entry_id);\n+        // Gdb requires both DW_AT_low_pc and DW_AT_high_pc. Otherwise the DW_TAG_subprogram is skipped.\n+        func_entry.set(gimli::DW_AT_low_pc, AttributeValue::Address(Address::Symbol {\n+            symbol: self.symbol,\n+            addend: 0,\n+        }));\n+        // Using Udata for DW_AT_high_pc requires at least DWARF4\n+        func_entry.set(gimli::DW_AT_high_pc, AttributeValue::Udata(u64::from(end)));\n+\n+        // FIXME Remove once actual debuginfo for locals works.\n+        for (i, (param, &val)) in context.func.signature.params.iter().zip(context.func.dfg.block_params(context.func.layout.entry_block().unwrap())).enumerate() {\n+            use cranelift_codegen::ir::ArgumentPurpose;\n+            let base_name = match param.purpose {\n+                ArgumentPurpose::Normal => \"arg\",\n+                ArgumentPurpose::StructReturn => \"sret\",\n+                ArgumentPurpose::Link | ArgumentPurpose::FramePointer | ArgumentPurpose::CalleeSaved => continue,\n+                ArgumentPurpose::VMContext | ArgumentPurpose::SignatureId | ArgumentPurpose::StackLimit => unreachable!(),\n+            };\n+            let name = format!(\"{}{}\", base_name, i);\n+\n+            let dw_ty = self.debug_context.dwarf_ty_for_clif_ty(param.value_type);\n+            let loc = Expression(\n+                translate_loc(isa, context.func.locations[val], &context.func.stack_slots).unwrap(),\n+            );\n+\n+            let arg_id = self.debug_context.dwarf.unit.add(self.entry_id, gimli::DW_TAG_formal_parameter);\n+            let var_entry = self.debug_context.dwarf.unit.get_mut(arg_id);\n+\n+            var_entry.set(gimli::DW_AT_name, AttributeValue::String(name.into_bytes()));\n+            var_entry.set(gimli::DW_AT_type, AttributeValue::ThisUnitEntryRef(dw_ty));\n+            var_entry.set(gimli::DW_AT_location, AttributeValue::Exprloc(loc));\n+        }\n+\n         // FIXME make it more reliable and implement scopes before re-enabling this.\n         if false {\n             let value_labels_ranges = context.build_value_labels_ranges(isa).unwrap();\n \n             for (local, _local_decl) in self.mir.local_decls.iter_enumerated() {\n-                let var_id = self.define_local(format!(\"{:?}\", local), &self.mir.local_decls[local].ty);\n+                let ty = self.debug_context.tcx.subst_and_normalize_erasing_regions(\n+                    self.instance.substs,\n+                    ty::ParamEnv::reveal_all(),\n+                    &self.mir.local_decls[local].ty,\n+                );\n+                let var_id = self.define_local(format!(\"{:?}\", local), ty);\n \n                 let location = place_location(\n                     self,"}]}