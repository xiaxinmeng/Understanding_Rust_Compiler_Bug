{"sha": "553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1M2E1NmRkOThjZWUyZTQyZmU4ZGUwZTNhZDAyYTQxYTRhMGViMTM=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-06T21:38:07Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-09-07T15:29:04Z"}, "message": "Apply suggestions from code review", "tree": {"sha": "92afc2f3bf4ccebb3b4cab330a93578163825a2e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92afc2f3bf4ccebb3b4cab330a93578163825a2e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "html_url": "https://github.com/rust-lang/rust/commit/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d2fd1725510fd3bf6f2937e178b1aa055ddb02", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d2fd1725510fd3bf6f2937e178b1aa055ddb02", "html_url": "https://github.com/rust-lang/rust/commit/49d2fd1725510fd3bf6f2937e178b1aa055ddb02"}], "stats": {"total": 35, "additions": 17, "deletions": 18}, "files": [{"sha": "3120d0e35173ddfe440e567bf554d3352db1b5b5", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -1086,7 +1086,7 @@ impl<'a> Parser<'a> {\n     /// statement. This is something of a best-effort heuristic.\n     ///\n     /// We terminate when we find an unmatched `}` (without consuming it).\n-    pub fn recover_stmt(&mut self) {\n+    crate fn recover_stmt(&mut self) {\n         self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n     }\n "}, {"sha": "c1ec41902e2bea58032c415ea1a10557fdfdbfb0", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -39,7 +39,7 @@ fn t1() {\n         let mut string_reader = setup(\n             &sm,\n             &sh,\n-            \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\".to_owned(),\n+            \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\".to_string(),\n         );\n         assert_eq!(string_reader.next_token(), token::Comment);\n         assert_eq!(string_reader.next_token(), token::Whitespace);"}, {"sha": "4dbb5ff75eb216225a8015a7c68593eee8d129b5", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -843,7 +843,7 @@ impl<'a> Parser<'a> {\n                 return self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs);\n             }\n             token::BinOp(token::Or) | token::OrOr => {\n-                return self.parse_closure(attrs);\n+                return self.parse_closure_expr(attrs);\n             }\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n@@ -919,7 +919,7 @@ impl<'a> Parser<'a> {\n                     return self.maybe_recover_from_bad_qpath(expr, true);\n                 }\n                 if self.check_keyword(kw::Move) || self.check_keyword(kw::Static) {\n-                    return self.parse_closure(attrs);\n+                    return self.parse_closure_expr(attrs);\n                 }\n                 if self.eat_keyword(kw::If) {\n                     return self.parse_if_expr(attrs);\n@@ -996,7 +996,7 @@ impl<'a> Parser<'a> {\n                     return if self.is_async_block() { // Check for `async {` and `async move {`.\n                         self.parse_async_block(attrs)\n                     } else {\n-                        self.parse_closure(attrs)\n+                        self.parse_closure_expr(attrs)\n                     };\n                 }\n                 if self.eat_keyword(kw::Return) {\n@@ -1097,8 +1097,8 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs))\n     }\n \n-    /// Parses a closure (e.g., `move |args| expr`).\n-    fn parse_closure(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    /// Parses a closure expression (e.g., `move |args| expr`).\n+    fn parse_closure_expr(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let lo = self.token.span;\n \n         let movability = if self.eat_keyword(kw::Static) {"}, {"sha": "04bd61a4cfb5b3f47a2ae7743c39550fac9baae3", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -422,7 +422,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a statement, including the trailing semicolon.\n-    pub fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n+    crate fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n         // Skip looking for a trailing semicolon when we have an interpolated statement.\n         maybe_whole!(self, NtStmt, |x| Some(x));\n "}, {"sha": "d7ea799e00459029495c3b13c755ea5746a57a03", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -479,8 +479,8 @@ impl SourceMap {\n     }\n \n     pub fn span_to_unmapped_path(&self, sp: Span) -> FileName {\n-        let source_file = self.lookup_char_pos(sp.lo()).file;\n-        source_file.unmapped_path.clone().unwrap_or(source_file.name.clone())\n+        self.lookup_char_pos(sp.lo()).file.unmapped_path.clone()\n+            .expect(\"`SourceMap::span_to_unmapped_path` called for imported `SourceFile`?\")\n     }\n \n     pub fn is_multiline(&self, sp: Span) -> bool {"}, {"sha": "15254336bbfa5dd8049113c24f230d165f16a02e", "filename": "src/libsyntax/source_map/tests.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map%2Ftests.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -97,7 +97,7 @@ fn t6() {\n #[test]\n fn t7() {\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let file_lines = sm.span_to_lines(span).unwrap();\n \n     assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n@@ -113,7 +113,7 @@ fn span_from_selection(input: &str, selection: &str) -> Span {\n     assert_eq!(input.len(), selection.len());\n     let left_index = selection.find('~').unwrap() as u32;\n     let right_index = selection.rfind('~').map(|x|x as u32).unwrap_or(left_index);\n-    Span::new(BytePos(left_index), BytePos(right_index + 1), NO_EXPANSION)\n+    Span::with_root_ctxt(BytePos(left_index), BytePos(right_index + 1))\n }\n \n /// Tests `span_to_snippet` and `span_to_lines` for a span converting 3\n@@ -143,7 +143,7 @@ fn span_to_snippet_and_lines_spanning_multiple_lines() {\n #[test]\n fn t8() {\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let snippet = sm.span_to_snippet(span);\n \n     assert_eq!(snippet, Ok(\"second line\".to_string()));\n@@ -153,7 +153,7 @@ fn t8() {\n #[test]\n fn t9() {\n     let sm = init_source_map();\n-    let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n+    let span = Span::with_root_ctxt(BytePos(12), BytePos(23));\n     let sstr =  sm.span_to_string(span);\n \n     assert_eq!(sstr, \"blork.rs:2:1: 2:12\");\n@@ -176,7 +176,7 @@ fn span_merging_fail() {\n /// Returns the span corresponding to the `n`th occurrence of `substring` in `source_text`.\n trait SourceMapExtension {\n     fn span_substr(\n-        self,\n+        &self,\n         file: &Lrc<SourceFile>,\n         source_text: &str,\n         substring: &str,\n@@ -208,10 +208,9 @@ impl SourceMapExtension for SourceMap {\n             let lo = hi + offset;\n             hi = lo + substring.len();\n             if i == n {\n-                let span = Span::new(\n+                let span = Span::with_root_ctxt(\n                     BytePos(lo as u32 + file.start_pos.0),\n                     BytePos(hi as u32 + file.start_pos.0),\n-                    NO_EXPANSION,\n                 );\n                 assert_eq!(&self.span_to_snippet(span).unwrap()[..], substring);\n                 return span;"}, {"sha": "d7c537be89668814707e1b873bd2a4d2a6ba622a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=553a56dd98cee2e42fe8de0e3ad02a41a4a0eb13", "patch": "@@ -344,7 +344,6 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n             walk_list!(visitor, visit_lifetime, opt_lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Never => {}\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }\n@@ -373,6 +372,7 @@ pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {\n         TyKind::Mac(ref mac) => {\n             visitor.visit_mac(mac)\n         }\n+        TyKind::Never |\n         TyKind::CVarArgs => {}\n     }\n }"}]}