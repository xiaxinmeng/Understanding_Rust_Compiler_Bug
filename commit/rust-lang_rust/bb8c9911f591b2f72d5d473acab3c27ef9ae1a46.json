{"sha": "bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiOGM5OTExZjU5MWIyZjcyZDVkNDczYWNhYjNjMjdlZjlhZTFhNDY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-12-28T15:52:51Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-14T22:40:03Z"}, "message": "Erase regions in opaque types in typeck", "tree": {"sha": "cf0e322814459086e6bb4cb31d297f0f3ba960ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf0e322814459086e6bb4cb31d297f0f3ba960ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "html_url": "https://github.com/rust-lang/rust/commit/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fb02549b85258a039cc8cb6006c028ab437f85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fb02549b85258a039cc8cb6006c028ab437f85a", "html_url": "https://github.com/rust-lang/rust/commit/2fb02549b85258a039cc8cb6006c028ab437f85a"}], "stats": {"total": 92, "additions": 65, "deletions": 27}, "files": [{"sha": "088e57f91a7a58348781738a3ef03d8544553d56", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "patch": "@@ -814,32 +814,37 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match r {\n-            // ignore bound regions that appear in the type (e.g., this\n-            // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) |\n+            // Ignore bound regions that appear in the type, they don't need to\n+            // be remapped (e.g., this would ignore `'r` in a type like\n+            // `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..)\n+\n+            // If regions have been erased, don't try to unerase them.\n+            | ty::ReErased\n \n             // ignore `'static`, as that can appear anywhere\n-            ty::ReStatic => return r,\n+            | ty::ReStatic => return r,\n \n-            _ => { }\n+            _ => {}\n         }\n \n         let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n+                self.tcx.lifetimes.re_empty\n+            }\n             None if generics.parent.is_some() => {\n-                if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n-                    if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        unexpected_hidden_region_diagnostic(\n-                            self.tcx,\n-                            None,\n-                            self.opaque_type_def_id,\n-                            hidden_ty,\n-                            r,\n-                        )\n-                        .emit();\n-                    }\n+                if let Some(hidden_ty) = self.hidden_ty.take() {\n+                    unexpected_hidden_region_diagnostic(\n+                        self.tcx,\n+                        None,\n+                        self.opaque_type_def_id,\n+                        hidden_ty,\n+                        r,\n+                    )\n+                    .emit();\n                 }\n                 self.tcx.lifetimes.re_root_empty\n             }"}, {"sha": "5ff0d04c1ed24e38d8d51bb5fce996794e245c91", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "patch": "@@ -120,6 +120,10 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n     }\n \n+    fn has_erased_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n+    }\n+\n     /// True if there are any un-erased free regions.\n     fn has_erasable_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)"}, {"sha": "6d36116d782e64504f04d550bd45e74127dede19", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "patch": "@@ -474,10 +474,13 @@ bitflags! {\n         /// if a global bound is safe to evaluate.\n         const HAS_RE_LATE_BOUND  = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 12;\n+        /// Does this have any `ReErased` regions?\n+        const HAS_RE_ERASED  = 1 << 12;\n \n-        const HAS_CT_INFER       = 1 << 13;\n-        const HAS_CT_PLACEHOLDER = 1 << 14;\n+        const HAS_TY_PLACEHOLDER = 1 << 13;\n+\n+        const HAS_CT_INFER       = 1 << 14;\n+        const HAS_CT_PLACEHOLDER = 1 << 15;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -497,6 +500,7 @@ bitflags! {\n                                   TypeFlags::HAS_FREE_LOCAL_NAMES.bits |\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n+                                  TypeFlags::HAS_RE_ERASED.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_CT_INFER.bits |\n                                   TypeFlags::HAS_CT_PLACEHOLDER.bits;"}, {"sha": "02abac975ac841e4a2faeab812625928370332ec", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "patch": "@@ -1777,7 +1777,9 @@ impl RegionKind {\n             ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n-            ty::ReErased => {}\n+            ty::ReErased => {\n+                flags = flags | TypeFlags::HAS_RE_ERASED;\n+            }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }"}, {"sha": "3a1622f1649e50d8e11685a570b5a498018753cd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "patch": "@@ -426,7 +426,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n-            let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n+            let instantiated_ty =\n+                self.tcx().erase_regions(&self.resolve(&opaque_defn.concrete_ty, &hir_id));\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n "}, {"sha": "4448c067d348bae14b406b495a8684e05b054142", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8c9911f591b2f72d5d473acab3c27ef9ae1a46/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bb8c9911f591b2f72d5d473acab3c27ef9ae1a46", "patch": "@@ -33,8 +33,8 @@ use rustc::ty::subst::GenericArgKind;\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, WithConstness};\n-use rustc::ty::{ReprOptions, ToPredicate};\n+use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n@@ -1463,9 +1463,22 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     find_opaque_ty_constraints(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n-                    tcx.mir_borrowck(owner)\n-                        .concrete_opaque_types\n+                ItemKind::OpaqueTy(hir::OpaqueTy {\n+                    impl_trait_fn: Some(owner), origin, ..\n+                }) => {\n+                    let concrete_types = match origin {\n+                        hir::OpaqueTyOrigin::FnReturn | hir::OpaqueTyOrigin::AsyncFn => {\n+                            &tcx.mir_borrowck(owner).concrete_opaque_types\n+                        }\n+                        hir::OpaqueTyOrigin::Misc => {\n+                            // We shouldn't leak borrowck results through impl Trait in bindings.\n+                            &tcx.typeck_tables_of(owner).concrete_opaque_types\n+                        }\n+                        hir::OpaqueTyOrigin::TypeAlias => {\n+                            span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n+                        }\n+                    };\n+                    let concrete_ty = concrete_types\n                         .get(&def_id)\n                         .map(|opaque| opaque.concrete_type)\n                         .unwrap_or_else(|| {\n@@ -1480,7 +1493,16 @@ fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 ),\n                             );\n                             tcx.types.err\n-                        })\n+                        });\n+                    debug!(\"concrete_ty = {:?}\", concrete_ty);\n+                    if concrete_ty.has_erased_regions() {\n+                        // FIXME(impl_trait_in_bindings) Handle this case.\n+                        tcx.sess.span_fatal(\n+                            item.span,\n+                            \"lifetimes in impl Trait types in bindings are not currently supported\",\n+                        );\n+                    }\n+                    concrete_ty\n                 }\n                 ItemKind::Trait(..)\n                 | ItemKind::TraitAlias(..)"}]}