{"sha": "4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMGFiN2RiODVkMjA4NDg3MGRiNGEyZjkyZDkyYTNhZTY3YTNiYjE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:01:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "explain the magic", "tree": {"sha": "4f3f6f904f72253d31ac9be6e42a972ab6b9f003", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f3f6f904f72253d31ac9be6e42a972ab6b9f003"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "html_url": "https://github.com/rust-lang/rust/commit/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "html_url": "https://github.com/rust-lang/rust/commit/b4b522fb3952fae365e02ffdc6ef05c8d75b7674"}], "stats": {"total": 75, "additions": 56, "deletions": 19}, "files": [{"sha": "3e7f458cf41ef83fa5890f3ccef60e47b17cf523", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "patch": "@@ -109,6 +109,13 @@ mod tests {\n \n     use super::*;\n \n+    // Good first issue (although a slightly chellegning one):\n+    //\n+    // * Pick a random test from here\n+    //   https://github.com/intellij-rust/intellij-rust/blob/c4e9feee4ad46e7953b1948c112533360b6087bb/src/test/kotlin/org/rust/lang/core/macros/RsMacroExpansionTest.kt\n+    // * Port the test to rust and add it to this module\n+    // * Make it pass :-)\n+\n     #[test]\n     fn test_convert_tt() {\n         let macro_definition = r#\""}, {"sha": "af5beb786c95b2e6cd92f154ec70ea4a9641447f", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 49, "deletions": 19, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=4c0ab7db85d2084870db4a2f92d92a3ae67a3bb1", "patch": "@@ -1,9 +1,12 @@\n+/// This module takes a (parsed) defenition of `macro_rules` invocation, a\n+/// `tt::TokenTree` representing an argument of macro invocation, and produces a\n+/// `tt::TokenTree` for the result of the expansion.\n use rustc_hash::FxHashMap;\n use ra_syntax::SmolStr;\n \n use crate::tt_cursor::TtCursor;\n \n-pub fn exapnd(rules: &crate::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n+pub(crate) fn exapnd(rules: &crate::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n     rules.rules.iter().find_map(|it| expand_rule(it, input))\n }\n \n@@ -13,6 +16,51 @@ fn expand_rule(rule: &crate::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n     expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n }\n \n+/// The actual algorithm for expansion is not too hard, but is pretty tricky.\n+/// `Bindings` structure is the key to understanding what we are doing here.\n+///\n+/// On the high level, it stores mapping from meta variables to the bits of\n+/// syntax it should be substituted with. For example, if `$e:expr` is matched\n+/// with `1 + 1` by macro_rules, the `Binding` will store `$e -> 1 + 1`.\n+///\n+/// The tricky bit is dealing with repetitions (`$()*`). Consider this example:\n+///\n+/// ```ignore\n+/// macro_rules! foo {\n+///     ($($ i:ident $($ e:expr),*);*) => {\n+///         $(fn $ i() { $($ e);*; })*\n+///     }\n+/// }\n+/// foo! { foo 1,2,3; bar 4,5,6 }\n+/// ```\n+///\n+/// Here, the `$i` meta variable is matched first with `foo` and then with\n+/// `bar`, and `$e` is matched in turn with `1`, `2`, `3`, `4`, `5`, `6`.\n+///\n+/// To represent such \"multi-mappings\", we use a recursive structures: we map\n+/// variables not to values, but to *lists* of values or other lists (that is,\n+/// to the trees).\n+///\n+/// For the above example, the bindings would store\n+///\n+/// ```ignore\n+/// i -> [foo, bar]\n+/// e -> [[1, 2, 3], [4, 5, 6]]\n+/// ```\n+///\n+/// We construct `Bindings` in the `match_lhs`. The interesting case is\n+/// `TokenTree::Repeat`, where we use `push_nested` to create the desired\n+/// nesting structure.\n+///\n+/// The other side of the puzzle is `expand_subtree`, where we use the bindings\n+/// to substitute meta variables in the output template. When expanding, we\n+/// maintain a `nesteing` stack of indicies whihc tells us which occurence from\n+/// the `Bindings` we should take. We push to the stack when we enter a\n+/// repetition.\n+///\n+/// In other words, `Bindings` is a *multi* mapping from `SmolStr` to\n+/// `tt::TokenTree`, where the index to select a particular `TokenTree` among\n+/// many is not a plain `usize`, but an `&[usize]`.\n #[derive(Debug, Default)]\n struct Bindings {\n     inner: FxHashMap<SmolStr, Binding>,\n@@ -95,24 +143,6 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Option<Bindings>\n     Some(res)\n }\n \n-/*\n-\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-impl_froms! (Foo: Bar, Baz)\n-\n-*/\n-\n fn expand_subtree(\n     template: &crate::Subtree,\n     bindings: &Bindings,"}]}