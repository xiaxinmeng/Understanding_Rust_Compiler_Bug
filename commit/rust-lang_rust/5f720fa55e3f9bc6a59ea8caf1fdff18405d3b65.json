{"sha": "5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65", "node_id": "C_kwDOAAsO6NoAKDVmNzIwZmE1NWUzZjliYzZhNTllYThjYWYxZmRmZjE4NDA1ZDNiNjU", "commit": {"author": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-28T04:37:28Z"}, "committer": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-30T00:18:28Z"}, "message": "more review fixes to ptr docs", "tree": {"sha": "1eb9e77ecb0cd482f50f2f4d2e1800a0fd06f74c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1eb9e77ecb0cd482f50f2f4d2e1800a0fd06f74c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65", "html_url": "https://github.com/rust-lang/rust/commit/5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9efcd996d528b7da9beb0a9743b6659c667154d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9efcd996d528b7da9beb0a9743b6659c667154d6", "html_url": "https://github.com/rust-lang/rust/commit/9efcd996d528b7da9beb0a9743b6659c667154d6"}], "stats": {"total": 30, "additions": 19, "deletions": 11}, "files": [{"sha": "afa6225a9f753268323a1669e3efb0fa87cc2518", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=5f720fa55e3f9bc6a59ea8caf1fdff18405d3b65", "patch": "@@ -103,17 +103,17 @@\n //! they must have provenance.\n //!\n //! When an allocation is created, that allocation has a unique Original Pointer. For alloc\n-//! APIs this is literally the pointer the call returns, and for variables declarations this\n-//! is the name of the variable. This is mildly overloading the term \"pointer\" for the sake\n-//! of brevity/exposition.\n+//! APIs this is literally the pointer the call returns, and for local variables and statics,\n+//! this is the name of the variable/static. This is mildly overloading the term \"pointer\"\n+//! for the sake of brevity/exposition.\n //!\n //! The Original Pointer for an allocation is guaranteed to have unique access to the entire\n //! allocation and *only* that allocation. In this sense, an allocation can be thought of\n //! as a \"sandbox\" that cannot be broken into or out of. *Provenance* is the permission\n //! to access an allocation's sandbox and has both a *spatial* and *temporal* component:\n //!\n-//! * Spatial: A range of bytes in the allocation that the pointer is allowed to access.\n-//! * Temporal: Some kind of globally unique identifier tied to the allocation itself.\n+//! * Spatial: A range of bytes that the pointer is allowed to access.\n+//! * Temporal: The allocation that access to these bytes is tied to.\n //!\n //! Spatial provenance makes sure you don't go beyond your sandbox, while temporal provenance\n //! makes sure that you can't \"get lucky\" after your permission to access some memory\n@@ -139,7 +139,8 @@\n //! formal [Stacked Borrows][] research project, which is what tools like [miri][] are based on.\n //! In particular, Stacked Borrows is necessary to properly describe what borrows are allowed\n //! to do and when they become invalidated. This necessarily involves much more complex\n-//! *temporal* reasoning than simply identifying allocations.\n+//! *temporal* reasoning than simply identifying allocations. Adjusting APIs and code\n+//! for the strict provenance experiment will also greatly help Stacked Borrows.\n //!\n //!\n //! ## Pointer Vs Addresses\n@@ -152,7 +153,13 @@\n //! to very complex and unreliable heuristics. But of course, converting between pointers and\n //! integers is very useful, so what can we do?\n //!\n-//! Strict Provenance attempts to square this circle by decoupling Rust's traditional conflation\n+//! Also did you know WASM is actually a \"Harvard Architecture\"? As in function pointers are\n+//! handled completely differently from data pointers? And we kind of just shipped Rust on WASM\n+//! without really addressing the fact that we let you freely convert between function pointers\n+//! and data pointers, because it mostly Just Works? Let's just put that on the \"pointer casts\n+//! are dubious\" pile.\n+//!\n+//! Strict Provenance attempts to square these circles by decoupling Rust's traditional conflation\n //! of pointers and `usize` (and `isize`), and defining a pointer to semantically contain the\n //! following information:\n //!\n@@ -246,14 +253,15 @@\n //! Situations where a valid pointer *must* be created from just an address, such as baremetal code\n //! accessing a memory-mapped interface at a fixed address, are an open question on how to support.\n //! These situations *will* still be allowed, but we might require some kind of \"I know what I'm\n-//! doing\" annotation to explain the situation to the compiler. Because those situations require\n-//! `volatile` accesses anyway, it should be possible to carve out exceptions for them.\n+//! doing\" annotation to explain the situation to the compiler. It's also possible they need no\n+//! special attention at all, because they're generally accessing memory outside the scope of\n+//! \"the abstract machine\", or already using \"I know what I'm doing\" annotations like \"volatile\".\n //!\n //! Under [Strict Provenance] is is Undefined Behaviour to:\n //!\n //! * Access memory through a pointer that does not have provenance over that memory.\n //!\n-//! * [`offset`] a pointer to an address it doesn't have provenance over.\n+//! * [`offset`] a pointer to or from an address it doesn't have provenance over.\n //!   This means it's always UB to offset a pointer derived from something deallocated,\n //!   even if the offset is 0. Note that a pointer \"one past the end\" of its provenance\n //!   is not actually outside its provenance, it just has 0 bytes it can load/store.\n@@ -295,7 +303,7 @@\n //!\n //! * Perform pointer tagging tricks. This falls out of [`wrapping_offset`] but is worth\n //!   mentioning in more detail because of the limitations of [CHERI][]. Low-bit tagging\n-//!   is very robust, and often doesn't even go out of bounds because types have a\n+//!   is very robust, and often doesn't even go out of bounds because types ensure\n //!   size >= align (and over-aligning actually gives CHERI more flexibility). Anything\n //!   more complex than this rapidly enters \"extremely platform-specific\" territory as\n //!   certain things may or may not be allowed based on specific supported operations."}]}