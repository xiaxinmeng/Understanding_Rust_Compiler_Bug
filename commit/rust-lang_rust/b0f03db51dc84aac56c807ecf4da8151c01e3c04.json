{"sha": "b0f03db51dc84aac56c807ecf4da8151c01e3c04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZjAzZGI1MWRjODRhYWM1NmM4MDdlY2Y0ZGE4MTUxYzAxZTNjMDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T09:32:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-08-13T09:37:54Z"}, "message": "Remove deprecated function", "tree": {"sha": "aa14955e0ea4838e6def7a953e90c2348c1a7c4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa14955e0ea4838e6def7a953e90c2348c1a7c4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0f03db51dc84aac56c807ecf4da8151c01e3c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f03db51dc84aac56c807ecf4da8151c01e3c04", "html_url": "https://github.com/rust-lang/rust/commit/b0f03db51dc84aac56c807ecf4da8151c01e3c04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0f03db51dc84aac56c807ecf4da8151c01e3c04/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26b98b07aa0e4430bc872b28eadbc822cfee7b6e", "url": "https://api.github.com/repos/rust-lang/rust/commits/26b98b07aa0e4430bc872b28eadbc822cfee7b6e", "html_url": "https://github.com/rust-lang/rust/commit/26b98b07aa0e4430bc872b28eadbc822cfee7b6e"}], "stats": {"total": 102, "additions": 48, "deletions": 54}, "files": [{"sha": "368d48a712348b8d1ded2d2c522e00c54147544c", "filename": "crates/ra_assists/src/assist_context.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fra_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_context.rs?ref=b0f03db51dc84aac56c807ecf4da8151c01e3c04", "patch": "@@ -5,14 +5,13 @@ use std::mem;\n use algo::find_covering_element;\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n-use ra_fmt::{leading_indent, reindent};\n use ra_ide_db::{\n     source_change::{SourceChange, SourceFileEdit},\n     RootDatabase,\n };\n use syntax::{\n     algo::{self, find_node_at_offset, SyntaxRewriter},\n-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxToken, TextRange, TextSize,\n     TokenAtOffset,\n };\n use text_edit::{TextEdit, TextEditBuilder};\n@@ -269,20 +268,6 @@ impl AssistBuilder {\n     pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n         algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n     }\n-    /// Replaces specified `node` of text with a given string, reindenting the\n-    /// string to maintain `node`'s existing indent.\n-    // FIXME: remove in favor of syntax::edit::IndentLevel::increase_indent\n-    pub(crate) fn replace_node_and_indent(\n-        &mut self,\n-        node: &SyntaxNode,\n-        replace_with: impl Into<String>,\n-    ) {\n-        let mut replace_with = replace_with.into();\n-        if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, &indent)\n-        }\n-        self.replace(node.text_range(), replace_with)\n-    }\n     pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n         let node = rewriter.rewrite_root().unwrap();\n         let new = rewriter.rewrite(&node);"}, {"sha": "be480943c549219f127cc5f082c6f8041e6d1764", "filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=b0f03db51dc84aac56c807ecf4da8151c01e3c04", "patch": "@@ -1,10 +1,12 @@\n+use std::iter;\n+\n use syntax::{\n-    ast::{self, BlockExpr, Expr, LoopBodyOwner},\n+    ast::{self, make, BlockExpr, Expr, LoopBodyOwner},\n     AstNode, SyntaxNode,\n };\n+use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n-use test_utils::mark;\n \n // Assist: change_return_type_to_result\n //\n@@ -44,7 +46,13 @@ pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContex\n             tail_return_expr_collector.collect_tail_exprs(block_expr);\n \n             for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n-                builder.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n+                let ok_wrapped = make::expr_call(\n+                    make::expr_path(make::path_unqualified(make::path_segment(make::name_ref(\n+                        \"Ok\",\n+                    )))),\n+                    make::arg_list(iter::once(ret_expr_arg.clone())),\n+                );\n+                builder.replace_ast(ret_expr_arg, ok_wrapped);\n             }\n \n             match ctx.config.snippet_cap {\n@@ -60,7 +68,7 @@ pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContex\n }\n \n struct TailReturnCollector {\n-    exprs_to_wrap: Vec<SyntaxNode>,\n+    exprs_to_wrap: Vec<ast::Expr>,\n }\n \n impl TailReturnCollector {\n@@ -86,7 +94,8 @@ impl TailReturnCollector {\n             if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n                 for last_expr in last_exprs {\n                     let last_expr = match last_expr {\n-                        NodeType::Node(expr) | NodeType::Leaf(expr) => expr,\n+                        NodeType::Node(expr) => expr,\n+                        NodeType::Leaf(expr) => expr.syntax().clone(),\n                     };\n \n                     if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n@@ -113,12 +122,12 @@ impl TailReturnCollector {\n             }\n             Expr::ReturnExpr(ret_expr) => {\n                 if let Some(ret_expr_arg) = &ret_expr.expr() {\n-                    self.exprs_to_wrap.push(ret_expr_arg.syntax().clone());\n+                    self.exprs_to_wrap.push(ret_expr_arg.clone());\n                 }\n             }\n             Expr::BreakExpr(break_expr) if collect_break => {\n                 if let Some(break_expr_arg) = &break_expr.expr() {\n-                    self.exprs_to_wrap.push(break_expr_arg.syntax().clone());\n+                    self.exprs_to_wrap.push(break_expr_arg.clone());\n                 }\n             }\n             Expr::IfExpr(if_expr) => {\n@@ -166,14 +175,11 @@ impl TailReturnCollector {\n                     NodeType::Leaf(expr) => {\n                         self.exprs_to_wrap.push(expr.clone());\n                     }\n-                    NodeType::Node(expr) => match &Expr::cast(expr.clone()) {\n-                        Some(last_expr) => {\n-                            self.fetch_tail_exprs(last_expr);\n-                        }\n-                        None => {\n-                            self.exprs_to_wrap.push(expr.clone());\n+                    NodeType::Node(expr) => {\n+                        if let Some(last_expr) = Expr::cast(expr.clone()) {\n+                            self.fetch_tail_exprs(&last_expr);\n                         }\n-                    },\n+                    }\n                 }\n             }\n         }\n@@ -182,7 +188,7 @@ impl TailReturnCollector {\n \n #[derive(Debug)]\n enum NodeType {\n-    Leaf(SyntaxNode),\n+    Leaf(ast::Expr),\n     Node(SyntaxNode),\n }\n \n@@ -233,25 +239,26 @@ fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n \n             Some(arms)\n         }\n-        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e.syntax().clone())]),\n+        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e)]),\n         Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n-        Expr::CallExpr(call_expr) => Some(vec![NodeType::Leaf(call_expr.syntax().clone())]),\n-        Expr::Literal(lit_expr) => Some(vec![NodeType::Leaf(lit_expr.syntax().clone())]),\n-        Expr::TupleExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::ArrayExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::ParenExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::PathExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RecordExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::IndexExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::MethodCallExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::AwaitExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::CastExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RefExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::PrefixExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RangeExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::BinExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::MacroCall(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::BoxExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+\n+        Expr::CallExpr(_)\n+        | Expr::Literal(_)\n+        | Expr::TupleExpr(_)\n+        | Expr::ArrayExpr(_)\n+        | Expr::ParenExpr(_)\n+        | Expr::PathExpr(_)\n+        | Expr::RecordExpr(_)\n+        | Expr::IndexExpr(_)\n+        | Expr::MethodCallExpr(_)\n+        | Expr::AwaitExpr(_)\n+        | Expr::CastExpr(_)\n+        | Expr::RefExpr(_)\n+        | Expr::PrefixExpr(_)\n+        | Expr::RangeExpr(_)\n+        | Expr::BinExpr(_)\n+        | Expr::MacroCall(_)\n+        | Expr::BoxExpr(_) => Some(vec![NodeType::Leaf(expr.clone())]),\n         _ => None,\n     }\n }"}, {"sha": "397a3c3ae0d80369bc7a29237f33a6ea7919e9cc", "filename": "crates/ra_fmt/src/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fra_fmt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fra_fmt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_fmt%2Fsrc%2Flib.rs?ref=b0f03db51dc84aac56c807ecf4da8151c01e3c04", "patch": "@@ -10,11 +10,6 @@ use syntax::{\n     SyntaxNode, SyntaxToken, T,\n };\n \n-pub fn reindent(text: &str, indent: &str) -> String {\n-    let indent = format!(\"\\n{}\", indent);\n-    text.lines().intersperse(&indent).collect()\n-}\n-\n /// If the node is on the beginning of the line, calculate indent.\n pub fn leading_indent(node: &SyntaxNode) -> Option<SmolStr> {\n     for token in prev_tokens(node.first_token()?) {"}, {"sha": "d20c085aa0a99eacc415f822d2a83a3f91c30752", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f03db51dc84aac56c807ecf4da8151c01e3c04/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=b0f03db51dc84aac56c807ecf4da8151c01e3c04", "patch": "@@ -134,6 +134,9 @@ pub fn expr_prefix(op: SyntaxKind, expr: ast::Expr) -> ast::Expr {\n     let token = token(op);\n     expr_from_text(&format!(\"{}{}\", token, expr))\n }\n+pub fn expr_call(f: ast::Expr, arg_list: ast::ArgList) -> ast::Expr {\n+    expr_from_text(&format!(\"{}{}\", f, arg_list))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -151,6 +154,10 @@ pub fn condition(expr: ast::Expr, pattern: Option<ast::Pat>) -> ast::Condition {\n     }\n }\n \n+pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {\n+    ast_from_text(&format!(\"fn main() {{ ()({}) }}\", args.into_iter().format(\", \")))\n+}\n+\n pub fn ident_pat(name: ast::Name) -> ast::IdentPat {\n     return from_text(name.text());\n "}]}