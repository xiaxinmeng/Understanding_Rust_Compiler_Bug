{"sha": "8ed5c0d37a79d22b919c969141f3453ade407ca1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZDVjMGQzN2E3OWQyMmI5MTljOTY5MTQxZjM0NTNhZGU0MDdjYTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-02T03:35:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-02T03:35:44Z"}, "message": "Rollup merge of #73345 - petrochenkov:nointerp, r=Aaron1011\n\nexpand: Stop using nonterminals for passing tokens to attribute and derive macros\n\nMake one more step towards fully token-based expansion and fix issues described in https://github.com/rust-lang/rust/issues/72545#issuecomment-640276791.\n\nNow `struct S;` is passed to `foo!(struct S;)` and `#[foo] struct S;` in the same way - as a token stream `struct S ;`, rather than a single non-terminal token `NtItem` which is then broken into parts later.\n\nThe cost is making pretty-printing of token streams less pretty.\nSome of the pretty-printing regressions will be recovered by keeping jointness with each token, which we will need to do anyway.\n\nUnfortunately, this is not exactly the same thing as https://github.com/rust-lang/rust/pull/73102.\nOne more observable effect is how `$crate` is printed in the attribute input.\nInside `NtItem` was printed as `crate` or `that_crate`, now as a part of a token stream it's printed as `$crate` (there are good reasons for these differences, see https://github.com/rust-lang/rust/pull/62393 and related PRs).\nThis may break old proc macros (custom derives) written before the main portion of the proc macro API (macros 1.2) was stabilized, those macros did `input.to_string()` and reparsed the result, now that result can contain `$crate` which cannot be reparsed.\n\nSo, I think we should do this regardless, but we need to run crater first.\nr? @Aaron1011", "tree": {"sha": "388fd6b4f3aa200b94c56711bdb4f09e33a542d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/388fd6b4f3aa200b94c56711bdb4f09e33a542d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ed5c0d37a79d22b919c969141f3453ade407ca1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/VYRCRBK7hj4Ov3rIwAAdHIIAGeAN4QTzubE1rSVvy8GNe/L\ntBTY7suRstGQbHFd/y7m9pJwuhbUMvyfOfzNBqXrRVgAFHN9Y3JpwdFCqMHkOoLc\n/ni8bMmn9UJXVcO/GKxo2rKOsYuXPo3H+FY22VPX/kG+Y+p1O5ryT0vViQsyAT0V\n/ra6/o1Ly/9+ChZoVgO3akisZ6/CZlEzm7bbXb+QR0US3pZ+4K6e0BAZ7Y4tVd2Z\nLzAH5rygQMjRzD8shnd5PMKyUfHGMFMqBjbRwDQEDDTZGRCqnUYZJYwmgSfXhxbd\n2uRrW+osz8Ivik6LQW+rXBKN2YZ8otsMVXLqaB6r8Bg1dhgEA3pYWDb6v7o+KsA=\n=CjUF\n-----END PGP SIGNATURE-----\n", "payload": "tree 388fd6b4f3aa200b94c56711bdb4f09e33a542d7\nparent 3d391d2a733404415010afadb4b0ffdf84c928a4\nparent eb4ba55055393961a51ae47fee1e734e095d91ef\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593660944 -0700\ncommitter GitHub <noreply@github.com> 1593660944 -0700\n\nRollup merge of #73345 - petrochenkov:nointerp, r=Aaron1011\n\nexpand: Stop using nonterminals for passing tokens to attribute and derive macros\n\nMake one more step towards fully token-based expansion and fix issues described in https://github.com/rust-lang/rust/issues/72545#issuecomment-640276791.\n\nNow `struct S;` is passed to `foo!(struct S;)` and `#[foo] struct S;` in the same way - as a token stream `struct S ;`, rather than a single non-terminal token `NtItem` which is then broken into parts later.\n\nThe cost is making pretty-printing of token streams less pretty.\nSome of the pretty-printing regressions will be recovered by keeping jointness with each token, which we will need to do anyway.\n\nUnfortunately, this is not exactly the same thing as https://github.com/rust-lang/rust/pull/73102.\nOne more observable effect is how `$crate` is printed in the attribute input.\nInside `NtItem` was printed as `crate` or `that_crate`, now as a part of a token stream it's printed as `$crate` (there are good reasons for these differences, see https://github.com/rust-lang/rust/pull/62393 and related PRs).\nThis may break old proc macros (custom derives) written before the main portion of the proc macro API (macros 1.2) was stabilized, those macros did `input.to_string()` and reparsed the result, now that result can contain `$crate` which cannot be reparsed.\n\nSo, I think we should do this regardless, but we need to run crater first.\nr? @Aaron1011\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ed5c0d37a79d22b919c969141f3453ade407ca1", "html_url": "https://github.com/rust-lang/rust/commit/8ed5c0d37a79d22b919c969141f3453ade407ca1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ed5c0d37a79d22b919c969141f3453ade407ca1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d391d2a733404415010afadb4b0ffdf84c928a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d391d2a733404415010afadb4b0ffdf84c928a4", "html_url": "https://github.com/rust-lang/rust/commit/3d391d2a733404415010afadb4b0ffdf84c928a4"}, {"sha": "eb4ba55055393961a51ae47fee1e734e095d91ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb4ba55055393961a51ae47fee1e734e095d91ef", "html_url": "https://github.com/rust-lang/rust/commit/eb4ba55055393961a51ae47fee1e734e095d91ef"}], "stats": {"total": 296, "additions": 152, "deletions": 144}, "files": [{"sha": "b812f2dadf6d40321e22740da1c7dad7047c3471", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -475,7 +475,7 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt, _), .. })) => match *nt {\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,"}, {"sha": "54f81ef106fe14e39424e5f26fcb4c74212aa43b", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -656,7 +656,7 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             *span = ident.span;\n             return; // Avoid visiting the span for the second time.\n         }\n-        token::Interpolated(nt, _) => {\n+        token::Interpolated(nt) => {\n             let mut nt = Lrc::make_mut(nt);\n             vis.visit_interpolated(&mut nt);\n         }"}, {"sha": "173ea5e48d682d54ca613282a8c2e4192c8969f0", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -11,7 +11,7 @@ use crate::tokenstream::TokenTree;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, Span, DUMMY_SP};\n use std::borrow::Cow;\n@@ -182,15 +182,6 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n-/// A hack used to pass AST fragments to attribute and derive macros\n-/// as a single nonterminal token instead of a token stream.\n-/// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n-pub enum FlattenGroup {\n-    Yes,\n-    No,\n-}\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n@@ -245,7 +236,7 @@ pub enum TokenKind {\n     /// treat regular and interpolated lifetime identifiers in the same way.\n     Lifetime(Symbol),\n \n-    Interpolated(Lrc<Nonterminal>, FlattenGroup),\n+    Interpolated(Lrc<Nonterminal>),\n \n     // Can be expanded into several tokens.\n     /// A doc comment.\n@@ -352,7 +343,7 @@ impl Token {\n     /// if they keep spans or perform edition checks.\n     pub fn uninterpolated_span(&self) -> Span {\n         match &self.kind {\n-            Interpolated(nt, _) => nt.span(),\n+            Interpolated(nt) => nt.span(),\n             _ => self.span,\n         }\n     }\n@@ -391,7 +382,7 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n@@ -417,7 +408,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n@@ -429,7 +420,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n                 _ => false,\n             },\n@@ -464,7 +455,7 @@ impl Token {\n         match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n-            Interpolated(ref nt, _) => match &**nt {\n+            Interpolated(ref nt) => match &**nt {\n                 NtLiteral(_) => true,\n                 NtExpr(e) => match &e.kind {\n                     ast::ExprKind::Lit(_) => true,\n@@ -485,7 +476,7 @@ impl Token {\n     // otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n-            Interpolated(nt, _) => match **nt {\n+            Interpolated(nt) => match **nt {\n                 NtIdent(ident, is_raw) => {\n                     Cow::Owned(Token::new(Ident(ident.name, is_raw), ident.span))\n                 }\n@@ -532,7 +523,7 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtPath(..) = **nt {\n                 return true;\n             }\n@@ -544,7 +535,7 @@ impl Token {\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtIdent(..) | NtBlock(_) = **nt {\n                 return true;\n             }\n@@ -555,7 +546,7 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtBlock(..) = **nt {\n                 return true;\n             }\n@@ -785,6 +776,26 @@ impl Nonterminal {\n             NtTT(tt) => tt.span(),\n         }\n     }\n+\n+    /// This nonterminal looks like some specific enums from\n+    /// `proc-macro-hack` and `procedural-masquerade` crates.\n+    /// We need to maintain some special pretty-printing behavior for them due to incorrect\n+    /// asserts in old versions of those crates and their wide use in the ecosystem.\n+    /// See issue #73345 for more details.\n+    /// FIXME(#73933): Remove this eventually.\n+    pub fn pretty_printing_compatibility_hack(&self) -> bool {\n+        if let NtItem(item) = self {\n+            let name = item.ident.name;\n+            if name == sym::ProceduralMasqueradeDummyType || name == sym::ProcMacroHack {\n+                if let ast::ItemKind::Enum(enum_def, _) = &item.kind {\n+                    if let [variant] = &*enum_def.variants {\n+                        return variant.ident.name == sym::Input;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n }\n \n impl PartialEq for Nonterminal {"}, {"sha": "4428d09902b92d6b8a3360e130737b33eb66b32d", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -205,7 +205,7 @@ impl Lit {\n                 token::Lit::new(token::Bool, name, None)\n             }\n             token::Literal(lit) => lit,\n-            token::Interpolated(ref nt, _) => {\n+            token::Interpolated(ref nt) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n                     if let ast::ExprKind::Lit(lit) = &expr.kind {\n                         return Ok(lit.clone());"}, {"sha": "0ad74a8e2056af20abd18b59e016941045fa7b92", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1027,7 +1027,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n-            token::Interpolated(nt, _) => {\n+            token::Interpolated(nt) => {\n                 let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n                 self.lower_token_stream(tts)\n             }"}, {"sha": "d7e816cec901ef8929dd88244313e53124750eb4", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -148,9 +148,14 @@ pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     printer.s.eof()\n }\n \n-// This makes comma-separated lists look slightly nicer,\n-// and also addresses a specific regression described in issue #63896.\n+// This makes printed token streams look slightly nicer,\n+// and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n+    if let TokenTree::Token(token) = prev {\n+        if let token::DocComment(s) = token.kind {\n+            return !s.as_str().starts_with(\"//\");\n+        }\n+    }\n     match tt {\n         TokenTree::Token(token) => match token.kind {\n             token::Comma => false,\n@@ -163,7 +168,14 @@ fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n             },\n             _ => true,\n         },\n-        _ => true,\n+        TokenTree::Delimited(_, DelimToken::Bracket, _) => match prev {\n+            TokenTree::Token(token) => match token.kind {\n+                token::Pound => false,\n+                _ => true,\n+            },\n+            _ => true,\n+        },\n+        TokenTree::Delimited(..) => true,\n     }\n }\n \n@@ -266,7 +278,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Shebang(s) => format!(\"/* shebang: {}*/\", s),\n         token::Unknown(s) => s.to_string(),\n \n-        token::Interpolated(ref nt, _) => nonterminal_to_string(nt),\n+        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n     }\n }\n "}, {"sha": "db9293bddeb7d446f6ba50e06d544fd6662ecbe4", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -4,14 +4,14 @@ use crate::module::DirectoryOwnership;\n use rustc_ast::ast::{self, Attribute, NodeId, PatKind};\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, FlattenGroup};\n-use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::{self, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n-use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n+use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit};\n use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition;\n@@ -120,10 +120,7 @@ impl Annotatable {\n         }\n     }\n \n-    crate fn into_tokens(self) -> TokenStream {\n-        // `Annotatable` can be converted into tokens directly, but we\n-        // are packing it into a nonterminal as a piece of AST to make\n-        // the produced token stream look nicer in pretty-printed form.\n+    crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n         let nt = match self {\n             Annotatable::Item(item) => token::NtItem(item),\n             Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n@@ -142,7 +139,7 @@ impl Annotatable {\n             | Annotatable::StructField(..)\n             | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n         };\n-        TokenTree::token(token::Interpolated(Lrc::new(nt), FlattenGroup::Yes), DUMMY_SP).into()\n+        nt_to_tokenstream(&nt, sess, DUMMY_SP)\n     }\n \n     pub fn expect_item(self) -> P<ast::Item> {\n@@ -374,7 +371,7 @@ where\n         impl MutVisitor for AvoidInterpolatedIdents {\n             fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n                 if let tokenstream::TokenTree::Token(token) = tt {\n-                    if let token::Interpolated(nt, _) = &token.kind {\n+                    if let token::Interpolated(nt) = &token.kind {\n                         if let token::NtIdent(ident, is_raw) = **nt {\n                             *tt = tokenstream::TokenTree::token(\n                                 token::Ident(ident.name, is_raw),"}, {"sha": "bd7a094c5e355737280dade8ea08d0a9748c6f39", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -705,7 +705,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let tokens = item.into_tokens();\n+                    let tokens = item.into_tokens(self.cx.parse_sess);\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");"}, {"sha": "3c15a81c67f6748af6fa10849c90916984e09d72", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -790,7 +790,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::block => match token.kind {\n             token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n                 | token::NtPat(_)\n                 | token::NtTy(_)\n@@ -804,7 +804,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::path | sym::meta => match token.kind {\n             token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n@@ -823,12 +823,12 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n             token::ModSep |                     // path\n             token::Lt |                         // path (UFCS constant)\n             token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt, _) => may_be_ident(nt),\n+            token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n         sym::lifetime => match token.kind {\n             token::Lifetime(_) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n                 _ => false,\n             },"}, {"sha": "e2d3d5c4d644e04076ac1fbb31ac672bdfa7f29e", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -4,7 +4,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n use rustc_ast::ast::MacCall;\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, FlattenGroup, NtTT, Token};\n+use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -240,10 +240,7 @@ pub(super) fn transcribe<'a>(\n                             result.push(tt.clone().into());\n                         } else {\n                             marker.visit_span(&mut sp);\n-                            let token = TokenTree::token(\n-                                token::Interpolated(nt.clone(), FlattenGroup::No),\n-                                sp,\n-                            );\n+                            let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n                     } else {"}, {"sha": "54012d62a72a7a54c68dade7752ae5c9724ea079", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -2,10 +2,11 @@ use crate::base::{self, *};\n use crate::proc_macro_server;\n \n use rustc_ast::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n-use rustc_ast::token::{self, FlattenGroup};\n-use rustc_ast::tokenstream::{self, TokenStream};\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, ErrorReported};\n+use rustc_parse::nt_to_tokenstream;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -102,8 +103,12 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        let token = token::Interpolated(Lrc::new(token::NtItem(item)), FlattenGroup::Yes);\n-        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n+        let item = token::NtItem(item);\n+        let input = if item.pretty_printing_compatibility_hack() {\n+            TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n+        } else {\n+            nt_to_tokenstream(&item, ecx.parse_sess, DUMMY_SP)\n+        };\n \n         let server = proc_macro_server::Rustc::new(ecx);\n         let stream = match self.client.run(&EXEC_STRATEGY, server, input) {"}, {"sha": "663bc508143d6748fa8fc9b3b288045976193d93", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1,7 +1,7 @@\n use crate::base::ExtCtxt;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, FlattenGroup};\n+use rustc_ast::token;\n use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use rustc_ast::util::comments;\n use rustc_ast_pretty::pprust;\n@@ -60,12 +60,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n-                return TokenTree::Group(Group {\n-                    delimiter,\n-                    stream: tts,\n-                    span,\n-                    flatten: FlattenGroup::No,\n-                });\n+                return TokenTree::Group(Group { delimiter, stream: tts, span, flatten: false });\n             }\n             tokenstream::TokenTree::Token(token) => token,\n         };\n@@ -172,21 +167,21 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     delimiter: Delimiter::Bracket,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten: FlattenGroup::No,\n+                    flatten: false,\n                 }));\n                 if style == ast::AttrStyle::Inner {\n                     stack.push(tt!(Punct::new('!', false)));\n                 }\n                 tt!(Punct::new('#', false))\n             }\n \n-            Interpolated(nt, flatten) => {\n+            Interpolated(nt) => {\n                 let stream = nt_to_tokenstream(&nt, sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten,\n+                    flatten: nt.pretty_printing_compatibility_hack(),\n                 })\n             }\n \n@@ -293,7 +288,7 @@ pub struct Group {\n     /// A hack used to pass AST fragments to attribute and derive macros\n     /// as a single nonterminal token instead of a token stream.\n     /// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-    flatten: FlattenGroup,\n+    flatten: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -453,7 +448,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n             // Such token needs to be \"unwrapped\" and not represented as a delimited group.\n             // FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n             if let TokenTree::Group(ref group) = tree {\n-                if matches!(group.flatten, FlattenGroup::Yes) {\n+                if group.flatten {\n                     iter.cursor.append(group.stream.clone());\n                     continue;\n                 }\n@@ -469,7 +464,7 @@ impl server::Group for Rustc<'_> {\n             delimiter,\n             stream,\n             span: DelimSpan::from_single(server::Span::call_site(self)),\n-            flatten: FlattenGroup::No,\n+            flatten: false,\n         }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> Delimiter {"}, {"sha": "803f14a2a228a6789915694fe27ee9ec38541dbb", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -155,7 +155,7 @@ impl<'a> Parser<'a> {\n     /// The delimiters or `=` are still put into the resulting token stream.\n     pub fn parse_attr_item(&mut self) -> PResult<'a, ast::AttrItem> {\n         let item = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n                 _ => None,\n             },\n@@ -254,7 +254,7 @@ impl<'a> Parser<'a> {\n     ///     meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n                 _ => None,\n             },"}, {"sha": "49a5c8801766c5521de580d6d8d170bbd52a81a2", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -26,7 +26,7 @@ use std::mem;\n /// `token::Interpolated` tokens.\n macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n-        if let token::Interpolated(nt, _) = &$p.token.kind {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n             match &**nt {\n                 token::NtExpr(e) | token::NtLiteral(e) => {\n                     let e = e.clone();"}, {"sha": "6f13d7994d17d257ec0fecb132f5d8baad5253cd", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1780,7 +1780,7 @@ impl<'a> Parser<'a> {\n \n     fn is_named_param(&self) -> bool {\n         let offset = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             },"}, {"sha": "7811d5fb741b27d946b6ce57c6856d8d2b4977d5", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -54,7 +54,7 @@ enum BlockMode {\n #[macro_export]\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n-        if let token::Interpolated(nt, _) = &$p.token.kind {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n             if let token::$constructor(x) = &**nt {\n                 let $x = x.clone();\n                 $p.bump();\n@@ -69,7 +69,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n-            if let token::Interpolated(nt, _) = &$self.token.kind {\n+            if let token::Interpolated(nt) = &$self.token.kind {\n                 if let token::NtTy(ty) = &**nt {\n                     let ty = ty.clone();\n                     $self.bump();\n@@ -922,7 +922,7 @@ impl<'a> Parser<'a> {\n                 if self.eat(&token::Eq) {\n                     let eq_span = self.prev_token.span;\n                     let mut is_interpolated_expr = false;\n-                    if let token::Interpolated(nt, _) = &self.token.kind {\n+                    if let token::Interpolated(nt) = &self.token.kind {\n                         if let token::NtExpr(..) = **nt {\n                             is_interpolated_expr = true;\n                         }"}, {"sha": "6603d0afc0248d6cf52ad3d147c3cf8a05d95d7d", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -515,7 +515,7 @@ impl<'a> Parser<'a> {\n         self.recover_additional_muts();\n \n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n-        if let token::Interpolated(ref nt, _) = self.token.kind {\n+        if let token::Interpolated(ref nt) = self.token.kind {\n             if let token::NtPat(_) = **nt {\n                 self.expected_ident_found().emit();\n             }"}, {"sha": "bca65c63e91986c476325156d3efa231869746e8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1325,7 +1325,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt, _) = t.kind {\n+        if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ast::ExprKind::MacCall(..) = expr.kind {\n                     self.visit_invoc(expr.id);"}, {"sha": "32af920020ce6438ea15b5761d08627042d9d6bb", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt, _) = t.kind {\n+        if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ExprKind::MacCall(..) = expr.kind {\n                     self.visit_macro_invoc(expr.id);"}, {"sha": "33f14e50edbf34282fa85aef1a11b854b879624f", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -401,6 +401,7 @@ symbols! {\n         infer_outlives_requirements,\n         infer_static_outlives_requirements,\n         inline,\n+        Input,\n         intel,\n         into_iter,\n         IntoIterator,\n@@ -589,6 +590,8 @@ symbols! {\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n+        ProceduralMasqueradeDummyType,\n+        ProcMacroHack,\n         profiler_builtins,\n         profiler_runtime,\n         ptr_guaranteed_eq,"}, {"sha": "66db1a21736659d15fd909df19c8a9e4b22f23b0", "filename": "src/test/run-make/rustc-macro-dep-files/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Frun-make%2Frustc-macro-dep-files%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Frun-make%2Frustc-macro-dep-files%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustc-macro-dep-files%2Ffoo.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -7,6 +7,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(A)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"struct A ;\"));\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "395d9e21b3848a1b953baf4ef1a5429f1a003242", "filename": "src/test/ui/async-await/issues/issue-60674.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.stdout?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1,3 +1,3 @@\n-async fn f(mut x: u8) { }\n-async fn g((mut x, y, mut z): (u8, u8, u8)) { }\n-async fn g(mut x: u8, (a, mut b, c): (u8, u8, u8), y: u8) { }\n+async fn f(mut x : u8) { }\n+async fn g((mut x, y, mut z) : (u8, u8, u8)) { }\n+async fn g(mut x : u8, (a, mut b, c) : (u8, u8, u8), y : u8) { }"}, {"sha": "2f0054cc14aa6454005f2889292acc42824b2c9f", "filename": "src/test/ui/proc-macro/auxiliary/attr-cfg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -11,11 +11,9 @@ use proc_macro::TokenStream;\n pub fn attr_cfg(args: TokenStream, input: TokenStream) -> TokenStream {\n     let input_str = input.to_string();\n \n-    assert_eq!(input_str, \"fn outer() -> u8 {\n-    #[cfg(foo)]\n-    fn inner() -> u8 { 1 }\n-    #[cfg(bar)]\n-    fn inner() -> u8 { 2 }\n+    assert_eq!(input_str, \"fn outer() -> u8\n+{\n+    #[cfg(foo)] fn inner() -> u8 { 1 } #[cfg(bar)] fn inner() -> u8 { 2 }\n     inner()\n }\");\n "}, {"sha": "e056bd32d2d0e9c0045e0dcb8e0fc81460963175", "filename": "src/test/ui/proc-macro/auxiliary/attr-stmt-expr-rpass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr-rpass.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,14 +10,14 @@ use proc_macro::TokenStream;\n #[proc_macro_attribute]\n pub fn expect_let(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\";\");\n+    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\" ;\");\n     item\n }\n \n #[proc_macro_attribute]\n pub fn expect_print_stmt(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string);\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string) ;\");\n     item\n }\n \n@@ -31,7 +31,7 @@ pub fn expect_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n #[proc_macro_attribute]\n pub fn expect_print_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string)\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string)\");\n     item\n }\n "}, {"sha": "213f999e9d0eaa080783f80d99fec8f9258ddcda", "filename": "src/test/ui/proc-macro/auxiliary/attr-stmt-expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,14 +10,14 @@ use proc_macro::TokenStream;\n #[proc_macro_attribute]\n pub fn expect_let(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\";\");\n+    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\" ;\");\n     item\n }\n \n #[proc_macro_attribute]\n pub fn expect_print_stmt(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string);\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string) ;\");\n     item\n }\n \n@@ -31,7 +31,7 @@ pub fn expect_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n #[proc_macro_attribute]\n pub fn expect_print_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string)\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string)\");\n     item\n }\n "}, {"sha": "79a3864bf991d8f31144a71b6fae5ca299853e99", "filename": "src/test/ui/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,6 +10,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(A)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"struct A ;\"));\n     \"\".parse().unwrap()\n }"}, {"sha": "207b7fd3203601eb7fee5be0deb814aaf24fe870", "filename": "src/test/ui/proc-macro/auxiliary/derive-atob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,6 +10,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"struct A;\");\n+    assert_eq!(input, \"struct A ;\");\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "641a95f78c112a92d66c81388ca45ce88f4e1e5b", "filename": "src/test/ui/proc-macro/auxiliary/derive-b-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-b-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-b-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-b-rpass.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,7 +10,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(B, attributes(B, C))]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"#[B[arbitrary tokens]]\"));\n+    assert!(input.contains(\"#[B [arbitrary tokens]]\"));\n     assert!(input.contains(\"struct B {\"));\n     assert!(input.contains(\"#[C]\"));\n     \"\".parse().unwrap()"}, {"sha": "2efe5a9134054de27130795bb380866ad91e49d6", "filename": "src/test/ui/proc-macro/auxiliary/derive-ctod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,6 +10,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(CToD)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"struct C;\");\n+    assert_eq!(input, \"struct C ;\");\n     \"struct D;\".parse().unwrap()\n }"}, {"sha": "7598d632cb6d57f396db1019b5e8784ed73b2b98", "filename": "src/test/ui/proc-macro/auxiliary/derive-same-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -10,12 +10,12 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive1(input: TokenStream) -> TokenStream {\n     println!(\"input1: {:?}\", input.to_string());\n-    assert_eq!(input.to_string(), \"struct A;\");\n+    assert_eq!(input.to_string(), \"struct A ;\");\n     \"#[derive(BToC)] struct B;\".parse().unwrap()\n }\n \n #[proc_macro_derive(BToC)]\n pub fn derive2(input: TokenStream) -> TokenStream {\n-    assert_eq!(input.to_string(), \"struct B;\");\n+    assert_eq!(input.to_string(), \"struct B ;\");\n     \"struct C;\".parse().unwrap()\n }"}, {"sha": "05883170c6c48006c771e8e4b327272a9c90f1ba", "filename": "src/test/ui/proc-macro/auxiliary/derive-union.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-union.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -12,7 +12,7 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"#[repr(C)]\"));\n     assert!(input.contains(\"union Test {\"));\n-    assert!(input.contains(\"a: u8,\"));\n+    assert!(input.contains(\"a : u8,\"));\n     assert!(input.contains(\"}\"));\n     \"\".parse().unwrap()\n }"}, {"sha": "99eb4e3754672e05e01b48f86eade2eb5aaf8e59", "filename": "src/test/ui/proc-macro/auxiliary/double.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdouble.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdouble.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdouble.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1,15 +1,16 @@\n // force-host\n // no-prefer-dynamic\n \n+#![feature(proc_macro_quote)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n+use proc_macro::*;\n \n // Outputs another copy of the struct.  Useful for testing the tokens\n // seen by the proc_macro.\n #[proc_macro_derive(Double)]\n pub fn derive(input: TokenStream) -> TokenStream {\n-    format!(\"mod foo {{ {} }}\", input.to_string()).parse().unwrap()\n+    quote!(mod foo { $input })\n }"}, {"sha": "d779d57af14c7a12ccde94871c96176a69cad71e", "filename": "src/test/ui/proc-macro/auxiliary/expand-with-a-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -11,7 +11,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(A)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"struct A ;\"));\n     r#\"\n         impl A {\n             fn a(&self) {"}, {"sha": "7478d9741409bb8e6f52896bfa41a2831e8df69c", "filename": "src/test/ui/proc-macro/derive-same-struct.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fderive-same-struct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fderive-same-struct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-same-struct.stdout?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1 +1 @@\n-input1: \"struct A;\"\n+input1: \"struct A ;\""}, {"sha": "5d93144b445530ddf79b355c2ca14a278179ebd2", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -38,8 +38,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A($crate :: S) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "e4212377626ca7fdccc575b5388a59ac039dee1c", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -1,5 +1,4 @@\n-PRINT-ATTR INPUT (DISPLAY): struct A(identity!(crate :: S));\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A(identity ! ($crate :: S)) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A(identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -54,8 +53,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct B(identity ! ($crate :: S)) ;\n+PRINT-ATTR INPUT (DISPLAY): struct B(identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "8a7406b1a3d134350ed110566dc505911311d0dc", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -38,8 +38,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A($crate :: S) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -79,8 +78,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D($crate :: S) ;\n+PRINT-DERIVE INPUT (DISPLAY): struct D($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -160,8 +158,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #13 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A($crate :: S) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -201,8 +198,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #13 bytes(LO..HI),\n     },\n ]\n-PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D($crate :: S) ;\n+PRINT-DERIVE INPUT (DISPLAY): struct D($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "72e40b8a33e0bd4f393c1634e8726adf7618de3c", "filename": "src/test/ui/proc-macro/input-interpolated.stdout", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Finput-interpolated.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Fproc-macro%2Finput-interpolated.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finput-interpolated.stdout?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -12,8 +12,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #3 bytes(269..271),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): const A: u8 = 0;\n-PRINT-ATTR RE-COLLECTED (DISPLAY): const A : u8 = 0 ;\n+PRINT-ATTR INPUT (DISPLAY): const A : u8 = 0 ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"const\",\n@@ -49,9 +48,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #0 bytes(0..0),\n     },\n ]\n-PRINT-DERIVE INPUT (DISPLAY): struct A {\n-}\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct A { }\n+PRINT-DERIVE INPUT (DISPLAY): struct A { }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "2a172c8458d71462493c1cb4a7b26d03c3e231b2", "filename": "src/test/ui/rfc-2565-param-attrs/auxiliary/param-attrs.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ed5c0d37a79d22b919c969141f3453ade407ca1/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs?ref=8ed5c0d37a79d22b919c969141f3453ade407ca1", "patch": "@@ -17,28 +17,27 @@ macro_rules! checker {\n     }\n }\n \n-checker!(attr_extern, r#\"extern \"C\" {\n-    fn ffi(#[a1] arg1: i32, #[a2] ...);\n-}\"#);\n-checker!(attr_extern_cvar, r#\"unsafe extern \"C\" fn cvar(arg1: i32, #[a1] mut args: ...) { }\"#);\n-checker!(attr_alias, \"type Alias = fn(#[a1] u8, #[a2] ...);\");\n-checker!(attr_free, \"fn free(#[a1] arg1: u8) { let lam = |#[a2] W(x), #[a3] y| (); }\");\n-checker!(attr_inherent_1, \"fn inherent1(#[a1] self, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_2, \"fn inherent2(#[a1] &self, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_3, \"fn inherent3<'a>(#[a1] &'a mut self, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_4, \"fn inherent4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_issue_64682, \"fn inherent5(#[a1] #[a2] arg1: u8, #[a3] arg2: u8) { }\");\n-checker!(attr_trait_1, \"fn trait1(#[a1] self, #[a2] arg1: u8);\");\n-checker!(attr_trait_2, \"fn trait2(#[a1] &self, #[a2] arg1: u8);\");\n-checker!(attr_trait_3, \"fn trait3<'a>(#[a1] &'a mut self, #[a2] arg1: u8);\");\n-checker!(attr_trait_4, \"fn trait4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8, #[a3] Vec<u8>);\");\n-checker!(attr_trait_issue_64682, \"fn trait5(#[a1] #[a2] arg1: u8, #[a3] arg2: u8);\");\n-checker!(rename_params, r#\"impl Foo {\n-    fn hello(#[angery(true)] a: i32, #[a2] b: i32, #[what = \"how\"] c: u32) { }\n-    fn hello2(#[a1] #[a2] a: i32, #[what = \"how\"] b: i32,\n-              #[angery(true)] c: u32) {\n-    }\n-    fn hello_self(#[a1] #[a2] &self, #[a1] #[a2] a: i32,\n-                  #[what = \"how\"] b: i32, #[angery(true)] c: u32) {\n-    }\n+checker!(attr_extern, r#\"extern \"C\" { fn ffi(#[a1] arg1 : i32, #[a2] ...) ; }\"#);\n+checker!(attr_extern_cvar, r#\"unsafe extern \"C\" fn cvar(arg1 : i32, #[a1] mut args : ...) { }\"#);\n+checker!(attr_alias, \"type Alias = fn(#[a1] u8, #[a2] ...) ;\");\n+checker!(attr_free, \"fn free(#[a1] arg1 : u8) { let lam = | #[a2] W(x), #[a3] y | () ; }\");\n+checker!(attr_inherent_1, \"fn inherent1(#[a1] self, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_2, \"fn inherent2(#[a1] & self, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_3, \"fn inherent3 < 'a > (#[a1] & 'a mut self, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_4, \"fn inherent4 < 'a > (#[a1] self : Box < Self >, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_issue_64682, \"fn inherent5(#[a1] #[a2] arg1 : u8, #[a3] arg2 : u8) { }\");\n+checker!(attr_trait_1, \"fn trait1(#[a1] self, #[a2] arg1 : u8) ;\");\n+checker!(attr_trait_2, \"fn trait2(#[a1] & self, #[a2] arg1 : u8) ;\");\n+checker!(attr_trait_3, \"fn trait3 < 'a > (#[a1] & 'a mut self, #[a2] arg1 : u8) ;\");\n+checker!(attr_trait_4, r#\"fn trait4 < 'a >\n+(#[a1] self : Box < Self >, #[a2] arg1 : u8, #[a3] Vec < u8 >) ;\"#);\n+checker!(attr_trait_issue_64682, \"fn trait5(#[a1] #[a2] arg1 : u8, #[a3] arg2 : u8) ;\");\n+checker!(rename_params, r#\"impl Foo\n+{\n+    fn hello(#[angery(true)] a : i32, #[a2] b : i32, #[what = \"how\"] c : u32)\n+    { } fn\n+    hello2(#[a1] #[a2] a : i32, #[what = \"how\"] b : i32, #[angery(true)] c :\n+           u32) { } fn\n+    hello_self(#[a1] #[a2] & self, #[a1] #[a2] a : i32, #[what = \"how\"] b :\n+               i32, #[angery(true)] c : u32) { }\n }\"#);"}]}