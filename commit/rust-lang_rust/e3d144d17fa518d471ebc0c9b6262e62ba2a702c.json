{"sha": "e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "node_id": "C_kwDOAAsO6NoAKGUzZDE0NGQxN2ZhNTE4ZDQ3MWViYzBjOWI2MjYyZTYyYmEyYTcwMmM", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-12-31T13:20:59Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-12-31T13:20:59Z"}, "message": "Diagnose private field accesses", "tree": {"sha": "916abd5d9b93c107ebae30824def48eeb0544297", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/916abd5d9b93c107ebae30824def48eeb0544297"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "html_url": "https://github.com/rust-lang/rust/commit/e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec125fe46af50a552b1045da1a1f1c5b08b2ade2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec125fe46af50a552b1045da1a1f1c5b08b2ade2", "html_url": "https://github.com/rust-lang/rust/commit/ec125fe46af50a552b1045da1a1f1c5b08b2ade2"}], "stats": {"total": 97, "additions": 86, "deletions": 11}, "files": [{"sha": "e38c2154413b76875a8c1afa6d91dd347128a7ce", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "patch": "@@ -208,6 +208,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n+    PrivateField { expr: ExprId, field: FieldId },\n     BreakOutsideOfLoop { expr: ExprId, is_break: bool },\n     MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }"}, {"sha": "4881e7c8fc72a5b38bb55c434273cd5ddab4ea3a", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "patch": "@@ -1,7 +1,6 @@\n //! Type inference for expressions.\n \n use std::{\n-    collections::hash_map::Entry,\n     iter::{repeat, repeat_with},\n     mem,\n };\n@@ -521,6 +520,7 @@ impl<'a> InferenceContext<'a> {\n                 let receiver_ty = self.infer_expr_inner(*expr, &Expectation::none());\n \n                 let mut autoderef = Autoderef::new(&mut self.table, receiver_ty);\n+                let mut private_field = None;\n                 let ty = autoderef.by_ref().find_map(|(derefed_ty, _)| {\n                     let (field_id, parameters) = match derefed_ty.kind(Interner) {\n                         TyKind::Tuple(_, substs) => {\n@@ -547,13 +547,8 @@ impl<'a> InferenceContext<'a> {\n                     let is_visible = self.db.field_visibilities(field_id.parent)[field_id.local_id]\n                         .is_visible_from(self.db.upcast(), self.resolver.module());\n                     if !is_visible {\n-                        // Write down the first field resolution even if it is not visible\n-                        // This aids IDE features for private fields like goto def and in\n-                        // case of autoderef finding an applicable field, this will be\n-                        // overwritten in a following cycle\n-                        if let Entry::Vacant(entry) = self.result.field_resolutions.entry(tgt_expr)\n-                        {\n-                            entry.insert(field_id);\n+                        if private_field.is_none() {\n+                            private_field = Some(field_id);\n                         }\n                         return None;\n                     }\n@@ -572,7 +567,17 @@ impl<'a> InferenceContext<'a> {\n                         let ty = self.normalize_associated_types_in(ty);\n                         ty\n                     }\n-                    _ => self.err_ty(),\n+                    _ => {\n+                        // Write down the first private field resolution if we found no field\n+                        // This aids IDE features for private fields like goto def\n+                        if let Some(field) = private_field {\n+                            self.result.field_resolutions.insert(tgt_expr, field);\n+                            self.result\n+                                .diagnostics\n+                                .push(InferenceDiagnostic::PrivateField { expr: tgt_expr, field });\n+                        }\n+                        self.err_ty()\n+                    }\n                 };\n                 ty\n             }"}, {"sha": "baeb525effe44e4f80aa39084eb230a2f83a4961", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "patch": "@@ -10,7 +10,7 @@ use hir_def::path::ModPath;\n use hir_expand::{name::Name, HirFileId, InFile};\n use syntax::{ast, AstPtr, SyntaxNodePtr, TextRange};\n \n-use crate::{MacroKind, Type};\n+use crate::{Field, MacroKind, Type};\n \n macro_rules! diagnostics {\n     ($($diag:ident,)*) => {\n@@ -41,6 +41,7 @@ diagnostics![\n     MissingMatchArms,\n     MissingUnsafe,\n     NoSuchField,\n+    PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n     UnimplementedBuiltinMacro,\n@@ -121,6 +122,12 @@ pub struct NoSuchField {\n     pub field: InFile<AstPtr<ast::RecordExprField>>,\n }\n \n+#[derive(Debug)]\n+pub struct PrivateField {\n+    pub expr: InFile<AstPtr<ast::Expr>>,\n+    pub field: Field,\n+}\n+\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "e8e623e7d61afa938b4ccb1a69a8e54b3506d60a", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "patch": "@@ -85,7 +85,7 @@ pub use crate::{\n     diagnostics::{\n         AnyDiagnostic, BreakOutsideOfLoop, InactiveCode, IncorrectCase, InvalidDeriveTarget,\n         MacroError, MalformedDerive, MismatchedArgCount, MissingFields, MissingMatchArms,\n-        MissingUnsafe, NoSuchField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n+        MissingUnsafe, NoSuchField, PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch,\n         UnimplementedBuiltinMacro, UnresolvedExternCrate, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedModule, UnresolvedProcMacro,\n     },\n@@ -1353,6 +1353,11 @@ impl DefWithBody {\n                         Err(SyntheticSyntax) => (),\n                     }\n                 }\n+                &hir_ty::InferenceDiagnostic::PrivateField { expr, field } => {\n+                    let expr = source_map.expr_syntax(expr).expect(\"unexpected synthetic\");\n+                    let field = field.into();\n+                    acc.push(PrivateField { expr, field }.into())\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {"}, {"sha": "3db5eca07bfc9c3d1305a8f5f0c1fef1f565ab3d", "filename": "crates/ide-diagnostics/src/handlers/private_field.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs?ref=e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "patch": "@@ -0,0 +1,55 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: private-field\n+//\n+// This diagnostic is triggered if created structure does not have field provided in record.\n+pub(crate) fn private_field(ctx: &DiagnosticsContext<'_>, d: &hir::PrivateField) -> Diagnostic {\n+    // FIXME: add quickfix\n+    Diagnostic::new(\n+        \"private-field\",\n+        format!(\n+            \"field `{}` of `{}` is private\",\n+            d.field.name(ctx.sema.db),\n+            d.field.parent_def(ctx.sema.db).name(ctx.sema.db)\n+        ),\n+        ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn private_field() {\n+        check_diagnostics(\n+            r#\"\n+mod module { pub struct Struct { field: u32 } }\n+fn main(s: module::Struct) {\n+    s.field;\n+  //^^^^^^^ error: field `field` of `Struct` is private\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn private_but_shadowed_in_deref() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: deref\n+mod module {\n+    pub struct Struct { field: Inner }\n+    pub struct Inner { pub field: u32 }\n+    impl core::ops::Deref for Struct {\n+        type Target = Inner;\n+        fn deref(&self) -> &Inner { &self.field }\n+    }\n+}\n+fn main(s: module::Struct) {\n+    s.field;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "91555e01b9caa6378fc5d2a6758c5d1e05e46f37", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3d144d17fa518d471ebc0c9b6262e62ba2a702c/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=e3d144d17fa518d471ebc0c9b6262e62ba2a702c", "patch": "@@ -37,6 +37,7 @@ mod handlers {\n     pub(crate) mod missing_match_arms;\n     pub(crate) mod missing_unsafe;\n     pub(crate) mod no_such_field;\n+    pub(crate) mod private_field;\n     pub(crate) mod replace_filter_map_next_with_find_map;\n     pub(crate) mod type_mismatch;\n     pub(crate) mod unimplemented_builtin_macro;\n@@ -254,6 +255,7 @@ pub fn diagnostics(\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::PrivateField(d) => handlers::private_field::private_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),"}]}