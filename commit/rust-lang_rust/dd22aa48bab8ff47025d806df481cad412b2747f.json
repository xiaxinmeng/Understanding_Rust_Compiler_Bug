{"sha": "dd22aa48bab8ff47025d806df481cad412b2747f", "node_id": "C_kwDOAAsO6NoAKGRkMjJhYTQ4YmFiOGZmNDcwMjVkODA2ZGY0ODFjYWQ0MTJiMjc0N2Y", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-08-20T11:12:23Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-08-21T09:41:46Z"}, "message": "Consider bounds on inherent impl in method resolution", "tree": {"sha": "92b2d2634a8363034b34de10b7eed25d64f1e5f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92b2d2634a8363034b34de10b7eed25d64f1e5f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd22aa48bab8ff47025d806df481cad412b2747f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmMB/d4ACgkQ4laYqTBY\nYXGMxxAAm5fNGNLv4pCzixugsb6pxz/0NYAwIZyqTyxXmo38ijdgZun5L3k6vkeS\nN7MvcIJeEicsfcxkXLS9/b7CpRcI3hRZwKOSL8GWUp0gBxn5hddLBIOi4TIqEJ3B\n8AygqMqutE2d8uOy7Y4ImZg0z53lN67HniIuB+//ygtgMrUdal3AI0aAuWNBPoCi\nBd0lgXLiiBFVoWMiEN7ug1CjBhWKS7j364tDU+nyIM07X91TPkDsTwfLBwBHIE6y\nobt1jJdXWH58qxzXxIgC1Pb99X2WBxnmItWpwLrt8E5FLTDhcUCd/De/yrtrPoFX\nNpV4tKWE2hKz0Gd8ye+ryiIjBr0hBDq3mHvAA/S1yi5/PZANTfmTqtc71+TK3xtB\n5FP8EO9SPvdFzTwKSHhp/c7s+pmWYSyyMyDKviN7iems8WZqbwNWVe6Ug/sX2spw\nvbj7SHdNwOpjUbgLZIheAW2CVDWEjo3r6Pt4RdYV11N5J8zkk7tNr3UYoMAu9xn/\nzuoyD9ObVk+0FQHHqh5t7sQ2nP2sqy7gW58qyB0pq3En+RVAcl0nnqA9XgGFdrlt\n9tUVr2YoJi8WeawBsiLNHs73WY4x4KGSYw9iSeuGxOmo8njI/KsNXn4UIvx5GSKN\nRoZSwgSCRjFDqE5n6WqsKLve52dNKjwXk5bGiDuny0wUnTZGYRQ=\n=D2/J\n-----END PGP SIGNATURE-----", "payload": "tree 92b2d2634a8363034b34de10b7eed25d64f1e5f9\nparent 099f911b4ac0ebf5c375215b030ebf8800630bbb\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1660993943 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1661074906 +0900\n\nConsider bounds on inherent impl in method resolution\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd22aa48bab8ff47025d806df481cad412b2747f", "html_url": "https://github.com/rust-lang/rust/commit/dd22aa48bab8ff47025d806df481cad412b2747f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd22aa48bab8ff47025d806df481cad412b2747f/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "099f911b4ac0ebf5c375215b030ebf8800630bbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/099f911b4ac0ebf5c375215b030ebf8800630bbb", "html_url": "https://github.com/rust-lang/rust/commit/099f911b4ac0ebf5c375215b030ebf8800630bbb"}], "stats": {"total": 185, "additions": 140, "deletions": 45}, "files": [{"sha": "9a63d5013b4671274e8c93747049a5aa11fd33c7", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 97, "deletions": 45, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/dd22aa48bab8ff47025d806df481cad412b2747f/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd22aa48bab8ff47025d806df481cad412b2747f/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=dd22aa48bab8ff47025d806df481cad412b2747f", "patch": "@@ -1064,6 +1064,14 @@ pub fn resolve_indexing_op(\n     None\n }\n \n+macro_rules! check_that {\n+    ($cond:expr) => {\n+        if !$cond {\n+            return false;\n+        }\n+    };\n+}\n+\n fn is_valid_candidate(\n     table: &mut InferenceTable<'_>,\n     name: Option<&Name>,\n@@ -1072,54 +1080,10 @@ fn is_valid_candidate(\n     self_ty: &Ty,\n     visible_from_module: Option<ModuleId>,\n ) -> bool {\n-    macro_rules! check_that {\n-        ($cond:expr) => {\n-            if !$cond {\n-                return false;\n-            }\n-        };\n-    }\n-\n     let db = table.db;\n     match item {\n         AssocItemId::FunctionId(m) => {\n-            let data = db.function_data(m);\n-\n-            check_that!(name.map_or(true, |n| n == &data.name));\n-            check_that!(visible_from_module.map_or(true, |from_module| {\n-                let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n-                if !v {\n-                    cov_mark::hit!(autoderef_candidate_not_visible);\n-                }\n-                v\n-            }));\n-\n-            table.run_in_snapshot(|table| {\n-                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-                let expect_self_ty = match m.lookup(db.upcast()).container {\n-                    ItemContainerId::TraitId(_) => {\n-                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n-                    }\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-                    }\n-                    // We should only get called for associated items (impl/trait)\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        unreachable!()\n-                    }\n-                };\n-                check_that!(table.unify(&expect_self_ty, self_ty));\n-                if let Some(receiver_ty) = receiver_ty {\n-                    check_that!(data.has_self_param());\n-\n-                    let sig = db.callable_item_signature(m.into());\n-                    let expected_receiver =\n-                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-\n-                    check_that!(table.unify(&receiver_ty, &expected_receiver));\n-                }\n-                true\n-            })\n+            is_valid_fn_candidate(table, m, name, receiver_ty, self_ty, visible_from_module)\n         }\n         AssocItemId::ConstId(c) => {\n             let data = db.const_data(c);\n@@ -1152,6 +1116,94 @@ fn is_valid_candidate(\n     }\n }\n \n+fn is_valid_fn_candidate(\n+    table: &mut InferenceTable<'_>,\n+    fn_id: FunctionId,\n+    name: Option<&Name>,\n+    receiver_ty: Option<&Ty>,\n+    self_ty: &Ty,\n+    visible_from_module: Option<ModuleId>,\n+) -> bool {\n+    let db = table.db;\n+    let data = db.function_data(fn_id);\n+\n+    check_that!(name.map_or(true, |n| n == &data.name));\n+    check_that!(visible_from_module.map_or(true, |from_module| {\n+        let v = db.function_visibility(fn_id).is_visible_from(db.upcast(), from_module);\n+        if !v {\n+            cov_mark::hit!(autoderef_candidate_not_visible);\n+        }\n+        v\n+    }));\n+\n+    table.run_in_snapshot(|table| {\n+        let container = fn_id.lookup(db.upcast()).container;\n+        let impl_subst = match container {\n+            ItemContainerId::ImplId(it) => {\n+                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+            }\n+            ItemContainerId::TraitId(it) => {\n+                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+            }\n+            _ => unreachable!(),\n+        };\n+\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n+            .use_parent_substs(&impl_subst)\n+            .fill_with_inference_vars(table)\n+            .build();\n+\n+        let expect_self_ty = match container {\n+            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n+            ItemContainerId::ImplId(impl_id) => {\n+                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+            }\n+            // We should only get called for associated items (impl/trait)\n+            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                unreachable!()\n+            }\n+        };\n+        check_that!(table.unify(&expect_self_ty, self_ty));\n+\n+        if let Some(receiver_ty) = receiver_ty {\n+            check_that!(data.has_self_param());\n+\n+            let sig = db.callable_item_signature(fn_id.into());\n+            let expected_receiver =\n+                sig.map(|s| s.params()[0].clone()).substitute(Interner, &fn_subst);\n+\n+            check_that!(table.unify(&receiver_ty, &expected_receiver));\n+        }\n+\n+        if let ItemContainerId::ImplId(impl_id) = container {\n+            // We need to consider the bounds on the impl to distinguish functions of the same name\n+            // for a type.\n+            let predicates = db.generic_predicates(impl_id.into());\n+            predicates\n+                .iter()\n+                .map(|predicate| {\n+                    let (p, b) = predicate\n+                        .clone()\n+                        .substitute(Interner, &impl_subst)\n+                        // Skipping the inner binders is ok, as we don't handle quantified where\n+                        // clauses yet.\n+                        .into_value_and_skipped_binders();\n+                    stdx::always!(b.len(Interner) == 0);\n+                    p\n+                })\n+                // It's ok to get ambiguity here, as we may not have enough information to prove\n+                // obligations. We'll check if the user is calling the selected method properly\n+                // later anyway.\n+                .all(|p| table.try_obligation(p.cast(Interner)).is_some())\n+        } else {\n+            // For `ItemContainerId::TraitId`, we check if `self_ty` implements the trait in\n+            // `iterate_trait_method_candidates()`.\n+            // For others, this function shouldn't be called.\n+            true\n+        }\n+    })\n+}\n+\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "81588a7c4ffd668bb6ccfb92f65e3628b09cb5a7", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dd22aa48bab8ff47025d806df481cad412b2747f/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd22aa48bab8ff47025d806df481cad412b2747f/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=dd22aa48bab8ff47025d806df481cad412b2747f", "patch": "@@ -1790,3 +1790,46 @@ impl u16 {\n         \"#,\n     )\n }\n+\n+#[test]\n+fn with_impl_bounds() {\n+    check_types(\n+        r#\"\n+trait Trait {}\n+struct Foo<T>(T);\n+impl Trait for isize {}\n+\n+impl<T: Trait> Foo<T> {\n+  fn foo() -> isize { 0 }\n+  fn bar(&self) -> isize { 0 }\n+}\n+\n+impl Foo<()> {\n+  fn foo() {}\n+  fn bar(&self) {}\n+}\n+\n+fn f() {\n+  let _ = Foo::<isize>::foo();\n+    //^isize\n+  let _ = Foo(0isize).bar();\n+    //^isize\n+  let _ = Foo::<()>::foo();\n+    //^()\n+  let _ = Foo(()).bar();\n+    //^()\n+  let _ = Foo::<usize>::foo();\n+    //^{unknown}\n+  let _ = Foo(0usize).bar();\n+    //^{unknown}\n+}\n+\n+fn g<T: Trait>(a: T) {\n+    let _ = Foo::<T>::foo();\n+      //^isize\n+    let _ = Foo(a).bar();\n+      //^isize\n+}\n+        \"#,\n+    );\n+}"}]}