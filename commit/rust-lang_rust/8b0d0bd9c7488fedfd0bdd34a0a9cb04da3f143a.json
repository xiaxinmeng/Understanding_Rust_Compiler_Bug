{"sha": "8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiMGQwYmQ5Yzc0ODhmZWRmZDBiZGQzNGEwYTljYjA0ZGEzZjE0M2E=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-23T18:19:44Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-23T18:57:04Z"}, "message": "Show item info when hovering intra doc links", "tree": {"sha": "755b2f33124306b9ae9ad658da66b543806928eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/755b2f33124306b9ae9ad658da66b543806928eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "html_url": "https://github.com/rust-lang/rust/commit/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "065a8e87cd015ccfe5c01ad6b603f4fdad18f768", "url": "https://api.github.com/repos/rust-lang/rust/commits/065a8e87cd015ccfe5c01ad6b603f4fdad18f768", "html_url": "https://github.com/rust-lang/rust/commit/065a8e87cd015ccfe5c01ad6b603f4fdad18f768"}], "stats": {"total": 303, "additions": 175, "deletions": 128}, "files": [{"sha": "5cd186565e3c0205bad25dcde91a9e5bf59b25f2", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "patch": "@@ -50,16 +50,16 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n     for (file_id, references) in refs.references {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n-        for (r_range, _) in references {\n-            let token = file.token_at_offset(r_range.start()).next()?;\n+        for (relative_range, token) in references\n+            .into_iter()\n+            .filter_map(|(range, _)| Some(range).zip(file.token_at_offset(range.start()).next()))\n+        {\n             let token = sema.descend_into_macros(token);\n             // This target is the containing function\n             if let Some(nav) = token.ancestors().find_map(|node| {\n-                let fn_ = ast::Fn::cast(node)?;\n-                let def = sema.to_def(&fn_)?;\n+                let def = ast::Fn::cast(node).and_then(|fn_| sema.to_def(&fn_))?;\n                 def.try_to_nav(sema.db)\n             }) {\n-                let relative_range = r_range;\n                 calls.add(&nav, relative_range);\n             }\n         }\n@@ -87,7 +87,6 @@ pub(crate) fn outgoing_calls(db: &RootDatabase, position: FilePosition) -> Optio\n             let name_ref = call_node.name_ref()?;\n             let func_target = match call_node {\n                 FnCallNode::CallExpr(expr) => {\n-                    //FIXME: Type::as_callable is broken\n                     let callable = sema.type_of_expr(&expr.expr()?)?.as_callable(db)?;\n                     match callable.kind() {\n                         hir::CallableKind::Function(it) => it.try_to_nav(db),"}, {"sha": "f12c9d44240d9e3e8315aa43c37ded8c180f9dfb", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 104, "deletions": 25, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "patch": "@@ -1,4 +1,4 @@\n-//! Resolves and rewrites links in markdown documentation.\n+//! Extracts, resolves and rewrites links and intra-doc links in markdown documentation.\n \n use std::{convert::TryFrom, iter::once, ops::Range};\n \n@@ -15,7 +15,10 @@ use ide_db::{\n     defs::{Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use syntax::{\n+    ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    TokenAtOffset, T,\n+};\n \n use crate::{FilePosition, Semantics};\n \n@@ -60,29 +63,6 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Defi\n     out\n }\n \n-pub(crate) fn extract_definitions_from_markdown(\n-    markdown: &str,\n-) -> Vec<(String, Option<hir::Namespace>, Range<usize>)> {\n-    let mut res = vec![];\n-    let mut cb = |link: BrokenLink| {\n-        // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n-        // this is fixed in the repo but not on the crates.io release yet\n-        Some((\n-            /*url*/ link.reference.to_owned().into(),\n-            /*title*/ link.reference.to_owned().into(),\n-        ))\n-    };\n-    let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n-    for (event, range) in doc.into_offset_iter() {\n-        if let Event::Start(Tag::Link(_, target, title)) = event {\n-            let link = if target.is_empty() { title } else { target };\n-            let (link, ns) = parse_link(&link);\n-            res.push((link.to_string(), ns, range));\n-        }\n-    }\n-    res\n-}\n-\n /// Remove all links in markdown documentation.\n pub(crate) fn remove_links(markdown: &str) -> String {\n     let mut drop_link = false;\n@@ -118,6 +98,105 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     out\n }\n \n+pub(crate) fn extract_definitions_from_markdown(\n+    markdown: &str,\n+) -> Vec<(Range<usize>, String, Option<hir::Namespace>)> {\n+    let mut res = vec![];\n+    let mut cb = |link: BrokenLink| {\n+        // These allocations are actually unnecessary but the lifetimes on BrokenLinkCallback are wrong\n+        // this is fixed in the repo but not on the crates.io release yet\n+        Some((\n+            /*url*/ link.reference.to_owned().into(),\n+            /*title*/ link.reference.to_owned().into(),\n+        ))\n+    };\n+    let doc = Parser::new_with_broken_link_callback(markdown, Options::empty(), Some(&mut cb));\n+    for (event, range) in doc.into_offset_iter() {\n+        if let Event::Start(Tag::Link(_, target, title)) = event {\n+            let link = if target.is_empty() { title } else { target };\n+            let (link, ns) = parse_link(&link);\n+            res.push((range, link.to_string(), ns));\n+        }\n+    }\n+    res\n+}\n+\n+/// Extracts a link from a comment at the given position returning the spanning range, link and\n+/// optionally it's namespace.\n+pub(crate) fn extract_positioned_link_from_comment(\n+    position: TextSize,\n+    comment: &ast::Comment,\n+) -> Option<(TextRange, String, Option<hir::Namespace>)> {\n+    let doc_comment = comment.doc_comment()?;\n+    let comment_start =\n+        comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n+    let def_links = extract_definitions_from_markdown(doc_comment);\n+    let (range, def_link, ns) =\n+        def_links.into_iter().find_map(|(Range { start, end }, def_link, ns)| {\n+            let range = TextRange::at(\n+                comment_start + TextSize::from(start as u32),\n+                TextSize::from((end - start) as u32),\n+            );\n+            range.contains(position).then(|| (range, def_link, ns))\n+        })?;\n+    Some((range, def_link, ns))\n+}\n+\n+/// Turns a syntax node into it's [`Definition`] if it can hold docs.\n+pub(crate) fn doc_owner_to_def(\n+    sema: &Semantics<RootDatabase>,\n+    item: &SyntaxNode,\n+) -> Option<Definition> {\n+    let res: hir::ModuleDef = match_ast! {\n+        match item {\n+            ast::SourceFile(_it) => sema.scope(item).module()?.into(),\n+            ast::Fn(it) => sema.to_def(&it)?.into(),\n+            ast::Struct(it) => sema.to_def(&it)?.into(),\n+            ast::Enum(it) => sema.to_def(&it)?.into(),\n+            ast::Union(it) => sema.to_def(&it)?.into(),\n+            ast::Trait(it) => sema.to_def(&it)?.into(),\n+            ast::Const(it) => sema.to_def(&it)?.into(),\n+            ast::Static(it) => sema.to_def(&it)?.into(),\n+            ast::TypeAlias(it) => sema.to_def(&it)?.into(),\n+            ast::Variant(it) => sema.to_def(&it)?.into(),\n+            ast::Trait(it) => sema.to_def(&it)?.into(),\n+            ast::Impl(it) => return sema.to_def(&it).map(Definition::SelfType),\n+            ast::MacroRules(it) => return sema.to_def(&it).map(Definition::Macro),\n+            ast::TupleField(it) => return sema.to_def(&it).map(Definition::Field),\n+            ast::RecordField(it) => return sema.to_def(&it).map(Definition::Field),\n+            _ => return None,\n+        }\n+    };\n+    Some(Definition::ModuleDef(res))\n+}\n+\n+pub(crate) fn resolve_doc_path_for_def(\n+    db: &dyn HirDatabase,\n+    def: Definition,\n+    link: &str,\n+    ns: Option<hir::Namespace>,\n+) -> Option<hir::ModuleDef> {\n+    match def {\n+        Definition::ModuleDef(def) => match def {\n+            ModuleDef::Module(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Function(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Adt(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Variant(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Const(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Static(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::Trait(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::TypeAlias(it) => it.resolve_doc_path(db, &link, ns),\n+            ModuleDef::BuiltinType(_) => None,\n+        },\n+        Definition::Macro(it) => it.resolve_doc_path(db, &link, ns),\n+        Definition::Field(it) => it.resolve_doc_path(db, &link, ns),\n+        Definition::SelfType(_)\n+        | Definition::Local(_)\n+        | Definition::GenericParam(_)\n+        | Definition::Label(_) => None,\n+    }\n+}\n+\n // FIXME:\n // BUG: For Option::Some\n // Returns https://doc.rust-lang.org/nightly/core/prelude/v1/enum.Option.html#variant.Some"}, {"sha": "a2c97061f2f5c61320f60468ada328eee7bc3172", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 8, "deletions": 58, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "patch": "@@ -1,18 +1,14 @@\n-use std::ops::Range;\n-\n use either::Either;\n-use hir::{HasAttrs, ModuleDef, Semantics};\n+use hir::Semantics;\n use ide_db::{\n-    defs::{Definition, NameClass, NameRefClass},\n+    defs::{NameClass, NameRefClass},\n     RootDatabase,\n };\n-use syntax::{\n-    ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TextRange, TextSize,\n-    TokenAtOffset, T,\n-};\n+use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{\n-    display::TryToNav, doc_links::extract_definitions_from_markdown, runnables::doc_owner_to_def,\n+    display::TryToNav,\n+    doc_links::{doc_owner_to_def, extract_positioned_link_from_comment, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -35,7 +31,9 @@ pub(crate) fn goto_definition(\n     let token = sema.descend_into_macros(original_token.clone());\n     let parent = token.parent()?;\n     if let Some(comment) = ast::Comment::cast(token) {\n-        let nav = def_for_doc_comment(&sema, position, &comment)?.try_to_nav(db)?;\n+        let (_, link, ns) = extract_positioned_link_from_comment(position.offset, &comment)?;\n+        let def = doc_owner_to_def(&sema, &parent)?;\n+        let nav = resolve_doc_path_for_def(db, def, &link, ns)?.try_to_nav(db)?;\n         return Some(RangeInfo::new(original_token.text_range(), vec![nav]));\n     }\n \n@@ -61,54 +59,6 @@ pub(crate) fn goto_definition(\n     Some(RangeInfo::new(original_token.text_range(), nav.into_iter().collect()))\n }\n \n-fn def_for_doc_comment(\n-    sema: &Semantics<RootDatabase>,\n-    position: FilePosition,\n-    doc_comment: &ast::Comment,\n-) -> Option<hir::ModuleDef> {\n-    let parent = doc_comment.syntax().parent()?;\n-    let (link, ns) = extract_positioned_link_from_comment(position, doc_comment)?;\n-\n-    let def = doc_owner_to_def(sema, parent)?;\n-    match def {\n-        Definition::ModuleDef(def) => match def {\n-            ModuleDef::Module(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Function(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Adt(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Variant(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Const(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Static(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::Trait(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::TypeAlias(it) => it.resolve_doc_path(sema.db, &link, ns),\n-            ModuleDef::BuiltinType(_) => return None,\n-        },\n-        Definition::Macro(it) => it.resolve_doc_path(sema.db, &link, ns),\n-        Definition::Field(it) => it.resolve_doc_path(sema.db, &link, ns),\n-        Definition::SelfType(_)\n-        | Definition::Local(_)\n-        | Definition::GenericParam(_)\n-        | Definition::Label(_) => return None,\n-    }\n-}\n-\n-fn extract_positioned_link_from_comment(\n-    position: FilePosition,\n-    comment: &ast::Comment,\n-) -> Option<(String, Option<hir::Namespace>)> {\n-    let doc_comment = comment.doc_comment()?;\n-    let comment_start =\n-        comment.syntax().text_range().start() + TextSize::from(comment.prefix().len() as u32);\n-    let def_links = extract_definitions_from_markdown(doc_comment);\n-    let (def_link, ns, _) = def_links.into_iter().find(|&(_, _, Range { start, end })| {\n-        TextRange::at(\n-            comment_start + TextSize::from(start as u32),\n-            TextSize::from((end - start) as u32),\n-        )\n-        .contains(position.offset)\n-    })?;\n-    Some((def_link, ns))\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {"}, {"sha": "c4308947650ec33da14e10a642664035177f8c3e", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 54, "deletions": 9, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "patch": "@@ -11,11 +11,14 @@ use ide_db::{\n };\n use itertools::Itertools;\n use stdx::format_to;\n-use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{\n     display::{macro_label, TryToNav},\n-    doc_links::{remove_links, rewrite_links},\n+    doc_links::{\n+        doc_owner_to_def, extract_positioned_link_from_comment, remove_links,\n+        resolve_doc_path_for_def, rewrite_links,\n+    },\n     markdown_remove::remove_markdown,\n     markup::Markup,\n     runnables::{runnable_fn, runnable_mod},\n@@ -93,20 +96,35 @@ pub(crate) fn hover(\n     let mut res = HoverResult::default();\n \n     let node = token.parent()?;\n+    let mut range = None;\n     let definition = match_ast! {\n         match node {\n             // we don't use NameClass::referenced_or_defined here as we do not want to resolve\n             // field pattern shorthands to their definition\n             ast::Name(name) => NameClass::classify(&sema, &name).and_then(|class| match class {\n                 NameClass::ConstReference(def) => Some(def),\n-                def => def.defined(sema.db),\n+                def => def.defined(db),\n             }),\n-            ast::NameRef(name_ref) => NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(sema.db)),\n-            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime)\n-                .map_or_else(|| NameRefClass::classify_lifetime(&sema, &lifetime).map(|d| d.referenced(sema.db)), |d| d.defined(sema.db)),\n-            _ => None,\n+            ast::NameRef(name_ref) => {\n+                NameRefClass::classify(&sema, &name_ref).map(|d| d.referenced(db))\n+            },\n+            ast::Lifetime(lifetime) => NameClass::classify_lifetime(&sema, &lifetime).map_or_else(\n+                || NameRefClass::classify_lifetime(&sema, &lifetime).map(|d| d.referenced(db)),\n+                |d| d.defined(db),\n+            ),\n+\n+            _ => ast::Comment::cast(token.clone())\n+                .and_then(|comment| {\n+                    let (idl_range, link, ns) =\n+                        extract_positioned_link_from_comment(position.offset, &comment)?;\n+                    range = Some(idl_range);\n+                    let def = doc_owner_to_def(&sema, &node)?;\n+                    resolve_doc_path_for_def(db, def, &link, ns)\n+                })\n+                .map(Definition::ModuleDef),\n         }\n     };\n+\n     if let Some(definition) = definition {\n         let famous_defs = match &definition {\n             Definition::ModuleDef(ModuleDef::BuiltinType(_)) => {\n@@ -128,15 +146,16 @@ pub(crate) fn hover(\n                 res.actions.push(action);\n             }\n \n-            let range = sema.original_range(&node).range;\n+            let range = range.unwrap_or_else(|| sema.original_range(&node).range);\n             return Some(RangeInfo::new(range, res));\n         }\n     }\n \n     if token.kind() == syntax::SyntaxKind::COMMENT {\n-        // don't highlight the entire parent node on comment hover\n+        cov_mark::hit!(no_highlight_on_comment_hover);\n         return None;\n     }\n+\n     if let res @ Some(_) = hover_for_keyword(&sema, links_in_hover, markdown, &token) {\n         return res;\n     }\n@@ -3483,6 +3502,7 @@ fn foo$0() {}\n \n     #[test]\n     fn hover_comments_dont_highlight_parent() {\n+        cov_mark::check!(no_highlight_on_comment_hover);\n         check_hover_no_result(\n             r#\"\n fn no_hover() {\n@@ -3755,4 +3775,29 @@ fn main() {\n             \"#]],\n         )\n     }\n+\n+    #[test]\n+    fn hover_intra_doc_links() {\n+        check(\n+            r#\"\n+/// This is the [`foo`](foo$0) function.\n+fn foo() {}\n+\"#,\n+            expect![[r#\"\n+                *[`foo`](foo)*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                fn foo()\n+                ```\n+\n+                ---\n+\n+                This is the [`foo`](https://docs.rs/test/*/test/fn.foo.html) function.\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "5b488e2c588d5374818f93e3451d1abb71cd6ea8", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 27, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "patch": "@@ -7,17 +7,13 @@ use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n     base_db::{FilePosition, FileRange},\n-    defs::Definition,\n     helpers::visit_file_defs,\n     search::SearchScope,\n     RootDatabase, SymbolKind,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n-use syntax::{\n-    ast::{self, AstNode, AttrsOwner},\n-    match_ast, SyntaxNode,\n-};\n+use syntax::ast::{self, AstNode, AttrsOwner};\n \n use crate::{\n     display::{ToNav, TryToNav},\n@@ -271,28 +267,6 @@ pub(crate) fn runnable_mod(sema: &Semantics<RootDatabase>, def: hir::Module) ->\n     Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg })\n }\n \n-// FIXME: figure out a proper API here.\n-pub(crate) fn doc_owner_to_def(\n-    sema: &Semantics<RootDatabase>,\n-    item: SyntaxNode,\n-) -> Option<Definition> {\n-    let res: hir::ModuleDef = match_ast! {\n-        match item {\n-            ast::SourceFile(_it) => sema.scope(&item).module()?.into(),\n-            ast::Fn(it) => sema.to_def(&it)?.into(),\n-            ast::Struct(it) => sema.to_def(&it)?.into(),\n-            ast::Enum(it) => sema.to_def(&it)?.into(),\n-            ast::Union(it) => sema.to_def(&it)?.into(),\n-            ast::Trait(it) => sema.to_def(&it)?.into(),\n-            ast::Const(it) => sema.to_def(&it)?.into(),\n-            ast::Static(it) => sema.to_def(&it)?.into(),\n-            ast::TypeAlias(it) => sema.to_def(&it)?.into(),\n-            _ => return None,\n-        }\n-    };\n-    Some(Definition::ModuleDef(res))\n-}\n-\n fn module_def_doctest(sema: &Semantics<RootDatabase>, def: hir::ModuleDef) -> Option<Runnable> {\n     let attrs = match def {\n         hir::ModuleDef::Module(it) => it.attrs(sema.db),"}, {"sha": "38bf49348963503c79fa8ef620670088f6bebd6f", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=8b0d0bd9c7488fedfd0bdd34a0a9cb04da3f143a", "patch": "@@ -190,10 +190,10 @@ pub(super) fn doc_comment(\n                     intra_doc_links.extend(\n                         extract_definitions_from_markdown(line)\n                             .into_iter()\n-                            .filter_map(|(link, ns, range)| {\n-                                validate_intra_doc_link(sema.db, &def, &link, ns).zip(Some(range))\n+                            .filter_map(|(range, link, ns)| {\n+                                Some(range).zip(validate_intra_doc_link(sema.db, &def, &link, ns))\n                             })\n-                            .map(|(def, Range { start, end })| {\n+                            .map(|(Range { start, end }, def)| {\n                                 (\n                                     def,\n                                     TextRange::at("}]}