{"sha": "20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZGMwYzUwNzA0YmExZmM4YzU2YTg4YWUyYmYwNWRkYjNlNDE5YmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-19T17:08:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-19T17:08:28Z"}, "message": "Auto merge of #54174 - parched:park, r=alexcrichton\n\nFix `thread` `park`/`unpark` synchronization\n\nPreviously the code below would not be guaranteed to exit when the\nsecond unpark took the `return, // already unparked` path because there\nwas no write to synchronize with a read in `park`.\n\nEDIT: doesn't actually require third thread\n```\nuse std::sync::atomic::{AtomicBool, Ordering};\nuse std::thread::{current, spawn, park};\n\nstatic FLAG: AtomicBool = AtomicBool::new(false);\n\nfn main() {\n    let thread_0 = current();\n    spawn(move || {\n        thread_0.unpark();\n        FLAG.store(true, Ordering::Relaxed);\n        thread_0.unpark();\n    });\n\n    while !FLAG.load(Ordering::Relaxed) {\n        park();\n    }\n}\n```\n\nI have some other ideas on how to improve the performance of `park` and `unpark` using fences, avoiding any atomic RMW when the state is already `NOTIFIED`, and also how to avoid calling `notify_one` without the mutex locked. But I need to write some micro benchmarks first, so I'll submit those changes at a later date if they prove to be faster.\n\nFixes https://github.com/rust-lang/rust/issues/53366 I hope.", "tree": {"sha": "f0703f76908d464550e18c0afa4a22f76d6ce400", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0703f76908d464550e18c0afa4a22f76d6ce400"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "html_url": "https://github.com/rust-lang/rust/commit/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f3ff5a97bcd2d05ee0c768122752dc74f96ccc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3ff5a97bcd2d05ee0c768122752dc74f96ccc3", "html_url": "https://github.com/rust-lang/rust/commit/4f3ff5a97bcd2d05ee0c768122752dc74f96ccc3"}, {"sha": "a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3b87058e7e4e590ac2c00215785e62aa5f7bec5", "html_url": "https://github.com/rust-lang/rust/commit/a3b87058e7e4e590ac2c00215785e62aa5f7bec5"}], "stats": {"total": 44, "additions": 26, "deletions": 18}, "files": [{"sha": "3987ae83866e5c472fe6cebb13f1730c4e7d3768", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=20dc0c50704ba1fc8c56a88ae2bf05ddb3e419bc", "patch": "@@ -800,7 +800,14 @@ pub fn park() {\n     match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n         Ok(_) => {}\n         Err(NOTIFIED) => {\n-            thread.inner.state.store(EMPTY, SeqCst);\n+            // We must read here, even though we know it will be `NOTIFIED`.\n+            // This is because `unpark` may have been called again since we read\n+            // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+            // acquire operation that synchronizes with that `unpark` to observe\n+            // any writes it made before the call to unpark. To do that we must\n+            // read from the write it made to `state`.\n+            let old = thread.inner.state.swap(EMPTY, SeqCst);\n+            assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n             return;\n         } // should consume this notification, so prohibit spurious wakeups in next park.\n         Err(_) => panic!(\"inconsistent park state\"),\n@@ -889,7 +896,9 @@ pub fn park_timeout(dur: Duration) {\n     match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n         Ok(_) => {}\n         Err(NOTIFIED) => {\n-            thread.inner.state.store(EMPTY, SeqCst);\n+            // We must read again here, see `park`.\n+            let old = thread.inner.state.swap(EMPTY, SeqCst);\n+            assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n             return;\n         } // should consume this notification, so prohibit spurious wakeups in next park.\n         Err(_) => panic!(\"inconsistent park_timeout state\"),\n@@ -1058,23 +1067,22 @@ impl Thread {\n     /// [park]: fn.park.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n-        loop {\n-            match self.inner.state.compare_exchange(EMPTY, NOTIFIED, SeqCst, SeqCst) {\n-                Ok(_) => return, // no one was waiting\n-                Err(NOTIFIED) => return, // already unparked\n-                Err(PARKED) => {} // gotta go wake someone up\n-                _ => panic!(\"inconsistent state in unpark\"),\n-            }\n-\n-            // Coordinate wakeup through the mutex and a condvar notification\n-            let _lock = self.inner.lock.lock().unwrap();\n-            match self.inner.state.compare_exchange(PARKED, NOTIFIED, SeqCst, SeqCst) {\n-                Ok(_) => return self.inner.cvar.notify_one(),\n-                Err(NOTIFIED) => return, // a different thread unparked\n-                Err(EMPTY) => {} // parked thread went away, try again\n-                _ => panic!(\"inconsistent state in unpark\"),\n-            }\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n+        match self.inner.state.swap(NOTIFIED, SeqCst) {\n+            EMPTY => return, // no one was waiting\n+            NOTIFIED => return, // already unparked\n+            PARKED => {} // gotta go wake someone up\n+            _ => panic!(\"inconsistent state in unpark\"),\n         }\n+\n+        // Coordinate wakeup through the mutex and a condvar notification\n+        let _lock = self.inner.lock.lock().unwrap();\n+        self.inner.cvar.notify_one()\n     }\n \n     /// Gets the thread's unique identifier."}]}