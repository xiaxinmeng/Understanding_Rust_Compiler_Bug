{"sha": "67e1681c1db9545ec05c458cad440a9197617a30", "node_id": "C_kwDOAAsO6NoAKDY3ZTE2ODFjMWRiOTU0NWVjMDVjNDU4Y2FkNDQwYTkxOTc2MTdhMzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T14:45:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-11T14:45:14Z"}, "message": "Auto merge of #109015 - matthiaskrgr:rollup-xu2s31g, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #106276 (Fix `vec_deque::Drain` FIXME)\n - #107629 (rustdoc: sort deprecated items lower in search)\n - #108711 (Add note when matching token with nonterminal)\n - #108757 (rustdoc: Migrate `document_item_info` to Askama)\n - #108784 (rustdoc: Migrate sidebar rendering to Askama)\n - #108927 (Move __thread_local_inner to sys)\n - #108949 (Honor current target when checking conditional compilation values)\n - #108950 (Directly construct Inherited in typeck.)\n - #108988 (rustdoc: Don't crash on `crate` references in blocks)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "05a239fccc142440bfe32b0bff8309da9ef9dc69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05a239fccc142440bfe32b0bff8309da9ef9dc69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67e1681c1db9545ec05c458cad440a9197617a30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67e1681c1db9545ec05c458cad440a9197617a30", "html_url": "https://github.com/rust-lang/rust/commit/67e1681c1db9545ec05c458cad440a9197617a30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67e1681c1db9545ec05c458cad440a9197617a30/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e350fe4e608b653da47e8012d13ef701613e717b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e350fe4e608b653da47e8012d13ef701613e717b", "html_url": "https://github.com/rust-lang/rust/commit/e350fe4e608b653da47e8012d13ef701613e717b"}, {"sha": "e12ba7300ae8936fe5627b43719a8b9df7e9a730", "url": "https://api.github.com/repos/rust-lang/rust/commits/e12ba7300ae8936fe5627b43719a8b9df7e9a730", "html_url": "https://github.com/rust-lang/rust/commit/e12ba7300ae8936fe5627b43719a8b9df7e9a730"}], "stats": {"total": 3272, "additions": 1728, "deletions": 1544}, "files": [{"sha": "b1d9cea277397102a427e9b93a20e1e557e83e63", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -1,19 +1,18 @@\n-use std::borrow::Cow;\n-\n use crate::base::{DummyResult, ExtCtxt, MacResult};\n use crate::expand::{parse_ast_fragment, AstFragmentKind};\n use crate::mbe::{\n     macro_parser::{MatcherLoc, NamedParseResult, ParseResult::*, TtParser},\n     macro_rules::{try_match_macro, Tracker},\n };\n-use rustc_ast::token::{self, Token};\n+use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage};\n use rustc_parse::parser::{Parser, Recovery};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n+use std::borrow::Cow;\n \n use super::macro_rules::{parser_from_cx, NoopTracker};\n \n@@ -63,6 +62,13 @@ pub(super) fn failed_to_match_macro<'cx>(\n         err.note(format!(\"while trying to match {remaining_matcher}\"));\n     }\n \n+    if let MatcherLoc::Token { token: expected_token } = &remaining_matcher\n+        && (matches!(expected_token.kind, TokenKind::Interpolated(_))\n+            || matches!(token.kind, TokenKind::Interpolated(_)))\n+    {\n+        err.note(\"captured metavariables except for `$tt`, `$ident` and `$lifetime` cannot be compared to other tokens\");\n+    }\n+\n     // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n     if let Some((arg, comma_span)) = arg.add_comma() {\n         for lhs in lhses {"}, {"sha": "4110b176b41b1f8f6bc8726abf81f6df98140bc2", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 7, "deletions": 32, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -4,7 +4,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n-use rustc_infer::infer;\n use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -73,40 +72,16 @@ impl<'tcx> Deref for Inherited<'tcx> {\n     }\n }\n \n-/// A temporary returned by `Inherited::build(...)`. This is necessary\n-/// for multiple `InferCtxt` to share the same `typeck_results`\n-/// without using `Rc` or something similar.\n-pub struct InheritedBuilder<'tcx> {\n-    infcx: infer::InferCtxtBuilder<'tcx>,\n-    typeck_results: RefCell<ty::TypeckResults<'tcx>>,\n-}\n-\n impl<'tcx> Inherited<'tcx> {\n-    pub fn build(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> InheritedBuilder<'tcx> {\n+    pub fn new(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         let hir_owner = tcx.hir().local_def_id_to_hir_id(def_id).owner;\n \n-        InheritedBuilder {\n-            infcx: tcx\n-                .infer_ctxt()\n-                .ignoring_regions()\n-                .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)),\n-            typeck_results: RefCell::new(ty::TypeckResults::new(hir_owner)),\n-        }\n-    }\n-}\n-\n-impl<'tcx> InheritedBuilder<'tcx> {\n-    pub fn enter<F, R>(mut self, f: F) -> R\n-    where\n-        F: FnOnce(&Inherited<'tcx>) -> R,\n-    {\n-        f(&Inherited::new(self.infcx.build(), self.typeck_results))\n-    }\n-}\n-\n-impl<'tcx> Inherited<'tcx> {\n-    fn new(infcx: InferCtxt<'tcx>, typeck_results: RefCell<ty::TypeckResults<'tcx>>) -> Self {\n-        let tcx = infcx.tcx;\n+        let infcx = tcx\n+            .infer_ctxt()\n+            .ignoring_regions()\n+            .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id))\n+            .build();\n+        let typeck_results = RefCell::new(ty::TypeckResults::new(hir_owner));\n \n         Inherited {\n             typeck_results,"}, {"sha": "70124a77364063cabdc588366b36135f1a7204ed", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 115, "deletions": 119, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -45,13 +45,14 @@ mod rvalue_scopes;\n mod upvar;\n mod writeback;\n \n-pub use diverges::Diverges;\n-pub use expectation::Expectation;\n-pub use fn_ctxt::*;\n-pub use inherited::{Inherited, InheritedBuilder};\n+pub use fn_ctxt::FnCtxt;\n+pub use inherited::Inherited;\n \n use crate::check::check_fn;\n use crate::coercion::DynamicCoerceMany;\n+use crate::diverges::Diverges;\n+use crate::expectation::Expectation;\n+use crate::fn_ctxt::RawTy;\n use crate::gather_locals::GatherLocalsVisitor;\n use rustc_data_structures::unord::UnordSet;\n use rustc_errors::{\n@@ -105,10 +106,9 @@ pub struct LocalTy<'tcx> {\n /// (notably closures), `typeck_results(def_id)` would wind up\n /// redirecting to the owning function.\n fn primary_body_of(\n-    tcx: TyCtxt<'_>,\n-    id: hir::HirId,\n+    node: Node<'_>,\n ) -> Option<(hir::BodyId, Option<&hir::Ty<'_>>, Option<&hir::FnSig<'_>>)> {\n-    match tcx.hir().get(id) {\n+    match node {\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Const(ty, body) | hir::ItemKind::Static(ty, _, body) => {\n                 Some((body, Some(ty), None))\n@@ -142,8 +142,7 @@ fn has_typeck_results(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n \n     if let Some(def_id) = def_id.as_local() {\n-        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        primary_body_of(tcx, id).is_some()\n+        primary_body_of(tcx.hir().get_by_def_id(def_id)).is_some()\n     } else {\n         false\n     }\n@@ -198,143 +197,140 @@ fn typeck_with_fallback<'tcx>(\n     }\n \n     let id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let node = tcx.hir().get(id);\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n-    let (body_id, body_ty, fn_sig) = primary_body_of(tcx, id).unwrap_or_else(|| {\n+    let (body_id, body_ty, fn_sig) = primary_body_of(node).unwrap_or_else(|| {\n         span_bug!(span, \"can't type-check body of {:?}\", def_id);\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let typeck_results = Inherited::build(tcx, def_id).enter(|inh| {\n-        let param_env = tcx.param_env(def_id);\n-        let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n-            param_env.without_const()\n+    let param_env = tcx.param_env(def_id);\n+    let param_env = if tcx.has_attr(def_id.to_def_id(), sym::rustc_do_not_const_check) {\n+        param_env.without_const()\n+    } else {\n+        param_env\n+    };\n+    let inh = Inherited::new(tcx, def_id);\n+    let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n+\n+    if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n+        let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n+            fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n         } else {\n-            param_env\n+            tcx.fn_sig(def_id).subst_identity()\n         };\n-        let mut fcx = FnCtxt::new(&inh, param_env, def_id);\n-\n-        if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n-            let fn_sig = if rustc_hir_analysis::collect::get_infer_ret_ty(&decl.output).is_some() {\n-                fcx.astconv().ty_of_fn(id, header.unsafety, header.abi, decl, None, None)\n-            } else {\n-                tcx.fn_sig(def_id).subst_identity()\n-            };\n \n-            check_abi(tcx, id, span, fn_sig.abi());\n+        check_abi(tcx, id, span, fn_sig.abi());\n \n-            // Compute the function signature from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n-            let fn_sig = fcx.normalize(body.value.span, fn_sig);\n+        // Compute the function signature from point of view of inside the fn.\n+        let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n+        let fn_sig = fcx.normalize(body.value.span, fn_sig);\n \n-            check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n-        } else {\n-            let expected_type = body_ty\n-                .and_then(|ty| match ty.kind {\n-                    hir::TyKind::Infer => Some(fcx.astconv().ast_ty_to_ty(ty)),\n-                    _ => None,\n-                })\n-                .unwrap_or_else(|| match tcx.hir().get(id) {\n-                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().parent_id(id)) {\n-                        Node::Expr(&hir::Expr {\n-                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n-                            ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Typeof(ref anon_const), ..\n-                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span,\n-                        }),\n-                        Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n-                        | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n-                            let operand_ty =\n-                                asm.operands.iter().find_map(|(op, _op_sp)| match op {\n-                                    hir::InlineAsmOperand::Const { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        // Inline assembly constants must be integers.\n-                                        Some(fcx.next_int_var())\n-                                    }\n-                                    hir::InlineAsmOperand::SymFn { anon_const }\n-                                        if anon_const.hir_id == id =>\n-                                    {\n-                                        Some(fcx.next_ty_var(TypeVariableOrigin {\n-                                            kind: TypeVariableOriginKind::MiscVariable,\n-                                            span,\n-                                        }))\n-                                    }\n-                                    _ => None,\n-                                });\n-                            operand_ty.unwrap_or_else(fallback)\n+        check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n+    } else {\n+        let expected_type = if let Some(&hir::Ty { kind: hir::TyKind::Infer, span, .. }) = body_ty {\n+            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::TypeInference,\n+                span,\n+            }))\n+        } else if let Node::AnonConst(_) = node {\n+            match tcx.hir().get(tcx.hir().parent_id(id)) {\n+                Node::Expr(&hir::Expr {\n+                    kind: hir::ExprKind::ConstBlock(ref anon_const), ..\n+                }) if anon_const.hir_id == id => Some(fcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                })),\n+                Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref anon_const), .. })\n+                    if anon_const.hir_id == id =>\n+                {\n+                    Some(fcx.next_ty_var(TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeInference,\n+                        span,\n+                    }))\n+                }\n+                Node::Expr(&hir::Expr { kind: hir::ExprKind::InlineAsm(asm), .. })\n+                | Node::Item(&hir::Item { kind: hir::ItemKind::GlobalAsm(asm), .. }) => {\n+                    asm.operands.iter().find_map(|(op, _op_sp)| match op {\n+                        hir::InlineAsmOperand::Const { anon_const } if anon_const.hir_id == id => {\n+                            // Inline assembly constants must be integers.\n+                            Some(fcx.next_int_var())\n+                        }\n+                        hir::InlineAsmOperand::SymFn { anon_const } if anon_const.hir_id == id => {\n+                            Some(fcx.next_ty_var(TypeVariableOrigin {\n+                                kind: TypeVariableOriginKind::MiscVariable,\n+                                span,\n+                            }))\n                         }\n-                        _ => fallback(),\n-                    },\n-                    _ => fallback(),\n-                });\n+                        _ => None,\n+                    })\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        };\n+        let expected_type = expected_type.unwrap_or_else(fallback);\n \n-            let expected_type = fcx.normalize(body.value.span, expected_type);\n-            fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n+        let expected_type = fcx.normalize(body.value.span, expected_type);\n+        fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n-            // Gather locals in statics (because of block expressions).\n-            GatherLocalsVisitor::new(&fcx).visit_body(body);\n+        // Gather locals in statics (because of block expressions).\n+        GatherLocalsVisitor::new(&fcx).visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n+        fcx.check_expr_coercable_to_type(&body.value, expected_type, None);\n \n-            fcx.write_ty(id, expected_type);\n-        };\n+        fcx.write_ty(id, expected_type);\n+    };\n \n-        fcx.type_inference_fallback();\n-\n-        // Even though coercion casts provide type hints, we check casts after fallback for\n-        // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n-        fcx.check_casts();\n-        fcx.select_obligations_where_possible(|_| {});\n-\n-        // Closure and generator analysis may run after fallback\n-        // because they don't constrain other type variables.\n-        // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n-        let prev_constness = fcx.param_env.constness();\n-        fcx.param_env = fcx.param_env.without_const();\n-        fcx.closure_analyze(body);\n-        fcx.param_env = fcx.param_env.with_constness(prev_constness);\n-        assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        // Before the generator analysis, temporary scopes shall be marked to provide more\n-        // precise information on types to be captured.\n-        fcx.resolve_rvalue_scopes(def_id.to_def_id());\n-\n-        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n-            let ty = fcx.normalize(span, ty);\n-            fcx.require_type_is_sized(ty, span, code);\n-        }\n+    fcx.type_inference_fallback();\n+\n+    // Even though coercion casts provide type hints, we check casts after fallback for\n+    // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n+    fcx.check_casts();\n+    fcx.select_obligations_where_possible(|_| {});\n+\n+    // Closure and generator analysis may run after fallback\n+    // because they don't constrain other type variables.\n+    // Closure analysis only runs on closures. Therefore they only need to fulfill non-const predicates (as of now)\n+    let prev_constness = fcx.param_env.constness();\n+    fcx.param_env = fcx.param_env.without_const();\n+    fcx.closure_analyze(body);\n+    fcx.param_env = fcx.param_env.with_constness(prev_constness);\n+    assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n+    // Before the generator analysis, temporary scopes shall be marked to provide more\n+    // precise information on types to be captured.\n+    fcx.resolve_rvalue_scopes(def_id.to_def_id());\n+\n+    for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+        let ty = fcx.normalize(span, ty);\n+        fcx.require_type_is_sized(ty, span, code);\n+    }\n \n-        fcx.select_obligations_where_possible(|_| {});\n+    fcx.select_obligations_where_possible(|_| {});\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        // This must be the last thing before `report_ambiguity_errors`.\n-        fcx.resolve_generator_interiors(def_id.to_def_id());\n+    // This must be the last thing before `report_ambiguity_errors`.\n+    fcx.resolve_generator_interiors(def_id.to_def_id());\n \n-        debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n+    debug!(pending_obligations = ?fcx.fulfillment_cx.borrow().pending_obligations());\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.report_ambiguity_errors();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.report_ambiguity_errors();\n+    }\n \n-        if let None = fcx.infcx.tainted_by_errors() {\n-            fcx.check_transmutes();\n-        }\n+    if let None = fcx.infcx.tainted_by_errors() {\n+        fcx.check_transmutes();\n+    }\n \n-        fcx.check_asms();\n+    fcx.check_asms();\n \n-        fcx.infcx.skip_region_resolution();\n+    fcx.infcx.skip_region_resolution();\n \n-        fcx.resolve_type_vars_in_body(body)\n-    });\n+    let typeck_results = fcx.resolve_type_vars_in_body(body);\n \n     // Consistency check our TypeckResults instance can hold all ItemLocalIds\n     // it will need to hold."}, {"sha": "043892410ceaa8e8f5bd9d915472c562b0248d6d", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -110,7 +110,7 @@ pub fn create_session(\n     add_configuration(&mut cfg, &mut sess, &*codegen_backend);\n \n     let mut check_cfg = config::to_crate_check_config(check_cfg);\n-    check_cfg.fill_well_known();\n+    check_cfg.fill_well_known(&sess.target);\n \n     sess.parse_sess.config = cfg;\n     sess.parse_sess.check_config = check_cfg;"}, {"sha": "f6888e55ad4313c4fa31fbb0fa31dcd2676f1e16", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -1849,20 +1849,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         &mut self,\n         path_str: &str,\n         ns: Namespace,\n-        mut parent_scope: ParentScope<'a>,\n+        parent_scope: ParentScope<'a>,\n     ) -> Option<Res> {\n         let mut segments =\n             Vec::from_iter(path_str.split(\"::\").map(Ident::from_str).map(Segment::from_ident));\n         if let Some(segment) = segments.first_mut() {\n-            if segment.ident.name == kw::Crate {\n-                // FIXME: `resolve_path` always resolves `crate` to the current crate root, but\n-                // rustdoc wants it to resolve to the `parent_scope`'s crate root. This trick of\n-                // replacing `crate` with `self` and changing the current module should achieve\n-                // the same effect.\n-                segment.ident.name = kw::SelfLower;\n-                parent_scope.module =\n-                    self.expect_module(parent_scope.module.def_id().krate.as_def_id());\n-            } else if segment.ident.name == kw::Empty {\n+            if segment.ident.name == kw::Empty {\n                 segment.ident.name = kw::PathRoot;\n             }\n         }"}, {"sha": "485c3f554625abb3f456988b702ae0c998a3a9c9", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -1137,7 +1137,7 @@ impl CrateCheckConfig {\n     }\n \n     /// Fills a `CrateCheckConfig` with well-known configuration values.\n-    fn fill_well_known_values(&mut self) {\n+    fn fill_well_known_values(&mut self, current_target: &Target) {\n         if !self.well_known_values {\n             return;\n         }\n@@ -1229,6 +1229,7 @@ impl CrateCheckConfig {\n             for target in TARGETS\n                 .iter()\n                 .map(|target| Target::expect_builtin(&TargetTriple::from_triple(target)))\n+                .chain(iter::once(current_target.clone()))\n             {\n                 values_target_os.insert(Symbol::intern(&target.options.os));\n                 values_target_family\n@@ -1243,9 +1244,9 @@ impl CrateCheckConfig {\n         }\n     }\n \n-    pub fn fill_well_known(&mut self) {\n+    pub fn fill_well_known(&mut self, current_target: &Target) {\n         self.fill_well_known_names();\n-        self.fill_well_known_values();\n+        self.fill_well_known_values(current_target);\n     }\n }\n "}, {"sha": "0be274a3822d3ac58608f3badfe556f7ee54d0a1", "filename": "library/alloc/src/collections/vec_deque/drain.rs", "status": "modified", "additions": 13, "deletions": 27, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -52,36 +52,22 @@ impl<'a, T, A: Allocator> Drain<'a, T, A> {\n         }\n     }\n \n-    // Only returns pointers to the slices, as that's\n-    // all we need to drop them. May only be called if `self.remaining != 0`.\n+    // Only returns pointers to the slices, as that's all we need\n+    // to drop them. May only be called if `self.remaining != 0`.\n     unsafe fn as_slices(&self) -> (*mut [T], *mut [T]) {\n         unsafe {\n             let deque = self.deque.as_ref();\n-            // FIXME: This is doing almost exactly the same thing as the else branch in `VecDeque::slice_ranges`.\n-            // Unfortunately, we can't just call `slice_ranges` here, as the deque's `len` is currently\n-            // just `drain_start`, so the range check would (almost) always panic. Between temporarily\n-            // adjusting the deques `len` to call `slice_ranges`, and just copy pasting the `slice_ranges`\n-            // implementation, this seemed like the less hacky solution, though it might be good to\n-            // find a better one in the future.\n-\n-            // because `self.remaining != 0`, we know that `self.idx < deque.original_len`, so it's a valid\n-            // logical index.\n-            let wrapped_start = deque.to_physical_idx(self.idx);\n-\n-            let head_len = deque.capacity() - wrapped_start;\n-\n-            let (a_range, b_range) = if head_len >= self.remaining {\n-                (wrapped_start..wrapped_start + self.remaining, 0..0)\n-            } else {\n-                let tail_len = self.remaining - head_len;\n-                (wrapped_start..deque.capacity(), 0..tail_len)\n-            };\n-\n-            // SAFETY: the range `self.idx..self.idx+self.remaining` lies strictly inside\n-            // the range `0..deque.original_len`. because of this, and because of the fact\n-            // that we acquire `a_range` and `b_range` exactly like `slice_ranges` would,\n-            // it's guaranteed that `a_range` and `b_range` represent valid ranges into\n-            // the deques buffer.\n+\n+            // We know that `self.idx + self.remaining <= deque.len <= usize::MAX`, so this won't overflow.\n+            let logical_remaining_range = self.idx..self.idx + self.remaining;\n+\n+            // SAFETY: `logical_remaining_range` represents the\n+            // range into the logical buffer of elements that\n+            // haven't been drained yet, so they're all initialized,\n+            // and `slice::range(start..end, end) == start..end`,\n+            // so the preconditions for `slice_ranges` are met.\n+            let (a_range, b_range) =\n+                deque.slice_ranges(logical_remaining_range.clone(), logical_remaining_range.end);\n             (deque.buffer_range(a_range), deque.buffer_range(b_range))\n         }\n     }"}, {"sha": "48e907e402ccf2462ddaa917d8c0a63bf9239503", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -1156,7 +1156,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_slices(&self) -> (&[T], &[T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&*self.buffer_range(a_range), &*self.buffer_range(b_range)) }\n@@ -1190,7 +1190,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     #[inline]\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n     pub fn as_mut_slices(&mut self) -> (&mut [T], &mut [T]) {\n-        let (a_range, b_range) = self.slice_ranges(..);\n+        let (a_range, b_range) = self.slice_ranges(.., self.len);\n         // SAFETY: `slice_ranges` always returns valid ranges into\n         // the physical buffer.\n         unsafe { (&mut *self.buffer_range(a_range), &mut *self.buffer_range(b_range)) }\n@@ -1232,19 +1232,28 @@ impl<T, A: Allocator> VecDeque<T, A> {\n \n     /// Given a range into the logical buffer of the deque, this function\n     /// return two ranges into the physical buffer that correspond to\n-    /// the given range.\n-    fn slice_ranges<R>(&self, range: R) -> (Range<usize>, Range<usize>)\n+    /// the given range. The `len` parameter should usually just be `self.len`;\n+    /// the reason it's passed explicitly is that if the deque is wrapped in\n+    /// a `Drain`, then `self.len` is not actually the length of the deque.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is always safe to call. For the resulting ranges to be valid\n+    /// ranges into the physical buffer, the caller must ensure that the result of\n+    /// calling `slice::range(range, ..len)` represents a valid range into the\n+    /// logical buffer, and that all elements in that range are initialized.\n+    fn slice_ranges<R>(&self, range: R, len: usize) -> (Range<usize>, Range<usize>)\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::range(range, ..self.len);\n+        let Range { start, end } = slice::range(range, ..len);\n         let len = end - start;\n \n         if len == 0 {\n             (0..0, 0..0)\n         } else {\n-            // `slice::range` guarantees that `start <= end <= self.len`.\n-            // because `len != 0`, we know that `start < end`, so `start < self.len`\n+            // `slice::range` guarantees that `start <= end <= len`.\n+            // because `len != 0`, we know that `start < end`, so `start < len`\n             // and the indexing is valid.\n             let wrapped_start = self.to_physical_idx(start);\n \n@@ -1290,7 +1299,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and\n@@ -1330,7 +1339,7 @@ impl<T, A: Allocator> VecDeque<T, A> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let (a_range, b_range) = self.slice_ranges(range);\n+        let (a_range, b_range) = self.slice_ranges(range, self.len);\n         // SAFETY: The ranges returned by `slice_ranges`\n         // are valid ranges into the physical buffer, so\n         // it's ok to pass them to `buffer_range` and"}, {"sha": "2b8782ddf4482c6ba242e79730a81a1896c81cc6", "filename": "library/std/src/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fmod.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -12,6 +12,7 @@\n \n pub mod alloc;\n pub mod small_c_string;\n+pub mod thread_local;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "2addcc4a759d0382c55ef5d3779a08ccefa6213e", "filename": "library/std/src/sys/common/thread_local/fast_local.rs", "status": "added", "additions": 276, "deletions": 0, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Ffast_local.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,276 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+            // If the platform has support for `#[thread_local]`, use it.\n+            #[thread_local]\n+            static mut VAL: $t = INIT_EXPR;\n+\n+            // If a dtor isn't needed we can do something \"very raw\" and\n+            // just get going.\n+            if !$crate::mem::needs_drop::<$t>() {\n+                unsafe {\n+                    return $crate::option::Option::Some(&VAL)\n+                }\n+            }\n+\n+            // 0 == dtor not registered\n+            // 1 == dtor registered, dtor not run\n+            // 2 == dtor registered and is running or has run\n+            #[thread_local]\n+            static mut STATE: $crate::primitive::u8 = 0;\n+\n+            unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n+                let ptr = ptr as *mut $t;\n+\n+                unsafe {\n+                    $crate::debug_assert_eq!(STATE, 1);\n+                    STATE = 2;\n+                    $crate::ptr::drop_in_place(ptr);\n+                }\n+            }\n+\n+            unsafe {\n+                match STATE {\n+                    // 0 == we haven't registered a destructor, so do\n+                    //   so now.\n+                    0 => {\n+                        $crate::thread::__LocalKeyInner::<$t>::register_dtor(\n+                            $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n+                            destroy,\n+                        );\n+                        STATE = 1;\n+                        $crate::option::Option::Some(&VAL)\n+                    }\n+                    // 1 == the destructor is registered and the value\n+                    //   is valid, so return the pointer.\n+                    1 => $crate::option::Option::Some(&VAL),\n+                    // otherwise the destructor has already run, so we\n+                    // can't give access.\n+                    _ => $crate::option::Option::None,\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                #[thread_local]\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::<$t>::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod fast {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n+    use crate::sys::thread_local_dtor::register_dtor;\n+    use crate::{fmt, mem, panic};\n+\n+    #[derive(Copy, Clone)]\n+    enum DtorState {\n+        Unregistered,\n+        Registered,\n+        RunningOrHasRun,\n+    }\n+\n+    // This data structure has been carefully constructed so that the fast path\n+    // only contains one branch on x86. That optimization is necessary to avoid\n+    // duplicated tls lookups on OSX.\n+    //\n+    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+    pub struct Key<T> {\n+        // If `LazyKeyInner::get` returns `None`, that indicates either:\n+        //   * The value has never been initialized\n+        //   * The value is being recursively initialized\n+        //   * The value has already been destroyed or is being destroyed\n+        // To determine which kind of `None`, check `dtor_state`.\n+        //\n+        // This is very optimizer friendly for the fast path - initialized but\n+        // not yet dropped.\n+        inner: LazyKeyInner<T>,\n+\n+        // Metadata to keep track of the state of the destructor. Remember that\n+        // this variable is thread-local, not global.\n+        dtor_state: Cell<DtorState>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n+        }\n+\n+        // note that this is just a publicly-callable function only for the\n+        // const-initialized form of thread locals, basically a way to call the\n+        // free `register_dtor` function defined elsewhere in std.\n+        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n+            unsafe {\n+                register_dtor(a, dtor);\n+            }\n+        }\n+\n+        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            // SAFETY: See the definitions of `LazyKeyInner::get` and\n+            // `try_initialize` for more information.\n+            //\n+            // The caller must ensure no mutable references are ever active to\n+            // the inner cell or the inner T when this is called.\n+            // The `try_initialize` is dependant on the passed `init` function\n+            // for this.\n+            unsafe {\n+                match self.inner.get() {\n+                    Some(val) => Some(val),\n+                    None => self.try_initialize(init),\n+                }\n+            }\n+        }\n+\n+        // `try_initialize` is only called once per fast thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        //\n+        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n+        // be performed for every call to `Key::get`.\n+        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n+        #[inline(never)]\n+        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n+            // SAFETY: See comment above (this function doc).\n+            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n+                // SAFETY: See comment above (this function doc).\n+                Some(unsafe { self.inner.initialize(init) })\n+            } else {\n+                None\n+            }\n+        }\n+\n+        // `try_register_dtor` is only called once per fast thread local\n+        // variable, except in corner cases where thread_local dtors reference\n+        // other thread_local's, or it is being recursively initialized.\n+        unsafe fn try_register_dtor(&self) -> bool {\n+            match self.dtor_state.get() {\n+                DtorState::Unregistered => {\n+                    // SAFETY: dtor registration happens before initialization.\n+                    // Passing `self` as a pointer while using `destroy_value<T>`\n+                    // is safe because the function will build a pointer to a\n+                    // Key<T>, which is the type of self and so find the correct\n+                    // size.\n+                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n+                    self.dtor_state.set(DtorState::Registered);\n+                    true\n+                }\n+                DtorState::Registered => {\n+                    // recursively initialized\n+                    true\n+                }\n+                DtorState::RunningOrHasRun => false,\n+            }\n+        }\n+    }\n+\n+    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n+        let ptr = ptr as *mut Key<T>;\n+\n+        // SAFETY:\n+        //\n+        // The pointer `ptr` has been built just above and comes from\n+        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n+        // making it non-NUL and of the correct type.\n+        //\n+        // Right before we run the user destructor be sure to set the\n+        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n+        // causes future calls to `get` to run `try_initialize_drop` again,\n+        // which will now fail, and return `None`.\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n+            let value = (*ptr).inner.take();\n+            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n+            drop(value);\n+        })) {\n+            rtabort!(\"thread local panicked on drop\");\n+        }\n+    }\n+}"}, {"sha": "1fee84a04349cde2d2382f9c484ff725f457161e", "filename": "library/std/src/sys/common/thread_local/mod.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fmod.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,109 @@\n+//! The following module declarations are outside cfg_if because the internal\n+//! `__thread_local_internal` macro does not seem to be exported properly when using cfg_if\n+#![unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n+\n+#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))]\n+mod fast_local;\n+#[cfg(all(\n+    not(target_thread_local),\n+    not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))\n+))]\n+mod os_local;\n+#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n+mod static_local;\n+\n+#[cfg(not(test))]\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))] {\n+        #[doc(hidden)]\n+        pub use static_local::statik::Key;\n+    } else if #[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        #[doc(hidden)]\n+        pub use fast_local::fast::Key;\n+    } else if #[cfg(all(not(target_thread_local), not(all(target_family = \"wasm\", not(target_feature = \"atomics\")))))] {\n+        #[doc(hidden)]\n+        pub use os_local::os::Key;\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[cfg(test)]\n+pub use realstd::thread::__LocalKeyInner as Key;\n+\n+mod lazy {\n+    use crate::cell::UnsafeCell;\n+    use crate::hint;\n+    use crate::mem;\n+\n+    pub struct LazyKeyInner<T> {\n+        inner: UnsafeCell<Option<T>>,\n+    }\n+\n+    impl<T> LazyKeyInner<T> {\n+        pub const fn new() -> LazyKeyInner<T> {\n+            LazyKeyInner { inner: UnsafeCell::new(None) }\n+        }\n+\n+        pub unsafe fn get(&self) -> Option<&'static T> {\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            unsafe { (*self.inner.get()).as_ref() }\n+        }\n+\n+        /// The caller must ensure that no reference is active: this method\n+        /// needs unique access.\n+        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n+            // Execute the initialization up front, *then* move it into our slot,\n+            // just in case initialization fails.\n+            let value = init();\n+            let ptr = self.inner.get();\n+\n+            // SAFETY:\n+            //\n+            // note that this can in theory just be `*ptr = Some(value)`, but due to\n+            // the compiler will currently codegen that pattern with something like:\n+            //\n+            //      ptr::drop_in_place(ptr)\n+            //      ptr::write(ptr, Some(value))\n+            //\n+            // Due to this pattern it's possible for the destructor of the value in\n+            // `ptr` (e.g., if this is being recursively initialized) to re-access\n+            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n+            // value (an aliasing violation). To avoid setting the \"I'm running a\n+            // destructor\" flag we just use `mem::replace` which should sequence the\n+            // operations a little differently and make this safe to call.\n+            //\n+            // The precondition also ensures that we are the only one accessing\n+            // `self` at the moment so replacing is fine.\n+            unsafe {\n+                let _ = mem::replace(&mut *ptr, Some(value));\n+            }\n+\n+            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n+            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n+            // will never be reached.\n+            unsafe {\n+                // After storing `Some` we want to get a reference to the contents of\n+                // what we just stored. While we could use `unwrap` here and it should\n+                // always work it empirically doesn't seem to always get optimized away,\n+                // which means that using something like `try_with` can pull in\n+                // panicking code and cause a large size bloat.\n+                match *ptr {\n+                    Some(ref x) => x,\n+                    None => hint::unreachable_unchecked(),\n+                }\n+            }\n+        }\n+\n+        /// The other methods hand out references while taking &self.\n+        /// As such, callers of this method must ensure no `&` and `&mut` are\n+        /// available and used at the same time.\n+        #[allow(unused)]\n+        pub unsafe fn take(&mut self) -> Option<T> {\n+            // SAFETY: See doc comment for this method.\n+            unsafe { (*self.inner.get()).take() }\n+        }\n+    }\n+}"}, {"sha": "6f6560c4aa94998708483a73ed2c43117a7df2d2", "filename": "library/std/src/sys/common/thread_local/os_local.rs", "status": "added", "additions": 217, "deletions": 0, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fos_local.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,217 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[cfg_attr(not(windows), inline)] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+                        // On platforms without `#[thread_local]` we fall back to the\n+            // same implementation as below for os thread locals.\n+            #[inline]\n+            const fn __init() -> $t { INIT_EXPR }\n+            static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                $crate::thread::__LocalKeyInner::new();\n+            #[allow(unused_unsafe)]\n+            unsafe {\n+                __KEY.get(move || {\n+                    if let $crate::option::Option::Some(init) = _init {\n+                        if let $crate::option::Option::Some(value) = init.take() {\n+                            return value;\n+                        } else if $crate::cfg!(debug_assertions) {\n+                            $crate::unreachable!(\"missing initial value\");\n+                        }\n+                    }\n+                    __init()\n+                })\n+            }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+\n+            // When reading this function you might ask \"why is this inlined\n+            // everywhere other than Windows?\", and that's a very reasonable\n+            // question to ask. The short story is that it segfaults rustc if\n+            // this function is inlined. The longer story is that Windows looks\n+            // to not support `extern` references to thread locals across DLL\n+            // boundaries. This appears to at least not be supported in the ABI\n+            // that LLVM implements.\n+            //\n+            // Because of this we never inline on Windows, but we do inline on\n+            // other platforms (where external references to thread locals\n+            // across DLLs are supported). A better fix for this would be to\n+            // inline this function on Windows, but only for \"statically linked\"\n+            // components. For example if two separately compiled rlibs end up\n+            // getting linked into a DLL then it's fine to inline this function\n+            // across that boundary. It's only not fine to inline this function\n+            // across a DLL boundary. Unfortunately rustc doesn't currently\n+            // have this sort of logic available in an attribute, and it's not\n+            // clear that rustc is even equipped to answer this (it's more of a\n+            // Cargo question kinda). This means that, unfortunately, Windows\n+            // gets the pessimistic path for now where it's never inlined.\n+            //\n+            // The issue of \"should enable on Windows sometimes\" is #84933\n+            #[cfg_attr(not(windows), inline)]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub mod os {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::cell::Cell;\n+    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n+    use crate::{fmt, marker, panic, ptr};\n+\n+    /// Use a regular global static to store this key; the state provided will then be\n+    /// thread-local.\n+    pub struct Key<T> {\n+        // OS-TLS key that we'll use to key off.\n+        os: OsStaticKey,\n+        marker: marker::PhantomData<Cell<T>>,\n+    }\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    unsafe impl<T> Sync for Key<T> {}\n+\n+    struct Value<T: 'static> {\n+        inner: LazyKeyInner<T>,\n+        key: &'static Key<T>,\n+    }\n+\n+    impl<T: 'static> Key<T> {\n+        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n+        pub const fn new() -> Key<T> {\n+            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n+        }\n+\n+        /// It is a requirement for the caller to ensure that no mutable\n+        /// reference is active when this method is called.\n+        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: See the documentation for this method.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n+            if ptr.addr() > 1 {\n+                // SAFETY: the check ensured the pointer is safe (its destructor\n+                // is not running) + it is coming from a trusted source (self).\n+                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n+                    return Some(value);\n+                }\n+            }\n+            // SAFETY: At this point we are sure we have no value and so\n+            // initializing (or trying to) is safe.\n+            unsafe { self.try_initialize(init) }\n+        }\n+\n+        // `try_initialize` is only called once per os thread local variable,\n+        // except in corner cases where thread_local dtors reference other\n+        // thread_local's, or it is being recursively initialized.\n+        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: No mutable references are ever handed out meaning getting\n+            // the value is ok.\n+            let ptr = unsafe { self.os.get() as *mut Value<T> };\n+            if ptr.addr() == 1 {\n+                // destructor is running\n+                return None;\n+            }\n+\n+            let ptr = if ptr.is_null() {\n+                // If the lookup returned null, we haven't initialized our own\n+                // local copy, so do that now.\n+                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n+                // SAFETY: At this point we are sure there is no value inside\n+                // ptr so setting it will not affect anyone else.\n+                unsafe {\n+                    self.os.set(ptr as *mut u8);\n+                }\n+                ptr\n+            } else {\n+                // recursive initialization\n+                ptr\n+            };\n+\n+            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n+            // dereferenced safely.\n+            unsafe { Some((*ptr).inner.initialize(init)) }\n+        }\n+    }\n+\n+    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n+        // SAFETY:\n+        //\n+        // The OS TLS ensures that this key contains a null value when this\n+        // destructor starts to run. We set it back to a sentinel value of 1 to\n+        // ensure that any future calls to `get` for this thread will return\n+        // `None`.\n+        //\n+        // Note that to prevent an infinite loop we reset it back to null right\n+        // before we return from the destructor ourselves.\n+        //\n+        // Wrap the call in a catch to ensure unwinding is caught in the event\n+        // a panic takes place in a destructor.\n+        if let Err(_) = panic::catch_unwind(|| unsafe {\n+            let ptr = Box::from_raw(ptr as *mut Value<T>);\n+            let key = ptr.key;\n+            key.os.set(ptr::invalid_mut(1));\n+            drop(ptr);\n+            key.os.set(ptr::null_mut());\n+        }) {\n+            rtabort!(\"thread local panicked on drop\");\n+        }\n+    }\n+}"}, {"sha": "ec4f2a12b7ee4a277412b40a1abefa88a87b3da5", "filename": "library/std/src/sys/common/thread_local/static_local.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcommon%2Fthread_local%2Fstatic_local.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,115 @@\n+#[doc(hidden)]\n+#[macro_export]\n+#[allow_internal_unstable(\n+    thread_local_internals,\n+    cfg_target_thread_local,\n+    thread_local,\n+    libstd_thread_internals\n+)]\n+#[allow_internal_unsafe]\n+macro_rules! __thread_local_inner {\n+    // used to generate the `LocalKey` value for const-initialized thread locals\n+    (@key $t:ty, const $init:expr) => {{\n+        #[inline] // see comments below\n+        #[deny(unsafe_op_in_unsafe_fn)]\n+        unsafe fn __getit(\n+            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+        ) -> $crate::option::Option<&'static $t> {\n+            const INIT_EXPR: $t = $init;\n+\n+            // wasm without atomics maps directly to `static mut`, and dtors\n+            // aren't implemented because thread dtors aren't really a thing\n+            // on wasm right now\n+            //\n+            // FIXME(#84224) this should come after the `target_thread_local`\n+            // block.\n+            static mut VAL: $t = INIT_EXPR;\n+            unsafe { $crate::option::Option::Some(&VAL) }\n+        }\n+\n+        unsafe {\n+            $crate::thread::LocalKey::new(__getit)\n+        }\n+    }};\n+\n+    // used to generate the `LocalKey` value for `thread_local!`\n+    (@key $t:ty, $init:expr) => {\n+        {\n+            #[inline]\n+            fn __init() -> $t { $init }\n+            #[inline]\n+            unsafe fn __getit(\n+                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n+            ) -> $crate::option::Option<&'static $t> {\n+                static __KEY: $crate::thread::__LocalKeyInner<$t> =\n+                    $crate::thread::__LocalKeyInner::new();\n+\n+                // FIXME: remove the #[allow(...)] marker when macros don't\n+                // raise warning for missing/extraneous unsafe blocks anymore.\n+                // See https://github.com/rust-lang/rust/issues/74838.\n+                #[allow(unused_unsafe)]\n+                unsafe {\n+                    __KEY.get(move || {\n+                        if let $crate::option::Option::Some(init) = init {\n+                            if let $crate::option::Option::Some(value) = init.take() {\n+                                return value;\n+                            } else if $crate::cfg!(debug_assertions) {\n+                                $crate::unreachable!(\"missing default value\");\n+                            }\n+                        }\n+                        __init()\n+                    })\n+                }\n+            }\n+\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit)\n+            }\n+        }\n+    };\n+    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n+        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n+            $crate::__thread_local_inner!(@key $t, $($init)*);\n+    }\n+}\n+\n+/// On some targets like wasm there's no threads, so no need to generate\n+/// thread locals and we can instead just use plain statics!\n+#[doc(hidden)]\n+pub mod statik {\n+    use super::super::lazy::LazyKeyInner;\n+    use crate::fmt;\n+\n+    pub struct Key<T> {\n+        inner: LazyKeyInner<T>,\n+    }\n+\n+    unsafe impl<T> Sync for Key<T> {}\n+\n+    impl<T> fmt::Debug for Key<T> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            f.debug_struct(\"Key\").finish_non_exhaustive()\n+        }\n+    }\n+\n+    impl<T> Key<T> {\n+        pub const fn new() -> Key<T> {\n+            Key { inner: LazyKeyInner::new() }\n+        }\n+\n+        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n+            // SAFETY: The caller must ensure no reference is ever handed out to\n+            // the inner cell nor mutable reference to the Option<T> inside said\n+            // cell. This make it safe to hand a reference, though the lifetime\n+            // of 'static is itself unsafe, making the get method unsafe.\n+            let value = unsafe {\n+                match self.inner.get() {\n+                    Some(ref value) => value,\n+                    None => self.inner.initialize(init),\n+                }\n+            };\n+\n+            Some(value)\n+        }\n+    }\n+}"}, {"sha": "7fdf03acc14d92c0c716122469a1ee86bc7c5b2f", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 0, "deletions": 567, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -173,200 +173,6 @@ macro_rules! thread_local {\n     );\n }\n \n-#[doc(hidden)]\n-#[unstable(feature = \"thread_local_internals\", reason = \"should not be necessary\", issue = \"none\")]\n-#[macro_export]\n-#[allow_internal_unstable(thread_local_internals, cfg_target_thread_local, thread_local)]\n-#[allow_internal_unsafe]\n-macro_rules! __thread_local_inner {\n-    // used to generate the `LocalKey` value for const-initialized thread locals\n-    (@key $t:ty, const $init:expr) => {{\n-        #[cfg_attr(not(windows), inline)] // see comments below\n-        #[deny(unsafe_op_in_unsafe_fn)]\n-        unsafe fn __getit(\n-            _init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-        ) -> $crate::option::Option<&'static $t> {\n-            const INIT_EXPR: $t = $init;\n-\n-            // wasm without atomics maps directly to `static mut`, and dtors\n-            // aren't implemented because thread dtors aren't really a thing\n-            // on wasm right now\n-            //\n-            // FIXME(#84224) this should come after the `target_thread_local`\n-            // block.\n-            #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-            {\n-                static mut VAL: $t = INIT_EXPR;\n-                unsafe { $crate::option::Option::Some(&VAL) }\n-            }\n-\n-            // If the platform has support for `#[thread_local]`, use it.\n-            #[cfg(all(\n-                target_thread_local,\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[thread_local]\n-                static mut VAL: $t = INIT_EXPR;\n-\n-                // If a dtor isn't needed we can do something \"very raw\" and\n-                // just get going.\n-                if !$crate::mem::needs_drop::<$t>() {\n-                    unsafe {\n-                        return $crate::option::Option::Some(&VAL)\n-                    }\n-                }\n-\n-                // 0 == dtor not registered\n-                // 1 == dtor registered, dtor not run\n-                // 2 == dtor registered and is running or has run\n-                #[thread_local]\n-                static mut STATE: $crate::primitive::u8 = 0;\n-\n-                unsafe extern \"C\" fn destroy(ptr: *mut $crate::primitive::u8) {\n-                    let ptr = ptr as *mut $t;\n-\n-                    unsafe {\n-                        $crate::debug_assert_eq!(STATE, 1);\n-                        STATE = 2;\n-                        $crate::ptr::drop_in_place(ptr);\n-                    }\n-                }\n-\n-                unsafe {\n-                    match STATE {\n-                        // 0 == we haven't registered a destructor, so do\n-                        //   so now.\n-                        0 => {\n-                            $crate::thread::__FastLocalKeyInner::<$t>::register_dtor(\n-                                $crate::ptr::addr_of_mut!(VAL) as *mut $crate::primitive::u8,\n-                                destroy,\n-                            );\n-                            STATE = 1;\n-                            $crate::option::Option::Some(&VAL)\n-                        }\n-                        // 1 == the destructor is registered and the value\n-                        //   is valid, so return the pointer.\n-                        1 => $crate::option::Option::Some(&VAL),\n-                        // otherwise the destructor has already run, so we\n-                        // can't give access.\n-                        _ => $crate::option::Option::None,\n-                    }\n-                }\n-            }\n-\n-            // On platforms without `#[thread_local]` we fall back to the\n-            // same implementation as below for os thread locals.\n-            #[cfg(all(\n-                not(target_thread_local),\n-                not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-            ))]\n-            {\n-                #[inline]\n-                const fn __init() -> $t { INIT_EXPR }\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = _init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing initial value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-        }\n-\n-        unsafe {\n-            $crate::thread::LocalKey::new(__getit)\n-        }\n-    }};\n-\n-    // used to generate the `LocalKey` value for `thread_local!`\n-    (@key $t:ty, $init:expr) => {\n-        {\n-            #[inline]\n-            fn __init() -> $t { $init }\n-\n-            // When reading this function you might ask \"why is this inlined\n-            // everywhere other than Windows?\", and that's a very reasonable\n-            // question to ask. The short story is that it segfaults rustc if\n-            // this function is inlined. The longer story is that Windows looks\n-            // to not support `extern` references to thread locals across DLL\n-            // boundaries. This appears to at least not be supported in the ABI\n-            // that LLVM implements.\n-            //\n-            // Because of this we never inline on Windows, but we do inline on\n-            // other platforms (where external references to thread locals\n-            // across DLLs are supported). A better fix for this would be to\n-            // inline this function on Windows, but only for \"statically linked\"\n-            // components. For example if two separately compiled rlibs end up\n-            // getting linked into a DLL then it's fine to inline this function\n-            // across that boundary. It's only not fine to inline this function\n-            // across a DLL boundary. Unfortunately rustc doesn't currently\n-            // have this sort of logic available in an attribute, and it's not\n-            // clear that rustc is even equipped to answer this (it's more of a\n-            // Cargo question kinda). This means that, unfortunately, Windows\n-            // gets the pessimistic path for now where it's never inlined.\n-            //\n-            // The issue of \"should enable on Windows sometimes\" is #84933\n-            #[cfg_attr(not(windows), inline)]\n-            unsafe fn __getit(\n-                init: $crate::option::Option<&mut $crate::option::Option<$t>>,\n-            ) -> $crate::option::Option<&'static $t> {\n-                #[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-                static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n-                    $crate::thread::__StaticLocalKeyInner::new();\n-\n-                #[thread_local]\n-                #[cfg(all(\n-                    target_thread_local,\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n-                    $crate::thread::__FastLocalKeyInner::new();\n-\n-                #[cfg(all(\n-                    not(target_thread_local),\n-                    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-                ))]\n-                static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n-                    $crate::thread::__OsLocalKeyInner::new();\n-\n-                // FIXME: remove the #[allow(...)] marker when macros don't\n-                // raise warning for missing/extraneous unsafe blocks anymore.\n-                // See https://github.com/rust-lang/rust/issues/74838.\n-                #[allow(unused_unsafe)]\n-                unsafe {\n-                    __KEY.get(move || {\n-                        if let $crate::option::Option::Some(init) = init {\n-                            if let $crate::option::Option::Some(value) = init.take() {\n-                                return value;\n-                            } else if $crate::cfg!(debug_assertions) {\n-                                $crate::unreachable!(\"missing default value\");\n-                            }\n-                        }\n-                        __init()\n-                    })\n-                }\n-            }\n-\n-            unsafe {\n-                $crate::thread::LocalKey::new(__getit)\n-            }\n-        }\n-    };\n-    ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $($init:tt)*) => {\n-        $(#[$attr])* $vis const $name: $crate::thread::LocalKey<$t> =\n-            $crate::__thread_local_inner!(@key $t, $($init)*);\n-    }\n-}\n-\n /// An error returned by [`LocalKey::try_with`](struct.LocalKey.html#method.try_with).\n #[stable(feature = \"thread_local_try_with\", since = \"1.26.0\")]\n #[non_exhaustive]\n@@ -779,376 +585,3 @@ impl<T: 'static> LocalKey<RefCell<T>> {\n         self.with(|cell| cell.replace(value))\n     }\n }\n-\n-mod lazy {\n-    use crate::cell::UnsafeCell;\n-    use crate::hint;\n-    use crate::mem;\n-\n-    pub struct LazyKeyInner<T> {\n-        inner: UnsafeCell<Option<T>>,\n-    }\n-\n-    impl<T> LazyKeyInner<T> {\n-        pub const fn new() -> LazyKeyInner<T> {\n-            LazyKeyInner { inner: UnsafeCell::new(None) }\n-        }\n-\n-        pub unsafe fn get(&self) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            unsafe { (*self.inner.get()).as_ref() }\n-        }\n-\n-        /// The caller must ensure that no reference is active: this method\n-        /// needs unique access.\n-        pub unsafe fn initialize<F: FnOnce() -> T>(&self, init: F) -> &'static T {\n-            // Execute the initialization up front, *then* move it into our slot,\n-            // just in case initialization fails.\n-            let value = init();\n-            let ptr = self.inner.get();\n-\n-            // SAFETY:\n-            //\n-            // note that this can in theory just be `*ptr = Some(value)`, but due to\n-            // the compiler will currently codegen that pattern with something like:\n-            //\n-            //      ptr::drop_in_place(ptr)\n-            //      ptr::write(ptr, Some(value))\n-            //\n-            // Due to this pattern it's possible for the destructor of the value in\n-            // `ptr` (e.g., if this is being recursively initialized) to re-access\n-            // TLS, in which case there will be a `&` and `&mut` pointer to the same\n-            // value (an aliasing violation). To avoid setting the \"I'm running a\n-            // destructor\" flag we just use `mem::replace` which should sequence the\n-            // operations a little differently and make this safe to call.\n-            //\n-            // The precondition also ensures that we are the only one accessing\n-            // `self` at the moment so replacing is fine.\n-            unsafe {\n-                let _ = mem::replace(&mut *ptr, Some(value));\n-            }\n-\n-            // SAFETY: With the call to `mem::replace` it is guaranteed there is\n-            // a `Some` behind `ptr`, not a `None` so `unreachable_unchecked`\n-            // will never be reached.\n-            unsafe {\n-                // After storing `Some` we want to get a reference to the contents of\n-                // what we just stored. While we could use `unwrap` here and it should\n-                // always work it empirically doesn't seem to always get optimized away,\n-                // which means that using something like `try_with` can pull in\n-                // panicking code and cause a large size bloat.\n-                match *ptr {\n-                    Some(ref x) => x,\n-                    None => hint::unreachable_unchecked(),\n-                }\n-            }\n-        }\n-\n-        /// The other methods hand out references while taking &self.\n-        /// As such, callers of this method must ensure no `&` and `&mut` are\n-        /// available and used at the same time.\n-        #[allow(unused)]\n-        pub unsafe fn take(&mut self) -> Option<T> {\n-            // SAFETY: See doc comment for this method.\n-            unsafe { (*self.inner.get()).take() }\n-        }\n-    }\n-}\n-\n-/// On some targets like wasm there's no threads, so no need to generate\n-/// thread locals and we can instead just use plain statics!\n-#[doc(hidden)]\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-pub mod statik {\n-    use super::lazy::LazyKeyInner;\n-    use crate::fmt;\n-\n-    pub struct Key<T> {\n-        inner: LazyKeyInner<T>,\n-    }\n-\n-    unsafe impl<T> Sync for Key<T> {}\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new() }\n-        }\n-\n-        pub unsafe fn get(&self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: The caller must ensure no reference is ever handed out to\n-            // the inner cell nor mutable reference to the Option<T> inside said\n-            // cell. This make it safe to hand a reference, though the lifetime\n-            // of 'static is itself unsafe, making the get method unsafe.\n-            let value = unsafe {\n-                match self.inner.get() {\n-                    Some(ref value) => value,\n-                    None => self.inner.initialize(init),\n-                }\n-            };\n-\n-            Some(value)\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[cfg(all(target_thread_local, not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),))]\n-pub mod fast {\n-    use super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys::thread_local_dtor::register_dtor;\n-    use crate::{fmt, mem, panic};\n-\n-    #[derive(Copy, Clone)]\n-    enum DtorState {\n-        Unregistered,\n-        Registered,\n-        RunningOrHasRun,\n-    }\n-\n-    // This data structure has been carefully constructed so that the fast path\n-    // only contains one branch on x86. That optimization is necessary to avoid\n-    // duplicated tls lookups on OSX.\n-    //\n-    // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-    pub struct Key<T> {\n-        // If `LazyKeyInner::get` returns `None`, that indicates either:\n-        //   * The value has never been initialized\n-        //   * The value is being recursively initialized\n-        //   * The value has already been destroyed or is being destroyed\n-        // To determine which kind of `None`, check `dtor_state`.\n-        //\n-        // This is very optimizer friendly for the fast path - initialized but\n-        // not yet dropped.\n-        inner: LazyKeyInner<T>,\n-\n-        // Metadata to keep track of the state of the destructor. Remember that\n-        // this variable is thread-local, not global.\n-        dtor_state: Cell<DtorState>,\n-    }\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    impl<T> Key<T> {\n-        pub const fn new() -> Key<T> {\n-            Key { inner: LazyKeyInner::new(), dtor_state: Cell::new(DtorState::Unregistered) }\n-        }\n-\n-        // note that this is just a publicly-callable function only for the\n-        // const-initialized form of thread locals, basically a way to call the\n-        // free `register_dtor` function defined elsewhere in std.\n-        pub unsafe fn register_dtor(a: *mut u8, dtor: unsafe extern \"C\" fn(*mut u8)) {\n-            unsafe {\n-                register_dtor(a, dtor);\n-            }\n-        }\n-\n-        pub unsafe fn get<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See the definitions of `LazyKeyInner::get` and\n-            // `try_initialize` for more information.\n-            //\n-            // The caller must ensure no mutable references are ever active to\n-            // the inner cell or the inner T when this is called.\n-            // The `try_initialize` is dependant on the passed `init` function\n-            // for this.\n-            unsafe {\n-                match self.inner.get() {\n-                    Some(val) => Some(val),\n-                    None => self.try_initialize(init),\n-                }\n-            }\n-        }\n-\n-        // `try_initialize` is only called once per fast thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        //\n-        // Macos: Inlining this function can cause two `tlv_get_addr` calls to\n-        // be performed for every call to `Key::get`.\n-        // LLVM issue: https://bugs.llvm.org/show_bug.cgi?id=41722\n-        #[inline(never)]\n-        unsafe fn try_initialize<F: FnOnce() -> T>(&self, init: F) -> Option<&'static T> {\n-            // SAFETY: See comment above (this function doc).\n-            if !mem::needs_drop::<T>() || unsafe { self.try_register_dtor() } {\n-                // SAFETY: See comment above (this function doc).\n-                Some(unsafe { self.inner.initialize(init) })\n-            } else {\n-                None\n-            }\n-        }\n-\n-        // `try_register_dtor` is only called once per fast thread local\n-        // variable, except in corner cases where thread_local dtors reference\n-        // other thread_local's, or it is being recursively initialized.\n-        unsafe fn try_register_dtor(&self) -> bool {\n-            match self.dtor_state.get() {\n-                DtorState::Unregistered => {\n-                    // SAFETY: dtor registration happens before initialization.\n-                    // Passing `self` as a pointer while using `destroy_value<T>`\n-                    // is safe because the function will build a pointer to a\n-                    // Key<T>, which is the type of self and so find the correct\n-                    // size.\n-                    unsafe { register_dtor(self as *const _ as *mut u8, destroy_value::<T>) };\n-                    self.dtor_state.set(DtorState::Registered);\n-                    true\n-                }\n-                DtorState::Registered => {\n-                    // recursively initialized\n-                    true\n-                }\n-                DtorState::RunningOrHasRun => false,\n-            }\n-        }\n-    }\n-\n-    unsafe extern \"C\" fn destroy_value<T>(ptr: *mut u8) {\n-        let ptr = ptr as *mut Key<T>;\n-\n-        // SAFETY:\n-        //\n-        // The pointer `ptr` has been built just above and comes from\n-        // `try_register_dtor` where it is originally a Key<T> coming from `self`,\n-        // making it non-NUL and of the correct type.\n-        //\n-        // Right before we run the user destructor be sure to set the\n-        // `Option<T>` to `None`, and `dtor_state` to `RunningOrHasRun`. This\n-        // causes future calls to `get` to run `try_initialize_drop` again,\n-        // which will now fail, and return `None`.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(panic::AssertUnwindSafe(|| unsafe {\n-            let value = (*ptr).inner.take();\n-            (*ptr).dtor_state.set(DtorState::RunningOrHasRun);\n-            drop(value);\n-        })) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub mod os {\n-    use super::lazy::LazyKeyInner;\n-    use crate::cell::Cell;\n-    use crate::sys_common::thread_local_key::StaticKey as OsStaticKey;\n-    use crate::{fmt, marker, panic, ptr};\n-\n-    /// Use a regular global static to store this key; the state provided will then be\n-    /// thread-local.\n-    pub struct Key<T> {\n-        // OS-TLS key that we'll use to key off.\n-        os: OsStaticKey,\n-        marker: marker::PhantomData<Cell<T>>,\n-    }\n-\n-    impl<T> fmt::Debug for Key<T> {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Key\").finish_non_exhaustive()\n-        }\n-    }\n-\n-    unsafe impl<T> Sync for Key<T> {}\n-\n-    struct Value<T: 'static> {\n-        inner: LazyKeyInner<T>,\n-        key: &'static Key<T>,\n-    }\n-\n-    impl<T: 'static> Key<T> {\n-        #[rustc_const_unstable(feature = \"thread_local_internals\", issue = \"none\")]\n-        pub const fn new() -> Key<T> {\n-            Key { os: OsStaticKey::new(Some(destroy_value::<T>)), marker: marker::PhantomData }\n-        }\n-\n-        /// It is a requirement for the caller to ensure that no mutable\n-        /// reference is active when this method is called.\n-        pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: See the documentation for this method.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() > 1 {\n-                // SAFETY: the check ensured the pointer is safe (its destructor\n-                // is not running) + it is coming from a trusted source (self).\n-                if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n-                    return Some(value);\n-                }\n-            }\n-            // SAFETY: At this point we are sure we have no value and so\n-            // initializing (or trying to) is safe.\n-            unsafe { self.try_initialize(init) }\n-        }\n-\n-        // `try_initialize` is only called once per os thread local variable,\n-        // except in corner cases where thread_local dtors reference other\n-        // thread_local's, or it is being recursively initialized.\n-        unsafe fn try_initialize(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n-            // SAFETY: No mutable references are ever handed out meaning getting\n-            // the value is ok.\n-            let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr.addr() == 1 {\n-                // destructor is running\n-                return None;\n-            }\n-\n-            let ptr = if ptr.is_null() {\n-                // If the lookup returned null, we haven't initialized our own\n-                // local copy, so do that now.\n-                let ptr = Box::into_raw(Box::new(Value { inner: LazyKeyInner::new(), key: self }));\n-                // SAFETY: At this point we are sure there is no value inside\n-                // ptr so setting it will not affect anyone else.\n-                unsafe {\n-                    self.os.set(ptr as *mut u8);\n-                }\n-                ptr\n-            } else {\n-                // recursive initialization\n-                ptr\n-            };\n-\n-            // SAFETY: ptr has been ensured as non-NUL just above an so can be\n-            // dereferenced safely.\n-            unsafe { Some((*ptr).inner.initialize(init)) }\n-        }\n-    }\n-\n-    unsafe extern \"C\" fn destroy_value<T: 'static>(ptr: *mut u8) {\n-        // SAFETY:\n-        //\n-        // The OS TLS ensures that this key contains a null value when this\n-        // destructor starts to run. We set it back to a sentinel value of 1 to\n-        // ensure that any future calls to `get` for this thread will return\n-        // `None`.\n-        //\n-        // Note that to prevent an infinite loop we reset it back to null right\n-        // before we return from the destructor ourselves.\n-        //\n-        // Wrap the call in a catch to ensure unwinding is caught in the event\n-        // a panic takes place in a destructor.\n-        if let Err(_) = panic::catch_unwind(|| unsafe {\n-            let ptr = Box::from_raw(ptr as *mut Value<T>);\n-            let key = ptr.key;\n-            key.os.set(ptr::invalid_mut(1));\n-            drop(ptr);\n-            key.os.set(ptr::null_mut());\n-        }) {\n-            rtabort!(\"thread local panicked on drop\");\n-        }\n-    }\n-}"}, {"sha": "b9aaf5f6e15dbb58571c3f68f30d7d71609c17f7", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -203,44 +203,9 @@ pub use self::local::{AccessError, LocalKey};\n // by the elf linker. \"static\" is for single-threaded platforms where a global\n // static is sufficient.\n \n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(not(test))]\n-#[cfg(all(\n-    target_thread_local,\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-#[doc(hidden)]\n-pub use self::local::fast::Key as __FastLocalKeyInner;\n-// when building for tests, use real std's type\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(test)]\n-#[cfg(all(\n-    target_thread_local,\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub use realstd::thread::__FastLocalKeyInner;\n-\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(not(test))]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n #[doc(hidden)]\n-pub use self::local::os::Key as __OsLocalKeyInner;\n-// when building for tests, use real std's type\n-#[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(test)]\n-#[cfg(all(\n-    not(target_thread_local),\n-    not(all(target_family = \"wasm\", not(target_feature = \"atomics\"))),\n-))]\n-pub use realstd::thread::__OsLocalKeyInner;\n-\n #[unstable(feature = \"libstd_thread_internals\", issue = \"none\")]\n-#[cfg(all(target_family = \"wasm\", not(target_feature = \"atomics\")))]\n-#[doc(hidden)]\n-pub use self::local::statik::Key as __StaticLocalKeyInner;\n+pub use crate::sys::common::thread_local::Key as __LocalKeyInner;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Builder"}, {"sha": "0295de8437ef195f9367e09508e77162eb377917", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -346,6 +346,7 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                                     self.cache,\n                                 ),\n                                 aliases: item.attrs.get_doc_aliases(),\n+                                deprecation: item.deprecation(self.tcx),\n                             });\n                         }\n                     }"}, {"sha": "63cd0e04a288a26bab74ae79b4f315e4a4ef0385", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -17,10 +17,11 @@ use super::print_item::{full_path, item_path, print_item};\n use super::search_index::build_index;\n use super::write_shared::write_shared;\n use super::{\n-    collect_spans_and_sources, print_sidebar, scrape_examples_help, sidebar_module_like, AllTypes,\n-    LinkFromSrc, StylePath,\n+    collect_spans_and_sources, scrape_examples_help,\n+    sidebar::print_sidebar,\n+    sidebar::{sidebar_module_like, Sidebar},\n+    AllTypes, LinkFromSrc, StylePath,\n };\n-\n use crate::clean::{self, types::ExternalLocation, ExternalCrate};\n use crate::config::{ModuleSorting, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n@@ -35,6 +36,7 @@ use crate::html::url_parts_builder::UrlPartsBuilder;\n use crate::html::{layout, sources, static_files};\n use crate::scrape_examples::AllCallLocations;\n use crate::try_err;\n+use askama::Template;\n \n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n@@ -600,15 +602,18 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         };\n         let all = shared.all.replace(AllTypes::new());\n         let mut sidebar = Buffer::html();\n-        write!(sidebar, \"<h2 class=\\\"location\\\"><a href=\\\"#\\\">Crate {}</a></h2>\", crate_name);\n-\n-        let mut items = Buffer::html();\n-        sidebar_module_like(&mut items, all.item_sections());\n-        if !items.is_empty() {\n-            sidebar.push_str(\"<div class=\\\"sidebar-elems\\\">\");\n-            sidebar.push_buffer(items);\n-            sidebar.push_str(\"</div>\");\n-        }\n+\n+        let blocks = sidebar_module_like(all.item_sections());\n+        let bar = Sidebar {\n+            title_prefix: \"Crate \",\n+            title: crate_name.as_str(),\n+            is_crate: false,\n+            version: \"\",\n+            blocks: vec![blocks],\n+            path: String::new(),\n+        };\n+\n+        bar.render_into(&mut sidebar).unwrap();\n \n         let v = layout::render(\n             &shared.layout,"}, {"sha": "da1f1cf5eccfc4c0252b310dc5e8bb66857b82bb", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 57, "deletions": 676, "changes": 733, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -30,6 +30,7 @@ mod tests;\n \n mod context;\n mod print_item;\n+mod sidebar;\n mod span_map;\n mod write_shared;\n \n@@ -46,14 +47,13 @@ use std::rc::Rc;\n use std::str;\n use std::string::ToString;\n \n+use askama::Template;\n use rustc_ast_pretty::pprust;\n use rustc_attr::{ConstStability, Deprecation, StabilityLevel};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::{\n     symbol::{sym, Symbol},\n@@ -104,6 +104,7 @@ pub(crate) struct IndexItem {\n     pub(crate) parent_idx: Option<usize>,\n     pub(crate) search_type: Option<IndexItemFunctionType>,\n     pub(crate) aliases: Box<[Symbol]>,\n+    pub(crate) deprecation: Option<Deprecation>,\n }\n \n /// A type used for the search index.\n@@ -417,7 +418,7 @@ fn document(\n     if let Some(ref name) = item.name {\n         info!(\"Documenting {}\", name);\n     }\n-    document_item_info(w, cx, item, parent);\n+    document_item_info(cx, item, parent).render_into(w).unwrap();\n     if parent.is_none() {\n         document_full_collapsible(w, item, cx, heading_offset);\n     } else {\n@@ -459,7 +460,7 @@ fn document_short(\n     parent: &clean::Item,\n     show_def_docs: bool,\n ) {\n-    document_item_info(w, cx, item, Some(parent));\n+    document_item_info(cx, item, Some(parent)).render_into(w).unwrap();\n     if !show_def_docs {\n         return;\n     }\n@@ -531,25 +532,23 @@ fn document_full_inner(\n     }\n }\n \n+#[derive(Template)]\n+#[template(path = \"item_info.html\")]\n+struct ItemInfo {\n+    items: Vec<ShortItemInfo>,\n+}\n /// Add extra information about an item such as:\n ///\n /// * Stability\n /// * Deprecated\n /// * Required features (through the `doc_cfg` feature)\n fn document_item_info(\n-    w: &mut Buffer,\n     cx: &mut Context<'_>,\n     item: &clean::Item,\n     parent: Option<&clean::Item>,\n-) {\n-    let item_infos = short_item_info(item, cx, parent);\n-    if !item_infos.is_empty() {\n-        w.write_str(\"<span class=\\\"item-info\\\">\");\n-        for info in item_infos {\n-            w.write_str(&info);\n-        }\n-        w.write_str(\"</span>\");\n-    }\n+) -> ItemInfo {\n+    let items = short_item_info(item, cx, parent);\n+    ItemInfo { items }\n }\n \n fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<String> {\n@@ -567,7 +566,25 @@ fn portability(item: &clean::Item, parent: Option<&clean::Item>) -> Option<Strin\n         cfg\n     );\n \n-    Some(format!(\"<div class=\\\"stab portability\\\">{}</div>\", cfg?.render_long_html()))\n+    Some(cfg?.render_long_html())\n+}\n+\n+#[derive(Template)]\n+#[template(path = \"short_item_info.html\")]\n+enum ShortItemInfo {\n+    /// A message describing the deprecation of this item\n+    Deprecation {\n+        message: String,\n+    },\n+    /// The feature corresponding to an unstable item, and optionally\n+    /// a tracking issue URL and number.\n+    Unstable {\n+        feature: String,\n+        tracking: Option<(String, u32)>,\n+    },\n+    Portability {\n+        message: String,\n+    },\n }\n \n /// Render the stability, deprecation and portability information that is displayed at the top of\n@@ -576,7 +593,7 @@ fn short_item_info(\n     item: &clean::Item,\n     cx: &mut Context<'_>,\n     parent: Option<&clean::Item>,\n-) -> Vec<String> {\n+) -> Vec<ShortItemInfo> {\n     let mut extra_info = vec![];\n \n     if let Some(depr @ Deprecation { note, since, is_since_rustc_version: _, suggestion: _ }) =\n@@ -602,15 +619,10 @@ fn short_item_info(\n         if let Some(note) = note {\n             let note = note.as_str();\n             let html = MarkdownItemInfo(note, &mut cx.id_map);\n-            message.push_str(&format!(\": {}\", html.into_string()));\n-        }\n-        extra_info.push(format!(\n-            \"<div class=\\\"stab deprecated\\\">\\\n-                 <span class=\\\"emoji\\\">\ud83d\udc4e</span>\\\n-                 <span>{}</span>\\\n-             </div>\",\n-            message,\n-        ));\n+            message.push_str(\": \");\n+            message.push_str(&html.into_string());\n+        }\n+        extra_info.push(ShortItemInfo::Deprecation { message });\n     }\n \n     // Render unstable items. But don't render \"rustc_private\" crates (internal compiler crates).\n@@ -621,26 +633,17 @@ fn short_item_info(\n         .filter(|stab| stab.feature != sym::rustc_private)\n         .map(|stab| (stab.level, stab.feature))\n     {\n-        let mut message = \"<span class=\\\"emoji\\\">\ud83d\udd2c</span>\\\n-             <span>This is a nightly-only experimental API.\"\n-            .to_owned();\n-\n-        let mut feature = format!(\"<code>{}</code>\", Escape(feature.as_str()));\n-        if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, issue) {\n-            feature.push_str(&format!(\n-                \"&nbsp;<a href=\\\"{url}{issue}\\\">#{issue}</a>\",\n-                url = url,\n-                issue = issue\n-            ));\n-        }\n-\n-        message.push_str(&format!(\" ({})</span>\", feature));\n-\n-        extra_info.push(format!(\"<div class=\\\"stab unstable\\\">{}</div>\", message));\n+        let tracking = if let (Some(url), Some(issue)) = (&cx.shared.issue_tracker_base_url, issue)\n+        {\n+            Some((url.clone(), issue.get()))\n+        } else {\n+            None\n+        };\n+        extra_info.push(ShortItemInfo::Unstable { feature: feature.to_string(), tracking });\n     }\n \n-    if let Some(portability) = portability(item, parent) {\n-        extra_info.push(portability);\n+    if let Some(message) = portability(item, parent) {\n+        extra_info.push(ShortItemInfo::Portability { message });\n     }\n \n     extra_info\n@@ -1472,7 +1475,9 @@ fn render_impl(\n                         // We need the stability of the item from the trait\n                         // because impls can't have a stability.\n                         if item.doc_value().is_some() {\n-                            document_item_info(&mut info_buffer, cx, it, Some(parent));\n+                            document_item_info(cx, it, Some(parent))\n+                                .render_into(&mut info_buffer)\n+                                .unwrap();\n                             document_full(&mut doc_buffer, item, cx, HeadingOffset::H5);\n                             short_documented = false;\n                         } else {\n@@ -1489,7 +1494,9 @@ fn render_impl(\n                         }\n                     }\n                 } else {\n-                    document_item_info(&mut info_buffer, cx, item, Some(parent));\n+                    document_item_info(cx, item, Some(parent))\n+                        .render_into(&mut info_buffer)\n+                        .unwrap();\n                     if rendering_params.show_def_docs {\n                         document_full(&mut doc_buffer, item, cx, HeadingOffset::H5);\n                         short_documented = false;\n@@ -1862,161 +1869,17 @@ pub(crate) fn render_impl_summary(\n     let is_trait = inner_impl.trait_.is_some();\n     if is_trait {\n         if let Some(portability) = portability(&i.impl_item, Some(parent)) {\n-            write!(w, \"<span class=\\\"item-info\\\">{}</span>\", portability);\n+            write!(\n+                w,\n+                \"<span class=\\\"item-info\\\"><div class=\\\"stab portability\\\">{}</div></span>\",\n+                portability\n+            );\n         }\n     }\n \n     w.write_str(\"</section>\");\n }\n \n-fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n-    if it.is_struct()\n-        || it.is_trait()\n-        || it.is_primitive()\n-        || it.is_union()\n-        || it.is_enum()\n-        || it.is_mod()\n-        || it.is_typedef()\n-    {\n-        write!(\n-            buffer,\n-            \"<h2 class=\\\"location\\\"><a href=\\\"#\\\">{}{}</a></h2>\",\n-            match *it.kind {\n-                clean::ModuleItem(..) =>\n-                    if it.is_crate() {\n-                        \"Crate \"\n-                    } else {\n-                        \"Module \"\n-                    },\n-                _ => \"\",\n-            },\n-            it.name.as_ref().unwrap()\n-        );\n-    }\n-\n-    buffer.write_str(\"<div class=\\\"sidebar-elems\\\">\");\n-    if it.is_crate() {\n-        write!(buffer, \"<ul class=\\\"block\\\">\");\n-        if let Some(ref version) = cx.cache().crate_version {\n-            write!(buffer, \"<li class=\\\"version\\\">Version {}</li>\", Escape(version));\n-        }\n-        write!(buffer, \"<li><a id=\\\"all-types\\\" href=\\\"all.html\\\">All Items</a></li>\");\n-        buffer.write_str(\"</ul>\");\n-    }\n-\n-    match *it.kind {\n-        clean::StructItem(ref s) => sidebar_struct(cx, buffer, it, s),\n-        clean::TraitItem(ref t) => sidebar_trait(cx, buffer, it, t),\n-        clean::PrimitiveItem(_) => sidebar_primitive(cx, buffer, it),\n-        clean::UnionItem(ref u) => sidebar_union(cx, buffer, it, u),\n-        clean::EnumItem(ref e) => sidebar_enum(cx, buffer, it, e),\n-        clean::TypedefItem(_) => sidebar_typedef(cx, buffer, it),\n-        clean::ModuleItem(ref m) => sidebar_module(buffer, &m.items),\n-        clean::ForeignTypeItem => sidebar_foreign_type(cx, buffer, it),\n-        _ => {}\n-    }\n-\n-    // The sidebar is designed to display sibling functions, modules and\n-    // other miscellaneous information. since there are lots of sibling\n-    // items (and that causes quadratic growth in large modules),\n-    // we refactor common parts into a shared JavaScript file per module.\n-    // still, we don't move everything into JS because we want to preserve\n-    // as much HTML as possible in order to allow non-JS-enabled browsers\n-    // to navigate the documentation (though slightly inefficiently).\n-\n-    if !it.is_mod() {\n-        let path: String = cx.current.iter().map(|s| s.as_str()).intersperse(\"::\").collect();\n-\n-        write!(buffer, \"<h2><a href=\\\"index.html\\\">In {}</a></h2>\", path);\n-    }\n-\n-    // Closes sidebar-elems div.\n-    buffer.write_str(\"</div>\");\n-}\n-\n-fn get_next_url(used_links: &mut FxHashSet<String>, url: String) -> String {\n-    if used_links.insert(url.clone()) {\n-        return url;\n-    }\n-    let mut add = 1;\n-    while !used_links.insert(format!(\"{}-{}\", url, add)) {\n-        add += 1;\n-    }\n-    format!(\"{}-{}\", url, add)\n-}\n-\n-struct SidebarLink {\n-    name: Symbol,\n-    url: String,\n-}\n-\n-impl fmt::Display for SidebarLink {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"<a href=\\\"#{}\\\">{}</a>\", self.url, self.name)\n-    }\n-}\n-\n-impl PartialEq for SidebarLink {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.url == other.url\n-    }\n-}\n-\n-impl Eq for SidebarLink {}\n-\n-impl PartialOrd for SidebarLink {\n-    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for SidebarLink {\n-    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n-        self.url.cmp(&other.url)\n-    }\n-}\n-\n-fn get_methods(\n-    i: &clean::Impl,\n-    for_deref: bool,\n-    used_links: &mut FxHashSet<String>,\n-    deref_mut: bool,\n-    tcx: TyCtxt<'_>,\n-) -> Vec<SidebarLink> {\n-    i.items\n-        .iter()\n-        .filter_map(|item| match item.name {\n-            Some(name) if !name.is_empty() && item.is_method() => {\n-                if !for_deref || should_render_item(item, deref_mut, tcx) {\n-                    Some(SidebarLink {\n-                        name,\n-                        url: get_next_url(used_links, format!(\"{}.{}\", ItemType::Method, name)),\n-                    })\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>()\n-}\n-\n-fn get_associated_constants(\n-    i: &clean::Impl,\n-    used_links: &mut FxHashSet<String>,\n-) -> Vec<SidebarLink> {\n-    i.items\n-        .iter()\n-        .filter_map(|item| match item.name {\n-            Some(name) if !name.is_empty() && item.is_associated_const() => Some(SidebarLink {\n-                name,\n-                url: get_next_url(used_links, format!(\"{}.{}\", ItemType::AssocConst, name)),\n-            }),\n-            _ => None,\n-        })\n-        .collect::<Vec<_>>()\n-}\n-\n pub(crate) fn small_url_encode(s: String) -> String {\n     // These characters don't need to be escaped in a URI.\n     // See https://url.spec.whatwg.org/#query-percent-encode-set\n@@ -2082,232 +1945,6 @@ pub(crate) fn small_url_encode(s: String) -> String {\n     }\n }\n \n-pub(crate) fn sidebar_render_assoc_items(\n-    cx: &Context<'_>,\n-    out: &mut Buffer,\n-    id_map: &mut IdMap,\n-    concrete: Vec<&Impl>,\n-    synthetic: Vec<&Impl>,\n-    blanket_impl: Vec<&Impl>,\n-) {\n-    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n-        let mut links = FxHashSet::default();\n-\n-        let mut ret = impls\n-            .iter()\n-            .filter_map(|it| {\n-                let trait_ = it.inner_impl().trait_.as_ref()?;\n-                let encoded =\n-                    id_map.derive(get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n-\n-                let i_display = format!(\"{:#}\", trait_.print(cx));\n-                let out = Escape(&i_display);\n-                let prefix = match it.inner_impl().polarity {\n-                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n-                    ty::ImplPolarity::Negative => \"!\",\n-                };\n-                let generated = format!(\"<a href=\\\"#{}\\\">{}{}</a>\", encoded, prefix, out);\n-                if links.insert(generated.clone()) { Some(generated) } else { None }\n-            })\n-            .collect::<Vec<String>>();\n-        ret.sort();\n-        ret\n-    };\n-\n-    let concrete_format = format_impls(concrete, id_map);\n-    let synthetic_format = format_impls(synthetic, id_map);\n-    let blanket_format = format_impls(blanket_impl, id_map);\n-\n-    if !concrete_format.is_empty() {\n-        print_sidebar_block(\n-            out,\n-            \"trait-implementations\",\n-            \"Trait Implementations\",\n-            concrete_format.iter(),\n-        );\n-    }\n-\n-    if !synthetic_format.is_empty() {\n-        print_sidebar_block(\n-            out,\n-            \"synthetic-implementations\",\n-            \"Auto Trait Implementations\",\n-            synthetic_format.iter(),\n-        );\n-    }\n-\n-    if !blanket_format.is_empty() {\n-        print_sidebar_block(\n-            out,\n-            \"blanket-implementations\",\n-            \"Blanket Implementations\",\n-            blanket_format.iter(),\n-        );\n-    }\n-}\n-\n-fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n-    let did = it.item_id.expect_def_id();\n-    let cache = cx.cache();\n-\n-    if let Some(v) = cache.impls.get(&did) {\n-        let mut used_links = FxHashSet::default();\n-        let mut id_map = IdMap::new();\n-\n-        {\n-            let used_links_bor = &mut used_links;\n-            let mut assoc_consts = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_associated_constants(i.inner_impl(), used_links_bor))\n-                .collect::<Vec<_>>();\n-            if !assoc_consts.is_empty() {\n-                // We want links' order to be reproducible so we don't use unstable sort.\n-                assoc_consts.sort();\n-\n-                print_sidebar_block(\n-                    out,\n-                    \"implementations\",\n-                    \"Associated Constants\",\n-                    assoc_consts.iter(),\n-                );\n-            }\n-            let mut methods = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), false, used_links_bor, false, cx.tcx()))\n-                .collect::<Vec<_>>();\n-            if !methods.is_empty() {\n-                // We want links' order to be reproducible so we don't use unstable sort.\n-                methods.sort();\n-\n-                print_sidebar_block(out, \"implementations\", \"Methods\", methods.iter());\n-            }\n-        }\n-\n-        if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) =\n-                v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n-            {\n-                let mut derefs = DefIdSet::default();\n-                derefs.insert(did);\n-                sidebar_deref_methods(cx, out, impl_, v, &mut derefs, &mut used_links);\n-            }\n-\n-            let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-                v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n-            let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-                concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n-\n-            sidebar_render_assoc_items(cx, out, &mut id_map, concrete, synthetic, blanket_impl);\n-        }\n-    }\n-}\n-\n-fn sidebar_deref_methods(\n-    cx: &Context<'_>,\n-    out: &mut Buffer,\n-    impl_: &Impl,\n-    v: &[Impl],\n-    derefs: &mut DefIdSet,\n-    used_links: &mut FxHashSet<String>,\n-) {\n-    let c = cx.cache();\n-\n-    debug!(\"found Deref: {:?}\", impl_);\n-    if let Some((target, real_target)) =\n-        impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n-            clean::AssocTypeItem(box ref t, _) => Some(match *t {\n-                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n-                _ => (&t.type_, &t.type_),\n-            }),\n-            _ => None,\n-        })\n-    {\n-        debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n-        if let Some(did) = target.def_id(c) &&\n-            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n-            // `impl Deref<Target = S> for S`\n-            (did == type_did || !derefs.insert(did))\n-        {\n-            // Avoid infinite cycles\n-            return;\n-        }\n-        let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-        let inner_impl = target\n-            .def_id(c)\n-            .or_else(|| {\n-                target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n-            })\n-            .and_then(|did| c.impls.get(&did));\n-        if let Some(impls) = inner_impl {\n-            debug!(\"found inner_impl: {:?}\", impls);\n-            let mut ret = impls\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), true, used_links, deref_mut, cx.tcx()))\n-                .collect::<Vec<_>>();\n-            if !ret.is_empty() {\n-                let id = if let Some(target_def_id) = real_target.def_id(c) {\n-                    cx.deref_id_map.get(&target_def_id).expect(\"Deref section without derived id\")\n-                } else {\n-                    \"deref-methods\"\n-                };\n-                let title = format!(\n-                    \"Methods from {}&lt;Target={}&gt;\",\n-                    Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n-                    Escape(&format!(\"{:#}\", real_target.print(cx))),\n-                );\n-                // We want links' order to be reproducible so we don't use unstable sort.\n-                ret.sort();\n-                print_sidebar_block(out, id, &title, ret.iter());\n-            }\n-        }\n-\n-        // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id(c) &&\n-            let Some(target_impls) = c.impls.get(&target_did) &&\n-            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n-                i.inner_impl()\n-                    .trait_\n-                    .as_ref()\n-                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n-                    .unwrap_or(false)\n-            })\n-        {\n-            sidebar_deref_methods(\n-                cx,\n-                out,\n-                target_deref_impl,\n-                target_impls,\n-                derefs,\n-                used_links,\n-            );\n-        }\n-    }\n-}\n-\n-fn sidebar_struct(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, s: &clean::Struct) {\n-    let mut sidebar = Buffer::new();\n-    let fields = get_struct_fields_name(&s.fields);\n-\n-    if !fields.is_empty() {\n-        match s.ctor_kind {\n-            None => {\n-                print_sidebar_block(&mut sidebar, \"fields\", \"Fields\", fields.iter());\n-            }\n-            Some(CtorKind::Fn) => print_sidebar_title(&mut sidebar, \"fields\", \"Tuple Fields\"),\n-            Some(CtorKind::Const) => {}\n-        }\n-    }\n-\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n fn get_id_for_impl(for_: &clean::Type, trait_: Option<&clean::Path>, cx: &Context<'_>) -> String {\n     match trait_ {\n         Some(t) => small_url_encode(format!(\"impl-{:#}-for-{:#}\", t.print(cx), for_.print(cx))),\n@@ -2328,131 +1965,6 @@ fn extract_for_impl_name(item: &clean::Item, cx: &Context<'_>) -> Option<(String\n     }\n }\n \n-fn print_sidebar_title(buf: &mut Buffer, id: &str, title: &str) {\n-    write!(buf, \"<h3><a href=\\\"#{}\\\">{}</a></h3>\", id, title);\n-}\n-\n-fn print_sidebar_block(\n-    buf: &mut Buffer,\n-    id: &str,\n-    title: &str,\n-    items: impl Iterator<Item = impl fmt::Display>,\n-) {\n-    print_sidebar_title(buf, id, title);\n-    buf.push_str(\"<ul class=\\\"block\\\">\");\n-    for item in items {\n-        write!(buf, \"<li>{}</li>\", item);\n-    }\n-    buf.push_str(\"</ul>\");\n-}\n-\n-fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean::Trait) {\n-    buf.write_str(\"<section>\");\n-\n-    fn print_sidebar_section(\n-        out: &mut Buffer,\n-        items: &[clean::Item],\n-        id: &str,\n-        title: &str,\n-        filter: impl Fn(&clean::Item) -> bool,\n-        mapper: impl Fn(&str) -> String,\n-    ) {\n-        let mut items: Vec<&str> = items\n-            .iter()\n-            .filter_map(|m| match m.name {\n-                Some(ref name) if filter(m) => Some(name.as_str()),\n-                _ => None,\n-            })\n-            .collect::<Vec<_>>();\n-\n-        if !items.is_empty() {\n-            items.sort_unstable();\n-            print_sidebar_block(out, id, title, items.into_iter().map(mapper));\n-        }\n-    }\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"required-associated-types\",\n-        \"Required Associated Types\",\n-        |m| m.is_ty_associated_type(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"provided-associated-types\",\n-        \"Provided Associated Types\",\n-        |m| m.is_associated_type(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocType),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"required-associated-consts\",\n-        \"Required Associated Constants\",\n-        |m| m.is_ty_associated_const(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"provided-associated-consts\",\n-        \"Provided Associated Constants\",\n-        |m| m.is_associated_const(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::AssocConst),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"required-methods\",\n-        \"Required Methods\",\n-        |m| m.is_ty_method(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::TyMethod),\n-    );\n-\n-    print_sidebar_section(\n-        buf,\n-        &t.items,\n-        \"provided-methods\",\n-        \"Provided Methods\",\n-        |m| m.is_method(),\n-        |sym| format!(\"<a href=\\\"#{1}.{0}\\\">{0}</a>\", sym, ItemType::Method),\n-    );\n-\n-    if let Some(implementors) = cx.cache().implementors.get(&it.item_id.expect_def_id()) {\n-        let mut res = implementors\n-            .iter()\n-            .filter(|i| !i.is_on_local_type(cx))\n-            .filter_map(|i| extract_for_impl_name(&i.impl_item, cx))\n-            .collect::<Vec<_>>();\n-\n-        if !res.is_empty() {\n-            res.sort();\n-            print_sidebar_block(\n-                buf,\n-                \"foreign-impls\",\n-                \"Implementations on Foreign Types\",\n-                res.iter().map(|(name, id)| format!(\"<a href=\\\"#{}\\\">{}</a>\", id, Escape(name))),\n-            );\n-        }\n-    }\n-\n-    sidebar_assoc_items(cx, buf, it);\n-\n-    print_sidebar_title(buf, \"implementors\", \"Implementors\");\n-    if t.is_auto(cx.tcx()) {\n-        print_sidebar_title(buf, \"synthetic-implementors\", \"Auto Implementors\");\n-    }\n-\n-    buf.push_str(\"</section>\")\n-}\n-\n /// Returns the list of implementations for the primitive reference type, filtering out any\n /// implementations that are on concrete or partially generic types, only keeping implementations\n /// of the form `impl<T> Trait for &T`.\n@@ -2483,89 +1995,6 @@ pub(crate) fn get_filtered_impls_for_reference<'a>(\n     (concrete, synthetic, blanket_impl)\n }\n \n-fn sidebar_primitive(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let mut sidebar = Buffer::new();\n-\n-    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        sidebar_assoc_items(cx, &mut sidebar, it);\n-    } else {\n-        let shared = Rc::clone(&cx.shared);\n-        let (concrete, synthetic, blanket_impl) = get_filtered_impls_for_reference(&shared, it);\n-\n-        sidebar_render_assoc_items(\n-            cx,\n-            &mut sidebar,\n-            &mut IdMap::new(),\n-            concrete,\n-            synthetic,\n-            blanket_impl,\n-        );\n-    }\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n-fn sidebar_typedef(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n-fn get_struct_fields_name(fields: &[clean::Item]) -> Vec<String> {\n-    let mut fields = fields\n-        .iter()\n-        .filter(|f| matches!(*f.kind, clean::StructFieldItem(..)))\n-        .filter_map(|f| {\n-            f.name.map(|name| format!(\"<a href=\\\"#structfield.{name}\\\">{name}</a>\", name = name))\n-        })\n-        .collect::<Vec<_>>();\n-    fields.sort();\n-    fields\n-}\n-\n-fn sidebar_union(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, u: &clean::Union) {\n-    let mut sidebar = Buffer::new();\n-    let fields = get_struct_fields_name(&u.fields);\n-\n-    if !fields.is_empty() {\n-        print_sidebar_block(&mut sidebar, \"fields\", \"Fields\", fields.iter());\n-    }\n-\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n-fn sidebar_enum(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, e: &clean::Enum) {\n-    let mut sidebar = Buffer::new();\n-\n-    let mut variants = e\n-        .variants()\n-        .filter_map(|v| {\n-            v.name\n-                .as_ref()\n-                .map(|name| format!(\"<a href=\\\"#variant.{name}\\\">{name}</a>\", name = name))\n-        })\n-        .collect::<Vec<_>>();\n-    if !variants.is_empty() {\n-        variants.sort_unstable();\n-        print_sidebar_block(&mut sidebar, \"variants\", \"Variants\", variants.iter());\n-    }\n-\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub(crate) enum ItemSection {\n     Reexports,\n@@ -2719,54 +2148,6 @@ fn item_ty_to_section(ty: ItemType) -> ItemSection {\n     }\n }\n \n-pub(crate) fn sidebar_module_like(buf: &mut Buffer, item_sections_in_use: FxHashSet<ItemSection>) {\n-    use std::fmt::Write as _;\n-\n-    let mut sidebar = String::new();\n-\n-    for &sec in ItemSection::ALL.iter().filter(|sec| item_sections_in_use.contains(sec)) {\n-        let _ = write!(sidebar, \"<li><a href=\\\"#{}\\\">{}</a></li>\", sec.id(), sec.name());\n-    }\n-\n-    if !sidebar.is_empty() {\n-        write!(\n-            buf,\n-            \"<section>\\\n-                 <ul class=\\\"block\\\">{}</ul>\\\n-             </section>\",\n-            sidebar\n-        );\n-    }\n-}\n-\n-fn sidebar_module(buf: &mut Buffer, items: &[clean::Item]) {\n-    let item_sections_in_use: FxHashSet<_> = items\n-        .iter()\n-        .filter(|it| {\n-            !it.is_stripped()\n-                && it\n-                    .name\n-                    .or_else(|| {\n-                        if let clean::ImportItem(ref i) = *it.kind &&\n-                            let clean::ImportKind::Simple(s) = i.kind { Some(s) } else { None }\n-                    })\n-                    .is_some()\n-        })\n-        .map(|it| item_ty_to_section(it.type_()))\n-        .collect();\n-\n-    sidebar_module_like(buf, item_sections_in_use);\n-}\n-\n-fn sidebar_foreign_type(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item) {\n-    let mut sidebar = Buffer::new();\n-    sidebar_assoc_items(cx, &mut sidebar, it);\n-\n-    if !sidebar.is_empty() {\n-        write!(buf, \"<section>{}</section>\", sidebar.into_inner());\n-    }\n-}\n-\n /// Returns a list of all paths used in the type.\n /// This is used to help deduplicate imported impls\n /// for reexported types. If any of the contained"}, {"sha": "577497868f687b47d00fc1b33a73bbf68ee3e857", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -470,10 +470,11 @@ fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) ->\n \n     // The trailing space after each tag is to space it properly against the rest of the docs.\n     if let Some(depr) = &item.deprecation(tcx) {\n-        let mut message = \"Deprecated\";\n-        if !stability::deprecation_in_effect(depr) {\n-            message = \"Deprecation planned\";\n-        }\n+        let message = if stability::deprecation_in_effect(depr) {\n+            \"Deprecated\"\n+        } else {\n+            \"Deprecation planned\"\n+        };\n         tags += &tag_html(\"deprecated\", \"\", message);\n     }\n "}, {"sha": "146221f5806b4e4b5ba8169b3e1c91b1fe51f66c", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -40,6 +40,7 @@ pub(crate) fn build_index<'tcx>(\n                 parent_idx: None,\n                 search_type: get_function_type_for_search(item, tcx, impl_generics.as_ref(), cache),\n                 aliases: item.attrs.get_doc_aliases(),\n+                deprecation: item.deprecation(tcx),\n             });\n         }\n     }\n@@ -251,7 +252,17 @@ pub(crate) fn build_index<'tcx>(\n             )?;\n             crate_data.serialize_field(\n                 \"q\",\n-                &self.items.iter().map(|item| &item.path).collect::<Vec<_>>(),\n+                &self\n+                    .items\n+                    .iter()\n+                    .enumerate()\n+                    // Serialize as an array of item indices and full paths\n+                    .filter_map(\n+                        |(index, item)| {\n+                            if item.path.is_empty() { None } else { Some((index, &item.path)) }\n+                        },\n+                    )\n+                    .collect::<Vec<_>>(),\n             )?;\n             crate_data.serialize_field(\n                 \"d\",\n@@ -304,6 +315,16 @@ pub(crate) fn build_index<'tcx>(\n                     })\n                     .collect::<Vec<_>>(),\n             )?;\n+            crate_data.serialize_field(\n+                \"c\",\n+                &self\n+                    .items\n+                    .iter()\n+                    .enumerate()\n+                    // Serialize as an array of deprecated item indices\n+                    .filter_map(|(index, item)| item.deprecation.map(|_| index))\n+                    .collect::<Vec<_>>(),\n+            )?;\n             crate_data.serialize_field(\n                 \"p\",\n                 &self.paths.iter().map(|(it, s)| (it, s.as_str())).collect::<Vec<_>>(),"}, {"sha": "94ad4753d7cb6bac65728ef904e0444ee0c9001f", "filename": "src/librustdoc/html/render/sidebar.rs", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fsidebar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Frender%2Fsidebar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsidebar.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,561 @@\n+use std::{borrow::Cow, rc::Rc};\n+\n+use askama::Template;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{def::CtorKind, def_id::DefIdSet};\n+use rustc_middle::ty::{self, TyCtxt};\n+\n+use crate::{\n+    clean,\n+    formats::{item_type::ItemType, Impl},\n+    html::{format::Buffer, markdown::IdMap},\n+};\n+\n+use super::{item_ty_to_section, Context, ItemSection};\n+\n+#[derive(Template)]\n+#[template(path = \"sidebar.html\")]\n+pub(super) struct Sidebar<'a> {\n+    pub(super) title_prefix: &'static str,\n+    pub(super) title: &'a str,\n+    pub(super) is_crate: bool,\n+    pub(super) version: &'a str,\n+    pub(super) blocks: Vec<LinkBlock<'a>>,\n+    pub(super) path: String,\n+}\n+\n+impl<'a> Sidebar<'a> {\n+    /// Only create a `<section>` if there are any blocks\n+    /// which should actually be rendered.\n+    pub fn should_render_blocks(&self) -> bool {\n+        self.blocks.iter().any(LinkBlock::should_render)\n+    }\n+}\n+\n+/// A sidebar section such as 'Methods'.\n+pub(crate) struct LinkBlock<'a> {\n+    /// The name of this section, e.g. 'Methods'\n+    /// as well as the link to it, e.g. `#implementations`.\n+    /// Will be rendered inside an `<h3>` tag\n+    heading: Link<'a>,\n+    links: Vec<Link<'a>>,\n+    /// Render the heading even if there are no links\n+    force_render: bool,\n+}\n+\n+impl<'a> LinkBlock<'a> {\n+    pub fn new(heading: Link<'a>, links: Vec<Link<'a>>) -> Self {\n+        Self { heading, links, force_render: false }\n+    }\n+\n+    pub fn forced(heading: Link<'a>) -> Self {\n+        Self { heading, links: vec![], force_render: true }\n+    }\n+\n+    pub fn should_render(&self) -> bool {\n+        self.force_render || !self.links.is_empty()\n+    }\n+}\n+\n+/// A link to an item. Content should not be escaped.\n+#[derive(PartialOrd, Ord, PartialEq, Eq, Hash, Clone)]\n+pub(crate) struct Link<'a> {\n+    /// The content for the anchor tag\n+    name: Cow<'a, str>,\n+    /// The id of an anchor within the page (without a `#` prefix)\n+    href: Cow<'a, str>,\n+}\n+\n+impl<'a> Link<'a> {\n+    pub fn new(href: impl Into<Cow<'a, str>>, name: impl Into<Cow<'a, str>>) -> Self {\n+        Self { href: href.into(), name: name.into() }\n+    }\n+    pub fn empty() -> Link<'static> {\n+        Link::new(\"\", \"\")\n+    }\n+}\n+\n+pub(super) fn print_sidebar(cx: &Context<'_>, it: &clean::Item, buffer: &mut Buffer) {\n+    let blocks: Vec<LinkBlock<'_>> = match *it.kind {\n+        clean::StructItem(ref s) => sidebar_struct(cx, it, s),\n+        clean::TraitItem(ref t) => sidebar_trait(cx, it, t),\n+        clean::PrimitiveItem(_) => sidebar_primitive(cx, it),\n+        clean::UnionItem(ref u) => sidebar_union(cx, it, u),\n+        clean::EnumItem(ref e) => sidebar_enum(cx, it, e),\n+        clean::TypedefItem(_) => sidebar_typedef(cx, it),\n+        clean::ModuleItem(ref m) => vec![sidebar_module(&m.items)],\n+        clean::ForeignTypeItem => sidebar_foreign_type(cx, it),\n+        _ => vec![],\n+    };\n+    // The sidebar is designed to display sibling functions, modules and\n+    // other miscellaneous information. since there are lots of sibling\n+    // items (and that causes quadratic growth in large modules),\n+    // we refactor common parts into a shared JavaScript file per module.\n+    // still, we don't move everything into JS because we want to preserve\n+    // as much HTML as possible in order to allow non-JS-enabled browsers\n+    // to navigate the documentation (though slightly inefficiently).\n+    let (title_prefix, title) = if it.is_struct()\n+        || it.is_trait()\n+        || it.is_primitive()\n+        || it.is_union()\n+        || it.is_enum()\n+        || it.is_mod()\n+        || it.is_typedef()\n+    {\n+        (\n+            match *it.kind {\n+                clean::ModuleItem(..) if it.is_crate() => \"Crate \",\n+                clean::ModuleItem(..) => \"Module \",\n+                _ => \"\",\n+            },\n+            it.name.as_ref().unwrap().as_str(),\n+        )\n+    } else {\n+        (\"\", \"\")\n+    };\n+    let version = if it.is_crate() {\n+        cx.cache().crate_version.as_ref().map(String::as_str).unwrap_or_default()\n+    } else {\n+        \"\"\n+    };\n+    let path: String = if !it.is_mod() {\n+        cx.current.iter().map(|s| s.as_str()).intersperse(\"::\").collect()\n+    } else {\n+        \"\".into()\n+    };\n+    let sidebar = Sidebar { title_prefix, title, is_crate: it.is_crate(), version, blocks, path };\n+    sidebar.render_into(buffer).unwrap();\n+}\n+\n+fn get_struct_fields_name<'a>(fields: &'a [clean::Item]) -> Vec<Link<'a>> {\n+    let mut fields = fields\n+        .iter()\n+        .filter(|f| matches!(*f.kind, clean::StructFieldItem(..)))\n+        .filter_map(|f| {\n+            f.name.as_ref().map(|name| Link::new(format!(\"structfield.{name}\"), name.as_str()))\n+        })\n+        .collect::<Vec<Link<'a>>>();\n+    fields.sort();\n+    fields\n+}\n+\n+fn sidebar_struct<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    s: &'a clean::Struct,\n+) -> Vec<LinkBlock<'a>> {\n+    let fields = get_struct_fields_name(&s.fields);\n+    let field_name = match s.ctor_kind {\n+        Some(CtorKind::Fn) => Some(\"Tuple Fields\"),\n+        None => Some(\"Fields\"),\n+        _ => None,\n+    };\n+    let mut items = vec![];\n+    if let Some(name) = field_name {\n+        items.push(LinkBlock::new(Link::new(\"fields\", name), fields));\n+    }\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+fn sidebar_trait<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    t: &'a clean::Trait,\n+) -> Vec<LinkBlock<'a>> {\n+    fn filter_items<'a>(\n+        items: &'a [clean::Item],\n+        filt: impl Fn(&clean::Item) -> bool,\n+        ty: &str,\n+    ) -> Vec<Link<'a>> {\n+        let mut res = items\n+            .iter()\n+            .filter_map(|m: &clean::Item| match m.name {\n+                Some(ref name) if filt(m) => Some(Link::new(format!(\"{ty}.{name}\"), name.as_str())),\n+                _ => None,\n+            })\n+            .collect::<Vec<Link<'a>>>();\n+        res.sort();\n+        res\n+    }\n+\n+    let req_assoc = filter_items(&t.items, |m| m.is_ty_associated_type(), \"associatedtype\");\n+    let prov_assoc = filter_items(&t.items, |m| m.is_associated_type(), \"associatedtype\");\n+    let req_assoc_const =\n+        filter_items(&t.items, |m| m.is_ty_associated_const(), \"associatedconstant\");\n+    let prov_assoc_const =\n+        filter_items(&t.items, |m| m.is_associated_const(), \"associatedconstant\");\n+    let req_method = filter_items(&t.items, |m| m.is_ty_method(), \"tymethod\");\n+    let prov_method = filter_items(&t.items, |m| m.is_method(), \"method\");\n+    let mut foreign_impls = vec![];\n+    if let Some(implementors) = cx.cache().implementors.get(&it.item_id.expect_def_id()) {\n+        foreign_impls.extend(\n+            implementors\n+                .iter()\n+                .filter(|i| !i.is_on_local_type(cx))\n+                .filter_map(|i| super::extract_for_impl_name(&i.impl_item, cx))\n+                .map(|(name, id)| Link::new(id, name)),\n+        );\n+        foreign_impls.sort();\n+    }\n+\n+    let mut blocks: Vec<LinkBlock<'_>> = [\n+        (\"required-associated-types\", \"Required Associated Types\", req_assoc),\n+        (\"provided-associated-types\", \"Provided Associated Types\", prov_assoc),\n+        (\"required-associated-consts\", \"Required Associated Constants\", req_assoc_const),\n+        (\"provided-associated-consts\", \"Provided Associated Constants\", prov_assoc_const),\n+        (\"required-methods\", \"Required Methods\", req_method),\n+        (\"provided-methods\", \"Provided Methods\", prov_method),\n+        (\"foreign-impls\", \"Implementations on Foreign Types\", foreign_impls),\n+    ]\n+    .into_iter()\n+    .map(|(id, title, items)| LinkBlock::new(Link::new(id, title), items))\n+    .collect();\n+    sidebar_assoc_items(cx, it, &mut blocks);\n+    blocks.push(LinkBlock::forced(Link::new(\"implementors\", \"Implementors\")));\n+    if t.is_auto(cx.tcx()) {\n+        blocks.push(LinkBlock::forced(Link::new(\"synthetic-implementors\", \"Auto Implementors\")));\n+    }\n+    blocks\n+}\n+\n+fn sidebar_primitive<'a>(cx: &'a Context<'_>, it: &'a clean::Item) -> Vec<LinkBlock<'a>> {\n+    if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n+        let mut items = vec![];\n+        sidebar_assoc_items(cx, it, &mut items);\n+        items\n+    } else {\n+        let shared = Rc::clone(&cx.shared);\n+        let (concrete, synthetic, blanket_impl) =\n+            super::get_filtered_impls_for_reference(&shared, it);\n+\n+        sidebar_render_assoc_items(cx, &mut IdMap::new(), concrete, synthetic, blanket_impl).into()\n+    }\n+}\n+\n+fn sidebar_typedef<'a>(cx: &'a Context<'_>, it: &'a clean::Item) -> Vec<LinkBlock<'a>> {\n+    let mut items = vec![];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+fn sidebar_union<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    u: &'a clean::Union,\n+) -> Vec<LinkBlock<'a>> {\n+    let fields = get_struct_fields_name(&u.fields);\n+    let mut items = vec![LinkBlock::new(Link::new(\"fields\", \"Fields\"), fields)];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+/// Adds trait implementations into the blocks of links\n+fn sidebar_assoc_items<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    links: &mut Vec<LinkBlock<'a>>,\n+) {\n+    let did = it.item_id.expect_def_id();\n+    let cache = cx.cache();\n+\n+    let mut assoc_consts = Vec::new();\n+    let mut methods = Vec::new();\n+    if let Some(v) = cache.impls.get(&did) {\n+        let mut used_links = FxHashSet::default();\n+        let mut id_map = IdMap::new();\n+\n+        {\n+            let used_links_bor = &mut used_links;\n+            assoc_consts.extend(\n+                v.iter()\n+                    .filter(|i| i.inner_impl().trait_.is_none())\n+                    .flat_map(|i| get_associated_constants(i.inner_impl(), used_links_bor)),\n+            );\n+            // We want links' order to be reproducible so we don't use unstable sort.\n+            assoc_consts.sort();\n+\n+            #[rustfmt::skip] // rustfmt makes the pipeline less readable\n+            methods.extend(\n+                v.iter()\n+                    .filter(|i| i.inner_impl().trait_.is_none())\n+                    .flat_map(|i| get_methods(i.inner_impl(), false, used_links_bor, false, cx.tcx())),\n+            );\n+\n+            // We want links' order to be reproducible so we don't use unstable sort.\n+            methods.sort();\n+        }\n+\n+        let mut deref_methods = Vec::new();\n+        let [concrete, synthetic, blanket] = if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n+            if let Some(impl_) =\n+                v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n+            {\n+                let mut derefs = DefIdSet::default();\n+                derefs.insert(did);\n+                sidebar_deref_methods(\n+                    cx,\n+                    &mut deref_methods,\n+                    impl_,\n+                    v,\n+                    &mut derefs,\n+                    &mut used_links,\n+                );\n+            }\n+\n+            let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+                v.iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_auto());\n+            let (blanket_impl, concrete): (Vec<&Impl>, Vec<&Impl>) =\n+                concrete.into_iter().partition::<Vec<_>, _>(|i| i.inner_impl().kind.is_blanket());\n+\n+            sidebar_render_assoc_items(cx, &mut id_map, concrete, synthetic, blanket_impl)\n+        } else {\n+            std::array::from_fn(|_| LinkBlock::new(Link::empty(), vec![]))\n+        };\n+\n+        let mut blocks = vec![\n+            LinkBlock::new(Link::new(\"implementations\", \"Associated Constants\"), assoc_consts),\n+            LinkBlock::new(Link::new(\"implementations\", \"Methods\"), methods),\n+        ];\n+        blocks.append(&mut deref_methods);\n+        blocks.extend([concrete, synthetic, blanket]);\n+        links.append(&mut blocks);\n+    }\n+}\n+\n+fn sidebar_deref_methods<'a>(\n+    cx: &'a Context<'_>,\n+    out: &mut Vec<LinkBlock<'a>>,\n+    impl_: &Impl,\n+    v: &[Impl],\n+    derefs: &mut DefIdSet,\n+    used_links: &mut FxHashSet<String>,\n+) {\n+    let c = cx.cache();\n+\n+    debug!(\"found Deref: {:?}\", impl_);\n+    if let Some((target, real_target)) =\n+        impl_.inner_impl().items.iter().find_map(|item| match *item.kind {\n+            clean::AssocTypeItem(box ref t, _) => Some(match *t {\n+                clean::Typedef { item_type: Some(ref type_), .. } => (type_, &t.type_),\n+                _ => (&t.type_, &t.type_),\n+            }),\n+            _ => None,\n+        })\n+    {\n+        debug!(\"found target, real_target: {:?} {:?}\", target, real_target);\n+        if let Some(did) = target.def_id(c) &&\n+            let Some(type_did) = impl_.inner_impl().for_.def_id(c) &&\n+            // `impl Deref<Target = S> for S`\n+            (did == type_did || !derefs.insert(did))\n+        {\n+            // Avoid infinite cycles\n+            return;\n+        }\n+        let deref_mut = v.iter().any(|i| i.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n+        let inner_impl = target\n+            .def_id(c)\n+            .or_else(|| {\n+                target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n+            })\n+            .and_then(|did| c.impls.get(&did));\n+        if let Some(impls) = inner_impl {\n+            debug!(\"found inner_impl: {:?}\", impls);\n+            let mut ret = impls\n+                .iter()\n+                .filter(|i| i.inner_impl().trait_.is_none())\n+                .flat_map(|i| get_methods(i.inner_impl(), true, used_links, deref_mut, cx.tcx()))\n+                .collect::<Vec<_>>();\n+            if !ret.is_empty() {\n+                let id = if let Some(target_def_id) = real_target.def_id(c) {\n+                    Cow::Borrowed(\n+                        cx.deref_id_map\n+                            .get(&target_def_id)\n+                            .expect(\"Deref section without derived id\")\n+                            .as_str(),\n+                    )\n+                } else {\n+                    Cow::Borrowed(\"deref-methods\")\n+                };\n+                let title = format!(\n+                    \"Methods from {:#}<Target={:#}>\",\n+                    impl_.inner_impl().trait_.as_ref().unwrap().print(cx),\n+                    real_target.print(cx),\n+                );\n+                // We want links' order to be reproducible so we don't use unstable sort.\n+                ret.sort();\n+                out.push(LinkBlock::new(Link::new(id, title), ret));\n+            }\n+        }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id(c) &&\n+            let Some(target_impls) = c.impls.get(&target_did) &&\n+            let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                i.inner_impl()\n+                    .trait_\n+                    .as_ref()\n+                    .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                    .unwrap_or(false)\n+            })\n+        {\n+            sidebar_deref_methods(\n+                cx,\n+                out,\n+                target_deref_impl,\n+                target_impls,\n+                derefs,\n+                used_links,\n+            );\n+        }\n+    }\n+}\n+\n+fn sidebar_enum<'a>(\n+    cx: &'a Context<'_>,\n+    it: &'a clean::Item,\n+    e: &'a clean::Enum,\n+) -> Vec<LinkBlock<'a>> {\n+    let mut variants = e\n+        .variants()\n+        .filter_map(|v| v.name)\n+        .map(|name| Link::new(format!(\"variant.{name}\"), name.to_string()))\n+        .collect::<Vec<_>>();\n+    variants.sort_unstable();\n+\n+    let mut items = vec![LinkBlock::new(Link::new(\"variants\", \"Variants\"), variants)];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+pub(crate) fn sidebar_module_like(\n+    item_sections_in_use: FxHashSet<ItemSection>,\n+) -> LinkBlock<'static> {\n+    let item_sections = ItemSection::ALL\n+        .iter()\n+        .copied()\n+        .filter(|sec| item_sections_in_use.contains(sec))\n+        .map(|sec| Link::new(sec.id(), sec.name()))\n+        .collect();\n+    LinkBlock::new(Link::empty(), item_sections)\n+}\n+\n+fn sidebar_module(items: &[clean::Item]) -> LinkBlock<'static> {\n+    let item_sections_in_use: FxHashSet<_> = items\n+        .iter()\n+        .filter(|it| {\n+            !it.is_stripped()\n+                && it\n+                    .name\n+                    .or_else(|| {\n+                        if let clean::ImportItem(ref i) = *it.kind &&\n+                            let clean::ImportKind::Simple(s) = i.kind { Some(s) } else { None }\n+                    })\n+                    .is_some()\n+        })\n+        .map(|it| item_ty_to_section(it.type_()))\n+        .collect();\n+\n+    sidebar_module_like(item_sections_in_use)\n+}\n+\n+fn sidebar_foreign_type<'a>(cx: &'a Context<'_>, it: &'a clean::Item) -> Vec<LinkBlock<'a>> {\n+    let mut items = vec![];\n+    sidebar_assoc_items(cx, it, &mut items);\n+    items\n+}\n+\n+/// Renders the trait implementations for this type\n+fn sidebar_render_assoc_items(\n+    cx: &Context<'_>,\n+    id_map: &mut IdMap,\n+    concrete: Vec<&Impl>,\n+    synthetic: Vec<&Impl>,\n+    blanket_impl: Vec<&Impl>,\n+) -> [LinkBlock<'static>; 3] {\n+    let format_impls = |impls: Vec<&Impl>, id_map: &mut IdMap| {\n+        let mut links = FxHashSet::default();\n+\n+        let mut ret = impls\n+            .iter()\n+            .filter_map(|it| {\n+                let trait_ = it.inner_impl().trait_.as_ref()?;\n+                let encoded =\n+                    id_map.derive(super::get_id_for_impl(&it.inner_impl().for_, Some(trait_), cx));\n+\n+                let prefix = match it.inner_impl().polarity {\n+                    ty::ImplPolarity::Positive | ty::ImplPolarity::Reservation => \"\",\n+                    ty::ImplPolarity::Negative => \"!\",\n+                };\n+                let generated = Link::new(encoded, format!(\"{prefix}{:#}\", trait_.print(cx)));\n+                if links.insert(generated.clone()) { Some(generated) } else { None }\n+            })\n+            .collect::<Vec<Link<'static>>>();\n+        ret.sort();\n+        ret\n+    };\n+\n+    let concrete = format_impls(concrete, id_map);\n+    let synthetic = format_impls(synthetic, id_map);\n+    let blanket = format_impls(blanket_impl, id_map);\n+    [\n+        LinkBlock::new(Link::new(\"trait-implementations\", \"Trait Implementations\"), concrete),\n+        LinkBlock::new(\n+            Link::new(\"synthetic-implementations\", \"Auto Trait Implementations\"),\n+            synthetic,\n+        ),\n+        LinkBlock::new(Link::new(\"blanket-implementations\", \"Blanket Implementations\"), blanket),\n+    ]\n+}\n+\n+fn get_next_url(used_links: &mut FxHashSet<String>, url: String) -> String {\n+    if used_links.insert(url.clone()) {\n+        return url;\n+    }\n+    let mut add = 1;\n+    while !used_links.insert(format!(\"{}-{}\", url, add)) {\n+        add += 1;\n+    }\n+    format!(\"{}-{}\", url, add)\n+}\n+\n+fn get_methods<'a>(\n+    i: &'a clean::Impl,\n+    for_deref: bool,\n+    used_links: &mut FxHashSet<String>,\n+    deref_mut: bool,\n+    tcx: TyCtxt<'_>,\n+) -> Vec<Link<'a>> {\n+    i.items\n+        .iter()\n+        .filter_map(|item| match item.name {\n+            Some(ref name) if !name.is_empty() && item.is_method() => {\n+                if !for_deref || super::should_render_item(item, deref_mut, tcx) {\n+                    Some(Link::new(\n+                        get_next_url(used_links, format!(\"{}.{}\", ItemType::Method, name)),\n+                        name.as_str(),\n+                    ))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        })\n+        .collect::<Vec<_>>()\n+}\n+\n+fn get_associated_constants<'a>(\n+    i: &'a clean::Impl,\n+    used_links: &mut FxHashSet<String>,\n+) -> Vec<Link<'a>> {\n+    i.items\n+        .iter()\n+        .filter_map(|item| match item.name {\n+            Some(ref name) if !name.is_empty() && item.is_associated_const() => Some(Link::new(\n+                get_next_url(used_links, format!(\"{}.{}\", ItemType::AssocConst, name)),\n+                name.as_str(),\n+            )),\n+            _ => None,\n+        })\n+        .collect::<Vec<_>>()\n+}"}, {"sha": "3ba2ca75458d25d714b13148c7ab663e461ca2cb", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -881,6 +881,13 @@ function initSearch(rawSearchIndex) {\n                     return a - b;\n                 }\n \n+                // sort deprecated items later\n+                a = aaa.item.deprecated;\n+                b = bbb.item.deprecated;\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n                 // sort by crate (current crate comes first)\n                 a = (aaa.item.crate !== preferredCrate);\n                 b = (bbb.item.crate !== preferredCrate);\n@@ -1244,6 +1251,7 @@ function initSearch(rawSearchIndex) {\n                 parent: item.parent,\n                 type: item.type,\n                 is_alias: true,\n+                deprecated: item.deprecated,\n             };\n         }\n \n@@ -2064,10 +2072,11 @@ function initSearch(rawSearchIndex) {\n              *   n: Array<string>,\n              *   t: String,\n              *   d: Array<string>,\n-             *   q: Array<string>,\n+             *   q: Array<[Number, string]>,\n              *   i: Array<Number>,\n              *   f: Array<RawFunctionSearchType>,\n              *   p: Array<Object>,\n+             *   c: Array<Number>\n              * }}\n              */\n             const crateCorpus = rawSearchIndex[crate];\n@@ -2086,6 +2095,7 @@ function initSearch(rawSearchIndex) {\n                 type: null,\n                 id: id,\n                 normalizedName: crate.indexOf(\"_\") === -1 ? crate : crate.replace(/_/g, \"\"),\n+                deprecated: null,\n             };\n             id += 1;\n             searchIndex.push(crateRow);\n@@ -2095,14 +2105,20 @@ function initSearch(rawSearchIndex) {\n             const itemTypes = crateCorpus.t;\n             // an array of (String) item names\n             const itemNames = crateCorpus.n;\n-            // an array of (String) full paths (or empty string for previous path)\n-            const itemPaths = crateCorpus.q;\n+            // an array of [(Number) item index,\n+            //              (String) full path]\n+            // an item whose index is not present will fall back to the previous present path\n+            // i.e. if indices 4 and 11 are present, but 5-10 and 12-13 are not present,\n+            // 5-10 will fall back to the path for 4 and 12-13 will fall back to the path for 11\n+            const itemPaths = new Map(crateCorpus.q);\n             // an array of (String) descriptions\n             const itemDescs = crateCorpus.d;\n             // an array of (Number) the parent path index + 1 to `paths`, or 0 if none\n             const itemParentIdxs = crateCorpus.i;\n             // an array of (Object | null) the type of the function, if any\n             const itemFunctionSearchTypes = crateCorpus.f;\n+            // an array of (Number) indices for the deprecated items\n+            const deprecatedItems = new Set(crateCorpus.c);\n             // an array of [(Number) item type,\n             //              (String) name]\n             const paths = crateCorpus.p;\n@@ -2142,12 +2158,13 @@ function initSearch(rawSearchIndex) {\n                     crate: crate,\n                     ty: itemTypes.charCodeAt(i) - charA,\n                     name: itemNames[i],\n-                    path: itemPaths[i] ? itemPaths[i] : lastPath,\n+                    path: itemPaths.has(i) ? itemPaths.get(i) : lastPath,\n                     desc: itemDescs[i],\n                     parent: itemParentIdxs[i] > 0 ? paths[itemParentIdxs[i] - 1] : undefined,\n                     type: buildFunctionSearchType(itemFunctionSearchTypes[i], lowercasePaths),\n                     id: id,\n                     normalizedName: word.indexOf(\"_\") === -1 ? word : word.replace(/_/g, \"\"),\n+                    deprecated: deprecatedItems.has(i),\n                 };\n                 id += 1;\n                 searchIndex.push(row);"}, {"sha": "d2ea9bdae9c65c0bc59cefdd3d861199469c4eee", "filename": "src/librustdoc/html/templates/item_info.html", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_info.html", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_info.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fitem_info.html?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,7 @@\n+{% if !items.is_empty() %}\n+    <span class=\"item-info\"> {# #}\n+        {% for item in items %}\n+            {{item|safe}} {# #}\n+        {% endfor %}\n+    </span>\n+{% endif %}"}, {"sha": "e3125af0e47ea25097a6be36bf6beae3f43c8d4d", "filename": "src/librustdoc/html/templates/short_item_info.html", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,23 @@\n+{% match self %}\n+    {% when Self::Deprecation with { message } %}\n+        <div class=\"stab deprecated\"> {# #}\n+            <span class=\"emoji\">\ud83d\udc4e</span> {# #}\n+            <span>{{message}}</span> {# #}\n+        </div> {# #}\n+    {% when Self::Unstable with { feature, tracking } %}\n+        <div class=\"stab unstable\"> {# #}\n+            <span class=\"emoji\">\ud83d\udd2c</span> {# #}\n+            <span> {# #}\n+                This is a nightly-only experimental API. ({# #}\n+                <code>{{feature}}</code> {# #}\n+                {% match tracking %}\n+                    {% when Some with ((url, num)) %}\n+                        &nbsp;<a href=\"{{url}}{{num}}\">#{{num}}</a> {# #}\n+                    {% when None %}\n+                {% endmatch %}\n+                ) {# #}\n+            </span> {# #}\n+        </div> {# #}\n+    {% when Self::Portability with { message } %}\n+        <div class=\"stab portability\">{{message|safe}}</div> {# #}\n+{% endmatch %}"}, {"sha": "01d476ad29f2f8529df915297502dca7645c5ca4", "filename": "src/librustdoc/html/templates/sidebar.html", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsidebar.html", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsidebar.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsidebar.html?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,37 @@\n+{% if !title.is_empty() %}\n+    <h2 class=\"location\"> {# #}\n+        <a href=\"#\">{{title_prefix}}{{title}}</a> {# #}\n+    </h2>\n+{% endif %}\n+<div class=\"sidebar-elems\">\n+    {% if is_crate %}\n+        <ul class=\"block\">\n+            {% if !version.is_empty() %}\n+                <li class=\"version\">Version {{+ version}}</li>\n+            {% endif %}\n+            <li><a id=\"all-types\" href=\"all.html\">All Items</a></li> {# #}\n+        </ul>\n+    {% endif %}\n+\n+    {% if self.should_render_blocks() %}\n+        <section>\n+            {% for block in blocks %}\n+                {% if block.should_render() %}\n+                    {% if !block.heading.name.is_empty() %}\n+                        <h3><a href=\"#{{block.heading.href|safe}}\">{{block.heading.name}}</a></h3>\n+                    {% endif %}\n+                    {% if !block.links.is_empty() %}\n+                        <ul class=\"block\">\n+                            {% for link in block.links %}\n+                                <li><a href=\"#{{link.href|safe}}\">{{link.name}}</a></li>\n+                            {% endfor %}\n+                        </ul>\n+                    {% endif %}\n+                {% endif %}\n+            {% endfor %}\n+        </section>\n+    {% endif %}\n+    {% if !path.is_empty() %}\n+        <h2><a href=\"index.html\">In {{+ path}}</a></h2>\n+    {% endif %}\n+</div>"}, {"sha": "4c4c003ca469122825ba59a3500beed1a81aac25", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -369,10 +369,10 @@ fn can_change_type<'a>(cx: &LateContext<'a>, mut expr: &'a Expr<'a>, mut ty: Ty<\n             Node::Item(item) => {\n                 if let ItemKind::Fn(_, _, body_id) = &item.kind\n                 && let output_ty = return_ty(cx, item.owner_id)\n-                && Inherited::build(cx.tcx, item.owner_id.def_id).enter(|inherited| {\n-                    let fn_ctxt = FnCtxt::new(inherited, cx.param_env, item.owner_id.def_id);\n-                    fn_ctxt.can_coerce(ty, output_ty)\n-                }) {\n+                && let inherited = Inherited::new(cx.tcx, item.owner_id.def_id)\n+                && let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, item.owner_id.def_id)\n+                && fn_ctxt.can_coerce(ty, output_ty)\n+                {\n                     if has_lifetime(output_ty) && has_lifetime(ty) {\n                         return false;\n                     }"}, {"sha": "62efd13b8d909a072232c40757ccd6e9b91de0b4", "filename": "src/tools/clippy/clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 28, "deletions": 29, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -33,38 +33,37 @@ pub(super) fn check_cast<'tcx>(\n     let hir_id = e.hir_id;\n     let local_def_id = hir_id.owner.def_id;\n \n-    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n-        let fn_ctxt = FnCtxt::new(inherited, cx.param_env, local_def_id);\n+    let inherited = Inherited::new(cx.tcx, local_def_id);\n+    let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, local_def_id);\n \n-        // If we already have errors, we can't be sure we can pointer cast.\n+    // If we already have errors, we can't be sure we can pointer cast.\n+    assert!(\n+        !fn_ctxt.errors_reported_since_creation(),\n+        \"Newly created FnCtxt contained errors\"\n+    );\n+\n+    if let Ok(check) = cast::CastCheck::new(\n+        &fn_ctxt,\n+        e,\n+        from_ty,\n+        to_ty,\n+        // We won't show any error to the user, so we don't care what the span is here.\n+        DUMMY_SP,\n+        DUMMY_SP,\n+        hir::Constness::NotConst,\n+    ) {\n+        let res = check.do_check(&fn_ctxt);\n+\n+        // do_check's documentation says that it might return Ok and create\n+        // errors in the fcx instead of returning Err in some cases. Those cases\n+        // should be filtered out before getting here.\n         assert!(\n             !fn_ctxt.errors_reported_since_creation(),\n-            \"Newly created FnCtxt contained errors\"\n+            \"`fn_ctxt` contained errors after cast check!\"\n         );\n \n-        if let Ok(check) = cast::CastCheck::new(\n-            &fn_ctxt,\n-            e,\n-            from_ty,\n-            to_ty,\n-            // We won't show any error to the user, so we don't care what the span is here.\n-            DUMMY_SP,\n-            DUMMY_SP,\n-            hir::Constness::NotConst,\n-        ) {\n-            let res = check.do_check(&fn_ctxt);\n-\n-            // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returning Err in some cases. Those cases\n-            // should be filtered out before getting here.\n-            assert!(\n-                !fn_ctxt.errors_reported_since_creation(),\n-                \"`fn_ctxt` contained errors after cast check!\"\n-            );\n-\n-            res.ok()\n-        } else {\n-            None\n-        }\n-    })\n+        res.ok()\n+    } else {\n+        None\n+    }\n }"}, {"sha": "868579b4b1a8c92e86c630b9e4b34a612ea5ca3b", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -62,8 +62,6 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"library/std/src/panic.rs\",   // fuchsia-specific panic backtrace handling\n     \"library/std/src/personality.rs\",\n     \"library/std/src/personality/\",\n-    \"library/std/src/thread/mod.rs\",\n-    \"library/std/src/thread/local.rs\",\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {"}, {"sha": "aede030e072b3c4dd8b96036752734e882c153e2", "filename": "tests/rustdoc-ui/crate-reference-in-block-module.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Frustdoc-ui%2Fcrate-reference-in-block-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Frustdoc-ui%2Fcrate-reference-in-block-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcrate-reference-in-block-module.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,5 @@\n+// check-pass\n+fn main() {\n+    /// [](crate)\n+    struct X;\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/rustdoc-ui/crate-reference-in-block-module.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Frustdoc-ui%2Fcrate-reference-in-block-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Frustdoc-ui%2Fcrate-reference-in-block-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fcrate-reference-in-block-module.stderr?ref=67e1681c1db9545ec05c458cad440a9197617a30"}, {"sha": "5e9ab8f1a2d00e2194cf95b042767f2387f5b175", "filename": "tests/ui/check-cfg/my-awesome-platform.json", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fcheck-cfg%2Fmy-awesome-platform.json", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fcheck-cfg%2Fmy-awesome-platform.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fmy-awesome-platform.json?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,12 @@\n+{\n+    \"llvm-target\": \"x86_64-unknown-none-gnu\",\n+    \"data-layout\": \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\",\n+    \"arch\": \"x86_64\",\n+    \"target-endian\": \"little\",\n+    \"target-pointer-width\": \"64\",\n+    \"target-c-int-width\": \"32\",\n+    \"os\": \"ericos\",\n+    \"linker-flavor\": \"ld.lld\",\n+    \"linker\": \"rust-lld\",\n+    \"executables\": true\n+}"}, {"sha": "2ef5a44592b8133aeca40ccdf4442b02e2f7acab", "filename": "tests/ui/check-cfg/values-target-json.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,21 @@\n+// This test checks that we don't lint values defined by a custom target (target json)\n+//\n+// check-pass\n+// needs-llvm-components: x86\n+// compile-flags: --crate-type=lib --check-cfg=values() --target={{src-base}}/check-cfg/my-awesome-platform.json -Z unstable-options\n+\n+#![feature(lang_items, no_core, auto_traits)]\n+#![no_core]\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+\n+#[cfg(target_os = \"linuz\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn target_os_linux_misspell() {}\n+\n+#[cfg(target_os = \"linux\")]\n+fn target_os_linux() {}\n+\n+#[cfg(target_os = \"ericos\")]\n+fn target_os_ericos() {}"}, {"sha": "b58d2970773b801548971abced9aa24a49e44ea6", "filename": "tests/ui/check-cfg/values-target-json.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Fvalues-target-json.stderr?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -0,0 +1,13 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/values-target-json.rs:13:7\n+   |\n+LL | #[cfg(target_os = \"linuz\")]\n+   |       ^^^^^^^^^^^^-------\n+   |                   |\n+   |                   help: did you mean: `\"linux\"`\n+   |\n+   = note: expected values for `target_os` are: aix, android, cuda, dragonfly, emscripten, ericos, espidf, freebsd, fuchsia, haiku, hermit, horizon, illumos, ios, l4re, linux, macos, netbsd, none, nto, openbsd, psp, redox, solaris, solid_asp3, tvos, uefi, unknown, vita, vxworks, wasi, watchos, windows, xous\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: 1 warning emitted\n+"}, {"sha": "762ecc3207fa558b3789c2d9d83b5652d57c7f25", "filename": "tests/ui/macros/nonterminal-matching.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fmacros%2Fnonterminal-matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fmacros%2Fnonterminal-matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacros%2Fnonterminal-matching.stderr?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -18,6 +18,7 @@ LL |     macro n(a $nt_item b) {\n ...\n LL | complex_nonterminal!(enum E {});\n    | ------------------------------- in this macro invocation\n+   = note: captured metavariables except for `$tt`, `$ident` and `$lifetime` cannot be compared to other tokens\n    = note: this error originates in the macro `complex_nonterminal` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "8f7a9c0837510ffb0763bf95e4a3de5b18894adb", "filename": "tests/ui/threads-sendsync/issue-43733-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fthreads-sendsync%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fthreads-sendsync%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthreads-sendsync%2Fissue-43733-2.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -21,7 +21,7 @@ impl<T> Key<T> {\n }\n \n #[cfg(target_thread_local)]\n-use std::thread::__FastLocalKeyInner as Key;\n+use std::thread::__LocalKeyInner as Key;\n \n static __KEY: Key<()> = Key::new();\n //~^ ERROR `UnsafeCell<Option<()>>` cannot be shared between threads"}, {"sha": "0eadef3e3e8cb8e4de2b114d4547de5f7b52052a", "filename": "tests/ui/threads-sendsync/issue-43733.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fthreads-sendsync%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e1681c1db9545ec05c458cad440a9197617a30/tests%2Fui%2Fthreads-sendsync%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fthreads-sendsync%2Fissue-43733.rs?ref=67e1681c1db9545ec05c458cad440a9197617a30", "patch": "@@ -1,8 +1,8 @@\n // ignore-wasm32\n // revisions: mir thir\n // [thir]compile-flags: -Z thir-unsafeck\n-// normalize-stderr-test: \"__FastLocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n-// normalize-stderr-test: \"__OsLocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n+// normalize-stderr-test: \"__LocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n+// normalize-stderr-test: \"__LocalKeyInner::<T>::get\" -> \"$$LOCALKEYINNER::<T>::get\"\n #![feature(thread_local)]\n #![feature(cfg_target_thread_local, thread_local_internals)]\n \n@@ -12,10 +12,10 @@ type Foo = std::cell::RefCell<String>;\n \n #[cfg(target_thread_local)]\n #[thread_local]\n-static __KEY: std::thread::__FastLocalKeyInner<Foo> = std::thread::__FastLocalKeyInner::new();\n+static __KEY: std::thread::__LocalKeyInner<Foo> = std::thread::__LocalKeyInner::new();\n \n #[cfg(not(target_thread_local))]\n-static __KEY: std::thread::__OsLocalKeyInner<Foo> = std::thread::__OsLocalKeyInner::new();\n+static __KEY: std::thread::__LocalKeyInner<Foo> = std::thread::__LocalKeyInner::new();\n \n fn __getit(_: Option<&mut Option<RefCell<String>>>) -> std::option::Option<&'static Foo> {\n     __KEY.get(Default::default)"}]}