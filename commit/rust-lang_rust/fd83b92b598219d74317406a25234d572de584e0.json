{"sha": "fd83b92b598219d74317406a25234d572de584e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkODNiOTJiNTk4MjE5ZDc0MzE3NDA2YTI1MjM0ZDU3MmRlNTg0ZTA=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-15T14:29:52Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-06-22T00:26:33Z"}, "message": "More Type refactorings", "tree": {"sha": "8c71a2810c0c6d6eacc30e67fc3fc81ccf1b2ccb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c71a2810c0c6d6eacc30e67fc3fc81ccf1b2ccb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd83b92b598219d74317406a25234d572de584e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd83b92b598219d74317406a25234d572de584e0", "html_url": "https://github.com/rust-lang/rust/commit/fd83b92b598219d74317406a25234d572de584e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd83b92b598219d74317406a25234d572de584e0/comments", "author": null, "committer": null, "parents": [{"sha": "1968622798ce565fe9f3905c972513393070a78e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1968622798ce565fe9f3905c972513393070a78e", "html_url": "https://github.com/rust-lang/rust/commit/1968622798ce565fe9f3905c972513393070a78e"}], "stats": {"total": 1048, "additions": 470, "deletions": 578}, "files": [{"sha": "731fa1c0ad79e9bb37b8033aa8a4d2f3509b660a", "filename": "src/librustc/back/upcall.rs", "status": "modified", "additions": 28, "deletions": 33, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fupcall.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -11,8 +11,8 @@\n \n use driver::session;\n use middle::trans::base;\n-use middle::trans::common::{T_fn, T_i8, T_i32, T_int, T_ptr, T_void};\n-use lib::llvm::{ModuleRef, ValueRef, TypeRef};\n+use middle::trans::type_::Type;\n+use lib::llvm::{ModuleRef, ValueRef};\n \n pub struct Upcalls {\n     trace: ValueRef,\n@@ -22,40 +22,35 @@ pub struct Upcalls {\n     reset_stack_limit: ValueRef\n }\n \n-pub fn declare_upcalls(targ_cfg: @session::config,\n-                       llmod: ModuleRef) -> @Upcalls {\n-    fn decl(llmod: ModuleRef, prefix: ~str, name: ~str,\n-            tys: ~[TypeRef], rv: TypeRef) ->\n-       ValueRef {\n-        let arg_tys = tys.map(|t| *t);\n-        let fn_ty = T_fn(arg_tys, rv);\n-        return base::decl_cdecl_fn(llmod, prefix + name, fn_ty);\n-    }\n-    fn nothrow(f: ValueRef) -> ValueRef {\n-        base::set_no_unwind(f); f\n-    }\n-    let d: &fn(a: ~str, b: ~[TypeRef], c: TypeRef) -> ValueRef =\n-        |a,b,c| decl(llmod, ~\"upcall_\", a, b, c);\n-    let dv: &fn(a: ~str, b: ~[TypeRef]) -> ValueRef =\n-        |a,b| decl(llmod, ~\"upcall_\", a, b, T_void());\n+macro_rules! upcall (\n+    (fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n+        let fn_ty = Type::func([ $($arg),* ], $ret);\n+        base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty)\n+    });\n+    (nothrow fn $name:ident($($arg:expr),+) -> $ret:expr) => ({\n+        let fn_ty = Type::func([ $($arg),* ], $ret);\n+        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n+        base::set_no_unwind(decl);\n+        decl\n+    });\n+    (nothrow fn $name:ident -> $ret:expr) => ({\n+        let fn_ty = Type::func([], $ret);\n+        let decl = base::decl_cdecl_fn(llmod, ~\"upcall_\" + stringify!($name), fn_ty);\n+        base::set_no_unwind(decl);\n+        decl\n+    })\n+)\n \n-    let int_t = T_int(targ_cfg);\n+pub fn declare_upcalls(targ_cfg: @session::config, llmod: ModuleRef) -> @Upcalls {\n+    let opaque_ptr = Type::i8().to_ptr();\n+    let int_ty = Type::int(targ_cfg.arch);\n \n     @Upcalls {\n-        trace: dv(~\"trace\", ~[T_ptr(T_i8()),\n-                              T_ptr(T_i8()),\n-                              int_t]),\n-        call_shim_on_c_stack:\n-            d(~\"call_shim_on_c_stack\",\n-              // arguments: void *args, void *fn_ptr\n-              ~[T_ptr(T_i8()), T_ptr(T_i8())],\n-              int_t),\n+        trace: upcall!(fn trace(opaque_ptr, opaque_ptr, int_ty) -> Type::void()),\n+        call_shim_on_c_stack: upcall!(fn call_shim_on_c_stack(opaque_ptr, opaque_ptr) -> int_ty),\n         call_shim_on_rust_stack:\n-            d(~\"call_shim_on_rust_stack\",\n-              ~[T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n-        rust_personality:\n-            nothrow(d(~\"rust_personality\", ~[], T_i32())),\n-        reset_stack_limit:\n-            nothrow(dv(~\"reset_stack_limit\", ~[]))\n+            upcall!(fn call_shim_on_rust_stack(opaque_ptr, opaque_ptr) -> int_ty),\n+        rust_personality: upcall!(nothrow fn rust_personality -> Type::i32()),\n+        reset_stack_limit: upcall!(nothrow fn reset_stack_limit -> Type::void())\n     }\n }"}, {"sha": "627474b21892c9b454e4c47f7120c51ad4a12da1", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -2233,18 +2233,6 @@ pub fn fn_ty_param_tys(fn_ty: TypeRef) -> ~[TypeRef] {\n     }\n }\n \n-pub fn struct_tys(struct_ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let n_elts = llvm::LLVMCountStructElementTypes(struct_ty) as uint;\n-        if n_elts == 0 {\n-            return ~[];\n-        }\n-        let mut elts = vec::from_elem(n_elts, ptr::null());\n-        llvm::LLVMGetStructElementTypes(struct_ty, &mut elts[0]);\n-        return elts;\n-    }\n-}\n-\n \n /* Memory-managed interface to target data. */\n "}, {"sha": "db5a642019c0800c9d3676d8b6f97682671427da", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -1644,7 +1644,7 @@ fn create_bindings_map(bcx: block, pat: @ast::pat) -> BindingsMap {\n                 // but during matching we need to store a *T as explained\n                 // above\n                 let is_move = ccx.maps.moves_map.contains(&p_id);\n-                llmatch = alloca(bcx, T_ptr(llvariable_ty));\n+                llmatch = alloca(bcx, llvariable_ty.ptr_to());\n                 trmode = TrByValue(is_move, alloca(bcx, llvariable_ty));\n             }\n             ast::bind_by_ref(_) => {"}, {"sha": "65163e384b1fb6ff99628acc7cda495d9ec932bf", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -49,7 +49,7 @@ use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n use core::vec;\n \n-use lib::llvm::{ValueRef, TypeRef, True, IntEQ, IntNE};\n+use lib::llvm::{ValueRef, True, IntEQ, IntNE};\n use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n@@ -212,7 +212,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n \n fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n     let lltys = tys.map(|&ty| type_of::sizing_type_of(cx, ty));\n-    let llty_rec = T_struct(lltys, packed);\n+    let llty_rec = Type::struct_(lltys, packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n@@ -226,17 +226,16 @@ fn mk_struct(cx: &mut CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n  * All nominal types are LLVM structs, in order to be able to use\n  * forward-declared opaque types to prevent circularity in `type_of`.\n  */\n-pub fn fields_of(cx: &mut CrateContext, r: &Repr) -> ~[TypeRef] {\n+pub fn fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n     generic_fields_of(cx, r, false)\n }\n /// Like `fields_of`, but for `type_of::sizing_type_of` (q.v.).\n-pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[TypeRef] {\n+pub fn sizing_fields_of(cx: &mut CrateContext, r: &Repr) -> ~[Type] {\n     generic_fields_of(cx, r, true)\n }\n-fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool)\n-    -> ~[TypeRef] {\n+fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool) -> ~[Type] {\n     match *r {\n-        CEnum(*) => ~[T_enum_discrim(cx)],\n+        CEnum(*) => ~[Type::enum_discrim(cx)],\n         Univariant(ref st, _dtor) => struct_llfields(cx, st, sizing),\n         NullablePointer{ nonnull: ref st, _ } => struct_llfields(cx, st, sizing),\n         General(ref sts) => {\n@@ -261,14 +260,15 @@ fn generic_fields_of(cx: &mut CrateContext, r: &Repr, sizing: bool)\n             let most_aligned = most_aligned.get();\n             let padding = largest_size - most_aligned.size;\n \n+            assert!(padding >= 0);\n+\n             struct_llfields(cx, most_aligned, sizing)\n-                + [T_array(T_i8(), padding /*bad*/as uint)]\n+                + [Type::array(Type::i8(), padding /*bad*/as uint)]\n         }\n     }\n }\n \n-fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool)\n-    -> ~[TypeRef] {\n+fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type] {\n     if sizing {\n         st.fields.map(|&ty| type_of::sizing_type_of(cx, ty))\n     } else {\n@@ -309,7 +309,7 @@ pub fn trans_get_discr(bcx: block, r: &Repr, scrutinee: ValueRef)\n                                          (cases.len() - 1) as int),\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n             ZExt(bcx, nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee),\n-                 T_enum_discrim(bcx.ccx()))\n+                 Type::enum_discrim(bcx.ccx()))\n         }\n     }\n }\n@@ -438,11 +438,11 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n             } else {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n-                let llty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n+                let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n                 assert_eq!(machine::llsize_of_alloc(bcx.ccx(), llty), 0);\n                 // The contents of memory at this pointer can't matter, but use\n                 // the value that's \"reasonable\" in case of pointer comparison.\n-                PointerCast(bcx, val, T_ptr(llty))\n+                PointerCast(bcx, val, ty.ptr_to())\n             }\n         }\n     }\n@@ -456,8 +456,8 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n         let fields = do st.fields.map |&ty| {\n             type_of::type_of(ccx, ty)\n         };\n-        let real_llty = T_struct(fields, st.packed);\n-        PointerCast(bcx, val, T_ptr(real_llty))\n+        let real_ty = Type::struct_(fields, st.packed);\n+        PointerCast(bcx, val, real_llty.to_ptr().to_ref())\n     } else {\n         val\n     };\n@@ -572,7 +572,7 @@ fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n }\n \n fn padding(size: u64) -> ValueRef {\n-    C_undef(T_array(T_i8(), size /*bad*/as uint))\n+    C_undef(Type::array(Type::i8(), size).to_ref())\n }\n \n // XXX this utility routine should be somewhere more general"}, {"sha": "17294107ce367494f51523cf6c3f179405be1742", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -110,11 +110,11 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     // Depending on how many outputs we have, the return type is different\n     let output = if numOutputs == 0 {\n-        T_void()\n+        Type::void()\n     } else if numOutputs == 1 {\n         val_ty(outputs[0])\n     } else {\n-        T_struct(outputs.map(|o| val_ty(*o)), false)\n+        Type::struct_(outputs.map(|o| val_ty(*o)), false)\n     };\n \n     let dialect = match ia.dialect {\n@@ -130,12 +130,12 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     // Again, based on how many outputs we have\n     if numOutputs == 1 {\n-        let op = PointerCast(bcx, aoutputs[0], T_ptr(val_ty(outputs[0])));\n+        let op = PointerCast(bcx, aoutputs[0], val_ty(outputs[0]).ptr_to());\n         Store(bcx, r, op);\n     } else {\n         for aoutputs.iter().enumerate().advance |(i, o)| {\n             let v = ExtractValue(bcx, r, i);\n-            let op = PointerCast(bcx, *o, T_ptr(val_ty(outputs[i])));\n+            let op = PointerCast(bcx, *o, val_ty(outputs[i]).ptr_to());\n             Store(bcx, v, op);\n         }\n     }"}, {"sha": "de91a9c593a532e5e1582c377c5dab55ca57a3d4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 156, "deletions": 309, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -29,7 +29,7 @@ use back::link::{mangle_exported_name};\n use back::{link, abi};\n use driver::session;\n use driver::session::Session;\n-use lib::llvm::{ContextRef, ModuleRef, ValueRef, TypeRef, BasicBlockRef};\n+use lib::llvm::{ContextRef, ModuleRef, ValueRef, BasicBlockRef};\n use lib::llvm::{llvm, True, False};\n use lib;\n use metadata::common::LinkMeta;\n@@ -138,42 +138,33 @@ fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n     }\n }\n \n-pub fn decl_fn(llmod: ModuleRef,\n-               name: &str,\n-               cc: lib::llvm::CallConv,\n-               llty: TypeRef)\n-               -> ValueRef {\n-    let llfn: ValueRef = str::as_c_str(name, |buf| {\n+pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n+    let llfn: ValueRef = do name.as_c_str |buf| {\n         unsafe {\n-            llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n+            llvm::LLVMGetOrInsertFunction(llmod, buf, ty.to_ref())\n         }\n-    });\n+    };\n \n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     return llfn;\n }\n \n-pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef)\n-                  -> ValueRef {\n+pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, ty: Type) -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n }\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, llty: TypeRef) ->\n-   ValueRef {\n-    let llfn = decl_cdecl_fn(llmod, name, llty);\n+pub fn decl_internal_cdecl_fn(llmod: ModuleRef, name: ~str, ty: Type) -> ValueRef {\n+    let llfn = decl_cdecl_fn(llmod, name, ty);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: &mut ExternMap,\n-                     llmod: ModuleRef,\n-                     name: @str,\n-                     cc: lib::llvm::CallConv,\n-                     ty: TypeRef) -> ValueRef {\n-    match externs.find(&name) {\n-        Some(n) => return copy *n,\n+pub fn get_extern_fn(externs: &mut ExternMap, llmod: ModuleRef, name: @str,\n+                     cc: lib::llvm::CallConv, ty: Type) -> ValueRef {\n+    match externs.find_copy(&name) {\n+        Some(n) => return n,\n         None => ()\n     }\n     let f = decl_fn(llmod, name, cc, ty);\n@@ -182,43 +173,19 @@ pub fn get_extern_fn(externs: &mut ExternMap,\n }\n \n pub fn get_extern_const(externs: &mut ExternMap, llmod: ModuleRef,\n-                        name: @str, ty: TypeRef) -> ValueRef {\n-    match externs.find(&name) {\n-        Some(n) => return copy *n,\n+                        name: @str, ty: Type) -> ValueRef {\n+    match externs.find_copy(&name) {\n+        Some(n) => return n,\n         None => ()\n     }\n     unsafe {\n-        let c = str::as_c_str(name, |buf| {\n-            llvm::LLVMAddGlobal(llmod, ty, buf)\n-        });\n+        let c = do name.as_c_str |buf| {\n+            llvm::LLVMAddGlobal(llmod, ty.to_ref(), buf)\n+        };\n         externs.insert(name, c);\n         return c;\n     }\n }\n-\n-fn get_simple_extern_fn(cx: block,\n-                        externs: &mut ExternMap,\n-                        llmod: ModuleRef,\n-                        name: @str,\n-                        n_args: int) -> ValueRef {\n-    let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n-    let ccx = cx.fcx.ccx;\n-    let inputs = vec::from_elem(n_args as uint, ccx.int_type);\n-    let output = ccx.int_type;\n-    let t = T_fn(inputs, output);\n-    return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n-}\n-\n-pub fn trans_foreign_call(cx: block, externs: &mut ExternMap,\n-                          llmod: ModuleRef, name: @str, args: &[ValueRef]) ->\n-   ValueRef {\n-    let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n-    let n = args.len() as int;\n-    let llforeign: ValueRef =\n-        get_simple_extern_fn(cx, externs, llmod, name, n);\n-    return Call(cx, llforeign, args);\n-}\n-\n pub fn umax(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"umax\");\n     let cond = ICmp(cx, lib::llvm::IntULT, a, b);\n@@ -236,7 +203,7 @@ pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n // return type, use bump_ptr().\n pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"ptr_offs\");\n-    let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n+    let raw = PointerCast(bcx, base, Type::i8p());\n     InBoundsGEP(bcx, raw, [sz])\n }\n \n@@ -247,7 +214,7 @@ pub fn bump_ptr(bcx: block, t: ty::t, base: ValueRef, sz: ValueRef) ->\n     let _icx = bcx.insn_ctxt(\"bump_ptr\");\n     let ccx = bcx.ccx();\n     let bumped = ptr_offs(bcx, base, sz);\n-    let typ = T_ptr(type_of(ccx, t));\n+    let typ = type_of(ccx, t).ptr_to();\n     PointerCast(bcx, bumped, typ)\n }\n \n@@ -262,8 +229,8 @@ pub fn opaque_box_body(bcx: block,\n     let _icx = bcx.insn_ctxt(\"opaque_box_body\");\n     let ccx = bcx.ccx();\n     let ty = type_of(ccx, body_t);\n-    let ty = T_box(ccx, ty);\n-    let boxptr = PointerCast(bcx, boxptr, T_ptr(ty));\n+    let ty = Type::box(ccx, ty);\n+    let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n     GEPi(bcx, boxptr, [0u, abi::box_field_body])\n }\n \n@@ -294,8 +261,8 @@ pub fn malloc_raw_dyn(bcx: block,\n     glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n     // Allocate space:\n-    let tydesc = PointerCast(bcx, static_ti.tydesc, T_ptr(T_i8()));\n-    let rval = alloca(bcx, T_ptr(T_i8()));\n+    let tydesc = PointerCast(bcx, static_ti.tydesc, Type::i8p());\n+    let rval = alloca(bcx, Type::i8p());\n     let bcx = callee::trans_lang_call(\n         bcx,\n         langcall,\n@@ -320,7 +287,7 @@ pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n         add_comment(bcx, \"non_gc_box_cast\");\n         assert!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n                      gc_box_addrspace || bcx.unreachable);\n-        let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n+        let non_gc_t = llvm::LLVMGetElementType(val_ty(val)).ptr_to();\n         PointerCast(bcx, val, non_gc_t)\n     }\n }\n@@ -760,8 +727,8 @@ pub fn cast_shift_const_rhs(op: ast::binop,\n \n pub fn cast_shift_rhs(op: ast::binop,\n                       lhs: ValueRef, rhs: ValueRef,\n-                      trunc: &fn(ValueRef, TypeRef) -> ValueRef,\n-                      zext: &fn(ValueRef, TypeRef) -> ValueRef)\n+                      trunc: &fn(ValueRef, Type) -> ValueRef,\n+                      zext: &fn(ValueRef, Type) -> ValueRef)\n                    -> ValueRef {\n     // Shifts may have any size int on the rhs\n     unsafe {\n@@ -794,11 +761,11 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n-        let zero = C_integral(T_int_ty(cx.ccx(), t), 0u64, False);\n+        let zero = C_integral(Type::int_from_ty(cx.ccx(), t), 0u64, False);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       ty::ty_uint(t) => {\n-        let zero = C_integral(T_uint_ty(cx.ccx(), t), 0u64, False);\n+        let zero = C_integral(Type::uint_from_ty(cx.ccx(), t), 0u64, False);\n         ICmp(cx, lib::llvm::IntEQ, rhs, zero)\n       }\n       _ => {\n@@ -812,7 +779,7 @@ pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n }\n \n pub fn null_env_ptr(bcx: block) -> ValueRef {\n-    C_null(T_opaque_box_ptr(bcx.ccx()))\n+    C_null(Type::opaque_box(bcx.ccx()).to_ptr())\n }\n \n pub fn trans_external_path(ccx: &mut CrateContext, did: ast::def_id, t: ty::t)\n@@ -835,7 +802,7 @@ pub fn invoke(bcx: block, llfn: ValueRef, llargs: ~[ValueRef])\n            -> (ValueRef, block) {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable {\n-        return (C_null(T_i8()), bcx);\n+        return (C_null(Type::i8()), bcx);\n     }\n \n     match bcx.node_info {\n@@ -968,7 +935,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n-    let llretty = T_struct([T_ptr(T_i8()), T_i32()], false);\n+    let llretty = Type::struct_([Type::i8p(), Type::i32()], false);\n     // The exception handling personality function. This is the C++\n     // personality function __gxx_personality_v0, wrapped in our naming\n     // convention.\n@@ -1026,7 +993,7 @@ pub fn find_bcx_for_scope(bcx: block, scope_id: ast::node_id) -> block {\n \n pub fn do_spill(bcx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     if ty::type_is_bot(t) {\n-        return C_null(T_ptr(T_i8()));\n+        return C_null(Type::i8p());\n     }\n     let llptr = alloc_ty(bcx, t);\n     Store(bcx, v, llptr);\n@@ -1069,8 +1036,8 @@ pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n       }\n     };\n     let ccx = bcx.ccx();\n-    let V_trace_str = PointerCast(bcx, V_trace_str, T_ptr(T_i8()));\n-    let V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n+    let V_trace_str = PointerCast(bcx, V_trace_str, Type::i8p());\n+    let V_filename = PointerCast(bcx, V_filename, Type::i8p());\n     let args = ~[V_trace_str, V_filename, C_int(ccx, V_line)];\n     Call(bcx, ccx.upcalls.trace, args);\n }\n@@ -1466,8 +1433,8 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n         X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n     let memcpy = ccx.intrinsics.get_copy(&key);\n-    let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n-    let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n+    let src_ptr = PointerCast(cx, src, Type::i8p());\n+    let dst_ptr = PointerCast(cx, dst, Type::i8p());\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(align as i32);\n     let volatile = C_i1(false);\n@@ -1510,50 +1477,48 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     };\n \n     let llintrinsicfn = ccx.intrinsics.get_copy(&intrinsic_key);\n-    let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n+    let llptr = PointerCast(cx, llptr, Type::i8().ptr_to());\n     let llzeroval = C_u8(0);\n-    let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n-    let align = C_i32(llalign_of_min(ccx, llty) as i32);\n+    let size = IntCast(cx, machine::llsize_of(ccx, ty), ccx.int_type.to_ref());\n+    let align = C_i32(llalign_of_min(ccx, ty) as i32);\n     let volatile = C_i1(false);\n     Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"alloc_ty\");\n     let ccx = bcx.ccx();\n-    let llty = type_of::type_of(ccx, t);\n-    if ty::type_has_params(t) { debug!(\"%s\", ty_to_str(ccx.tcx, t)); }\n-    assert!(!ty::type_has_params(t));\n-    let val = alloca(bcx, llty);\n+    let ty = type_of::type_of(ccx, t);\n+    assert!(!ty::type_has_params(t), \"Type has params: %s\", ty_to_str(ccx.tcx, t));\n+    let val = alloca(bcx, ty);\n     return val;\n }\n \n-pub fn alloca(cx: block, t: TypeRef) -> ValueRef {\n-    alloca_maybe_zeroed(cx, t, false)\n+pub fn alloca(cx: block, ty: Type) -> ValueRef {\n+    alloca_maybe_zeroed(cx, ty, false)\n }\n \n pub fn alloca_maybe_zeroed(cx: block, t: TypeRef, zero: bool) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"alloca\");\n     if cx.unreachable {\n         unsafe {\n-            return llvm::LLVMGetUndef(t);\n+            return llvm::LLVMGetUndef(ty.to_ref());\n         }\n     }\n     let initcx = base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas);\n-    let p = Alloca(initcx, t);\n-    if zero { memzero(initcx, p, t); }\n-    return p;\n+    let p = Alloca(initcx, ty.to_ref());\n+    if zero { memzero(initcx, p, ty); }\n+    p\n }\n \n pub fn arrayalloca(cx: block, t: TypeRef, v: ValueRef) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"arrayalloca\");\n     if cx.unreachable {\n         unsafe {\n-            return llvm::LLVMGetUndef(t);\n+            return llvm::LLVMGetUndef(ty);\n         }\n     }\n-    return ArrayAlloca(\n-        base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), t, v);\n+    return ArrayAlloca(base::raw_block(cx.fcx, false, cx.fcx.llstaticallocas), ty.to_ref(), v);\n }\n \n pub struct BasicBlocks {\n@@ -1623,7 +1588,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n     let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe {\n-              llvm::LLVMGetUndef(T_ptr(T_i8()))\n+              llvm::LLVMGetUndef(Type::i8p())\n           },\n           llretptr: None,\n           llstaticallocas: llbbs.sa,\n@@ -1741,7 +1706,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n                 Store(bcx, tmp, alloc);\n                 alloc\n             } else {\n-                PointerCast(bcx, slf.v, T_ptr(type_of(bcx.ccx(), slf.t)))\n+                PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n             };\n \n             fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n@@ -2268,7 +2233,7 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n                           attrs: &[ast::attribute],\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n-                          llfty: TypeRef)\n+                          fn_ty: Type)\n                           -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n@@ -2280,12 +2245,11 @@ pub fn register_fn_fuller(ccx: @mut CrateContext,\n         mangle_exported_name(ccx, /*bad*/copy path, node_type)\n     };\n \n-    let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n+    let llfn = decl_fn(ccx.llmod, ps, cc, fn_ty);\n     ccx.item_symbols.insert(node_id, ps);\n \n     // FIXME #4404 android JNI hacks\n-    let is_entry = is_entry_fn(&ccx.sess, node_id) &&\n-                     (!*ccx.sess.building_library ||\n+    let is_entry = is_entry_fn(&ccx.sess, node_id) && (!*ccx.sess.building_library ||\n                       (*ccx.sess.building_library &&\n                        ccx.sess.targ_cfg.os == session::os_android));\n     if is_entry {\n@@ -2345,7 +2309,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n     fn create_entry_fn(ccx: @mut CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = T_fn([ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n+        let llfty = Type::func([ccx.int_type, Type::i8().ptr_to().ptr_to()], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n         let llfn = if *ccx.sess.building_library {\n@@ -2376,7 +2340,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n             let crate_map = ccx.crate_map;\n             let opaque_crate_map = llvm::LLVMBuildPointerCast(bld,\n                                                               crate_map,\n-                                                              T_ptr(T_i8()),\n+                                                              Type::i8p(),\n                                                               noname());\n \n             let (start_fn, args) = if use_start_lang_item {\n@@ -2391,10 +2355,10 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n \n                 let args = {\n                     let opaque_rust_main = llvm::LLVMBuildPointerCast(\n-                            bld, rust_main, T_ptr(T_i8()), noname());\n+                            bld, rust_main, Type::i8p(), noname());\n \n                     ~[\n-                        C_null(T_opaque_box_ptr(ccx)),\n+                        C_null(Type::opaque_box(ccx).ptr_to()),\n                         opaque_rust_main,\n                         llvm::LLVMGetParam(llfn, 0),\n                         llvm::LLVMGetParam(llfn, 1),\n@@ -2406,7 +2370,7 @@ pub fn create_entry_wrapper(ccx: @mut CrateContext,\n                 debug!(\"using user-defined start fn\");\n                 let args = {\n                     ~[\n-                        C_null(T_opaque_box_ptr(ccx)),\n+                        C_null(Type::opaque_box(ccx).ptr_to()),\n                         llvm::LLVMGetParam(llfn, 0 as c_uint),\n                         llvm::LLVMGetParam(llfn, 1 as c_uint),\n                         opaque_crate_map\n@@ -2432,7 +2396,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n     let code_cell = GEPi(bcx, pair, [0u, abi::fn_field_code]);\n     Store(bcx, llfn, code_cell);\n     let env_cell = GEPi(bcx, pair, [0u, abi::fn_field_box]);\n-    let llenvblobptr = PointerCast(bcx, llenvptr, T_opaque_box_ptr(ccx));\n+    let llenvblobptr = PointerCast(bcx, llenvptr, Type::opaque_box(ccx).ptr_to());\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n@@ -2656,215 +2620,98 @@ pub fn p2i(ccx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n-    let T_memcpy32_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n-    let T_memcpy64_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i64(), T_i32(), T_i1()];\n-    let T_memset32_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_i8(), T_i32(), T_i32(), T_i1()];\n-    let T_memset64_args: ~[TypeRef] =\n-        ~[T_ptr(T_i8()), T_i8(), T_i64(), T_i32(), T_i1()];\n-    let T_trap_args: ~[TypeRef] = ~[];\n-    let T_frameaddress_args: ~[TypeRef] = ~[T_i32()];\n-    let gcroot =\n-        decl_cdecl_fn(llmod, \"llvm.gcroot\",\n-                      T_fn([T_ptr(T_ptr(T_i8())), T_ptr(T_i8())],\n-                           T_void()));\n-    let gcread =\n-        decl_cdecl_fn(llmod, \"llvm.gcread\",\n-                      T_fn([T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))],\n-                           T_void()));\n-    let memcpy32 =\n-        decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i32\",\n-                      T_fn(T_memcpy32_args, T_void()));\n-    let memcpy64 =\n-        decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i64\",\n-                      T_fn(T_memcpy64_args, T_void()));\n-    let memmove32 =\n-        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n-                      T_fn(T_memcpy32_args, T_void()));\n-    let memmove64 =\n-        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i64\",\n-                      T_fn(T_memcpy64_args, T_void()));\n-    let memset32 =\n-        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i32\",\n-                      T_fn(T_memset32_args, T_void()));\n-    let memset64 =\n-        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n-                      T_fn(T_memset64_args, T_void()));\n-    let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args,\n-                                                      T_void()));\n-    let frameaddress = decl_cdecl_fn(llmod, \"llvm.frameaddress\",\n-                                     T_fn(T_frameaddress_args,\n-                                          T_ptr(T_i8())));\n-    let sqrtf32 = decl_cdecl_fn(llmod, \"llvm.sqrt.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let sqrtf64 = decl_cdecl_fn(llmod, \"llvm.sqrt.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let powif32 = decl_cdecl_fn(llmod, \"llvm.powi.f32\",\n-                                T_fn([T_f32(), T_i32()], T_f32()));\n-    let powif64 = decl_cdecl_fn(llmod, \"llvm.powi.f64\",\n-                                T_fn([T_f64(), T_i32()], T_f64()));\n-    let sinf32 = decl_cdecl_fn(llmod, \"llvm.sin.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let sinf64 = decl_cdecl_fn(llmod, \"llvm.sin.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let cosf32 = decl_cdecl_fn(llmod, \"llvm.cos.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let cosf64 = decl_cdecl_fn(llmod, \"llvm.cos.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let powf32 = decl_cdecl_fn(llmod, \"llvm.pow.f32\",\n-                                T_fn([T_f32(), T_f32()], T_f32()));\n-    let powf64 = decl_cdecl_fn(llmod, \"llvm.pow.f64\",\n-                                T_fn([T_f64(), T_f64()], T_f64()));\n-    let expf32 = decl_cdecl_fn(llmod, \"llvm.exp.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let expf64 = decl_cdecl_fn(llmod, \"llvm.exp.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let exp2f32 = decl_cdecl_fn(llmod, \"llvm.exp2.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let exp2f64 = decl_cdecl_fn(llmod, \"llvm.exp2.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let logf32 = decl_cdecl_fn(llmod, \"llvm.log.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let logf64 = decl_cdecl_fn(llmod, \"llvm.log.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let log10f32 = decl_cdecl_fn(llmod, \"llvm.log10.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let log10f64 = decl_cdecl_fn(llmod, \"llvm.log10.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let log2f32 = decl_cdecl_fn(llmod, \"llvm.log2.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let log2f64 = decl_cdecl_fn(llmod, \"llvm.log2.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let fmaf32 = decl_cdecl_fn(llmod, \"llvm.fma.f32\",\n-                                T_fn([T_f32(), T_f32(), T_f32()], T_f32()));\n-    let fmaf64 = decl_cdecl_fn(llmod, \"llvm.fma.f64\",\n-                                T_fn([T_f64(), T_f64(), T_f64()], T_f64()));\n-    let fabsf32 = decl_cdecl_fn(llmod, \"llvm.fabs.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let fabsf64 = decl_cdecl_fn(llmod, \"llvm.fabs.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let floorf32 = decl_cdecl_fn(llmod, \"llvm.floor.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let floorf64 = decl_cdecl_fn(llmod, \"llvm.floor.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let ceilf32 = decl_cdecl_fn(llmod, \"llvm.ceil.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let ceilf64 = decl_cdecl_fn(llmod, \"llvm.ceil.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let truncf32 = decl_cdecl_fn(llmod, \"llvm.trunc.f32\",\n-                                T_fn([T_f32()], T_f32()));\n-    let truncf64 = decl_cdecl_fn(llmod, \"llvm.trunc.f64\",\n-                                T_fn([T_f64()], T_f64()));\n-    let ctpop8 = decl_cdecl_fn(llmod, \"llvm.ctpop.i8\",\n-                                T_fn([T_i8()], T_i8()));\n-    let ctpop16 = decl_cdecl_fn(llmod, \"llvm.ctpop.i16\",\n-                                T_fn([T_i16()], T_i16()));\n-    let ctpop32 = decl_cdecl_fn(llmod, \"llvm.ctpop.i32\",\n-                                T_fn([T_i32()], T_i32()));\n-    let ctpop64 = decl_cdecl_fn(llmod, \"llvm.ctpop.i64\",\n-                                T_fn([T_i64()], T_i64()));\n-    let ctlz8 = decl_cdecl_fn(llmod, \"llvm.ctlz.i8\",\n-                                T_fn([T_i8(), T_i1()], T_i8()));\n-    let ctlz16 = decl_cdecl_fn(llmod, \"llvm.ctlz.i16\",\n-                                T_fn([T_i16(), T_i1()], T_i16()));\n-    let ctlz32 = decl_cdecl_fn(llmod, \"llvm.ctlz.i32\",\n-                                T_fn([T_i32(), T_i1()], T_i32()));\n-    let ctlz64 = decl_cdecl_fn(llmod, \"llvm.ctlz.i64\",\n-                                T_fn([T_i64(), T_i1()], T_i64()));\n-    let cttz8 = decl_cdecl_fn(llmod, \"llvm.cttz.i8\",\n-                                T_fn([T_i8(), T_i1()], T_i8()));\n-    let cttz16 = decl_cdecl_fn(llmod, \"llvm.cttz.i16\",\n-                                T_fn([T_i16(), T_i1()], T_i16()));\n-    let cttz32 = decl_cdecl_fn(llmod, \"llvm.cttz.i32\",\n-                                T_fn([T_i32(), T_i1()], T_i32()));\n-    let cttz64 = decl_cdecl_fn(llmod, \"llvm.cttz.i64\",\n-                                T_fn([T_i64(), T_i1()], T_i64()));\n-    let bswap16 = decl_cdecl_fn(llmod, \"llvm.bswap.i16\",\n-                                T_fn([T_i16()], T_i16()));\n-    let bswap32 = decl_cdecl_fn(llmod, \"llvm.bswap.i32\",\n-                                T_fn([T_i32()], T_i32()));\n-    let bswap64 = decl_cdecl_fn(llmod, \"llvm.bswap.i64\",\n-                                T_fn([T_i64()], T_i64()));\n+macro_rules! ifn (\n+    ($name:expr, $args:expr, $ret:expr) => ({\n+        let name = $name;\n+        let f = decl_cdecl_fn(llmod, name, Type::func($args, $ret));\n+        intrinsics.insert(name, f);\n+    })\n+)\n \n+pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n+    let i8p = Type::i8p();\n     let mut intrinsics = HashMap::new();\n-    intrinsics.insert(\"llvm.gcroot\", gcroot);\n-    intrinsics.insert(\"llvm.gcread\", gcread);\n-    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n-    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i64\", memcpy64);\n-    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n-    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n-    intrinsics.insert(\"llvm.memset.p0i8.i32\", memset32);\n-    intrinsics.insert(\"llvm.memset.p0i8.i64\", memset64);\n-    intrinsics.insert(\"llvm.trap\", trap);\n-    intrinsics.insert(\"llvm.frameaddress\", frameaddress);\n-    intrinsics.insert(\"llvm.sqrt.f32\", sqrtf32);\n-    intrinsics.insert(\"llvm.sqrt.f64\", sqrtf64);\n-    intrinsics.insert(\"llvm.powi.f32\", powif32);\n-    intrinsics.insert(\"llvm.powi.f64\", powif64);\n-    intrinsics.insert(\"llvm.sin.f32\", sinf32);\n-    intrinsics.insert(\"llvm.sin.f64\", sinf64);\n-    intrinsics.insert(\"llvm.cos.f32\", cosf32);\n-    intrinsics.insert(\"llvm.cos.f64\", cosf64);\n-    intrinsics.insert(\"llvm.pow.f32\", powf32);\n-    intrinsics.insert(\"llvm.pow.f64\", powf64);\n-    intrinsics.insert(\"llvm.exp.f32\", expf32);\n-    intrinsics.insert(\"llvm.exp.f64\", expf64);\n-    intrinsics.insert(\"llvm.exp2.f32\", exp2f32);\n-    intrinsics.insert(\"llvm.exp2.f64\", exp2f64);\n-    intrinsics.insert(\"llvm.log.f32\", logf32);\n-    intrinsics.insert(\"llvm.log.f64\", logf64);\n-    intrinsics.insert(\"llvm.log10.f32\", log10f32);\n-    intrinsics.insert(\"llvm.log10.f64\", log10f64);\n-    intrinsics.insert(\"llvm.log2.f32\", log2f32);\n-    intrinsics.insert(\"llvm.log2.f64\", log2f64);\n-    intrinsics.insert(\"llvm.fma.f32\", fmaf32);\n-    intrinsics.insert(\"llvm.fma.f64\", fmaf64);\n-    intrinsics.insert(\"llvm.fabs.f32\", fabsf32);\n-    intrinsics.insert(\"llvm.fabs.f64\", fabsf64);\n-    intrinsics.insert(\"llvm.floor.f32\", floorf32);\n-    intrinsics.insert(\"llvm.floor.f64\", floorf64);\n-    intrinsics.insert(\"llvm.ceil.f32\", ceilf32);\n-    intrinsics.insert(\"llvm.ceil.f64\", ceilf64);\n-    intrinsics.insert(\"llvm.trunc.f32\", truncf32);\n-    intrinsics.insert(\"llvm.trunc.f64\", truncf64);\n-    intrinsics.insert(\"llvm.ctpop.i8\", ctpop8);\n-    intrinsics.insert(\"llvm.ctpop.i16\", ctpop16);\n-    intrinsics.insert(\"llvm.ctpop.i32\", ctpop32);\n-    intrinsics.insert(\"llvm.ctpop.i64\", ctpop64);\n-    intrinsics.insert(\"llvm.ctlz.i8\", ctlz8);\n-    intrinsics.insert(\"llvm.ctlz.i16\", ctlz16);\n-    intrinsics.insert(\"llvm.ctlz.i32\", ctlz32);\n-    intrinsics.insert(\"llvm.ctlz.i64\", ctlz64);\n-    intrinsics.insert(\"llvm.cttz.i8\", cttz8);\n-    intrinsics.insert(\"llvm.cttz.i16\", cttz16);\n-    intrinsics.insert(\"llvm.cttz.i32\", cttz32);\n-    intrinsics.insert(\"llvm.cttz.i64\", cttz64);\n-    intrinsics.insert(\"llvm.bswap.i16\", bswap16);\n-    intrinsics.insert(\"llvm.bswap.i32\", bswap32);\n-    intrinsics.insert(\"llvm.bswap.i64\", bswap64);\n+\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\",\n+         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\",\n+         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\",\n+         [i8p, i8p, Type::i32(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\",\n+         [i8p, i8p, Type::i64(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memset.p0i8.i32\",\n+         [i8p, Type::i8(), Type::i32(), Type::i32(), Type::i1()], Type::void());\n+    ifn!(\"llvm.memcpy.p0i8.i64\",\n+         [i8p, Type::i8(), Type::i64(), Type::i32(), Type::i1()], Type::void());\n+\n+    ifn!(\"llvm.trap\", [], Type::void());\n+    ifn!(\"llvm.frameaddress\", [Type::i32()], i8p);\n+\n+    ifn!(\"llvm.powi.f32\", [Type::f32(), Type::i32()], Type::f32());\n+    ifn!(\"llvm.powi.f64\", [Type::f64(), Type::i32()], Type::f64());\n+    ifn!(\"llvm.pow.f32\",  [Type::f32(), Type::f32()], Type::f32());\n+    ifn!(\"llvm.pow.f64\",  [Type::f64(), Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.sqrt.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.sqrt.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.sin.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.sin.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.cos.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.cos.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.exp.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.exp.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.exp2.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.exp2.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.log.f32\",  [Type::f32()], Type::f32());\n+    ifn!(\"llvm.log.f64\",  [Type::f64()], Type::f64());\n+    ifn!(\"llvm.log10.f32\",[Type::f32()], Type::f32());\n+    ifn!(\"llvm.log10.f64\",[Type::f64()], Type::f64());\n+    ifn!(\"llvm.log2.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.log2.f64\", [Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.fma.f32\",  [Type::f32(), Type::f32(), Type::f32()], Type::f32());\n+    ifn!(\"llvm.fma.f64\",  [Type::f64(), Type::f64(), Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.fabs.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.fabs.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.floor.f32\",[Type::f32()], Type::f32());\n+    ifn!(\"llvm.floor.f64\",[Type::f64()], Type::f64());\n+    ifn!(\"llvm.ceil.f32\", [Type::f32()], Type::f32());\n+    ifn!(\"llvm.ceil.f64\", [Type::f64()], Type::f64());\n+    ifn!(\"llvm.trunc.f32\",[Type::f32()], Type::f32());\n+    ifn!(\"llvm.trunc.f64\",[Type::f64()], Type::f64());\n+\n+    ifn!(\"llvm.ctpop.i8\", [Type::i8()], Type::i8());\n+    ifn!(\"llvm.ctpop.i16\",[Type::i16()], Type::i16());\n+    ifn!(\"llvm.ctpop.i32\",[Type::i32()], Type::i32());\n+    ifn!(\"llvm.ctpop.i64\",[Type::i64()], Type::i64());\n+\n+    ifn!(\"llvm.ctlz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n+    ifn!(\"llvm.ctlz.i16\", [Type::i16(), Type::i1()], Type::i16());\n+    ifn!(\"llvm.ctlz.i32\", [Type::i32(), Type::i1()], Type::i32());\n+    ifn!(\"llvm.ctlz.i64\", [Type::i64(), Type::i1()], Type::i64());\n+\n+    ifn!(\"llvm.cttz.i8\",  [Type::i8() , Type::i1()], Type::i8());\n+    ifn!(\"llvm.cttz.i16\", [Type::i16(), Type::i1()], Type::i16());\n+    ifn!(\"llvm.cttz.i32\", [Type::i32(), Type::i1()], Type::i32());\n+    ifn!(\"llvm.cttz.i64\", [Type::i64(), Type::i1()], Type::i64());\n+\n+    ifn!(\"llvm.bswap.i16\",[Type::i16()], Type::i16());\n+    ifn!(\"llvm.bswap.i32\",[Type::i32()], Type::i32());\n+    ifn!(\"llvm.bswap.i64\",[Type::i64()], Type::i64());\n \n     return intrinsics;\n }\n \n-pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n-                              intrinsics: &mut HashMap<&'static str, ValueRef>) {\n-    let declare =\n-        decl_cdecl_fn(llmod, \"llvm.dbg.declare\",\n-                      T_fn([T_metadata(), T_metadata()], T_void()));\n-    let value =\n-        decl_cdecl_fn(llmod, \"llvm.dbg.value\",\n-                      T_fn([T_metadata(), T_i64(), T_metadata()], T_void()));\n-    intrinsics.insert(\"llvm.dbg.declare\", declare);\n-    intrinsics.insert(\"llvm.dbg.value\", value);\n+pub fn declare_dbg_intrinsics(llmod: ModuleRef, intrinsics: &mut HashMap<&'static str, ValueRef>) {\n+    ifn!(\"llvm.dbg.declare\", [Type::metadata(), Type::metadata()], Type::void());\n+    ifn!(\"llvm.dbg.value\",   [Type::metadata(), Type::i64(), Type::metadata()], Type::void());\n }\n \n pub fn trap(bcx: block) {\n-    let v: ~[ValueRef] = ~[];\n-    match bcx.ccx().intrinsics.find(& &\"llvm.trap\") {\n-      Some(&x) => { Call(bcx, x, v); },\n+    match bcx.ccx().intrinsics.find_equiv(\"llvm.trap\") {\n+      Some(&x) => { Call(bcx, x, []); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n }\n@@ -2877,7 +2724,7 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n     let gc_metadata_name = ~\"_gc_module_metadata_\" + llmod_id;\n     let gc_metadata = do str::as_c_str(gc_metadata_name) |buf| {\n         unsafe {\n-            llvm::LLVMAddGlobal(ccx.llmod, T_i32(), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, Type::i32(), buf)\n         }\n     };\n     unsafe {\n@@ -2888,8 +2735,8 @@ pub fn decl_gc_metadata(ccx: &mut CrateContext, llmod_id: &str) {\n }\n \n pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n-    let elttype = T_struct([ccx.int_type, ccx.int_type], false);\n-    let maptype = T_array(elttype, ccx.module_data.len() + 1);\n+    let elttype = Type::struct_([ccx.int_type, ccx.int_type], false);\n+    let maptype = Type::array(elttype, ccx.module_data.len() + 1);\n     let map = str::as_c_str(\"_rust_mod_map\", |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n@@ -2926,7 +2773,7 @@ pub fn create_module_map(ccx: &mut CrateContext) -> ValueRef {\n pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n                       llmod: ModuleRef) -> ValueRef {\n     let targ_cfg = sess.targ_cfg;\n-    let int_type = T_int(targ_cfg);\n+    let int_type = Type::int(targ_cfg.arch);\n     let mut n_subcrates = 1;\n     let cstore = sess.cstore;\n     while cstore::have_crate_data(cstore, n_subcrates) { n_subcrates += 1; }\n@@ -2936,8 +2783,8 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n         ~\"toplevel\"\n     };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n-    let arrtype = T_array(int_type, n_subcrates as uint);\n-    let maptype = T_struct([T_i32(), T_ptr(T_i8()), int_type, arrtype], false);\n+    let arrtype = Type::array(int_type, n_subcrates as u64);\n+    let maptype = Type::struct_([Type::i32(), Type::i8p(), int_type, arrtype], false);\n     let map = str::as_c_str(sym_name, |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype, buf)\n@@ -2984,7 +2831,7 @@ pub fn fill_crate_map(ccx: @mut CrateContext, map: ValueRef) {\n         llvm::LLVMSetInitializer(map, C_struct(\n             [C_i32(1),\n              lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n-                                                   T_ptr(T_i8())),\n+                                                   Type::i8p()),\n              p2i(ccx, mod_map),\n              C_array(ccx.int_type, subcrates)]));\n     }\n@@ -3032,11 +2879,11 @@ pub fn write_metadata(cx: &mut CrateContext, crate: &ast::crate) {\n         });\n         lib::llvm::SetLinkage(llglobal, lib::llvm::InternalLinkage);\n \n-        let t_ptr_i8 = T_ptr(T_i8());\n+        let t_ptr_i8 = Type::i8p();\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-        let llvm_used = str::as_c_str(\"llvm.used\", |buf| {\n-            llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n-        });\n+        let llvm_used = do \"llvm.used\".as_c_str |buf| {\n+            llvm::LLVMAddGlobal(cx.llmod, Type::array(t_ptr_i8, 1u), buf)\n+        };\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n         llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }"}, {"sha": "be14da66a16242ad09a0ad7df1d5da60d25e11d3", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 103, "deletions": 106, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -13,7 +13,7 @@ use core::prelude::*;\n use lib::llvm::llvm;\n use lib::llvm::{CallConv, AtomicBinOp, AtomicOrdering, AsmDialect};\n use lib::llvm::{Opcode, IntPredicate, RealPredicate, False};\n-use lib::llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, ModuleRef};\n+use lib::llvm::{ValueRef, Type, BasicBlockRef, BuilderRef, ModuleRef};\n use lib;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_min;\n@@ -186,7 +186,7 @@ pub fn Invoke(cx: block,\n               Catch: BasicBlockRef)\n            -> ValueRef {\n     if cx.unreachable {\n-        return C_null(T_i8());\n+        return C_null(Type::i8());\n     }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n@@ -486,35 +486,35 @@ pub fn Not(cx: block, V: ValueRef) -> ValueRef {\n }\n \n /* Memory */\n-pub fn Malloc(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn Malloc(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"malloc\");\n-        return llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+        return llvm::LLVMBuildMalloc(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n-pub fn ArrayMalloc(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p().to_ref()); }\n         count_insn(cx, \"arraymalloc\");\n-        return llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+        return llvm::LLVMBuildArrayMalloc(B(cx), Ty.to_ref(), Val, noname());\n     }\n }\n \n-pub fn Alloca(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn Alloca(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ptr().to_ref()); }\n         count_insn(cx, \"alloca\");\n-        return llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+        return llvm::LLVMBuildAlloca(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n-pub fn ArrayAlloca(cx: block, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+pub fn ArrayAlloca(cx: block, Ty: Type, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(Ty)); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ptr().to_ref()); }\n         count_insn(cx, \"arrayalloca\");\n-        return llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+        return llvm::LLVMBuildArrayAlloca(B(cx), Ty.to_ref(), Val, noname());\n     }\n }\n \n@@ -597,7 +597,7 @@ pub fn AtomicStore(cx: block, Val: ValueRef, Ptr: ValueRef, order: AtomicOrderin\n \n pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"gep\");\n         return llvm::LLVMBuildGEP(B(cx), Pointer, vec::raw::to_ptr(Indices),\n                                    Indices.len() as c_uint, noname());\n@@ -617,7 +617,7 @@ pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n    ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"inboundsgep\");\n         return llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n                                            vec::raw::to_ptr(Indices),\n@@ -628,7 +628,7 @@ pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) ->\n \n pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_nil())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().ptr_to().to_ref()); }\n         count_insn(cx, \"structgep\");\n         return llvm::LLVMBuildStructGEP(B(cx),\n                                         Pointer,\n@@ -639,171 +639,171 @@ pub fn StructGEP(cx: block, Pointer: ValueRef, Idx: uint) -> ValueRef {\n \n pub fn GlobalString(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p()); }\n         count_insn(cx, \"globalstring\");\n         return llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n     }\n }\n \n pub fn GlobalStringPtr(cx: block, _Str: *c_char) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_ptr(T_i8())); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i8p()); }\n         count_insn(cx, \"globalstringptr\");\n         return llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n     }\n }\n \n /* Casts */\n-pub fn Trunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn Trunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"trunc\");\n-        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildTrunc(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn ZExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn ZExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"zext\");\n-        return llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildZExt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn SExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"sext\");\n-        return llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildSExt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPToUI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPToUI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fptoui\");\n-        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPToUI(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPToSI(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPToSI(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fptosi\");\n-        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPToSI(B(cx), Val, DestTy.to_ref(),noname());\n     }\n }\n \n-pub fn UIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn UIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"uitofp\");\n-        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildUIToFP(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn SIToFP(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SIToFP(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"sitofp\");\n-        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildSIToFP(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPTrunc(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fptrunc\");\n-        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPExt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPExt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fpext\");\n-        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPExt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn PtrToInt(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"ptrtoint\");\n-        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn IntToPtr(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"inttoptr\");\n-        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn BitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn BitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"bitcast\");\n-        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn ZExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"zextorbitcast\");\n-        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn SExtOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"sextorbitcast\");\n-        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn TruncOrBitCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"truncorbitcast\");\n-        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: TypeRef, _: *u8)\n+pub fn Cast(cx: block, Op: Opcode, Val: ValueRef, DestTy: Type, _: *u8)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n         count_insn(cx, \"cast\");\n-        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n+        return llvm::LLVMBuildCast(B(cx), Op, Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn PointerCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn PointerCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"pointercast\");\n-        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildPointerCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn IntCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn IntCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"intcast\");\n-        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildIntCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n-pub fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+pub fn FPCast(cx: block, Val: ValueRef, DestTy: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(DestTy); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(DestTy.to_ref()); }\n         count_insn(cx, \"fpcast\");\n-        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+        return llvm::LLVMBuildFPCast(B(cx), Val, DestTy.to_ref(), noname());\n     }\n }\n \n@@ -812,7 +812,7 @@ pub fn FPCast(cx: block, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"icmp\");\n         return llvm::LLVMBuildICmp(B(cx), Op as c_uint, LHS, RHS, noname());\n     }\n@@ -821,27 +821,27 @@ pub fn ICmp(cx: block, Op: IntPredicate, LHS: ValueRef, RHS: ValueRef)\n pub fn FCmp(cx: block, Op: RealPredicate, LHS: ValueRef, RHS: ValueRef)\n      -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"fcmp\");\n         return llvm::LLVMBuildFCmp(B(cx), Op as c_uint, LHS, RHS, noname());\n     }\n }\n \n /* Miscellaneous instructions */\n-pub fn EmptyPhi(cx: block, Ty: TypeRef) -> ValueRef {\n+pub fn EmptyPhi(cx: block, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         count_insn(cx, \"emptyphi\");\n-        return llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+        return llvm::LLVMBuildPhi(B(cx), Ty.to_ref(), noname());\n     }\n }\n \n-pub fn Phi(cx: block, Ty: TypeRef, vals: &[ValueRef], bbs: &[BasicBlockRef])\n+pub fn Phi(cx: block, Ty: Type, vals: &[ValueRef], bbs: &[BasicBlockRef])\n     -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         assert_eq!(vals.len(), bbs.len());\n-        let phi = EmptyPhi(cx, Ty);\n+        let phi = EmptyPhi(cx, Ty.to_ref());\n         count_insn(cx, \"addincoming\");\n         llvm::LLVMAddIncoming(phi, vec::raw::to_ptr(vals),\n                               vec::raw::to_ptr(bbs),\n@@ -886,20 +886,17 @@ pub fn add_comment(bcx: block, text: &str) {\n             let sanitized = text.replace(\"$\", \"\");\n             let comment_text = ~\"# \" +\n                 sanitized.replace(\"\\n\", \"\\n\\t# \");\n+            count_insn(bcx, \"inlineasm\");\n             let asm = str::as_c_str(comment_text, |c| {\n-                str::as_c_str(\"\", |e| {\n-                    count_insn(bcx, \"inlineasm\");\n-                    llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e,\n-                                             False, False)\n-                })\n+                llvm::LLVMConstInlineAsm(Type::func([], Type::void()), c, noname(), False, False)\n             });\n             Call(bcx, asm, []);\n         }\n     }\n }\n \n pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n-                     inputs: &[ValueRef], output: TypeRef,\n+                     inputs: &[ValueRef], output: Type,\n                      volatile: bool, alignstack: bool,\n                      dia: AsmDialect) -> ValueRef {\n     unsafe {\n@@ -916,9 +913,8 @@ pub fn InlineAsmCall(cx: block, asm: *c_char, cons: *c_char,\n         };\n \n         debug!(\"Asm Output Type: %?\", cx.ccx().tn.type_to_str(output));\n-        let llfty = T_fn(argtys, output);\n-        let v = llvm::LLVMInlineAsm(llfty, asm, cons, volatile,\n-                                    alignstack, dia as c_uint);\n+        let fty = Type::func(argtys, output);\n+        let v = llvm::LLVMInlineAsm(llfty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);\n \n         Call(cx, v, inputs)\n     }\n@@ -971,18 +967,18 @@ pub fn Select(cx: block, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n     }\n }\n \n-pub fn VAArg(cx: block, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+pub fn VAArg(cx: block, list: ValueRef, Ty: Type) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(Ty); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Ty.to_ref()); }\n         count_insn(cx, \"vaarg\");\n-        return llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+        return llvm::LLVMBuildVAArg(B(cx), list, Ty.to_ref(), noname());\n     }\n }\n \n pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"extractelement\");\n         return llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n     }\n@@ -991,7 +987,7 @@ pub fn ExtractElement(cx: block, VecVal: ValueRef, Index: ValueRef) ->\n pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n                      Index: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"insertelement\");\n         llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname())\n     }\n@@ -1000,23 +996,24 @@ pub fn InsertElement(cx: block, VecVal: ValueRef, EltVal: ValueRef,\n pub fn ShuffleVector(cx: block, V1: ValueRef, V2: ValueRef,\n                      Mask: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"shufflevector\");\n         llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname())\n     }\n }\n \n pub fn VectorSplat(cx: block, NumElts: uint, EltVal: ValueRef) -> ValueRef {\n     unsafe {\n-        let Undef = llvm::LLVMGetUndef(T_vector(val_ty(EltVal), NumElts));\n+        let elt_ty = val_ty(EltVal);\n+        let Undef = llvm::LLVMGetUndef(Type::vector(elt_ty, NumElts).to_ref());\n         let VecVal = InsertElement(cx, Undef, EltVal, C_i32(0));\n-        ShuffleVector(cx, VecVal, Undef, C_null(T_vector(T_i32(), NumElts)))\n+        ShuffleVector(cx, VecVal, Undef, C_null(Type::vector(Type::i32().to_ref(), NumElts)))\n     }\n }\n \n pub fn ExtractValue(cx: block, AggVal: ValueRef, Index: uint) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_nil()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::nil().to_ref()); }\n         count_insn(cx, \"extractvalue\");\n         return llvm::LLVMBuildExtractValue(\n             B(cx), AggVal, Index as c_uint, noname());\n@@ -1035,15 +1032,15 @@ pub fn InsertValue(cx: block, AggVal: ValueRef, EltVal: ValueRef,\n \n pub fn IsNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"isnull\");\n         return llvm::LLVMBuildIsNull(B(cx), Val, noname());\n     }\n }\n \n pub fn IsNotNull(cx: block, Val: ValueRef) -> ValueRef {\n     unsafe {\n-        if cx.unreachable { return llvm::LLVMGetUndef(T_i1()); }\n+        if cx.unreachable { return llvm::LLVMGetUndef(Type::i1().to_ref()); }\n         count_insn(cx, \"isnotnull\");\n         return llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n     }\n@@ -1076,13 +1073,13 @@ pub fn Trap(cx: block) {\n     }\n }\n \n-pub fn LandingPad(cx: block, Ty: TypeRef, PersFn: ValueRef,\n+pub fn LandingPad(cx: block, Ty: Type, PersFn: ValueRef,\n                   NumClauses: uint) -> ValueRef {\n     unsafe {\n         check_not_terminated(cx);\n         assert!(!cx.unreachable);\n         count_insn(cx, \"landingpad\");\n-        return llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn,\n+        return llvm::LLVMBuildLandingPad(B(cx), Ty.to_ref(), PersFn,\n                                       NumClauses as c_uint, noname());\n     }\n }"}, {"sha": "036f34b1974eca75f3afd95e3b0394539afa51c7", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -26,7 +26,7 @@ pub trait ABIInfo {\n \n pub struct LLVMType {\n     cast: bool,\n-    ty: TypeRef\n+    ty: Type\n }\n \n pub struct FnType {\n@@ -37,10 +37,10 @@ pub struct FnType {\n }\n \n impl FnType {\n-    pub fn decl_fn(&self, decl: &fn(fnty: TypeRef) -> ValueRef) -> ValueRef {\n+    pub fn decl_fn(&self, decl: &fn(fnty: Type) -> ValueRef) -> ValueRef {\n         let atys = vec::map(self.arg_tys, |t| t.ty);\n         let rty = self.ret_ty.ty;\n-        let fnty = T_fn(atys, rty);\n+        let fnty = Type::func(atys, rty);\n         let llfn = decl(fnty);\n \n         for self.attrs.iter().enumerate().advance |(i, a)| {\n@@ -59,7 +59,7 @@ impl FnType {\n \n     pub fn build_shim_args(&self,\n                            bcx: block,\n-                           arg_tys: &[TypeRef],\n+                           arg_tys: &[Type],\n                            llargbundle: ValueRef)\n                            -> ~[ValueRef] {\n         let mut atys: &[LLVMType] = self.arg_tys;\n@@ -96,7 +96,7 @@ impl FnType {\n \n     pub fn build_shim_ret(&self,\n                           bcx: block,\n-                          arg_tys: &[TypeRef],\n+                          arg_tys: &[Type],\n                           ret_def: bool,\n                           llargbundle: ValueRef,\n                           llretval: ValueRef) {\n@@ -132,7 +132,7 @@ impl FnType {\n \n     pub fn build_wrap_args(&self,\n                            bcx: block,\n-                           ret_ty: TypeRef,\n+                           ret_ty: Type,\n                            llwrapfn: ValueRef,\n                            llargbundle: ValueRef) {\n         let mut atys: &[LLVMType] = self.arg_tys;\n@@ -145,7 +145,7 @@ impl FnType {\n             get_param(llwrapfn, 0u)\n         } else if self.ret_ty.cast {\n             let retptr = alloca(bcx, self.ret_ty.ty);\n-            BitCast(bcx, retptr, T_ptr(ret_ty))\n+            BitCast(bcx, retptr, ret_ty.ptr_to())\n         } else {\n             alloca(bcx, ret_ty)\n         };\n@@ -182,14 +182,14 @@ impl FnType {\n         if bcx.fcx.llretptr.is_some() {\n             let llretval = load_inbounds(bcx, llargbundle, [ 0, arg_tys.len() ]);\n             let llretval = if self.ret_ty.cast {\n-                let retptr = BitCast(bcx, llretval, T_ptr(self.ret_ty.ty));\n+                let retptr = BitCast(bcx, llretval, self.ret_ty.ty.ptr_to());\n                 Load(bcx, retptr)\n             } else {\n                 Load(bcx, llretval)\n             };\n             let llretptr = BitCast(bcx,\n                                    bcx.fcx.llretptr.get(),\n-                                   T_ptr(self.ret_ty.ty));\n+                                   self.ret_ty.ty.ptr_to());\n             Store(bcx, llretval, llretptr);\n         }\n     }"}, {"sha": "f29ccad76b17829c1f964d81a342a5c429f96c92", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -10,12 +10,9 @@\n \n use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::struct_tys;\n-use lib::llvm::TypeRef;\n use lib::llvm::{Attribute, StructRetAttribute};\n use lib::llvm::True;\n use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n-use middle::trans::common::{T_i8, T_i16, T_i32, T_i64};\n-use middle::trans::common::{T_array, T_ptr, T_void};\n \n use core::option::{Option, None, Some};\n use core::uint;\n@@ -24,102 +21,102 @@ fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n \n-fn align(off: uint, ty: TypeRef) -> uint {\n+fn align(off: uint, ty: Type) -> uint {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn ty_align(ty: TypeRef) -> uint {\n+fn ty_align(ty: Type) -> uint {\n     unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n+        match ty.kind() {\n             Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n             Pointer => 4,\n             Float => 4,\n             Double => 8,\n             Struct => {\n-                if llvm::LLVMIsPackedStruct(ty) == True {\n+                if ty.is_packed() {\n                     1\n                 } else {\n-                    let str_tys = struct_tys(ty);\n+                    let str_tys = ty.field_types();\n                     str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n                 }\n             }\n             Array => {\n-                let elt = llvm::LLVMGetElementType(ty);\n+                let elt = ty.element_type();\n                 ty_align(elt)\n             }\n             _ => fail!(\"ty_align: unhandled type\")\n-        };\n+        }\n     }\n }\n \n-fn ty_size(ty: TypeRef) -> uint {\n+fn ty_size(ty: Type) -> uint {\n     unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n+        match ty.kind() {\n             Integer => {\n-                ((llvm::LLVMGetIntTypeWidth(ty) as uint) + 7) / 8\n+                ((llvm::LLVMGetIntTypeWidth(ty.to_ref()) as uint) + 7) / 8\n             }\n             Pointer => 4,\n             Float => 4,\n             Double => 8,\n             Struct => {\n-                if llvm::LLVMIsPackedStruct(ty) == True {\n-                    let str_tys = struct_tys(ty);\n+                if ty.is_packed() {\n+                    let str_tys = ty.field_types();\n                     str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                 } else {\n-                    let str_tys = struct_tys(ty);\n+                    let str_tys = ty.field_types();\n                     let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                     align(size, ty)\n                 }\n             }\n             Array => {\n-                let len = llvm::LLVMGetArrayLength(ty) as uint;\n-                let elt = llvm::LLVMGetElementType(ty);\n+                let len = ty.array_length();\n+                let elt = ty.element_type();\n                 let eltsz = ty_size(elt);\n                 len * eltsz\n             }\n             _ => fail!(\"ty_size: unhandled type\")\n-        };\n+        }\n     }\n }\n \n-fn classify_ret_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+fn classify_ret_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     if is_reg_ty(ty) {\n         return (LLVMType { cast: false, ty: ty }, None);\n     }\n     let size = ty_size(ty);\n     if size <= 4 {\n         let llty = if size <= 1 {\n-            T_i8()\n+            Type::i8()\n         } else if size <= 2 {\n-            T_i16()\n+            Type::i16()\n         } else {\n-            T_i32()\n+            Type::i32()\n         };\n         return (LLVMType { cast: true, ty: llty }, None);\n     }\n-    (LLVMType { cast: false, ty: T_ptr(ty) }, Some(StructRetAttribute))\n+    (LLVMType { cast: false, ty: ty.ptr_to() }, Some(StructRetAttribute))\n }\n \n-fn classify_arg_ty(ty: TypeRef) -> (LLVMType, Option<Attribute>) {\n+fn classify_arg_ty(ty: Type) -> (LLVMType, Option<Attribute>) {\n     if is_reg_ty(ty) {\n         return (LLVMType { cast: false, ty: ty }, None);\n     }\n     let align = ty_align(ty);\n     let size = ty_size(ty);\n     let llty = if align <= 4 {\n-        T_array(T_i32(), (size + 3) / 4)\n+        Type::array(Type::i32(), (size + 3) / 4)\n     } else {\n-        T_array(T_i64(), (size + 7) / 8)\n+        Type::array(Type::i64(), (size + 7) / 8)\n     };\n     (LLVMType { cast: true, ty: llty }, None)\n }\n \n-fn is_reg_ty(ty: TypeRef) -> bool {\n+fn is_reg_ty(ty: Type) -> bool {\n     unsafe {\n-        return match llvm::LLVMGetTypeKind(ty) {\n+        match ty.kind() {\n             Integer\n             | Pointer\n             | Float\n@@ -133,8 +130,8 @@ enum ARM_ABIInfo { ARM_ABIInfo }\n \n impl ABIInfo for ARM_ABIInfo {\n     fn compute_info(&self,\n-                    atys: &[TypeRef],\n-                    rty: TypeRef,\n+                    atys: &[Type],\n+                    rty: Type,\n                     ret_def: bool) -> FnType {\n         let mut arg_tys = ~[];\n         let mut attrs = ~[];\n@@ -147,14 +144,14 @@ impl ABIInfo for ARM_ABIInfo {\n         let mut (ret_ty, ret_attr) = if ret_def {\n             classify_ret_ty(rty)\n         } else {\n-            (LLVMType { cast: false, ty: T_void() }, None)\n+            (LLVMType { cast: false, ty: Type::void() }, None)\n         };\n \n         let sret = ret_attr.is_some();\n         if sret {\n             arg_tys.unshift(ret_ty);\n             attrs.unshift(ret_attr);\n-            ret_ty = LLVMType { cast: false, ty: T_void() };\n+            ret_ty = LLVMType { cast: false, ty: Type::void() };\n         }\n \n         return FnType {"}, {"sha": "de988493b471f73082346c37f3273232ed0f14f6", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -14,9 +14,9 @@ use core::libc::c_uint;\n use core::ptr;\n use core::uint;\n use core::vec;\n-use lib::llvm::{llvm, TypeRef, Integer, Pointer, Float, Double};\n-use lib::llvm::{Struct, Array, Attribute};\n-use lib::llvm::{StructRetAttribute};\n+use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n+use lib::llvm::struct_tys;\n+use lib::llvm::{Attribute, StructRetAttribute};\n use lib::llvm::True;\n use middle::trans::context::task_llcx;\n use middle::trans::common::*;\n@@ -26,23 +26,11 @@ fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n \n-fn align(off: uint, ty: TypeRef) -> uint {\n+fn align(off: uint, ty: Type) -> uint {\n     let a = ty_align(ty);\n     return align_up_to(off, a);\n }\n \n-fn struct_tys(ty: TypeRef) -> ~[TypeRef] {\n-    unsafe {\n-        let n = llvm::LLVMCountStructElementTypes(ty);\n-    if (n == 0) {\n-        return ~[];\n-    }\n-        let mut elts = vec::from_elem(n as uint, ptr::null());\n-        llvm::LLVMGetStructElementTypes(ty, &mut elts[0]);\n-        return elts;\n-    }\n-}\n-\n fn ty_align(ty: TypeRef) -> uint {\n     unsafe {\n         return match llvm::LLVMGetTypeKind(ty) {"}, {"sha": "a72f9489abcc950d5ec8c4980087e8bb9b74317f", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -690,8 +690,8 @@ impl block_ {\n         self.ccx().tn.val_to_str(val)\n     }\n \n-    pub fn llty_str(&self, llty: TypeRef) -> ~str {\n-        self.ccx().tn.type_to_str(llty)\n+    pub fn llty_str(&self, ty: Type) -> ~str {\n+        self.ccx().tn.type_to_str(ty)\n     }\n \n     pub fn ty_to_str(&self, t: ty::t) -> ~str {\n@@ -708,6 +708,7 @@ impl block_ {\n     }\n }\n \n+/*\n // LLVM type constructors.\n pub fn T_void() -> TypeRef {\n     unsafe { return llvm::LLVMVoidTypeInContext(base::task_llcx()); }\n@@ -931,19 +932,6 @@ pub fn T_opaque_vec(targ_cfg: @session::config) -> TypeRef {\n     return T_vec2(targ_cfg, T_i8());\n }\n \n-// Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n-// representation of @T as a tuple (i.e., the ty::t version of what T_box()\n-// returns).\n-pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n-    let ptr = ty::mk_ptr(\n-        tcx,\n-        ty::mt {ty: ty::mk_nil(), mutbl: ast::m_imm}\n-    );\n-    return ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_type(tcx),\n-                         ptr, ptr,\n-                         t]);\n-}\n-\n pub fn T_box_header_fields(cx: &CrateContext) -> ~[TypeRef] {\n     let ptr = T_ptr(T_i8());\n     return ~[cx.int_type, T_ptr(cx.tydesc_type), ptr, ptr];\n@@ -1025,6 +1013,20 @@ pub fn T_opaque_trait(cx: &CrateContext, store: ty::TraitStore) -> TypeRef {\n pub fn T_opaque_port_ptr() -> TypeRef { return T_ptr(T_i8()); }\n \n pub fn T_opaque_chan_ptr() -> TypeRef { return T_ptr(T_i8()); }\n+*/\n+\n+// Let T be the content of a box @T.  tuplify_box_ty(t) returns the\n+// representation of @T as a tuple (i.e., the ty::t version of what T_box()\n+// returns).\n+pub fn tuplify_box_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n+    let ptr = ty::mk_ptr(\n+        tcx,\n+        ty::mt {ty: ty::mk_nil(), mutbl: ast::m_imm}\n+    );\n+    return ty::mk_tup(tcx, ~[ty::mk_uint(), ty::mk_type(tcx),\n+                         ptr, ptr,\n+                         t]);\n+}\n \n \n // LLVM constant constructors."}, {"sha": "ada0284e0e317717486a81267db37681931be283", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -37,8 +37,7 @@ use extra::time;\n use syntax::ast;\n \n use middle::trans::common::{ExternMap,tydesc_info,BuilderRef_res,Stats,namegen,addrspace_gen};\n-use middle::trans::common::{mono_id,T_int,T_float,T_tydesc,T_opaque_vec};\n-use middle::trans::common::{new_namegen,new_addrspace_gen};\n+use middle::trans::common::{mono_id,new_namegen,new_addrspace_gen};\n \n use middle::trans::base::{decl_crate_map};\n "}, {"sha": "851ff4511a039d4c037e86c1ff0cdad30b994f9e", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 100, "deletions": 21, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd83b92b598219d74317406a25234d572de584e0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=fd83b92b598219d74317406a25234d572de584e0", "patch": "@@ -10,15 +10,19 @@\n \n use core::prelude::*;\n \n-use lib::llvm::{llvm, TypeRef, Bool, False, True};\n+use lib::llvm::{llvm, TypeRef, Bool, False, True, TypeKind};\n+\n+use middle::ty;\n \n use middle::trans::context::CrateContext;\n use middle::trans::base;\n \n-use syntax::{ast,abi};\n-use syntax::abi::{X86, X86_64, Arm, Mips};\n+use syntax::ast;\n+use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use back::abi;\n \n use core::vec;\n+use core::cast;\n \n use core::libc::{c_uint};\n \n@@ -27,9 +31,7 @@ pub struct Type {\n }\n \n macro_rules! ty (\n-    ($e:expr) => ( Type::from_ref(unsafe {\n-\n-    }))\n+    ($e:expr) => ( Type::from_ref(unsafe { $e }))\n )\n \n /**\n@@ -94,14 +96,18 @@ impl Type {\n         Type::i32()\n     }\n \n-    pub fn int(arch: abi::Architecture) -> Type {\n+    pub fn i8p() -> Type {\n+        Type::i8().ptr_to()\n+    }\n+\n+    pub fn int(arch: Architecture) -> Type {\n         match arch {\n             X86 | Arm | Mips => Type::i32(),\n             X86_64 => Type::i64()\n         }\n     }\n \n-    pub fn float(_: abi::Architecture) -> Type {\n+    pub fn float(_: Architecture) -> Type {\n         // All architectures currently just use doubles as the default\n         // float size\n         Type::f64()\n@@ -136,7 +142,7 @@ impl Type {\n         }\n     }\n \n-    pub fn size_t(arch: abi::Architecture) -> Type {\n+    pub fn size_t(arch: Architecture) -> Type {\n         Type::int(arch)\n     }\n \n@@ -147,8 +153,6 @@ impl Type {\n     }\n \n     pub fn func_pair(cx: &CrateContext, fn_ty: &Type) -> Type {\n-        assert!(fn_ty.is_func(), \"`fn_ty` must be a function type\");\n-\n         Type::struct_([fn_ty.ptr_to(), Type::opaque_cbox_ptr(cx)], false)\n     }\n \n@@ -186,7 +190,7 @@ impl Type {\n         return ty;\n     }\n \n-    pub fn tydesc(arch: abi::Architecture) -> Type {\n+    pub fn tydesc(arch: Architecture) -> Type {\n         let mut tydesc = Type::named_struct(\"tydesc\");\n         let tydescpp = tydesc.ptr_to().ptr_to();\n         let pvoid = Type::i8().ptr_to();\n@@ -197,7 +201,7 @@ impl Type {\n         let int_ty = Type::int(arch);\n \n         let elems = [\n-            int_type, int_type,\n+            int_ty, int_ty,\n             glue_fn_ty, glue_fn_ty, glue_fn_ty, glue_fn_ty,\n             pvoid, pvoid\n         ];\n@@ -207,21 +211,21 @@ impl Type {\n         return tydesc;\n     }\n \n-    pub fn array(ty: &Type, len: uint) -> Type {\n+    pub fn array(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMArrayType(ty.to_ref(), len as c_uint))\n     }\n \n-    pub fn vector(ty: &Type, len: uint) -> Type {\n+    pub fn vector(ty: &Type, len: u64) -> Type {\n         ty!(llvm::LLVMVectorType(ty.to_ref(), len as c_uint))\n     }\n \n-    pub fn vec(arch: abi::Architecture, ty: &Type) -> Type {\n+    pub fn vec(arch: Architecture, ty: &Type) -> Type {\n         Type::struct_(\n             [ Type::int(arch), Type::int(arch), Type::array(ty, 0) ],\n         false)\n     }\n \n-    pub fn opaque_vec(arch: abi::Architecture) -> Type {\n+    pub fn opaque_vec(arch: Architecture) -> Type {\n         Type::vec(arch, Type::i8())\n     }\n \n@@ -238,7 +242,7 @@ impl Type {\n     }\n \n     pub fn box(ctx: &CrateContext, ty: &Type) -> Type {\n-        Type::struct_(Type::box_header_fields(ctx) + [t], false)\n+        Type::struct_(Type::box_header_fields(ctx) + [ty], false)\n     }\n \n     pub fn opaque_box(ctx: &CrateContext) -> Type {\n@@ -257,13 +261,88 @@ impl Type {\n         cx.int_type\n     }\n \n-    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n-        assert!(self.is_struct(), \"Type must be a struct\");\n+    pub fn captured_tydescs(ctx: &CrateContext, num: uint) -> Type {\n+        Type::struct_(vec::from_elem(num, ctx.tydesc_type.ptr_to()), false)\n+    }\n+\n+    pub fn opaque_trait(ctx: &CrateContext, store: ty::TraitStore) -> Type {\n+        let tydesc_ptr = ctx.tydesc_type.ptr_to();\n+        match store {\n+            ty::BoxTraitStore => {\n+                Type::struct_(\n+                    [ tydesc_ptr, Type::opaque_box(ctx).ptr_to() ],\n+                false)\n+            }\n+            ty::UniqTraitStore => {\n+                Type::struct_(\n+                    [ tydesc_ptr, Type::unique(ctx, Type::i8()).ptr_to()],\n+                false)\n+            }\n+            ty::RegionTraitStore(*) => {\n+                Type::struct_(\n+                    [ tydesc_ptr, Type::i8().ptr_to() ],\n+                false)\n+            }\n+        }\n+    }\n \n+    pub fn kind(&self) -> TypeKind {\n+        unsafe {\n+            llvm::LLVMGetTypeKind(self.to_ref())\n+        }\n+    }\n+\n+    pub fn set_struct_body(&mut self, els: &[Type], packed: bool) {\n         unsafe {\n             let vec : &[TypeRef] = cast::transmute(els);\n-            llvm::LLVMStructSetBody(self.to_ref(), to_ptr(vec),\n+            llvm::LLVMStructSetBody(self.to_ref(), vec::raw::to_ptr(vec),\n                                     els.len() as c_uint, packed as Bool)\n         }\n     }\n+\n+    pub fn ptr_to(&self) -> Type {\n+        ty!(llvm::LLVMPointerType(self.to_ref()))\n+    }\n+\n+    pub fn get_field(&self, idx: uint) -> Type {\n+        unsafe {\n+            let num_fields = llvm::LLVMCountStructElementTypes(self.to_ref()) as uint;\n+            let mut elems = vec::from_elem(num_fields, 0 as TypeRef);\n+\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), vec::raw::to_mut_ptr(elems));\n+\n+            Type::from_ref(elems[idx])\n+        }\n+    }\n+\n+    pub fn is_packed(&self) -> bool {\n+        unsafe {\n+            llvm::LLVMIsPackedStruct(self.to_ref()) == True\n+        }\n+    }\n+\n+    pub fn element_type(&self) -> Type {\n+        unsafe {\n+            Type::from_ref(llvm::LLVMGetElementType(self.to_ref()))\n+        }\n+    }\n+\n+    pub fn array_length(&self) -> uint {\n+        unsafe {\n+            llvm::LLVMGetArrayLength(self.to_ref()) as uint\n+        }\n+    }\n+\n+    pub fn field_types(&self) -> ~[Type] {\n+        unsafe {\n+            let n_elts = llvm::LLVMCountStructElementTypes(struct_ty) as uint;\n+            if n_elts == 0 {\n+                return ~[];\n+            }\n+            let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n+            llvm::LLVMGetStructElementTypes(struct_ty, &mut elts[0]);\n+            cast::transmute(elts)\n+        }\n+    }\n+\n }"}]}