{"sha": "07183ea6e719e18f5d6b09afbe519c9f940c4705", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MTgzZWE2ZTcxOWUxOGY1ZDZiMDlhZmJlNTE5YzlmOTQwYzQ3MDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T02:52:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-12T02:52:37Z"}, "message": "auto merge of #7677 : alexcrichton/rust/tls-gc, r=pcwalton\n\ncc #6004 and #3273\r\n\r\nThis is a rewrite of TLS to get towards not requiring `@` when using task local storage. Most of the rewrite is straightforward, although there are two caveats:\r\n\r\n1. Changing `local_set` to not require `@` is blocked on #7673\r\n2. The code in `local_pop` is some of the most unsafe code I've written. A second set of eyes should definitely scrutinize it...\r\n\r\nThe public-facing interface currently hasn't changed, although it will have to change because `local_data::get` cannot return `Option<T>`, nor can it return `Option<&T>` (the lifetime isn't known). This will have to be changed to be given a closure which yield `&T` (or as an Option). I didn't do this part of the api rewrite in this pull request as I figured that it could wait until when `@` is fully removed.\r\n\r\nThis also doesn't deal with the issue of using something other than functions as keys, but I'm looking into using static slices (as mentioned in the issues).", "tree": {"sha": "e7d78b7be38a4f9e3763c08cfdd9569a45be6d6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7d78b7be38a4f9e3763c08cfdd9569a45be6d6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07183ea6e719e18f5d6b09afbe519c9f940c4705", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07183ea6e719e18f5d6b09afbe519c9f940c4705", "html_url": "https://github.com/rust-lang/rust/commit/07183ea6e719e18f5d6b09afbe519c9f940c4705", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07183ea6e719e18f5d6b09afbe519c9f940c4705/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a9c84fb8362c26f24b1ea8443a509047f27b38f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a9c84fb8362c26f24b1ea8443a509047f27b38f", "html_url": "https://github.com/rust-lang/rust/commit/9a9c84fb8362c26f24b1ea8443a509047f27b38f"}, {"sha": "a15c1b4464099fa65ec5da389381db83c22801ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/a15c1b4464099fa65ec5da389381db83c22801ec", "html_url": "https://github.com/rust-lang/rust/commit/a15c1b4464099fa65ec5da389381db83c22801ec"}], "stats": {"total": 891, "additions": 617, "deletions": 274}, "files": [{"sha": "c1eeb5005b26578184736428aeed322313555efc", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -72,11 +72,11 @@ fn complete_key(_v: @CompletionCb) {}\n \n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n-    local_data::local_data_set(complete_key, @(cb));\n+    local_data::set(complete_key, @(cb));\n \n     extern fn callback(line: *c_char, completions: *()) {\n         unsafe {\n-            let cb = *local_data::local_data_get(complete_key)\n+            let cb = *local_data::get(complete_key, |k| k.map(|&k| *k))\n                 .get();\n \n             do cb(str::raw::from_c_str(line)) |suggestion| {"}, {"sha": "d4d6162a9198f4ef804e0f9585d3d90bc92a722d", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -1204,11 +1204,11 @@ mod big_tests {\n     #[unsafe_destructor]\n     impl<'self> Drop for LVal<'self> {\n         fn drop(&self) {\n-            let x = unsafe { local_data::local_data_get(self.key) };\n+            let x = unsafe { local_data::get(self.key, |k| k.map(|&k| *k)) };\n             match x {\n                 Some(@y) => {\n                     unsafe {\n-                        local_data::local_data_set(self.key, @(y+1));\n+                        local_data::set(self.key, @(y+1));\n                     }\n                 }\n                 _ => fail!(\"Expected key to work\"),"}, {"sha": "697eb2a5c0409ddb1ff8d65796953a20d9eaf20b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -91,7 +91,7 @@ fn task_local_insn_key(_v: @~[&'static str]) {}\n \n pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n     unsafe {\n-        let opt = local_data::local_data_get(task_local_insn_key);\n+        let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));\n         if opt.is_some() {\n             blk(*opt.unwrap());\n         }\n@@ -100,7 +100,7 @@ pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n \n pub fn init_insn_ctxt() {\n     unsafe {\n-        local_data::local_data_set(task_local_insn_key, @~[]);\n+        local_data::set(task_local_insn_key, @~[]);\n     }\n }\n \n@@ -110,7 +110,7 @@ pub struct _InsnCtxt { _x: () }\n impl Drop for _InsnCtxt {\n     fn drop(&self) {\n         unsafe {\n-            do local_data::local_data_modify(task_local_insn_key) |c| {\n+            do local_data::modify(task_local_insn_key) |c| {\n                 do c.map_consume |ctx| {\n                     let mut ctx = copy *ctx;\n                     ctx.pop();\n@@ -124,7 +124,7 @@ impl Drop for _InsnCtxt {\n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: %s\", s);\n     unsafe {\n-        do local_data::local_data_modify(task_local_insn_key) |c| {\n+        do local_data::modify(task_local_insn_key) |c| {\n             do c.map_consume |ctx| {\n                 let mut ctx = copy *ctx;\n                 ctx.push(s);"}, {"sha": "1557916658df78d0c486bddc5d5ff1554fb13ef5", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -240,14 +240,14 @@ impl Drop for CrateContext {\n \n fn task_local_llcx_key(_v: @ContextRef) {}\n pub fn task_llcx() -> ContextRef {\n-    let opt = unsafe { local_data::local_data_get(task_local_llcx_key) };\n+    let opt = unsafe { local_data::get(task_local_llcx_key, |k| k.map(|&k| *k)) };\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n }\n \n unsafe fn set_task_llcx(c: ContextRef) {\n-    local_data::local_data_set(task_local_llcx_key, @c);\n+    local_data::set(task_local_llcx_key, @c);\n }\n \n unsafe fn unset_task_llcx() {\n-    local_data::local_data_pop(task_local_llcx_key);\n+    local_data::pop(task_local_llcx_key);\n }"}, {"sha": "716c7a2481eed13e27646ab41c863e7b7e5699a9", "filename": "src/librusti/program.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -58,7 +58,7 @@ struct LocalVariable {\n }\n \n type LocalCache = @mut HashMap<~str, @~[u8]>;\n-fn tls_key(_k: @LocalCache) {}\n+fn tls_key(_k: LocalCache) {}\n \n impl Program {\n     pub fn new() -> Program {\n@@ -132,7 +132,7 @@ impl Program {\n         \");\n \n         let key: sys::Closure = unsafe {\n-            let tls_key: &'static fn(@LocalCache) = tls_key;\n+            let tls_key: &'static fn(LocalCache) = tls_key;\n             cast::transmute(tls_key)\n         };\n         // First, get a handle to the tls map which stores all the local\n@@ -144,7 +144,7 @@ impl Program {\n                 let key = ::std::sys::Closure{ code: %? as *(),\n                                                env: ::std::ptr::null() };\n                 let key = ::std::cast::transmute(key);\n-                *::std::local_data::local_data_get(key).unwrap()\n+                ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n             };\\n\", key.code as uint));\n \n         // Using this __tls_map handle, deserialize each variable binding that\n@@ -227,7 +227,7 @@ impl Program {\n             map.insert(copy *name, @copy value.data);\n         }\n         unsafe {\n-            local_data::local_data_set(tls_key, @map);\n+            local_data::set(tls_key, map);\n         }\n     }\n \n@@ -236,7 +236,7 @@ impl Program {\n     /// it updates this cache with the new values of each local variable.\n     pub fn consume_cache(&mut self) {\n         let map = unsafe {\n-            local_data::local_data_pop(tls_key).expect(\"tls is empty\")\n+            local_data::pop(tls_key).expect(\"tls is empty\")\n         };\n         do map.consume |name, value| {\n             match self.local_vars.find_mut(&name) {"}, {"sha": "d6d09527f83012c118130ace8708fbe37d2f6f1a", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -12,7 +12,6 @@\n \n #[allow(missing_doc)];\n \n-use local_data::{local_data_pop, local_data_set};\n use local_data;\n use prelude::*;\n \n@@ -26,14 +25,14 @@ pub struct Handler<T, U> {\n \n pub struct Condition<'self, T, U> {\n     name: &'static str,\n-    key: local_data::LocalDataKey<'self, Handler<T, U>>\n+    key: local_data::Key<'self, @Handler<T, U>>\n }\n \n impl<'self, T, U> Condition<'self, T, U> {\n     pub fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n-            let prev = local_data::local_data_get(self.key);\n+            let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n             let h = @Handler { handle: *p, prev: prev };\n             Trap { cond: self, handler: h }\n         }\n@@ -46,7 +45,7 @@ impl<'self, T, U> Condition<'self, T, U> {\n \n     pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n         unsafe {\n-            match local_data_pop(self.key) {\n+            match local_data::pop(self.key) {\n                 None => {\n                     debug!(\"Condition.raise: found no handler\");\n                     default()\n@@ -55,12 +54,12 @@ impl<'self, T, U> Condition<'self, T, U> {\n                     debug!(\"Condition.raise: found handler\");\n                     match handler.prev {\n                         None => {}\n-                        Some(hp) => local_data_set(self.key, hp)\n+                        Some(hp) => local_data::set(self.key, hp)\n                     }\n                     let handle : &fn(T) -> U =\n                         ::cast::transmute(handler.handle);\n                     let u = handle(t);\n-                    local_data_set(self.key, handler);\n+                    local_data::set(self.key, handler);\n                     u\n                 }\n             }\n@@ -78,7 +77,7 @@ impl<'self, T, U> Trap<'self, T, U> {\n         unsafe {\n             let _g = Guard { cond: self.cond };\n             debug!(\"Trap: pushing handler to TLS\");\n-            local_data_set(self.cond.key, self.handler);\n+            local_data::set(self.cond.key, self.handler);\n             inner()\n         }\n     }\n@@ -93,12 +92,12 @@ impl<'self, T, U> Drop for Guard<'self, T, U> {\n     fn drop(&self) {\n         unsafe {\n             debug!(\"Guard: popping handler from TLS\");\n-            let curr = local_data_pop(self.cond.key);\n+            let curr = local_data::pop(self.cond.key);\n             match curr {\n                 None => {}\n                 Some(h) => match h.prev {\n                     None => {}\n-                    Some(hp) => local_data_set(self.cond.key, hp)\n+                    Some(hp) => local_data::set(self.cond.key, hp)\n                 }\n             }\n         }"}, {"sha": "b241de887004c15d8f1125a3532cfde6c2e8f60c", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 111, "deletions": 54, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -12,14 +12,28 @@\n \n Task local data management\n \n-Allows storing boxes with arbitrary types inside, to be accessed\n-anywhere within a task, keyed by a pointer to a global finaliser\n-function. Useful for dynamic variables, singletons, and interfacing\n-with foreign code with bad callback interfaces.\n+Allows storing boxes with arbitrary types inside, to be accessed anywhere within\n+a task, keyed by a pointer to a global finaliser function. Useful for dynamic\n+variables, singletons, and interfacing with foreign code with bad callback\n+interfaces.\n \n-To use, declare a monomorphic global function at the type to store,\n-and use it as the 'key' when accessing. See the 'tls' tests below for\n-examples.\n+To use, declare a monomorphic (no type parameters) global function at the type\n+to store, and use it as the 'key' when accessing.\n+\n+~~~{.rust}\n+use std::local_data;\n+\n+fn key_int(_: @int) {}\n+fn key_vector(_: @~[int]) {}\n+\n+unsafe {\n+    local_data::set(key_int, @3);\n+    assert!(local_data::get(key_int) == Some(@3));\n+\n+    local_data::set(key_vector, @~[3]);\n+    assert!(local_data::get(key_vector).unwrap()[0] == 3);\n+}\n+~~~\n \n Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n magic.\n@@ -28,7 +42,7 @@ magic.\n \n use prelude::*;\n \n-use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handle};\n+use task::local_data_priv::{local_get, local_pop, local_set, Handle};\n \n #[cfg(test)] use task;\n \n@@ -46,105 +60,140 @@ use task::local_data_priv::{local_get, local_pop, local_modify, local_set, Handl\n  *\n  * These two cases aside, the interface is safe.\n  */\n-pub type LocalDataKey<'self,T> = &'self fn:Copy(v: @T);\n+pub type Key<'self,T> = &'self fn:Copy(v: T);\n \n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n-pub unsafe fn local_data_pop<T: 'static>(\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n+#[cfg(stage0)]\n+pub unsafe fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n+    local_pop(Handle::new(), key)\n+}\n+/**\n+ * Remove a task-local data value from the table, returning the\n+ * reference that was originally created to insert it.\n+ */\n+#[cfg(not(stage0))]\n+pub unsafe fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n     local_pop(Handle::new(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n-pub unsafe fn local_data_get<T: 'static>(\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get(Handle::new(), key)\n+#[cfg(stage0)]\n+pub unsafe fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n+    local_get(Handle::new(), key, f)\n+}\n+/**\n+ * Retrieve a task-local data value. It will also be kept alive in the\n+ * table until explicitly removed.\n+ */\n+#[cfg(not(stage0))]\n+pub unsafe fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n+    local_get(Handle::new(), key, f)\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n-pub unsafe fn local_data_set<T: 'static>(\n-    key: LocalDataKey<T>, data: @T) {\n-\n+#[cfg(stage0)]\n+pub unsafe fn set<T: 'static>(key: Key<@T>, data: @T) {\n+    local_set(Handle::new(), key, data)\n+}\n+/**\n+ * Store a value in task-local data. If this key already has a value,\n+ * that value is overwritten (and its destructor is run).\n+ */\n+#[cfg(not(stage0))]\n+pub unsafe fn set<T: 'static>(key: Key<T>, data: T) {\n     local_set(Handle::new(), key, data)\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n-pub unsafe fn local_data_modify<T: 'static>(\n-    key: LocalDataKey<T>,\n-    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n-\n-    local_modify(Handle::new(), key, modify_fn)\n+#[cfg(stage0)]\n+pub unsafe fn modify<T: 'static>(key: Key<@T>,\n+                                 f: &fn(Option<@T>) -> Option<@T>) {\n+    match f(pop(key)) {\n+        Some(next) => { set(key, next); }\n+        None => {}\n+    }\n+}\n+/**\n+ * Modify a task-local data value. If the function returns 'None', the\n+ * data is removed (and its reference dropped).\n+ */\n+#[cfg(not(stage0))]\n+pub unsafe fn modify<T: 'static>(key: Key<T>,\n+                                 f: &fn(Option<T>) -> Option<T>) {\n+    match f(pop(key)) {\n+        Some(next) => { set(key, next); }\n+        None => {}\n+    }\n }\n \n #[test]\n fn test_tls_multitask() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n-        local_data_set(my_key, @~\"parent data\");\n+        set(my_key, @~\"parent data\");\n         do task::spawn {\n             // TLS shouldn't carry over.\n-            assert!(local_data_get(my_key).is_none());\n-            local_data_set(my_key, @~\"child data\");\n-            assert!(*(local_data_get(my_key).get()) ==\n+            assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n+            set(my_key, @~\"child data\");\n+            assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n                     ~\"child data\");\n             // should be cleaned up for us\n         }\n         // Must work multiple times\n-        assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n-        assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n-        assert!(*(local_data_get(my_key).get()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n     }\n }\n \n #[test]\n fn test_tls_overwrite() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n-        local_data_set(my_key, @~\"first data\");\n-        local_data_set(my_key, @~\"next data\"); // Shouldn't leak.\n-        assert!(*(local_data_get(my_key).get()) == ~\"next data\");\n+        set(my_key, @~\"first data\");\n+        set(my_key, @~\"next data\"); // Shouldn't leak.\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n     }\n }\n \n #[test]\n fn test_tls_pop() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n-        local_data_set(my_key, @~\"weasel\");\n-        assert!(*(local_data_pop(my_key).get()) == ~\"weasel\");\n+        set(my_key, @~\"weasel\");\n+        assert!(*(pop(my_key).get()) == ~\"weasel\");\n         // Pop must remove the data from the map.\n-        assert!(local_data_pop(my_key).is_none());\n+        assert!(pop(my_key).is_none());\n     }\n }\n \n #[test]\n fn test_tls_modify() {\n     unsafe {\n         fn my_key(_x: @~str) { }\n-        local_data_modify(my_key, |data| {\n+        modify(my_key, |data| {\n             match data {\n                 Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n                 None           => Some(@~\"first data\")\n             }\n         });\n-        local_data_modify(my_key, |data| {\n+        modify(my_key, |data| {\n             match data {\n                 Some(@~\"first data\") => Some(@~\"next data\"),\n                 Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n                 None                 => fail!(\"missing value\")\n             }\n         });\n-        assert!(*(local_data_pop(my_key).get()) == ~\"next data\");\n+        assert!(*(pop(my_key).get()) == ~\"next data\");\n     }\n }\n \n@@ -158,7 +207,7 @@ fn test_tls_crust_automorestack_memorial_bug() {\n     // a stack smaller than 1 MB.\n     fn my_key(_x: @~str) { }\n     do task::spawn {\n-        unsafe { local_data_set(my_key, @~\"hax\"); }\n+        unsafe { set(my_key, @~\"hax\"); }\n     }\n }\n \n@@ -169,9 +218,9 @@ fn test_tls_multiple_types() {\n     fn int_key(_x: @int) { }\n     do task::spawn {\n         unsafe {\n-            local_data_set(str_key, @~\"string data\");\n-            local_data_set(box_key, @@());\n-            local_data_set(int_key, @42);\n+            set(str_key, @~\"string data\");\n+            set(box_key, @@());\n+            set(int_key, @42);\n         }\n     }\n }\n@@ -183,12 +232,12 @@ fn test_tls_overwrite_multiple_types() {\n     fn int_key(_x: @int) { }\n     do task::spawn {\n         unsafe {\n-            local_data_set(str_key, @~\"string data\");\n-            local_data_set(int_key, @42);\n+            set(str_key, @~\"string data\");\n+            set(int_key, @42);\n             // This could cause a segfault if overwriting-destruction is done\n             // with the crazy polymorphic transmute rather than the provided\n             // finaliser.\n-            local_data_set(int_key, @31337);\n+            set(int_key, @31337);\n         }\n     }\n }\n@@ -201,17 +250,17 @@ fn test_tls_cleanup_on_failure() {\n         fn str_key(_x: @~str) { }\n         fn box_key(_x: @@()) { }\n         fn int_key(_x: @int) { }\n-        local_data_set(str_key, @~\"parent data\");\n-        local_data_set(box_key, @@());\n+        set(str_key, @~\"parent data\");\n+        set(box_key, @@());\n         do task::spawn {\n             // spawn_linked\n-            local_data_set(str_key, @~\"string data\");\n-            local_data_set(box_key, @@());\n-            local_data_set(int_key, @42);\n+            set(str_key, @~\"string data\");\n+            set(box_key, @@());\n+            set(int_key, @42);\n             fail!();\n         }\n         // Not quite nondeterministic.\n-        local_data_set(int_key, @31337);\n+        set(int_key, @31337);\n         fail!();\n     }\n }\n@@ -221,6 +270,14 @@ fn test_static_pointer() {\n     unsafe {\n         fn key(_x: @&'static int) { }\n         static VALUE: int = 0;\n-        local_data_set(key, @&VALUE);\n+        set(key, @&VALUE);\n+    }\n+}\n+\n+#[test]\n+fn test_owned() {\n+    unsafe {\n+        fn key(_x: ~int) { }\n+        set(key, ~1);\n     }\n }"}, {"sha": "8d70732641d8c28c70f056b9e77def728f998e37", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -1248,7 +1248,7 @@ fn overridden_arg_key(_v: @OverriddenArgs) {}\n /// `os::set_args` function.\n pub fn args() -> ~[~str] {\n     unsafe {\n-        match local_data::local_data_get(overridden_arg_key) {\n+        match local_data::get(overridden_arg_key, |k| k.map(|&k| *k)) {\n             None => real_args(),\n             Some(args) => copy args.val\n         }\n@@ -1261,7 +1261,7 @@ pub fn args() -> ~[~str] {\n pub fn set_args(new_args: ~[~str]) {\n     unsafe {\n         let overridden_args = @OverriddenArgs { val: copy new_args };\n-        local_data::local_data_set(overridden_arg_key, overridden_args);\n+        local_data::set(overridden_arg_key, overridden_args);\n     }\n }\n "}, {"sha": "55b6fad21e7a18bafe20eeb41ac7e613345797a3", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -862,13 +862,13 @@ fn tls_rng_state(_v: @@mut IsaacRng) {}\n pub fn task_rng() -> @mut IsaacRng {\n     let r : Option<@@mut IsaacRng>;\n     unsafe {\n-        r = local_data::local_data_get(tls_rng_state);\n+        r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n     }\n     match r {\n         None => {\n             unsafe {\n                 let rng = @@mut IsaacRng::new_seeded(seed());\n-                local_data::local_data_set(tls_rng_state, rng);\n+                local_data::set(tls_rng_state, rng);\n                 *rng\n             }\n         }"}, {"sha": "c5961be40ecbe76b02b29557992156fb609cc042", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -57,7 +57,7 @@ pub enum SchedHome {\n }\n \n pub struct GarbageCollector;\n-pub struct LocalStorage(*c_void, Option<~fn(*c_void)>);\n+pub struct LocalStorage(*c_void, Option<extern \"Rust\" fn(*c_void)>);\n \n pub struct Unwinder {\n     unwinding: bool,\n@@ -346,15 +346,15 @@ mod test {\n \n     #[test]\n     fn tls() {\n-        use local_data::*;\n+        use local_data;\n         do run_in_newsched_task() {\n             unsafe {\n                 fn key(_x: @~str) { }\n-                local_data_set(key, @~\"data\");\n-                assert!(*local_data_get(key).get() == ~\"data\");\n+                local_data::set(key, @~\"data\");\n+                assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n                 fn key2(_x: @~str) { }\n-                local_data_set(key2, @~\"data\");\n-                assert!(*local_data_get(key2).get() == ~\"data\");\n+                local_data::set(key2, @~\"data\");\n+                assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n             }\n         }\n     }"}, {"sha": "42cfcbc16dbf8a7f038cb8e03e52bc532fb77a08", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 207, "deletions": 148, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -11,11 +11,13 @@\n #[allow(missing_doc)];\n \n use cast;\n-use cmp::Eq;\n use libc;\n+use local_data;\n use prelude::*;\n+use ptr;\n+use sys;\n use task::rt;\n-use local_data::LocalDataKey;\n+use util;\n \n use super::rt::rust_task;\n use rt::task::{Task, LocalStorage};\n@@ -43,25 +45,41 @@ impl Handle {\n     }\n }\n \n-pub trait LocalData { }\n-impl<T: 'static> LocalData for @T { }\n+trait LocalData {}\n+impl<T: 'static> LocalData for T {}\n \n-impl Eq for @LocalData {\n-    fn eq(&self, other: &@LocalData) -> bool {\n-        unsafe {\n-            let ptr_a: &(uint, uint) = cast::transmute(self);\n-            let ptr_b: &(uint, uint) = cast::transmute(other);\n-            return ptr_a == ptr_b;\n-        }\n-    }\n-    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n-}\n-\n-// If TLS is used heavily in future, this could be made more efficient with a\n-// proper map.\n-type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n-// Has to be a pointer at outermost layer; the foreign call returns void *.\n-type TaskLocalMap = @mut ~[Option<TaskLocalElement>];\n+// The task-local-map stores all TLS information for the currently running task.\n+// It is stored as an owned pointer into the runtime, and it's only allocated\n+// when TLS is used for the first time. This map must be very carefully\n+// constructed because it has many mutable loans unsoundly handed out on it to\n+// the various invocations of TLS requests.\n+//\n+// One of the most important operations is loaning a value via `get` to a\n+// caller. In doing so, the slot that the TLS entry is occupying cannot be\n+// invalidated because upon returning it's loan state must be updated. Currently\n+// the TLS map is a vector, but this is possibly dangerous because the vector\n+// can be reallocated/moved when new values are pushed onto it.\n+//\n+// This problem currently isn't solved in a very elegant way. Inside the `get`\n+// function, it internally \"invalidates\" all references after the loan is\n+// finished and looks up into the vector again. In theory this will prevent\n+// pointers from being moved under our feet so long as LLVM doesn't go too crazy\n+// with the optimizations.\n+//\n+// n.b. Other structures are not sufficient right now:\n+//          * HashMap uses ~[T] internally (push reallocates/moves)\n+//          * TreeMap is plausible, but it's in extra\n+//          * dlist plausible, but not in std\n+//          * a custom owned linked list was attempted, but difficult to write\n+//            and involved a lot of extra code bloat\n+//\n+// n.b. Has to be stored with a pointer at outermost layer; the foreign call\n+//      returns void *.\n+//\n+// n.b. If TLS is used heavily in future, this could be made more efficient with\n+//      a proper map.\n+type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, uint)>];\n+type TLSValue = ~LocalData:;\n \n fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -74,162 +92,203 @@ fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n }\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n-unsafe fn get_local_map(handle: Handle) -> TaskLocalMap {\n-    match handle {\n-        OldHandle(task) => get_task_local_map(task),\n-        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n-    }\n-}\n+unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n \n-unsafe fn get_task_local_map(task: *rust_task) -> TaskLocalMap {\n+    unsafe fn oldsched_map(task: *rust_task) -> &mut TaskLocalMap {\n+        extern fn cleanup_extern_cb(map_ptr: *libc::c_void) {\n+            cleanup_task_local_map(map_ptr);\n+        }\n \n-    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n-        cleanup_task_local_map(map_ptr);\n+        // Relies on the runtime initialising the pointer to null.\n+        // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n+        // into the tls slot for this task, and then mutable loans are taken\n+        // from this slot to modify the map.\n+        let map_ptr = rt::rust_get_task_local_data(task);\n+        if (*map_ptr).is_null() {\n+            // First time TLS is used, create a new map and set up the necessary\n+            // TLS information for its safe destruction\n+            let map: TaskLocalMap = ~[];\n+            *map_ptr = cast::transmute(map);\n+            rt::rust_task_local_data_atexit(task, cleanup_extern_cb);\n+        }\n+        return cast::transmute(map_ptr);\n     }\n \n-    // Relies on the runtime initialising the pointer to null.\n-    // Note: The map's box lives in TLS invisibly referenced once. Each time\n-    // we retrieve it for get/set, we make another reference, which get/set\n-    // drop when they finish. No \"re-storing after modifying\" is needed.\n-    let map_ptr = rt::rust_get_task_local_data(task);\n-    if map_ptr.is_null() {\n-        let map: TaskLocalMap = @mut ~[];\n-        // NB: This bumps the ref count before converting to an unsafe pointer,\n-        // keeping the map alive until TLS is destroyed\n-        rt::rust_set_task_local_data(task, cast::transmute(map));\n-        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n-        map\n-    } else {\n-        let map = cast::transmute(map_ptr);\n-        let nonmut = cast::transmute::<TaskLocalMap,\n-                                       @~[Option<TaskLocalElement>]>(map);\n-        cast::bump_box_refcount(nonmut);\n-        map\n+    unsafe fn newsched_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n+        // This is based on the same idea as the oldsched code above.\n+        match &mut *local {\n+            // If the at_exit function is already set, then we just need to take\n+            // a loan out on the TLS map stored inside\n+            &LocalStorage(ref mut map_ptr, Some(_)) => {\n+                assert!(map_ptr.is_not_null());\n+                return cast::transmute(map_ptr);\n+            }\n+            // If this is the first time we've accessed TLS, perform similar\n+            // actions to the oldsched way of doing things.\n+            &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+                assert!(map_ptr.is_null());\n+                assert!(at_exit.is_none());\n+                let map: TaskLocalMap = ~[];\n+                *map_ptr = cast::transmute(map);\n+                *at_exit = Some(cleanup_task_local_map);\n+                return cast::transmute(map_ptr);\n+            }\n+        }\n     }\n-}\n \n-unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> TaskLocalMap {\n-    match &mut *local {\n-        &LocalStorage(map_ptr, Some(_)) => {\n-            assert!(map_ptr.is_not_null());\n-            let map = cast::transmute(map_ptr);\n-            let nonmut = cast::transmute::<TaskLocalMap,\n-            @~[Option<TaskLocalElement>]>(map);\n-            cast::bump_box_refcount(nonmut);\n-            return map;\n-        }\n-        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n-            assert!((*map_ptr).is_null());\n-            let map: TaskLocalMap = @mut ~[];\n-            *map_ptr = cast::transmute(map);\n-            let at_exit_fn: ~fn(*libc::c_void) = |p|cleanup_task_local_map(p);\n-            *at_exit = Some(at_exit_fn);\n-            return map;\n-        }\n+    match handle {\n+        OldHandle(task) => oldsched_map(task),\n+        NewHandle(local_storage) => newsched_map(local_storage)\n     }\n }\n \n-unsafe fn key_to_key_value<T: 'static>(key: LocalDataKey<T>) -> *libc::c_void {\n-    // Keys are closures, which are (fnptr,envptr) pairs. Use fnptr.\n-    // Use reinterpret_cast -- transmute would leak (forget) the closure.\n-    let pair: (*libc::c_void, *libc::c_void) = cast::transmute_copy(&key);\n-    pair.first()\n+unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n+    let pair: sys::Closure = cast::transmute(key);\n+    return pair.code as *libc::c_void;\n }\n \n-// If returning Some(..), returns with @T with the map's reference. Careful!\n-unsafe fn local_data_lookup<T: 'static>(\n-    map: TaskLocalMap, key: LocalDataKey<T>)\n-    -> Option<(uint, *libc::c_void)> {\n-\n+pub unsafe fn local_pop<T: 'static>(handle: Handle,\n+                                    key: local_data::Key<T>) -> Option<T> {\n+    let map = get_local_map(handle);\n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).iter().position(|entry|\n+\n+    for map.mut_iter().advance |entry| {\n         match *entry {\n-            Some((k,_,_)) => k == key_value,\n-            None => false\n-        }\n-    );\n-    do map_pos.map |index| {\n-        // .get() is guaranteed because of \"None { false }\" above.\n-        let (_, data_ptr, _) = (*map)[*index].get();\n-        (*index, data_ptr)\n-    }\n-}\n+            Some((k, _, loans)) if k == key_value => {\n+                if loans != 0 {\n+                    fail!(\"TLS value has been loaned via get already\");\n+                }\n+                // Move the data out of the `entry` slot via util::replace. This\n+                // is guaranteed to succeed because we already matched on `Some`\n+                // above.\n+                let data = match util::replace(entry, None) {\n+                    Some((_, data, _)) => data,\n+                    None => libc::abort(),\n+                };\n \n-unsafe fn local_get_helper<T: 'static>(\n-    handle: Handle, key: LocalDataKey<T>,\n-    do_pop: bool) -> Option<@T> {\n+                // Move `data` into transmute to get out the memory that it\n+                // owns, we must free it manually later.\n+                let (_vtable, box): (uint, ~~T) = cast::transmute(data);\n \n-    let map = get_local_map(handle);\n-    // Interpreturn our findings from the map\n-    do local_data_lookup(map, key).map |result| {\n-        // A reference count magically appears on 'data' out of thin air. It\n-        // was referenced in the local_data box, though, not here, so before\n-        // overwriting the local_data_box we need to give an extra reference.\n-        // We must also give an extra reference when not removing.\n-        let (index, data_ptr) = *result;\n-        let data: @T = cast::transmute(data_ptr);\n-        cast::bump_box_refcount(data);\n-        if do_pop {\n-            map[index] = None;\n+                // Read the box's value (using the compiler's built-in\n+                // auto-deref functionality to obtain a pointer to the base)\n+                let ret = ptr::read_ptr(cast::transmute::<&T, *mut T>(*box));\n+\n+                // Finally free the allocated memory. we don't want this to\n+                // actually touch the memory inside because it's all duplicated\n+                // now, so the box is transmuted to a 0-sized type. We also use\n+                // a type which references `T` because currently the layout\n+                // could depend on whether T contains managed pointers or not.\n+                let _: ~~[T, ..0] = cast::transmute(box);\n+\n+                // Everything is now deallocated, and we own the value that was\n+                // located inside TLS, so we now return it.\n+                return Some(ret);\n+            }\n+            _ => {}\n         }\n-        data\n     }\n+    return None;\n }\n \n+pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n+                                       key: local_data::Key<T>,\n+                                       f: &fn(Option<&T>) -> U) -> U {\n+    // This function must be extremely careful. Because TLS can store owned\n+    // values, and we must have some form of `get` function other than `pop`,\n+    // this function has to give a `&` reference back to the caller.\n+    //\n+    // One option is to return the reference, but this cannot be sound because\n+    // the actual lifetime of the object is not known. The slot in TLS could not\n+    // be modified until the object goes out of scope, but the TLS code cannot\n+    // know when this happens.\n+    //\n+    // For this reason, the reference is yielded to a specified closure. This\n+    // way the TLS code knows exactly what the lifetime of the yielded pointer\n+    // is, allowing callers to acquire references to owned data. This is also\n+    // sound so long as measures are taken to ensure that while a TLS slot is\n+    // loaned out to a caller, it's not modified recursively.\n+    let map = get_local_map(handle);\n+    let key_value = key_to_key_value(key);\n \n-pub unsafe fn local_pop<T: 'static>(\n-    handle: Handle,\n-    key: LocalDataKey<T>) -> Option<@T> {\n-\n-    local_get_helper(handle, key, true)\n-}\n-\n-pub unsafe fn local_get<T: 'static>(\n-    handle: Handle,\n-    key: LocalDataKey<T>) -> Option<@T> {\n+    let pos = map.iter().position(|entry| {\n+        match *entry {\n+            Some((k, _, _)) if k == key_value => true, _ => false\n+        }\n+    });\n+    match pos {\n+        None => { return f(None); }\n+        Some(i) => {\n+            let ret;\n+            match map[i] {\n+                Some((_, ref data, ref mut loans)) => {\n+                    *loans = *loans + 1;\n+                    // data was created with `~~T as ~LocalData`, so we extract\n+                    // pointer part of the trait, (as ~~T), and then use\n+                    // compiler coercions to achieve a '&' pointer\n+                    match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data) {\n+                        (_vtable, ref box) => {\n+                            let value: &T = **box;\n+                            ret = f(Some(value));\n+                        }\n+                    }\n+                }\n+                _ => libc::abort()\n+            }\n \n-    local_get_helper(handle, key, false)\n+            // n.b. 'data' and 'loans' are both invalid pointers at the point\n+            // 'f' returned because `f` could have appended more TLS items which\n+            // in turn relocated the vector. Hence we do another lookup here to\n+            // fixup the loans.\n+            match map[i] {\n+                Some((_, _, ref mut loans)) => { *loans = *loans - 1; }\n+                None => { libc::abort(); }\n+            }\n+            return ret;\n+        }\n+    }\n }\n \n-pub unsafe fn local_set<T: 'static>(\n-    handle: Handle, key: LocalDataKey<T>, data: @T) {\n-\n+pub unsafe fn local_set<T: 'static>(handle: Handle,\n+                                    key: local_data::Key<T>,\n+                                    data: T) {\n     let map = get_local_map(handle);\n-    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n     let keyval = key_to_key_value(key);\n-    // We keep the data in two forms: one as an unsafe pointer, so we can get\n-    // it back by casting; another in an existential box, so the reference we\n-    // own on it can be dropped when the box is destroyed. The unsafe pointer\n-    // does not have a reference associated with it, so it may become invalid\n-    // when the box is destroyed.\n-    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n-    let data_box = @data as @LocalData;\n-    // Construct new entry to store in the map.\n-    let new_entry = Some((keyval, data_ptr, data_box));\n-    // Find a place to put it.\n-    match local_data_lookup(map, key) {\n-        Some((index, _old_data_ptr)) => {\n-            // Key already had a value set, _old_data_ptr, whose reference\n-            // will get dropped when the local_data box is overwritten.\n-            map[index] = new_entry;\n-        }\n-        None => {\n-            // Find an empty slot. If not, grow the vector.\n-            match (*map).iter().position(|x| x.is_none()) {\n-                Some(empty_index) => { map[empty_index] = new_entry; }\n-                None => { map.push(new_entry); }\n+\n+    // When the task-local map is destroyed, all the data needs to be cleaned\n+    // up. For this reason we can't do some clever tricks to store '~T' as a\n+    // '*c_void' or something like that. To solve the problem, we cast\n+    // everything to a trait (LocalData) which is then stored inside the map.\n+    // Upon destruction of the map, all the objects will be destroyed and the\n+    // traits have enough information about them to destroy themselves.\n+    //\n+    // FIXME(#7673): This should be \"~data as ~LocalData\" (without the colon at\n+    //               the end, and only one sigil)\n+    let data = ~~data as ~LocalData:;\n+\n+    fn insertion_position(map: &mut TaskLocalMap,\n+                          key: *libc::c_void) -> Option<uint> {\n+        // First see if the map contains this key already\n+        let curspot = map.iter().position(|entry| {\n+            match *entry {\n+                Some((ekey, _, loans)) if key == ekey => {\n+                    if loans != 0 {\n+                        fail!(\"TLS value has been loaned via get already\");\n+                    }\n+                    true\n+                }\n+                _ => false,\n             }\n+        });\n+        // If it doesn't contain the key, just find a slot that's None\n+        match curspot {\n+            Some(i) => Some(i),\n+            None => map.iter().position(|entry| entry.is_none())\n         }\n     }\n-}\n-\n-pub unsafe fn local_modify<T: 'static>(\n-    handle: Handle, key: LocalDataKey<T>,\n-    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n \n-    // Could be more efficient by doing the lookup work, but this is easy.\n-    let newdata = modify_fn(local_pop(handle, key));\n-    if newdata.is_some() {\n-        local_set(handle, key, newdata.unwrap());\n+    match insertion_position(map, keyval) {\n+        Some(i) => { map[i] = Some((keyval, data, 0)); }\n+        None => { map.push(Some((keyval, data, 0))); }\n     }\n }"}, {"sha": "fe80ec06c69d01ff997f85a17ecb29907fdd2876", "filename": "src/libstd/task/local_data_priv_stage0.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(missing_doc)];\n+\n+use cast;\n+use cmp::Eq;\n+use libc;\n+use local_data;\n+use prelude::*;\n+use sys;\n+use task::rt;\n+\n+use super::rt::rust_task;\n+use rt::task::{Task, LocalStorage};\n+\n+pub enum Handle {\n+    OldHandle(*rust_task),\n+    NewHandle(*mut LocalStorage)\n+}\n+\n+impl Handle {\n+    pub fn new() -> Handle {\n+        use rt::{context, OldTaskContext};\n+        use rt::local::Local;\n+        unsafe {\n+            match context() {\n+                OldTaskContext => {\n+                    OldHandle(rt::rust_get_task())\n+                }\n+                _ => {\n+                    let task = Local::unsafe_borrow::<Task>();\n+                    NewHandle(&mut (*task).storage)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub trait LocalData { }\n+impl<T: 'static> LocalData for @T { }\n+\n+impl Eq for @LocalData {\n+    fn eq(&self, other: &@LocalData) -> bool {\n+        unsafe {\n+            let ptr_a: &(uint, uint) = cast::transmute(self);\n+            let ptr_b: &(uint, uint) = cast::transmute(other);\n+            return ptr_a == ptr_b;\n+        }\n+    }\n+    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n+}\n+\n+// If TLS is used heavily in future, this could be made more efficient with a\n+// proper map.\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n+// Has to be a pointer at outermost layer; the foreign call returns void *.\n+type TaskLocalMap = ~[Option<TaskLocalElement>];\n+\n+fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n+    unsafe {\n+        assert!(!map_ptr.is_null());\n+        // Get and keep the single reference that was created at the\n+        // beginning.\n+        let _map: TaskLocalMap = cast::transmute(map_ptr);\n+        // All local_data will be destroyed along with the map.\n+    }\n+}\n+\n+// Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n+    match handle {\n+        OldHandle(task) => get_task_local_map(task),\n+        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n+    }\n+}\n+\n+unsafe fn get_task_local_map(task: *rust_task) -> &mut TaskLocalMap {\n+\n+    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n+        cleanup_task_local_map(map_ptr);\n+    }\n+\n+    // Relies on the runtime initialising the pointer to null.\n+    // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n+    // into the tls slot for this task, and then mutable loans are taken from\n+    // this slot to modify the map.\n+    let map_ptr = rt::rust_get_task_local_data(task);\n+    if (*map_ptr).is_null() {\n+        // First time TLS is used, create a new map and set up the necessary\n+        // TLS information for its safe destruction\n+        let map: TaskLocalMap = ~[];\n+        *map_ptr = cast::transmute(map);\n+        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n+    }\n+    return cast::transmute(map_ptr);\n+}\n+\n+unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n+    // This is based on the same idea as the oldsched code above.\n+    match &mut *local {\n+        // If the at_exit function is already set, then we just need to take a\n+        // loan out on the TLS map stored inside\n+        &LocalStorage(ref mut map_ptr, Some(_)) => {\n+            assert!(map_ptr.is_not_null());\n+            return cast::transmute(map_ptr);\n+        }\n+        // If this is the first time we've accessed TLS, perform similar\n+        // actions to the oldsched way of doing things.\n+        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+            assert!(map_ptr.is_null());\n+            assert!(at_exit.is_none());\n+            let map: TaskLocalMap = ~[];\n+            *map_ptr = cast::transmute(map);\n+            *at_exit = Some(cleanup_task_local_map);\n+            return cast::transmute(map_ptr);\n+        }\n+    }\n+}\n+\n+unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<@T>) -> *libc::c_void {\n+    let pair: sys::Closure = cast::transmute(key);\n+    return pair.code as *libc::c_void;\n+}\n+\n+// If returning Some(..), returns with @T with the map's reference. Careful!\n+unsafe fn local_data_lookup<T: 'static>(\n+    map: &mut TaskLocalMap, key: local_data::Key<@T>)\n+    -> Option<(uint, *libc::c_void)> {\n+\n+    let key_value = key_to_key_value(key);\n+    for map.iter().enumerate().advance |(i, entry)| {\n+        match *entry {\n+            Some((k, data, _)) if k == key_value => { return Some((i, data)); }\n+            _ => {}\n+        }\n+    }\n+    return None;\n+}\n+\n+unsafe fn local_get_helper<T: 'static>(\n+    handle: Handle, key: local_data::Key<@T>,\n+    do_pop: bool) -> Option<@T> {\n+\n+    let map = get_local_map(handle);\n+    // Interpreturn our findings from the map\n+    do local_data_lookup(map, key).map |result| {\n+        // A reference count magically appears on 'data' out of thin air. It\n+        // was referenced in the local_data box, though, not here, so before\n+        // overwriting the local_data_box we need to give an extra reference.\n+        // We must also give an extra reference when not removing.\n+        let (index, data_ptr) = *result;\n+        let data: @T = cast::transmute(data_ptr);\n+        cast::bump_box_refcount(data);\n+        if do_pop {\n+            map[index] = None;\n+        }\n+        data\n+    }\n+}\n+\n+\n+pub unsafe fn local_pop<T: 'static>(\n+    handle: Handle,\n+    key: local_data::Key<@T>) -> Option<@T> {\n+\n+    local_get_helper(handle, key, true)\n+}\n+\n+pub unsafe fn local_get<T: 'static, U>(\n+    handle: Handle,\n+    key: local_data::Key<@T>,\n+    f: &fn(Option<&@T>) -> U) -> U {\n+\n+    match local_get_helper(handle, key, false) {\n+        Some(ref x) => f(Some(x)),\n+        None => f(None)\n+    }\n+}\n+\n+pub unsafe fn local_set<T: 'static>(\n+    handle: Handle, key: local_data::Key<@T>, data: @T) {\n+\n+    let map = get_local_map(handle);\n+    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n+    let keyval = key_to_key_value(key);\n+    // We keep the data in two forms: one as an unsafe pointer, so we can get\n+    // it back by casting; another in an existential box, so the reference we\n+    // own on it can be dropped when the box is destroyed. The unsafe pointer\n+    // does not have a reference associated with it, so it may become invalid\n+    // when the box is destroyed.\n+    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n+    let data_box = @data as @LocalData;\n+    // Construct new entry to store in the map.\n+    let new_entry = Some((keyval, data_ptr, data_box));\n+    // Find a place to put it.\n+    match local_data_lookup(map, key) {\n+        Some((index, _old_data_ptr)) => {\n+            // Key already had a value set, _old_data_ptr, whose reference\n+            // will get dropped when the local_data box is overwritten.\n+            map[index] = new_entry;\n+        }\n+        None => {\n+            // Find an empty slot. If not, grow the vector.\n+            match map.iter().position(|x| x.is_none()) {\n+                Some(empty_index) => { map[empty_index] = new_entry; }\n+                None => { map.push(new_entry); }\n+            }\n+        }\n+    }\n+}\n+\n+pub unsafe fn local_modify<T: 'static>(\n+    handle: Handle, key: local_data::Key<@T>,\n+    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n+\n+    // Could be more efficient by doing the lookup work, but this is easy.\n+    let newdata = modify_fn(local_pop(handle, key));\n+    if newdata.is_some() {\n+        local_set(handle, key, newdata.unwrap());\n+    }\n+}"}, {"sha": "b14100991dfcf3b64954c831e6a9cdde0c9ad14a", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -54,6 +54,10 @@ use util;\n #[cfg(test)] use ptr;\n #[cfg(test)] use task;\n \n+#[cfg(stage0)]\n+#[path=\"local_data_priv_stage0.rs\"]\n+mod local_data_priv;\n+#[cfg(not(stage0))]\n mod local_data_priv;\n pub mod rt;\n pub mod spawn;"}, {"sha": "76fcad0759af3715875885fe43f05226ce8fa2b0", "filename": "src/libstd/task/rt.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Frt.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -63,9 +63,7 @@ pub extern {\n     fn rust_task_kill_all(task: *rust_task);\n \n     #[rust_stack]\n-    fn rust_get_task_local_data(task: *rust_task) -> *libc::c_void;\n-    #[rust_stack]\n-    fn rust_set_task_local_data(task: *rust_task, map: *libc::c_void);\n+    fn rust_get_task_local_data(task: *rust_task) -> *mut *libc::c_void;\n     #[rust_stack]\n     fn rust_task_local_data_atexit(task: *rust_task, cleanup_fn: *u8);\n }"}, {"sha": "f45d470a9f67a18c5fcdf364d867dfc4a26ae884", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -478,26 +478,28 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n          * Step 1. Get spawner's taskgroup info.\n          *##################################################################*/\n         let spawner_group: @@mut TCB =\n-            match local_get(OldHandle(spawner), taskgroup_key!()) {\n-                None => {\n-                    // Main task, doing first spawn ever. Lazily initialise\n-                    // here.\n-                    let mut members = new_taskset();\n-                    taskset_insert(&mut members, spawner);\n-                    let tasks = exclusive(Some(TaskGroupData {\n-                        members: members,\n-                        descendants: new_taskset(),\n-                    }));\n-                    // Main task/group has no ancestors, no notifier, etc.\n-                    let group = @@mut TCB(spawner,\n-                                          tasks,\n-                                          AncestorList(None),\n-                                          true,\n-                                          None);\n-                    local_set(OldHandle(spawner), taskgroup_key!(), group);\n-                    group\n+            do local_get(OldHandle(spawner), taskgroup_key!()) |group| {\n+                match group {\n+                    None => {\n+                        // Main task, doing first spawn ever. Lazily initialise\n+                        // here.\n+                        let mut members = new_taskset();\n+                        taskset_insert(&mut members, spawner);\n+                        let tasks = exclusive(Some(TaskGroupData {\n+                            members: members,\n+                            descendants: new_taskset(),\n+                        }));\n+                        // Main task/group has no ancestors, no notifier, etc.\n+                        let group = @@mut TCB(spawner,\n+                                              tasks,\n+                                              AncestorList(None),\n+                                              true,\n+                                              None);\n+                        local_set(OldHandle(spawner), taskgroup_key!(), group);\n+                        group\n+                    }\n+                    Some(&group) => group\n                 }\n-                Some(group) => group\n             };\n         let spawner_group: &mut TCB = *spawner_group;\n "}, {"sha": "1942cb6ad56928c23b3b474f827b2c6d90ce5247", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -698,10 +698,10 @@ pub fn get_sctable() -> @mut SCTable {\n         let sctable_key = (cast::transmute::<(uint, uint),\n                            &fn:Copy(v: @@mut SCTable)>(\n                                (-4 as uint, 0u)));\n-        match local_data::local_data_get(sctable_key) {\n+        match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n             None => {\n                 let new_table = @@mut new_sctable_internal();\n-                local_data::local_data_set(sctable_key,new_table);\n+                local_data::set(sctable_key,new_table);\n                 *new_table\n             },\n             Some(intr) => *intr"}, {"sha": "46e0ef32321a5a3f1faa788d5976ba792cdaa63c", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -490,11 +490,11 @@ pub fn get_ident_interner() -> @ident_interner {\n             (cast::transmute::<(uint, uint),\n              &fn:Copy(v: @@::parse::token::ident_interner)>(\n                  (-3 as uint, 0u)));\n-        match local_data::local_data_get(key) {\n+        match local_data::get(key, |k| k.map(|&k| *k)) {\n             Some(interner) => *interner,\n             None => {\n                 let interner = mk_fresh_ident_interner();\n-                local_data::local_data_set(key, @interner);\n+                local_data::set(key, @interner);\n                 interner\n             }\n         }"}, {"sha": "4382e5b22a0245b2e1e25943486d37de7b74c24f", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -671,14 +671,10 @@ rust_unlock_little_lock(lock_and_signal *lock) {\n     lock->unlock();\n }\n \n-// set/get/atexit task_local_data can run on the rust stack for speed.\n-extern \"C\" void *\n+// get/atexit task_local_data can run on the rust stack for speed.\n+extern \"C\" void **\n rust_get_task_local_data(rust_task *task) {\n-    return task->task_local_data;\n-}\n-extern \"C\" void\n-rust_set_task_local_data(rust_task *task, void *data) {\n-    task->task_local_data = data;\n+    return &task->task_local_data;\n }\n extern \"C\" void\n rust_task_local_data_atexit(rust_task *task, void (*cleanup_fn)(void *data)) {"}, {"sha": "a13b1d6015bdebbba77f36830f803575bacaf140", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -195,7 +195,6 @@ rust_destroy_little_lock\n rust_lock_little_lock\n rust_unlock_little_lock\n rust_get_task_local_data\n-rust_set_task_local_data\n rust_task_local_data_atexit\n rust_task_ref\n rust_task_deref\n@@ -271,4 +270,4 @@ rust_current_boxed_region\n rust_take_global_args_lock\n rust_drop_global_args_lock\n rust_set_exit_status_newrt\n-rust_get_exit_status_newrt\n\\ No newline at end of file\n+rust_get_exit_status_newrt"}, {"sha": "13c996692288955091dabfc130bdf4e809d219d2", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07183ea6e719e18f5d6b09afbe519c9f940c4705/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=07183ea6e719e18f5d6b09afbe519c9f940c4705", "patch": "@@ -10,12 +10,12 @@\n \n // Testing that we can't store a borrowed pointer it task-local storage\n \n-use std::local_data::*;\n+use std::local_data;\n \n fn key(_x: @&int) { }\n \n fn main() {\n     unsafe {\n-        local_data_set(key, @&0); //~ ERROR does not fulfill `'static`\n+        local_data::set(key, @&0); //~ ERROR does not fulfill `'static`\n     }\n }"}]}