{"sha": "da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhODg3MDc0ZmM3MGE5ZjhkMmFmZWM4ZGJlNmUyZWVlYTZmYzE0MDY=", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-06-27T02:26:52Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2017-07-02T11:53:29Z"}, "message": "Output line column info when panicking", "tree": {"sha": "8c9777a4efcf37736d7ef89aa6f273c61968a5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c9777a4efcf37736d7ef89aa6f273c61968a5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "html_url": "https://github.com/rust-lang/rust/commit/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3a130cffca55c650c4a6d2de77c3138cf74c3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3a130cffca55c650c4a6d2de77c3138cf74c3f8", "html_url": "https://github.com/rust-lang/rust/commit/c3a130cffca55c650c4a6d2de77c3138cf74c3f8"}], "stats": {"total": 261, "additions": 207, "deletions": 54}, "files": [{"sha": "5acc6c3848a07b1587cfd33cc2b5e44e17d34b17", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -39,9 +39,9 @@\n //! * `rust_begin_panic` - This function takes three arguments, a\n //!   `fmt::Arguments`, a `&'static str`, and a `u32`. These three arguments\n //!   dictate the panic message, the file at which panic was invoked, and the\n-//!   line. It is up to consumers of this core library to define this panic\n-//!   function; it is only required to never return. This requires a `lang`\n-//!   attribute named `panic_fmt`.\n+//!   line and column inside the file. It is up to consumers of this core\n+//!   library to define this panic function; it is only required to never\n+//!   return. This requires a `lang` attribute named `panic_fmt`.\n //!\n //! * `rust_eh_personality` - is used by the failure mechanisms of the\n //!    compiler. This is often mapped to GCC's personality function, but crates\n@@ -160,6 +160,11 @@ pub mod array;\n pub mod sync;\n pub mod cell;\n pub mod char;\n+// FIXME: remove when SNAP\n+#[cfg(stage0)]\n+#[path = \"panicking_stage0.rs\"]\n+pub mod panicking;\n+#[cfg(not(stage0))]\n pub mod panicking;\n pub mod iter;\n pub mod option;"}, {"sha": "c9761bbe61153cf8bbf8e28ae0edc233b0037b4c", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -17,16 +17,18 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     );\n     ($msg:expr) => ({\n-        static _MSG_FILE_LINE: (&'static str, &'static str, u32) = ($msg, file!(), line!());\n-        $crate::panicking::panic(&_MSG_FILE_LINE)\n+        static _MSG_FILE_LINE_COL: (&'static str, &'static str, u32, u32) =\n+            ($msg, file!(), line!(), column!());\n+        $crate::panicking::panic_new(&_MSG_FILE_LINE_COL)\n     });\n     ($fmt:expr, $($arg:tt)*) => ({\n         // The leading _'s are to avoid dead code warnings if this is\n         // used inside a dead function. Just `#[allow(dead_code)]` is\n         // insufficient, since the user may have\n         // `#[forbid(dead_code)]` and which cannot be overridden.\n-        static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-        $crate::panicking::panic_fmt(format_args!($fmt, $($arg)*), &_FILE_LINE)\n+        static _MSG_FILE_LINE_COL: (&'static str, u32, u32) =\n+            (file!(), line!(), column!());\n+        $crate::panicking::panic_fmt_new(format_args!($fmt, $($arg)*), &_MSG_FILE_LINE_COL)\n     });\n }\n "}, {"sha": "d4df0f69b907d442b9de24c5d5ec2d7c8c8e84ac", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -17,7 +17,7 @@\n //!\n //! ```\n //! # use std::fmt;\n-//! fn panic_impl(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> !\n+//! fn panic_impl(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> !\n //! # { loop {} }\n //! ```\n //!\n@@ -38,35 +38,45 @@\n \n use fmt;\n \n+#[cold] #[inline(never)]\n+pub fn panic_new(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n+    panic(&expr_file_line_col)\n+}\n+\n #[cold] #[inline(never)] // this is the slow path, always\n #[lang = \"panic\"]\n-pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n+pub fn panic(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n     // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n     // reduce size overhead. The format_args! macro uses str's Display trait to\n     // write expr, which calls Formatter::pad, which must accommodate string\n     // truncation and padding (even though none is used here). Using\n     // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n     // output binary, saving up to a few kilobytes.\n-    let (expr, file, line) = *expr_file_line;\n-    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line))\n+    let (expr, file, line, col) = *expr_file_line_col;\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line, col))\n }\n \n #[cold] #[inline(never)]\n #[lang = \"panic_bounds_check\"]\n-fn panic_bounds_check(file_line: &(&'static str, u32),\n+fn panic_bounds_check(file_line_col: &(&'static str, u32, u32),\n                      index: usize, len: usize) -> ! {\n     panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n-                           len, index), file_line)\n+                           len, index), file_line_col)\n+}\n+\n+#[cold] #[inline(never)]\n+pub fn panic_fmt_new(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    panic_fmt(fmt, &file_line_col)\n }\n \n #[cold] #[inline(never)]\n-pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n+pub fn panic_fmt(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n     #[allow(improper_ctypes)]\n     extern {\n         #[lang = \"panic_fmt\"]\n         #[unwind]\n-        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32) -> !;\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col :u32) -> !;\n     }\n-    let (file, line) = *file_line;\n-    unsafe { panic_impl(fmt, file, line) }\n+    let (file, line, col) = *file_line_col;\n+    unsafe { panic_impl(fmt, file, line, col) }\n }"}, {"sha": "3506f6a93bc0daf9118645a7e28ade18617252de", "filename": "src/libcore/panicking_stage0.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Fpanicking_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibcore%2Fpanicking_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking_stage0.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Panic support for libcore\n+//!\n+//! The core library cannot define panicking, but it does *declare* panicking. This\n+//! means that the functions inside of libcore are allowed to panic, but to be\n+//! useful an upstream crate must define panicking for libcore to use. The current\n+//! interface for panicking is:\n+//!\n+//! ```\n+//! # use std::fmt;\n+//! fn panic_impl(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> !\n+//! # { loop {} }\n+//! ```\n+//!\n+//! This definition allows for panicking with any general message, but it does not\n+//! allow for failing with a `Box<Any>` value. The reason for this is that libcore\n+//! is not allowed to allocate.\n+//!\n+//! This module contains a few other panicking functions, but these are just the\n+//! necessary lang items for the compiler. All panics are funneled through this\n+//! one function. Currently, the actual symbol is declared in the standard\n+//! library, but the location of this may change over time.\n+\n+#![allow(dead_code, missing_docs)]\n+#![unstable(feature = \"core_panic\",\n+            reason = \"internal details of the implementation of the `panic!` \\\n+                      and related macros\",\n+            issue = \"0\")]\n+\n+use fmt;\n+\n+#[cold] #[inline(never)]\n+pub fn panic_new(expr_file_line_col: &(&'static str, &'static str, u32, u32)) -> ! {\n+    let (expr, file, line, _) = *expr_file_line_col;\n+    let expr_file_line = (expr, file, line);\n+    panic(&expr_file_line)\n+}\n+\n+#[cold] #[inline(never)] // this is the slow path, always\n+#[lang = \"panic\"]\n+pub fn panic(expr_file_line: &(&'static str, &'static str, u32)) -> ! {\n+    // Use Arguments::new_v1 instead of format_args!(\"{}\", expr) to potentially\n+    // reduce size overhead. The format_args! macro uses str's Display trait to\n+    // write expr, which calls Formatter::pad, which must accommodate string\n+    // truncation and padding (even though none is used here). Using\n+    // Arguments::new_v1 may allow the compiler to omit Formatter::pad from the\n+    // output binary, saving up to a few kilobytes.\n+    let (expr, file, line) = *expr_file_line;\n+    panic_fmt(fmt::Arguments::new_v1(&[expr], &[]), &(file, line))\n+}\n+\n+#[cold] #[inline(never)]\n+#[lang = \"panic_bounds_check\"]\n+fn panic_bounds_check(file_line: &(&'static str, u32),\n+                     index: usize, len: usize) -> ! {\n+    panic_fmt(format_args!(\"index out of bounds: the len is {} but the index is {}\",\n+                           len, index), file_line)\n+}\n+\n+#[cold] #[inline(never)]\n+pub fn panic_fmt_new(fmt: fmt::Arguments, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    let (file, line, _) = *file_line_col;\n+    let file_line = (file, line);\n+    panic_fmt(fmt, &file_line)\n+}\n+\n+#[cold] #[inline(never)]\n+pub fn panic_fmt(fmt: fmt::Arguments, file_line: &(&'static str, u32)) -> ! {\n+    #[allow(improper_ctypes)]\n+    extern {\n+        #[lang = \"panic_fmt\"]\n+        #[unwind]\n+        fn panic_impl(fmt: fmt::Arguments, file: &'static str, line: u32, col: u32) -> !;\n+    }\n+    let (file, line) = *file_line;\n+    unsafe { panic_impl(fmt, file, line, 0) }\n+}"}, {"sha": "48b166c61deb17323bd228e88f65cf10d00027af", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -28,6 +28,7 @@ use type_of;\n use type_::Type;\n \n use syntax::symbol::Symbol;\n+use syntax_pos::Pos;\n \n use std::cmp;\n \n@@ -333,6 +334,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n+                let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);\n \n                 // Put together the arguments to the panic entry point.\n                 let (lang_item, args, const_err) = match *msg {\n@@ -347,29 +349,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     index: index as u64\n                                 }));\n \n-                        let file_line = C_struct(bcx.ccx, &[filename, line], false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));\n-                        let file_line = consts::addr_of(bcx.ccx,\n-                                                        file_line,\n-                                                        align,\n-                                                        \"panic_bounds_check_loc\");\n+                        let file_line_col = C_struct(bcx.ccx, &[filename, line, col], false);\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(file_line_col));\n+                        let file_line_col = consts::addr_of(bcx.ccx,\n+                                                            file_line_col,\n+                                                            align,\n+                                                            \"panic_bounds_check_loc\");\n                         (lang_items::PanicBoundsCheckFnLangItem,\n-                         vec![file_line, index, len],\n+                         vec![file_line_col, index, len],\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n                         let msg_str = Symbol::intern(err.description()).as_str();\n                         let msg_str = C_str_slice(bcx.ccx, msg_str);\n-                        let msg_file_line = C_struct(bcx.ccx,\n-                                                     &[msg_str, filename, line],\n+                        let msg_file_line_col = C_struct(bcx.ccx,\n+                                                     &[msg_str, filename, line, col],\n                                                      false);\n-                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line));\n-                        let msg_file_line = consts::addr_of(bcx.ccx,\n-                                                            msg_file_line,\n-                                                            align,\n-                                                            \"panic_loc\");\n+                        let align = llalign_of_min(bcx.ccx, common::val_ty(msg_file_line_col));\n+                        let msg_file_line_col = consts::addr_of(bcx.ccx,\n+                                                                msg_file_line_col,\n+                                                                align,\n+                                                                \"panic_loc\");\n                         (lang_items::PanicFnLangItem,\n-                         vec![msg_file_line],\n+                         vec![msg_file_line_col],\n                          Some(ErrKind::Math(err.clone())))\n                     }\n                 };"}, {"sha": "6eb9faacf7fbe4f392ca2609291e520ec8865c7b", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -41,10 +41,10 @@ macro_rules! panic {\n         panic!(\"explicit panic\")\n     });\n     ($msg:expr) => ({\n-        $crate::rt::begin_panic($msg, {\n+        $crate::rt::begin_panic_new($msg, {\n             // static requires less code at runtime, more constant data\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            &_FILE_LINE_COL\n         })\n     });\n     ($fmt:expr, $($arg:tt)+) => ({\n@@ -53,8 +53,8 @@ macro_rules! panic {\n             // used inside a dead function. Just `#[allow(dead_code)]` is\n             // insufficient, since the user may have\n             // `#[forbid(dead_code)]` and which cannot be overridden.\n-            static _FILE_LINE: (&'static str, u32) = (file!(), line!());\n-            &_FILE_LINE\n+            static _FILE_LINE_COL: (&'static str, u32, u32) = (file!(), line!(), column!());\n+            &_FILE_LINE_COL\n         })\n     });\n }"}, {"sha": "1a8d3b09009206160c5d89a6827a7c7105cbf325", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 58, "deletions": 11, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -262,6 +262,7 @@ impl<'a> PanicInfo<'a> {\n pub struct Location<'a> {\n     file: &'a str,\n     line: u32,\n+    col: u32,\n }\n \n impl<'a> Location<'a> {\n@@ -308,6 +309,28 @@ impl<'a> Location<'a> {\n     pub fn line(&self) -> u32 {\n         self.line\n     }\n+\n+    /// Returns the column from which the panic originated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```should_panic\n+    /// use std::panic;\n+    ///\n+    /// panic::set_hook(Box::new(|panic_info| {\n+    ///     if let Some(location) = panic_info.location() {\n+    ///         println!(\"panic occured at column {}\", location.column());\n+    ///     } else {\n+    ///         println!(\"panic occured but can't get location information...\");\n+    ///     }\n+    /// }));\n+    ///\n+    /// panic!(\"Normal panic\");\n+    /// ```\n+    #[unstable(feature = \"panic_col\", issue = \"42939\")]\n+    pub fn column(&self) -> u32 {\n+        self.col\n+    }\n }\n \n fn default_hook(info: &PanicInfo) {\n@@ -329,6 +352,7 @@ fn default_hook(info: &PanicInfo) {\n \n     let file = info.location.file;\n     let line = info.location.line;\n+    let col = info.location.col;\n \n     let msg = match info.payload.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n@@ -342,8 +366,8 @@ fn default_hook(info: &PanicInfo) {\n     let name = thread.as_ref().and_then(|t| t.name()).unwrap_or(\"<unnamed>\");\n \n     let write = |err: &mut ::io::Write| {\n-        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}\",\n-                         name, msg, file, line);\n+        let _ = writeln!(err, \"thread '{}' panicked at '{}', {}:{}:{}\",\n+                         name, msg, file, line, col);\n \n         #[cfg(feature = \"backtrace\")]\n         {\n@@ -467,8 +491,9 @@ pub fn panicking() -> bool {\n #[unwind]\n pub extern fn rust_begin_panic(msg: fmt::Arguments,\n                                file: &'static str,\n-                               line: u32) -> ! {\n-    begin_panic_fmt(&msg, &(file, line))\n+                               line: u32,\n+                               col: u32) -> ! {\n+    begin_panic_fmt(&msg, &(file, line, col))\n }\n \n /// The entry point for panicking with a formatted message.\n@@ -482,7 +507,7 @@ pub extern fn rust_begin_panic(msg: fmt::Arguments,\n            issue = \"0\")]\n #[inline(never)] #[cold]\n pub fn begin_panic_fmt(msg: &fmt::Arguments,\n-                       file_line: &(&'static str, u32)) -> ! {\n+                       file_line_col: &(&'static str, u32, u32)) -> ! {\n     use fmt::Write;\n \n     // We do two allocations here, unfortunately. But (a) they're\n@@ -492,7 +517,25 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments,\n \n     let mut s = String::new();\n     let _ = s.write_fmt(*msg);\n-    begin_panic(s, file_line)\n+    begin_panic_new(s, file_line_col)\n+}\n+\n+// FIXME: remove begin_panic and rename begin_panic_new to begin_panic when SNAP\n+\n+/// This is the entry point of panicking for panic!() and assert!().\n+#[unstable(feature = \"libstd_sys_internals\",\n+           reason = \"used by the panic! macro\",\n+           issue = \"0\")]\n+#[inline(never)] #[cold] // avoid code bloat at the call sites as much as possible\n+pub fn begin_panic_new<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u32)) -> ! {\n+    // Note that this should be the only allocation performed in this code path.\n+    // Currently this means that panic!() on OOM will invoke this code path,\n+    // but then again we're not really ready for panic on OOM anyway. If\n+    // we do start doing this, then we should propagate this allocation to\n+    // be performed in the parent of this thread instead of the thread that's\n+    // panicking.\n+\n+    rust_panic_with_hook(Box::new(msg), file_line_col)\n }\n \n /// This is the entry point of panicking for panic!() and assert!().\n@@ -508,7 +551,10 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n     // be performed in the parent of this thread instead of the thread that's\n     // panicking.\n \n-    rust_panic_with_hook(Box::new(msg), file_line)\n+    let (file, line) = *file_line;\n+    let file_line_col = (file, line, 0);\n+\n+    rust_panic_with_hook(Box::new(msg), &file_line_col)\n }\n \n /// Executes the primary logic for a panic, including checking for recursive\n@@ -520,8 +566,8 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line: &(&'static str, u32)) -> !\n #[inline(never)]\n #[cold]\n fn rust_panic_with_hook(msg: Box<Any + Send>,\n-                        file_line: &(&'static str, u32)) -> ! {\n-    let (file, line) = *file_line;\n+                        file_line_col: &(&'static str, u32, u32)) -> ! {\n+    let (file, line, col) = *file_line_col;\n \n     let panics = update_panic_count(1);\n \n@@ -540,8 +586,9 @@ fn rust_panic_with_hook(msg: Box<Any + Send>,\n         let info = PanicInfo {\n             payload: &*msg,\n             location: Location {\n-                file: file,\n-                line: line,\n+                file,\n+                line,\n+                col,\n             },\n         };\n         HOOK_LOCK.read();"}, {"sha": "2ee63527c147cfd739f93b04939abb2557103ce2", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -25,7 +25,7 @@\n \n \n // Reexport some of our utilities which are expected by other crates.\n-pub use panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n+pub use panicking::{begin_panic_new, begin_panic, begin_panic_fmt, update_panic_count};\n \n #[cfg(not(test))]\n #[lang = \"start\"]"}, {"sha": "412a34932087d52a9bbbabb4794baaeb9590b2c4", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da887074fc70a9f8d2afec8dbe6e2eeea6fc1406/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=da887074fc70a9f8d2afec8dbe6e2eeea6fc1406", "patch": "@@ -11,7 +11,7 @@\n use abi::Abi;\n use ast::{self, Ident, Generics, Expr, BlockCheckMode, UnOp, PatKind};\n use attr;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Pos, Span, DUMMY_SP};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n@@ -768,14 +768,15 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n-        let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n-        let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n+        let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n+        let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);\n+        let expr_loc_ptr = self.expr_addr_of(span, expr_loc_tuple);\n         self.expr_call_global(\n             span,\n-            self.std_path(&[\"rt\", \"begin_panic\"]),\n+            self.std_path(&[\"rt\", \"begin_panic_new\"]),\n             vec![\n                 self.expr_str(span, msg),\n-                expr_file_line_ptr])\n+                expr_loc_ptr])\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {"}]}