{"sha": "c995a62d44ce8534d4f8bf36284419661b87e167", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5OTVhNjJkNDRjZTg1MzRkNGY4YmYzNjI4NDQxOTY2MWI4N2UxNjc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-18T22:53:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T19:00:08Z"}, "message": "librustc: WIP patch for using the return value.", "tree": {"sha": "e262af9ba09eb89d97b631596c344f9f3620c17a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e262af9ba09eb89d97b631596c344f9f3620c17a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c995a62d44ce8534d4f8bf36284419661b87e167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c995a62d44ce8534d4f8bf36284419661b87e167", "html_url": "https://github.com/rust-lang/rust/commit/c995a62d44ce8534d4f8bf36284419661b87e167", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c995a62d44ce8534d4f8bf36284419661b87e167/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4", "html_url": "https://github.com/rust-lang/rust/commit/7720c15ae11141e2b1a2a3a560b1cdacb6ddada4"}], "stats": {"total": 1184, "additions": 778, "deletions": 406}, "files": [{"sha": "81190ea8fc62e4f8c9d805674b988057cb1d35dc", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -95,7 +95,7 @@ pub use str::{StrSlice};\n pub use container::{Container, Mutable};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use iter::{ExtendedMutableIter};"}, {"sha": "1d7cc8515a6566d9397dd5dfe69c88d43c9cfc47", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -16,7 +16,6 @@\n use container::{Container, Mutable, Map, Set};\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use to_bytes::IterBytes;\n use iter::BaseIter;\n use hash::Hash;\n use iter;\n@@ -72,7 +71,7 @@ fn linear_map_with_capacity_and_keys<K:Eq + Hash,V>(\n     }\n }\n \n-priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n+priv impl<K:Hash + Eq,V> HashMap<K, V> {\n     #[inline(always)]\n     fn to_bucket(&self, h: uint) -> uint {\n         // A good hash function with entropy spread over all of the\n@@ -111,9 +110,8 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n     }\n \n     #[inline(always)]\n-    fn bucket_for_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self,\n-                                                           k: &Q)\n-                                                        -> SearchResult {\n+    fn bucket_for_key_equiv<Q:Hash + Equiv<K>>(&self, k: &Q)\n+                                               -> SearchResult {\n         let hash = k.hash_keyed(self.k0, self.k1) as uint;\n         self.bucket_for_key_with_hash_equiv(hash, k)\n     }\n@@ -303,15 +301,15 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Container for HashMap<K, V> {\n+impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n     /// Return the number of elements in the map\n     fn len(&const self) -> uint { self.size }\n \n     /// Return true if the map contains no elements\n     fn is_empty(&const self) -> bool { self.len() == 0 }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Mutable for HashMap<K, V> {\n+impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         for uint::range(0, self.buckets.len()) |idx| {\n@@ -321,7 +319,7 @@ impl<K:Hash + IterBytes + Eq,V> Mutable for HashMap<K, V> {\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n+impl<K:Hash + Eq,V> Map<K, V> for HashMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, k: &K) -> bool {\n         match self.bucket_for_key(k) {\n@@ -458,7 +456,7 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n }\n \n-pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n+pub impl<K: Hash + Eq, V> HashMap<K, V> {\n     /// Create an empty HashMap\n     fn new() -> HashMap<K, V> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n@@ -669,8 +667,7 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n \n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence\n-    fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n-                                                      -> bool {\n+    fn contains_key_equiv<Q:Hash + Equiv<K>>(&self, key: &Q) -> bool {\n         match self.bucket_for_key_equiv(key) {\n             FoundEntry(_) => {true}\n             TableFull | FoundHole(_) => {false}\n@@ -680,8 +677,7 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n     #[cfg(stage0)]\n-    fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n-                                              -> Option<&'self V> {\n+    fn find_equiv<Q:Hash + Equiv<K>>(&self, k: &Q) -> Option<&'self V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n@@ -693,17 +689,15 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n     #[cfg(stage1)]\n     #[cfg(stage2)]\n     #[cfg(stage3)]\n-    fn find_equiv<'a, Q:Hash + IterBytes + Equiv<K>>(\n-        &'a self, k: &Q) -> Option<&'a V>\n-    {\n+    fn find_equiv<'a, Q:Hash + Equiv<K>>(&'a self, k: &Q) -> Option<&'a V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n }\n \n-impl<K:Hash + IterBytes + Eq,V:Eq> Eq for HashMap<K, V> {\n+impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n@@ -724,31 +718,31 @@ pub struct HashSet<T> {\n     priv map: HashMap<T, ()>\n }\n \n-impl<T:Hash + IterBytes + Eq> BaseIter<T> for HashSet<T> {\n+impl<T:Hash + Eq> BaseIter<T> for HashSet<T> {\n     /// Visit all values in order\n     fn each(&self, f: &fn(&T) -> bool) { self.map.each_key(f) }\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T:Hash + IterBytes + Eq> Eq for HashSet<T> {\n+impl<T:Hash + Eq> Eq for HashSet<T> {\n     fn eq(&self, other: &HashSet<T>) -> bool { self.map == other.map }\n     fn ne(&self, other: &HashSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T:Hash + IterBytes + Eq> Container for HashSet<T> {\n+impl<T:Hash + Eq> Container for HashSet<T> {\n     /// Return the number of elements in the set\n     fn len(&const self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     fn is_empty(&const self) -> bool { self.map.is_empty() }\n }\n \n-impl<T:Hash + IterBytes + Eq> Mutable for HashSet<T> {\n+impl<T:Hash + Eq> Mutable for HashSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Hash + IterBytes + Eq> Set<T> for HashSet<T> {\n+impl<T:Hash + Eq> Set<T> for HashSet<T> {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool { self.map.contains_key(value) }\n \n@@ -816,7 +810,7 @@ impl<T:Hash + IterBytes + Eq> Set<T> for HashSet<T> {\n     }\n }\n \n-pub impl <T:Hash + IterBytes + Eq> HashSet<T> {\n+pub impl <T:Hash + Eq> HashSet<T> {\n     /// Create an empty HashSet\n     fn new() -> HashSet<T> {\n         HashSet::with_capacity(INITIAL_CAPACITY)"}, {"sha": "945d08323b4e5360b8863e19e90e6e815b7fe652", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -1097,9 +1097,12 @@ pub mod funcs {\n                 unsafe fn setbuf(stream: *FILE, buf: *c_char);\n                 // Omitted: printf and scanf variants.\n                 unsafe fn fgetc(stream: *FILE) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn fgets(buf: *mut c_char, n: c_int,\n                          stream: *FILE) -> *c_char;\n+                #[fast_ffi]\n                 unsafe fn fputc(c: c_int, stream: *FILE) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn fputs(s: *c_char, stream: *FILE) -> *c_char;\n                 // Omitted: getc, getchar (might be macros).\n \n@@ -1263,6 +1266,7 @@ pub mod funcs {\n                 unsafe fn pclose(stream: *FILE) -> c_int;\n \n                 #[link_name = \"_fdopen\"]\n+                #[fast_ffi]\n                 unsafe fn fdopen(fd: c_int, mode: *c_char) -> *FILE;\n \n                 #[link_name = \"_fileno\"]"}, {"sha": "e170d85cc716e6d0ef73ac00c6940798984d028c", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -503,4 +503,4 @@ mod tests {\n     fn test_range_step_zero_step() {\n         for range_step(0,10,0) |_i| {}\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "0fb6ea614d8614f9e57d264e1d3137257f56cf19", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -474,4 +474,4 @@ mod tests {\n     fn test_range_step_zero_step_down() {\n         for range_step(0,-10,0) |_i| {}\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "822fb2e476beb2de74b5149a807a9fdd85c1cf07", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -46,7 +46,7 @@ pub use to_str::ToStr;\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};\n pub use vec::{CopyableVector, ImmutableVector};\n pub use vec::{ImmutableEqVector, ImmutableCopyableVector};\n-pub use vec::{OwnedVector, OwnedCopyableVector};\n+pub use vec::{OwnedVector, OwnedCopyableVector, MutableVector};\n pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n \n /* Reexported runtime types */"}, {"sha": "837f9c1a9adeadbb785cc406f94f6eab9b839f26", "filename": "src/libcore/str.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -430,6 +430,15 @@ pub fn byte_slice<T>(s: &str, f: &fn(v: &[u8]) -> T) -> T {\n     }\n }\n \n+/// Work with the string as a byte slice, not including trailing null, without\n+/// a callback.\n+#[inline(always)]\n+pub fn byte_slice_no_callback<'a>(s: &'a str) -> &'a [u8] {\n+    unsafe {\n+        cast::transmute(s)\n+    }\n+}\n+\n /// Convert a string to a unique vector of characters\n pub fn to_chars(s: &str) -> ~[char] {\n     let mut buf = ~[];"}, {"sha": "0d612369cc5c8f3179768a249027a04b83f0af94", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -76,6 +76,7 @@ pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n  * * v - A vector\n  * * n - The number of elements to reserve space for\n  */\n+#[inline]\n pub fn reserve<T>(v: &mut ~[T], n: uint) {\n     // Only make the (slow) call into the runtime if we have to\n     use managed;\n@@ -1831,6 +1832,7 @@ pub trait ImmutableVector<T> {\n     fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+    unsafe fn unsafe_ref(&self, index: uint) -> *T;\n }\n \n /// Extension methods for vectors\n@@ -1941,6 +1943,14 @@ impl<'self,T> ImmutableVector<T> for &'self [T] {\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n         filter_mapped(*self, f)\n     }\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    #[inline(always)]\n+    unsafe fn unsafe_ref(&self, index: uint) -> *T {\n+        let (ptr, _): (*T, uint) = transmute(*self);\n+        ptr.offset(index)\n+    }\n }\n \n #[cfg(stage1)]\n@@ -2178,9 +2188,8 @@ impl<'self,T:Copy> ImmutableCopyableVector<T> for &'self [T] {\n \n     /// Returns the element at the given index, without doing bounds checking.\n     #[inline(always)]\n-    unsafe fn unsafe_get(&self, elem: uint) -> T {\n-        let (ptr, _): (*T, uint) = transmute(*self);\n-        *ptr.offset(elem)\n+    unsafe fn unsafe_get(&self, index: uint) -> T {\n+        *self.unsafe_ref(index)\n     }\n }\n \n@@ -2323,15 +2332,21 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n }\n \n pub trait MutableVector<T> {\n-    unsafe fn unsafe_set(&self, elem: uint, val: T);\n+    unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n+    unsafe fn unsafe_set(&self, index: uint, val: T);\n }\n \n impl<'self,T> MutableVector<T> for &'self mut [T] {\n     #[inline(always)]\n-    unsafe fn unsafe_set(&self, elem: uint, val: T) {\n+    unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n         let pair_ptr: &(*mut T, uint) = transmute(self);\n         let (ptr, _) = *pair_ptr;\n-        *ptr.offset(elem) = val;\n+        ptr.offset(index)\n+    }\n+\n+    #[inline(always)]\n+    unsafe fn unsafe_set(&self, index: uint, val: T) {\n+        *self.unsafe_mut_ref(index) = val;\n     }\n }\n "}, {"sha": "eb7965e1ac6dd32f6bb04effc80f4a0699711a60", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -188,8 +188,10 @@ pub mod write {\n         return false;\n     }\n \n-    pub fn run_passes(sess: Session, llmod: ModuleRef,\n-            output_type: output_type, output: &Path) {\n+    pub fn run_passes(sess: Session,\n+                      llmod: ModuleRef,\n+                      output_type: output_type,\n+                      output: &Path) {\n         unsafe {\n             let opts = sess.opts;\n             if sess.time_llvm_passes() { llvm::LLVMRustEnableTimePasses(); }"}, {"sha": "e897b4e10471b205cc25333f2ecfd78abf359027", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 206, "deletions": 101, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -136,13 +136,17 @@ pub fn log_fn_time(ccx: @CrateContext, +name: ~str, start: time::Timespec,\n     ccx.stats.fn_times.push((name, elapsed));\n }\n \n-pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n-               llty: TypeRef) -> ValueRef {\n+pub fn decl_fn(llmod: ModuleRef,\n+               name: &str,\n+               cc: lib::llvm::CallConv,\n+               llty: TypeRef)\n+               -> ValueRef {\n     let llfn: ValueRef = str::as_c_str(name, |buf| {\n         unsafe {\n             llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n         }\n     });\n+\n     lib::llvm::SetFunctionCallConv(llfn, cc);\n     return llfn;\n }\n@@ -478,29 +482,42 @@ pub fn note_unique_llvm_symbol(ccx: @CrateContext, sym: @~str) {\n }\n \n \n-pub fn get_res_dtor(ccx: @CrateContext, did: ast::def_id,\n-                    parent_id: ast::def_id, substs: &[ty::t])\n-   -> ValueRef {\n+pub fn get_res_dtor(ccx: @CrateContext,\n+                    did: ast::def_id,\n+                    parent_id: ast::def_id,\n+                    substs: &[ty::t])\n+                 -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"trans_res_dtor\");\n     if !substs.is_empty() {\n         let did = if did.crate != ast::local_crate {\n             inline::maybe_instantiate_inline(ccx, did, true)\n-        } else { did };\n+        } else {\n+            did\n+        };\n         assert!(did.crate == ast::local_crate);\n-        let (val, _) =\n-            monomorphize::monomorphic_fn(ccx, did, substs, None, None, None);\n+        let (val, _) = monomorphize::monomorphic_fn(ccx,\n+                                                    did,\n+                                                    substs,\n+                                                    None,\n+                                                    None,\n+                                                    None);\n \n         val\n     } else if did.crate == ast::local_crate {\n         get_item_val(ccx, did.node)\n     } else {\n         let tcx = ccx.tcx;\n         let name = csearch::get_symbol(ccx.sess.cstore, did);\n-        let class_ty = ty::subst_tps(tcx, substs, None,\n-                          ty::lookup_item_type(tcx, parent_id).ty);\n+        let class_ty = ty::subst_tps(tcx,\n+                                     substs,\n+                                     None,\n+                                     ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n         let name = name.to_managed(); // :-(\n-        get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n+        get_extern_fn(ccx.externs,\n+                      ccx.llmod,\n+                      name,\n+                      lib::llvm::CCallConv,\n                       llty)\n     }\n }\n@@ -804,9 +821,12 @@ pub fn trans_external_path(ccx: @CrateContext, did: ast::def_id, t: ty::t)\n     };\n }\n \n-pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n+pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef])\n+           -> (ValueRef, block) {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n-    if bcx.unreachable { return bcx; }\n+    if bcx.unreachable {\n+        return (C_null(T_i8()), bcx);\n+    }\n \n     match bcx.node_info {\n         None => debug!(\"invoke at ???\"),\n@@ -826,8 +846,12 @@ pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n             }\n         }\n         let normal_bcx = sub_block(bcx, ~\"normal return\");\n-        Invoke(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n-        return normal_bcx;\n+        let llresult = Invoke(bcx,\n+                              llfn,\n+                              llargs,\n+                              normal_bcx.llbb,\n+                              get_landing_pad(bcx));\n+        return (llresult, normal_bcx);\n     } else {\n         unsafe {\n             debug!(\"calling %x at %x\",\n@@ -837,8 +861,8 @@ pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n                 debug!(\"arg: %x\", ::core::cast::transmute(llarg));\n             }\n         }\n-        Call(bcx, llfn, llargs);\n-        return bcx;\n+        let llresult = Call(bcx, llfn, llargs);\n+        return (llresult, bcx);\n     }\n }\n \n@@ -1568,6 +1592,18 @@ pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n     }\n }\n \n+// Creates and returns space for, or returns the argument representing, the\n+// slot where the return value of the function must go.\n+pub fn make_return_pointer(fcx: fn_ctxt, output_type: ty::t) -> ValueRef {\n+    unsafe {\n+        if !ty::type_is_immediate(output_type) {\n+            llvm::LLVMGetParam(fcx.llfn, 0)\n+        } else {\n+            let lloutputtype = type_of::type_of(*fcx.ccx, output_type);\n+            alloca(raw_block(fcx, false, fcx.llstaticallocas), lloutputtype)\n+        }\n+    }\n+}\n \n // NB: must keep 4 fns in sync:\n //\n@@ -1579,10 +1615,11 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n                         +path: path,\n                         llfndecl: ValueRef,\n                         id: ast::node_id,\n+                        output_type: ty::t,\n                         impl_id: Option<ast::def_id>,\n                         param_substs: Option<@param_substs>,\n-                        sp: Option<span>) -> fn_ctxt\n-{\n+                        sp: Option<span>)\n+                     -> fn_ctxt {\n     for param_substs.each |p| { p.validate(); }\n \n     debug!(\"new_fn_ctxt_w_id(path=%s, id=%?, impl_id=%?, \\\n@@ -1593,16 +1630,26 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n            param_substs.repr(ccx.tcx));\n \n     let llbbs = mk_standard_basic_blocks(llfndecl);\n-    return @mut fn_ctxt_ {\n+\n+    let substd_output_type = match param_substs {\n+        None => output_type,\n+        Some(substs) => {\n+            ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n+        }\n+    };\n+    let is_immediate = ty::type_is_immediate(substd_output_type);\n+\n+    let fcx = @mut fn_ctxt_ {\n           llfn: llfndecl,\n           llenv: unsafe { llvm::LLVMGetParam(llfndecl, 1u as c_uint) },\n-          llretptr: unsafe { llvm::LLVMGetParam(llfndecl, 0u as c_uint) },\n+          llretptr: None,\n           llstaticallocas: llbbs.sa,\n           llloadenv: None,\n           llreturn: llbbs.rt,\n           llself: None,\n           personality: None,\n           loop_ret: None,\n+          has_immediate_return_value: is_immediate,\n           llargs: @mut HashMap::new(),\n           lllocals: @mut HashMap::new(),\n           llupvars: @mut HashMap::new(),\n@@ -1613,14 +1660,18 @@ pub fn new_fn_ctxt_w_id(ccx: @CrateContext,\n           path: path,\n           ccx: @ccx\n     };\n+\n+    fcx.llretptr = Some(make_return_pointer(fcx, substd_output_type));\n+    fcx\n }\n \n pub fn new_fn_ctxt(ccx: @CrateContext,\n                    +path: path,\n                    llfndecl: ValueRef,\n+                   output_type: ty::t,\n                    sp: Option<span>)\n                 -> fn_ctxt {\n-    return new_fn_ctxt_w_id(ccx, path, llfndecl, -1, None, None, sp);\n+    new_fn_ctxt_w_id(ccx, path, llfndecl, -1, output_type, None, None, sp)\n }\n \n // NB: must keep 4 fns in sync:\n@@ -1639,7 +1690,8 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // field of the fn_ctxt with\n pub fn create_llargs_for_fn_args(cx: fn_ctxt,\n                                  ty_self: self_arg,\n-                                 args: &[ast::arg]) -> ~[ValueRef] {\n+                                 args: &[ast::arg])\n+                              -> ~[ValueRef] {\n     let _icx = cx.insn_ctxt(\"create_llargs_for_fn_args\");\n \n     match ty_self {\n@@ -1745,8 +1797,19 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n pub fn finish_fn(fcx: fn_ctxt, lltop: BasicBlockRef) {\n     let _icx = fcx.insn_ctxt(\"finish_fn\");\n     tie_up_header_blocks(fcx, lltop);\n+    build_return_block(fcx);\n+}\n+\n+// Builds the return block for a function.\n+pub fn build_return_block(fcx: fn_ctxt) {\n     let ret_cx = raw_block(fcx, false, fcx.llreturn);\n-    RetVoid(ret_cx);\n+\n+    // Return the value if this function immediate; otherwise, return void.\n+    if fcx.has_immediate_return_value {\n+        Ret(ret_cx, Load(ret_cx, fcx.llretptr.get()))\n+    } else {\n+        RetVoid(ret_cx)\n+    }\n }\n \n pub fn tie_up_header_blocks(fcx: fn_ctxt, lltop: BasicBlockRef) {\n@@ -1777,6 +1840,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                      id: ast::node_id,\n                      impl_id: Option<ast::def_id>,\n                      attributes: &[ast::attribute],\n+                     output_type: ty::t,\n                      maybe_load_env: &fn(fn_ctxt),\n                      finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n@@ -1791,6 +1855,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                                path,\n                                llfndecl,\n                                id,\n+                               output_type,\n                                impl_id,\n                                param_substs,\n                                Some(body.span));\n@@ -1833,7 +1898,8 @@ pub fn trans_closure(ccx: @CrateContext,\n     {\n         bcx = controlflow::trans_block(bcx, body, expr::Ignore);\n     } else {\n-        bcx = controlflow::trans_block(bcx, body, expr::SaveIn(fcx.llretptr));\n+        let dest = expr::SaveIn(fcx.llretptr.get());\n+        bcx = controlflow::trans_block(bcx, body, dest);\n     }\n \n     finish(bcx);\n@@ -1864,6 +1930,7 @@ pub fn trans_fn(ccx: @CrateContext,\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     let the_path_str = path_str(ccx.sess, path);\n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, id));\n     trans_closure(ccx,\n                   path,\n                   decl,\n@@ -1874,6 +1941,7 @@ pub fn trans_fn(ccx: @CrateContext,\n                   id,\n                   impl_id,\n                   attrs,\n+                  output_type,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo {\n                           debuginfo::create_function(fcx);\n@@ -1907,26 +1975,39 @@ pub fn trans_enum_variant(ccx: @CrateContext,\n             id: varg.id,\n         }\n     };\n-    let fcx = new_fn_ctxt_w_id(ccx, ~[], llfndecl, variant.node.id, None,\n-                               param_substs, None);\n-    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n+\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => { copy substs.tys }\n         None => ~[]\n     };\n+    let enum_ty = ty::subst_tps(ccx.tcx,\n+                                ty_param_substs,\n+                                None,\n+                                ty::node_id_to_type(ccx.tcx, enum_id));\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               ~[],\n+                               llfndecl,\n+                               variant.node.id,\n+                               enum_ty,\n+                               None,\n+                               param_substs,\n+                               None);\n+\n+    let raw_llargs = create_llargs_for_fn_args(fcx, no_self, fn_args);\n     let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, variant.node.id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n     // XXX is there a better way to reconstruct the ty::t?\n-    let enum_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n-                                ty::node_id_to_type(ccx.tcx, enum_id));\n     let repr = adt::represent_type(ccx, enum_ty);\n \n-    adt::trans_start_init(bcx, repr, fcx.llretptr, disr);\n+    adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n     for vec::eachi(args) |i, va| {\n-        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr,\n-                                             disr, i);\n+        let lldestptr = adt::trans_field_ptr(bcx,\n+                                             repr,\n+                                             fcx.llretptr.get(),\n+                                             disr,\n+                                             i);\n \n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n@@ -1964,10 +2045,25 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n         }\n     };\n \n+    // XXX is there a better way to reconstruct the ty::t?\n+    let ty_param_substs = match param_substs {\n+        Some(ref substs) => { copy substs.tys }\n+        None => ~[]\n+    };\n+    let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n+                                ty::node_id_to_type(ccx.tcx, ctor_id));\n+    let tup_ty = match ty::get(ctor_ty).sty {\n+        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n+                                return type %s\",\n+                               ty_to_str(ccx.tcx, ctor_ty)))\n+    };\n+\n     let fcx = new_fn_ctxt_w_id(ccx,\n                                ~[],\n                                llfndecl,\n                                ctor_id,\n+                               tup_ty,\n                                None,\n                                param_substs,\n                                None);\n@@ -1979,23 +2075,14 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, ctor_id));\n     let bcx = copy_args_to_allocas(fcx, bcx, fn_args, raw_llargs, arg_tys);\n \n-    // XXX is there a better way to reconstruct the ty::t?\n-    let ty_param_substs = match param_substs {\n-        Some(ref substs) => { copy substs.tys }\n-        None => ~[]\n-    };\n-    let ctor_ty = ty::subst_tps(ccx.tcx, ty_param_substs, None,\n-                                ty::node_id_to_type(ccx.tcx, ctor_id));\n-    let tup_ty = match ty::get(ctor_ty).sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output,\n-        _ => ccx.sess.bug(fmt!(\"trans_tuple_struct: unexpected ctor \\\n-                                return type %s\",\n-                               ty_to_str(ccx.tcx, ctor_ty)))\n-    };\n     let repr = adt::represent_type(ccx, tup_ty);\n \n     for fields.eachi |i, field| {\n-        let lldestptr = adt::trans_field_ptr(bcx, repr, fcx.llretptr, 0, i);\n+        let lldestptr = adt::trans_field_ptr(bcx,\n+                                             repr,\n+                                             fcx.llretptr.get(),\n+                                             0,\n+                                             i);\n         let llarg = match *fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n@@ -2095,10 +2182,12 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n-                                     vec::append(\n-                                         /*bad*/copy *path,\n-                                         ~[path_name(item.ident)]),\n-                                      decl, body, llfndecl, item.id);\n+                                      vec::append(/*bad*/copy *path,\n+                                                  ~[path_name(item.ident)]),\n+                                      decl,\n+                                      body,\n+                                      llfndecl,\n+                                      item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n@@ -2215,7 +2304,7 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n                           llfty: TypeRef)\n-                       -> ValueRef {\n+                          -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n            ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n@@ -2235,7 +2324,9 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n                      (!*ccx.sess.building_library ||\n                       (*ccx.sess.building_library &&\n                        ccx.sess.targ_cfg.os == session::os_android));\n-    if is_entry { create_entry_wrapper(ccx, sp, llfn); }\n+    if is_entry {\n+        create_entry_wrapper(ccx, sp, llfn);\n+    }\n     llfn\n }\n \n@@ -2264,23 +2355,26 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(ccx, ~[], llfdecl, None);\n+        let fcx = new_fn_ctxt(ccx, ~[], llfdecl, nt, None);\n \n         let bcx = top_scope_block(fcx, None);\n         let lltop = bcx.llbb;\n \n         // Call main.\n-        let lloutputarg = unsafe { llvm::LLVMGetParam(llfdecl, 0 as c_uint) };\n+        let lloutputarg = C_null(T_ptr(T_i8()));\n         let llenvarg = unsafe { llvm::LLVMGetParam(llfdecl, 1 as c_uint) };\n         let mut args = ~[lloutputarg, llenvarg];\n-        Call(bcx, main_llfn, args);\n+        let llresult = Call(bcx, main_llfn, args);\n+        Store(bcx, llresult, fcx.llretptr.get());\n \n         build_return(bcx);\n         finish_fn(fcx, lltop);\n         return llfdecl;\n     }\n \n-    fn create_entry_fn(ccx: @CrateContext, rust_main: ValueRef, use_start_lang_item:bool) {\n+    fn create_entry_fn(ccx: @CrateContext,\n+                       rust_main: ValueRef,\n+                       use_start_lang_item: bool) {\n         let llfty = T_fn(~[ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n@@ -2301,58 +2395,70 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n         let bld = ccx.builder.B;\n         unsafe {\n             llvm::LLVMPositionBuilderAtEnd(bld, llbb);\n-        }\n-\n-        let retptr = unsafe {\n-            llvm::LLVMBuildAlloca(bld, ccx.int_type, noname())\n-        };\n \n-        let crate_map = ccx.crate_map;\n-        let opaque_crate_map = unsafe {llvm::LLVMBuildPointerCast(\n-                bld, crate_map, T_ptr(T_i8()), noname())};\n-\n-        let (start_fn, args) = if use_start_lang_item {\n+            let crate_map = ccx.crate_map;\n             let start_def_id = ccx.tcx.lang_items.start_fn();\n             let start_fn = if start_def_id.crate == ast::local_crate {\n                 ccx.sess.bug(~\"start lang item is never in the local crate\")\n             } else {\n                 let start_fn_type = csearch::get_type(ccx.tcx,\n-                        start_def_id).ty;\n+                                                      start_def_id).ty;\n                 trans_external_path(ccx, start_def_id, start_fn_type)\n             };\n \n-            let args = unsafe {\n-                let opaque_rust_main = llvm::LLVMBuildPointerCast(\n-                        bld, rust_main, T_ptr(T_i8()), noname());\n-\n-                ~[\n-                    retptr,\n-                    C_null(T_opaque_box_ptr(ccx)),\n-                    opaque_rust_main,\n-                    llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                    llvm::LLVMGetParam(llfn, 1 as c_uint),\n-                    opaque_crate_map\n-                 ]\n-            };\n-            (start_fn, args)\n-        } else {\n-            debug!(\"using user-defined start fn\");\n-            let args = unsafe {\n-                ~[ retptr,\n-                   C_null(T_opaque_box_ptr(ccx)),\n-                   llvm::LLVMGetParam(llfn, 0 as c_uint),\n-                   llvm::LLVMGetParam(llfn, 1 as c_uint),\n-                   opaque_crate_map\n-                ]\n-            };\n+            let retptr = llvm::LLVMBuildAlloca(bld, T_i8(), noname());\n \n-            (rust_main, args)\n-        };\n+            let crate_map = ccx.crate_map;\n+            let opaque_crate_map = llvm::LLVMBuildPointerCast(bld,\n+                                                              crate_map,\n+                                                              T_ptr(T_i8()),\n+                                                              noname());\n \n-        unsafe {\n-            llvm::LLVMBuildCall(bld, start_fn, vec::raw::to_ptr(args),\n-                                args.len() as c_uint, noname());\n-            let result = llvm::LLVMBuildLoad(bld, retptr, noname());\n+            let (start_fn, args) = if use_start_lang_item {\n+                let start_def_id = ccx.tcx.lang_items.start_fn();\n+                let start_fn = if start_def_id.crate == ast::local_crate {\n+                    ccx.sess.bug(~\"start lang item is never in the local \\\n+                                   crate\")\n+                } else {\n+                    let start_fn_type = csearch::get_type(ccx.tcx,\n+                            start_def_id).ty;\n+                    trans_external_path(ccx, start_def_id, start_fn_type)\n+                };\n+\n+                let args = {\n+                    let opaque_rust_main = llvm::LLVMBuildPointerCast(\n+                            bld, rust_main, T_ptr(T_i8()), noname());\n+\n+                    ~[\n+                        retptr,\n+                        C_null(T_opaque_box_ptr(ccx)),\n+                        opaque_rust_main,\n+                        llvm::LLVMGetParam(llfn, 0),\n+                        llvm::LLVMGetParam(llfn, 1),\n+                        opaque_crate_map\n+                     ]\n+                };\n+                (start_fn, args)\n+            } else {\n+                debug!(\"using user-defined start fn\");\n+                let args = {\n+                    ~[\n+                        retptr,\n+                        C_null(T_opaque_box_ptr(ccx)),\n+                        llvm::LLVMGetParam(llfn, 0 as c_uint),\n+                        llvm::LLVMGetParam(llfn, 1 as c_uint),\n+                        opaque_crate_map\n+                    ]\n+                };\n+\n+                (rust_main, args)\n+            };\n+\n+            let result = llvm::LLVMBuildCall(bld,\n+                                             start_fn,\n+                                             &args[0],\n+                                             args.len() as c_uint,\n+                                             noname());\n             llvm::LLVMBuildRet(bld, result);\n         }\n     }\n@@ -2423,7 +2529,6 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n     match ccx.item_vals.find(&id) {\n       Some(&v) => v,\n       None => {\n-\n         let mut exprt = false;\n         let val = match *ccx.tcx.items.get(&id) {\n           ast_map::node_item(i, pth) => {\n@@ -2515,10 +2620,10 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             assert!(!ty::type_has_params(class_ty));\n             let lldty = unsafe {\n                 T_fn(~[\n-                    T_ptr(type_of(ccx, ty::mk_nil(tcx))),\n+                    T_ptr(T_i8()),\n                     T_ptr(type_of(ccx, class_ty))\n                 ],\n-                llvm::LLVMVoidType())\n+                T_nil())\n             };\n             let s = get_dtor_symbol(ccx, /*bad*/copy *pt, dt.node.id, None);\n "}, {"sha": "fe2461632ad76bddb41294efbf32b329a6da8cfd", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -181,9 +181,15 @@ pub fn noname() -> *libc::c_char {\n     }\n }\n \n-pub fn Invoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n-              Then: BasicBlockRef, Catch: BasicBlockRef) {\n-    if cx.unreachable { return; }\n+pub fn Invoke(cx: block,\n+              Fn: ValueRef,\n+              Args: &[ValueRef],\n+              Then: BasicBlockRef,\n+              Catch: BasicBlockRef)\n+           -> ValueRef {\n+    if cx.unreachable {\n+        return C_null(T_i8());\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Invoke\");\n     debug!(\"Invoke(%s with arguments (%s))\",\n@@ -193,9 +199,13 @@ pub fn Invoke(cx: block, Fn: ValueRef, Args: &[ValueRef],\n                         ~\", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::raw::to_ptr(Args),\n-                              Args.len() as c_uint, Then, Catch,\n-                              noname());\n+        llvm::LLVMBuildInvoke(B(cx),\n+                              Fn,\n+                              vec::raw::to_ptr(Args),\n+                              Args.len() as c_uint,\n+                              Then,\n+                              Catch,\n+                              noname())\n     }\n }\n "}, {"sha": "41b812c8e14d793e8db3c5dc76f98271819c7f45", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -13,6 +13,7 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n \n+use core::io::println;\n use core::libc::c_uint;\n use core::option;\n use core::vec;\n@@ -92,16 +93,19 @@ pub impl FnType {\n         return llargvals;\n     }\n \n-    fn build_shim_ret(&self, bcx: block,\n-                      arg_tys: &[TypeRef], ret_def: bool,\n-                      llargbundle: ValueRef, llretval: ValueRef) {\n+    fn build_shim_ret(&self,\n+                      bcx: block,\n+                      arg_tys: &[TypeRef],\n+                      ret_def: bool,\n+                      llargbundle: ValueRef,\n+                      llretval: ValueRef) {\n         for vec::eachi(self.attrs) |i, a| {\n             match *a {\n                 option::Some(attr) => {\n                     unsafe {\n-                        llvm::LLVMAddInstrAttribute(\n-                            llretval, (i + 1u) as c_uint,\n-                                        attr as c_uint);\n+                        llvm::LLVMAddInstrAttribute(llretval,\n+                                                    (i + 1u) as c_uint,\n+                                                    attr as c_uint);\n                     }\n                 }\n                 _ => ()\n@@ -125,8 +129,11 @@ pub impl FnType {\n         };\n     }\n \n-    fn build_wrap_args(&self, bcx: block, ret_ty: TypeRef,\n-                       llwrapfn: ValueRef, llargbundle: ValueRef) {\n+    fn build_wrap_args(&self,\n+                       bcx: block,\n+                       ret_ty: TypeRef,\n+                       llwrapfn: ValueRef,\n+                       llargbundle: ValueRef) {\n         let mut atys = /*bad*/copy self.arg_tys;\n         let mut attrs = /*bad*/copy self.attrs;\n         let mut j = 0u;\n@@ -161,22 +168,27 @@ pub impl FnType {\n         store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n     }\n \n-    fn build_wrap_ret(&self, bcx: block,\n-                      arg_tys: &[TypeRef], llargbundle: ValueRef) {\n+    fn build_wrap_ret(&self,\n+                      bcx: block,\n+                      arg_tys: &[TypeRef],\n+                      llargbundle: ValueRef) {\n         unsafe {\n             if llvm::LLVMGetTypeKind(self.ret_ty.ty) == Void {\n-                RetVoid(bcx);\n                 return;\n             }\n         }\n-        let n = vec::len(arg_tys);\n-        let llretval = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+\n+        let llretval = load_inbounds(bcx, llargbundle, ~[ 0, arg_tys.len() ]);\n         let llretval = if self.ret_ty.cast {\n             let retptr = BitCast(bcx, llretval, T_ptr(self.ret_ty.ty));\n             Load(bcx, retptr)\n         } else {\n             Load(bcx, llretval)\n         };\n-        Ret(bcx, llretval);\n+        let llretptr = BitCast(bcx,\n+                               bcx.fcx.llretptr.get(),\n+                               T_ptr(self.ret_ty.ty));\n+        Store(bcx, llretval, llretptr);\n     }\n }\n+"}, {"sha": "88d185740298f2c3980e3f1ebe5145d1439e868e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 53, "deletions": 24, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -314,19 +314,24 @@ pub fn trans_call(in_cx: block,\n                   args: CallArgs,\n                   id: ast::node_id,\n                   dest: expr::Dest)\n-               -> block {\n+                  -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_call\");\n-    trans_call_inner(\n-        in_cx, call_ex.info(), expr_ty(in_cx, f), node_id_type(in_cx, id),\n-        |cx| trans(cx, f), args, dest, DontAutorefArg)\n+    trans_call_inner(in_cx,\n+                     call_ex.info(),\n+                     expr_ty(in_cx, f),\n+                     node_id_type(in_cx, id),\n+                     |cx| trans(cx, f),\n+                     args,\n+                     dest,\n+                     DontAutorefArg)\n }\n \n pub fn trans_method_call(in_cx: block,\n                          call_ex: @ast::expr,\n                          rcvr: @ast::expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n-                      -> block {\n+                         -> block {\n     let _icx = in_cx.insn_ctxt(\"trans_method_call\");\n     debug!(\"trans_method_call(call_ex=%s, rcvr=%s)\",\n            call_ex.repr(in_cx.tcx()),\n@@ -439,15 +444,15 @@ pub fn body_contains_ret(body: &ast::blk) -> bool {\n }\n \n // See [Note-arg-mode]\n-pub fn trans_call_inner(\n-    ++in_cx: block,\n-    call_info: Option<NodeInfo>,\n-    fn_expr_ty: ty::t,\n-    ret_ty: ty::t,\n-    get_callee: &fn(block) -> Callee,\n-    args: CallArgs,\n-    dest: expr::Dest,\n-    autoref_arg: AutorefArg) -> block {\n+pub fn trans_call_inner(++in_cx: block,\n+                        call_info: Option<NodeInfo>,\n+                        fn_expr_ty: ty::t,\n+                        ret_ty: ty::t,\n+                        get_callee: &fn(block) -> Callee,\n+                        args: CallArgs,\n+                        dest: expr::Dest,\n+                        autoref_arg: AutorefArg)\n+                        -> block {\n     do base::with_scope(in_cx, call_info, ~\"call\") |cx| {\n         let ret_in_loop = match args {\n           ArgExprs(args) => {\n@@ -500,7 +505,15 @@ pub fn trans_call_inner(\n         let llretslot = trans_ret_slot(bcx, fn_expr_ty, dest);\n \n         let mut llargs = ~[];\n-        llargs.push(llretslot);\n+\n+        if ty::type_is_immediate(ret_ty) {\n+            unsafe {\n+                llargs.push(llvm::LLVMGetUndef(T_ptr(T_i8())));\n+            }\n+        } else {\n+            llargs.push(llretslot);\n+        }\n+\n         llargs.push(llenv);\n         bcx = trans_args(bcx, args, fn_expr_ty,\n                          ret_flag, autoref_arg, &mut llargs);\n@@ -527,25 +540,42 @@ pub fn trans_call_inner(\n         // If the block is terminated, then one or more of the args\n         // has type _|_. Since that means it diverges, the code for\n         // the call itself is unreachable.\n-        bcx = base::invoke(bcx, llfn, llargs);\n-        match dest { // drop the value if it is not being saved.\n+        let (llresult, new_bcx) = base::invoke(bcx, llfn, llargs);\n+        bcx = new_bcx;\n+\n+        match dest {\n             expr::Ignore => {\n+                // drop the value if it is not being saved.\n                 unsafe {\n                     if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n-                        bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                        if ty::type_is_immediate(ret_ty) {\n+                            let llscratchptr = alloc_ty(bcx, ret_ty);\n+                            Store(bcx, llresult, llscratchptr);\n+                            bcx = glue::drop_ty(bcx, llscratchptr, ret_ty);\n+                        } else {\n+                            bcx = glue::drop_ty(bcx, llretslot, ret_ty);\n+                        }\n                     }\n                 }\n             }\n-            expr::SaveIn(_) => { }\n+            expr::SaveIn(lldest) => {\n+                // If this is an immediate, store into the result location.\n+                // (If this was not an immediate, the result will already be\n+                // directly written into the output slot.)\n+                if ty::type_is_immediate(ret_ty) {\n+                    Store(bcx, llresult, lldest);\n+                }\n+            }\n         }\n+\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n             let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 for (copy bcx.fcx.loop_ret).each |&(flagptr, _)| {\n                     Store(bcx, C_bool(true), flagptr);\n-                    Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+                    Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n                 }\n                 base::cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n                 Unreachable(bcx);\n@@ -562,11 +592,10 @@ pub enum CallArgs<'self> {\n     ArgVals(&'self [ValueRef])\n }\n \n-pub fn trans_ret_slot(+bcx: block,\n-                      +fn_ty: ty::t,\n-                      +dest: expr::Dest) -> ValueRef\n-{\n+pub fn trans_ret_slot(+bcx: block, +fn_ty: ty::t, +dest: expr::Dest)\n+                      -> ValueRef {\n     let retty = ty::ty_fn_ret(fn_ty);\n+\n     match dest {\n         expr::SaveIn(dst) => dst,\n         expr::Ignore => {"}, {"sha": "cb815506c39d20c13c479a071ebfa38156067991", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -299,7 +299,7 @@ pub fn build_closure(bcx0: block,\n         // the right thing):\n         let ret_true = match bcx.fcx.loop_ret {\n             Some((_, retptr)) => retptr,\n-            None => bcx.fcx.llretptr\n+            None => bcx.fcx.llretptr.get()\n         };\n         let ret_casted = PointerCast(bcx, ret_true, T_ptr(T_nil()));\n         let ret_datum = Datum {val: ret_casted, ty: ty::mk_nil(tcx),\n@@ -367,8 +367,7 @@ pub fn trans_expr_fn(bcx: block,\n                      outer_id: ast::node_id,\n                      user_id: ast::node_id,\n                      is_loop_body: Option<Option<ValueRef>>,\n-                     dest: expr::Dest) -> block\n-{\n+                     dest: expr::Dest) -> block {\n     /*!\n      *\n      * Translates the body of a closure expression.\n@@ -400,7 +399,9 @@ pub fn trans_expr_fn(bcx: block,\n \n     let ccx = bcx.ccx();\n     let fty = node_id_type(bcx, outer_id);\n+\n     let llfnty = type_of_fn_from_ty(ccx, fty);\n+\n     let sub_path = vec::append_one(/*bad*/copy bcx.fcx.path,\n                                    path_name(special_idents::anon));\n     // XXX: Bad copy.\n@@ -418,6 +419,12 @@ pub fn trans_expr_fn(bcx: block,\n         set_inline_hint(llfn);\n     }\n \n+    let real_return_type = if is_loop_body.is_some() {\n+        ty::mk_bool(bcx.tcx())\n+    } else {\n+        ty::ty_fn_ret(fty)\n+    };\n+\n     let Result {bcx: bcx, val: closure} = match sigil {\n         ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n             let cap_vars = *ccx.maps.capture_map.get(&user_id);\n@@ -435,11 +442,14 @@ pub fn trans_expr_fn(bcx: block,\n                           user_id,\n                           None,\n                           [],\n+                          real_return_type,\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars,\n                                                  ret_handle.is_some(), sigil),\n                           |bcx| {\n                               if is_loop_body.is_some() {\n-                                  Store(bcx, C_bool(true), bcx.fcx.llretptr);\n+                                  Store(bcx,\n+                                        C_bool(true),\n+                                        bcx.fcx.llretptr.get());\n                               }\n                           });\n             rslt(bcx, llbox)"}, {"sha": "76f0892277e28542e67486c56f950c0a6deb55ee", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -291,10 +291,15 @@ pub struct fn_ctxt_ {\n     // section of the executable we're generating.\n     llfn: ValueRef,\n \n-    // The two implicit arguments that arrive in the function we're creating.\n-    // For instance, foo(int, int) is really foo(ret*, env*, int, int).\n+    // The implicit environment argument that arrives in the function we're\n+    // creating.\n     llenv: ValueRef,\n-    llretptr: ValueRef,\n+\n+    // The place to store the return value. If the return type is immediate,\n+    // this is an alloca in the function. Otherwise, it's the hidden first\n+    // parameter to the function. After function construction, this should\n+    // always be Some.\n+    llretptr: Option<ValueRef>,\n \n     // These elements: \"hoisted basic blocks\" containing\n     // administrative activities that have to happen in only one place in\n@@ -322,6 +327,11 @@ pub struct fn_ctxt_ {\n     // for that (flagptr, retptr)\n     loop_ret: Option<(ValueRef, ValueRef)>,\n \n+    // True if this function has an immediate return value, false otherwise.\n+    // If this is false, the llretptr will alias the first argument of the\n+    // function.\n+    has_immediate_return_value: bool,\n+\n     // Maps arguments to allocas created for them in llallocas.\n     llargs: @mut HashMap<ast::node_id, local_val>,\n     // Maps the def_ids for local variables to the allocas created for"}, {"sha": "69e267744351dc7ec4b8bc5744b808e9999ed496", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -274,7 +274,7 @@ pub fn trans_break_cont(bcx: block,\n           Some(bcx) => bcx,\n           // This is a return from a loop body block\n           None => {\n-            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr);\n+            Store(bcx, C_bool(!to_end), bcx.fcx.llretptr.get());\n             cleanup_and_leave(bcx, None, Some(bcx.fcx.llreturn));\n             Unreachable(bcx);\n             return bcx;\n@@ -303,14 +303,14 @@ pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n         // to false, return flag to true, and then store the value in the\n         // parent's retptr.\n         Store(bcx, C_bool(true), flagptr);\n-        Store(bcx, C_bool(false), bcx.fcx.llretptr);\n+        Store(bcx, C_bool(false), bcx.fcx.llretptr.get());\n         match e {\n           Some(x) => PointerCast(bcx, retptr,\n                                  T_ptr(type_of(bcx.ccx(), expr_ty(bcx, x)))),\n           None => retptr\n         }\n       }\n-      None => bcx.fcx.llretptr\n+      None => bcx.fcx.llretptr.get()\n     };\n     match e {\n       Some(x) => {"}, {"sha": "477065377a5270f131da67ed715b963d001a8024", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -31,7 +31,7 @@\n  * value stored in the datum is indicated in the field `ty`.\n  *\n  * Generally speaking, you probably do not want to access the `val` field\n- * unless you know what mode the value is in.  Intead you should use one\n+ * unless you know what mode the value is in.  Instead you should use one\n  * of the following accessors:\n  *\n  * - `to_value_llval()` converts to by-value"}, {"sha": "21d62f95cc51c8fa020568da4e6ca311bd580dd0", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -624,10 +624,14 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             let sigil = ty::ty_closure_sigil(expr_ty);\n             match blk.node {\n                 ast::expr_fn_block(ref decl, ref body) => {\n-                    return closure::trans_expr_fn(bcx, sigil,\n-                                                  decl, body,\n-                                                  expr.id, blk.id,\n-                                                  Some(None), dest);\n+                    return closure::trans_expr_fn(bcx,\n+                                                  sigil,\n+                                                  decl,\n+                                                  body,\n+                                                  expr.id,\n+                                                  blk.id,\n+                                                  Some(None),\n+                                                  dest);\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n@@ -655,15 +659,30 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_binary(_, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, lhs, ~[rhs], dest);\n+            return trans_overloaded_op(bcx,\n+                                       expr,\n+                                       lhs,\n+                                       ~[rhs],\n+                                       expr_ty(bcx, expr),\n+                                       dest);\n         }\n         ast::expr_unary(_, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, subexpr, ~[], dest);\n+            return trans_overloaded_op(bcx,\n+                                       expr,\n+                                       subexpr,\n+                                       ~[],\n+                                       expr_ty(bcx, expr),\n+                                       dest);\n         }\n         ast::expr_index(base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n-            return trans_overloaded_op(bcx, expr, base, ~[idx], dest);\n+            return trans_overloaded_op(bcx,\n+                                       expr,\n+                                       base,\n+                                       ~[idx],\n+                                       expr_ty(bcx, expr),\n+                                       dest);\n         }\n         ast::expr_cast(val, _) => {\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n@@ -1554,15 +1573,24 @@ fn trans_overloaded_op(bcx: block,\n                        expr: @ast::expr,\n                        rcvr: @ast::expr,\n                        +args: ~[@ast::expr],\n-                       dest: Dest) -> block\n-{\n+                       ret_ty: ty::t,\n+                       dest: Dest)\n+                       -> block {\n     let origin = *bcx.ccx().maps.method_map.get(&expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n-    return callee::trans_call_inner(\n-        bcx, expr.info(), fty,\n-        expr_ty(bcx, expr),\n-        |bcx| meth::trans_method_callee(bcx, expr.callee_id, rcvr, origin),\n-        callee::ArgExprs(args), dest, DoAutorefArg);\n+    callee::trans_call_inner(bcx,\n+                             expr.info(),\n+                             fty,\n+                             ret_ty,\n+                             |bcx| {\n+                                meth::trans_method_callee(bcx,\n+                                                          expr.callee_id,\n+                                                          rcvr,\n+                                                          origin)\n+                             },\n+                             callee::ArgExprs(args),\n+                             dest,\n+                             DoAutorefArg)\n }\n \n fn int_cast(bcx: block, lldsttype: TypeRef, llsrctype: TypeRef,\n@@ -1697,7 +1725,11 @@ fn trans_assign_op(bcx: block,\n     if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n         // FIXME(#2528) evaluates the receiver twice!!\n         let scratch = scratch_datum(bcx, dst_datum.ty, false);\n-        let bcx = trans_overloaded_op(bcx, expr, dst, ~[src],\n+        let bcx = trans_overloaded_op(bcx,\n+                                      expr,\n+                                      dst,\n+                                      ~[src],\n+                                      dst_datum.ty,\n                                       SaveIn(scratch.val));\n         return scratch.move_to_datum(bcx, DROP_EXISTING, dst_datum);\n     }"}, {"sha": "b00f4d8ed42cf9fbc61bea5027170dccb2308327", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 279, "deletions": 166, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -83,10 +83,11 @@ struct ShimTypes {\n struct LlvmSignature {\n     llarg_tys: ~[TypeRef],\n     llret_ty: TypeRef,\n+    sret: bool,\n }\n \n-fn foreign_signature(ccx: @CrateContext,\n-                     fn_sig: &ty::FnSig) -> LlvmSignature {\n+fn foreign_signature(ccx: @CrateContext, fn_sig: &ty::FnSig)\n+                     -> LlvmSignature {\n     /*!\n      * The ForeignSignature is the LLVM types of the arguments/return type\n      * of a function.  Note that these LLVM types are not quite the same\n@@ -97,7 +98,11 @@ fn foreign_signature(ccx: @CrateContext,\n \n     let llarg_tys = fn_sig.inputs.map(|arg| type_of(ccx, arg.ty));\n     let llret_ty = type_of::type_of(ccx, fn_sig.output);\n-    LlvmSignature {llarg_tys: llarg_tys, llret_ty: llret_ty}\n+    LlvmSignature {\n+        llarg_tys: llarg_tys,\n+        llret_ty: llret_ty,\n+        sret: !ty::type_is_immediate(fn_sig.output),\n+    }\n }\n \n fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n@@ -109,20 +114,17 @@ fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n     let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n                                              T_ptr(llsig.llret_ty)),\n                              false);\n-    let ret_def =\n-        !ty::type_is_bot(fn_sig.output) &&\n-        !ty::type_is_nil(fn_sig.output);\n-    let fn_ty =\n-        abi_info(ccx).compute_info(\n-            llsig.llarg_tys,\n-            llsig.llret_ty,\n-            ret_def);\n+    let ret_def = !ty::type_is_bot(fn_sig.output) &&\n+                  !ty::type_is_nil(fn_sig.output);\n+    let fn_ty = abi_info(ccx).compute_info(llsig.llarg_tys,\n+                                           llsig.llret_ty,\n+                                           ret_def);\n     ShimTypes {\n         fn_sig: fn_sig,\n         llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_void()),\n+        shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_nil()),\n         fn_ty: fn_ty\n     }\n }\n@@ -142,13 +144,13 @@ fn build_shim_fn_(ccx: @CrateContext,\n                   tys: &ShimTypes,\n                   cc: lib::llvm::CallConv,\n                   arg_builder: shim_arg_builder,\n-                  ret_builder: shim_ret_builder) -> ValueRef\n-{\n+                  ret_builder: shim_ret_builder)\n+               -> ValueRef {\n     let llshimfn = decl_internal_cdecl_fn(\n         ccx.llmod, shim_name, tys.shim_fn_ty);\n \n     // Declare the body of the shim function:\n-    let fcx = new_fn_ctxt(ccx, ~[], llshimfn, None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llshimfn, tys.fn_sig.output, None);\n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n     let llargbundle = get_param(llshimfn, 0u);\n@@ -159,30 +161,42 @@ fn build_shim_fn_(ccx: @CrateContext,\n \n     ret_builder(bcx, tys, llargbundle, llretval);\n \n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n+    // Don't finish up the function in the usual way, because this doesn't\n+    // follow the normal Rust calling conventions.\n+    tie_up_header_blocks(fcx, lltop);\n+\n+    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n+    Ret(ret_cx, C_null(T_nil()));\n \n     return llshimfn;\n }\n \n-type wrap_arg_builder<'self> =\n-    &'self fn(bcx: block, tys: &ShimTypes,\n-              llwrapfn: ValueRef, llargbundle: ValueRef);\n+type wrap_arg_builder<'self> = &'self fn(bcx: block,\n+                                         tys: &ShimTypes,\n+                                         llwrapfn: ValueRef,\n+                                         llargbundle: ValueRef);\n \n-type wrap_ret_builder<'self> =\n-    &'self fn(bcx: block, tys: &ShimTypes,\n-              llargbundle: ValueRef);\n+type wrap_ret_builder<'self> = &'self fn(bcx: block,\n+                                         tys: &ShimTypes,\n+                                         llargbundle: ValueRef);\n \n fn build_wrap_fn_(ccx: @CrateContext,\n                   tys: &ShimTypes,\n                   llshimfn: ValueRef,\n                   llwrapfn: ValueRef,\n                   shim_upcall: ValueRef,\n                   arg_builder: wrap_arg_builder,\n-                  ret_builder: wrap_ret_builder)\n-{\n+                  ret_builder: wrap_ret_builder) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn_\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llwrapfn, tys.fn_sig.output, None);\n+\n+    // Patch up the return type if it's not immediate.\n+    /*if !ty::type_is_immediate(tys.fn_sig.output) {\n+        let lloutputtype = type_of::type_of(*fcx.ccx, tys.fn_sig.output);\n+        fcx.llretptr = Some(alloca(raw_block(fcx, false, fcx.llstaticallocas),\n+                                   lloutputtype));\n+    }*/\n+\n     let bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n \n@@ -196,11 +210,34 @@ fn build_wrap_fn_(ccx: @CrateContext,\n     Call(bcx, shim_upcall, ~[llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n+    // Perform a custom version of `finish_fn`. First, tie up the header\n+    // blocks.\n     tie_up_header_blocks(fcx, lltop);\n \n-    // Make sure our standard return block (that we didn't use) is terminated\n-    let ret_cx = raw_block(fcx, false, fcx.llreturn);\n-    Unreachable(ret_cx);\n+    // Then return according to the C ABI.\n+    unsafe {\n+        let return_context = raw_block(fcx, false, fcx.llreturn);\n+\n+        let llfunctiontype = val_ty(llwrapfn);\n+        let llfunctiontype =\n+            ::lib::llvm::llvm::LLVMGetElementType(llfunctiontype);\n+        let llfunctionreturntype =\n+            ::lib::llvm::llvm::LLVMGetReturnType(llfunctiontype);\n+        if ::lib::llvm::llvm::LLVMGetTypeKind(llfunctionreturntype) ==\n+                ::lib::llvm::Void {\n+            // XXX: This might be wrong if there are any functions for which\n+            // the C ABI specifies a void output pointer and the Rust ABI\n+            // does not.\n+            RetVoid(return_context);\n+        } else {\n+            // Cast if we have to...\n+            // XXX: This is ugly.\n+            let llretptr = BitCast(return_context,\n+                                   fcx.llretptr.get(),\n+                                   T_ptr(llfunctionreturntype));\n+            Ret(return_context, Load(return_context, llretptr));\n+        }\n+    }\n }\n \n // For each foreign function F, we generate a wrapper function W and a shim\n@@ -241,8 +278,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n // in the future.\n pub fn trans_foreign_mod(ccx: @CrateContext,\n                          path: &ast_map::path,\n-                         foreign_mod: &ast::foreign_mod)\n-{\n+                         foreign_mod: &ast::foreign_mod) {\n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n     let arch = ccx.sess.targ_cfg.arch;\n@@ -312,8 +348,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     fn build_foreign_fn(ccx: @CrateContext,\n                         id: ast::node_id,\n                         foreign_item: @ast::foreign_item,\n-                        cc: lib::llvm::CallConv)\n-    {\n+                        cc: lib::llvm::CallConv) {\n         let llwrapfn = get_item_val(ccx, id);\n         let tys = shim_types(ccx, id);\n         if attr::attrs_contains_name(foreign_item.attrs, \"rust_stack\") {\n@@ -322,17 +357,16 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         } else if attr::attrs_contains_name(foreign_item.attrs, \"fast_ffi\") {\n             build_fast_ffi_fn(ccx, llwrapfn, foreign_item, &tys, cc);\n         } else {\n-            let llshimfn = build_shim_fn(ccx, foreign_item,\n-                                         &tys, cc);\n+            let llshimfn = build_shim_fn(ccx, foreign_item, &tys, cc);\n             build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n         }\n     }\n \n     fn build_shim_fn(ccx: @CrateContext,\n                      foreign_item: @ast::foreign_item,\n                      tys: &ShimTypes,\n-                     cc: lib::llvm::CallConv) -> ValueRef\n-    {\n+                     cc: lib::llvm::CallConv)\n+                  -> ValueRef {\n         /*!\n          *\n          * Build S, from comment above:\n@@ -344,31 +378,43 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llargbundle: ValueRef) -> ~[ValueRef] {\n+        fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n+                   -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_args\");\n-            tys.fn_ty.build_shim_args(\n-                bcx, tys.llsig.llarg_tys, llargbundle)\n+            tys.fn_ty.build_shim_args(bcx, tys.llsig.llarg_tys, llargbundle)\n         }\n \n-        fn build_ret(bcx: block, tys: &ShimTypes,\n-                     llargbundle: ValueRef, llretval: ValueRef)  {\n+        fn build_ret(bcx: block,\n+                     tys: &ShimTypes,\n+                     llargbundle: ValueRef,\n+                     llretval: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::shim::build_ret\");\n-            tys.fn_ty.build_shim_ret(\n-                bcx, tys.llsig.llarg_tys,\n-                tys.ret_def, llargbundle, llretval);\n+            tys.fn_ty.build_shim_ret(bcx,\n+                                     tys.llsig.llarg_tys,\n+                                     tys.ret_def,\n+                                     llargbundle,\n+                                     llretval);\n+            build_return(bcx);\n         }\n \n         let lname = link_name(ccx, foreign_item);\n         let llbasefn = base_fn(ccx, *lname, tys, cc);\n         // Name the shim function\n         let shim_name = *lname + ~\"__c_stack_shim\";\n-        return build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n-                           build_args, build_ret);\n+        build_shim_fn_(ccx,\n+                       shim_name,\n+                       llbasefn,\n+                       tys,\n+                       cc,\n+                       build_args,\n+                       build_ret)\n     }\n \n-    fn base_fn(ccx: @CrateContext, lname: &str, tys: &ShimTypes,\n-               cc: lib::llvm::CallConv) -> ValueRef {\n+    fn base_fn(ccx: @CrateContext,\n+               lname: &str,\n+               tys: &ShimTypes,\n+               cc: lib::llvm::CallConv)\n+               -> ValueRef {\n         // Declare the \"prototype\" for the base function F:\n         do tys.fn_ty.decl_fn |fnty| {\n             decl_fn(ccx.llmod, lname, cc, fnty)\n@@ -377,12 +423,14 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n     // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n     // over the place\n-    fn build_direct_fn(ccx: @CrateContext, decl: ValueRef,\n-                       item: @ast::foreign_item, tys: &ShimTypes,\n+    fn build_direct_fn(ccx: @CrateContext,\n+                       decl: ValueRef,\n+                       item: @ast::foreign_item,\n+                       tys: &ShimTypes,\n                        cc: lib::llvm::CallConv) {\n         debug!(\"build_direct_fn(%s)\", *link_name(ccx, item));\n \n-        let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n+        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n@@ -393,7 +441,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         let retval = Call(bcx, llbasefn, args);\n         let ret_ty = ty::ty_fn_ret(ty);\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr);\n+            Store(bcx, retval, fcx.llretptr.get());\n         }\n         build_return(bcx);\n         finish_fn(fcx, lltop);\n@@ -408,7 +456,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                          cc: lib::llvm::CallConv) {\n         debug!(\"build_fast_ffi_fn(%s)\", *link_name(ccx, item));\n \n-        let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n+        let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n@@ -421,7 +469,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         let retval = Call(bcx, llbasefn, args);\n         let ret_ty = ty::ty_fn_ret(ty);\n         if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n-            Store(bcx, retval, fcx.llretptr);\n+            Store(bcx, retval, fcx.llretptr.get());\n         }\n         build_return(bcx);\n         finish_fn(fcx, lltop);\n@@ -446,12 +494,18 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::build_wrap_fn\");\n \n-        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+        build_wrap_fn_(ccx,\n+                       tys,\n+                       llshimfn,\n+                       llwrapfn,\n                        ccx.upcalls.call_shim_on_c_stack,\n-                       build_args, build_ret);\n+                       build_args,\n+                       build_ret);\n \n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llwrapfn: ValueRef, llargbundle: ValueRef) {\n+        fn build_args(bcx: block,\n+                      tys: &ShimTypes,\n+                      llwrapfn: ValueRef,\n+                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_args\");\n             let ccx = bcx.ccx();\n             let n = vec::len(tys.llsig.llarg_tys);\n@@ -468,14 +522,18 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n \n                 store_inbounds(bcx, llargval, llargbundle, ~[0u, i]);\n             }\n-            let llretptr = get_param(llwrapfn, 0u);\n+            let llretptr = bcx.fcx.llretptr.get();\n             store_inbounds(bcx, llretptr, llargbundle, ~[0u, n]);\n         }\n \n-        fn build_ret(bcx: block, _tys: &ShimTypes,\n-                     _llargbundle: ValueRef) {\n+        fn build_ret(bcx: block,\n+                     shim_types: &ShimTypes,\n+                     llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n-            RetVoid(bcx);\n+            let arg_count = shim_types.fn_sig.inputs.len();\n+            let llretptr = load_inbounds(bcx, llargbundle, ~[0, arg_count]);\n+            Store(bcx, Load(bcx, llretptr), bcx.fcx.llretptr.get());\n+            build_return(bcx);\n         }\n     }\n }\n@@ -488,9 +546,18 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                        ref_id: Option<ast::node_id>) {\n     debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n \n+    let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n+\n     // XXX: Bad copy.\n-    let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, None,\n-                               Some(copy substs), Some(item.span));\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               path,\n+                               decl,\n+                               item.id,\n+                               output_type,\n+                               None,\n+                               Some(copy substs),\n+                               Some(item.span));\n+\n     let mut bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n     match *ccx.sess.str_of(item.ident) {\n         ~\"atomic_cxchg\" => {\n@@ -499,92 +566,92 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_cxchg_acq\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_cxchg_rel\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xchg\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xchg_acq\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xchg_rel\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xadd\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xadd_acq\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xadd_rel\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xsub\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xsub_acq\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"atomic_xsub_rel\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n-            Store(bcx, old, fcx.llretptr);\n+            Store(bcx, old, fcx.llretptr.get());\n         }\n         ~\"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"move_val\" => {\n             // Create a datum reflecting the value being moved:\n@@ -615,13 +682,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"pref_align_of\"=> {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n@@ -631,13 +698,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // FIXME (#3727): change this to T_ptr(ccx.tydesc_ty) when the\n             // core::sys copy of the get_tydesc interface dies off.\n             let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n-            Store(bcx, td, fcx.llretptr);\n+            Store(bcx, td, fcx.llretptr.get());\n         }\n         ~\"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             if !ty::type_is_nil(tp_ty) {\n-                Store(bcx, C_null(lltp_ty), fcx.llretptr);\n+                Store(bcx, C_null(lltp_ty), fcx.llretptr.get());\n             }\n         }\n         ~\"forget\" => {}\n@@ -663,20 +730,21 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n               // NB: Do not use a Load and Store here. This causes\n               // massive code bloat when reinterpret_cast is used on\n               // large structural types.\n-              let llretptr = PointerCast(bcx, fcx.llretptr, T_ptr(T_i8()));\n+              let llretptr = fcx.llretptr.get();\n+              let llretptr = PointerCast(bcx, llretptr, T_ptr(T_i8()));\n               let llcast = get_param(decl, first_real_arg);\n               let llcast = PointerCast(bcx, llcast, T_ptr(T_i8()));\n               call_memcpy(bcx, llretptr, llcast, llsize_of(ccx, lltp_ty));\n           }\n         }\n         ~\"addr_of\" => {\n-            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr);\n+            Store(bcx, get_param(decl, first_real_arg), fcx.llretptr.get());\n         }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n             Store(bcx,\n                   C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n-                  fcx.llretptr);\n+                  fcx.llretptr.get());\n         }\n         ~\"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n@@ -718,7 +786,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 bcx.ccx().llmod, ~\"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr,\n                                              T_ptr(T_nil()));\n-            Store(bcx, morestack_addr, fcx.llretptr);\n+            Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n         ~\"memmove32\" => {\n             let dst_ptr = get_param(decl, first_real_arg);\n@@ -743,243 +811,243 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n-            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n-            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powif = *ccx.intrinsics.get(&~\"llvm.powi.f32\");\n-            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powif = *ccx.intrinsics.get(&~\"llvm.powi.f64\");\n-            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f32\");\n-            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f64\");\n-            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f32\");\n-            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f64\");\n-            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powf = *ccx.intrinsics.get(&~\"llvm.pow.f32\");\n-            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powf = *ccx.intrinsics.get(&~\"llvm.pow.f64\");\n-            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr.get());\n         }\n         ~\"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let expf = *ccx.intrinsics.get(&~\"llvm.exp.f32\");\n-            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let expf = *ccx.intrinsics.get(&~\"llvm.exp.f64\");\n-            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n-            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n-            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let logf = *ccx.intrinsics.get(&~\"llvm.log.f32\");\n-            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let logf = *ccx.intrinsics.get(&~\"llvm.log.f64\");\n-            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f32\");\n-            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f64\");\n-            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f32\");\n-            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f64\");\n-            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr.get());\n         }\n         ~\"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n             let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f32\");\n-            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr.get());\n         }\n         ~\"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n             let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f64\");\n-            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr.get());\n         }\n         ~\"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n-            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n-            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f32\");\n-            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f64\");\n-            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n-            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n-            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n-            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n-            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n+            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr.get());\n         }\n         ~\"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n         }\n         ~\"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n         }\n         ~\"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n         }\n         ~\"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n+            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n         }\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n@@ -1025,9 +1093,12 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n-    fn build_rust_fn(ccx: @CrateContext, +path: ast_map::path,\n-                     decl: &ast::fn_decl, body: &ast::blk,\n-                     id: ast::node_id) -> ValueRef {\n+    fn build_rust_fn(ccx: @CrateContext,\n+                     +path: ast_map::path,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n+                     id: ast::node_id)\n+                  -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n         // XXX: Bad copy.\n@@ -1050,8 +1121,11 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n         return llfndecl;\n     }\n \n-    fn build_shim_fn(ccx: @CrateContext, +path: ast_map::path,\n-                     llrustfn: ValueRef, tys: &ShimTypes) -> ValueRef {\n+    fn build_shim_fn(ccx: @CrateContext,\n+                     +path: ast_map::path,\n+                     llrustfn: ValueRef,\n+                     tys: &ShimTypes)\n+                     -> ValueRef {\n         /*!\n          *\n          * Generate the shim S:\n@@ -1069,15 +1143,21 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_shim_fn\");\n \n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llargbundle: ValueRef) -> ~[ValueRef] {\n+        fn build_args(bcx: block, tys: &ShimTypes, llargbundle: ValueRef)\n+                      -> ~[ValueRef] {\n             let _icx = bcx.insn_ctxt(\"foreign::extern::shim::build_args\");\n             let ccx = bcx.ccx();\n             let mut llargvals = ~[];\n             let mut i = 0u;\n             let n = tys.fn_sig.inputs.len();\n-            let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n-            llargvals.push(llretptr);\n+\n+            if !ty::type_is_immediate(tys.fn_sig.output) {\n+                let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+                llargvals.push(llretptr);\n+            } else {\n+                llargvals.push(C_null(T_ptr(T_i8())));\n+            }\n+\n             let llenvptr = C_null(T_opaque_box_ptr(bcx.ccx()));\n             llargvals.push(llenvptr);\n             while i < n {\n@@ -1095,24 +1175,43 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n             return llargvals;\n         }\n \n-        fn build_ret(_bcx: block, _tys: &ShimTypes,\n-                     _llargbundle: ValueRef, _llretval: ValueRef)  {\n-            // Nop. The return pointer in the Rust ABI function\n-            // is wired directly into the return slot in the shim struct\n+        fn build_ret(bcx: block,\n+                     shim_types: &ShimTypes,\n+                     llargbundle: ValueRef,\n+                     llretval: ValueRef) {\n+            if ty::type_is_immediate(shim_types.fn_sig.output) {\n+                // Write the value into the argument bundle.\n+                let arg_count = shim_types.fn_sig.inputs.len();\n+                let llretptr = load_inbounds(bcx,\n+                                             llargbundle,\n+                                             ~[0, arg_count]);\n+                Store(bcx, llretval, llretptr);\n+            } else {\n+                // NB: The return pointer in the Rust ABI function is wired\n+                // directly into the return slot in the shim struct.\n+            }\n+\n+            build_return(bcx);\n         }\n \n         let shim_name = link::mangle_internal_name_by_path(\n-            ccx, vec::append_one(path, ast_map::path_name(\n+            ccx,\n+            vec::append_one(path, ast_map::path_name(\n                 special_idents::clownshoe_stack_shim\n             )));\n-        return build_shim_fn_(ccx, shim_name, llrustfn, tys,\n-                           lib::llvm::CCallConv,\n-                           build_args, build_ret);\n+        build_shim_fn_(ccx,\n+                       shim_name,\n+                       llrustfn,\n+                       tys,\n+                       lib::llvm::CCallConv,\n+                       build_args,\n+                       build_ret)\n     }\n \n-    fn build_wrap_fn(ccx: @CrateContext, llshimfn: ValueRef,\n-                     llwrapfn: ValueRef, tys: &ShimTypes)\n-    {\n+    fn build_wrap_fn(ccx: @CrateContext,\n+                     llshimfn: ValueRef,\n+                     llwrapfn: ValueRef,\n+                     tys: &ShimTypes) {\n         /*!\n          *\n          * Generate the wrapper W:\n@@ -1125,23 +1224,29 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n \n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_wrap_fn\");\n \n-        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+        build_wrap_fn_(ccx,\n+                       tys,\n+                       llshimfn,\n+                       llwrapfn,\n                        ccx.upcalls.call_shim_on_rust_stack,\n-                       build_args, build_ret);\n+                       build_args,\n+                       build_ret);\n \n-        fn build_args(bcx: block, tys: &ShimTypes,\n-                      llwrapfn: ValueRef, llargbundle: ValueRef) {\n+        fn build_args(bcx: block,\n+                      tys: &ShimTypes,\n+                      llwrapfn: ValueRef,\n+                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_args\");\n-            tys.fn_ty.build_wrap_args(\n-                bcx, tys.llsig.llret_ty,\n-                llwrapfn, llargbundle);\n+            tys.fn_ty.build_wrap_args(bcx,\n+                                      tys.llsig.llret_ty,\n+                                      llwrapfn,\n+                                      llargbundle);\n         }\n \n-        fn build_ret(bcx: block, tys: &ShimTypes,\n-                     llargbundle: ValueRef) {\n+        fn build_ret(bcx: block, tys: &ShimTypes, llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::foreign::wrap::build_ret\");\n-            tys.fn_ty.build_wrap_ret(\n-                bcx, tys.llsig.llarg_tys, llargbundle);\n+            tys.fn_ty.build_wrap_ret(bcx, tys.llsig.llarg_tys, llargbundle);\n+            build_return(bcx);\n         }\n     }\n \n@@ -1160,12 +1265,20 @@ pub fn register_foreign_fn(ccx: @CrateContext,\n                            +path: ast_map::path,\n                            node_id: ast::node_id,\n                            attrs: &[ast::attribute])\n-                        -> ValueRef {\n+                           -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"foreign::register_foreign_fn\");\n+\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n+\n     let tys = shim_types(ccx, node_id);\n     do tys.fn_ty.decl_fn |fnty| {\n-        register_fn_fuller(ccx, sp, /*bad*/copy path, node_id, attrs,\n-                           t, lib::llvm::CCallConv, fnty)\n+        register_fn_fuller(ccx,\n+                           sp,\n+                           /*bad*/copy path,\n+                           node_id,\n+                           attrs,\n+                           t,\n+                           lib::llvm::CCallConv,\n+                           fnty)\n     }\n }"}, {"sha": "2072c4712457334e2022efe88175da62e0b6c6e9", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -499,7 +499,8 @@ pub fn trans_struct_drop(bcx: block,\n         }\n \n         let self_arg = PointerCast(bcx, llval, params[1]);\n-        let args = ~[bcx.fcx.llretptr, self_arg];\n+        let args = ~[C_null(T_ptr(T_i8())), self_arg];\n+\n         Call(bcx, dtor_addr, args);\n \n         // Drop the fields\n@@ -575,9 +576,7 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-pub fn decr_refcnt_maybe_free(bcx: block,\n-                              box_ptr: ValueRef,\n-                              t: ty::t)\n+pub fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t)\n                            -> block {\n     let _icx = bcx.insn_ctxt(\"decr_refcnt_maybe_free\");\n     let ccx = bcx.ccx();\n@@ -737,7 +736,7 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n                                helper: glue_helper)\n                             -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue_inner\");\n-    let fcx = new_fn_ctxt(ccx, ~[], llfn, None);\n+    let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(ccx.tcx), None);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n     // All glue functions take values passed *by alias*; this is a\n@@ -756,8 +755,11 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n     return llfn;\n }\n \n-pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n-                         helper: glue_helper, name: &str)\n+pub fn make_generic_glue(ccx: @CrateContext,\n+                         t: ty::t,\n+                         llfn: ValueRef,\n+                         helper: glue_helper,\n+                         name: &str)\n                       -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"make_generic_glue\");\n     if !ccx.sess.trans_stats() {\n@@ -767,8 +769,10 @@ pub fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n     let start = time::get_time();\n     let llval = make_generic_glue_inner(ccx, t, llfn, helper);\n     let end = time::get_time();\n-    log_fn_time(ccx, fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)),\n-                start, end);\n+    log_fn_time(ccx,\n+                fmt!(\"glue %s %s\", name, ty_to_short_str(ccx.tcx, t)),\n+                start,\n+                end);\n     return llval;\n }\n "}, {"sha": "8cac00252d0d3665d35f4931ca8f213b2b845e78", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -39,20 +39,34 @@ pub fn type_of_explicit_args(ccx: @CrateContext,\n     inputs.map(|arg| type_of_explicit_arg(ccx, arg))\n }\n \n-pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg],\n-                  output: ty::t) -> TypeRef {\n+pub fn type_of_fn(cx: @CrateContext, inputs: &[ty::arg], output: ty::t)\n+               -> TypeRef {\n     unsafe {\n         let mut atys: ~[TypeRef] = ~[];\n \n         // Arg 0: Output pointer.\n-        atys.push(T_ptr(type_of(cx, output)));\n+        // (if the output type is non-immediate)\n+        let output_is_immediate = ty::type_is_immediate(output);\n+        let lloutputtype = type_of(cx, output);\n+        if !output_is_immediate {\n+            atys.push(T_ptr(lloutputtype));\n+        } else {\n+            // XXX: Eliminate this.\n+            atys.push(T_ptr(T_i8()));\n+        }\n \n         // Arg 1: Environment\n         atys.push(T_opaque_box_ptr(cx));\n \n         // ... then explicit args.\n         atys.push_all(type_of_explicit_args(cx, inputs));\n-        return T_fn(atys, llvm::LLVMVoidType());\n+\n+        // Use the output as the actual return value if it's immediate.\n+        if output_is_immediate {\n+            T_fn(atys, lloutputtype)\n+        } else {\n+            T_fn(atys, llvm::LLVMVoidType())\n+        }\n     }\n }\n \n@@ -318,11 +332,9 @@ pub fn llvm_type_name(cx: @CrateContext,\n }\n \n pub fn type_of_dtor(ccx: @CrateContext, self_ty: ty::t) -> TypeRef {\n-    unsafe {\n-        T_fn(~[T_ptr(type_of(ccx, ty::mk_nil(ccx.tcx))), // output pointer\n-               T_ptr(type_of(ccx, self_ty))],            // self arg\n-             llvm::LLVMVoidType())\n-    }\n+    T_fn(~[T_ptr(T_i8()),                   // output pointer\n+           T_ptr(type_of(ccx, self_ty))],   // self arg\n+         T_nil())\n }\n \n pub fn type_of_rooted(ccx: @CrateContext, t: ty::t) -> TypeRef {\n@@ -336,5 +348,5 @@ pub fn type_of_glue_fn(ccx: @CrateContext, t: ty::t) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     let llty = T_ptr(type_of(ccx, t));\n     return T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty],\n-                T_void());\n+                T_nil());\n }"}, {"sha": "ef4932d667a299b02e93ac950575a2fa5881bd78", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -222,7 +222,11 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                         };\n                         match connect_result {\n                             0i32 => {\n-                                debug!(\"tcp_connect successful\");\n+                                debug!(\"tcp_connect successful: \\\n+                                        stream %x,\n+                                        socket data %x\",\n+                                       stream_handle_ptr as uint,\n+                                       socket_data_ptr as uint);\n                                 // reusable data that we'll have for the\n                                 // duration..\n                                 uv::ll::set_data_for_uv_handle(\n@@ -556,13 +560,21 @@ pub fn accept(new_conn: TcpNewConnection)\n                             server_handle_ptr as *libc::c_void,\n                             client_stream_handle_ptr as *libc::c_void) {\n                             0i32 => {\n-                                debug!(\n-                                    \"successfully accepted client \\\n-                                      connection\");\n+                                debug!(\"successfully accepted client \\\n+                                        connection: \\\n+                                        stream %x, \\\n+                                        socket data %x\",\n+                                       client_stream_handle_ptr as uint,\n+                                       client_socket_data_ptr as uint);\n                                 uv::ll::set_data_for_uv_handle(\n                                     client_stream_handle_ptr,\n                                     client_socket_data_ptr\n                                     as *libc::c_void);\n+                                let ptr = uv::ll::get_data_for_uv_handle(\n+                                    client_stream_handle_ptr);\n+                                debug!(\"ptrs: %x %x\",\n+                                       client_socket_data_ptr as uint,\n+                                       ptr as uint);\n                                 result_ch.send(None);\n                             }\n                             _ => {\n@@ -1268,14 +1280,15 @@ impl ToTcpErr for uv::ll::uv_err_data {\n }\n \n extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n-                    nread: libc::ssize_t,\n-                    buf: uv::ll::uv_buf_t) {\n+                         nread: libc::ssize_t,\n+                         buf: uv::ll::uv_buf_t) {\n     unsafe {\n-        debug!(\"entering on_tcp_read_cb stream: %? nread: %?\",\n-                        stream, nread);\n+        debug!(\"entering on_tcp_read_cb stream: %x nread: %?\",\n+                        stream as uint, nread);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream);\n         let socket_data_ptr = uv::ll::get_data_for_uv_handle(stream)\n             as *TcpSocketData;\n+        debug!(\"socket data is %x\", socket_data_ptr as uint);\n         match nread as int {\n           // incoming err.. probably eof\n           -1 => {"}, {"sha": "98d76c6b9aa56e1bed99e0306bd7df020c00240b", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -1156,8 +1156,7 @@ pub unsafe fn set_data_for_uv_loop(loop_ptr: *libc::c_void,\n pub unsafe fn get_data_for_uv_handle<T>(handle: *T) -> *libc::c_void {\n     return rustrt::rust_uv_get_data_for_uv_handle(handle as *libc::c_void);\n }\n-pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T,\n-                    data: *U) {\n+pub unsafe fn set_data_for_uv_handle<T, U>(handle: *T, data: *U) {\n     rustrt::rust_uv_set_data_for_uv_handle(handle as *libc::c_void,\n                                            data as *libc::c_void);\n }"}, {"sha": "8cf2bd4b4acb99340654dfe6f966d7562b6dead9", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -401,8 +401,7 @@ rust_uv_get_data_for_uv_handle(uv_handle_t* handle) {\n }\n \n extern \"C\" void\n-rust_uv_set_data_for_uv_handle(uv_handle_t* handle,\n-        void* data) {\n+rust_uv_set_data_for_uv_handle(uv_handle_t* handle, void* data) {\n     handle->data = data;\n }\n "}, {"sha": "685d86c740d9706487e732f4ee4c0580616d0642", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -17,11 +17,11 @@ fn foo<T:Copy + Const>(x: T) -> T { x }\n struct F { field: int }\n \n pub fn main() {\n-    foo(1);\n+    /*foo(1);\n     foo(~\"hi\");\n     foo(~[1, 2, 3]);\n     foo(F{field: 42});\n     foo((1, 2u));\n-    foo(@1);\n+    foo(@1);*/\n     foo(~1);\n }"}, {"sha": "37e531eaa8e60b5abe7a70d042dcc592748db57f", "filename": "src/test/run-pass/extern-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Ftest%2Frun-pass%2Fextern-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c995a62d44ce8534d4f8bf36284419661b87e167/src%2Ftest%2Frun-pass%2Fextern-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call.rs?ref=c995a62d44ce8534d4f8bf36284419661b87e167", "patch": "@@ -11,7 +11,7 @@\n mod rustrt {\n     pub extern {\n         pub fn rust_dbg_call(cb: *u8, data: libc::uintptr_t)\n-                          -> libc::uintptr_t;\n+                             -> libc::uintptr_t;\n     }\n }\n "}]}