{"sha": "321f8d81b878da1ead6c73fb7877d494619ef284", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyMWY4ZDgxYjg3OGRhMWVhZDZjNzNmYjc4NzdkNDk0NjE5ZWYyODQ=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-31T20:54:15Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2015-08-31T20:54:15Z"}, "message": "remove the is_instantiable check\n\nFixes #27497", "tree": {"sha": "c652894090f665badf1d99288623e33fc06467f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c652894090f665badf1d99288623e33fc06467f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/321f8d81b878da1ead6c73fb7877d494619ef284", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/321f8d81b878da1ead6c73fb7877d494619ef284", "html_url": "https://github.com/rust-lang/rust/commit/321f8d81b878da1ead6c73fb7877d494619ef284", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/321f8d81b878da1ead6c73fb7877d494619ef284/comments", "author": null, "committer": null, "parents": [{"sha": "f9f82f8dc8c936c9cd55d529d9941c5d925d9e67", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9f82f8dc8c936c9cd55d529d9941c5d925d9e67", "html_url": "https://github.com/rust-lang/rust/commit/f9f82f8dc8c936c9cd55d529d9941c5d925d9e67"}], "stats": {"total": 116, "additions": 1, "deletions": 115}, "files": [{"sha": "483f2873166c6cedb939f6dee4b9a4e4e4512551", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/321f8d81b878da1ead6c73fb7877d494619ef284/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321f8d81b878da1ead6c73fb7877d494619ef284/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=321f8d81b878da1ead6c73fb7877d494619ef284", "patch": "@@ -4821,100 +4821,6 @@ impl<'tcx> TyS<'tcx> {\n \n         result\n     }\n-\n-    // True if instantiating an instance of `r_ty` requires an instance of `r_ty`.\n-    pub fn is_instantiable(&'tcx self, cx: &ctxt<'tcx>) -> bool {\n-        fn type_requires<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<AdtDef<'tcx>>,\n-                               r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-            debug!(\"type_requires({:?}, {:?})?\",\n-                   r_ty, ty);\n-\n-            let r = r_ty == ty || subtypes_require(cx, seen, r_ty, ty);\n-\n-            debug!(\"type_requires({:?}, {:?})? {:?}\",\n-                   r_ty, ty, r);\n-            return r;\n-        }\n-\n-        fn subtypes_require<'tcx>(cx: &ctxt<'tcx>, seen: &mut Vec<AdtDef<'tcx>>,\n-                                  r_ty: Ty<'tcx>, ty: Ty<'tcx>) -> bool {\n-            debug!(\"subtypes_require({:?}, {:?})?\",\n-                   r_ty, ty);\n-\n-            let r = match ty.sty {\n-                // fixed length vectors need special treatment compared to\n-                // normal vectors, since they don't necessarily have the\n-                // possibility to have length zero.\n-                TyArray(_, 0) => false, // don't need no contents\n-                TyArray(ty, _) => type_requires(cx, seen, r_ty, ty),\n-\n-                TyBool |\n-                TyChar |\n-                TyInt(_) |\n-                TyUint(_) |\n-                TyFloat(_) |\n-                TyStr |\n-                TyBareFn(..) |\n-                TyParam(_) |\n-                TyProjection(_) |\n-                TySlice(_) => {\n-                    false\n-                }\n-                TyBox(typ) => {\n-                    type_requires(cx, seen, r_ty, typ)\n-                }\n-                TyRef(_, ref mt) => {\n-                    type_requires(cx, seen, r_ty, mt.ty)\n-                }\n-\n-                TyRawPtr(..) => {\n-                    false           // unsafe ptrs can always be NULL\n-                }\n-\n-                TyTrait(..) => {\n-                    false\n-                }\n-\n-                TyStruct(def, substs) | TyEnum(def, substs) => {\n-                    if seen.contains(&def) {\n-                        // FIXME(#27497) ???\n-                        false\n-                    } else if def.is_empty() {\n-                        // HACK: required for empty types to work. This\n-                        // check is basically a lint anyway.\n-                        false\n-                    } else {\n-                        seen.push(def);\n-                        let r = def.variants.iter().all(|v| v.fields.iter().any(|f| {\n-                            type_requires(cx, seen, r_ty, f.ty(cx, substs))\n-                        }));\n-                        seen.pop().unwrap();\n-                        r\n-                    }\n-                }\n-\n-                TyError |\n-                TyInfer(_) |\n-                TyClosure(..) => {\n-                    // this check is run on type definitions, so we don't expect to see\n-                    // inference by-products or closure types\n-                    cx.sess.bug(&format!(\"requires check invoked on inapplicable type: {:?}\", ty))\n-                }\n-\n-                TyTuple(ref ts) => {\n-                    ts.iter().any(|ty| type_requires(cx, seen, r_ty, *ty))\n-                }\n-            };\n-\n-            debug!(\"subtypes_require({:?}, {:?})? {:?}\",\n-                   r_ty, ty, r);\n-\n-            return r;\n-        }\n-\n-        let mut seen = Vec::new();\n-        !subtypes_require(cx, &mut seen, self, self)\n-    }\n }\n \n /// Describes whether a type is representable. For types that are not"}, {"sha": "e9d78b3b7d742703c425362e17760fbab23f8931", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/321f8d81b878da1ead6c73fb7877d494619ef284/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321f8d81b878da1ead6c73fb7877d494619ef284/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=321f8d81b878da1ead6c73fb7877d494619ef284", "patch": "@@ -117,7 +117,6 @@ use syntax::attr::AttrMetaMethods;\n use syntax::ast::{self, Visibility};\n use syntax::ast_util;\n use syntax::codemap::{self, Span};\n-use syntax::feature_gate::emit_feature_err;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::{self, InternedString};\n use syntax::print::pprust;\n@@ -669,7 +668,6 @@ pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n     check_representable(tcx, span, id, \"struct\");\n-    check_instantiable(tcx, span, id);\n \n     if tcx.lookup_simd(DefId::local(id)) {\n         check_simd(tcx, span, id);\n@@ -4202,22 +4200,6 @@ pub fn check_representable(tcx: &ty::ctxt,\n     return true\n }\n \n-/// Checks whether a type can be constructed at runtime without\n-/// an existing instance of that type.\n-pub fn check_instantiable(tcx: &ty::ctxt,\n-                          sp: Span,\n-                          item_id: ast::NodeId) {\n-    let item_ty = tcx.node_id_to_type(item_id);\n-    if !item_ty.is_instantiable(tcx) &&\n-            !tcx.sess.features.borrow().static_recursion {\n-        emit_feature_err(&tcx.sess.parse_sess.span_diagnostic,\n-                         \"static_recursion\",\n-                         sp,\n-                         \"this type cannot be instantiated at runtime \\\n-                          without an instance of itself\");\n-    }\n-}\n-\n pub fn check_simd(tcx: &ty::ctxt, sp: Span, id: ast::NodeId) {\n     let t = tcx.node_id_to_type(id);\n     match t.sty {\n@@ -4352,7 +4334,6 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     do_check(ccx, vs, id, hint);\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n-    check_instantiable(ccx.tcx, sp, id);\n }\n \n // Returns the type parameter count and the type for the given definition."}, {"sha": "d974017157655ea04864e23df9ac94c38810c07e", "filename": "src/test/run-pass/uninstantiable-struct.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/321f8d81b878da1ead6c73fb7877d494619ef284/src%2Ftest%2Frun-pass%2Funinstantiable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/321f8d81b878da1ead6c73fb7877d494619ef284/src%2Ftest%2Frun-pass%2Funinstantiable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funinstantiable-struct.rs?ref=321f8d81b878da1ead6c73fb7877d494619ef284", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Z(&'static Z);\n-//~^ ERROR this type cannot be instantiated\n+pub struct Z(&'static Z);\n \n pub fn main() {}", "previous_filename": "src/test/compile-fail/static-recursion-gate-2.rs"}]}