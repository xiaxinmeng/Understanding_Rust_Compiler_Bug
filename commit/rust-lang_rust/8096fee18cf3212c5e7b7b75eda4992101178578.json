{"sha": "8096fee18cf3212c5e7b7b75eda4992101178578", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwOTZmZWUxOGNmMzIxMmM1ZTdiN2I3NWVkYTQ5OTIxMDExNzg1Nzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T21:17:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-15T21:17:22Z"}, "message": "auto merge of #17934 : pcwalton/rust/better-autoderef-fixup, r=pnkfelix\n\nlibrustc: Improve method autoderef/deref/index behavior more, and enable IndexMut on mutable vectors.\r\n\r\nThis fixes a bug whereby the mutability fixups for method behavior were\r\nnot kicking in after autoderef failed to happen at any level. It also\r\nadds support for `Index` to the fixer-upper.\r\n\r\nCloses #12825.\r\n\r\nr? @pnkfelix", "tree": {"sha": "26e633cd000b9e9c12ed924f51b2c90a7f67d0bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26e633cd000b9e9c12ed924f51b2c90a7f67d0bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8096fee18cf3212c5e7b7b75eda4992101178578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8096fee18cf3212c5e7b7b75eda4992101178578", "html_url": "https://github.com/rust-lang/rust/commit/8096fee18cf3212c5e7b7b75eda4992101178578", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8096fee18cf3212c5e7b7b75eda4992101178578/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7134fc8de6c50b48af688c5c530d63c788215663", "url": "https://api.github.com/repos/rust-lang/rust/commits/7134fc8de6c50b48af688c5c530d63c788215663", "html_url": "https://github.com/rust-lang/rust/commit/7134fc8de6c50b48af688c5c530d63c788215663"}, {"sha": "f7fb38729ea665ef296d423ceb420be9f9d92cc3", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7fb38729ea665ef296d423ceb420be9f9d92cc3", "html_url": "https://github.com/rust-lang/rust/commit/f7fb38729ea665ef296d423ceb420be9f9d92cc3"}], "stats": {"total": 132, "additions": 76, "deletions": 56}, "files": [{"sha": "0bfdcee7f76f4093fcc323609a8e60eaa5d0ca23", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=8096fee18cf3212c5e7b7b75eda4992101178578", "patch": "@@ -453,13 +453,13 @@ impl<T> Index<uint,T> for Vec<T> {\n     }\n }\n \n-// FIXME(#12825) Indexing will always try IndexMut first and that causes issues.\n-/*impl<T> IndexMut<uint,T> for Vec<T> {\n+#[cfg(not(stage0))]\n+impl<T> IndexMut<uint,T> for Vec<T> {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &uint) -> &'a mut T {\n         self.get_mut(*index)\n     }\n-}*/\n+}\n \n impl<T> ops::Slice<uint, [T]> for Vec<T> {\n     #[inline]\n@@ -2154,7 +2154,6 @@ impl<T> Vec<T> {\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     extern crate test;"}, {"sha": "45658e8a356a0761000920a3822c9f79d7e7f567", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 66, "deletions": 41, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=8096fee18cf3212c5e7b7b75eda4992101178578", "patch": "@@ -359,8 +359,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         match result {\n             Some(Some(result)) => {\n-                self.fixup_derefs_on_method_receiver_if_necessary(&result,\n-                                                                  self_ty);\n+                self.fixup_derefs_on_method_receiver_if_necessary(&result);\n                 Some(result)\n             }\n             _ => None\n@@ -1388,8 +1387,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n     fn fixup_derefs_on_method_receiver_if_necessary(\n             &self,\n-            method_callee: &MethodCallee,\n-            self_ty: ty::t) {\n+            method_callee: &MethodCallee) {\n         let sig = match ty::get(method_callee.ty).sty {\n             ty::ty_bare_fn(ref f) => f.sig.clone(),\n             ty::ty_closure(ref f) => f.sig.clone(),\n@@ -1404,55 +1402,82 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             _ => return,\n         }\n \n-        // Fix up autoderefs and derefs.\n-        let mut self_expr = match self.self_expr {\n-            Some(expr) => expr,\n-            None => return,\n-        };\n+        // Gather up expressions we want to munge.\n+        let mut exprs = Vec::new();\n+        match self.self_expr {\n+            Some(expr) => exprs.push(expr),\n+            None => {}\n+        }\n         loop {\n+            if exprs.len() == 0 {\n+                break\n+            }\n+            let last = exprs[exprs.len() - 1];\n+            match last.node {\n+                ast::ExprParen(ref expr) |\n+                ast::ExprField(ref expr, _, _) |\n+                ast::ExprTupField(ref expr, _, _) |\n+                ast::ExprSlice(ref expr, _, _, _) |\n+                ast::ExprIndex(ref expr, _) |\n+                ast::ExprUnary(ast::UnDeref, ref expr) => exprs.push(&**expr),\n+                _ => break,\n+            }\n+        }\n+\n+        // Fix up autoderefs and derefs.\n+        for (i, expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n             let autoderef_count = match self.fcx\n                                             .inh\n                                             .adjustments\n                                             .borrow()\n-                                            .find(&self_expr.id) {\n+                                            .find(&expr.id) {\n                 Some(&ty::AdjustDerefRef(ty::AutoDerefRef {\n                     autoderefs: autoderef_count,\n                     autoref: _\n-                })) if autoderef_count > 0 => autoderef_count,\n-                Some(_) | None => return,\n+                })) => autoderef_count,\n+                Some(_) | None => 0,\n             };\n \n-            check::autoderef(self.fcx,\n-                             self_expr.span,\n-                             self.fcx.expr_ty(self_expr),\n-                             Some(self_expr.id),\n-                             PreferMutLvalue,\n-                             |_, autoderefs| {\n-                                 if autoderefs == autoderef_count + 1 {\n-                                     Some(())\n-                                 } else {\n-                                     None\n-                                 }\n-                             });\n-\n-            match self_expr.node {\n-                ast::ExprParen(ref expr) |\n-                ast::ExprIndex(ref expr, _) |\n-                ast::ExprField(ref expr, _, _) |\n-                ast::ExprTupField(ref expr, _, _) |\n-                ast::ExprSlice(ref expr, _, _, _) => self_expr = &**expr,\n-                ast::ExprUnary(ast::UnDeref, ref expr) => {\n-                    drop(check::try_overloaded_deref(\n-                            self.fcx,\n-                            self_expr.span,\n-                            Some(MethodCall::expr(self_expr.id)),\n-                            Some(self_expr),\n-                            self_ty,\n-                            PreferMutLvalue));\n-                    self_expr = &**expr\n+            if autoderef_count > 0 {\n+                check::autoderef(self.fcx,\n+                                 expr.span,\n+                                 self.fcx.expr_ty(*expr),\n+                                 Some(expr.id),\n+                                 PreferMutLvalue,\n+                                 |_, autoderefs| {\n+                                     if autoderefs == autoderef_count + 1 {\n+                                         Some(())\n+                                     } else {\n+                                         None\n+                                     }\n+                                 });\n+            }\n+\n+            // Don't retry the first one or we might infinite loop!\n+            if i != 0 {\n+                match expr.node {\n+                    ast::ExprIndex(ref base_expr, ref index_expr) => {\n+                        check::try_overloaded_index(\n+                                self.fcx,\n+                                Some(MethodCall::expr(expr.id)),\n+                                *expr,\n+                                &**base_expr,\n+                                self.fcx.expr_ty(&**base_expr),\n+                                index_expr,\n+                                PreferMutLvalue);\n+                    }\n+                    ast::ExprUnary(ast::UnDeref, ref base_expr) => {\n+                        check::try_overloaded_deref(\n+                                self.fcx,\n+                                expr.span,\n+                                Some(MethodCall::expr(expr.id)),\n+                                Some(&**base_expr),\n+                                self.fcx.expr_ty(&**base_expr),\n+                                PreferMutLvalue);\n+                    }\n+                    _ => {}\n                 }\n-                _ => break,\n             }\n         }\n     }"}, {"sha": "e906d7a9c5fe2dc0228511fdc55476d4b6d28a9b", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=8096fee18cf3212c5e7b7b75eda4992101178578", "patch": "@@ -2918,12 +2918,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                          expr: &ast::Expr,\n                          method_name: ast::SpannedIdent,\n                          args: &[P<ast::Expr>],\n-                         tps: &[P<ast::Ty>]) {\n+                         tps: &[P<ast::Ty>],\n+                         lvalue_pref: LvaluePreference) {\n         let rcvr = &*args[0];\n-        // We can't know if we need &mut self before we look up the method,\n-        // so treat the receiver as mutable just in case - only explicit\n-        // overloaded dereferences care about the distinction.\n-        check_expr_with_lvalue_pref(fcx, &*rcvr, PreferMutLvalue);\n+        check_expr_with_lvalue_pref(fcx, &*rcvr, lvalue_pref);\n \n         // no need to check for bot/err -- callee does that\n         let expr_t = structurally_resolved_type(fcx,\n@@ -4141,7 +4139,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n           }\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice());\n+        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n         let mut arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let (args_bot, args_err) = arg_tys.fold((false, false),\n              |(rest_bot, rest_err), a| {"}, {"sha": "7645500c02f544a44c21e599ebfe61ebfbfd886c", "filename": "src/test/run-pass/overloaded-deref-count.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8096fee18cf3212c5e7b7b75eda4992101178578/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref-count.rs?ref=8096fee18cf3212c5e7b7b75eda4992101178578", "patch": "@@ -68,12 +68,10 @@ pub fn main() {\n     *n -= 3; // Mutable deref + assignment with binary operation.\n     assert_eq!(n.counts(), (2, 3));\n \n-    // Mutable deref used for calling a method taking &self.\n-    // N.B. This is required because method lookup hasn't been performed so\n-    // we don't know whether the called method takes mutable self, before\n-    // the dereference itself is type-checked (a chicken-and-egg problem).\n+    // Immutable deref used for calling a method taking &self. (The\n+    // typechecker is smarter now about doing this.)\n     (*n).to_string();\n-    assert_eq!(n.counts(), (2, 4));\n+    assert_eq!(n.counts(), (3, 3));\n \n     // Mutable deref used for calling a method taking &mut self.\n     (*v).push(2);"}]}