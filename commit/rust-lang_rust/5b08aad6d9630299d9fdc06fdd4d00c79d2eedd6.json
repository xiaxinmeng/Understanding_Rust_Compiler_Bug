{"sha": "5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMDhhYWQ2ZDk2MzAyOTlkOWZkYzA2ZmRkNGQwMGM3OWQyZWVkZDY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-10T05:47:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-10T05:47:46Z"}, "message": "Rollup merge of #69475 - Zoxc:no-no-force, r=michaelwoerister\n\nRemove the `no_force` query attribute\n\nThis removes the `no_force` query attribute and instead uses the `DepNodeParams` trait to find out if a query can be forced.\n\nAlso the `analysis` query is moved to the query macro.\n\nr? @eddyb", "tree": {"sha": "b5854a715f3904b935c5d545ccbf4994fd28b40c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5854a715f3904b935c5d545ccbf4994fd28b40c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeZyoCCRBK7hj4Ov3rIwAAdHIIAKhrR2ggG5uaRtGrZmIPNnkZ\n0wnVFosF6fZtSNUVwbccRa94sBsP/f8vmaVrgpRRyKviQ4Hsh3UEOxVsumscBE3Y\nzys0ygO07ynSgWaabf7yD7TySqKRAJq3hsF36nGFH4gxrAVQoQ20TayEhSgYp4vJ\nDx09jjMnEFGnn895Ur+3zrr63PFC0pdKpxqogiWeUx80NwBSAqwz7dpVgWPDASTI\nkyT6fplsXMGM3SBUOH4RG/F0LRV40F4y1sTf29K5yBqmeRyppAZ6Pcs0Bb+QbZJ1\nyLwKDufs862z6MnfnzR9Km+UtC0mhUQLwhkFplm47//kHm2kxFPxBOsH2iYcZOA=\n=2ARu\n-----END PGP SIGNATURE-----\n", "payload": "tree b5854a715f3904b935c5d545ccbf4994fd28b40c\nparent 3dbade652ed8ebac70f903e01f51cd92c4e4302c\nparent 2f120095b59320d8c0adc3ad8f9294560bdf5c07\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1583819266 +0100\ncommitter GitHub <noreply@github.com> 1583819266 +0100\n\nRollup merge of #69475 - Zoxc:no-no-force, r=michaelwoerister\n\nRemove the `no_force` query attribute\n\nThis removes the `no_force` query attribute and instead uses the `DepNodeParams` trait to find out if a query can be forced.\n\nAlso the `analysis` query is moved to the query macro.\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "html_url": "https://github.com/rust-lang/rust/commit/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3dbade652ed8ebac70f903e01f51cd92c4e4302c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dbade652ed8ebac70f903e01f51cd92c4e4302c", "html_url": "https://github.com/rust-lang/rust/commit/3dbade652ed8ebac70f903e01f51cd92c4e4302c"}, {"sha": "2f120095b59320d8c0adc3ad8f9294560bdf5c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f120095b59320d8c0adc3ad8f9294560bdf5c07", "html_url": "https://github.com/rust-lang/rust/commit/2f120095b59320d8c0adc3ad8f9294560bdf5c07"}], "stats": {"total": 398, "additions": 161, "deletions": 237}, "files": [{"sha": "156f412e0902ec83aef1749f4063333701b9befb", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -360,33 +360,9 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [anon] TraitSelect,\n \n     [] CompileCodegenUnit(Symbol),\n-\n-    [eval_always] Analysis(CrateNum),\n ]);\n \n-pub trait RecoverKey<'tcx>: Sized {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n-}\n-\n-impl RecoverKey<'tcx> for CrateNum {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.krate)\n-    }\n-}\n-\n-impl RecoverKey<'tcx> for DefId {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx)\n-    }\n-}\n-\n-impl RecoverKey<'tcx> for DefIndex {\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.index)\n-    }\n-}\n-\n-trait DepNodeParams<'tcx>: fmt::Debug {\n+pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool;\n \n     /// This method turns the parameters of a DepNodeConstructor into an opaque\n@@ -400,6 +376,14 @@ trait DepNodeParams<'tcx>: fmt::Debug {\n     fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", self)\n     }\n+\n+    /// This method tries to recover the query key from the given `DepNode`,\n+    /// something which is needed when forcing `DepNode`s during red-green\n+    /// evaluation. The query system will only call this method if\n+    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// It is always valid to return `None` here, in which case incremental\n+    /// compilation will treat the query as having changed instead of forcing it.\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n }\n \n impl<'tcx, T> DepNodeParams<'tcx> for T\n@@ -420,6 +404,10 @@ where\n     default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n         format!(\"{:?}\", *self)\n     }\n+\n+    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n+        None\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for DefId {\n@@ -432,6 +420,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(*self)\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n@@ -444,6 +436,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.def_path_str(DefId::local(*self))\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.index)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n@@ -457,6 +453,10 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n         tcx.crate_name(*self).to_string()\n     }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.krate)\n+    }\n }\n \n impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {"}, {"sha": "1fbd90743f402e764212ab57b8cfdca142f4f36b", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -6,7 +6,8 @@ mod query;\n mod safe;\n mod serialized;\n \n-pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, RecoverKey, WorkProductId};\n+pub(crate) use self::dep_node::DepNodeParams;\n+pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, WorkProductId};\n pub use self::graph::WorkProductFileKind;\n pub use self::graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n pub use self::prev::PreviousDepGraph;"}, {"sha": "11e9acf3a3912828fd6657eab393a6b5c5ed5be6", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepKind, DepNode, RecoverKey, SerializedDepNodeIndex};\n+use crate::dep_graph::SerializedDepNodeIndex;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n@@ -60,6 +60,11 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n+        query analysis(key: CrateNum) -> Result<(), ErrorReported> {\n+            eval_always\n+            desc { \"running analysis passes on this crate\" }\n+        }\n+\n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to its\n         /// associated generics.\n         query generics_of(key: DefId) -> &'tcx ty::Generics {\n@@ -195,7 +200,6 @@ rustc_queries! {\n             // queries). Making it anonymous avoids hashing the result, which\n             // may save a bit of time.\n             anon\n-            no_force\n             desc { \"erasing regions from `{:?}`\", ty }\n         }\n \n@@ -204,7 +208,6 @@ rustc_queries! {\n         }\n \n         query program_clauses_for_env(_: traits::Environment<'tcx>) -> Clauses<'tcx> {\n-            no_force\n             desc { \"generating chalk-style clauses for environment\" }\n         }\n \n@@ -247,7 +250,6 @@ rustc_queries! {\n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n-            no_force\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n                 let id = tcx.hir().as_local_hir_id(key.1).unwrap();\n                 tcx.hir().ty_param_name(id)\n@@ -503,7 +505,6 @@ rustc_queries! {\n         /// form to be used outside of const eval.\n         query const_eval_raw(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalRawResult<'tcx> {\n-            no_force\n             desc { |tcx|\n                 \"const-evaluating `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n@@ -520,7 +521,6 @@ rustc_queries! {\n         /// `tcx.const_eval_resolve`, `tcx.const_eval_instance`, or `tcx.const_eval_global_id`.\n         query const_eval_validated(key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalResult<'tcx> {\n-            no_force\n             desc { |tcx|\n                 \"const-evaluating + checking `{}`\",\n                 tcx.def_path_str(key.value.instance.def.def_id())\n@@ -535,7 +535,6 @@ rustc_queries! {\n         query const_field(\n             key: ty::ParamEnvAnd<'tcx, (&'tcx ty::Const<'tcx>, mir::Field)>\n         ) -> ConstValue<'tcx> {\n-            no_force\n             desc { \"extract field of const\" }\n         }\n \n@@ -544,19 +543,16 @@ rustc_queries! {\n         query destructure_const(\n             key: ty::ParamEnvAnd<'tcx, &'tcx ty::Const<'tcx>>\n         ) -> mir::DestructuredConst<'tcx> {\n-            no_force\n             desc { \"destructure constant\" }\n         }\n \n         query const_caller_location(key: (rustc_span::Symbol, u32, u32)) -> ConstValue<'tcx> {\n-            no_force\n             desc { \"get a &core::panic::Location referring to a span\" }\n         }\n \n         query lit_to_const(\n             key: LitToConstInput<'tcx>\n         ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n-            no_force\n             desc { \"converting literal to const\" }\n         }\n     }\n@@ -587,15 +583,13 @@ rustc_queries! {\n         query region_scope_tree(_: DefId) -> &'tcx region::ScopeTree {}\n \n         query mir_shims(key: ty::InstanceDef<'tcx>) -> &'tcx mir::BodyAndCache<'tcx> {\n-            no_force\n             desc { |tcx| \"generating MIR shim for `{}`\", tcx.def_path_str(key.def_id()) }\n         }\n \n         /// The `symbol_name` query provides the symbol name for calling a\n         /// given instance from the local crate. In particular, it will also\n         /// look up the correct symbol name of instances from upstream crates.\n         query symbol_name(key: ty::Instance<'tcx>) -> ty::SymbolName {\n-            no_force\n             desc { \"computing the symbol for `{}`\", key }\n             cache_on_disk_if { true }\n         }\n@@ -642,7 +636,6 @@ rustc_queries! {\n     Other {\n         query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n                             -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-            no_force\n             desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n         }\n     }\n@@ -651,7 +644,6 @@ rustc_queries! {\n         query codegen_fulfill_obligation(\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n         ) -> Option<Vtable<'tcx, ()>> {\n-            no_force\n             cache_on_disk_if { true }\n             desc { |tcx|\n                 \"checking if `{}` fulfills its obligations\",\n@@ -683,22 +675,18 @@ rustc_queries! {\n         /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n         query is_copy_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is `Copy`\", env.value }\n         }\n         /// Query backing `TyS::is_sized`.\n         query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is `Sized`\", env.value }\n         }\n         /// Query backing `TyS::is_freeze`.\n         query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` is freeze\", env.value }\n         }\n         /// Query backing `TyS::needs_drop`.\n         query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-            no_force\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n@@ -712,7 +700,6 @@ rustc_queries! {\n         query layout_raw(\n             env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {\n-            no_force\n             desc { \"computing layout of `{}`\", env.value }\n         }\n     }\n@@ -768,7 +755,6 @@ rustc_queries! {\n \n     TypeChecking {\n         query specializes(_: (DefId, DefId)) -> bool {\n-            no_force\n             desc { \"computing whether impls specialize one another\" }\n         }\n         query in_scope_traits_map(_: DefIndex)\n@@ -853,7 +839,6 @@ rustc_queries! {\n         ///       (like `Clone::clone` for example).\n         query upstream_drop_glue_for(substs: SubstsRef<'tcx>) -> Option<CrateNum> {\n             desc { \"available upstream drop-glue for `{:?}`\", substs }\n-            no_force\n         }\n     }\n \n@@ -898,7 +883,6 @@ rustc_queries! {\n     TypeChecking {\n         query implementations_of_trait(_: (CrateNum, DefId))\n             -> &'tcx [DefId] {\n-            no_force\n             desc { \"looking up implementations of a trait in a crate\" }\n         }\n         query all_trait_implementations(_: CrateNum)\n@@ -1065,7 +1049,6 @@ rustc_queries! {\n         }\n         query is_codegened_item(_: DefId) -> bool {}\n         query codegen_unit(_: Symbol) -> Arc<CodegenUnit<'tcx>> {\n-            no_force\n             desc { \"codegen_unit\" }\n         }\n         query backend_optimization_level(_: CrateNum) -> OptLevel {\n@@ -1088,15 +1071,13 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n         /// Do not call this query directly: invoke `normalize_erasing_regions` instead.\n         query normalize_ty_after_erasing_regions(\n             goal: ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Ty<'tcx> {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1106,7 +1087,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Vec<OutlivesBound<'tcx>>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"computing implied outlives bounds for `{:?}`\", goal }\n         }\n \n@@ -1117,7 +1097,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, DropckOutlivesResult<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"computing dropck types for `{:?}`\", goal }\n         }\n \n@@ -1126,7 +1105,6 @@ rustc_queries! {\n         query evaluate_obligation(\n             goal: CanonicalPredicateGoal<'tcx>\n         ) -> Result<traits::EvaluationResult, traits::OverflowError> {\n-            no_force\n             desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n         }\n \n@@ -1137,7 +1115,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_ascribe_user_type` `{:?}`\", goal }\n         }\n \n@@ -1148,7 +1125,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_eq` `{:?}`\", goal }\n         }\n \n@@ -1159,7 +1135,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_subtype` `{:?}`\", goal }\n         }\n \n@@ -1170,7 +1145,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"evaluating `type_op_prove_predicate` `{:?}`\", goal }\n         }\n \n@@ -1181,7 +1155,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, Ty<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1192,7 +1165,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::Predicate<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1203,7 +1175,6 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::PolyFnSig<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n@@ -1214,12 +1185,10 @@ rustc_queries! {\n             &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ty::FnSig<'tcx>>>,\n             NoSolution,\n         > {\n-            no_force\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n         query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n-            no_force\n             desc { |tcx|\n                 \"testing substituted normalized predicates:`{}`\",\n                 tcx.def_path_str(key.0)\n@@ -1229,7 +1198,6 @@ rustc_queries! {\n         query method_autoderef_steps(\n             goal: CanonicalTyGoal<'tcx>\n         ) -> MethodAutoderefStepsResult<'tcx> {\n-            no_force\n             desc { \"computing autoderef types for `{:?}`\", goal }\n         }\n     }\n@@ -1243,7 +1211,6 @@ rustc_queries! {\n         // Get an estimate of the size of an InstanceDef based on its MIR for CGU partitioning.\n         query instance_def_size_estimate(def: ty::InstanceDef<'tcx>)\n             -> usize {\n-            no_force\n             desc { |tcx| \"estimating size for `{}`\", tcx.def_path_str(def.def_id()) }\n         }\n "}, {"sha": "178c2362def6e9db554cbdef6f8c67c63c2048f5", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -2,11 +2,10 @@ use crate::dep_graph::SerializedDepNodeIndex;\n use crate::dep_graph::{DepKind, DepNode};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n-use crate::ty::query::queries;\n use crate::ty::query::{Query, QueryState};\n use crate::ty::TyCtxt;\n use rustc_data_structures::profiling::ProfileCategory;\n-use rustc_hir::def_id::{CrateNum, DefId};\n+use rustc_hir::def_id::DefId;\n \n use crate::ich::StableHashingContext;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -87,9 +86,3 @@ where\n         bug!(\"QueryDescription::load_from_disk() called for an unsupported query.\")\n     }\n }\n-\n-impl<'tcx> QueryDescription<'tcx> for queries::analysis<'tcx> {\n-    fn describe(_tcx: TyCtxt<'_>, _: CrateNum) -> Cow<'static, str> {\n-        \"running analysis passes on this crate\".into()\n-    }\n-}"}, {"sha": "8adb828fbebc4467876a0f7de758bea32ad4ebb0", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 104, "deletions": 8, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{self, DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepConstructor, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n@@ -60,8 +60,8 @@ use std::sync::Arc;\n \n #[macro_use]\n mod plumbing;\n+pub use self::plumbing::CycleError;\n use self::plumbing::*;\n-pub use self::plumbing::{force_from_dep_node, CycleError};\n \n mod stats;\n pub use self::stats::print_stats;\n@@ -104,9 +104,105 @@ pub use self::profiling_support::{IntoSelfProfilingString, QueryKeyStringBuilder\n // Queries marked with `fatal_cycle` do not need the latter implementation,\n // as they will raise an fatal error on query cycles instead.\n \n-rustc_query_append! { [define_queries!][ <'tcx>\n-    Other {\n-        /// Runs analysis passes on the crate.\n-        [eval_always] fn analysis: Analysis(CrateNum) -> Result<(), ErrorReported>,\n-    },\n-]}\n+rustc_query_append! { [define_queries!][<'tcx>] }\n+\n+/// The red/green evaluation system will try to mark a specific DepNode in the\n+/// dependency graph as green by recursively trying to mark the dependencies of\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+/// where we don't know if it is red or green and we therefore actually have\n+/// to recompute its value in order to find out. Since the only piece of\n+/// information that we have at that point is the `DepNode` we are trying to\n+/// re-evaluate, we need some way to re-run a query from just that. This is what\n+/// `force_from_dep_node()` implements.\n+///\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+/// is usually constructed by computing a stable hash of the query-key that the\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+/// back from hash to query-key (since hash functions are not reversible). For\n+/// this reason `force_from_dep_node()` is expected to fail from time to time\n+/// because we just cannot find out, from the `DepNode` alone, what the\n+/// corresponding query-key is and therefore cannot re-run the query.\n+///\n+/// The system deals with this case letting `try_mark_green` fail which forces\n+/// the root query to be re-evaluated.\n+///\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+/// Fortunately, we can use some contextual information that will allow us to\n+/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+/// valid `DefPathHash`. Since we also always build a huge table that maps every\n+/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+/// everything we need to re-run the query.\n+///\n+/// Take the `mir_validated` query as an example. Like many other queries, it\n+/// just has a single parameter: the `DefId` of the item it will compute the\n+/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+/// `DefId` in `tcx.def_path_hash_to_def_id`.\n+///\n+/// When you implement a new query, it will likely have a corresponding new\n+/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n+/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+/// add it to the \"We don't have enough information to reconstruct...\" group in\n+/// the match below.\n+pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n+    use crate::dep_graph::DepKind;\n+\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n+    // would always end up having to evaluate the first caller of the\n+    // `codegen_unit` query that *is* reconstructible. This might very well be\n+    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n+    // to re-trigger calling the `codegen_unit` query with the right key. At\n+    // that point we would already have re-done all the work we are trying to\n+    // avoid doing in the first place.\n+    // The solution is simple: Just explicitly call the `codegen_unit` query for\n+    // each CGU, right after partitioning. This way `try_mark_green` will always\n+    // hit the cache instead of having to go through `force_from_dep_node`.\n+    // This assertion makes sure, we actually keep applying the solution above.\n+    debug_assert!(\n+        dep_node.kind != DepKind::codegen_unit,\n+        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n+    );\n+\n+    if !dep_node.kind.can_reconstruct_query_key() {\n+        return false;\n+    }\n+\n+    rustc_dep_node_force!([dep_node, tcx]\n+        // These are inputs that are expected to be pre-allocated and that\n+        // should therefore always be red or green already.\n+        DepKind::AllLocalTraitImpls |\n+        DepKind::CrateMetadata |\n+        DepKind::HirBody |\n+        DepKind::Hir |\n+\n+        // These are anonymous nodes.\n+        DepKind::TraitSelect |\n+\n+        // We don't have enough information to reconstruct the query key of\n+        // these.\n+        DepKind::CompileCodegenUnit => {\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+        }\n+    );\n+\n+    false\n+}\n+\n+impl DepNode {\n+    /// Check whether the query invocation corresponding to the given\n+    /// DepNode is eligible for on-disk-caching. If so, this is method\n+    /// will execute the query corresponding to the given DepNode.\n+    /// Also, as a sanity check, it expects that the corresponding query\n+    /// invocation has been marked as green already.\n+    pub fn try_load_from_on_disk_cache<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n+        use crate::dep_graph::DepKind;\n+\n+        rustc_dep_node_try_load_from_on_disk_cache!(self, tcx)\n+    }\n+}"}, {"sha": "acf67f52dceaa94ebe9bb50ebd6a4979e78cf73c", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 104, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -2,7 +2,7 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use crate::dep_graph::{DepKind, DepNode, DepNodeIndex, SerializedDepNodeIndex};\n+use crate::dep_graph::{DepNode, DepNodeIndex, SerializedDepNodeIndex};\n use crate::ty::query::caches::QueryCache;\n use crate::ty::query::config::{QueryAccessors, QueryDescription};\n use crate::ty::query::job::{QueryInfo, QueryJob, QueryJobId, QueryShardJobId};\n@@ -720,7 +720,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[allow(dead_code)]\n-    fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n+    pub(super) fn force_query<Q: QueryDescription<'tcx> + 'tcx>(\n         self,\n         key: Q::Key,\n         span: Span,\n@@ -1162,105 +1162,3 @@ macro_rules! define_provider_struct {\n         }\n     };\n }\n-\n-/// The red/green evaluation system will try to mark a specific DepNode in the\n-/// dependency graph as green by recursively trying to mark the dependencies of\n-/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-/// where we don't know if it is red or green and we therefore actually have\n-/// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the `DepNode` we are trying to\n-/// re-evaluate, we need some way to re-run a query from just that. This is what\n-/// `force_from_dep_node()` implements.\n-///\n-/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-/// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-/// is usually constructed by computing a stable hash of the query-key that the\n-/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-/// back from hash to query-key (since hash functions are not reversible). For\n-/// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the `DepNode` alone, what the\n-/// corresponding query-key is and therefore cannot re-run the query.\n-///\n-/// The system deals with this case letting `try_mark_green` fail which forces\n-/// the root query to be re-evaluated.\n-///\n-/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-/// Fortunately, we can use some contextual information that will allow us to\n-/// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-/// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-/// valid `DefPathHash`. Since we also always build a huge table that maps every\n-/// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-/// everything we need to re-run the query.\n-///\n-/// Take the `mir_validated` query as an example. Like many other queries, it\n-/// just has a single parameter: the `DefId` of the item it will compute the\n-/// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-/// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-/// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-/// `DefId` in `tcx.def_path_hash_to_def_id`.\n-///\n-/// When you implement a new query, it will likely have a corresponding new\n-/// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n-/// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-/// add it to the \"We don't have enough information to reconstruct...\" group in\n-/// the match below.\n-pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n-    use crate::dep_graph::RecoverKey;\n-\n-    // We must avoid ever having to call `force_from_dep_node()` for a\n-    // `DepNode::codegen_unit`:\n-    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n-    // would always end up having to evaluate the first caller of the\n-    // `codegen_unit` query that *is* reconstructible. This might very well be\n-    // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n-    // to re-trigger calling the `codegen_unit` query with the right key. At\n-    // that point we would already have re-done all the work we are trying to\n-    // avoid doing in the first place.\n-    // The solution is simple: Just explicitly call the `codegen_unit` query for\n-    // each CGU, right after partitioning. This way `try_mark_green` will always\n-    // hit the cache instead of having to go through `force_from_dep_node`.\n-    // This assertion makes sure, we actually keep applying the solution above.\n-    debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n-        \"calling force_from_dep_node() on DepKind::codegen_unit\"\n-    );\n-\n-    if !dep_node.kind.can_reconstruct_query_key() {\n-        return false;\n-    }\n-\n-    rustc_dep_node_force!([dep_node, tcx]\n-        // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already.\n-        DepKind::AllLocalTraitImpls |\n-        DepKind::CrateMetadata |\n-        DepKind::HirBody |\n-        DepKind::Hir |\n-\n-        // These are anonymous nodes.\n-        DepKind::TraitSelect |\n-\n-        // We don't have enough information to reconstruct the query key of\n-        // these.\n-        DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n-        }\n-\n-        DepKind::Analysis => {\n-            let def_id = if let Some(def_id) = dep_node.extract_def_id(tcx) {\n-                def_id\n-            } else {\n-                // Return from the whole function.\n-                return false\n-            };\n-            tcx.force_query::<crate::ty::query::queries::analysis<'_>>(\n-                def_id.krate,\n-                DUMMY_SP,\n-                *dep_node\n-            );\n-        }\n-    );\n-\n-    true\n-}"}, {"sha": "56b7be2f7e2d531912a1aa88c04a7dbd868dc871", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 21, "deletions": 52, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=5b08aad6d9630299d9fdc06fdd4d00c79d2eedd6", "patch": "@@ -51,9 +51,6 @@ enum QueryModifier {\n     /// Don't hash the result, instead just mark a query red if it runs\n     NoHash,\n \n-    /// Don't force the query\n-    NoForce,\n-\n     /// Generate a dep node based on the dependencies of the query\n     Anon,\n \n@@ -118,8 +115,6 @@ impl Parse for QueryModifier {\n             Ok(QueryModifier::CycleDelayBug)\n         } else if modifier == \"no_hash\" {\n             Ok(QueryModifier::NoHash)\n-        } else if modifier == \"no_force\" {\n-            Ok(QueryModifier::NoForce)\n         } else if modifier == \"anon\" {\n             Ok(QueryModifier::Anon)\n         } else if modifier == \"eval_always\" {\n@@ -222,9 +217,6 @@ struct QueryModifiers {\n     /// Don't hash the result, instead just mark a query red if it runs\n     no_hash: bool,\n \n-    /// Don't force the query\n-    no_force: bool,\n-\n     /// Generate a dep node based on the dependencies of the query\n     anon: bool,\n \n@@ -241,7 +233,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n     let mut fatal_cycle = false;\n     let mut cycle_delay_bug = false;\n     let mut no_hash = false;\n-    let mut no_force = false;\n     let mut anon = false;\n     let mut eval_always = false;\n     for modifier in query.modifiers.0.drain(..) {\n@@ -288,12 +279,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n                 }\n                 no_hash = true;\n             }\n-            QueryModifier::NoForce => {\n-                if no_force {\n-                    panic!(\"duplicate modifier `no_force` for query `{}`\", query.name);\n-                }\n-                no_force = true;\n-            }\n             QueryModifier::Anon => {\n                 if anon {\n                     panic!(\"duplicate modifier `anon` for query `{}`\", query.name);\n@@ -316,7 +301,6 @@ fn process_modifiers(query: &mut Query) -> QueryModifiers {\n         fatal_cycle,\n         cycle_delay_bug,\n         no_hash,\n-        no_force,\n         anon,\n         eval_always,\n     }\n@@ -425,7 +409,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut dep_node_def_stream = quote! {};\n     let mut dep_node_force_stream = quote! {};\n     let mut try_load_from_on_disk_cache_stream = quote! {};\n-    let mut no_force_queries = Vec::new();\n     let mut cached_queries = quote! {};\n \n     for group in groups.0 {\n@@ -444,19 +427,19 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 cached_queries.extend(quote! {\n                     #name,\n                 });\n-            }\n \n-            if modifiers.cache.is_some() && !modifiers.no_force {\n                 try_load_from_on_disk_cache_stream.extend(quote! {\n                     DepKind::#name => {\n-                        debug_assert!(tcx.dep_graph\n-                                         .node_color(self)\n-                                         .map(|c| c.is_green())\n-                                         .unwrap_or(false));\n-\n-                        let key = RecoverKey::recover(tcx, self).unwrap();\n-                        if queries::#name::cache_on_disk(tcx, key, None) {\n-                            let _ = tcx.#name(key);\n+                        if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                            debug_assert!($tcx.dep_graph\n+                                            .node_color($dep_node)\n+                                            .map(|c| c.is_green())\n+                                            .unwrap_or(false));\n+\n+                            let key = <#arg as DepNodeParams>::recover($tcx, $dep_node).unwrap();\n+                            if queries::#name::cache_on_disk($tcx, key, None) {\n+                                let _ = $tcx.#name(key);\n+                            }\n                         }\n                     }\n                 });\n@@ -501,24 +484,21 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 [#attribute_stream] #name(#arg),\n             });\n \n-            if modifiers.no_force {\n-                no_force_queries.push(name.clone());\n-            } else {\n-                // Add a match arm to force the query given the dep node\n-                dep_node_force_stream.extend(quote! {\n-                    DepKind::#name => {\n-                        if let Some(key) = RecoverKey::recover($tcx, $dep_node) {\n+            // Add a match arm to force the query given the dep node\n+            dep_node_force_stream.extend(quote! {\n+                DepKind::#name => {\n+                    if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if let Some(key) = <#arg as DepNodeParams>::recover($tcx, $dep_node) {\n                             $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n                                 key,\n                                 DUMMY_SP,\n                                 *$dep_node\n                             );\n-                        } else {\n-                            return false;\n+                            return true;\n                         }\n                     }\n-                });\n-            }\n+                }\n+            });\n \n             add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n@@ -528,12 +508,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n         });\n     }\n \n-    // Add an arm for the no force queries to panic when trying to force them\n-    for query in no_force_queries {\n-        dep_node_force_stream.extend(quote! {\n-            DepKind::#query |\n-        });\n-    }\n     dep_node_force_stream.extend(quote! {\n         DepKind::Null => {\n             bug!(\"Cannot force dep node: {:?}\", $dep_node)\n@@ -577,14 +551,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n         #query_description_stream\n \n-        impl DepNode {\n-            /// Check whether the query invocation corresponding to the given\n-            /// DepNode is eligible for on-disk-caching. If so, this is method\n-            /// will execute the query corresponding to the given DepNode.\n-            /// Also, as a sanity check, it expects that the corresponding query\n-            /// invocation has been marked as green already.\n-            pub fn try_load_from_on_disk_cache(&self, tcx: TyCtxt<'_>) {\n-                match self.kind {\n+        macro_rules! rustc_dep_node_try_load_from_on_disk_cache {\n+            ($dep_node:expr, $tcx:expr) => {\n+                match $dep_node.kind {\n                     #try_load_from_on_disk_cache_stream\n                     _ => (),\n                 }"}]}