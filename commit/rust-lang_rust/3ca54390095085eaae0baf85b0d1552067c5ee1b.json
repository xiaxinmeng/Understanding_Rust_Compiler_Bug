{"sha": "3ca54390095085eaae0baf85b0d1552067c5ee1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjYTU0MzkwMDk1MDg1ZWFhZTBiYWY4NWIwZDE1NTIwNjdjNWVlMWI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T01:44:41Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-24T06:38:34Z"}, "message": "Rollup merge of #22700 - nick29581:ints_hash, r=alexcrichton\n\n fmt and hash are pretty straightforward I think. sync is a bit more complex. I thought one or two of the `isize`s ought to be `i32`s, but that would require a bunch of casting (the root cause being the lack of atomics other than isize/usize).\n\nr? @alexcrichton", "tree": {"sha": "e50973fda6443d39eda491461c4da0f6ddf3f08f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e50973fda6443d39eda491461c4da0f6ddf3f08f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ca54390095085eaae0baf85b0d1552067c5ee1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ca54390095085eaae0baf85b0d1552067c5ee1b", "html_url": "https://github.com/rust-lang/rust/commit/3ca54390095085eaae0baf85b0d1552067c5ee1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ca54390095085eaae0baf85b0d1552067c5ee1b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaacc7aad5817ca10277ea6658d6e23b88d4cf77", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaacc7aad5817ca10277ea6658d6e23b88d4cf77", "html_url": "https://github.com/rust-lang/rust/commit/eaacc7aad5817ca10277ea6658d6e23b88d4cf77"}, {"sha": "1db684f67ad277ab7a002ee238872ca68fb13b27", "url": "https://api.github.com/repos/rust-lang/rust/commits/1db684f67ad277ab7a002ee238872ca68fb13b27", "html_url": "https://github.com/rust-lang/rust/commit/1db684f67ad277ab7a002ee238872ca68fb13b27"}], "stats": {"total": 485, "additions": 253, "deletions": 232}, "files": [{"sha": "f92e631c1f25c4becc028f0056484346b26fa603", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -40,10 +40,10 @@ pub enum ExponentFormat {\n pub enum SignificantDigits {\n     /// At most the given number of digits will be printed, truncating any\n     /// trailing zeroes.\n-    DigMax(uint),\n+    DigMax(usize),\n \n     /// Precisely the given number of digits will be printed.\n-    DigExact(uint)\n+    DigExact(usize)\n }\n \n /// How to emit the sign of a number.\n@@ -240,27 +240,27 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == b'-'\n-                    || buf[i as uint] == b'+' {\n-                        for j in (i as uint + 1..end).rev() {\n+                    || buf[i as usize] == b'-'\n+                    || buf[i as usize] == b'+' {\n+                        for j in (i as usize + 1..end).rev() {\n                             buf[j + 1] = buf[j];\n                         }\n-                        buf[(i + 1) as uint] = value2ascii(1);\n+                        buf[(i + 1) as usize] = value2ascii(1);\n                         end += 1;\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == b'.' { i -= 1; continue; }\n+                    if buf[i as usize] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(buf[i as usize]);\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        buf[i as usize] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        buf[i as usize] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -311,7 +311,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             struct Filler<'a> {\n                 buf: &'a mut [u8],\n-                end: &'a mut uint,\n+                end: &'a mut usize,\n             }\n \n             impl<'a> fmt::Write for Filler<'a> {"}, {"sha": "0bf44dd77aaa199a939a505974232b581f54aee6", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -110,11 +110,14 @@ pub trait Write {\n /// traits.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {\n-    flags: uint,\n+    #[cfg(not(stage0))]\n+    flags: u32,\n+    #[cfg(stage0)]\n+    flags: usize,\n     fill: char,\n     align: rt::v1::Alignment,\n-    width: Option<uint>,\n-    precision: Option<uint>,\n+    width: Option<usize>,\n+    precision: Option<usize>,\n \n     buf: &'a mut (Write+'a),\n     curarg: slice::Iter<'a, ArgumentV1<'a>>,\n@@ -140,7 +143,7 @@ pub struct ArgumentV1<'a> {\n \n impl<'a> ArgumentV1<'a> {\n     #[inline(never)]\n-    fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n+    fn show_usize(x: &usize, f: &mut Formatter) -> Result {\n         Display::fmt(x, f)\n     }\n \n@@ -156,15 +159,22 @@ impl<'a> ArgumentV1<'a> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[doc(hidden)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_uint(x: &uint) -> ArgumentV1 {\n-        ArgumentV1::new(x, ArgumentV1::show_uint)\n+        ArgumentV1::new(x, ArgumentV1::show_usize)\n+    }\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn from_usize(x: &usize) -> ArgumentV1 {\n+        ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n \n-    fn as_uint(&self) -> Option<uint> {\n-        if self.formatter as uint == ArgumentV1::show_uint as uint {\n-            Some(unsafe { *(self.value as *const _ as *const uint) })\n+    fn as_usize(&self) -> Option<usize> {\n+        if self.formatter as usize == ArgumentV1::show_usize as usize {\n+            Some(unsafe { *(self.value as *const _ as *const usize) })\n         } else {\n             None\n         }\n@@ -194,7 +204,7 @@ impl<'a> Arguments<'a> {\n     /// The `pieces` array must be at least as long as `fmt` to construct\n     /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -402,15 +412,15 @@ impl<'a> Formatter<'a> {\n         (value.formatter)(value.value, self)\n     }\n \n-    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<uint> {\n+    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n         match *cnt {\n             rt::v1::Count::Is(n) => Some(n),\n             rt::v1::Count::Implied => None,\n             rt::v1::Count::Param(i) => {\n-                self.args[i].as_uint()\n+                self.args[i].as_usize()\n             }\n             rt::v1::Count::NextParam => {\n-                self.curarg.next().and_then(|arg| arg.as_uint())\n+                self.curarg.next().and_then(|arg| arg.as_usize())\n             }\n         }\n     }\n@@ -444,12 +454,12 @@ impl<'a> Formatter<'a> {\n         let mut sign = None;\n         if !is_positive {\n             sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagV1::SignPlus as uint)) != 0 {\n+        } else if self.flags & (1 << (FlagV1::SignPlus as u32)) != 0 {\n             sign = Some('+'); width += 1;\n         }\n \n         let mut prefixed = false;\n-        if self.flags & (1 << (FlagV1::Alternate as uint)) != 0 {\n+        if self.flags & (1 << (FlagV1::Alternate as u32)) != 0 {\n             prefixed = true; width += prefix.char_len();\n         }\n \n@@ -479,7 +489,7 @@ impl<'a> Formatter<'a> {\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n-            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as uint)) != 0 => {\n+            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as u32)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n                 self.with_padding(min - width, Alignment::Right, |f| {\n@@ -549,7 +559,7 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: uint, default: Alignment,\n+    fn with_padding<F>(&mut self, padding: usize, default: Alignment,\n                        f: F) -> Result\n         where F: FnOnce(&mut Formatter) -> Result,\n     {\n@@ -595,6 +605,11 @@ impl<'a> Formatter<'a> {\n         write(self.buf, fmt)\n     }\n \n+    #[cfg(not(stage0))]\n+    /// Flags for formatting (packed version of rt::Flag)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn flags(&self) -> u32 { self.flags }\n+    #[cfg(stage0)]\n     /// Flags for formatting (packed version of rt::Flag)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flags(&self) -> usize { self.flags }\n@@ -609,11 +624,11 @@ impl<'a> Formatter<'a> {\n \n     /// Optionally specified integer width that the output should be\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn width(&self) -> Option<uint> { self.width }\n+    pub fn width(&self) -> Option<usize> { self.width }\n \n     /// Optionally specified precision for numeric types\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn precision(&self) -> Option<uint> { self.precision }\n+    pub fn precision(&self) -> Option<usize> { self.precision }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -699,9 +714,9 @@ impl Display for char {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (FlagV1::Alternate as uint);\n-        let ret = LowerHex::fmt(&(*self as uint), f);\n-        f.flags &= !(1 << (FlagV1::Alternate as uint));\n+        f.flags |= 1 << (FlagV1::Alternate as u32);\n+        let ret = LowerHex::fmt(&(*self as u32), f);\n+        f.flags &= !(1 << (FlagV1::Alternate as u32));\n         ret\n     }\n }\n@@ -857,7 +872,7 @@ impl<'a> Debug for &'a (any::Any+'a) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as u32)) == 0 {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n@@ -869,7 +884,7 @@ impl<T: Debug> Debug for [T] {\n             }\n             try!(write!(f, \"{:?}\", *x))\n         }\n-        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as u32)) == 0 {\n             try!(write!(f, \"]\"));\n         }\n         Ok(())"}, {"sha": "0175e21c8da6152b47bfbbae924118a19bc3bc64", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -214,7 +214,7 @@ macro_rules! integer {\n         show! { $Uint with $SU }\n     }\n }\n-integer! { int, uint, \"i\", \"u\" }\n+integer! { isize, usize, \"i\", \"u\" }\n integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }"}, {"sha": "c35611acb81428561ccb4634f72889588e534ec6", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -32,8 +32,12 @@ pub struct FormatSpec {\n     pub fill: char,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub align: Alignment,\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub flags: uint,\n+    pub flags: usize,\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub flags: u32,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub precision: Count,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "edc4b7e10ee49b04b024a3b3076d2f425f12358a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -20,7 +20,7 @@\n //!\n //! #[derive(Hash)]\n //! struct Person {\n-//!     id: uint,\n+//!     id: u32,\n //!     name: String,\n //!     phone: u64,\n //! }\n@@ -38,7 +38,7 @@\n //! use std::hash::{hash, Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n-//!     id: uint,\n+//!     id: u32,\n //!     name: String,\n //!     phone: u64,\n //! }"}, {"sha": "39bcbacdff182c23b137037d007099a58ca17ed8", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -34,13 +34,13 @@ use super::Hasher;\n pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n-    length: uint, // how many bytes we've processed\n+    length: usize, // how many bytes we've processed\n     v0: u64,      // hash state\n     v1: u64,\n     v2: u64,\n     v3: u64,\n     tail: u64, // unprocessed bytes le\n-    ntail: uint,  // how many bytes in tail are valid\n+    ntail: usize,  // how many bytes in tail are valid\n }\n \n // sadly, these macro definitions can't appear later,"}, {"sha": "4e25e51e9a466075c58b49ae0207413b88a8b426", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -24,7 +24,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unicode)]\n \n@@ -65,7 +64,7 @@ pub struct FormatSpec<'a> {\n     /// Optionally specified alignment\n     pub align: Alignment,\n     /// Packed version of various flags provided\n-    pub flags: uint,\n+    pub flags: u32,\n     /// The integer precision to use\n     pub precision: Count<'a>,\n     /// The string width requested for the resulting format\n@@ -82,7 +81,7 @@ pub enum Position<'a> {\n     /// The argument will be in the next position. This is the default.\n     ArgumentNext,\n     /// The argument is located at a specific index.\n-    ArgumentIs(uint),\n+    ArgumentIs(usize),\n     /// The argument has a name.\n     ArgumentNamed(&'a str),\n }\n@@ -121,11 +120,11 @@ pub enum Flag {\n #[derive(Copy, PartialEq)]\n pub enum Count<'a> {\n     /// The count is specified explicitly.\n-    CountIs(uint),\n+    CountIs(usize),\n     /// The count is specified by the argument with the given name.\n     CountIsName(&'a str),\n     /// The count is specified by the argument at the given index.\n-    CountIsParam(uint),\n+    CountIsParam(usize),\n     /// The count is specified by the next parameter.\n     CountIsNextParam,\n     /// The count is implied and cannot be explicitly specified.\n@@ -237,7 +236,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n-    fn string(&mut self, start: uint) -> &'a str {\n+    fn string(&mut self, start: usize) -> &'a str {\n         loop {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n@@ -314,13 +313,13 @@ impl<'a> Parser<'a> {\n         }\n         // Sign flags\n         if self.consume('+') {\n-            spec.flags |= 1 << (FlagSignPlus as uint);\n+            spec.flags |= 1 << (FlagSignPlus as u32);\n         } else if self.consume('-') {\n-            spec.flags |= 1 << (FlagSignMinus as uint);\n+            spec.flags |= 1 << (FlagSignMinus as u32);\n         }\n         // Alternate marker\n         if self.consume('#') {\n-            spec.flags |= 1 << (FlagAlternate as uint);\n+            spec.flags |= 1 << (FlagAlternate as u32);\n         }\n         // Width and precision\n         let mut havewidth = false;\n@@ -333,7 +332,7 @@ impl<'a> Parser<'a> {\n                 spec.width = CountIsParam(0);\n                 havewidth = true;\n             } else {\n-                spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+                spec.flags |= 1 << (FlagSignAwareZeroPad as u32);\n             }\n         }\n         if !havewidth {\n@@ -413,7 +412,7 @@ impl<'a> Parser<'a> {\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n     /// with overflow at all, it's just accumulating digits.\n-    fn integer(&mut self) -> Option<uint> {\n+    fn integer(&mut self) -> Option<usize> {\n         let mut cur = 0;\n         let mut found = false;\n         loop {\n@@ -617,7 +616,7 @@ mod tests {\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n-                flags: (1 << FlagSignMinus as uint),\n+                flags: (1 << FlagSignMinus as u32),\n                 precision: CountImplied,\n                 width: CountImplied,\n                 ty: \"\",\n@@ -628,7 +627,7 @@ mod tests {\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n-                flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n+                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n                 precision: CountImplied,\n                 width: CountImplied,\n                 ty: \"\","}, {"sha": "f697d10d5dfab14ad5f85ee1db0a45569f89fc52", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -33,13 +33,13 @@ use sync::{Mutex, Condvar};\n pub struct Barrier {\n     lock: Mutex<BarrierState>,\n     cvar: Condvar,\n-    num_threads: uint,\n+    num_threads: usize,\n }\n \n // The inner state of a double barrier\n struct BarrierState {\n-    count: uint,\n-    generation_id: uint,\n+    count: usize,\n+    generation_id: usize,\n }\n \n /// A result returned from wait.\n@@ -54,7 +54,7 @@ impl Barrier {\n     /// A barrier will block `n`-1 threads which call `wait` and then wake up\n     /// all threads at once when the `n`th thread calls `wait`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new(n: uint) -> Barrier {\n+    pub fn new(n: usize) -> Barrier {\n         Barrier {\n             lock: Mutex::new(BarrierState {\n                 count: 0,\n@@ -115,7 +115,7 @@ mod tests {\n \n     #[test]\n     fn test_barrier() {\n-        const N: uint = 10;\n+        const N: usize = 10;\n \n         let barrier = Arc::new(Barrier::new(N));\n         let (tx, rx) = channel();"}, {"sha": "aa87abc6e9aacdecce704f680c08911e2888d780", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -327,7 +327,7 @@ impl StaticCondvar {\n     }\n \n     fn verify(&self, mutex: &sys_mutex::Mutex) {\n-        let addr = mutex as *const _ as uint;\n+        let addr = mutex as *const _ as usize;\n         match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n             // If we got out 0, then we have successfully bound the mutex to\n             // this cvar.\n@@ -388,7 +388,7 @@ mod tests {\n \n     #[test]\n     fn notify_all() {\n-        const N: uint = 10;\n+        const N: usize = 10;\n \n         let data = Arc::new((Mutex::new(0), Condvar::new()));\n         let (tx, rx) = channel();"}, {"sha": "2e4155ea35128d070c7854e304a40b58a30a87ac", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -61,17 +61,17 @@ impl SignalToken {\n         wake\n     }\n \n-    /// Convert to an unsafe uint value. Useful for storing in a pipe's state\n+    /// Convert to an unsafe usize value. Useful for storing in a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_to_uint(self) -> uint {\n+    pub unsafe fn cast_to_usize(self) -> usize {\n         mem::transmute(self.inner)\n     }\n \n-    /// Convert from an unsafe uint value. Useful for retrieving a pipe's state\n+    /// Convert from an unsafe usize value. Useful for retrieving a pipe's state\n     /// flag.\n     #[inline]\n-    pub unsafe fn cast_from_uint(signal_ptr: uint) -> SignalToken {\n+    pub unsafe fn cast_from_usize(signal_ptr: usize) -> SignalToken {\n         SignalToken { inner: mem::transmute(signal_ptr) }\n     }\n "}, {"sha": "7bd1f3542eb13828ca4a2806e53a623bc8c68e45", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -94,7 +94,7 @@\n //!\n //! // The call to recv() will return an error because the channel has already\n //! // hung up (or been deallocated)\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! drop(tx);\n //! assert!(rx.recv().is_err());\n //! ```\n@@ -105,7 +105,7 @@\n //! use std::thread;\n //! use std::sync::mpsc::sync_channel;\n //!\n-//! let (tx, rx) = sync_channel::<int>(0);\n+//! let (tx, rx) = sync_channel::<i32>(0);\n //! thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53).unwrap();\n@@ -123,7 +123,7 @@\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! let mut timer = Timer::new().unwrap();\n //! let timeout = timer.oneshot(Duration::seconds(10));\n //!\n@@ -147,7 +147,7 @@\n //! use std::old_io::timer::Timer;\n //! use std::time::Duration;\n //!\n-//! let (tx, rx) = channel::<int>();\n+//! let (tx, rx) = channel::<i32>();\n //! let mut timer = Timer::new().unwrap();\n //!\n //! loop {\n@@ -525,7 +525,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n+pub fn sync_channel<T: Send>(bound: usize) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n@@ -1028,7 +1028,7 @@ mod test {\n     use super::*;\n     use thread;\n \n-    pub fn stress_factor() -> uint {\n+    pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n             Ok(val) => val.parse().unwrap(),\n             Err(..) => 1,\n@@ -1037,7 +1037,7 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n@@ -1058,7 +1058,7 @@ mod test {\n \n     #[test]\n     fn smoke_shared() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n@@ -1068,7 +1068,7 @@ mod test {\n \n     #[test]\n     fn smoke_threads() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n@@ -1077,21 +1077,21 @@ mod test {\n \n     #[test]\n     fn smoke_port_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn smoke_shared_port_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(1).is_err())\n     }\n \n     #[test]\n     fn smoke_shared_port_gone2() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n@@ -1100,7 +1100,7 @@ mod test {\n \n     #[test]\n     fn port_gone_concurrent() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n@@ -1109,7 +1109,7 @@ mod test {\n \n     #[test]\n     fn port_gone_concurrent_shared() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n@@ -1119,7 +1119,7 @@ mod test {\n \n     #[test]\n     fn smoke_chan_gone() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n@@ -1135,7 +1135,7 @@ mod test {\n \n     #[test]\n     fn chan_gone_concurrent() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n@@ -1145,7 +1145,7 @@ mod test {\n \n     #[test]\n     fn stress() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n             for _ in 0..10000 { tx.send(1).unwrap(); }\n         });\n@@ -1157,9 +1157,9 @@ mod test {\n \n     #[test]\n     fn stress_shared() {\n-        static AMT: uint = 10000;\n-        static NTHREADS: uint = 8;\n-        let (tx, rx) = channel::<int>();\n+        static AMT: u32 = 10000;\n+        static NTHREADS: u32 = 8;\n+        let (tx, rx) = channel::<i32>();\n \n         let t = thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n@@ -1184,7 +1184,7 @@ mod test {\n     #[test]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx2, rx2) = channel::<i32>();\n         let t1 = thread::spawn(move|| {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n@@ -1203,7 +1203,7 @@ mod test {\n \n     #[test]\n     fn recv_from_outside_runtime() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n@@ -1217,8 +1217,8 @@ mod test {\n \n     #[test]\n     fn no_runtime() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let t1 = thread::spawn(move|| {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n@@ -1234,21 +1234,21 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (_tx, rx) = channel::<int>();\n+        let (_tx, rx) = channel::<i32>();\n         drop(rx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (tx, _rx) = channel::<int>();\n+        let (tx, _rx) = channel::<i32>();\n         drop(tx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         drop(rx);\n         assert!(tx.send(box 0).is_err());\n     }\n@@ -1257,7 +1257,7 @@ mod test {\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             drop(tx);\n             rx.recv().unwrap();\n         }).join();\n@@ -1267,64 +1267,64 @@ mod test {\n \n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         tx.send(box 10).unwrap();\n         assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         assert!(tx.send(10).is_ok());\n         assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(rx);\n         assert!(tx.send(10).is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         tx.send(10).unwrap();\n         assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n         tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n-        let (_tx, rx) = channel::<int>();\n+        let (_tx, rx) = channel::<i32>();\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n@@ -1334,7 +1334,7 @@ mod test {\n \n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = channel::<Box<int>>();\n+        let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n@@ -1347,7 +1347,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1358,7 +1358,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1371,7 +1371,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = channel::<int>();\n+            let (tx, rx) = channel::<i32>();\n             thread::spawn(move|| {\n                 let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n@@ -1405,7 +1405,7 @@ mod test {\n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: Sender<Box<int>>, i: int) {\n+            fn send(tx: Sender<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1414,7 +1414,7 @@ mod test {\n                 });\n             }\n \n-            fn recv(rx: Receiver<Box<int>>, i: int) {\n+            fn recv(rx: Receiver<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1451,8 +1451,8 @@ mod test {\n \n     #[test]\n     fn test_nested_recv_iter() {\n-        let (tx, rx) = channel::<int>();\n-        let (total_tx, total_rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n+        let (total_tx, total_rx) = channel::<i32>();\n \n         let _t = thread::spawn(move|| {\n             let mut acc = 0;\n@@ -1471,7 +1471,7 @@ mod test {\n \n     #[test]\n     fn test_recv_iter_break() {\n-        let (tx, rx) = channel::<int>();\n+        let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n \n         let _t = thread::spawn(move|| {\n@@ -1496,7 +1496,7 @@ mod test {\n \n     #[test]\n     fn try_recv_states() {\n-        let (tx1, rx1) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n         let _t = thread::spawn(move|| {\n@@ -1550,7 +1550,7 @@ mod sync_tests {\n     use thread;\n     use super::*;\n \n-    pub fn stress_factor() -> uint {\n+    pub fn stress_factor() -> usize {\n         match env::var(\"RUST_TEST_STRESS\") {\n             Ok(val) => val.parse().unwrap(),\n             Err(..) => 1,\n@@ -1559,7 +1559,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n     }\n@@ -1572,7 +1572,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_shared() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         assert_eq!(rx.recv().unwrap(), 1);\n         let tx = tx.clone();\n@@ -1582,7 +1582,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_threads() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n@@ -1591,14 +1591,14 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_port_gone() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn smoke_shared_port_gone2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n@@ -1607,7 +1607,7 @@ mod sync_tests {\n \n     #[test]\n     fn port_gone_concurrent() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n@@ -1616,7 +1616,7 @@ mod sync_tests {\n \n     #[test]\n     fn port_gone_concurrent_shared() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n@@ -1626,7 +1626,7 @@ mod sync_tests {\n \n     #[test]\n     fn smoke_chan_gone() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n@@ -1642,7 +1642,7 @@ mod sync_tests {\n \n     #[test]\n     fn chan_gone_concurrent() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n@@ -1652,7 +1652,7 @@ mod sync_tests {\n \n     #[test]\n     fn stress() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n             for _ in 0..10000 { tx.send(1).unwrap(); }\n         });\n@@ -1663,9 +1663,9 @@ mod sync_tests {\n \n     #[test]\n     fn stress_shared() {\n-        static AMT: uint = 1000;\n-        static NTHREADS: uint = 8;\n-        let (tx, rx) = sync_channel::<int>(0);\n+        static AMT: u32 = 1000;\n+        static NTHREADS: u32 = 8;\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n         thread::spawn(move|| {\n@@ -1692,21 +1692,21 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (_tx, rx) = sync_channel::<int>(0);\n+        let (_tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         drop(tx);\n     }\n \n     #[test]\n     fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         drop(rx);\n         assert!(tx.send(box 0).is_err());\n     }\n@@ -1715,7 +1715,7 @@ mod sync_tests {\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             drop(tx);\n             rx.recv().unwrap();\n         }).join();\n@@ -1725,70 +1725,70 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_single_thread_send_then_recv() {\n-        let (tx, rx) = sync_channel::<Box<int>>(1);\n+        let (tx, rx) = sync_channel::<Box<i32>>(1);\n         tx.send(box 10).unwrap();\n         assert!(rx.recv().unwrap() == box 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_open() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n         assert!(rx.recv().unwrap() == 10);\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(rx);\n         assert_eq!(tx.try_send(10), Err(TrySendError::Disconnected(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_send_closed2() {\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         assert_eq!(tx.try_send(10), Err(TrySendError::Full(10)));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_open() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(10).unwrap();\n         assert!(rx.recv() == Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_try_recv_closed() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_data() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n         tx.send(10).unwrap();\n         assert_eq!(rx.try_recv(), Ok(10));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_close() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Disconnected));\n     }\n \n     #[test]\n     fn oneshot_single_thread_peek_open() {\n-        let (_tx, rx) = sync_channel::<int>(0);\n+        let (_tx, rx) = sync_channel::<i32>(0);\n         assert_eq!(rx.try_recv(), Err(TryRecvError::Empty));\n     }\n \n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n@@ -1798,7 +1798,7 @@ mod sync_tests {\n \n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n-        let (tx, rx) = sync_channel::<Box<int>>(0);\n+        let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n@@ -1811,7 +1811,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1822,7 +1822,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n@@ -1835,7 +1835,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<int>(0);\n+            let (tx, rx) = sync_channel::<i32>(0);\n             let _t = thread::spawn(move|| {\n                 let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n@@ -1853,7 +1853,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<Box<int>>(0);\n+            let (tx, rx) = sync_channel::<Box<i32>>(0);\n             let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n@@ -1864,12 +1864,12 @@ mod sync_tests {\n     #[test]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n-            let (tx, rx) = sync_channel::<Box<int>>(0);\n+            let (tx, rx) = sync_channel::<Box<i32>>(0);\n \n             send(tx, 0);\n             recv(rx, 0);\n \n-            fn send(tx: SyncSender<Box<int>>, i: int) {\n+            fn send(tx: SyncSender<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1878,7 +1878,7 @@ mod sync_tests {\n                 });\n             }\n \n-            fn recv(rx: Receiver<Box<int>>, i: int) {\n+            fn recv(rx: Receiver<Box<i32>>, i: i32) {\n                 if i == 10 { return }\n \n                 thread::spawn(move|| {\n@@ -1915,8 +1915,8 @@ mod sync_tests {\n \n     #[test]\n     fn test_nested_recv_iter() {\n-        let (tx, rx) = sync_channel::<int>(0);\n-        let (total_tx, total_rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n+        let (total_tx, total_rx) = sync_channel::<i32>(0);\n \n         let _t = thread::spawn(move|| {\n             let mut acc = 0;\n@@ -1935,7 +1935,7 @@ mod sync_tests {\n \n     #[test]\n     fn test_recv_iter_break() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n         let _t = thread::spawn(move|| {\n@@ -1960,7 +1960,7 @@ mod sync_tests {\n \n     #[test]\n     fn try_recv_states() {\n-        let (tx1, rx1) = sync_channel::<int>(1);\n+        let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n         let _t = thread::spawn(move|| {\n@@ -2007,29 +2007,29 @@ mod sync_tests {\n \n     #[test]\n     fn send1() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n         let _t =thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send4() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n@@ -2048,20 +2048,20 @@ mod sync_tests {\n \n     #[test]\n     fn try_send1() {\n-        let (tx, _rx) = sync_channel::<int>(0);\n+        let (tx, _rx) = sync_channel::<i32>(0);\n         assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send2() {\n-        let (tx, _rx) = sync_channel::<int>(1);\n+        let (tx, _rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         assert_eq!(tx.try_send(1), Err(TrySendError::Full(1)));\n     }\n \n     #[test]\n     fn try_send3() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n         assert_eq!(tx.try_send(1), Err(TrySendError::Disconnected(1)));"}, {"sha": "f287712d9d45d59bdc2eb7745ed4ddd468092fe0", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -22,7 +22,7 @@\n ///\n /// # Implementation\n ///\n-/// Oneshots are implemented around one atomic uint variable. This variable\n+/// Oneshots are implemented around one atomic usize variable. This variable\n /// indicates both the state of the port/chan but also contains any tasks\n /// blocked on the port. All atomic operations happen on this one word.\n ///\n@@ -45,9 +45,9 @@ use core::mem;\n use sync::atomic::{AtomicUsize, Ordering};\n \n // Various states you can find a port in.\n-const EMPTY: uint = 0;          // initial state: no data, no blocked receiver\n-const DATA: uint = 1;           // data ready for receiver to take\n-const DISCONNECTED: uint = 2;   // channel is disconnected OR upgraded\n+const EMPTY: usize = 0;          // initial state: no data, no blocked receiver\n+const DATA: usize = 1;           // data ready for receiver to take\n+const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // Any other value represents a pointer to a SignalToken value. The\n // protocol ensures that when the state moves *to* a pointer,\n // ownership of the token is given to the packet, and when the state\n@@ -123,7 +123,7 @@ impl<T: Send> Packet<T> {\n             // There is a thread waiting on the other end. We leave the 'DATA'\n             // state inside so it'll pick it up on the other end.\n             ptr => unsafe {\n-                SignalToken::cast_from_uint(ptr).signal();\n+                SignalToken::cast_from_usize(ptr).signal();\n                 Ok(())\n             }\n         }\n@@ -143,15 +143,15 @@ impl<T: Send> Packet<T> {\n         // like we're not empty, then immediately go through to `try_recv`.\n         if self.state.load(Ordering::SeqCst) == EMPTY {\n             let (wait_token, signal_token) = blocking::tokens();\n-            let ptr = unsafe { signal_token.cast_to_uint() };\n+            let ptr = unsafe { signal_token.cast_to_usize() };\n \n             // race with senders to enter the blocking state\n             if self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) == EMPTY {\n                 wait_token.wait();\n                 debug_assert!(self.state.load(Ordering::SeqCst) != EMPTY);\n             } else {\n                 // drop the signal token, since we never blocked\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n             }\n         }\n \n@@ -220,7 +220,7 @@ impl<T: Send> Packet<T> {\n             DISCONNECTED => { self.upgrade = prev; UpDisconnected }\n \n             // If someone's waiting, we gotta wake them up\n-            ptr => UpWoke(unsafe { SignalToken::cast_from_uint(ptr) })\n+            ptr => UpWoke(unsafe { SignalToken::cast_from_usize(ptr) })\n         }\n     }\n \n@@ -230,7 +230,7 @@ impl<T: Send> Packet<T> {\n \n             // If someone's waiting, we gotta wake them up\n             ptr => unsafe {\n-                SignalToken::cast_from_uint(ptr).signal();\n+                SignalToken::cast_from_usize(ptr).signal();\n             }\n         }\n     }\n@@ -283,15 +283,15 @@ impl<T: Send> Packet<T> {\n     // Attempts to start selection on this port. This can either succeed, fail\n     // because there is data, or fail because there is an upgrade pending.\n     pub fn start_selection(&mut self, token: SignalToken) -> SelectionResult<T> {\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         match self.state.compare_and_swap(EMPTY, ptr, Ordering::SeqCst) {\n             EMPTY => SelSuccess,\n             DATA => {\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                 SelCanceled\n             }\n             DISCONNECTED if self.data.is_some() => {\n-                drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                 SelCanceled\n             }\n             DISCONNECTED => {\n@@ -300,15 +300,15 @@ impl<T: Send> Packet<T> {\n                     // propagate upwards whether the upgrade can receive\n                     // data\n                     GoUp(upgrade) => {\n-                        SelUpgraded(unsafe { SignalToken::cast_from_uint(ptr) }, upgrade)\n+                        SelUpgraded(unsafe { SignalToken::cast_from_usize(ptr) }, upgrade)\n                     }\n \n                     // If the other end disconnected without sending an\n                     // upgrade, then we have data to receive (the channel is\n                     // disconnected).\n                     up => {\n                         self.upgrade = up;\n-                        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+                        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n                         SelCanceled\n                     }\n                 }\n@@ -360,7 +360,7 @@ impl<T: Send> Packet<T> {\n \n             // We woke ourselves up from select.\n             ptr => unsafe {\n-                drop(SignalToken::cast_from_uint(ptr));\n+                drop(SignalToken::cast_from_usize(ptr));\n                 Ok(false)\n             }\n         }"}, {"sha": "b6f93b8e0e574ce470608e2e70b6960c36ecb357", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -71,7 +71,7 @@ use sync::mpsc::blocking::{self, SignalToken};\n pub struct Select {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n-    next_id: Cell<uint>,\n+    next_id: Cell<usize>,\n }\n \n impl !marker::Send for Select {}\n@@ -82,7 +82,7 @@ impl !marker::Send for Select {}\n pub struct Handle<'rx, T:'rx> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n-    id: uint,\n+    id: usize,\n     selector: &'rx Select,\n     next: *mut Handle<'static, ()>,\n     prev: *mut Handle<'static, ()>,\n@@ -154,12 +154,12 @@ impl Select {\n     /// the matching `id` will have some sort of event available on it. The\n     /// event could either be that data is available or the corresponding\n     /// channel has been closed.\n-    pub fn wait(&self) -> uint {\n+    pub fn wait(&self) -> usize {\n         self.wait2(true)\n     }\n \n     /// Helper method for skipping the preflight checks during testing\n-    fn wait2(&self, do_preflight_checks: bool) -> uint {\n+    fn wait2(&self, do_preflight_checks: bool) -> usize {\n         // Note that this is currently an inefficient implementation. We in\n         // theory have knowledge about all receivers in the set ahead of time,\n         // so this method shouldn't really have to iterate over all of them yet\n@@ -254,7 +254,7 @@ impl Select {\n impl<'rx, T: Send> Handle<'rx, T> {\n     /// Retrieve the id of this handle.\n     #[inline]\n-    pub fn id(&self) -> uint { self.id }\n+    pub fn id(&self) -> usize { self.id }\n \n     /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n@@ -369,8 +369,8 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         tx1.send(1).unwrap();\n         select! {\n             foo = rx1.recv() => { assert_eq!(foo.unwrap(), 1); },\n@@ -394,11 +394,11 @@ mod test {\n \n     #[test]\n     fn smoke2() {\n-        let (_tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n-        let (_tx3, rx3) = channel::<int>();\n-        let (_tx4, rx4) = channel::<int>();\n-        let (tx5, rx5) = channel::<int>();\n+        let (_tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n+        let (_tx3, rx3) = channel::<i32>();\n+        let (_tx4, rx4) = channel::<i32>();\n+        let (tx5, rx5) = channel::<i32>();\n         tx5.send(4).unwrap();\n         select! {\n             _foo = rx1.recv() => { panic!(\"1\") },\n@@ -411,8 +411,8 @@ mod test {\n \n     #[test]\n     fn closed() {\n-        let (_tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (_tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         drop(tx2);\n \n         select! {\n@@ -423,9 +423,9 @@ mod test {\n \n     #[test]\n     fn unblocks() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n-        let (tx3, rx3) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n+        let (tx3, rx3) = channel::<i32>();\n \n         let _t = thread::spawn(move|| {\n             for _ in 0..20 { thread::yield_now(); }\n@@ -447,8 +447,8 @@ mod test {\n \n     #[test]\n     fn both_ready() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -473,9 +473,9 @@ mod test {\n \n     #[test]\n     fn stress() {\n-        static AMT: int = 10000;\n-        let (tx1, rx1) = channel::<int>();\n-        let (tx2, rx2) = channel::<int>();\n+        static AMT: u32 = 10000;\n+        let (tx1, rx1) = channel::<i32>();\n+        let (tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -500,8 +500,8 @@ mod test {\n \n     #[test]\n     fn cloning() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -522,8 +522,8 @@ mod test {\n \n     #[test]\n     fn cloning2() {\n-        let (tx1, rx1) = channel::<int>();\n-        let (_tx2, rx2) = channel::<int>();\n+        let (tx1, rx1) = channel::<i32>();\n+        let (_tx2, rx2) = channel::<i32>();\n         let (tx3, rx3) = channel::<()>();\n \n         let _t = thread::spawn(move|| {\n@@ -716,7 +716,7 @@ mod test {\n \n     #[test]\n     fn sync1() {\n-        let (tx, rx) = sync_channel::<int>(1);\n+        let (tx, rx) = sync_channel::<i32>(1);\n         tx.send(1).unwrap();\n         select! {\n             n = rx.recv() => { assert_eq!(n.unwrap(), 1); }\n@@ -725,7 +725,7 @@ mod test {\n \n     #[test]\n     fn sync2() {\n-        let (tx, rx) = sync_channel::<int>(0);\n+        let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n             for _ in 0..100 { thread::yield_now() }\n             tx.send(1).unwrap();\n@@ -737,8 +737,8 @@ mod test {\n \n     #[test]\n     fn sync3() {\n-        let (tx1, rx1) = sync_channel::<int>(0);\n-        let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n+        let (tx1, rx1) = sync_channel::<i32>(0);\n+        let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();\n         let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n         let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {"}, {"sha": "8d14824d37feed09e3e0c9916b2b2431b8897b4b", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -101,7 +101,7 @@ impl<T: Send> Packet<T> {\n         token.map(|token| {\n             assert_eq!(self.cnt.load(Ordering::SeqCst), 0);\n             assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-            self.to_wake.store(unsafe { token.cast_to_uint() }, Ordering::SeqCst);\n+            self.to_wake.store(unsafe { token.cast_to_usize() }, Ordering::SeqCst);\n             self.cnt.store(-1, Ordering::SeqCst);\n \n             // This store is a little sketchy. What's happening here is that\n@@ -241,7 +241,7 @@ impl<T: Send> Packet<T> {\n     // Returns true if blocking should proceed.\n     fn decrement(&mut self, token: SignalToken) -> StartResult {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n@@ -258,7 +258,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, Ordering::SeqCst);\n-        drop(unsafe { SignalToken::cast_from_uint(ptr) });\n+        drop(unsafe { SignalToken::cast_from_usize(ptr) });\n         Abort\n     }\n \n@@ -380,7 +380,7 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n \n     ////////////////////////////////////////////////////////////////////////////"}, {"sha": "ce40fa2672ab32555339aca56e87deed24dbf4a9", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -69,7 +69,7 @@ pub struct Queue<T> {\n \n     // Cache maintenance fields. Additions and subtractions are stored\n     // separately in order to allow them to use nonatomic addition/subtraction.\n-    cache_bound: uint,\n+    cache_bound: usize,\n     cache_additions: AtomicUsize,\n     cache_subtractions: AtomicUsize,\n }\n@@ -107,7 +107,7 @@ impl<T: Send> Queue<T> {\n     ///               cache (if desired). If the value is 0, then the cache has\n     ///               no bound. Otherwise, the cache will never grow larger than\n     ///               `bound` (although the queue itself could be much larger.\n-    pub unsafe fn new(bound: uint) -> Queue<T> {\n+    pub unsafe fn new(bound: usize) -> Queue<T> {\n         let n1 = Node::new();\n         let n2 = Node::new();\n         (*n1).next.store(n2, Ordering::Relaxed);\n@@ -319,7 +319,7 @@ mod test {\n             stress_bound(1);\n         }\n \n-        unsafe fn stress_bound(bound: uint) {\n+        unsafe fn stress_bound(bound: usize) {\n             let q = Arc::new(Queue::new(bound));\n \n             let (tx, rx) = channel();"}, {"sha": "5a1e05f9c1565e1e28512f51685cc5b59849b20a", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -43,7 +43,7 @@ pub struct Packet<T> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n-    steals: int, // How many times has a port received without blocking?\n+    steals: isize, // How many times has a port received without blocking?\n     to_wake: AtomicUsize, // SignalToken for the blocked thread to wake up\n \n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n@@ -146,15 +146,15 @@ impl<T: Send> Packet<T> {\n         let ptr = self.to_wake.load(Ordering::SeqCst);\n         self.to_wake.store(0, Ordering::SeqCst);\n         assert!(ptr != 0);\n-        unsafe { SignalToken::cast_from_uint(ptr) }\n+        unsafe { SignalToken::cast_from_usize(ptr) }\n     }\n \n     // Decrements the count on the channel for a sleeper, returning the sleeper\n     // back if it shouldn't sleep. Note that this is the location where we take\n     // steals into account.\n     fn decrement(&mut self, token: SignalToken) -> Result<(), SignalToken> {\n         assert_eq!(self.to_wake.load(Ordering::SeqCst), 0);\n-        let ptr = unsafe { token.cast_to_uint() };\n+        let ptr = unsafe { token.cast_to_usize() };\n         self.to_wake.store(ptr, Ordering::SeqCst);\n \n         let steals = self.steals;\n@@ -171,7 +171,7 @@ impl<T: Send> Packet<T> {\n         }\n \n         self.to_wake.store(0, Ordering::SeqCst);\n-        Err(unsafe { SignalToken::cast_from_uint(ptr) })\n+        Err(unsafe { SignalToken::cast_from_usize(ptr) })\n     }\n \n     pub fn recv(&mut self) -> Result<T, Failure<T>> {\n@@ -350,7 +350,7 @@ impl<T: Send> Packet<T> {\n     }\n \n     // increment the count on the channel (used for selection)\n-    fn bump(&mut self, amt: int) -> int {\n+    fn bump(&mut self, amt: isize) -> isize {\n         match self.cnt.fetch_add(amt, Ordering::SeqCst) {\n             DISCONNECTED => {\n                 self.cnt.store(DISCONNECTED, Ordering::SeqCst);"}, {"sha": "33c1614e1b297dfe7037782d6533c6c6fe19a943", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -64,7 +64,7 @@ struct State<T> {\n     queue: Queue,       // queue of senders waiting to send data\n     blocker: Blocker,   // currently blocked task on this channel\n     buf: Buffer<T>,     // storage for buffered messages\n-    cap: uint,          // capacity of this channel\n+    cap: usize,         // capacity of this channel\n \n     /// A curious flag used to indicate whether a sender failed or succeeded in\n     /// blocking. This is used to transmit information back to the task that it\n@@ -101,8 +101,8 @@ unsafe impl Send for Node {}\n /// A simple ring-buffer\n struct Buffer<T> {\n     buf: Vec<Option<T>>,\n-    start: uint,\n-    size: uint,\n+    start: usize,\n+    size: usize,\n }\n \n #[derive(Debug)]\n@@ -137,7 +137,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n }\n \n impl<T: Send> Packet<T> {\n-    pub fn new(cap: uint) -> Packet<T> {\n+    pub fn new(cap: usize) -> Packet<T> {\n         Packet {\n             channels: AtomicUsize::new(1),\n             lock: Mutex::new(State {\n@@ -442,8 +442,8 @@ impl<T> Buffer<T> {\n         result.take().unwrap()\n     }\n \n-    fn size(&self) -> uint { self.size }\n-    fn cap(&self) -> uint { self.buf.len() }\n+    fn size(&self) -> usize { self.size }\n+    fn cap(&self) -> usize { self.buf.len() }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "02b2db572ec4fe49be4efa50643560b4638c759d", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -50,7 +50,7 @@ use sys_common::mutex as sys;\n /// use std::thread;\n /// use std::sync::mpsc::channel;\n ///\n-/// const N: uint = 10;\n+/// const N: usize = 10;\n ///\n /// // Spawn a few threads to increment a shared variable (non-atomically), and\n /// // let the main thread know once all increments are done.\n@@ -377,9 +377,9 @@ mod test {\n     #[test]\n     fn lots_and_lots() {\n         static M: StaticMutex = MUTEX_INIT;\n-        static mut CNT: uint = 0;\n-        static J: uint = 1000;\n-        static K: uint = 3;\n+        static mut CNT: u32 = 0;\n+        static J: u32 = 1000;\n+        static K: u32 = 3;\n \n         fn inc() {\n             for _ in 0..J {\n@@ -501,7 +501,7 @@ mod test {\n         let arc2 = arc.clone();\n         let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n-                i: Arc<Mutex<int>>,\n+                i: Arc<Mutex<i32>>,\n             }\n             impl Drop for Unwinder {\n                 fn drop(&mut self) {"}, {"sha": "495a172e2453d4fc5539cf9d905658d1f7c5bf58", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -425,8 +425,8 @@ mod tests {\n     #[test]\n     fn frob() {\n         static R: StaticRwLock = RW_LOCK_INIT;\n-        static N: usize = 10;\n-        static M: usize = 1000;\n+        static N: u32 = 10;\n+        static M: u32 = 1000;\n \n         let (tx, rx) = channel::<()>();\n         for _ in 0..N {"}, {"sha": "738aeccbe7aab1488f001aec3e9838b3f203f9ba", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -89,7 +89,7 @@ impl TaskPool {\n     /// # Panics\n     ///\n     /// This function will panic if `threads` is 0.\n-    pub fn new(threads: uint) -> TaskPool {\n+    pub fn new(threads: usize) -> TaskPool {\n         assert!(threads >= 1);\n \n         let (tx, rx) = channel::<Thunk>();\n@@ -142,7 +142,7 @@ mod test {\n     use super::*;\n     use sync::mpsc::channel;\n \n-    const TEST_TASKS: uint = 4;\n+    const TEST_TASKS: u32 = 4;\n \n     #[test]\n     fn test_works() {"}, {"sha": "5d9eeeeda1b82cdf5e9547f8e48c5831990cd527", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -702,6 +702,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs(false),\n                                                                   ast::Sign::new(i))))\n     }\n+    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n+        self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU32)))\n+    }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n     }"}, {"sha": "91262556abd706f72ee4bcc91b90d279d1292221", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ca54390095085eaae0baf85b0d1552067c5ee1b/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=3ca54390095085eaae0baf85b0d1552067c5ee1b", "patch": "@@ -417,7 +417,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     parse::AlignUnknown => align(\"Unknown\"),\n                 };\n                 let align = self.ecx.expr_path(align);\n-                let flags = self.ecx.expr_usize(sp, arg.format.flags);\n+                let flags = self.ecx.expr_u32(sp, arg.format.flags);\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n@@ -610,7 +610,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         ecx.ident_of_std(\"core\"),\n                         ecx.ident_of(\"fmt\"),\n                         ecx.ident_of(\"ArgumentV1\"),\n-                        ecx.ident_of(\"from_uint\")], vec![arg])\n+                        ecx.ident_of(\"from_usize\")], vec![arg])\n             }\n         };\n "}]}