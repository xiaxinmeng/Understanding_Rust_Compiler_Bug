{"sha": "4367e41ea2a105c373de27c2f080fc2527cc6927", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNjdlNDFlYTJhMTA1YzM3M2RlMjdjMmYwODBmYzI1MjdjYzY5Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-12T00:36:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-12T00:36:21Z"}, "message": "Auto merge of #51241 - glandium:globalalloc, r=sfackler,SimonSapin\n\nStabilize GlobalAlloc and #[global_allocator]\n\nThis PR implements the changes discussed in https://github.com/rust-lang/rust/issues/49668#issuecomment-393263510\n\nFixes #49668\nFixes #27389\n\nThis does not change the default global allocator: #36963", "tree": {"sha": "9ca30ec2dbf3311f0a0d0d6275d5abca8f23fc1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ca30ec2dbf3311f0a0d0d6275d5abca8f23fc1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4367e41ea2a105c373de27c2f080fc2527cc6927", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4367e41ea2a105c373de27c2f080fc2527cc6927", "html_url": "https://github.com/rust-lang/rust/commit/4367e41ea2a105c373de27c2f080fc2527cc6927", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4367e41ea2a105c373de27c2f080fc2527cc6927/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9944fde377b8b2575f96fff60f784eddce54002", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9944fde377b8b2575f96fff60f784eddce54002", "html_url": "https://github.com/rust-lang/rust/commit/f9944fde377b8b2575f96fff60f784eddce54002"}, {"sha": "7f0d54d98842c786ab7a140c17c3ea32aea6aead", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f0d54d98842c786ab7a140c17c3ea32aea6aead", "html_url": "https://github.com/rust-lang/rust/commit/7f0d54d98842c786ab7a140c17c3ea32aea6aead"}], "stats": {"total": 1195, "additions": 566, "deletions": 629}, "files": [{"sha": "8f1ba22de8cb1f0b4726fd05b660cd431608a8ab", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=f9944fde377b8b2575f96fff60f784eddce54002", "patch": "@@ -1,72 +0,0 @@\n-# `global_allocator`\n-\n-The tracking issue for this feature is: [#27389]\n-\n-[#27389]: https://github.com/rust-lang/rust/issues/27389\n-\n-------------------------\n-\n-Rust programs may need to change the allocator that they're running with from\n-time to time. This use case is distinct from an allocator-per-collection (e.g. a\n-`Vec` with a custom allocator) and instead is more related to changing the\n-global default allocator, e.g. what `Vec<T>` uses by default.\n-\n-Currently Rust programs don't have a specified global allocator. The compiler\n-may link to a version of [jemalloc] on some platforms, but this is not\n-guaranteed. Libraries, however, like cdylibs and staticlibs are guaranteed\n-to use the \"system allocator\" which means something like `malloc` on Unixes and\n-`HeapAlloc` on Windows.\n-\n-[jemalloc]: https://github.com/jemalloc/jemalloc\n-\n-The `#[global_allocator]` attribute, however, allows configuring this choice.\n-You can use this to implement a completely custom global allocator to route all\n-default allocation requests to a custom object. Defined in [RFC 1974] usage\n-looks like:\n-\n-[RFC 1974]: https://github.com/rust-lang/rfcs/pull/1974\n-\n-```rust\n-#![feature(global_allocator, allocator_api, heap_api)]\n-\n-use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n-use std::ptr::NonNull;\n-\n-struct MyAllocator;\n-\n-unsafe impl GlobalAlloc for MyAllocator {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-        System.alloc(layout)\n-    }\n-\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-        System.dealloc(ptr, layout)\n-    }\n-}\n-\n-#[global_allocator]\n-static GLOBAL: MyAllocator = MyAllocator;\n-\n-fn main() {\n-    // This `Vec` will allocate memory through `GLOBAL` above\n-    let mut v = Vec::new();\n-    v.push(1);\n-}\n-```\n-\n-And that's it! The `#[global_allocator]` attribute is applied to a `static`\n-which implements the `Alloc` trait in the `std::alloc` module. Note, though,\n-that the implementation is defined for `&MyAllocator`, not just `MyAllocator`.\n-You may wish, however, to also provide `Alloc for MyAllocator` for other use\n-cases.\n-\n-A crate can only have one instance of `#[global_allocator]` and this instance\n-may be loaded through a dependency. For example `#[global_allocator]` above\n-could have been placed in one of the dependencies loaded through `extern crate`.\n-\n-Note that `Alloc` itself is an `unsafe` trait, with much documentation on the\n-trait itself about usage and for implementors. Extra care should be taken when\n-implementing a global allocator as well as the allocator may be called from many\n-portions of the standard library, such as the panicking routine. As a result it\n-is highly recommended to not panic during allocation and work in as many\n-situations with as few dependencies as possible as well."}, {"sha": "425d4cb79b2df7e359fbd0c05edd3c8155d3156c", "filename": "src/doc/unstable-book/src/library-features/alloc-jemalloc.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-jemalloc.md?ref=f9944fde377b8b2575f96fff60f784eddce54002", "patch": "@@ -1,13 +0,0 @@\n-# `alloc_jemalloc`\n-\n-The tracking issue for this feature is: [#33082]\n-\n-[#33082]: https://github.com/rust-lang/rust/issues/33082\n-\n-See also [`alloc_system`](library-features/alloc-system.html).\n-\n-------------------------\n-\n-This feature has been replaced by [the `jemallocator` crate on crates.io.][jemallocator].\n-\n-[jemallocator]: https://crates.io/crates/jemallocator"}, {"sha": "9effab202cabd909b8c270110f2ff1df5f7fa568", "filename": "src/doc/unstable-book/src/library-features/alloc-system.md", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "raw_url": "https://github.com/rust-lang/rust/raw/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Falloc-system.md?ref=f9944fde377b8b2575f96fff60f784eddce54002", "patch": "@@ -1,77 +0,0 @@\n-# `alloc_system`\n-\n-The tracking issue for this feature is: [#32838]\n-\n-[#32838]: https://github.com/rust-lang/rust/issues/32838\n-\n-See also [`global_allocator`](language-features/global-allocator.html).\n-\n-------------------------\n-\n-The compiler currently ships two default allocators: `alloc_system` and\n-`alloc_jemalloc` (some targets don't have jemalloc, however). These allocators\n-are normal Rust crates and contain an implementation of the routines to\n-allocate and deallocate memory. The standard library is not compiled assuming\n-either one, and the compiler will decide which allocator is in use at\n-compile-time depending on the type of output artifact being produced.\n-\n-Binaries generated by the compiler will use `alloc_jemalloc` by default (where\n-available). In this situation the compiler \"controls the world\" in the sense of\n-it has power over the final link. Primarily this means that the allocator\n-decision can be left up the compiler.\n-\n-Dynamic and static libraries, however, will use `alloc_system` by default. Here\n-Rust is typically a 'guest' in another application or another world where it\n-cannot authoritatively decide what allocator is in use. As a result it resorts\n-back to the standard APIs (e.g. `malloc` and `free`) for acquiring and releasing\n-memory.\n-\n-# Switching Allocators\n-\n-Although the compiler's default choices may work most of the time, it's often\n-necessary to tweak certain aspects. Overriding the compiler's decision about\n-which allocator is in use is done through the `#[global_allocator]` attribute:\n-\n-```rust,no_run\n-#![feature(alloc_system, global_allocator, allocator_api)]\n-\n-extern crate alloc_system;\n-\n-use alloc_system::System;\n-\n-#[global_allocator]\n-static A: System = System;\n-\n-fn main() {\n-    let a = Box::new(4); // Allocates from the system allocator.\n-    println!(\"{}\", a);\n-}\n-```\n-\n-In this example the binary generated will not link to jemalloc by default but\n-instead use the system allocator. Conversely to generate a dynamic library which\n-uses jemalloc by default one would write:\n-\n-(The `alloc_jemalloc` crate cannot be used to control the global allocator,\n-crate.io\u2019s `jemallocator` crate provides equivalent functionality.)\n-\n-```toml\n-# Cargo.toml\n-[dependencies]\n-jemallocator = \"0.1\"\n-```\n-```rust,ignore\n-#![feature(global_allocator)]\n-#![crate_type = \"dylib\"]\n-\n-extern crate jemallocator;\n-\n-#[global_allocator]\n-static ALLOC: jemallocator::Jemalloc = jemallocator::Jemalloc;\n-\n-pub fn foo() {\n-    let a = Box::new(4); // Allocates from jemalloc.\n-    println!(\"{}\", a);\n-}\n-# fn main() {}\n-```"}, {"sha": "04c8063ffebc5dbc613fab0bfc48f9d35b80c16a", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 103, "deletions": 47, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,17 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"allocator_api\",\n-            reason = \"the precise API and guarantees it provides may be tweaked \\\n-                      slightly, especially to possibly take into account the \\\n-                      types being stored to make room for a future \\\n-                      tracing garbage collector\",\n-            issue = \"32838\")]\n+//! Memory allocation APIs\n+\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n use core::ptr::{NonNull, Unique};\n use core::usize;\n \n+#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n #[doc(inline)]\n pub use core::alloc::*;\n \n@@ -37,67 +35,112 @@ extern \"Rust\" {\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n }\n \n+/// The global memory allocator.\n+///\n+/// This type implements the [`Alloc`] trait by forwarding calls\n+/// to the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n-pub type Heap = Global;\n-\n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"type renamed to `Global`\")]\n-#[allow(non_upper_case_globals)]\n-pub const Heap: Global = Global;\n-\n-unsafe impl GlobalAlloc for Global {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-        let ptr = __rust_alloc(layout.size(), layout.align());\n-        ptr as *mut Opaque\n-    }\n+/// Allocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::alloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `alloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::alloc`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n+    __rust_alloc(layout.size(), layout.align())\n+}\n \n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-        __rust_dealloc(ptr as *mut u8, layout.size(), layout.align())\n-    }\n+/// Deallocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::dealloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `dealloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::dealloc`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n+    __rust_dealloc(ptr, layout.size(), layout.align())\n+}\n \n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-        let ptr = __rust_realloc(ptr as *mut u8, layout.size(), layout.align(), new_size);\n-        ptr as *mut Opaque\n-    }\n+/// Reallocate memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::realloc`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `realloc` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::realloc`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+    __rust_realloc(ptr, layout.size(), layout.align(), new_size)\n+}\n \n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-        let ptr = __rust_alloc_zeroed(layout.size(), layout.align());\n-        ptr as *mut Opaque\n-    }\n+/// Allocate zero-initialized memory with the global allocator.\n+///\n+/// This function forwards calls to the [`GlobalAlloc::alloc_zeroed`] method\n+/// of the allocator registered with the `#[global_allocator]` attribute\n+/// if there is one, or the `std` crate\u2019s default.\n+///\n+/// This function is expected to be deprecated in favor of the `alloc_zeroed` method\n+/// of the [`Global`] type when it and the [`Alloc`] trait become stable.\n+///\n+/// # Safety\n+///\n+/// See [`GlobalAlloc::alloc_zeroed`].\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+#[inline]\n+pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {\n+    __rust_alloc_zeroed(layout.size(), layout.align())\n }\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(alloc(layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+        dealloc(ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n                       new_size: usize)\n-                      -> Result<NonNull<Opaque>, AllocErr>\n+                      -> Result<NonNull<u8>, AllocErr>\n     {\n-        NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n+        NonNull::new(realloc(ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n-        NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+        NonNull::new(alloc_zeroed(layout)).ok_or(AllocErr)\n     }\n }\n \n@@ -111,9 +154,9 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         align as *mut u8\n     } else {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        let ptr = Global.alloc(layout);\n+        let ptr = alloc(layout);\n         if !ptr.is_null() {\n-            ptr as *mut u8\n+            ptr\n         } else {\n             oom(layout)\n         }\n@@ -129,10 +172,23 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n     // We do not allocate for Box<T> when T is ZST, so deallocation is also not necessary.\n     if size != 0 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        Global.dealloc(ptr as *mut Opaque, layout);\n+        dealloc(ptr as *mut u8, layout);\n     }\n }\n \n+/// Abort on memory allocation error or failure.\n+///\n+/// Callers of memory allocation APIs wishing to abort computation\n+/// in response to an allocation error are encouraged to call this function,\n+/// rather than directly invoking `panic!` or similar.\n+///\n+/// The default behavior of this function is to print a message to standard error\n+/// and abort the process.\n+/// It can be replaced with [`set_oom_hook`] and [`take_oom_hook`].\n+///\n+/// [`set_oom_hook`]: ../../std/alloc/fn.set_oom_hook.html\n+/// [`take_oom_hook`]: ../../std/alloc/fn.take_oom_hook.html\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[rustc_allocator_nounwind]\n pub fn oom(layout: Layout) -> ! {\n     #[allow(improper_ctypes)]"}, {"sha": "e3369f0a5b5bf52524b6e11d7e211ffdc4ac3f7c", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -519,7 +519,7 @@ impl<T: ?Sized> Arc<T> {\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n+            Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n \n@@ -639,7 +639,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.as_opaque(), self.layout.clone());\n+                    Global.dealloc(self.mem.cast(), self.layout.clone());\n                 }\n             }\n         }\n@@ -1196,7 +1196,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n-                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()))\n+                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()))\n             }\n         }\n     }"}, {"sha": "19bdcbc6ad63ea8d3f7fe7531b3f866fe019440c", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -287,7 +287,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Global.dealloc(NonNull::from(top).as_opaque(), Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -478,7 +478,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n         debug_assert!(!self.is_shared_root());\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_opaque(), Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -499,7 +499,7 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n     > {\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.as_opaque(), Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(node.cast(), Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1321,12 +1321,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Global.dealloc(\n-                    right_node.node.as_opaque(),\n+                    right_node.node.cast(),\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Global.dealloc(\n-                    right_node.node.as_opaque(),\n+                    right_node.node.cast(),\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "16f0630b91134dd62965aa04d75663b98cc402f6", "filename": "src/liballoc/heap.rs", "status": "removed", "additions": 0, "deletions": 110, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9944fde377b8b2575f96fff60f784eddce54002/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=f9944fde377b8b2575f96fff60f784eddce54002", "patch": "@@ -1,110 +0,0 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(deprecated)]\n-\n-pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Opaque};\n-use core::alloc::Alloc as CoreAlloc;\n-use core::ptr::NonNull;\n-\n-#[doc(hidden)]\n-pub mod __core {\n-    pub use core::*;\n-}\n-\n-#[derive(Debug)]\n-pub struct Excess(pub *mut u8, pub usize);\n-\n-/// Compatibility with older versions of #[global_allocator] during bootstrap\n-pub unsafe trait Alloc {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n-    fn oom(&mut self, err: AllocErr) -> !;\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize);\n-    unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n-                      layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr>;\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr>;\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n-                             layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr>;\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n-                            layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n-                              layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n-}\n-\n-unsafe impl<T> Alloc for T where T: CoreAlloc {\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::alloc(self, layout).map(|ptr| ptr.cast().as_ptr())\n-    }\n-\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::dealloc(self, ptr, layout)\n-    }\n-\n-    fn oom(&mut self, _: AllocErr) -> ! {\n-        unsafe { ::core::intrinsics::abort() }\n-    }\n-\n-    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n-        CoreAlloc::usable_size(self, layout)\n-    }\n-\n-    unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n-                      layout: Layout,\n-                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::realloc(self, ptr, layout, new_layout.size()).map(|ptr| ptr.cast().as_ptr())\n-    }\n-\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::alloc_zeroed(self, layout).map(|ptr| ptr.cast().as_ptr())\n-    }\n-\n-    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n-        CoreAlloc::alloc_excess(self, layout)\n-            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n-    }\n-\n-    unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n-                             layout: Layout,\n-                             new_layout: Layout) -> Result<Excess, AllocErr> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n-            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n-    }\n-\n-    unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n-                            layout: Layout,\n-                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n-    }\n-\n-    unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n-                              layout: Layout,\n-                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n-        let ptr = NonNull::new_unchecked(ptr as *mut Opaque);\n-        CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n-    }\n-}"}, {"sha": "74bbd65924630472cb7ce7594931adc925bcc0e0", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -151,18 +151,10 @@ pub mod allocator {\n \n pub mod alloc;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n-/// Use the `alloc` module instead.\n-pub mod heap {\n-    pub use alloc::*;\n-}\n-\n #[unstable(feature = \"futures_api\",\n            reason = \"futures in libcore are unstable\",\n            issue = \"50547\")]\n pub mod task;\n-\n // Primitive types using the heaps above\n \n // Need to conditionally define the mod from `boxed.rs` to avoid"}, {"sha": "d1f140e96a3ae45c456a4a25211f289c17bc0f9b", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -93,7 +93,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                NonNull::<T>::dangling().as_opaque()\n+                NonNull::<T>::dangling()\n             } else {\n                 let align = mem::align_of::<T>();\n                 let layout = Layout::from_size_align(alloc_size, align).unwrap();\n@@ -103,13 +103,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     a.alloc(layout)\n                 };\n                 match result {\n-                    Ok(ptr) => ptr,\n+                    Ok(ptr) => ptr.cast(),\n                     Err(_) => oom(layout),\n                 }\n             };\n \n             RawVec {\n-                ptr: ptr.cast().into(),\n+                ptr: ptr.into(),\n                 cap,\n                 a,\n             }\n@@ -314,7 +314,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).cast(),\n                                                  cur,\n                                                  new_size);\n                     match ptr_res {\n@@ -373,7 +373,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).unwrap_or_else(|_| capacity_overflow());\n-            match self.a.grow_in_place(NonNull::from(self.ptr).as_opaque(), old_layout, new_size) {\n+            match self.a.grow_in_place(NonNull::from(self.ptr).cast(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -546,7 +546,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).unwrap_or_else(|_| capacity_overflow());\n             match self.a.grow_in_place(\n-                NonNull::from(self.ptr).as_opaque(), old_layout, new_layout.size(),\n+                NonNull::from(self.ptr).cast(), old_layout, new_layout.size(),\n             ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -607,7 +607,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(NonNull::from(self.ptr).as_opaque(),\n+                match self.a.realloc(NonNull::from(self.ptr).cast(),\n                                      old_layout,\n                                      new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n@@ -667,7 +667,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n+                    self.a.realloc(NonNull::from(self.ptr).cast(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n@@ -710,7 +710,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n             if let Some(layout) = self.current_layout() {\n-                self.a.dealloc(NonNull::from(self.ptr).as_opaque(), layout);\n+                self.a.dealloc(NonNull::from(self.ptr).cast(), layout);\n             }\n         }\n     }\n@@ -753,7 +753,6 @@ fn capacity_overflow() -> ! {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use alloc::Opaque;\n \n     #[test]\n     fn allocator_param() {\n@@ -773,7 +772,7 @@ mod tests {\n         // before allocation attempts start failing.\n         struct BoundedAlloc { fuel: usize }\n         unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n                 let size = layout.size();\n                 if size > self.fuel {\n                     return Err(AllocErr);\n@@ -783,7 +782,7 @@ mod tests {\n                     err @ Err(_) => err,\n                 }\n             }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n                 Global.dealloc(ptr, layout)\n             }\n         }"}, {"sha": "84a6ecf710399d0f0fc923101da92599f7e567c4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -259,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use alloc::{Global, Alloc, Layout, Opaque, box_free, oom};\n+use alloc::{Global, Alloc, Layout, box_free, oom};\n use string::String;\n use vec::Vec;\n \n@@ -732,7 +732,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: NonNull<Opaque>,\n+            mem: NonNull<u8>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -755,7 +755,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             let v_ptr = v as *const [T];\n             let ptr = Self::allocate_for_ptr(v_ptr);\n \n-            let mem = ptr as *mut _ as *mut Opaque;\n+            let mem = ptr as *mut _ as *mut u8;\n             let layout = Layout::for_value(&*ptr);\n \n             // Pointer to first element\n@@ -839,7 +839,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n+                    Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1263,7 +1263,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                Global.dealloc(self.ptr.as_opaque(), Layout::for_value(self.ptr.as_ref()));\n+                Global.dealloc(self.ptr.cast(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }"}, {"sha": "b3b20715511a7627662d6eac5550f62f6db4508e", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -11,9 +11,8 @@\n #![no_std]\n #![allow(unused_attributes)]\n #![unstable(feature = \"alloc_jemalloc\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"27783\")]\n+            reason = \"implementation detail of std, does not provide any public API\",\n+            issue = \"0\")]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n #![feature(linkage)]"}, {"sha": "64348e05de7db16967708aded5d286e613cd75b1", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -14,7 +14,6 @@\n             reason = \"this library is unlikely to be stabilized in its current \\\n                       form or name\",\n             issue = \"32838\")]\n-#![feature(global_allocator)]\n #![feature(allocator_api)]\n #![feature(core_intrinsics)]\n #![feature(staged_api)]\n@@ -41,54 +40,78 @@ const MIN_ALIGN: usize = 8;\n #[allow(dead_code)]\n const MIN_ALIGN: usize = 16;\n \n-use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Opaque};\n+use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout};\n use core::ptr::NonNull;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+/// The default memory allocator provided by the operating system.\n+///\n+/// This is based on `malloc` on Unix platforms and `HeapAlloc` on Windows,\n+/// plus related functions.\n+///\n+/// This type can be used in a `static` item\n+/// with the `#[global_allocator]` attribute\n+/// to force the global allocator to be the system\u2019s one.\n+/// (The default is jemalloc for executables, on some platforms.)\n+///\n+/// ```rust\n+/// use std::alloc::System;\n+///\n+/// #[global_allocator]\n+/// static A: System = System;\n+///\n+/// fn main() {\n+///     let a = Box::new(4); // Allocates from the system allocator.\n+///     println!(\"{}\", a);\n+/// }\n+/// ```\n+///\n+/// It can also be used directly to allocate memory\n+/// independently of the standard library\u2019s global allocator.\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n pub struct System;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::alloc_zeroed(self, layout)).ok_or(AllocErr)\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout) {\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n         GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n         NonNull::new(GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size)).ok_or(AllocErr)\n     }\n }\n \n #[cfg(any(windows, unix, target_os = \"cloudabi\", target_os = \"redox\"))]\n mod realloc_fallback {\n-    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::alloc::{GlobalAlloc, Layout};\n     use core::cmp;\n     use core::ptr;\n \n     impl super::System {\n-        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut Opaque, old_layout: Layout,\n-                                              new_size: usize) -> *mut Opaque {\n+        pub(crate) unsafe fn realloc_fallback(&self, ptr: *mut u8, old_layout: Layout,\n+                                              new_size: usize) -> *mut u8 {\n             // Docs for GlobalAlloc::realloc require this to be valid:\n             let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n \n             let new_ptr = GlobalAlloc::alloc(self, new_layout);\n             if !new_ptr.is_null() {\n                 let size = cmp::min(old_layout.size(), new_size);\n-                ptr::copy_nonoverlapping(ptr as *mut u8, new_ptr as *mut u8, size);\n+                ptr::copy_nonoverlapping(ptr, new_ptr, size);\n                 GlobalAlloc::dealloc(self, ptr, old_layout);\n             }\n             new_ptr\n@@ -104,49 +127,47 @@ mod platform {\n \n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Layout, Opaque};\n+    use core::alloc::{GlobalAlloc, Layout};\n \n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::malloc(layout.size()) as *mut Opaque\n+                libc::malloc(layout.size()) as *mut u8\n             } else {\n                 #[cfg(target_os = \"macos\")]\n                 {\n                     if layout.align() > (1 << 31) {\n-                        // FIXME: use Opaque::null_mut\n-                        // https://github.com/rust-lang/rust/issues/49659\n-                        return 0 as *mut Opaque\n+                        return ptr::null_mut()\n                     }\n                 }\n                 aligned_malloc(&layout)\n             }\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-                libc::calloc(layout.size(), 1) as *mut Opaque\n+                libc::calloc(layout.size(), 1) as *mut u8\n             } else {\n                 let ptr = self.alloc(layout.clone());\n                 if !ptr.is_null() {\n-                    ptr::write_bytes(ptr as *mut u8, 0, layout.size());\n+                    ptr::write_bytes(ptr, 0, layout.size());\n                 }\n                 ptr\n             }\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, _layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n             libc::free(ptr as *mut libc::c_void)\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut Opaque\n+                libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n             } else {\n                 self.realloc_fallback(ptr, layout, new_size)\n             }\n@@ -155,7 +176,7 @@ mod platform {\n \n     #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n         // doesn't have the `posix_memalign` API used below. Instead we use\n         // `memalign`, but this unfortunately has the property on some systems\n@@ -173,19 +194,18 @@ mod platform {\n         // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n         // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n         //                                       /memory/aligned_memory.cc\n-        libc::memalign(layout.align(), layout.size()) as *mut Opaque\n+        libc::memalign(layout.align(), layout.size()) as *mut u8\n     }\n \n     #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n     #[inline]\n-    unsafe fn aligned_malloc(layout: &Layout) -> *mut Opaque {\n+    unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();\n         let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n         if ret != 0 {\n-            // FIXME: use Opaque::null_mut https://github.com/rust-lang/rust/issues/49659\n-            0 as *mut Opaque\n+            ptr::null_mut()\n         } else {\n-            out as *mut Opaque\n+            out as *mut u8\n         }\n     }\n }\n@@ -195,7 +215,7 @@ mod platform {\n mod platform {\n     use MIN_ALIGN;\n     use System;\n-    use core::alloc::{GlobalAlloc, Opaque, Layout};\n+    use core::alloc::{GlobalAlloc, Layout};\n \n     type LPVOID = *mut u8;\n     type HANDLE = LPVOID;\n@@ -227,7 +247,7 @@ mod platform {\n     }\n \n     #[inline]\n-    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut Opaque {\n+    unsafe fn allocate_with_flags(layout: Layout, flags: DWORD) -> *mut u8 {\n         let ptr = if layout.align() <= MIN_ALIGN {\n             HeapAlloc(GetProcessHeap(), flags, layout.size())\n         } else {\n@@ -239,39 +259,39 @@ mod platform {\n                 align_ptr(ptr, layout.align())\n             }\n         };\n-        ptr as *mut Opaque\n+        ptr as *mut u8\n     }\n \n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n             allocate_with_flags(layout, 0)\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n             allocate_with_flags(layout, HEAP_ZERO_MEMORY)\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n             if layout.align() <= MIN_ALIGN {\n                 let err = HeapFree(GetProcessHeap(), 0, ptr as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             } else {\n-                let header = get_header(ptr as *mut u8);\n+                let header = get_header(ptr);\n                 let err = HeapFree(GetProcessHeap(), 0, header.0 as LPVOID);\n                 debug_assert!(err != 0, \"Failed to free heap memory: {}\",\n                               GetLastError());\n             }\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n             if layout.align() <= MIN_ALIGN {\n-                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut Opaque\n+                HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, new_size) as *mut u8\n             } else {\n                 self.realloc_fallback(ptr, layout, new_size)\n             }\n@@ -300,32 +320,32 @@ mod platform {\n mod platform {\n     extern crate dlmalloc;\n \n-    use core::alloc::{GlobalAlloc, Layout, Opaque};\n+    use core::alloc::{GlobalAlloc, Layout};\n     use System;\n \n     // No need for synchronization here as wasm is currently single-threaded\n     static mut DLMALLOC: dlmalloc::Dlmalloc = dlmalloc::DLMALLOC_INIT;\n \n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    #[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n     unsafe impl GlobalAlloc for System {\n         #[inline]\n-        unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n-            DLMALLOC.malloc(layout.size(), layout.align()) as *mut Opaque\n+        unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+            DLMALLOC.malloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n-            DLMALLOC.calloc(layout.size(), layout.align()) as *mut Opaque\n+        unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+            DLMALLOC.calloc(layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n-            DLMALLOC.free(ptr as *mut u8, layout.size(), layout.align())\n+        unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+            DLMALLOC.free(ptr, layout.size(), layout.align())\n         }\n \n         #[inline]\n-        unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n-            DLMALLOC.realloc(ptr as *mut u8, layout.size(), layout.align(), new_size) as *mut Opaque\n+        unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+            DLMALLOC.realloc(ptr, layout.size(), layout.align(), new_size)\n         }\n     }\n }"}, {"sha": "353688d1b85583bd3b2f18e23049aee16872e062", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 249, "deletions": 96, "changes": 345, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,12 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"allocator_api\",\n-            reason = \"the precise API and guarantees it provides may be tweaked \\\n-                      slightly, especially to possibly take into account the \\\n-                      types being stored to make room for a future \\\n-                      tracing garbage collector\",\n-            issue = \"32838\")]\n+//! Memory allocation APIs\n+\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use cmp;\n use fmt;\n@@ -22,30 +19,15 @@ use usize;\n use ptr::{self, NonNull};\n use num::NonZeroUsize;\n \n-extern {\n-    /// An opaque, unsized type. Used for pointers to allocated memory.\n-    ///\n-    /// This type can only be used behind a pointer like `*mut Opaque` or `ptr::NonNull<Opaque>`.\n-    /// Such pointers are similar to C\u2019s `void*` type.\n-    pub type Opaque;\n-}\n-\n-impl Opaque {\n-    /// Similar to `std::ptr::null`, which requires `T: Sized`.\n-    pub fn null() -> *const Self {\n-        0 as _\n-    }\n-\n-    /// Similar to `std::ptr::null_mut`, which requires `T: Sized`.\n-    pub fn null_mut() -> *mut Self {\n-        0 as _\n-    }\n-}\n+#[unstable(feature = \"alloc_internals\", issue = \"0\")]\n+#[cfg(stage0)]\n+pub type Opaque = u8;\n \n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Debug)]\n-pub struct Excess(pub NonNull<Opaque>, pub usize);\n+pub struct Excess(pub NonNull<u8>, pub usize);\n \n fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n@@ -64,6 +46,7 @@ fn size_align<T>() -> (usize, usize) {\n /// requests have positive size. A caller to the `Alloc::alloc`\n /// method must either ensure that conditions like this are met, or\n /// use specific allocators with looser requirements.)\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct Layout {\n     // size of the requested block of memory, measured in bytes.\n@@ -89,6 +72,7 @@ impl Layout {\n     /// * `size`, when rounded up to the nearest multiple of `align`,\n     ///    must not overflow (i.e. the rounded value must be less than\n     ///    `usize::MAX`).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutErr> {\n         if !align.is_power_of_two() {\n@@ -124,20 +108,24 @@ impl Layout {\n     ///\n     /// This function is unsafe as it does not verify the preconditions from\n     /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {\n         Layout { size_: size, align_: NonZeroUsize::new_unchecked(align) }\n     }\n \n     /// The minimum size in bytes for a memory block of this layout.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub fn size(&self) -> usize { self.size_ }\n \n     /// The minimum byte alignment for a memory block of this layout.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub fn align(&self) -> usize { self.align_.get() }\n \n     /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub fn new<T>() -> Self {\n         let (size, align) = size_align::<T>();\n@@ -154,6 +142,7 @@ impl Layout {\n     /// Produces layout describing a record that could be used to\n     /// allocate backing structure for `T` (which could be a trait\n     /// or other unsized type like a slice).\n+    #[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n     #[inline]\n     pub fn for_value<T: ?Sized>(t: &T) -> Self {\n         let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n@@ -181,6 +170,7 @@ impl Layout {\n     /// Panics if the combination of `self.size()` and the given `align`\n     /// violates the conditions listed in\n     /// [`Layout::from_size_align`](#method.from_size_align).\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn align_to(&self, align: usize) -> Self {\n         Layout::from_size_align(self.size(), cmp::max(self.align(), align)).unwrap()\n@@ -202,6 +192,7 @@ impl Layout {\n     /// to be less than or equal to the alignment of the starting\n     /// address for the whole allocated block of memory. One way to\n     /// satisfy this constraint is to ensure `align <= self.align()`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn padding_needed_for(&self, align: usize) -> usize {\n         let len = self.size();\n@@ -238,6 +229,7 @@ impl Layout {\n     /// of each element in the array.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutErr> {\n         let padded_size = self.size().checked_add(self.padding_needed_for(self.align()))\n@@ -263,6 +255,7 @@ impl Layout {\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn extend(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_align = cmp::max(self.align(), next.align());\n@@ -289,6 +282,7 @@ impl Layout {\n     /// aligned.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn repeat_packed(&self, n: usize) -> Result<Self, LayoutErr> {\n         let size = self.size().checked_mul(n).ok_or(LayoutErr { private: () })?;\n@@ -310,6 +304,7 @@ impl Layout {\n     ///  `extend`.)\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn extend_packed(&self, next: Self) -> Result<(Self, usize), LayoutErr> {\n         let new_size = self.size().checked_add(next.size())\n@@ -321,6 +316,7 @@ impl Layout {\n     /// Creates a layout describing the record for a `[T; n]`.\n     ///\n     /// On arithmetic overflow, returns `LayoutErr`.\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n     #[inline]\n     pub fn array<T>(n: usize) -> Result<Self, LayoutErr> {\n         Layout::new::<T>()\n@@ -332,28 +328,33 @@ impl Layout {\n     }\n }\n \n-/// The parameters given to `Layout::from_size_align` do not satisfy\n-/// its documented constraints.\n+/// The parameters given to `Layout::from_size_align`\n+/// or some other `Layout` constructor\n+/// do not satisfy its documented constraints.\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct LayoutErr {\n     private: ()\n }\n \n // (we need this for downstream impl of trait Error)\n+#[stable(feature = \"alloc_layout\", since = \"1.28.0\")]\n impl fmt::Display for LayoutErr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"invalid parameters to Layout::from_size_align\")\n     }\n }\n \n-/// The `AllocErr` error specifies whether an allocation failure is\n-/// specifically due to resource exhaustion or if it is due to\n+/// The `AllocErr` error indicates an allocation failure\n+/// that may be due to resource exhaustion or to\n /// something wrong when combining the given input arguments with this\n /// allocator.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct AllocErr;\n \n // (we need this for downstream impl of trait Error)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl fmt::Display for AllocErr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.write_str(\"memory allocation failed\")\n@@ -363,23 +364,27 @@ impl fmt::Display for AllocErr {\n /// The `CannotReallocInPlace` error is used when `grow_in_place` or\n /// `shrink_in_place` were unable to reuse the given memory block for\n /// a requested layout.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct CannotReallocInPlace;\n \n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl CannotReallocInPlace {\n     pub fn description(&self) -> &str {\n         \"cannot reallocate allocator's memory in place\"\n     }\n }\n \n // (we need this for downstream impl of trait Error)\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n impl fmt::Display for CannotReallocInPlace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.description())\n     }\n }\n \n /// Augments `AllocErr` with a CapacityOverflow variant.\n+// FIXME: should this be in libcore or liballoc?\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n pub enum CollectionAllocErr {\n@@ -406,59 +411,196 @@ impl From<LayoutErr> for CollectionAllocErr {\n     }\n }\n \n-/// A memory allocator that can be registered to be the one backing `std::alloc::Global`\n+/// A memory allocator that can be registered as the standard library\u2019s default\n /// though the `#[global_allocator]` attributes.\n+///\n+/// Some of the methods require that a memory block be *currently\n+/// allocated* via an allocator. This means that:\n+///\n+/// * the starting address for that memory block was previously\n+///   returned by a previous call to an allocation method\n+///   such as `alloc`, and\n+///\n+/// * the memory block has not been subsequently deallocated, where\n+///   blocks are deallocated either by being passed to a deallocation\n+///   method such as `dealloc` or by being\n+///   passed to a reallocation method that returns a non-null pointer.\n+///\n+///\n+/// # Example\n+///\n+/// ```no_run\n+/// use std::alloc::{GlobalAlloc, Layout, alloc};\n+/// use std::ptr::null_mut;\n+///\n+/// struct MyAllocator;\n+///\n+/// unsafe impl GlobalAlloc for MyAllocator {\n+///     unsafe fn alloc(&self, _layout: Layout) -> *mut u8 { null_mut() }\n+///     unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {}\n+/// }\n+///\n+/// #[global_allocator]\n+/// static A: MyAllocator = MyAllocator;\n+///\n+/// fn main() {\n+///     unsafe {\n+///         assert!(alloc(Layout::new::<u32>()).is_null())\n+///     }\n+/// }\n+/// ```\n+///\n+/// # Unsafety\n+///\n+/// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n+/// implementors must ensure that they adhere to these contracts:\n+///\n+/// * It's undefined behavior if global allocators unwind.  This restriction may\n+///   be lifted in the future, but currently a panic from any of these\n+///   functions may lead to memory unsafety.\n+///\n+/// * `Layout` queries and calculations in general must be correct. Callers of\n+///   this trait are allowed to rely on the contracts defined on each method,\n+///   and implementors must ensure such contracts remain true.\n+#[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n pub unsafe trait GlobalAlloc {\n     /// Allocate memory as described by the given `layout`.\n     ///\n     /// Returns a pointer to newly-allocated memory,\n-    /// or NULL to indicate allocation failure.\n+    /// or null to indicate allocation failure.\n     ///\n     /// # Safety\n     ///\n-    /// **FIXME:** what are the exact requirements?\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque;\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure that `layout` has non-zero size.\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// The allocated block of memory may or may not be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet allocator's size or alignment constraints.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8;\n \n     /// Deallocate the block of memory at the given `ptr` pointer with the given `layout`.\n     ///\n     /// # Safety\n     ///\n-    /// **FIXME:** what are the exact requirements?\n-    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout);\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via\n+    ///   this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocated that block of memory,\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);\n \n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut Opaque {\n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    /// However the allocated block of memory is guaranteed to be initialized.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning a null pointer indicates that either memory is exhausted\n+    /// or `layout` does not meet allocator's size or alignment constraints,\n+    /// just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n         let size = layout.size();\n         let ptr = self.alloc(layout);\n         if !ptr.is_null() {\n-            ptr::write_bytes(ptr as *mut u8, 0, size);\n+            ptr::write_bytes(ptr, 0, size);\n         }\n         ptr\n     }\n \n     /// Shink or grow a block of memory to the given `new_size`.\n     /// The block is described by the given `ptr` pointer and `layout`.\n     ///\n-    /// Return a new pointer (which may or may not be the same as `ptr`),\n-    /// or NULL to indicate reallocation failure.\n+    /// If this returns a non-null pointer, then ownership of the memory block\n+    /// referenced by `ptr` has been transferred to this alloctor.\n+    /// The memory may or may not have been deallocated,\n+    /// and should be considered unusable (unless of course it was\n+    /// transferred back to the caller again via the return value of\n+    /// this method).\n     ///\n-    /// If reallocation is successful, the old `ptr` pointer is considered\n-    /// to have been deallocated.\n+    /// If this method returns null, then ownership of the memory\n+    /// block has not been transferred to this allocator, and the\n+    /// contents of the memory block are unaltered.\n     ///\n     /// # Safety\n     ///\n-    /// `new_size`, when rounded up to the nearest multiple of `old_layout.align()`,\n-    /// must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must be the same layout that was used\n+    ///   to allocated that block of memory,\n+    ///\n+    /// * `new_size` must be greater than zero.\n+    ///\n+    /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`,\n+    ///   must not overflow (i.e. the rounded value must be less than `usize::MAX`).\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns null if the new layout does not meet the size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// Implementations are encouraged to return null on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n     ///\n-    /// **FIXME:** what are the exact requirements?\n-    /// In particular around layout *fit*. (See docs for the `Alloc` trait.)\n-    unsafe fn realloc(&self, ptr: *mut Opaque, layout: Layout, new_size: usize) -> *mut Opaque {\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let new_ptr = self.alloc(new_layout);\n         if !new_ptr.is_null() {\n             ptr::copy_nonoverlapping(\n-                ptr as *const u8,\n-                new_ptr as *mut u8,\n+                ptr,\n+                new_ptr,\n                 cmp::min(layout.size(), new_size),\n             );\n             self.dealloc(ptr, layout);\n@@ -540,27 +682,22 @@ pub unsafe trait GlobalAlloc {\n ///   retain their validity until at least the instance of `Alloc` is dropped\n ///   itself.\n ///\n-/// * It's undefined behavior if global allocators unwind.  This restriction may\n-///   be lifted in the future, but currently a panic from any of these\n-///   functions may lead to memory unsafety. Note that as of the time of this\n-///   writing allocators *not* intending to be global allocators can still panic\n-///   in their implementation without violating memory safety.\n-///\n /// * `Layout` queries and calculations in general must be correct. Callers of\n ///   this trait are allowed to rely on the contracts defined on each method,\n ///   and implementors must ensure such contracts remain true.\n ///\n /// Note that this list may get tweaked over time as clarifications are made in\n-/// the future. Additionally global allocators may gain unique requirements for\n-/// how to safely implement one in the future as well.\n+/// the future.\n+#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait Alloc {\n \n-    // (Note: existing allocators have unspecified but well-defined\n+    // (Note: some existing allocators have unspecified but well-defined\n     // behavior in response to a zero size allocation request ;\n     // e.g. in C, `malloc` of 0 will either return a null pointer or a\n     // unique pointer, but will not have arbitrary undefined\n-    // behavior. Rust should consider revising the alloc::heap crate\n-    // to reflect this reality.)\n+    // behavior.\n+    // However in jemalloc for example,\n+    // `mallocx(0)` is documented as undefined behavior.)\n \n     /// Returns a pointer meeting the size and alignment guarantees of\n     /// `layout`.\n@@ -596,9 +733,11 @@ pub unsafe trait Alloc {\n     /// library that aborts on memory exhaustion.)\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr>;\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -615,7 +754,7 @@ pub unsafe trait Alloc {\n     /// * In addition to fitting the block of memory `layout`, the\n     ///   alignment of the `layout` must match the alignment used\n     ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: NonNull<Opaque>, layout: Layout);\n+    unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n     // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n     // usable_size\n@@ -703,13 +842,15 @@ pub unsafe trait Alloc {\n     /// implement this trait atop an underlying native allocation\n     /// library that aborts on memory exhaustion.)\n     ///\n-    /// Clients wishing to abort computation in response to an\n-    /// reallocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n     unsafe fn realloc(&mut self,\n-                      ptr: NonNull<Opaque>,\n+                      ptr: NonNull<u8>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<NonNull<Opaque>, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<u8>, AllocErr> {\n         let old_size = layout.size();\n \n         if new_size >= old_size {\n@@ -726,8 +867,8 @@ pub unsafe trait Alloc {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n         if let Ok(new_ptr) = result {\n-            ptr::copy_nonoverlapping(ptr.as_ptr() as *const u8,\n-                                     new_ptr.as_ptr() as *mut u8,\n+            ptr::copy_nonoverlapping(ptr.as_ptr(),\n+                                     new_ptr.as_ptr(),\n                                      cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n@@ -748,13 +889,15 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Opaque>, AllocErr> {\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n         if let Ok(p) = p {\n-            ptr::write_bytes(p.as_ptr() as *mut u8, 0, size);\n+            ptr::write_bytes(p.as_ptr(), 0, size);\n         }\n         p\n     }\n@@ -774,8 +917,10 @@ pub unsafe trait Alloc {\n     /// constraints, just as in `alloc`.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n     unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n         let usable_size = self.usable_size(&layout);\n         self.alloc(layout).map(|p| Excess(p, usable_size.1))\n@@ -795,11 +940,13 @@ pub unsafe trait Alloc {\n     /// `layout` does not meet allocator's size or alignment\n     /// constraints, just as in `realloc`.\n     ///\n-    /// Clients wishing to abort computation in response to an\n-    /// reallocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n     unsafe fn realloc_excess(&mut self,\n-                             ptr: NonNull<Opaque>,\n+                             ptr: NonNull<u8>,\n                              layout: Layout,\n                              new_size: usize) -> Result<Excess, AllocErr> {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n@@ -840,11 +987,11 @@ pub unsafe trait Alloc {\n     /// could fit `layout`.\n     ///\n     /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n-    /// method; clients are expected either to be able to recover from\n+    /// function; clients are expected either to be able to recover from\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n     unsafe fn grow_in_place(&mut self,\n-                            ptr: NonNull<Opaque>,\n+                            ptr: NonNull<u8>,\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -895,11 +1042,11 @@ pub unsafe trait Alloc {\n     /// could fit `layout`.\n     ///\n     /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n-    /// method; clients are expected either to be able to recover from\n+    /// function; clients are expected either to be able to recover from\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n     unsafe fn shrink_in_place(&mut self,\n-                              ptr: NonNull<Opaque>,\n+                              ptr: NonNull<u8>,\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -943,8 +1090,10 @@ pub unsafe trait Alloc {\n     /// will *not* yield undefined behavior.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n     fn alloc_one<T>(&mut self) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n@@ -978,7 +1127,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            self.dealloc(ptr.as_opaque(), k);\n+            self.dealloc(ptr.cast(), k);\n         }\n     }\n \n@@ -1010,8 +1159,10 @@ pub unsafe trait Alloc {\n     /// Always returns `Err` on arithmetic overflow.\n     ///\n     /// Clients wishing to abort computation in response to an\n-    /// allocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// allocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n     fn alloc_array<T>(&mut self, n: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n@@ -1054,9 +1205,11 @@ pub unsafe trait Alloc {\n     ///\n     /// Always returns `Err` on arithmetic overflow.\n     ///\n-    /// Clients wishing to abort computation in response to an\n-    /// reallocation error are encouraged to call the allocator's `oom`\n-    /// method, rather than directly invoking `panic!` or similar.\n+    /// Clients wishing to abort computation in response to a\n+    /// reallocation error are encouraged to call the [`oom`] function,\n+    /// rather than directly invoking `panic!` or similar.\n+    ///\n+    /// [`oom`]: ../../alloc/alloc/fn.oom.html\n     unsafe fn realloc_array<T>(&mut self,\n                                ptr: NonNull<T>,\n                                n_old: usize,\n@@ -1066,7 +1219,7 @@ pub unsafe trait Alloc {\n         match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n             (Ok(ref k_old), Ok(ref k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n                 debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr.as_opaque(), k_old.clone(), k_new.size()).map(NonNull::cast)\n+                self.realloc(ptr.cast(), k_old.clone(), k_new.size()).map(NonNull::cast)\n             }\n             _ => {\n                 Err(AllocErr)\n@@ -1099,7 +1252,7 @@ pub unsafe trait Alloc {\n     {\n         match Layout::array::<T>(n) {\n             Ok(ref k) if k.size() > 0 => {\n-                Ok(self.dealloc(ptr.as_opaque(), k.clone()))\n+                Ok(self.dealloc(ptr.cast(), k.clone()))\n             }\n             _ => {\n                 Err(AllocErr)"}, {"sha": "5ba77edee6e486e7b09772615833f7ec0e011981", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -215,13 +215,6 @@ pub mod task;\n #[allow(missing_docs)]\n pub mod alloc;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n-/// Use the `alloc` module instead.\n-pub mod heap {\n-    pub use alloc::*;\n-}\n-\n // note: does not need to be public\n mod iter_private;\n mod nonzero;"}, {"sha": "81a8b3ef0474d6f7b9eb835e1cc075f7722e0676", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -2922,14 +2922,6 @@ impl<T: ?Sized> NonNull<T> {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)\n         }\n     }\n-\n-    /// Cast to an `Opaque` pointer\n-    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-    pub fn as_opaque(self) -> NonNull<::alloc::Opaque> {\n-        unsafe {\n-            NonNull::new_unchecked(self.as_ptr() as _)\n-        }\n-    }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "ec0676259ef20845f4ae2f1f62f797cc5588268d", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -237,7 +237,7 @@ impl<'a> AllocFnFactory<'a> {\n                 let ident = ident();\n                 args.push(self.cx.arg(self.span, ident, self.ptr_u8()));\n                 let arg = self.cx.expr_ident(self.span, ident);\n-                self.cx.expr_cast(self.span, arg, self.ptr_opaque())\n+                self.cx.expr_cast(self.span, arg, self.ptr_u8())\n             }\n \n             AllocatorTy::Usize => {\n@@ -281,17 +281,4 @@ impl<'a> AllocFnFactory<'a> {\n         let ty_u8 = self.cx.ty_path(u8);\n         self.cx.ty_ptr(self.span, ty_u8, Mutability::Mutable)\n     }\n-\n-    fn ptr_opaque(&self) -> P<Ty> {\n-        let opaque = self.cx.path(\n-            self.span,\n-            vec![\n-                self.core,\n-                Ident::from_str(\"alloc\"),\n-                Ident::from_str(\"Opaque\"),\n-            ],\n-        );\n-        let ty_opaque = self.cx.ty_path(opaque);\n-        self.cx.ty_ptr(self.span, ty_opaque, Mutability::Mutable)\n-    }\n }"}, {"sha": "a7aeed76309591c2bf38a23620502844fd774dcd", "filename": "src/librustc_asan/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_asan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_asan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -10,8 +10,7 @@\n \n #![sanitizer_runtime]\n #![feature(alloc_system)]\n-#![feature(allocator_api)]\n-#![feature(global_allocator)]\n+#![cfg_attr(stage0, feature(global_allocator))]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "a7aeed76309591c2bf38a23620502844fd774dcd", "filename": "src/librustc_lsan/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_lsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_lsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(sanitizer_runtime)]\n #![feature(alloc_system)]\n-#![feature(allocator_api)]\n-#![feature(global_allocator)]\n+#![cfg_attr(stage0, feature(global_allocator))]\n+#![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\","}, {"sha": "a7aeed76309591c2bf38a23620502844fd774dcd", "filename": "src/librustc_msan/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_msan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_msan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_msan%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n #![sanitizer_runtime]\n-#![feature(sanitizer_runtime)]\n #![feature(alloc_system)]\n-#![feature(allocator_api)]\n-#![feature(global_allocator)]\n+#![cfg_attr(stage0, feature(global_allocator))]\n+#![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]\n #![unstable(feature = \"sanitizer_runtime_lib\","}, {"sha": "a7aeed76309591c2bf38a23620502844fd774dcd", "filename": "src/librustc_tsan/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_tsan%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibrustc_tsan%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_tsan%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -10,8 +10,7 @@\n \n #![sanitizer_runtime]\n #![feature(alloc_system)]\n-#![feature(allocator_api)]\n-#![feature(global_allocator)]\n+#![cfg_attr(stage0, feature(global_allocator))]\n #![feature(sanitizer_runtime)]\n #![feature(staged_api)]\n #![no_std]"}, {"sha": "ae74a71dd06815de686c74a615245261056f4af9", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 81, "deletions": 12, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,19 +8,84 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! dox\n+//! Memory allocation APIs\n+//!\n+//! In a given program, the standard library has one \u201cglobal\u201d memory allocator\n+//! that is used for example by `Box<T>` and `Vec<T>`.\n+//!\n+//! Currently the default global allocator is unspecified.\n+//! The compiler may link to a version of [jemalloc] on some platforms,\n+//! but this is not guaranteed.\n+//! Libraries, however, like `cdylib`s and `staticlib`s are guaranteed\n+//! to use the [`System`] by default.\n+//!\n+//! [jemalloc]: https://github.com/jemalloc/jemalloc\n+//! [`System`]: struct.System.html\n+//!\n+//! # The `#[global_allocator]` attribute\n+//!\n+//! This attribute allows configuring the choice of global allocator.\n+//! You can use this to implement a completely custom global allocator\n+//! to route all default allocation requests to a custom object.\n+//!\n+//! ```rust\n+//! use std::alloc::{GlobalAlloc, System, Layout};\n+//!\n+//! struct MyAllocator;\n+//!\n+//! unsafe impl GlobalAlloc for MyAllocator {\n+//!     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+//!         System.alloc(layout)\n+//!     }\n+//!\n+//!     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+//!         System.dealloc(ptr, layout)\n+//!     }\n+//! }\n+//!\n+//! #[global_allocator]\n+//! static GLOBAL: MyAllocator = MyAllocator;\n+//!\n+//! fn main() {\n+//!     // This `Vec` will allocate memory through `GLOBAL` above\n+//!     let mut v = Vec::new();\n+//!     v.push(1);\n+//! }\n+//! ```\n+//!\n+//! The attribute is used on a `static` item whose type implements the\n+//! [`GlobalAlloc`] trait. This type can be provided by an external library:\n+//!\n+//! [`GlobalAlloc`]: ../../core/alloc/trait.GlobalAlloc.html\n+//!\n+//! ```rust,ignore (demonstrates crates.io usage)\n+//! extern crate jemallocator;\n+//!\n+//! use jemallacator::Jemalloc;\n+//!\n+//! #[global_allocator]\n+//! static GLOBAL: Jemalloc = Jemalloc;\n+//!\n+//! fn main() {}\n+//! ```\n+//!\n+//! The `#[global_allocator]` can only be used once in a crate\n+//! or its recursive dependencies.\n \n-#![unstable(issue = \"32838\", feature = \"allocator_api\")]\n-\n-#[doc(inline)] #[allow(deprecated)] pub use alloc_crate::alloc::Heap;\n-#[doc(inline)] pub use alloc_crate::alloc::{Global, Layout, oom};\n-#[doc(inline)] pub use alloc_system::System;\n-#[doc(inline)] pub use core::alloc::*;\n+#![stable(feature = \"alloc_module\", since = \"1.28.0\")]\n \n use core::sync::atomic::{AtomicPtr, Ordering};\n use core::{mem, ptr};\n use sys_common::util::dumb_print;\n \n+#[stable(feature = \"alloc_module\", since = \"1.28.0\")]\n+#[doc(inline)]\n+pub use alloc_crate::alloc::*;\n+\n+#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n+#[doc(inline)]\n+pub use alloc_system::System;\n+\n static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n \n /// Registers a custom OOM hook, replacing any that was previously registered.\n@@ -34,6 +99,7 @@ static HOOK: AtomicPtr<()> = AtomicPtr::new(ptr::null_mut());\n /// about the allocation that failed.\n ///\n /// The OOM hook is a global resource.\n+#[unstable(feature = \"oom_hook\", issue = \"51245\")]\n pub fn set_oom_hook(hook: fn(Layout)) {\n     HOOK.store(hook as *mut (), Ordering::SeqCst);\n }\n@@ -43,6 +109,7 @@ pub fn set_oom_hook(hook: fn(Layout)) {\n /// *See also the function [`set_oom_hook`].*\n ///\n /// If no custom hook is registered, the default hook will be returned.\n+#[unstable(feature = \"oom_hook\", issue = \"51245\")]\n pub fn take_oom_hook() -> fn(Layout) {\n     let hook = HOOK.swap(ptr::null_mut(), Ordering::SeqCst);\n     if hook.is_null() {\n@@ -59,6 +126,7 @@ fn default_oom_hook(layout: Layout) {\n #[cfg(not(test))]\n #[doc(hidden)]\n #[lang = \"oom\"]\n+#[unstable(feature = \"alloc_internals\", issue = \"0\")]\n pub extern fn rust_oom(layout: Layout) -> ! {\n     let hook = HOOK.load(Ordering::SeqCst);\n     let hook: fn(Layout) = if hook.is_null() {\n@@ -73,8 +141,9 @@ pub extern fn rust_oom(layout: Layout) -> ! {\n #[cfg(not(test))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n+#[unstable(feature = \"alloc_internals\", issue = \"0\")]\n pub mod __default_lib_allocator {\n-    use super::{System, Layout, GlobalAlloc, Opaque};\n+    use super::{System, Layout, GlobalAlloc};\n     // for symbol names src/librustc/middle/allocator.rs\n     // for signatures src/librustc_allocator/lib.rs\n \n@@ -85,15 +154,15 @@ pub mod __default_lib_allocator {\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_alloc(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc(layout) as *mut u8\n+        System.alloc(layout)\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_dealloc(ptr: *mut u8,\n                                        size: usize,\n                                        align: usize) {\n-        System.dealloc(ptr as *mut Opaque, Layout::from_size_align_unchecked(size, align))\n+        System.dealloc(ptr, Layout::from_size_align_unchecked(size, align))\n     }\n \n     #[no_mangle]\n@@ -103,13 +172,13 @@ pub mod __default_lib_allocator {\n                                        align: usize,\n                                        new_size: usize) -> *mut u8 {\n         let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-        System.realloc(ptr as *mut Opaque, old_layout, new_size) as *mut u8\n+        System.realloc(ptr, old_layout, new_size)\n     }\n \n     #[no_mangle]\n     #[rustc_std_internal_symbol]\n     pub unsafe extern fn __rdl_alloc_zeroed(size: usize, align: usize) -> *mut u8 {\n         let layout = Layout::from_size_align_unchecked(size, align);\n-        System.alloc_zeroed(layout) as *mut u8\n+        System.alloc_zeroed(layout)\n     }\n }"}, {"sha": "55f9f4f7cfeb75d7b8a615d06d2acc0f070d00ac", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -1124,7 +1124,7 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         let (layout, _) = calculate_layout::<K, V>(self.capacity())\n             .unwrap_or_else(|_| unsafe { hint::unreachable_unchecked() });\n         unsafe {\n-            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_opaque(), layout);\n+            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).cast(), layout);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}, {"sha": "421134141837b7425bf6c9a2118e4ad01696c744", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -438,7 +438,7 @@ pub use self::hash_map::HashMap;\n pub use self::hash_set::HashSet;\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub use heap::CollectionAllocErr;\n+pub use alloc::CollectionAllocErr;\n \n mod hash;\n "}, {"sha": "3160485375f6df57f76627f2193a31ab3119d6f6", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -23,13 +23,13 @@\n // coherence challenge (e.g., specialization, neg impls, etc) we can\n // reconsider what crate these items belong in.\n \n+use alloc::{AllocErr, LayoutErr, CannotReallocInPlace};\n use any::TypeId;\n use borrow::Cow;\n use cell;\n use char;\n use core::array;\n use fmt::{self, Debug, Display};\n-use heap::{AllocErr, LayoutErr, CannotReallocInPlace};\n use mem::transmute;\n use num;\n use str;"}, {"sha": "1bdc1dc2b7cfba810cc0e669bf4c4e15f3b2fd98", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -264,7 +264,6 @@\n #![feature(fnbox)]\n #![feature(futures_api)]\n #![feature(hashmap_internals)]\n-#![feature(heap_api)]\n #![feature(int_error_internals)]\n #![feature(integer_atomics)]\n #![feature(into_cow)]\n@@ -500,13 +499,6 @@ pub mod process;\n pub mod sync;\n pub mod time;\n \n-#[unstable(feature = \"allocator_api\", issue = \"32838\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"module renamed to `alloc`\")]\n-/// Use the `alloc` module instead.\n-pub mod heap {\n-    pub use alloc::*;\n-}\n-\n // Platform-abstraction modules\n #[macro_use]\n mod sys_common;"}, {"sha": "1535e6495067b6beeb9dd09d23aded14987be0e7", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -357,8 +357,6 @@ declare_features! (\n     // Trait aliases\n     (active, trait_alias, \"1.24.0\", Some(41517), None),\n \n-    // global allocators and their internals\n-    (active, global_allocator, \"1.20.0\", Some(27389), None),\n     // rustc internal\n     (active, allocator_internals, \"1.20.0\", None, None),\n \n@@ -615,6 +613,8 @@ declare_features! (\n     (accepted, macro_lifetime_matcher, \"1.27.0\", Some(34303), None),\n     // Termination trait in tests (RFC 1937)\n     (accepted, termination_trait_test, \"1.27.0\", Some(48854), None),\n+    // The #[global_allocator] attribute\n+    (accepted, global_allocator, \"1.28.0\", Some(27389), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -776,11 +776,7 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                              \"the `#[rustc_const_unstable]` attribute \\\n                                               is an internal feature\",\n                                              cfg_fn!(rustc_const_unstable))),\n-    (\"global_allocator\", Normal, Gated(Stability::Unstable,\n-                                       \"global_allocator\",\n-                                       \"the `#[global_allocator]` attribute is \\\n-                                        an experimental feature\",\n-                                       cfg_fn!(global_allocator))),\n+    (\"global_allocator\", Normal, Ungated),\n     (\"default_lib_allocator\", Whitelisted, Gated(Stability::Unstable,\n                                             \"allocator_internals\",\n                                             \"the `#[default_lib_allocator]` \\"}, {"sha": "e5650d5b7b0994d67a74255901110bd1c18812ef", "filename": "src/test/compile-fail/allocator/auxiliary/system-allocator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(global_allocator, allocator_api)]\n #![crate_type = \"rlib\"]\n \n use std::alloc::System;"}, {"sha": "e5650d5b7b0994d67a74255901110bd1c18812ef", "filename": "src/test/compile-fail/allocator/auxiliary/system-allocator2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fauxiliary%2Fsystem-allocator2.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(global_allocator, allocator_api)]\n #![crate_type = \"rlib\"]\n \n use std::alloc::System;"}, {"sha": "989c102b86e699e72c15b4530862844d6d5a3cee", "filename": "src/test/compile-fail/allocator/function-allocator.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ffunction-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ffunction-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ffunction-allocator.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(global_allocator)]\n \n #[global_allocator]\n fn foo() {} //~ ERROR: allocators must be statics"}, {"sha": "6559335960ac5e1804c40d6304ee87c18c7d804a", "filename": "src/test/compile-fail/allocator/not-an-allocator.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Fnot-an-allocator.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(global_allocator, heap_api)]\n-\n #[global_allocator]\n static A: usize = 0;\n //~^ the trait bound `usize:"}, {"sha": "7a97a11df20334d7e88e1de082249393cfba59c2", "filename": "src/test/compile-fail/allocator/two-allocators.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(global_allocator, allocator_api)]\n-\n use std::alloc::System;\n \n #[global_allocator]"}, {"sha": "e747140dfe560f2c3c140282a1ba94d55bf0445e", "filename": "src/test/compile-fail/allocator/two-allocators2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators2.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -12,8 +12,6 @@\n // no-prefer-dynamic\n // error-pattern: the #[global_allocator] in\n \n-#![feature(global_allocator, allocator_api)]\n-\n extern crate system_allocator;\n \n use std::alloc::System;"}, {"sha": "dd86b02bd20ec98c2fe1041bc7d9d126aac2c6a6", "filename": "src/test/compile-fail/allocator/two-allocators3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fallocator%2Ftwo-allocators3.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -13,7 +13,6 @@\n // no-prefer-dynamic\n // error-pattern: the #[global_allocator] in\n \n-#![feature(global_allocator)]\n \n extern crate system_allocator;\n extern crate system_allocator2;"}, {"sha": "b1b1a9a1fbf8e7d5789f4e155f89e7b26c866f25", "filename": "src/test/compile-fail/lint-stability-fields.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability-fields.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -18,6 +18,11 @@\n mod cross_crate {\n     extern crate lint_stability_fields;\n \n+    mod reexport {\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub use super::lint_stability_fields::*;\n+    }\n+\n     use self::lint_stability_fields::*;\n \n     pub fn foo() {\n@@ -73,6 +78,8 @@ mod cross_crate {\n             // the patterns are all fine:\n             { .. } = x;\n \n+        // Unstable items are still unstable even when used through a stable \"pub use\".\n+        let x = reexport::Unstable2(1, 2, 3); //~ ERROR use of unstable\n \n         let x = Unstable2(1, 2, 3); //~ ERROR use of unstable\n "}, {"sha": "4b885e5e2bb8287070a98cea7e257aaacbce9c8f", "filename": "src/test/run-make-fulldeps/std-core-cycle/bar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Fbar.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -16,11 +16,11 @@ use std::alloc::*;\n pub struct A;\n \n unsafe impl GlobalAlloc for A {\n-    unsafe fn alloc(&self, _: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, _: Layout) -> *mut u8 {\n         loop {}\n     }\n \n-    unsafe fn dealloc(&self, _ptr: *mut Opaque, _: Layout) {\n+    unsafe fn dealloc(&self, _ptr: *mut u8, _: Layout) {\n         loop {}\n     }\n }"}, {"sha": "46047fb835d757242a52257babc410f4c19099cd", "filename": "src/test/run-make-fulldeps/std-core-cycle/foo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fstd-core-cycle%2Ffoo.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(global_allocator)]\n #![crate_type = \"cdylib\"]\n \n extern crate bar;"}, {"sha": "29cfae1692924a089214da02fd97c4e31e2646ef", "filename": "src/test/run-pass-valgrind/issue-44800.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass-valgrind%2Fissue-44800.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass-valgrind%2Fissue-44800.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fissue-44800.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -8,11 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(global_allocator, alloc_system, allocator_api)]\n-extern crate alloc_system;\n-\n+use std::alloc::System;\n use std::collections::VecDeque;\n-use alloc_system::System;\n \n #[global_allocator]\n static ALLOCATOR: System = System;"}, {"sha": "a3f05a01c5ad0d47bbbd13d37ddcea50e5a09aac", "filename": "src/test/run-pass/allocator/auxiliary/custom-as-global.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom-as-global.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -10,7 +10,6 @@\n \n // no-prefer-dynamic\n \n-#![feature(global_allocator)]\n #![crate_type = \"rlib\"]\n \n extern crate custom;"}, {"sha": "02e86fa19f8645a86500866088c37f41c10561e4", "filename": "src/test/run-pass/allocator/auxiliary/custom.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fauxiliary%2Fcustom.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -13,18 +13,18 @@\n #![feature(heap_api, allocator_api)]\n #![crate_type = \"rlib\"]\n \n-use std::alloc::{GlobalAlloc, System, Layout, Opaque};\n+use std::alloc::{GlobalAlloc, System, Layout};\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n pub struct A(pub AtomicUsize);\n \n unsafe impl GlobalAlloc for A {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         self.0.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "3a7f8fa86209401e72f73f110ccd8bce78d02f94", "filename": "src/test/run-pass/allocator/custom.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fcustom.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -11,24 +11,24 @@\n // aux-build:helper.rs\n // no-prefer-dynamic\n \n-#![feature(global_allocator, heap_api, allocator_api)]\n+#![feature(allocator_api)]\n \n extern crate helper;\n \n-use std::alloc::{self, Global, Alloc, System, Layout, Opaque};\n+use std::alloc::{self, Global, Alloc, System, Layout};\n use std::sync::atomic::{AtomicUsize, Ordering, ATOMIC_USIZE_INIT};\n \n static HITS: AtomicUsize = ATOMIC_USIZE_INIT;\n \n struct A;\n \n unsafe impl alloc::GlobalAlloc for A {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut Opaque {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.alloc(layout)\n     }\n \n-    unsafe fn dealloc(&self, ptr: *mut Opaque, layout: Layout) {\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         HITS.fetch_add(1, Ordering::SeqCst);\n         System.dealloc(ptr, layout)\n     }"}, {"sha": "482e3b04aae2dbe363e5262e7cb65eae196e1df2", "filename": "src/test/run-pass/allocator/xcrate-use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -12,7 +12,7 @@\n // aux-build:helper.rs\n // no-prefer-dynamic\n \n-#![feature(global_allocator, heap_api, allocator_api)]\n+#![feature(allocator_api)]\n \n extern crate custom;\n extern crate helper;"}, {"sha": "fbde7e855c2b06cdbb36c47d25779a211f436b6d", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -19,7 +19,7 @@ extern crate custom;\n extern crate custom_as_global;\n extern crate helper;\n \n-use std::alloc::{Global, Alloc, GlobalAlloc, System, Layout};\n+use std::alloc::{alloc, dealloc, GlobalAlloc, System, Layout};\n use std::sync::atomic::{Ordering, ATOMIC_USIZE_INIT};\n \n static GLOBAL: custom::A = custom::A(ATOMIC_USIZE_INIT);\n@@ -30,10 +30,10 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         // Global allocator routes to the `custom_as_global` global\n-        let ptr = Global.alloc(layout.clone());\n+        let ptr = alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 1);\n-        Global.dealloc(ptr, layout.clone());\n+        dealloc(ptr, layout.clone());\n         assert_eq!(custom_as_global::get(), n + 2);\n \n         // Usage of the system allocator avoids all globals"}, {"sha": "7152e721eac9e63642ef45ffae13e4571b79506f", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -64,15 +64,15 @@ unsafe fn test_triangle() -> bool {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Global.dealloc(NonNull::new_unchecked(ptr).as_opaque(), layout);\n+        Global.dealloc(NonNull::new_unchecked(ptr), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_opaque(), old, new.size())\n+        let ret = Global.realloc(NonNull::new_unchecked(ptr), old, new.size())\n             .unwrap_or_else(|_| oom(Layout::from_size_align_unchecked(new.size(), old.align())));\n \n         if PRINT {"}, {"sha": "3a0e2fe01db055ce62388095eca1225f80ae01a6", "filename": "src/test/run-pass/thin-lto-global-allocator.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fthin-lto-global-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4367e41ea2a105c373de27c2f080fc2527cc6927/src%2Ftest%2Frun-pass%2Fthin-lto-global-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthin-lto-global-allocator.rs?ref=4367e41ea2a105c373de27c2f080fc2527cc6927", "patch": "@@ -11,8 +11,6 @@\n // compile-flags: -Z thinlto -C codegen-units=2\n // min-llvm-version 4.0\n \n-#![feature(allocator_api, global_allocator)]\n-\n #[global_allocator]\n static A: std::alloc::System = std::alloc::System;\n "}, {"sha": "ff3c342f9e00343f223452e3ee15c2efeaf63f06", "filename": "src/test/ui/feature-gate-global_allocator.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f9944fde377b8b2575f96fff60f784eddce54002/src%2Ftest%2Fui%2Ffeature-gate-global_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9944fde377b8b2575f96fff60f784eddce54002/src%2Ftest%2Fui%2Ffeature-gate-global_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-global_allocator.rs?ref=f9944fde377b8b2575f96fff60f784eddce54002", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[global_allocator] //~ ERROR: attribute is an experimental feature\n-static A: usize = 0;\n-\n-fn main() {}"}, {"sha": "9f8b98ede09f164efa9602b1b8591f2749f24783", "filename": "src/test/ui/feature-gate-global_allocator.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f9944fde377b8b2575f96fff60f784eddce54002/src%2Ftest%2Fui%2Ffeature-gate-global_allocator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f9944fde377b8b2575f96fff60f784eddce54002/src%2Ftest%2Fui%2Ffeature-gate-global_allocator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-global_allocator.stderr?ref=f9944fde377b8b2575f96fff60f784eddce54002", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: the `#[global_allocator]` attribute is an experimental feature (see issue #27389)\n-  --> $DIR/feature-gate-global_allocator.rs:11:1\n-   |\n-LL | #[global_allocator] //~ ERROR: attribute is an experimental feature\n-   | ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: add #![feature(global_allocator)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}]}