{"sha": "e3211fa1f1f24268b91b0c89cb312e70499d41f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMjExZmExZjFmMjQyNjhiOTFiMGM4OWNiMzEyZTcwNDk5ZDQxZjM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-12T08:38:44Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-14T16:29:12Z"}, "message": "Purge the last remnants of the old TLS api\n\nCloses #3273", "tree": {"sha": "adcfe3900f33641ac4c73bff3e61f048d7270157", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adcfe3900f33641ac4c73bff3e61f048d7270157"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3211fa1f1f24268b91b0c89cb312e70499d41f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3211fa1f1f24268b91b0c89cb312e70499d41f3", "html_url": "https://github.com/rust-lang/rust/commit/e3211fa1f1f24268b91b0c89cb312e70499d41f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3211fa1f1f24268b91b0c89cb312e70499d41f3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "242606c79339e2d2e3cf15cc8f02bd6ebc0b8c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/242606c79339e2d2e3cf15cc8f02bd6ebc0b8c44", "html_url": "https://github.com/rust-lang/rust/commit/242606c79339e2d2e3cf15cc8f02bd6ebc0b8c44"}], "stats": {"total": 584, "additions": 291, "deletions": 293}, "files": [{"sha": "b7b74694475a44b43388863e5f11483875065798", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -66,24 +66,28 @@ pub unsafe fn read(prompt: &str) -> Option<~str> {\n     }\n }\n \n-pub type CompletionCb<'self> = @fn(~str, &'self fn(~str));\n+pub type CompletionCb = @fn(~str, @fn(~str));\n \n-fn complete_key(_v: @CompletionCb) {}\n+#[cfg(not(stage0))]\n+static complete_key: local_data::Key<@CompletionCb> = &[];\n+#[cfg(stage0)]\n+fn complete_key(_: @CompletionCb) {}\n \n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n-    local_data::set(complete_key, @(cb));\n+    local_data::set(complete_key, @cb);\n \n     extern fn callback(line: *c_char, completions: *()) {\n-        unsafe {\n-            let cb = *local_data::get(complete_key, |k| k.map(|&k| *k))\n-                .get();\n-\n-            do cb(str::raw::from_c_str(line)) |suggestion| {\n-                do str::as_c_str(suggestion) |buf| {\n-                    rustrt::linenoiseAddCompletion(completions, buf);\n+        do local_data::get(complete_key) |cb| {\n+            let cb = **cb.unwrap();\n+\n+            unsafe {\n+                do cb(str::raw::from_c_str(line)) |suggestion| {\n+                    do str::as_c_str(suggestion) |buf| {\n+                        rustrt::linenoiseAddCompletion(completions, buf);\n+                    }\n                 }\n-            }\n+}\n         }\n     }\n "}, {"sha": "db4ad43e41d7a4967c953441bcd7a93d5a2b9d03", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -1195,39 +1195,4 @@ mod big_tests {\n             isSorted(arr);\n         }\n     }\n-\n-    struct LVal<'self> {\n-        val: uint,\n-        key: &'self fn:Copy(@uint),\n-    }\n-\n-    #[unsafe_destructor]\n-    impl<'self> Drop for LVal<'self> {\n-        fn drop(&self) {\n-            let x = unsafe { local_data::get(self.key, |k| k.map(|&k| *k)) };\n-            match x {\n-                Some(@y) => {\n-                    unsafe {\n-                        local_data::set(self.key, @(y+1));\n-                    }\n-                }\n-                _ => fail!(\"Expected key to work\"),\n-            }\n-        }\n-    }\n-\n-    impl<'self> Ord for LVal<'self> {\n-        fn lt<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val < other.val\n-        }\n-        fn le<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val <= other.val\n-        }\n-        fn gt<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val > other.val\n-        }\n-        fn ge<'a>(&self, other: &'a LVal<'self>) -> bool {\n-            (*self).val >= other.val\n-        }\n-    }\n }"}, {"sha": "bfa325a21eef59bc70d7c2ef44a3c64b450de3a5", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -87,49 +87,44 @@ use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub use middle::trans::context::task_llcx;\n \n-fn task_local_insn_key(_v: @~[&'static str]) {}\n+#[cfg(not(stage0))]\n+static task_local_insn_key: local_data::Key<@~[&'static str]> = &[];\n+#[cfg(stage0)]\n+fn task_local_insn_key(_: @~[&'static str]) {}\n \n pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n-    unsafe {\n-        let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));\n-        if opt.is_some() {\n-            blk(*opt.unwrap());\n-        }\n+    let opt = local_data::get(task_local_insn_key, |k| k.map(|&k| *k));\n+    if opt.is_some() {\n+        blk(*opt.unwrap());\n     }\n }\n \n pub fn init_insn_ctxt() {\n-    unsafe {\n-        local_data::set(task_local_insn_key, @~[]);\n-    }\n+    local_data::set(task_local_insn_key, @~[]);\n }\n \n pub struct _InsnCtxt { _x: () }\n \n #[unsafe_destructor]\n impl Drop for _InsnCtxt {\n     fn drop(&self) {\n-        unsafe {\n-            do local_data::modify(task_local_insn_key) |c| {\n-                do c.map_consume |ctx| {\n-                    let mut ctx = copy *ctx;\n-                    ctx.pop();\n-                    @ctx\n-                }\n+        do local_data::modify(task_local_insn_key) |c| {\n+            do c.map_consume |ctx| {\n+                let mut ctx = copy *ctx;\n+                ctx.pop();\n+                @ctx\n             }\n         }\n     }\n }\n \n pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     debug!(\"new InsnCtxt: %s\", s);\n-    unsafe {\n-        do local_data::modify(task_local_insn_key) |c| {\n-            do c.map_consume |ctx| {\n-                let mut ctx = copy *ctx;\n-                ctx.push(s);\n-                @ctx\n-            }\n+    do local_data::modify(task_local_insn_key) |c| {\n+        do c.map_consume |ctx| {\n+            let mut ctx = copy *ctx;\n+            ctx.push(s);\n+            @ctx\n         }\n     }\n     _InsnCtxt { _x: () }"}, {"sha": "a2f0fd480e1d48e17f94093d8fb7070dd9d58077", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -232,22 +232,24 @@ impl CrateContext {\n #[unsafe_destructor]\n impl Drop for CrateContext {\n     fn drop(&self) {\n-        unsafe {\n-            unset_task_llcx();\n-        }\n+        unset_task_llcx();\n     }\n }\n \n+#[cfg(stage0)]\n fn task_local_llcx_key(_v: @ContextRef) {}\n+#[cfg(not(stage0))]\n+static task_local_llcx_key: local_data::Key<@ContextRef> = &[];\n+\n pub fn task_llcx() -> ContextRef {\n-    let opt = unsafe { local_data::get(task_local_llcx_key, |k| k.map(|&k| *k)) };\n+    let opt = local_data::get(task_local_llcx_key, |k| k.map(|&k| *k));\n     *opt.expect(\"task-local LLVMContextRef wasn't ever set!\")\n }\n \n-unsafe fn set_task_llcx(c: ContextRef) {\n+fn set_task_llcx(c: ContextRef) {\n     local_data::set(task_local_llcx_key, @c);\n }\n \n-unsafe fn unset_task_llcx() {\n+fn unset_task_llcx() {\n     local_data::pop(task_local_llcx_key);\n }"}, {"sha": "d1d5b47ff57f367a8853b017ecd4b9f2e8daa69c", "filename": "src/librusti/program.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -8,10 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cast;\n use std::hashmap::HashMap;\n use std::local_data;\n-use std::sys;\n+use std::vec;\n \n use syntax::ast;\n use syntax::parse::token;\n@@ -58,7 +57,7 @@ struct LocalVariable {\n }\n \n type LocalCache = @mut HashMap<~str, @~[u8]>;\n-fn tls_key(_k: LocalCache) {}\n+static tls_key: local_data::Key<LocalCache> = &[];\n \n impl Program {\n     pub fn new() -> Program {\n@@ -131,21 +130,18 @@ impl Program {\n             fn main() {\n         \");\n \n-        let key: sys::Closure = unsafe {\n-            let tls_key: &'static fn(LocalCache) = tls_key;\n-            cast::transmute(tls_key)\n-        };\n+        let key: *LocalCache = vec::raw::to_ptr(tls_key);\n         // First, get a handle to the tls map which stores all the local\n         // variables. This works by totally legitimately using the 'code'\n         // pointer of the 'tls_key' function as a uint, and then casting it back\n         // up to a function\n         code.push_str(fmt!(\"\n             let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe {\n-                let key = ::std::sys::Closure{ code: %? as *(),\n-                                               env: ::std::ptr::null() };\n+                let key = ::std::vec::raw::SliceRepr{ data: %? as *u8,\n+                                                      len: 0 };\n                 let key = ::std::cast::transmute(key);\n                 ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n-            };\\n\", key.code as uint));\n+            };\\n\", key as uint));\n \n         // Using this __tls_map handle, deserialize each variable binding that\n         // we know about\n@@ -226,18 +222,14 @@ impl Program {\n         for self.local_vars.iter().advance |(name, value)| {\n             map.insert(copy *name, @copy value.data);\n         }\n-        unsafe {\n-            local_data::set(tls_key, map);\n-        }\n+        local_data::set(tls_key, map);\n     }\n \n     /// Once the program has finished running, this function will consume the\n     /// task-local cache of local variables. After the program finishes running,\n     /// it updates this cache with the new values of each local variable.\n     pub fn consume_cache(&mut self) {\n-        let map = unsafe {\n-            local_data::pop(tls_key).expect(\"tls is empty\")\n-        };\n+        let map = local_data::pop(tls_key).expect(\"tls is empty\");\n         do map.consume |name, value| {\n             match self.local_vars.find_mut(&name) {\n                 Some(v) => { v.data = copy *value; }"}, {"sha": "3a5be12b3c586f1654928e9621cdb8103b6c1aaf", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 68, "deletions": 15, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -23,13 +23,59 @@ pub struct Handler<T, U> {\n     prev: Option<@Handler<T, U>>,\n }\n \n+#[cfg(stage0)]\n pub struct Condition<'self, T, U> {\n     name: &'static str,\n     key: local_data::Key<'self, @Handler<T, U>>\n }\n+#[cfg(not(stage0))]\n+pub struct Condition<T, U> {\n+    name: &'static str,\n+    key: local_data::Key<@Handler<T, U>>\n+}\n+\n+#[cfg(not(stage0))]\n+impl<T, U> Condition<T, U> {\n+    pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n+        unsafe {\n+            let p : *RustClosure = ::cast::transmute(&h);\n+            let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n+            let h = @Handler { handle: *p, prev: prev };\n+            Trap { cond: self, handler: h }\n+        }\n+    }\n+\n+    pub fn raise(&self, t: T) -> U {\n+        let msg = fmt!(\"Unhandled condition: %s: %?\", self.name, t);\n+        self.raise_default(t, || fail!(copy msg))\n+    }\n \n+    pub fn raise_default(&self, t: T, default: &fn() -> U) -> U {\n+        unsafe {\n+            match local_data::pop(self.key) {\n+                None => {\n+                    debug!(\"Condition.raise: found no handler\");\n+                    default()\n+                }\n+                Some(handler) => {\n+                    debug!(\"Condition.raise: found handler\");\n+                    match handler.prev {\n+                        None => {}\n+                        Some(hp) => local_data::set(self.key, hp)\n+                    }\n+                    let handle : &fn(T) -> U =\n+                        ::cast::transmute(handler.handle);\n+                    let u = handle(t);\n+                    local_data::set(self.key, handler);\n+                    u\n+                }\n+            }\n+        }\n+    }\n+}\n+#[cfg(stage0)]\n impl<'self, T, U> Condition<'self, T, U> {\n-    pub fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n+    pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n@@ -67,38 +113,45 @@ impl<'self, T, U> Condition<'self, T, U> {\n     }\n }\n \n+#[cfg(stage0)]\n struct Trap<'self, T, U> {\n     cond: &'self Condition<'self, T, U>,\n     handler: @Handler<T, U>\n }\n+#[cfg(not(stage0))]\n+struct Trap<'self, T, U> {\n+    cond: &'self Condition<T, U>,\n+    handler: @Handler<T, U>\n+}\n \n impl<'self, T, U> Trap<'self, T, U> {\n     pub fn in<V>(&self, inner: &'self fn() -> V) -> V {\n-        unsafe {\n-            let _g = Guard { cond: self.cond };\n-            debug!(\"Trap: pushing handler to TLS\");\n-            local_data::set(self.cond.key, self.handler);\n-            inner()\n-        }\n+        let _g = Guard { cond: self.cond };\n+        debug!(\"Trap: pushing handler to TLS\");\n+        local_data::set(self.cond.key, self.handler);\n+        inner()\n     }\n }\n \n+#[cfg(stage0)]\n struct Guard<'self, T, U> {\n     cond: &'self Condition<'self, T, U>\n }\n+#[cfg(not(stage0))]\n+struct Guard<'self, T, U> {\n+    cond: &'self Condition<T, U>\n+}\n \n #[unsafe_destructor]\n impl<'self, T, U> Drop for Guard<'self, T, U> {\n     fn drop(&self) {\n-        unsafe {\n-            debug!(\"Guard: popping handler from TLS\");\n-            let curr = local_data::pop(self.cond.key);\n-            match curr {\n+        debug!(\"Guard: popping handler from TLS\");\n+        let curr = local_data::pop(self.cond.key);\n+        match curr {\n+            None => {}\n+            Some(h) => match h.prev {\n                 None => {}\n-                Some(h) => match h.prev {\n-                    None => {}\n-                    Some(hp) => local_data::set(self.cond.key, hp)\n-                }\n+                Some(hp) => local_data::set(self.cond.key, hp)\n             }\n         }\n     }"}, {"sha": "640bcc757b3fb5be862c2c69437f6a6cf3d268d4", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 121, "deletions": 119, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -12,27 +12,25 @@\n \n Task local data management\n \n-Allows storing boxes with arbitrary types inside, to be accessed anywhere within\n-a task, keyed by a pointer to a global finaliser function. Useful for dynamic\n-variables, singletons, and interfacing with foreign code with bad callback\n-interfaces.\n+Allows storing arbitrary types inside task-local-storage (TLS), to be accessed\n+anywhere within a task, keyed by a global slice of the appropriate type.\n+Useful for dynamic variables, singletons, and interfacing with foreign code\n+with bad callback interfaces.\n \n-To use, declare a monomorphic (no type parameters) global function at the type\n-to store, and use it as the 'key' when accessing.\n+To use, declare a static slice of the type you wish to store. The initialization\n+should be `&[]`. This is then the key to what you wish to store.\n \n ~~~{.rust}\n use std::local_data;\n \n-fn key_int(_: @int) {}\n-fn key_vector(_: @~[int]) {}\n+static key_int: local_data::Key<int> = &[];\n+static key_vector: local_data::Key<~[int]> = &[];\n \n-unsafe {\n-    local_data::set(key_int, @3);\n-    assert!(local_data::get(key_int) == Some(@3));\n+local_data::set(key_int, 3);\n+local_data::get(key_int, |opt| assert_eq!(opt, Some(&3)));\n \n-    local_data::set(key_vector, @~[3]);\n-    assert!(local_data::get(key_vector).unwrap()[0] == 3);\n-}\n+local_data::set(key_vector, ~[4]);\n+local_data::get(key_int, |opt| assert_eq!(opt, Some(&~[4])));\n ~~~\n \n Casting 'Arcane Sight' reveals an overwhelming aura of Transmutation\n@@ -60,63 +58,65 @@ use task::local_data_priv::{local_get, local_pop, local_set, Handle};\n  *\n  * These two cases aside, the interface is safe.\n  */\n+#[cfg(not(stage0))]\n+pub type Key<T> = &'static [T];\n+#[cfg(stage0)]\n pub type Key<'self,T> = &'self fn:Copy(v: T);\n \n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n #[cfg(stage0)]\n-pub unsafe fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n-    local_pop(Handle::new(), key)\n+pub fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n+    unsafe { local_pop(Handle::new(), key) }\n }\n /**\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n-    local_pop(Handle::new(), key)\n+pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n+    unsafe { local_pop(Handle::new(), key) }\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n #[cfg(stage0)]\n-pub unsafe fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n-    local_get(Handle::new(), key, f)\n+pub fn get<T: 'static, U>(key: Key<@T>, f: &fn(Option<&@T>) -> U) -> U {\n+    unsafe { local_get(Handle::new(), key, f) }\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n-    local_get(Handle::new(), key, f)\n+pub fn get<T: 'static, U>(key: Key<T>, f: &fn(Option<&T>) -> U) -> U {\n+    unsafe { local_get(Handle::new(), key, f) }\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n #[cfg(stage0)]\n-pub unsafe fn set<T: 'static>(key: Key<@T>, data: @T) {\n-    local_set(Handle::new(), key, data)\n+pub fn set<T: 'static>(key: Key<@T>, data: @T) {\n+    unsafe { local_set(Handle::new(), key, data) }\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn set<T: 'static>(key: Key<T>, data: T) {\n-    local_set(Handle::new(), key, data)\n+pub fn set<T: 'static>(key: Key<T>, data: T) {\n+    unsafe { local_set(Handle::new(), key, data) }\n }\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n #[cfg(stage0)]\n-pub unsafe fn modify<T: 'static>(key: Key<@T>,\n-                                 f: &fn(Option<@T>) -> Option<@T>) {\n+pub fn modify<T: 'static>(key: Key<@T>, f: &fn(Option<@T>) -> Option<@T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}\n@@ -127,8 +127,7 @@ pub unsafe fn modify<T: 'static>(key: Key<@T>,\n  * data is removed (and its reference dropped).\n  */\n #[cfg(not(stage0))]\n-pub unsafe fn modify<T: 'static>(key: Key<T>,\n-                                 f: &fn(Option<T>) -> Option<T>) {\n+pub fn modify<T: 'static>(key: Key<T>, f: &fn(Option<T>) -> Option<T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}\n@@ -137,64 +136,56 @@ pub unsafe fn modify<T: 'static>(key: Key<T>,\n \n #[test]\n fn test_tls_multitask() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        set(my_key, @~\"parent data\");\n-        do task::spawn {\n-            // TLS shouldn't carry over.\n-            assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n-            set(my_key, @~\"child data\");\n-            assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n-                    ~\"child data\");\n-            // should be cleaned up for us\n-        }\n-        // Must work multiple times\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    static my_key: Key<@~str> = &[];\n+    set(my_key, @~\"parent data\");\n+    do task::spawn {\n+        // TLS shouldn't carry over.\n+        assert!(get(my_key, |k| k.map(|&k| *k)).is_none());\n+        set(my_key, @~\"child data\");\n+        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) ==\n+                ~\"child data\");\n+        // should be cleaned up for us\n     }\n+    // Must work multiple times\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"parent data\");\n }\n \n #[test]\n fn test_tls_overwrite() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        set(my_key, @~\"first data\");\n-        set(my_key, @~\"next data\"); // Shouldn't leak.\n-        assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n-    }\n+    static my_key: Key<@~str> = &[];\n+    set(my_key, @~\"first data\");\n+    set(my_key, @~\"next data\"); // Shouldn't leak.\n+    assert!(*(get(my_key, |k| k.map(|&k| *k)).get()) == ~\"next data\");\n }\n \n #[test]\n fn test_tls_pop() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        set(my_key, @~\"weasel\");\n-        assert!(*(pop(my_key).get()) == ~\"weasel\");\n-        // Pop must remove the data from the map.\n-        assert!(pop(my_key).is_none());\n-    }\n+    static my_key: Key<@~str> = &[];\n+    set(my_key, @~\"weasel\");\n+    assert!(*(pop(my_key).get()) == ~\"weasel\");\n+    // Pop must remove the data from the map.\n+    assert!(pop(my_key).is_none());\n }\n \n #[test]\n fn test_tls_modify() {\n-    unsafe {\n-        fn my_key(_x: @~str) { }\n-        modify(my_key, |data| {\n-            match data {\n-                Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n-                None           => Some(@~\"first data\")\n-            }\n-        });\n-        modify(my_key, |data| {\n-            match data {\n-                Some(@~\"first data\") => Some(@~\"next data\"),\n-                Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n-                None                 => fail!(\"missing value\")\n-            }\n-        });\n-        assert!(*(pop(my_key).get()) == ~\"next data\");\n-    }\n+    static my_key: Key<@~str> = &[];\n+    modify(my_key, |data| {\n+        match data {\n+            Some(@ref val) => fail!(\"unwelcome value: %s\", *val),\n+            None           => Some(@~\"first data\")\n+        }\n+    });\n+    modify(my_key, |data| {\n+        match data {\n+            Some(@~\"first data\") => Some(@~\"next data\"),\n+            Some(@ref val)       => fail!(\"wrong value: %s\", *val),\n+            None                 => fail!(\"missing value\")\n+        }\n+    });\n+    assert!(*(pop(my_key).get()) == ~\"next data\");\n }\n \n #[test]\n@@ -205,79 +196,90 @@ fn test_tls_crust_automorestack_memorial_bug() {\n     // to get recorded as something within a rust stack segment. Then a\n     // subsequent upcall (esp. for logging, think vsnprintf) would run on\n     // a stack smaller than 1 MB.\n-    fn my_key(_x: @~str) { }\n+    static my_key: Key<@~str> = &[];\n     do task::spawn {\n-        unsafe { set(my_key, @~\"hax\"); }\n+        set(my_key, @~\"hax\");\n     }\n }\n \n #[test]\n fn test_tls_multiple_types() {\n-    fn str_key(_x: @~str) { }\n-    fn box_key(_x: @@()) { }\n-    fn int_key(_x: @int) { }\n+    static str_key: Key<@~str> = &[];\n+    static box_key: Key<@@()> = &[];\n+    static int_key: Key<@int> = &[];\n     do task::spawn {\n-        unsafe {\n-            set(str_key, @~\"string data\");\n-            set(box_key, @@());\n-            set(int_key, @42);\n-        }\n+        set(str_key, @~\"string data\");\n+        set(box_key, @@());\n+        set(int_key, @42);\n     }\n }\n \n #[test]\n fn test_tls_overwrite_multiple_types() {\n-    fn str_key(_x: @~str) { }\n-    fn box_key(_x: @@()) { }\n-    fn int_key(_x: @int) { }\n+    static str_key: Key<@~str> = &[];\n+    static box_key: Key<@@()> = &[];\n+    static int_key: Key<@int> = &[];\n     do task::spawn {\n-        unsafe {\n-            set(str_key, @~\"string data\");\n-            set(int_key, @42);\n-            // This could cause a segfault if overwriting-destruction is done\n-            // with the crazy polymorphic transmute rather than the provided\n-            // finaliser.\n-            set(int_key, @31337);\n-        }\n+        set(str_key, @~\"string data\");\n+        set(int_key, @42);\n+        // This could cause a segfault if overwriting-destruction is done\n+        // with the crazy polymorphic transmute rather than the provided\n+        // finaliser.\n+        set(int_key, @31337);\n     }\n }\n \n #[test]\n #[should_fail]\n #[ignore(cfg(windows))]\n fn test_tls_cleanup_on_failure() {\n-    unsafe {\n-        fn str_key(_x: @~str) { }\n-        fn box_key(_x: @@()) { }\n-        fn int_key(_x: @int) { }\n-        set(str_key, @~\"parent data\");\n+    static str_key: Key<@~str> = &[];\n+    static box_key: Key<@@()> = &[];\n+    static int_key: Key<@int> = &[];\n+    set(str_key, @~\"parent data\");\n+    set(box_key, @@());\n+    do task::spawn {\n+        // spawn_linked\n+        set(str_key, @~\"string data\");\n         set(box_key, @@());\n-        do task::spawn {\n-            // spawn_linked\n-            set(str_key, @~\"string data\");\n-            set(box_key, @@());\n-            set(int_key, @42);\n-            fail!();\n-        }\n-        // Not quite nondeterministic.\n-        set(int_key, @31337);\n+        set(int_key, @42);\n         fail!();\n     }\n+    // Not quite nondeterministic.\n+    set(int_key, @31337);\n+    fail!();\n }\n \n #[test]\n fn test_static_pointer() {\n-    unsafe {\n-        fn key(_x: @&'static int) { }\n-        static VALUE: int = 0;\n-        set(key, @&VALUE);\n-    }\n+    static key: Key<@&'static int> = &[];\n+    static VALUE: int = 0;\n+    let v: @&'static int = @&VALUE;\n+    set(key, v);\n }\n \n #[test]\n fn test_owned() {\n-    unsafe {\n-        fn key(_x: ~int) { }\n-        set(key, ~1);\n-    }\n+    static key: Key<~int> = &[];\n+    set(key, ~1);\n+}\n+\n+#[test]\n+fn test_same_key_type() {\n+    static key1: Key<int> = &[];\n+    static key2: Key<int> = &[];\n+    static key3: Key<int> = &[];\n+    static key4: Key<int> = &[];\n+    static key5: Key<int> = &[];\n+    set(key1, 1);\n+    set(key2, 2);\n+    set(key3, 3);\n+    set(key4, 4);\n+    set(key5, 5);\n+\n+    get(key1, |x| assert_eq!(*x.unwrap(), 1));\n+    get(key2, |x| assert_eq!(*x.unwrap(), 2));\n+    get(key3, |x| assert_eq!(*x.unwrap(), 3));\n+    get(key4, |x| assert_eq!(*x.unwrap(), 4));\n+    get(key5, |x| assert_eq!(*x.unwrap(), 5));\n }"}, {"sha": "cbd1e4e7663f60c9f44dc41b1f79fd54de133d64", "filename": "src/libstd/os.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -1239,30 +1239,29 @@ struct OverriddenArgs {\n     val: ~[~str]\n }\n \n+#[cfg(stage0)]\n fn overridden_arg_key(_v: @OverriddenArgs) {}\n+#[cfg(not(stage0))]\n+static overridden_arg_key: local_data::Key<@OverriddenArgs> = &[];\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n ///\n /// The return value of the function can be changed by invoking the\n /// `os::set_args` function.\n pub fn args() -> ~[~str] {\n-    unsafe {\n-        match local_data::get(overridden_arg_key, |k| k.map(|&k| *k)) {\n-            None => real_args(),\n-            Some(args) => copy args.val\n-        }\n+    match local_data::get(overridden_arg_key, |k| k.map(|&k| *k)) {\n+        None => real_args(),\n+        Some(args) => copy args.val\n     }\n }\n \n /// For the current task, overrides the task-local cache of the arguments this\n /// program had when it started. These new arguments are only available to the\n /// current task via the `os::args` method.\n pub fn set_args(new_args: ~[~str]) {\n-    unsafe {\n-        let overridden_args = @OverriddenArgs { val: copy new_args };\n-        local_data::set(overridden_arg_key, overridden_args);\n-    }\n+    let overridden_args = @OverriddenArgs { val: copy new_args };\n+    local_data::set(overridden_arg_key, overridden_args);\n }\n \n // FIXME #6100 we should really use an internal implementation of this - using"}, {"sha": "8551012d6d77aba7c36d143f4cf64bb9ae1c8ef2", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -851,7 +851,10 @@ pub fn seed() -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n+#[cfg(stage0)]\n fn tls_rng_state(_v: @@mut IsaacRng) {}\n+#[cfg(not(stage0))]\n+static tls_rng_state: local_data::Key<@@mut IsaacRng> = &[];\n \n /**\n  * Gives back a lazily initialized task-local random number generator,\n@@ -860,17 +863,12 @@ fn tls_rng_state(_v: @@mut IsaacRng) {}\n  */\n #[inline]\n pub fn task_rng() -> @mut IsaacRng {\n-    let r : Option<@@mut IsaacRng>;\n-    unsafe {\n-        r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n-    }\n+    let r = local_data::get(tls_rng_state, |k| k.map(|&k| *k));\n     match r {\n         None => {\n-            unsafe {\n-                let rng = @@mut IsaacRng::new_seeded(seed());\n-                local_data::set(tls_rng_state, rng);\n-                *rng\n-            }\n+            let rng = @@mut IsaacRng::new_seeded(seed());\n+            local_data::set(tls_rng_state, rng);\n+            *rng\n         }\n         Some(rng) => *rng\n     }"}, {"sha": "0fd8c5c03d3398d394278f320c6c0eaa06856578", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -348,14 +348,12 @@ mod test {\n     fn tls() {\n         use local_data;\n         do run_in_newsched_task() {\n-            unsafe {\n-                fn key(_x: @~str) { }\n-                local_data::set(key, @~\"data\");\n-                assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n-                fn key2(_x: @~str) { }\n-                local_data::set(key2, @~\"data\");\n-                assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n-            }\n+            static key: local_data::Key<@~str> = &[];\n+            local_data::set(key, @~\"data\");\n+            assert!(*local_data::get(key, |k| k.map(|&k| *k)).get() == ~\"data\");\n+            static key2: local_data::Key<@~str> = &[];\n+            local_data::set(key2, @~\"data\");\n+            assert!(*local_data::get(key2, |k| k.map(|&k| *k)).get() == ~\"data\");\n         }\n     }\n "}, {"sha": "1a2141e996a489d61a30eb147f2a75f2c4aac96d", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -15,9 +15,9 @@ use libc;\n use local_data;\n use prelude::*;\n use ptr;\n-use sys;\n use task::rt;\n use util;\n+use vec;\n \n use super::rt::rust_task;\n use rt::task::{Task, LocalStorage};\n@@ -142,9 +142,8 @@ unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n     }\n }\n \n-unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n-    let pair: sys::Closure = cast::transmute(key);\n-    return pair.code as *libc::c_void;\n+fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void {\n+    return vec::raw::to_ptr(key) as *libc::c_void;\n }\n \n pub unsafe fn local_pop<T: 'static>(handle: Handle,"}, {"sha": "0b876bf1f817c492ddcb03e8900506349648a400", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -20,7 +20,6 @@ use std::hashmap::HashMap;\n use std::int;\n use std::num;\n use std::option;\n-use std::cast;\n use std::local_data;\n \n pub fn path_name_i(idents: &[ident]) -> ~str {\n@@ -695,18 +694,17 @@ pub fn new_sctable_internal() -> SCTable {\n \n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_sctable() -> @mut SCTable {\n-    unsafe {\n-        let sctable_key = (cast::transmute::<(uint, uint),\n-                           &fn:Copy(v: @@mut SCTable)>(\n-                               (-4 as uint, 0u)));\n-        match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n-            None => {\n-                let new_table = @@mut new_sctable_internal();\n-                local_data::set(sctable_key,new_table);\n-                *new_table\n-            },\n-            Some(intr) => *intr\n-        }\n+    #[cfg(not(stage0))]\n+    static sctable_key: local_data::Key<@@mut SCTable> = &[];\n+    #[cfg(stage0)]\n+    fn sctable_key(_: @@mut SCTable) {}\n+    match local_data::get(sctable_key, |k| k.map(|&k| *k)) {\n+        None => {\n+            let new_table = @@mut new_sctable_internal();\n+            local_data::set(sctable_key,new_table);\n+            *new_table\n+        },\n+        Some(intr) => *intr\n     }\n }\n "}, {"sha": "4fbc38628489248d276f9e97f58376ced6000525", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -579,11 +579,11 @@ pub fn core_macros() -> @str {\n         { pub $c:ident: $in:ty -> $out:ty; } => {\n \n             pub mod $c {\n-                fn key(_x: @::std::condition::Handler<$in,$out>) { }\n+                #[allow(non_uppercase_statics)];\n+                static key: &'static [@::std::condition::Handler<$in, $out>] = &[];\n \n-                #[allow(non_uppercase_statics)]\n                 pub static cond :\n-                    ::std::condition::Condition<'static,$in,$out> =\n+                    ::std::condition::Condition<$in,$out> =\n                     ::std::condition::Condition {\n                         name: stringify!($c),\n                         key: key\n@@ -595,11 +595,11 @@ pub fn core_macros() -> @str {\n \n             // FIXME (#6009): remove mod's `pub` below once variant above lands.\n             pub mod $c {\n-                fn key(_x: @::std::condition::Handler<$in,$out>) { }\n+                #[allow(non_uppercase_statics)];\n+                static key: &'static [@::std::condition::Handler<$in, $out>] = &[];\n \n-                #[allow(non_uppercase_statics)]\n                 pub static cond :\n-                    ::std::condition::Condition<'static,$in,$out> =\n+                    ::std::condition::Condition<$in,$out> =\n                     ::std::condition::Condition {\n                         name: stringify!($c),\n                         key: key"}, {"sha": "8737e571399be0519da9c1ce443cd0ae1c545bdb", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -15,7 +15,6 @@ use parse::token;\n use util::interner::StrInterner;\n use util::interner;\n \n-use std::cast;\n use std::cmp::Equiv;\n use std::local_data;\n use std::rand;\n@@ -485,18 +484,16 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n-    unsafe {\n-        let key =\n-            (cast::transmute::<(uint, uint),\n-             &fn:Copy(v: @@::parse::token::ident_interner)>(\n-                 (-3 as uint, 0u)));\n-        match local_data::get(key, |k| k.map(|&k| *k)) {\n-            Some(interner) => *interner,\n-            None => {\n-                let interner = mk_fresh_ident_interner();\n-                local_data::set(key, @interner);\n-                interner\n-            }\n+    #[cfg(not(stage0))]\n+    static key: local_data::Key<@@::parse::token::ident_interner> = &[];\n+    #[cfg(stage0)]\n+    fn key(_: @@::parse::token::ident_interner) {}\n+    match local_data::get(key, |k| k.map(|&k| *k)) {\n+        Some(interner) => *interner,\n+        None => {\n+            let interner = mk_fresh_ident_interner();\n+            local_data::set(key, @interner);\n+            interner\n         }\n     }\n }"}, {"sha": "f5b7f34b3653085f56e26171a30ed55d031e0a04", "filename": "src/test/compile-fail/core-tls-store-pointer.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3211fa1f1f24268b91b0c89cb312e70499d41f3/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcore-tls-store-pointer.rs?ref=e3211fa1f1f24268b91b0c89cb312e70499d41f3", "patch": "@@ -12,10 +12,6 @@\n \n use std::local_data;\n \n-fn key(_x: @&int) { }\n+static key: local_data::Key<@&int> = &[]; //~ ERROR only 'static is allowed\n \n-fn main() {\n-    unsafe {\n-        local_data::set(key, @&0); //~ ERROR does not fulfill `'static`\n-    }\n-}\n+fn main() {}"}]}