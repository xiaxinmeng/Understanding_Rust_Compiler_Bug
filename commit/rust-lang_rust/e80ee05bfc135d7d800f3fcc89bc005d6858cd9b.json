{"sha": "e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4MGVlMDViZmMxMzVkN2Q4MDBmM2ZjYzg5YmMwMDVkNjg1OGNkOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-12T23:23:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-12T23:23:56Z"}, "message": "Auto merge of #78998 - m-ou-se:rollup-6r4pt9m, r=m-ou-se\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #76730 (Fix rustdoc rendering of by-value mutable arguments in async fn)\n - #78836 (Implement destructuring assignment for structs and slices)\n - #78857 (Improve BinaryHeap performance)\n - #78950 (Add asm register information for SPIR-V)\n - #78970 (update rustfmt to v1.4.25)\n - #78972 (Update cargo)\n - #78987 (extend min_const_generics param ty tests)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4b8950bc77d07a409c0c444ac07d6816785eede1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b8950bc77d07a409c0c444ac07d6816785eede1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "html_url": "https://github.com/rust-lang/rust/commit/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9722952f0bed5815cb22cb4878be09fb39f92804", "url": "https://api.github.com/repos/rust-lang/rust/commits/9722952f0bed5815cb22cb4878be09fb39f92804", "html_url": "https://github.com/rust-lang/rust/commit/9722952f0bed5815cb22cb4878be09fb39f92804"}, {"sha": "38ca6e3561dbd2465cd604feeed93cf82580745c", "url": "https://api.github.com/repos/rust-lang/rust/commits/38ca6e3561dbd2465cd604feeed93cf82580745c", "html_url": "https://github.com/rust-lang/rust/commit/38ca6e3561dbd2465cd604feeed93cf82580745c"}], "stats": {"total": 972, "additions": 839, "deletions": 133}, "files": [{"sha": "c72c7b8481b5bb5d2b35cd9a7e60f06643d5aa1e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -4329,7 +4329,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.24\"\n+version = \"1.4.25\"\n dependencies = [\n  \"annotate-snippets 0.6.1\",\n  \"anyhow\","}, {"sha": "3e953729aabecaabac7e5c6b87fc583b5746bd1c", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1061,7 +1061,7 @@ pub struct Expr {\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Expr, 112);\n+rustc_data_structures::static_assert_size!(Expr, 120);\n \n impl Expr {\n     /// Returns `true` if this expression would be valid somewhere that expects a value;\n@@ -1218,6 +1218,16 @@ pub enum RangeLimits {\n     Closed,\n }\n \n+#[derive(Clone, Encodable, Decodable, Debug)]\n+pub enum StructRest {\n+    /// `..x`.\n+    Base(P<Expr>),\n+    /// `..`.\n+    Rest(Span),\n+    /// No trailing `..` or expression.\n+    None,\n+}\n+\n #[derive(Clone, Encodable, Decodable, Debug)]\n pub enum ExprKind {\n     /// A `box x` expression.\n@@ -1312,7 +1322,7 @@ pub enum ExprKind {\n     Field(P<Expr>, Ident),\n     /// An indexing operation (e.g., `foo[2]`).\n     Index(P<Expr>, P<Expr>),\n-    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`).\n+    /// A range (e.g., `1..2`, `1..`, `..2`, `1..=2`, `..=2`; and `..` in destructuring assingment).\n     Range(Option<P<Expr>>, Option<P<Expr>>, RangeLimits),\n \n     /// Variable reference, possibly containing `::` and/or type\n@@ -1340,9 +1350,8 @@ pub enum ExprKind {\n \n     /// A struct literal expression.\n     ///\n-    /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. base}`,\n-    /// where `base` is the `Option<Expr>`.\n-    Struct(Path, Vec<Field>, Option<P<Expr>>),\n+    /// E.g., `Foo {x: 1, y: 2}`, or `Foo {x: 1, .. rest}`.\n+    Struct(Path, Vec<Field>, StructRest),\n \n     /// An array literal constructed from one repeated element.\n     ///"}, {"sha": "26097980e8be441c4a7b1c7273334d154cff05a9", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1288,7 +1288,11 @@ pub fn noop_visit_expr<T: MutVisitor>(\n         ExprKind::Struct(path, fields, expr) => {\n             vis.visit_path(path);\n             fields.flat_map_in_place(|field| vis.flat_map_field(field));\n-            visit_opt(expr, |expr| vis.visit_expr(expr));\n+            match expr {\n+                StructRest::Base(expr) => vis.visit_expr(expr),\n+                StructRest::Rest(_span) => {}\n+                StructRest::None => {}\n+            }\n         }\n         ExprKind::Paren(expr) => {\n             vis.visit_expr(expr);"}, {"sha": "49b521afcdc782df7c80eee1abe38fdc663332b6", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -719,7 +719,11 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Struct(ref path, ref fields, ref optional_base) => {\n             visitor.visit_path(path, expression.id);\n             walk_list!(visitor, visit_field, fields);\n-            walk_list!(visitor, visit_expr, optional_base);\n+            match optional_base {\n+                StructRest::Base(expr) => visitor.visit_expr(expr),\n+                StructRest::Rest(_span) => {}\n+                StructRest::None => {}\n+            }\n         }\n         ExprKind::Tup(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);"}, {"sha": "330776fc8c5980f8fdaee02cac5cfdb3a4c365e7", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 119, "deletions": 7, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -187,8 +187,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 ExprKind::InlineAsm(ref asm) => self.lower_expr_asm(e.span, asm),\n                 ExprKind::LlvmInlineAsm(ref asm) => self.lower_expr_llvm_asm(asm),\n-                ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    let maybe_expr = maybe_expr.as_ref().map(|x| self.lower_expr(x));\n+                ExprKind::Struct(ref path, ref fields, ref rest) => {\n+                    let rest = match rest {\n+                        StructRest::Base(e) => Some(self.lower_expr(e)),\n+                        StructRest::Rest(sp) => {\n+                            self.sess\n+                                .struct_span_err(*sp, \"base expression required after `..`\")\n+                                .span_label(*sp, \"add a base expression here\")\n+                                .emit();\n+                            Some(&*self.arena.alloc(self.expr_err(*sp)))\n+                        }\n+                        StructRest::None => None,\n+                    };\n                     hir::ExprKind::Struct(\n                         self.arena.alloc(self.lower_qpath(\n                             e.id,\n@@ -198,7 +208,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             ImplTraitContext::disallowed(),\n                         )),\n                         self.arena.alloc_from_iter(fields.iter().map(|x| self.lower_field(x))),\n-                        maybe_expr,\n+                        rest,\n                     )\n                 }\n                 ExprKind::Yield(ref opt_expr) => self.lower_expr_yield(e.span, opt_expr.as_deref()),\n@@ -851,20 +861,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         whole_span: Span,\n     ) -> hir::ExprKind<'hir> {\n         // Return early in case of an ordinary assignment.\n-        fn is_ordinary(lhs: &Expr) -> bool {\n+        fn is_ordinary(lower_ctx: &mut LoweringContext<'_, '_>, lhs: &Expr) -> bool {\n             match &lhs.kind {\n-                ExprKind::Tup(..) => false,\n+                ExprKind::Array(..) | ExprKind::Struct(..) | ExprKind::Tup(..) => false,\n+                // Check for tuple struct constructor.\n+                ExprKind::Call(callee, ..) => lower_ctx.extract_tuple_struct_path(callee).is_none(),\n                 ExprKind::Paren(e) => {\n                     match e.kind {\n                         // We special-case `(..)` for consistency with patterns.\n                         ExprKind::Range(None, None, RangeLimits::HalfOpen) => false,\n-                        _ => is_ordinary(e),\n+                        _ => is_ordinary(lower_ctx, e),\n                     }\n                 }\n                 _ => true,\n             }\n         }\n-        if is_ordinary(lhs) {\n+        if is_ordinary(self, lhs) {\n             return hir::ExprKind::Assign(self.lower_expr(lhs), self.lower_expr(rhs), eq_sign_span);\n         }\n         if !self.sess.features_untracked().destructuring_assignment {\n@@ -902,6 +914,26 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ExprKind::Block(&self.block_all(whole_span, stmts, None), None)\n     }\n \n+    /// If the given expression is a path to a tuple struct, returns that path.\n+    /// It is not a complete check, but just tries to reject most paths early\n+    /// if they are not tuple structs.\n+    /// Type checking will take care of the full validation later.\n+    fn extract_tuple_struct_path<'a>(&mut self, expr: &'a Expr) -> Option<&'a Path> {\n+        // For tuple struct destructuring, it must be a non-qualified path (like in patterns).\n+        if let ExprKind::Path(None, path) = &expr.kind {\n+            // Does the path resolves to something disallowed in a tuple struct/variant pattern?\n+            if let Some(partial_res) = self.resolver.get_partial_res(expr.id) {\n+                if partial_res.unresolved_segments() == 0\n+                    && !partial_res.base_res().expected_in_tuple_struct_pat()\n+                {\n+                    return None;\n+                }\n+            }\n+            return Some(path);\n+        }\n+        None\n+    }\n+\n     /// Convert the LHS of a destructuring assignment to a pattern.\n     /// Each sub-assignment is recorded in `assignments`.\n     fn destructure_assign(\n@@ -911,6 +943,86 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         assignments: &mut Vec<hir::Stmt<'hir>>,\n     ) -> &'hir hir::Pat<'hir> {\n         match &lhs.kind {\n+            // Slice patterns.\n+            ExprKind::Array(elements) => {\n+                let (pats, rest) =\n+                    self.destructure_sequence(elements, \"slice\", eq_sign_span, assignments);\n+                let slice_pat = if let Some((i, span)) = rest {\n+                    let (before, after) = pats.split_at(i);\n+                    hir::PatKind::Slice(\n+                        before,\n+                        Some(self.pat_without_dbm(span, hir::PatKind::Wild)),\n+                        after,\n+                    )\n+                } else {\n+                    hir::PatKind::Slice(pats, None, &[])\n+                };\n+                return self.pat_without_dbm(lhs.span, slice_pat);\n+            }\n+            // Tuple structs.\n+            ExprKind::Call(callee, args) => {\n+                if let Some(path) = self.extract_tuple_struct_path(callee) {\n+                    let (pats, rest) = self.destructure_sequence(\n+                        args,\n+                        \"tuple struct or variant\",\n+                        eq_sign_span,\n+                        assignments,\n+                    );\n+                    let qpath = self.lower_qpath(\n+                        callee.id,\n+                        &None,\n+                        path,\n+                        ParamMode::Optional,\n+                        ImplTraitContext::disallowed(),\n+                    );\n+                    // Destructure like a tuple struct.\n+                    let tuple_struct_pat =\n+                        hir::PatKind::TupleStruct(qpath, pats, rest.map(|r| r.0));\n+                    return self.pat_without_dbm(lhs.span, tuple_struct_pat);\n+                }\n+            }\n+            // Structs.\n+            ExprKind::Struct(path, fields, rest) => {\n+                let field_pats = self.arena.alloc_from_iter(fields.iter().map(|f| {\n+                    let pat = self.destructure_assign(&f.expr, eq_sign_span, assignments);\n+                    hir::FieldPat {\n+                        hir_id: self.next_id(),\n+                        ident: f.ident,\n+                        pat,\n+                        is_shorthand: f.is_shorthand,\n+                        span: f.span,\n+                    }\n+                }));\n+                let qpath = self.lower_qpath(\n+                    lhs.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                let fields_omitted = match rest {\n+                    StructRest::Base(e) => {\n+                        self.sess\n+                            .struct_span_err(\n+                                e.span,\n+                                \"functional record updates are not allowed in destructuring \\\n+                                    assignments\",\n+                            )\n+                            .span_suggestion(\n+                                e.span,\n+                                \"consider removing the trailing pattern\",\n+                                String::new(),\n+                                rustc_errors::Applicability::MachineApplicable,\n+                            )\n+                            .emit();\n+                        true\n+                    }\n+                    StructRest::Rest(_) => true,\n+                    StructRest::None => false,\n+                };\n+                let struct_pat = hir::PatKind::Struct(qpath, field_pats, fields_omitted);\n+                return self.pat_without_dbm(lhs.span, struct_pat);\n+            }\n             // Tuples.\n             ExprKind::Tup(elements) => {\n                 let (pats, rest) ="}, {"sha": "d353bc19f7aef510d759169cc2446527bafd4ef6", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1096,8 +1096,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n                 let (ident, is_simple_parameter) = match parameter.pat.kind {\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) => {\n-                        (ident, true)\n+                    hir::PatKind::Binding(\n+                        hir::BindingAnnotation::Unannotated | hir::BindingAnnotation::Mutable,\n+                        _,\n+                        ident,\n+                        _,\n+                    ) => (ident, true),\n+                    // For `ref mut` or wildcard arguments, we can't reuse the binding, but\n+                    // we can keep the same name for the parameter.\n+                    // This lets rustdoc render it correctly in documentation.\n+                    hir::PatKind::Binding(_, _, ident, _) => (ident, false),\n+                    hir::PatKind::Wild => {\n+                        (Ident::with_dummy_span(rustc_span::symbol::kw::Underscore), false)\n                     }\n                     _ => {\n                         // Replace the ident for bindings that aren't simple."}, {"sha": "2831675cb36712558a7fb6da536bf69696925e84", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -630,6 +630,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n     gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n     gate_all!(inline_const, \"inline-const is experimental\");\n+    gate_all!(destructuring_assignment, \"destructuring assignments are unstable\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "a566200c3389678f511c95689dfc379ffedb4fc6", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1729,7 +1729,7 @@ impl<'a> State<'a> {\n         &mut self,\n         path: &ast::Path,\n         fields: &[ast::Field],\n-        wth: &Option<P<ast::Expr>>,\n+        rest: &ast::StructRest,\n         attrs: &[ast::Attribute],\n     ) {\n         self.print_path(path, true, 0);\n@@ -1750,22 +1750,21 @@ impl<'a> State<'a> {\n             },\n             |f| f.span,\n         );\n-        match *wth {\n-            Some(ref expr) => {\n+        match rest {\n+            ast::StructRest::Base(_) | ast::StructRest::Rest(_) => {\n                 self.ibox(INDENT_UNIT);\n                 if !fields.is_empty() {\n                     self.s.word(\",\");\n                     self.s.space();\n                 }\n                 self.s.word(\"..\");\n-                self.print_expr(expr);\n-                self.end();\n-            }\n-            _ => {\n-                if !fields.is_empty() {\n-                    self.s.word(\",\")\n+                if let ast::StructRest::Base(ref expr) = *rest {\n+                    self.print_expr(expr);\n                 }\n+                self.end();\n             }\n+            ast::StructRest::None if !fields.is_empty() => self.s.word(\",\"),\n+            _ => {}\n         }\n         self.s.word(\"}\");\n     }\n@@ -1891,8 +1890,8 @@ impl<'a> State<'a> {\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(element, count, attrs);\n             }\n-            ast::ExprKind::Struct(ref path, ref fields, ref wth) => {\n-                self.print_expr_struct(path, &fields[..], wth, attrs);\n+            ast::ExprKind::Struct(ref path, ref fields, ref rest) => {\n+                self.print_expr_struct(path, &fields[..], rest, attrs);\n             }\n             ast::ExprKind::Tup(ref exprs) => {\n                 self.print_expr_tup(&exprs[..], attrs);"}, {"sha": "b5d279eeb6f2fd1bf6b7638c32936137e036e582", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -12,8 +12,8 @@ use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_middle::span_bug;\n use rustc_middle::ty::layout::TyAndLayout;\n+use rustc_middle::{bug, span_bug};\n use rustc_span::{Pos, Span};\n use rustc_target::abi::*;\n use rustc_target::asm::*;\n@@ -260,6 +260,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 InlineAsmArch::Nvptx64 => {}\n                 InlineAsmArch::Hexagon => {}\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {}\n+                InlineAsmArch::SpirV => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -518,6 +519,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass, layout: Option<&TyAndLayout<'tcx>>)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n+            InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+                bug!(\"LLVM backend does not support SPIR-V\")\n+            }\n         }\n         .to_string(),\n     }\n@@ -580,6 +584,9 @@ fn modifier_to_llvm(\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+        InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+            bug!(\"LLVM backend does not support SPIR-V\")\n+        }\n     }\n }\n \n@@ -619,6 +626,9 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+        InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n+            bug!(\"LLVM backend does not support SPIR-V\")\n+        }\n     }\n }\n "}, {"sha": "30f0fc6cddfa2cbd08d9101247bb76ef576bb396", "filename": "compiler/rustc_expand/src/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbuild.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -298,7 +298,7 @@ impl<'a> ExtCtxt<'a> {\n         path: ast::Path,\n         fields: Vec<ast::Field>,\n     ) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprKind::Struct(path, fields, None))\n+        self.expr(span, ast::ExprKind::Struct(path, fields, ast::StructRest::None))\n     }\n     pub fn expr_struct_ident(\n         &self,"}, {"sha": "298cfcc254c86d745c35a6d600225ea01ad987d7", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -484,4 +484,9 @@ impl<Id> Res<Id> {\n     pub fn matches_ns(&self, ns: Namespace) -> bool {\n         self.ns().map_or(true, |actual_ns| actual_ns == ns)\n     }\n+\n+    /// Returns whether such a resolved path can occur in a tuple struct/variant pattern\n+    pub fn expected_in_tuple_struct_pat(&self) -> bool {\n+        matches!(self, Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..))\n+    }\n }"}, {"sha": "188bf227c4249ead979ceb1f9d8284985462c487", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -2087,7 +2087,7 @@ impl<'a> Parser<'a> {\n         recover: bool,\n     ) -> PResult<'a, P<Expr>> {\n         let mut fields = Vec::new();\n-        let mut base = None;\n+        let mut base = ast::StructRest::None;\n         let mut recover_async = false;\n \n         attrs.extend(self.parse_inner_attributes()?);\n@@ -2102,8 +2102,14 @@ impl<'a> Parser<'a> {\n         while self.token != token::CloseDelim(token::Brace) {\n             if self.eat(&token::DotDot) {\n                 let exp_span = self.prev_token.span;\n+                // We permit `.. }` on the left-hand side of a destructuring assignment.\n+                if self.check(&token::CloseDelim(token::Brace)) {\n+                    self.sess.gated_spans.gate(sym::destructuring_assignment, self.prev_token.span);\n+                    base = ast::StructRest::Rest(self.prev_token.span.shrink_to_hi());\n+                    break;\n+                }\n                 match self.parse_expr() {\n-                    Ok(e) => base = Some(e),\n+                    Ok(e) => base = ast::StructRest::Base(e),\n                     Err(mut e) if recover => {\n                         e.emit();\n                         self.recover_stmt();"}, {"sha": "2149fd7e011849e02dc1c6396bf699555f10e088", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -298,9 +298,7 @@ impl<'a> PathSource<'a> {\n                     _,\n                 )\n                 | Res::SelfCtor(..)),\n-            PathSource::TupleStruct(..) => {\n-                matches!(res, Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Res::SelfCtor(..))\n-            }\n+            PathSource::TupleStruct(..) => res.expected_in_tuple_struct_pat(),\n             PathSource::Struct => matches!(res, Res::Def(\n                     DefKind::Struct\n                     | DefKind::Union"}, {"sha": "40d60a8394be362662519ae2fcd1bf14d643a450", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -816,7 +816,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         path: &'tcx hir::QPath<'tcx>,\n         fields: &'tcx [hir::Field<'tcx>],\n         variant: &'tcx ty::VariantDef,\n-        base: Option<&'tcx hir::Expr<'tcx>>,\n+        rest: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             if let hir::QPath::Resolved(_, path) = path {\n@@ -836,7 +836,9 @@ impl<'tcx> DumpVisitor<'tcx> {\n             }\n         }\n \n-        walk_list!(self, visit_expr, base);\n+        if let Some(base) = rest {\n+            self.visit_expr(&base);\n+        }\n     }\n \n     fn process_method_call(\n@@ -1399,7 +1401,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n         debug!(\"visit_expr {:?}\", ex.kind);\n         self.process_macro_use(ex.span);\n         match ex.kind {\n-            hir::ExprKind::Struct(ref path, ref fields, ref base) => {\n+            hir::ExprKind::Struct(ref path, ref fields, ref rest) => {\n                 let hir_expr = self.save_ctxt.tcx.hir().expect_expr(ex.hir_id);\n                 let adt = match self.save_ctxt.typeck_results().expr_ty_opt(&hir_expr) {\n                     Some(ty) if ty.ty_adt_def().is_some() => ty.ty_adt_def().unwrap(),\n@@ -1409,7 +1411,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                     }\n                 };\n                 let res = self.save_ctxt.get_path_res(hir_expr.hir_id);\n-                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *base)\n+                self.process_struct_lit(ex, path, fields, adt.variant_of_res(res), *rest)\n             }\n             hir::ExprKind::MethodCall(ref seg, _, args, _) => {\n                 self.process_method_call(ex, seg, args)"}, {"sha": "5ebd6c4a2349f5a689656f22b6ee9ce77462cca4", "filename": "compiler/rustc_target/src/asm/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fmod.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -155,6 +155,7 @@ mod hexagon;\n mod mips;\n mod nvptx;\n mod riscv;\n+mod spirv;\n mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n@@ -163,6 +164,7 @@ pub use hexagon::{HexagonInlineAsmReg, HexagonInlineAsmRegClass};\n pub use mips::{MipsInlineAsmReg, MipsInlineAsmRegClass};\n pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n+pub use spirv::{SpirVInlineAsmReg, SpirVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n \n #[derive(Copy, Clone, Encodable, Decodable, Debug, Eq, PartialEq, Hash)]\n@@ -177,6 +179,7 @@ pub enum InlineAsmArch {\n     Hexagon,\n     Mips,\n     Mips64,\n+    SpirV,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -194,6 +197,7 @@ impl FromStr for InlineAsmArch {\n             \"hexagon\" => Ok(Self::Hexagon),\n             \"mips\" => Ok(Self::Mips),\n             \"mips64\" => Ok(Self::Mips64),\n+            \"spirv\" => Ok(Self::SpirV),\n             _ => Err(()),\n         }\n     }\n@@ -208,6 +212,7 @@ pub enum InlineAsmReg {\n     Nvptx(NvptxInlineAsmReg),\n     Hexagon(HexagonInlineAsmReg),\n     Mips(MipsInlineAsmReg),\n+    SpirV(SpirVInlineAsmReg),\n }\n \n impl InlineAsmReg {\n@@ -264,6 +269,9 @@ impl InlineAsmReg {\n             InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                 Self::Mips(MipsInlineAsmReg::parse(arch, has_feature, target, &name)?)\n             }\n+            InlineAsmArch::SpirV => {\n+                Self::SpirV(SpirVInlineAsmReg::parse(arch, has_feature, target, &name)?)\n+            }\n         })\n     }\n \n@@ -306,6 +314,7 @@ pub enum InlineAsmRegClass {\n     Nvptx(NvptxInlineAsmRegClass),\n     Hexagon(HexagonInlineAsmRegClass),\n     Mips(MipsInlineAsmRegClass),\n+    SpirV(SpirVInlineAsmRegClass),\n }\n \n impl InlineAsmRegClass {\n@@ -318,6 +327,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.name(),\n             Self::Hexagon(r) => r.name(),\n             Self::Mips(r) => r.name(),\n+            Self::SpirV(r) => r.name(),\n         }\n     }\n \n@@ -333,6 +343,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Nvptx),\n             Self::Hexagon(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Hexagon),\n             Self::Mips(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Mips),\n+            Self::SpirV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::SpirV),\n         }\n     }\n \n@@ -355,6 +366,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.suggest_modifier(arch, ty),\n             Self::Hexagon(r) => r.suggest_modifier(arch, ty),\n             Self::Mips(r) => r.suggest_modifier(arch, ty),\n+            Self::SpirV(r) => r.suggest_modifier(arch, ty),\n         }\n     }\n \n@@ -373,6 +385,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.default_modifier(arch),\n             Self::Hexagon(r) => r.default_modifier(arch),\n             Self::Mips(r) => r.default_modifier(arch),\n+            Self::SpirV(r) => r.default_modifier(arch),\n         }\n     }\n \n@@ -390,6 +403,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.supported_types(arch),\n             Self::Hexagon(r) => r.supported_types(arch),\n             Self::Mips(r) => r.supported_types(arch),\n+            Self::SpirV(r) => r.supported_types(arch),\n         }\n     }\n \n@@ -414,6 +428,7 @@ impl InlineAsmRegClass {\n                 InlineAsmArch::Mips | InlineAsmArch::Mips64 => {\n                     Self::Mips(MipsInlineAsmRegClass::parse(arch, name)?)\n                 }\n+                InlineAsmArch::SpirV => Self::SpirV(SpirVInlineAsmRegClass::parse(arch, name)?),\n             })\n         })\n     }\n@@ -429,6 +444,7 @@ impl InlineAsmRegClass {\n             Self::Nvptx(r) => r.valid_modifiers(arch),\n             Self::Hexagon(r) => r.valid_modifiers(arch),\n             Self::Mips(r) => r.valid_modifiers(arch),\n+            Self::SpirV(r) => r.valid_modifiers(arch),\n         }\n     }\n }\n@@ -571,5 +587,10 @@ pub fn allocatable_registers(\n             mips::fill_reg_map(arch, has_feature, target, &mut map);\n             map\n         }\n+        InlineAsmArch::SpirV => {\n+            let mut map = spirv::regclass_map();\n+            spirv::fill_reg_map(arch, has_feature, target, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "da82749e96a16704719374cbe2fdafc23045aa69", "filename": "compiler/rustc_target/src/asm/spirv.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fasm%2Fspirv.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,46 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+\n+def_reg_class! {\n+    SpirV SpirVInlineAsmRegClass {\n+        reg,\n+    }\n+}\n+\n+impl SpirVInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: super::InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg => {\n+                types! { _: I8, I16, I32, I64, F32, F64; }\n+            }\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    // SPIR-V is SSA-based, it does not have registers.\n+    SpirV SpirVInlineAsmReg SpirVInlineAsmRegClass {}\n+}"}, {"sha": "97ebc12175f73c6149a0b49189636b9d74cd2651", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -495,7 +495,14 @@ impl<T: Ord> BinaryHeap<T> {\n         let mut end = self.len();\n         while end > 1 {\n             end -= 1;\n-            self.data.swap(0, end);\n+            // SAFETY: `end` goes from `self.len() - 1` to 1 (both included),\n+            //  so it's always a valid index to access.\n+            //  It is safe to access index 0 (i.e. `ptr`), because\n+            //  1 <= end < self.len(), which means self.len() >= 2.\n+            unsafe {\n+                let ptr = self.data.as_mut_ptr();\n+                ptr::swap(ptr, ptr.add(end));\n+            }\n             self.sift_down_range(0, end);\n         }\n         self.into_vec()\n@@ -531,19 +538,19 @@ impl<T: Ord> BinaryHeap<T> {\n         unsafe {\n             let mut hole = Hole::new(&mut self.data, pos);\n             let mut child = 2 * pos + 1;\n-            while child < end {\n-                let right = child + 1;\n+            while child < end - 1 {\n                 // compare with the greater of the two children\n-                if right < end && hole.get(child) <= hole.get(right) {\n-                    child = right;\n-                }\n+                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n                 // if we are already in order, stop.\n                 if hole.element() >= hole.get(child) {\n-                    break;\n+                    return;\n                 }\n                 hole.move_to(child);\n                 child = 2 * hole.pos() + 1;\n             }\n+            if child == end - 1 && hole.element() < hole.get(child) {\n+                hole.move_to(child);\n+            }\n         }\n     }\n \n@@ -563,15 +570,14 @@ impl<T: Ord> BinaryHeap<T> {\n         unsafe {\n             let mut hole = Hole::new(&mut self.data, pos);\n             let mut child = 2 * pos + 1;\n-            while child < end {\n-                let right = child + 1;\n-                // compare with the greater of the two children\n-                if right < end && hole.get(child) <= hole.get(right) {\n-                    child = right;\n-                }\n+            while child < end - 1 {\n+                child += (hole.get(child) <= hole.get(child + 1)) as usize;\n                 hole.move_to(child);\n                 child = 2 * hole.pos() + 1;\n             }\n+            if child == end - 1 {\n+                hole.move_to(child);\n+            }\n             pos = hole.pos;\n         }\n         self.sift_up(start, pos);"}, {"sha": "e7a7d1831f73efbef707ef40b05e0671b4d0b30f", "filename": "src/test/rustdoc/async-fn.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Frustdoc%2Fasync-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fasync-fn.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1,4 +1,5 @@\n // edition:2018\n+#![feature(min_const_generics)]\n \n // @has async_fn/fn.foo.html '//pre[@class=\"rust fn\"]' 'pub async fn foo() -> Option<Foo>'\n pub async fn foo() -> Option<Foo> {\n@@ -20,6 +21,12 @@ pub async unsafe fn qux() -> char {\n     '\u26a0'\n }\n \n+// @has async_fn/fn.mut_args.html '//pre[@class=\"rust fn\"]' 'pub async fn mut_args(a: usize)'\n+pub async fn mut_args(mut a: usize) {}\n+\n+// @has async_fn/fn.mut_ref.html '//pre[@class=\"rust fn\"]' 'pub async fn mut_ref(x: i32)'\n+pub async fn mut_ref(ref mut x: i32) {}\n+\n trait Bar {}\n \n impl Bar for () {}\n@@ -32,9 +39,16 @@ pub async fn quux() -> impl Bar {\n // @has async_fn/struct.Foo.html\n // @matches - '//code' 'pub async fn f\\(\\)$'\n // @matches - '//code' 'pub async unsafe fn g\\(\\)$'\n+// @matches - '//code' 'pub async fn mut_self\\(self, first: usize\\)$'\n pub struct Foo;\n \n impl Foo {\n     pub async fn f() {}\n     pub async unsafe fn g() {}\n+    pub async fn mut_self(mut self, mut first: usize) {}\n }\n+\n+pub trait Trait<const N: usize> {}\n+// @has async_fn/fn.const_generics.html\n+// @has - '//pre[@class=\"rust fn\"]' 'pub async fn const_generics<const N: usize>(_: impl Trait<N>)'\n+pub async fn const_generics<const N: usize>(_: impl Trait<N>) {}"}, {"sha": "9c68e067c6f8ffda550c9faba2dd8d5b04c398d9", "filename": "src/test/rustdoc/const-generics/const-generics-docs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -70,8 +70,7 @@ pub async fn a_sink<const N: usize>(v: [u8; N]) -> impl Trait<N> {\n }\n \n // @has foo/fn.b_sink.html '//pre[@class=\"rust fn\"]' \\\n-//      'pub async fn b_sink<const N: usize>(__arg0: impl Trait<N>)'\n-// FIXME(const_generics): This should be `_` not `__arg0`.\n+//      'pub async fn b_sink<const N: usize>(_: impl Trait<N>)'\n pub async fn b_sink<const N: usize>(_: impl Trait<N>) {}\n \n // @has foo/fn.concrete.html '//pre[@class=\"rust fn\"]' \\"}, {"sha": "bff92d8607ece1936cc71b5dcd2f1232e101648b", "filename": "src/test/ui-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fpprust-expr-roundtrip.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -155,7 +155,7 @@ fn iter_exprs(depth: usize, f: &mut dyn FnMut(P<Expr>)) {\n             },\n             17 => {\n                 let path = Path::from_ident(Ident::from_str(\"S\"));\n-                g(ExprKind::Struct(path, vec![], Some(make_x())));\n+                g(ExprKind::Struct(path, vec![], StructRest::Base(make_x())));\n             },\n             18 => {\n                 iter_exprs(depth - 1, &mut |e| g(ExprKind::Try(e)));"}, {"sha": "c4351e059dec6a5ab2e740d7d677fb10b6594380", "filename": "src/test/ui/const-generics/core-types.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fconst-generics%2Fcore-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fconst-generics%2Fcore-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fcore-types.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,51 @@\n+// Check that all types allowed with `min_const_generics` work.\n+// run-pass\n+// revisions: full min\n+\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+struct A<const N: u8>;\n+struct B<const N: u16>;\n+struct C<const N: u32>;\n+struct D<const N: u64>;\n+struct E<const N: u128>;\n+struct F<const N: usize>;\n+struct G<const N: i8>;\n+struct H<const N: i16>;\n+struct I<const N: i32>;\n+struct J<const N: i64>;\n+struct K<const N: i128>;\n+struct L<const N: isize>;\n+struct M<const N: char>;\n+struct N<const N: bool>;\n+\n+fn main() {\n+    let _ = A::<{u8::MIN}>;\n+    let _ = A::<{u8::MAX}>;\n+    let _ = B::<{u16::MIN}>;\n+    let _ = B::<{u16::MAX}>;\n+    let _ = C::<{u32::MIN}>;\n+    let _ = C::<{u32::MAX}>;\n+    let _ = D::<{u64::MIN}>;\n+    let _ = D::<{u64::MAX}>;\n+    let _ = E::<{u128::MIN}>;\n+    let _ = E::<{u128::MAX}>;\n+    let _ = F::<{usize::MIN}>;\n+    let _ = F::<{usize::MAX}>;\n+    let _ = G::<{i8::MIN}>;\n+    let _ = G::<{i8::MAX}>;\n+    let _ = H::<{i16::MIN}>;\n+    let _ = H::<{i16::MAX}>;\n+    let _ = I::<{i32::MIN}>;\n+    let _ = I::<{i32::MAX}>;\n+    let _ = J::<{i64::MIN}>;\n+    let _ = J::<{i64::MAX}>;\n+    let _ = K::<{i128::MIN}>;\n+    let _ = K::<{i128::MAX}>;\n+    let _ = L::<{isize::MIN}>;\n+    let _ = L::<{isize::MAX}>;\n+    let _ = M::<'A'>;\n+    let _ = N::<true>;\n+}"}, {"sha": "2aaf2c39875583ca9ec703a4ad04e5d9b103013b", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1,4 +1,5 @@\n #![feature(min_const_generics)]\n+#![feature(never_type)]\n \n struct Foo<const N: [u8; 0]>;\n //~^ ERROR `[u8; 0]` is forbidden\n@@ -14,4 +15,14 @@ struct Fez<const N: No>;\n struct Faz<const N: &'static u8>;\n //~^ ERROR `&'static u8` is forbidden\n \n+struct Fiz<const N: !>;\n+//~^ ERROR `!` is forbidden\n+\n+enum Goo<const N: ()> { A, B }\n+//~^ ERROR `()` is forbidden\n+\n+union Boo<const N: ()> { a: () }\n+//~^ ERROR `()` is forbidden\n+\n+\n fn main() {}"}, {"sha": "52ed3c1c6ee8c80341234a9a915fb9997218a947", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.stderr", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1,5 +1,5 @@\n error: `[u8; 0]` is forbidden as the type of a const generic parameter\n-  --> $DIR/complex-types.rs:3:21\n+  --> $DIR/complex-types.rs:4:21\n    |\n LL | struct Foo<const N: [u8; 0]>;\n    |                     ^^^^^^^\n@@ -8,7 +8,7 @@ LL | struct Foo<const N: [u8; 0]>;\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: `()` is forbidden as the type of a const generic parameter\n-  --> $DIR/complex-types.rs:6:21\n+  --> $DIR/complex-types.rs:7:21\n    |\n LL | struct Bar<const N: ()>;\n    |                     ^^\n@@ -17,7 +17,7 @@ LL | struct Bar<const N: ()>;\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: `No` is forbidden as the type of a const generic parameter\n-  --> $DIR/complex-types.rs:11:21\n+  --> $DIR/complex-types.rs:12:21\n    |\n LL | struct Fez<const N: No>;\n    |                     ^^\n@@ -26,13 +26,40 @@ LL | struct Fez<const N: No>;\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: `&'static u8` is forbidden as the type of a const generic parameter\n-  --> $DIR/complex-types.rs:14:21\n+  --> $DIR/complex-types.rs:15:21\n    |\n LL | struct Faz<const N: &'static u8>;\n    |                     ^^^^^^^^^^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: aborting due to 4 previous errors\n+error: `!` is forbidden as the type of a const generic parameter\n+  --> $DIR/complex-types.rs:18:21\n+   |\n+LL | struct Fiz<const N: !>;\n+   |                     ^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: `()` is forbidden as the type of a const generic parameter\n+  --> $DIR/complex-types.rs:21:19\n+   |\n+LL | enum Goo<const N: ()> { A, B }\n+   |                   ^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: `()` is forbidden as the type of a const generic parameter\n+  --> $DIR/complex-types.rs:24:20\n+   |\n+LL | union Boo<const N: ()> { a: () }\n+   |                    ^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "393dfc16c0a1c131333f6526122e231d9b3186f9", "filename": "src/test/ui/destructuring-assignment/nested_destructure.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnested_destructure.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,17 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+struct Struct<S, T> {\n+    a: S,\n+    b: T,\n+}\n+\n+struct TupleStruct<S, T>(S, T);\n+\n+fn main() {\n+    let (a, b, c, d);\n+    Struct { a: TupleStruct((a, b), c), b: [d] } =\n+        Struct { a: TupleStruct((0, 1), 2), b: [3] };\n+    assert_eq!((a, b, c, d), (0, 1, 2, 3));\n+}"}, {"sha": "249fba7f920bc81153abc4d72338d1540a691fbf", "filename": "src/test/ui/destructuring-assignment/note-unsupported.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -7,18 +7,19 @@ fn main() {\n     (a, b) += (3, 4); //~ ERROR invalid left-hand side of assignment\n     //~| ERROR binary assignment operation `+=` cannot be applied\n \n-    [a, b] = [3, 4]; //~ ERROR invalid left-hand side of assignment\n+    [a, b] = [3, 4]; //~ ERROR destructuring assignments are unstable\n     [a, b] += [3, 4]; //~ ERROR invalid left-hand side of assignment\n     //~| ERROR binary assignment operation `+=` cannot be applied\n \n     let s = S { x: 3, y: 4 };\n \n-    S { x: a, y: b } = s; //~ ERROR invalid left-hand side of assignment\n+    S { x: a, y: b } = s; //~ ERROR destructuring assignments are unstable\n     S { x: a, y: b } += s; //~ ERROR invalid left-hand side of assignment\n     //~| ERROR binary assignment operation `+=` cannot be applied\n \n     S { x: a, ..s } = S { x: 3, y: 4 };\n-    //~^ ERROR invalid left-hand side of assignment\n+    //~^ ERROR functional record updates are not allowed in destructuring assignments\n+    //~| ERROR destructuring assignments are unstable\n \n     let c = 3;\n "}, {"sha": "a81324b99e5868c4ad3509244348e9e541e4f004", "filename": "src/test/ui/destructuring-assignment/note-unsupported.stderr", "status": "modified", "additions": 42, "deletions": 27, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fnote-unsupported.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -10,7 +10,46 @@ LL |     (a, b) = (3, 4);\n    = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n \n error[E0658]: destructuring assignments are unstable\n-  --> $DIR/note-unsupported.rs:25:17\n+  --> $DIR/note-unsupported.rs:10:12\n+   |\n+LL |     [a, b] = [3, 4];\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:16:22\n+   |\n+LL |     S { x: a, y: b } = s;\n+   |     ---------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:20:21\n+   |\n+LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n+   |     --------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: functional record updates are not allowed in destructuring assignments\n+  --> $DIR/note-unsupported.rs:20:17\n+   |\n+LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n+   |                 ^ help: consider removing the trailing pattern\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/note-unsupported.rs:26:17\n    |\n LL |     ((a, b), c) = ((3, 4), 5);\n    |     ----------- ^\n@@ -36,14 +75,6 @@ LL |     (a, b) += (3, 4);\n    |     |\n    |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:10:12\n-   |\n-LL |     [a, b] = [3, 4];\n-   |     ------ ^\n-   |     |\n-   |     cannot assign to this expression\n-\n error[E0368]: binary assignment operation `+=` cannot be applied to type `[{integer}; 2]`\n   --> $DIR/note-unsupported.rs:11:5\n    |\n@@ -60,14 +91,6 @@ LL |     [a, b] += [3, 4];\n    |     |\n    |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:16:22\n-   |\n-LL |     S { x: a, y: b } = s;\n-   |     ---------------- ^\n-   |     |\n-   |     cannot assign to this expression\n-\n error[E0368]: binary assignment operation `+=` cannot be applied to type `S`\n   --> $DIR/note-unsupported.rs:17:5\n    |\n@@ -86,15 +109,7 @@ LL |     S { x: a, y: b } += s;\n    |     |\n    |     cannot assign to this expression\n \n-error[E0070]: invalid left-hand side of assignment\n-  --> $DIR/note-unsupported.rs:20:21\n-   |\n-LL |     S { x: a, ..s } = S { x: 3, y: 4 };\n-   |     --------------- ^\n-   |     |\n-   |     cannot assign to this expression\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 12 previous errors\n \n-Some errors have detailed explanations: E0067, E0070, E0368, E0658.\n+Some errors have detailed explanations: E0067, E0368, E0658.\n For more information about an error, try `rustc --explain E0067`."}, {"sha": "3dd10aff19c72aaefb019b7d7d5a86fc309be765", "filename": "src/test/ui/destructuring-assignment/slice_destructure.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,15 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+  let (mut a, mut b);\n+  [a, b] = [0, 1];\n+  assert_eq!((a, b), (0, 1));\n+  let mut c;\n+  [a, .., b, c] = [1, 2, 3, 4, 5];\n+  assert_eq!((a, b, c), (1, 4, 5));\n+  [..] = [1, 2, 3];\n+  [c, ..] = [5, 6, 6];\n+  assert_eq!(c, 5);\n+}"}, {"sha": "f636ea3511c2672090e8e08db4a2a4b2f6d9e25a", "filename": "src/test/ui/destructuring-assignment/slice_destructure_fail.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,7 @@\n+#![feature(destructuring_assignment)]\n+\n+fn main() {\n+  let (mut a, mut b);\n+  [a, .., b, ..] = [0, 1]; //~ ERROR `..` can only be used once per slice pattern\n+  [a, a, b] = [1, 2]; //~ ERROR pattern requires 3 elements but array has 2\n+}"}, {"sha": "728687deb8bbbd96af66338f9708a5ead40e22cd", "filename": "src/test/ui/destructuring-assignment/slice_destructure_fail.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fslice_destructure_fail.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,17 @@\n+error: `..` can only be used once per slice pattern\n+  --> $DIR/slice_destructure_fail.rs:5:14\n+   |\n+LL |   [a, .., b, ..] = [0, 1];\n+   |       --     ^^ can only be used once per slice pattern\n+   |       |\n+   |       previously used here\n+\n+error[E0527]: pattern requires 3 elements but array has 2\n+  --> $DIR/slice_destructure_fail.rs:6:3\n+   |\n+LL |   [a, a, b] = [1, 2];\n+   |   ^^^^^^^^^ expected 2 elements\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0527`."}, {"sha": "b3a96ee1573460c0ef6b9a49322568fd33771f48", "filename": "src/test/ui/destructuring-assignment/struct_destructure.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+struct Struct<S, T> {\n+    a: S,\n+    b: T,\n+}\n+\n+fn main() {\n+    let (mut a, mut b);\n+    Struct { a, b } = Struct { a: 0, b: 1 };\n+    assert_eq!((a, b), (0, 1));\n+    Struct { a: b, b: a }  = Struct { a: 1, b: 2 };\n+    assert_eq!((a,b), (2, 1));\n+    Struct { a, .. } = Struct { a: 1, b: 3 };\n+    assert_eq!((a, b), (1, 1));\n+    Struct { .. } = Struct { a: 1, b: 4 };\n+    assert_eq!((a, b), (1, 1));\n+}"}, {"sha": "c22695ed38849523faaec38300ab2cd322711f2d", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,15 @@\n+#![feature(destructuring_assignment)]\n+struct Struct<S, T> {\n+    a: S,\n+    b: T,\n+}\n+\n+fn main() {\n+    let (mut a, b);\n+    let mut c;\n+    let d = Struct { a: 0, b: 1 };\n+    Struct { a, b, c } = Struct { a: 0, b: 1 }; //~ ERROR does not have a field named `c`\n+    Struct { a, ..d } = Struct { a: 1, b: 2 };\n+    //~^ ERROR functional record updates are not allowed in destructuring assignments\n+    Struct { a, .. }; //~ ERROR base expression required after `..`\n+}"}, {"sha": "4da4698804f1ad4ebea6cdfbbb083f0c28da2e92", "filename": "src/test/ui/destructuring-assignment/struct_destructure_fail.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Fstruct_destructure_fail.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,21 @@\n+error: functional record updates are not allowed in destructuring assignments\n+  --> $DIR/struct_destructure_fail.rs:12:19\n+   |\n+LL |     Struct { a, ..d } = Struct { a: 1, b: 2 };\n+   |                   ^ help: consider removing the trailing pattern\n+\n+error: base expression required after `..`\n+  --> $DIR/struct_destructure_fail.rs:14:19\n+   |\n+LL |     Struct { a, .. };\n+   |                   ^ add a base expression here\n+\n+error[E0026]: struct `Struct` does not have a field named `c`\n+  --> $DIR/struct_destructure_fail.rs:11:20\n+   |\n+LL |     Struct { a, b, c } = Struct { a: 0, b: 1 };\n+   |                    ^ struct `Struct` does not have this field\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0026`."}, {"sha": "106a9b16db45981167938c49cf75cedb3ba55b51", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,34 @@\n+// run-pass\n+\n+#![feature(destructuring_assignment)]\n+\n+struct TupleStruct<S, T>(S, T);\n+\n+impl<S, T> TupleStruct<S, T> {\n+    fn assign(self, first: &mut S, second: &mut T) {\n+        // Test usage of `Self` instead of the struct name:\n+        Self(*first, *second) = self\n+    }\n+}\n+\n+enum Enum<S, T> {\n+    SingleVariant(S, T)\n+}\n+\n+type Alias<S> = Enum<S, isize>;\n+\n+fn main() {\n+    let (mut a, mut b);\n+    TupleStruct(a, b) = TupleStruct(0, 1);\n+    assert_eq!((a, b), (0, 1));\n+    TupleStruct(a, .., b) = TupleStruct(1, 2);\n+    assert_eq!((a, b), (1, 2));\n+    TupleStruct(..) = TupleStruct(3, 4);\n+    assert_eq!((a, b), (1, 2));\n+    TupleStruct(5,6).assign(&mut a, &mut b);\n+    assert_eq!((a, b), (5, 6));\n+    Enum::SingleVariant(a, b) = Enum::SingleVariant(7, 8);\n+    assert_eq!((a, b), (7, 8));\n+    Alias::SingleVariant(a, b) = Alias::SingleVariant(9, 10);\n+    assert_eq!((a, b), (9, 10));\n+}"}, {"sha": "61ae42a51751f0b92d2be5504d83e5cf58e996bc", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,42 @@\n+#![feature(destructuring_assignment)]\n+\n+struct TupleStruct<S, T>(S, T);\n+\n+enum Enum<S, T> {\n+    SingleVariant(S, T)\n+}\n+\n+type Alias<S> = Enum<S, isize>;\n+\n+trait Test {\n+    fn test() -> TupleStruct<isize, isize> {\n+        TupleStruct(0, 0)\n+    }\n+}\n+\n+impl Test for Alias<isize> {}\n+\n+fn test() -> TupleStruct<isize, isize> {\n+    TupleStruct(0, 0)\n+}\n+\n+fn main() {\n+    let (mut a, mut b);\n+    TupleStruct(a, .., b, ..) = TupleStruct(0, 1);\n+    //~^ ERROR `..` can only be used once per tuple struct or variant pattern\n+    Enum::SingleVariant(a, .., b, ..) = Enum::SingleVariant(0, 1);\n+    //~^ ERROR `..` can only be used once per tuple struct or variant pattern\n+\n+    TupleStruct(a, a, b) = TupleStruct(1, 2);\n+    //~^ ERROR this pattern has 3 fields, but the corresponding tuple struct has 2 fields\n+    Enum::SingleVariant(a, a, b) = Enum::SingleVariant(1, 2);\n+    //~^ ERROR this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+\n+    // Check if `test` is recognized as not a tuple struct but a function call:\n+    test() = TupleStruct(0, 0);\n+    //~^ ERROR invalid left-hand side of assignment\n+    (test)() = TupleStruct(0, 0);\n+    //~^ ERROR invalid left-hand side of assignment\n+    <Alias::<isize> as Test>::test() = TupleStruct(0, 0);\n+    //~^ ERROR invalid left-hand side of assignment\n+}"}, {"sha": "863eedecf7697ac96980966cbf358b1533f2509a", "filename": "src/test/ui/destructuring-assignment/tuple_struct_destructure_fail.stderr", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Ftuple_struct_destructure_fail.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,62 @@\n+error: `..` can only be used once per tuple struct or variant pattern\n+  --> $DIR/tuple_struct_destructure_fail.rs:25:27\n+   |\n+LL |     TupleStruct(a, .., b, ..) = TupleStruct(0, 1);\n+   |                    --     ^^ can only be used once per tuple struct or variant pattern\n+   |                    |\n+   |                    previously used here\n+\n+error: `..` can only be used once per tuple struct or variant pattern\n+  --> $DIR/tuple_struct_destructure_fail.rs:27:35\n+   |\n+LL |     Enum::SingleVariant(a, .., b, ..) = Enum::SingleVariant(0, 1);\n+   |                            --     ^^ can only be used once per tuple struct or variant pattern\n+   |                            |\n+   |                            previously used here\n+\n+error[E0023]: this pattern has 3 fields, but the corresponding tuple struct has 2 fields\n+  --> $DIR/tuple_struct_destructure_fail.rs:30:5\n+   |\n+LL | struct TupleStruct<S, T>(S, T);\n+   | ------------------------------- tuple struct defined here\n+...\n+LL |     TupleStruct(a, a, b) = TupleStruct(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n+\n+error[E0023]: this pattern has 3 fields, but the corresponding tuple variant has 2 fields\n+  --> $DIR/tuple_struct_destructure_fail.rs:32:5\n+   |\n+LL |     SingleVariant(S, T)\n+   |     ------------------- tuple variant defined here\n+...\n+LL |     Enum::SingleVariant(a, a, b) = Enum::SingleVariant(1, 2);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected 2 fields, found 3\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_struct_destructure_fail.rs:36:12\n+   |\n+LL |     test() = TupleStruct(0, 0);\n+   |     ------ ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_struct_destructure_fail.rs:38:14\n+   |\n+LL |     (test)() = TupleStruct(0, 0);\n+   |     -------- ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/tuple_struct_destructure_fail.rs:40:38\n+   |\n+LL |     <Alias::<isize> as Test>::test() = TupleStruct(0, 0);\n+   |     -------------------------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+\n+error: aborting due to 7 previous errors\n+\n+Some errors have detailed explanations: E0023, E0070.\n+For more information about an error, try `rustc --explain E0023`."}, {"sha": "b41f2f52a3d6f5ce4aa0ea1ffcd9a15c60f17702", "filename": "src/test/ui/destructuring-assignment/underscore-range-expr-gating.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,8 @@\n+fn main() {}\n+\n+struct S { x : u32 }\n+\n+#[cfg(FALSE)]\n+fn foo() {\n+    S { x: 5, .. }; //~ ERROR destructuring assignments are unstable\n+}"}, {"sha": "442e36cd3065e6d10b1fe86e4a382745a6c87ffb", "filename": "src/test/ui/destructuring-assignment/underscore-range-expr-gating.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructuring-assignment%2Funderscore-range-expr-gating.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/underscore-range-expr-gating.rs:7:15\n+   |\n+LL |     S { x: 5, .. };\n+   |               ^^\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a6a2401795ff4690de26464185566ef459dcd38e", "filename": "src/test/ui/issues/issue-77218.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77218.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1,7 +1,11 @@\n fn main() {\n     let value = [7u8];\n-    while Some(0) = value.get(0) { //~ ERROR mismatched types\n-        //~^ NOTE expected `bool`, found `()`\n-        //~| HELP you might have meant to use pattern matching\n+    while Some(0) = value.get(0) { //~ ERROR destructuring assignments are unstable\n+        //~| ERROR invalid left-hand side of assignment\n+        //~| ERROR mismatched types\n+        //~| ERROR mismatched types\n+\n+        // FIXME The following diagnostic should also be emitted\n+        // HELP you might have meant to use pattern matching\n     }\n }"}, {"sha": "4f6fbaa2265d5ac01ca8de66553da8e8ddca240d", "filename": "src/test/ui/issues/issue-77218.stderr", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fissues%2Fissue-77218.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-77218.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1,14 +1,38 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/issue-77218.rs:3:19\n+   |\n+LL |     while Some(0) = value.get(0) {\n+   |           ------- ^\n+   |           |\n+   |           cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/issue-77218.rs:3:19\n+   |\n+LL |     while Some(0) = value.get(0) {\n+   |                -  ^\n+   |                |\n+   |                cannot assign to this expression\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-77218.rs:3:16\n+   |\n+LL |     while Some(0) = value.get(0) {\n+   |                ^\n+   |                |\n+   |                expected integer, found `&u8`\n+   |                help: consider dereferencing the borrow: `*0`\n+\n error[E0308]: mismatched types\n   --> $DIR/issue-77218.rs:3:11\n    |\n LL |     while Some(0) = value.get(0) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n-   |\n-help: you might have meant to use pattern matching\n-   |\n-LL |     while let Some(0) = value.get(0) {\n-   |           ^^^\n \n-error: aborting due to previous error\n+error: aborting due to 4 previous errors\n \n-For more information about this error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0070, E0308, E0658.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "688b6e826582610956fc49e3e50f6c56734652a2", "filename": "src/test/ui/suggestions/if-let-typo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -2,7 +2,12 @@ fn main() {\n     let foo = Some(0);\n     let bar = None;\n     if Some(x) = foo {} //~ ERROR cannot find value `x` in this scope\n+    //~^ ERROR mismatched types\n+    //~^^ ERROR destructuring assignments are unstable\n     if Some(foo) = bar {} //~ ERROR mismatched types\n+    //~^ ERROR destructuring assignments are unstable\n     if 3 = foo {} //~ ERROR mismatched types\n     if Some(3) = foo {} //~ ERROR mismatched types\n+    //~^ ERROR destructuring assignments are unstable\n+    //~^^ ERROR invalid left-hand side of assignment\n }"}, {"sha": "ce1ee0cd06d4854788b78cd9ca1a7e61213d00e7", "filename": "src/test/ui/suggestions/if-let-typo.stderr", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fif-let-typo.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -9,23 +9,53 @@ help: you might have meant to use pattern matching\n LL |     if let Some(x) = foo {}\n    |        ^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/if-let-typo.rs:5:8\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/if-let-typo.rs:4:16\n+   |\n+LL |     if Some(x) = foo {}\n+   |        ------- ^\n+   |        |\n+   |        cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/if-let-typo.rs:7:18\n    |\n LL |     if Some(foo) = bar {}\n-   |        ^^^^^^^^^^^^^^^ expected `bool`, found `()`\n+   |        --------- ^\n+   |        |\n+   |        cannot assign to this expression\n    |\n-help: you might have meant to use pattern matching\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/if-let-typo.rs:10:16\n    |\n-LL |     if let Some(foo) = bar {}\n-   |        ^^^\n-help: you might have meant to compare for equality\n+LL |     if Some(3) = foo {}\n+   |        ------- ^\n+   |        |\n+   |        cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-let-typo.rs:4:8\n+   |\n+LL |     if Some(x) = foo {}\n+   |        ^^^^^^^^^^^^^ expected `bool`, found `()`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/if-let-typo.rs:7:8\n    |\n-LL |     if Some(foo) == bar {}\n-   |                  ^^\n+LL |     if Some(foo) = bar {}\n+   |        ^^^^^^^^^^^^^^^ expected `bool`, found `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/if-let-typo.rs:6:8\n+  --> $DIR/if-let-typo.rs:9:8\n    |\n LL |     if 3 = foo {}\n    |        ^^^^^^^ expected `bool`, found `()`\n@@ -35,22 +65,21 @@ help: you might have meant to use pattern matching\n LL |     if let 3 = foo {}\n    |        ^^^\n \n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/if-let-typo.rs:10:16\n+   |\n+LL |     if Some(3) = foo {}\n+   |             -  ^\n+   |             |\n+   |             cannot assign to this expression\n+\n error[E0308]: mismatched types\n-  --> $DIR/if-let-typo.rs:7:8\n+  --> $DIR/if-let-typo.rs:10:8\n    |\n LL |     if Some(3) = foo {}\n    |        ^^^^^^^^^^^^^ expected `bool`, found `()`\n-   |\n-help: you might have meant to use pattern matching\n-   |\n-LL |     if let Some(3) = foo {}\n-   |        ^^^\n-help: you might have meant to compare for equality\n-   |\n-LL |     if Some(3) == foo {}\n-   |                ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 9 previous errors\n \n-Some errors have detailed explanations: E0308, E0425.\n-For more information about an error, try `rustc --explain E0308`.\n+Some errors have detailed explanations: E0070, E0308, E0425, E0658.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "8662ab427a8d6ad8047811cc4d78dbd20dd07699", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1 +1 @@\n-Subproject commit d5556aeb8405b1fe696adb6e297ad7a1f2989b62\n+Subproject commit 8662ab427a8d6ad8047811cc4d78dbd20dd07699"}, {"sha": "9050b9b2d9ab820c04332248b383375048eb67a5", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -107,6 +107,15 @@ pub fn eq_expr_opt(l: &Option<P<Expr>>, r: &Option<P<Expr>>) -> bool {\n     both(l, r, |l, r| eq_expr(l, r))\n }\n \n+pub fn eq_struct_rest(l: &StructRest, r: &StructRest) -> bool {\n+    match (l, r) {\n+        (StructRest::Base(lb), StructRest::Base(rb)) => eq_expr(lb, rb),\n+        (StructRest::Rest(_), StructRest::Rest(_)) => true,\n+        (StructRest::None, StructRest::None) => true,\n+        _ => false,\n+    }\n+}\n+\n pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n     use ExprKind::*;\n     if !over(&l.attrs, &r.attrs, |l, r| eq_attr(l, r)) {\n@@ -150,7 +159,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lp, lfs, lb), Struct(rp, rfs, rb)) => {\n-            eq_path(lp, rp) && eq_expr_opt(lb, rb) && unordered_over(lfs, rfs, |l, r| eq_field(l, r))\n+            eq_path(lp, rp) && eq_struct_rest(lb, rb) && unordered_over(lfs, rfs, |l, r| eq_field(l, r))\n         },\n         _ => false,\n     }"}, {"sha": "c38727316cd4e8dff0d860c058609953eb1e42da", "filename": "src/tools/clippy/tests/ui/crashes/ice-6250.stderr", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e80ee05bfc135d7d800f3fcc89bc005d6858cd9b/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-6250.stderr?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1,3 +1,14 @@\n+error[E0658]: destructuring assignments are unstable\n+  --> $DIR/ice-6250.rs:12:25\n+   |\n+LL |         Some(reference) = cache.data.get(key) {\n+   |         --------------- ^\n+   |         |\n+   |         cannot assign to this expression\n+   |\n+   = note: see issue #71126 <https://github.com/rust-lang/rust/issues/71126> for more information\n+   = help: add `#![feature(destructuring_assignment)]` to the crate attributes to enable\n+\n error[E0601]: `main` function not found in crate `ice_6250`\n   --> $DIR/ice-6250.rs:4:1\n    |\n@@ -10,18 +21,22 @@ LL | |     }\n LL | | }\n    | |_^ consider adding a `main` function to `$DIR/ice-6250.rs`\n \n+error[E0308]: mismatched types\n+  --> $DIR/ice-6250.rs:12:14\n+   |\n+LL |         Some(reference) = cache.data.get(key) {\n+   |              ^^^^^^^^^\n+   |              |\n+   |              expected integer, found `&i32`\n+   |              help: consider dereferencing the borrow: `*reference`\n+\n error[E0308]: mismatched types\n   --> $DIR/ice-6250.rs:12:9\n    |\n LL |         Some(reference) = cache.data.get(key) {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n-   |\n-help: you might have meant to use pattern matching\n-   |\n-LL |         let Some(reference) = cache.data.get(key) {\n-   |         ^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0308, E0601.\n+Some errors have detailed explanations: E0308, E0601, E0658.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "0f29ff6da0c5ff622e739beb8fc3bbe77119b3c1", "filename": "src/tools/rustfmt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt?ref=e80ee05bfc135d7d800f3fcc89bc005d6858cd9b", "patch": "@@ -1 +1 @@\n-Subproject commit eb894d53708122a67762de9489881c11aa8ce257\n+Subproject commit 0f29ff6da0c5ff622e739beb8fc3bbe77119b3c1"}]}