{"sha": "7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmN2Y0NzYyMGVhZWFhYjhlNDk5M2U1NjhkMmY1YzIzZTFjYjY0MTY=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-02T23:01:38Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-08T00:18:14Z"}, "message": "Implement static typeclass methods. Closes #3132.", "tree": {"sha": "3e93c8b6772ae3d87b090766661e429215b2cbad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e93c8b6772ae3d87b090766661e429215b2cbad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "html_url": "https://github.com/rust-lang/rust/commit/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a695e074f23e1c5353947c1d0e0c2b418750b80d", "url": "https://api.github.com/repos/rust-lang/rust/commits/a695e074f23e1c5353947c1d0e0c2b418750b80d", "html_url": "https://github.com/rust-lang/rust/commit/a695e074f23e1c5353947c1d0e0c2b418750b80d"}], "stats": {"total": 851, "additions": 605, "deletions": 246}, "files": [{"sha": "0cc433fdebab238468d774ab9b24c26d591e9628", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -71,6 +71,7 @@ type ty_param = {ident: ident, id: node_id, bounds: @~[ty_param_bound]};\n #[auto_serialize]\n enum def {\n     def_fn(def_id, purity),\n+    def_static_method(def_id, purity),\n     def_self(node_id),\n     def_mod(def_id),\n     def_foreign_mod(def_id),\n@@ -596,6 +597,7 @@ enum ret_style {\n \n #[auto_serialize]\n enum self_ty_ {\n+    sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n     sty_value,                          // by-value self: `self`\n     sty_region(@region, mutability),    // by-region self: `&self`"}, {"sha": "7bbdac4db3cff0bb45488ee70d2164218b503aea", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -53,7 +53,7 @@ fn variant_def_ids(d: def) -> {enm: def_id, var: def_id} {\n \n pure fn def_id_of_def(d: def) -> def_id {\n     match d {\n-      def_fn(id, _) | def_mod(id) |\n+      def_fn(id, _) | def_static_method(id, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n       def_use(id) | def_class(id, _) => {"}, {"sha": "780eff1f7578ad13b7832936b0b1299061b07f4c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -43,20 +43,24 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              match_nonterminal, match_seq, match_tok, method, mode, mt, mul,\n              mutability, neg, noreturn, not, pat, pat_box, pat_enum,\n              pat_ident, pat_lit, pat_range, pat_rec, pat_struct, pat_tup,\n-             pat_uniq, pat_wild, path, private, proto, proto_bare,\n-             proto_block, proto_box, proto_uniq, provided, public, pure_fn,\n-             purity, re_anon, re_named, region, rem, required, ret_style,\n-             return_val, self_ty, shl, shr, stmt, stmt_decl, stmt_expr,\n-             stmt_semi, subtract, sty_box, sty_by_ref, sty_region, sty_uniq,\n-             sty_value, token_tree, trait_method, trait_ref, tt_delim, tt_seq,\n-             tt_tok, tt_nonterminal, tuple_variant_kind, ty, ty_, ty_bot,\n-             ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method, ty_nil,\n-             ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr,\n-             ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length, unchecked_blk,\n-             uniq, unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n-             view_item_export, view_item_import, view_item_use, view_path,\n-             view_path_glob, view_path_list, view_path_simple, visibility,\n-             vstore, vstore_box, vstore_fixed, vstore_slice, vstore_uniq};\n+             pat_uniq,\n+             pat_wild, path, private, proto, proto_bare, proto_block,\n+             proto_box, proto_uniq, provided, public, pure_fn, purity,\n+             re_anon, re_named, region, rem, required, ret_style, return_val,\n+             self_ty, shl, shr, stmt, stmt_decl, stmt_expr, stmt_semi,\n+             subtract, sty_box, sty_by_ref, sty_region, sty_static,\n+             sty_uniq, sty_value,\n+             token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok,\n+             tt_nonterminal, ty, ty_, ty_bot, ty_box, ty_field, ty_fn,\n+             ty_infer, ty_mac, ty_method, ty_nil, ty_param, ty_param_bound,\n+             ty_path, ty_ptr,\n+             ty_rec, ty_rptr, ty_tup, ty_u32, ty_uniq, ty_vec,\n+             ty_fixed_length, tuple_variant_kind,\n+             unchecked_blk, uniq, unsafe_blk, unsafe_fn,\n+             variant, view_item, view_item_, view_item_export,\n+             view_item_import, view_item_use, view_path, view_path_glob,\n+             view_path_list, view_path_simple, visibility, vstore, vstore_box,\n+             vstore_fixed, vstore_slice, vstore_uniq};\n \n export file_type;\n export parser;\n@@ -279,6 +283,9 @@ class parser {\n                                     seq_sep_none()) |p| {\n             let attrs = p.parse_outer_attributes();\n             let lo = p.span.lo;\n+            let is_static = p.parse_staticness();\n+            let static_sty = spanned(lo, p.span.hi, sty_static);\n+\n             let pur = p.parse_fn_purity();\n             // NB: at the moment, trait methods are public by default; this\n             // could change.\n@@ -287,7 +294,8 @@ class parser {\n             let tps = p.parse_ty_params();\n             let d = p.parse_ty_fn_decl(pur);\n             let hi = p.last_span.hi;\n-            let self_ty = spanned(lo, hi, sty_by_ref);  // XXX: Wrong.\n+            let self_ty = if is_static { static_sty } else\n+                { spanned(lo, hi, sty_by_ref) }; // XXX: Wrong.\n             debug!{\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n                    token_to_str(p.reader, p.token)};\n@@ -2379,15 +2387,24 @@ class parser {\n \n     fn parse_method(pr: visibility) -> @method {\n         let attrs = self.parse_outer_attributes();\n-        let lo = self.span.lo, pur = self.parse_fn_purity();\n+        let lo = self.span.lo;\n+\n+        let is_static = self.parse_staticness();\n+        let static_sty = spanned(lo, self.span.hi, sty_static);\n+\n+        let pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n         let tps = self.parse_ty_params();\n         let (self_ty, decl, _) = do self.parse_fn_decl_with_self(pur) |p| {\n             p.parse_arg()\n         };\n+        // XXX: interaction between staticness, self_ty is broken now\n+        let self_ty = if is_static { static_sty} else { self_ty };\n+\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         let attrs = vec::append(attrs, inner_attrs);\n-        @{ident: ident, attrs: attrs, tps: tps, self_ty: self_ty, decl: decl,\n+        @{ident: ident, attrs: attrs,\n+          tps: tps, self_ty: self_ty, decl: decl,\n           body: body, id: self.get_id(), span: mk_sp(lo, body.span.hi),\n           self_id: self.get_id(), vis: pr}\n     }\n@@ -2689,6 +2706,9 @@ class parser {\n         else if self.eat_keyword(~\"priv\") { private }\n         else { inherited }\n     }\n+    fn parse_staticness() -> bool {\n+        self.eat_keyword(~\"static\")\n+    }\n \n     fn parse_mod_items(term: token::token,\n                        +first_item_attrs: ~[attribute]) -> _mod {"}, {"sha": "1965ea73186fdd5c748f9b79a838d82a88f981c8", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -144,7 +144,7 @@ fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n               params: ~[ast::ty_param]) -> ~str {\n     let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n-    print_fn(s, decl, name, params);\n+    print_fn(s, decl, name, params, none);\n     end(s); // Close the head box\n     end(s); // Close the outer box\n     eof(s.s);\n@@ -400,7 +400,7 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         pclose(s);\n       }\n       ast::ty_fn(proto, bounds, d) => {\n-        print_ty_fn(s, some(proto), bounds, d, none, none);\n+        print_ty_fn(s, some(proto), bounds, d, none, none, none);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n       ast::ty_fixed_length(t, v) => {\n@@ -425,7 +425,7 @@ fn print_foreign_item(s: ps, item: @ast::foreign_item) {\n     print_outer_attributes(s, item.attrs);\n     match item.node {\n       ast::foreign_item_fn(decl, typarams) => {\n-        print_fn(s, decl, item.ident, typarams);\n+        print_fn(s, decl, item.ident, typarams, none);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n         end(s); // end the outer fn box\n@@ -454,7 +454,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n \n       }\n       ast::item_fn(decl, typarams, body) => {\n-        print_fn(s, decl, item.ident, typarams);\n+        print_fn(s, decl, item.ident, typarams, none);\n         word(s.s, ~\" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n@@ -722,7 +722,8 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, none, @~[], m.decl, some(m.ident), some(m.tps));\n+    print_ty_fn(s, none, @~[], m.decl, some(m.ident), some(m.tps),\n+                some(m.self_ty.node));\n     word(s.s, ~\";\");\n }\n \n@@ -737,7 +738,7 @@ fn print_method(s: ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, meth.decl, meth.ident, meth.tps);\n+    print_fn(s, meth.decl, meth.ident, meth.tps, some(meth.self_ty.node));\n     word(s.s, ~\" \");\n     print_block_with_attrs(s, meth.body, meth.attrs);\n }\n@@ -1150,8 +1151,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n-        print_purity(s, decl.purity);\n-        word(s.s, proto_to_str(proto));\n+        word(s.s, fn_header_info_to_str(none, decl.purity, some(proto)));\n         print_fn_args_and_ret(s, decl, *cap_clause);\n         space(s.s);\n         print_block(s, body);\n@@ -1455,11 +1455,9 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n }\n \n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n-            typarams: ~[ast::ty_param]) {\n-    match decl.purity {\n-      ast::impure_fn => head(s, ~\"fn\"),\n-      _ => head(s, purity_to_str(decl.purity) + ~\" fn\")\n-    }\n+            typarams: ~[ast::ty_param],\n+            opt_self_ty: option<ast::self_ty_>) {\n+    head(s, fn_header_info_to_str(opt_self_ty, decl.purity, none));\n     word(s.s, *name);\n     print_type_params(s, typarams);\n     print_fn_args_and_ret(s, decl, ~[]);\n@@ -1667,9 +1665,10 @@ fn print_arg(s: ps, input: ast::arg) {\n fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n                bounds: @~[ast::ty_param_bound],\n                decl: ast::fn_decl, id: option<ast::ident>,\n-               tps: option<~[ast::ty_param]>) {\n+               tps: option<~[ast::ty_param]>,\n+               opt_self_ty: option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n-    word(s.s, opt_proto_to_str(opt_proto));\n+    word(s.s, fn_header_info_to_str(opt_self_ty, decl.purity, opt_proto));\n     print_bounds(s, bounds);\n     match id { some(id) => { word(s.s, ~\" \"); word(s.s, *id); } _ => () }\n     match tps { some(tps) => print_type_params(s, tps), _ => () }\n@@ -1869,6 +1868,27 @@ fn next_comment(s: ps) -> option<comments::cmnt> {\n     }\n }\n \n+fn fn_header_info_to_str(opt_sty: option<ast::self_ty_>,\n+                         purity: ast::purity,\n+                         opt_p: option<ast::proto>) -> ~str {\n+    let mut s = match opt_sty {\n+      some(ast::sty_static) => ~\"static \",\n+      _ => ~ \"\"\n+    };\n+\n+    match purity {\n+      ast::impure_fn => { }\n+      _ => {\n+        str::push_str(s, purity_to_str(purity));\n+        str::push_char(s, ' ');\n+      }\n+    }\n+\n+    str::push_str(s, opt_proto_to_str(opt_p));\n+\n+    return s;\n+}\n+\n fn opt_proto_to_str(opt_p: option<ast::proto>) -> ~str {\n     match opt_p {\n       none => ~\"fn\","}, {"sha": "203b527b21f60eaa678785961077dea0af474734", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -144,7 +144,7 @@ fn get_trait_methods(tcx: ty::ctxt, def: ast::def_id) -> @~[ty::method] {\n }\n \n fn get_method_names_if_trait(cstore: cstore::cstore, def: ast::def_id)\n-                          -> option<@dvec<@~str>> {\n+    -> option<@dvec<(@~str, ast::self_ty_)>> {\n \n     let cdata = cstore::get_crate_data(cstore, def.crate);\n     return decoder::get_method_names_if_trait(cdata, def.node);"}, {"sha": "fdb4be4c6e049f0656c355b52c25aa2e308d3754", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -282,7 +282,10 @@ fn item_to_def_like(item: ebml::doc, did: ast::def_id, cnum: ast::crate_num)\n       'u' => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n       'f' => dl_def(ast::def_fn(did, ast::impure_fn)),\n       'p' => dl_def(ast::def_fn(did, ast::pure_fn)),\n-      'F' => dl_def(ast::def_fn(did, ast::extern_fn)),\n+      'e' => dl_def(ast::def_fn(did, ast::extern_fn)),\n+      'U' => dl_def(ast::def_static_method(did, ast::unsafe_fn)),\n+      'F' => dl_def(ast::def_static_method(did, ast::impure_fn)),\n+      'P' => dl_def(ast::def_static_method(did, ast::pure_fn)),\n       'y' => dl_def(ast::def_ty(did)),\n       't' => dl_def(ast::def_ty(did)),\n       'm' => dl_def(ast::def_mod(did)),\n@@ -592,6 +595,7 @@ fn get_self_ty(item: ebml::doc) -> ast::self_ty_ {\n \n     let self_ty_kind = string[0];\n     match self_ty_kind as char {\n+        's' => { return ast::sty_static; }\n         'r' => { return ast::sty_by_ref; }\n         'v' => { return ast::sty_value; }\n         '@' => { return ast::sty_box(get_mutability(string[1])); }\n@@ -693,21 +697,23 @@ fn get_trait_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     @result\n }\n \n-// If the item in question is a trait, returns its set of methods. Otherwise,\n-// returns none.\n+// If the item in question is a trait, returns its set of methods and\n+// their self types. Otherwise, returns none. This overlaps in an\n+// annoying way with get_trait_methods.\n fn get_method_names_if_trait(cdata: cmd, node_id: ast::node_id)\n-                          -> option<@dvec<@~str>> {\n+                          -> option<@dvec<(@~str, ast::self_ty_)>> {\n \n     let item = lookup_item(node_id, cdata.data);\n     if item_family(item) != 'I' {\n         return none;\n     }\n \n-    let resulting_method_names = @dvec();\n+    let resulting_methods = @dvec();\n     for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n-        (*resulting_method_names).push(item_name(method));\n+        resulting_methods.push(\n+            (item_name(method), get_self_ty(method)));\n     }\n-    return some(resulting_method_names);\n+    return some(resulting_methods);\n }\n \n fn get_item_attrs(cdata: cmd,\n@@ -757,7 +763,7 @@ fn get_class_fields(cdata: cmd, id: ast::node_id) -> ~[ty::field_ty] {\n \n fn family_has_type_params(fam_ch: char) -> bool {\n     match check fam_ch {\n-      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' => false,\n+      'c' | 'T' | 'm' | 'n' | 'g' | 'h' | 'j' | 'e' => false,\n       'f' | 'u' | 'p' | 'F' | 'U' | 'P' | 'y' | 't' | 'v' | 'i' | 'I' | 'C'\n           | 'a' | 'S'\n           => true\n@@ -791,9 +797,10 @@ fn item_family_to_str(fam: char) -> ~str {\n       'f' => return ~\"fn\",\n       'u' => return ~\"unsafe fn\",\n       'p' => return ~\"pure fn\",\n-      'F' => return ~\"foreign fn\",\n-      'U' => return ~\"unsafe foreign fn\",\n-      'P' => return ~\"pure foreign fn\",\n+      'F' => return ~\"static method\",\n+      'U' => return ~\"unsafe static method\",\n+      'P' => return ~\"pure static method\",\n+      'e' => return ~\"foreign fn\",\n       'y' => return ~\"type\",\n       'T' => return ~\"foreign type\",\n       't' => return ~\"type\","}, {"sha": "4c535f8af09a755bd56f3c5102521cba181b35c3", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 67, "deletions": 10, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -122,6 +122,21 @@ fn encode_enum_variant_paths(ebml_w: ebml::writer, variants: ~[variant],\n     }\n }\n \n+fn encode_trait_static_method_paths(ebml_w: ebml::writer,\n+                                    methods: ~[trait_method],\n+                                    path: ~[ident],\n+                                    &index: ~[entry<~str>]) {\n+    for methods.each |method| {\n+        let ty_m = trait_method_to_ty_method(method);\n+        if ty_m.self_ty.node != sty_static { again; }\n+        add_to_index(ebml_w, path, index, ty_m.ident);\n+        do ebml_w.wr_tag(tag_paths_data_item) {\n+            encode_name(ebml_w, ty_m.ident);\n+            encode_def_id(ebml_w, local_def(ty_m.id));\n+        }\n+    }\n+}\n+\n fn add_to_index(ebml_w: ebml::writer, path: &[ident], &index: ~[entry<~str>],\n                 name: ident) {\n     let mut full_path = ~[];\n@@ -214,10 +229,11 @@ fn encode_module_item_paths(ebml_w: ebml::writer, ecx: @encode_ctxt,\n               }\n               encode_enum_variant_paths(ebml_w, variants, path, index);\n           }\n-          item_trait(*) => {\n+          item_trait(_, _, methods) => {\n             do ebml_w.wr_tag(tag_paths_data_item) {\n-                  encode_name_and_def_id(ebml_w, it.ident, it.id);\n-              }\n+                encode_name_and_def_id(ebml_w, it.ident, it.id);\n+            }\n+            encode_trait_static_method_paths(ebml_w, methods, path, index);\n           }\n           item_impl(*) => {}\n           item_mac(*) => fail ~\"item macros unimplemented\"\n@@ -286,21 +302,28 @@ fn encode_family(ebml_w: ebml::writer, c: char) {\n \n fn def_to_str(did: def_id) -> ~str { fmt!{\"%d:%d\", did.crate, did.node} }\n \n-fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n-                            params: ~[ty_param]) {\n+fn encode_ty_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n+                               params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n                         tcx: ecx.tcx,\n                         reachable: |a| reachable(ecx, a),\n                         abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n-        let bs = ecx.tcx.ty_param_bounds.get(param.id);\n-        tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, bs);\n+        tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, param);\n         ebml_w.end_tag();\n     }\n }\n \n+fn encode_type_param_bounds(ebml_w: ebml::writer, ecx: @encode_ctxt,\n+                            params: ~[ty_param]) {\n+    let ty_param_bounds =\n+        @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n+    encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n+}\n+\n+\n fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::bytes(def_to_str(vid)));\n@@ -472,6 +495,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n     // Encode the base self type.\n     let ch;\n     match self_type {\n+        sty_static =>       { ch = 's' as u8; }\n         sty_by_ref =>       { ch = 'r' as u8; }\n         sty_value =>        { ch = 'v' as u8; }\n         sty_region(_, _) => { ch = '&' as u8; }\n@@ -482,7 +506,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n \n     // Encode mutability.\n     match self_type {\n-        sty_by_ref | sty_value => { /* No-op. */ }\n+        sty_static | sty_by_ref | sty_value => { /* No-op. */ }\n         sty_region(_, m_imm) | sty_box(m_imm) | sty_uniq(m_imm) => {\n             ebml_w.writer.write(&[ 'i' as u8 ]);\n         }\n@@ -499,7 +523,7 @@ fn encode_self_type(ebml_w: ebml::writer, self_type: ast::self_ty_) {\n         sty_region(region, _) => {\n             encode_region(ebml_w, *region);\n         }\n-        sty_by_ref | sty_value | sty_box(*) | sty_uniq(*) => {\n+        sty_static | sty_by_ref | sty_value | sty_box(*) | sty_uniq(*) => {\n             // Nothing to do.\n         }\n     }\n@@ -608,7 +632,15 @@ fn purity_fn_family(p: purity) -> char {\n       unsafe_fn => 'u',\n       pure_fn => 'p',\n       impure_fn => 'f',\n-      extern_fn => 'F'\n+      extern_fn => 'e'\n+    }\n+}\n+fn purity_static_method_family(p: purity) -> char {\n+    match p {\n+      unsafe_fn => 'U',\n+      pure_fn => 'P',\n+      impure_fn => 'F',\n+      extern_fn => 'E'\n     }\n }\n \n@@ -853,6 +885,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n             match ms[i] {\n               required(ty_m) => {\n                 ebml_w.start_tag(tag_item_trait_method);\n+                encode_def_id(ebml_w, local_def(ty_m.id));\n                 encode_name(ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, ty_m.tps);\n                 encode_type(ecx, ebml_w, ty::mk_fn(tcx, mty.fty));\n@@ -873,6 +906,30 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n            encode_trait_ref(ebml_w, ecx, associated_trait)\n         }\n         ebml_w.end_tag();\n+\n+        // Now, output all of the static methods as items.  Note that for the\n+        // method info, we output static methods with type signatures as\n+        // written. Here, we output the *real* type signatures. I feel like\n+        // maybe we should only ever handle the real type signatures.\n+        for vec::each(ms) |m| {\n+            let ty_m = ast_util::trait_method_to_ty_method(m);\n+            if ty_m.self_ty.node != ast::sty_static { again; }\n+\n+            vec::push(*index, {val: ty_m.id, pos: ebml_w.writer.tell()});\n+\n+            ebml_w.start_tag(tag_items_data_item);\n+            encode_def_id(ebml_w, local_def(ty_m.id));\n+            encode_name(ebml_w, ty_m.ident);\n+            encode_family(ebml_w,\n+                          purity_static_method_family(ty_m.decl.purity));\n+            let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n+            encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n+            encode_type(ecx, ebml_w, polyty.ty);\n+            encode_path(ebml_w, path, ast_map::path_name(ty_m.ident));\n+            ebml_w.end_tag();\n+        }\n+\n+\n       }\n       item_mac(*) => fail ~\"item macros unimplemented\"\n     }"}, {"sha": "cf0b586e51e99aa78d7d044f847a09464f48cd39", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -353,13 +353,16 @@ fn decode_def(xcx: extended_decode_ctxt, doc: ebml::doc) -> ast::def {\n impl of tr for ast::def {\n     fn tr(xcx: extended_decode_ctxt) -> ast::def {\n         match self {\n-          ast::def_fn(did, p) => ast::def_fn(did.tr(xcx), p),\n-          ast::def_self(nid) => ast::def_self(xcx.tr_id(nid)),\n-          ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n-          ast::def_foreign_mod(did) => ast::def_foreign_mod(did.tr(xcx)),\n-          ast::def_const(did) => ast::def_const(did.tr(xcx)),\n-          ast::def_arg(nid, m) => ast::def_arg(xcx.tr_id(nid), m),\n-          ast::def_local(nid, b) => ast::def_local(xcx.tr_id(nid), b),\n+          ast::def_fn(did, p) => { ast::def_fn(did.tr(xcx), p) }\n+          ast::def_static_method(did, p) => {\n+            ast::def_static_method(did.tr(xcx), p)\n+          }\n+          ast::def_self(nid) => { ast::def_self(xcx.tr_id(nid)) }\n+          ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n+          ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n+          ast::def_const(did) => { ast::def_const(did.tr(xcx)) }\n+          ast::def_arg(nid, m) => { ast::def_arg(xcx.tr_id(nid), m) }\n+          ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n           }"}, {"sha": "41204f117a5b333643d165d23293bcb023571f47", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -191,7 +191,7 @@ impl public_methods for borrowck_ctxt {\n                expr_ty: ty::t,\n                def: ast::def) -> cmt {\n         match def {\n-          ast::def_fn(*) | ast::def_mod(_) |\n+          ast::def_fn(*) | ast::def_static_method(*) | ast::def_mod(_) |\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(*) |\n           ast::def_ty(_) | ast::def_prim_ty(_) |"}, {"sha": "7efd7442380eff1a9a33af1060f6368689bffdae", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 161, "deletions": 160, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -16,7 +16,7 @@ import syntax::ast::{class_member, class_method, crate, crate_num, decl_item};\n import syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n import syntax::ast::{def_foreign_mod, def_id, def_local, def_mod};\n import syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-import syntax::ast::{def_typaram_binder};\n+import syntax::ast::{def_typaram_binder, def_static_method};\n import syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n import syntax::ast::{expr_binary, expr_cast, expr_field, expr_fn};\n import syntax::ast::{expr_fn_block, expr_index, expr_path};\n@@ -30,17 +30,18 @@ import syntax::ast::{instance_var, item, item_class, item_const, item_enum};\n import syntax::ast::{item_fn, item_mac, item_foreign_mod, item_impl};\n import syntax::ast::{item_mod, item_trait, item_ty, le, local, local_crate};\n import syntax::ast::{lt, method, mul, ne, neg, node_id, pat, pat_enum};\n-import syntax::ast::{pat_ident, pat_struct, path, prim_ty, pat_box, pat_uniq};\n-import syntax::ast::{pat_lit, pat_range, pat_rec, pat_tup, pat_wild};\n+import syntax::ast::{pat_ident, path, prim_ty, pat_box, pat_uniq, pat_lit};\n+import syntax::ast::{pat_range, pat_rec, pat_struct, pat_tup, pat_wild};\n import syntax::ast::{provided, required, rem, self_ty_, shl, stmt_decl};\n-import syntax::ast::{subtract, ty, ty_bool, ty_char, ty_f, ty_f32, ty_f64};\n-import syntax::ast::{ty_float, ty_i, ty_i16, ty_i32, ty_i64, ty_i8, ty_int};\n-import syntax::ast::{ty_param, ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64};\n-import syntax::ast::{ty_u8, ty_uint, variant, view_item, view_item_export};\n+import syntax::ast::{sty_static, subtract, ty};\n+import syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64, ty_float, ty_i};\n+import syntax::ast::{ty_i16, ty_i32, ty_i64, ty_i8, ty_int, ty_param};\n+import syntax::ast::{ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64, ty_u8};\n+import syntax::ast::{ty_uint, variant, view_item, view_item_export};\n import syntax::ast::{view_item_import, view_item_use, view_path_glob};\n import syntax::ast::{view_path_list, view_path_simple};\n import syntax::ast_util::{def_id_of_def, dummy_sp, local_def, new_def_hash};\n-import syntax::ast_util::{walk_pat, path_to_ident};\n+import syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n import syntax::attr::{attr_metas, contains_name};\n import syntax::print::pprust::{pat_to_str, path_to_str};\n import syntax::codemap::span;\n@@ -1079,18 +1080,25 @@ class Resolver {\n                 // Add the names of all the methods to the trait info.\n                 let method_names = @atom_hashmap();\n                 for methods.each |method| {\n-                    let atom;\n-                    match method {\n-                        required(required_method) => {\n-                            atom = (*self.atom_table).intern\n-                                (required_method.ident);\n-                        }\n-                        provided(provided_method) => {\n-                            atom = (*self.atom_table).intern\n-                                (provided_method.ident);\n-                        }\n+                    let ty_m = trait_method_to_ty_method(method);\n+\n+                    let atom = (*self.atom_table).intern(ty_m.ident);\n+                    // Add it to the trait info if not static,\n+                    // add it as a name in the enclosing module otherwise.\n+                    match ty_m.self_ty.node {\n+                      sty_static => {\n+                        // which parent to use??\n+                        let (method_name_bindings, _) =\n+                            self.add_child(atom, new_parent, ~[ValueNS],\n+                                           ty_m.span);\n+                        let def = def_static_method(local_def(ty_m.id),\n+                                                    ty_m.decl.purity);\n+                        (*method_name_bindings).define_value(def, ty_m.span);\n+                      }\n+                      _ => {\n+                        (*method_names).insert(atom, ());\n+                      }\n                     }\n-                    (*method_names).insert(atom, ());\n                 }\n \n                 let def_id = local_def(item.id);\n@@ -1338,6 +1346,124 @@ class Resolver {\n         visit_block(block, new_parent, visitor);\n     }\n \n+    fn handle_external_def(def: def, modules: hashmap<def_id, @Module>,\n+                           child_name_bindings: @NameBindings,\n+                           final_ident: ~str,\n+                           atom: Atom, new_parent: ReducedGraphParent) {\n+        match def {\n+          def_mod(def_id) | def_foreign_mod(def_id) => {\n+            match copy child_name_bindings.module_def {\n+              NoModuleDef => {\n+                debug!(\"(building reduced graph for \\\n+                        external crate) building module \\\n+                        %s\", final_ident);\n+                let parent_link = self.get_parent_link(new_parent, atom);\n+\n+                match modules.find(def_id) {\n+                  none => {\n+                    child_name_bindings.define_module(parent_link,\n+                                                      some(def_id),\n+                                                      dummy_sp());\n+                    modules.insert(def_id,\n+                                   child_name_bindings.get_module());\n+                  }\n+                  some(existing_module) => {\n+                    // Create an import resolution to\n+                    // avoid creating cycles in the\n+                    // module graph.\n+\n+                    let resolution = @ImportResolution(dummy_sp());\n+                    resolution.outstanding_references = 0;\n+\n+                    match existing_module.parent_link {\n+                      NoParentLink |\n+                      BlockParentLink(*) => {\n+                        fail ~\"can't happen\";\n+                      }\n+                      ModuleParentLink(parent_module, atom) => {\n+\n+                        let name_bindings = parent_module.children.get(atom);\n+\n+                        resolution.module_target =\n+                            some(Target(parent_module, name_bindings));\n+                      }\n+                    }\n+\n+                    debug!(\"(building reduced graph for external crate) \\\n+                            ... creating import resolution\");\n+\n+                    new_parent.import_resolutions.insert(atom, resolution);\n+                  }\n+                }\n+              }\n+              ModuleDef(module_) => {\n+                debug!(\"(building reduced graph for \\\n+                        external crate) already created \\\n+                        module\");\n+                module_.def_id = some(def_id);\n+                modules.insert(def_id, module_);\n+              }\n+            }\n+          }\n+          def_fn(def_id, _) | def_static_method(def_id, _) |\n+          def_const(def_id) | def_variant(_, def_id) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building value %s\", final_ident);\n+            (*child_name_bindings).define_value(def, dummy_sp());\n+          }\n+          def_ty(def_id) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building type %s\", final_ident);\n+\n+            // If this is a trait, add all the method names\n+            // to the trait info.\n+\n+            match get_method_names_if_trait(self.session.cstore,\n+                                          def_id) {\n+              none => {\n+                // Nothing to do.\n+              }\n+              some(method_names) => {\n+                let interned_method_names = @atom_hashmap();\n+                for method_names.each |method_data| {\n+                    let (method_name, self_ty) = method_data;\n+                    debug!(\"(building reduced graph for \\\n+                            external crate) ... adding \\\n+                            trait method '%?'\", method_name);\n+\n+                    let m_atom = self.atom_table.intern(method_name);\n+\n+                    // Add it to the trait info if not static.\n+                    if self_ty != sty_static {\n+                        interned_method_names.insert(m_atom, ());\n+                    }\n+                }\n+                self.trait_info.insert(def_id, interned_method_names);\n+              }\n+            }\n+\n+            child_name_bindings.define_type(def, dummy_sp());\n+          }\n+          def_class(def_id, has_constructor) => {\n+            debug!(\"(building reduced graph for external \\\n+                    crate) building type %s (value? %d)\",\n+                   final_ident,\n+                   if has_constructor { 1 } else { 0 });\n+            child_name_bindings.define_type(def, dummy_sp());\n+\n+            if has_constructor {\n+                child_name_bindings.define_value(def, dummy_sp());\n+            }\n+          }\n+          def_self(*) | def_arg(*) | def_local(*) |\n+          def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n+          def_use(*) | def_upvar(*) | def_region(*) |\n+          def_typaram_binder(*) => {\n+            fail fmt!(\"didn't expect `%?`\", def);\n+          }\n+        }\n+    }\n+\n     /**\n      * Builds the reduced graph rooted at the 'use' directive for an external\n      * crate.\n@@ -1395,145 +1521,9 @@ class Resolver {\n \n             match path_entry.def_like {\n                 dl_def(def) => {\n-                    match def {\n-                        def_mod(def_id) | def_foreign_mod(def_id) => {\n-                            match copy child_name_bindings.module_def {\n-                                NoModuleDef => {\n-                                    debug!{\"(building reduced graph for \\\n-                                            external crate) building module \\\n-                                            %s\", final_ident};\n-                                    let parent_link =\n-                                        self.get_parent_link(new_parent,\n-                                                             atom);\n-\n-                                    match modules.find(def_id) {\n-                                        none => {\n-                                            (*child_name_bindings).\n-                                                define_module(parent_link,\n-                                                              some(def_id),\n-                                                             dummy_sp());\n-                                            modules.insert(def_id,\n-                                                (*child_name_bindings).\n-                                                    get_module());\n-                                        }\n-                                        some(existing_module) => {\n-                                            // Create an import resolution to\n-                                            // avoid creating cycles in the\n-                                            // module graph.\n-\n-                                            let resolution =\n-                                                @ImportResolution(dummy_sp());\n-                                            resolution.\n-                                                outstanding_references = 0;\n-\n-                                            match existing_module\n-                                                .parent_link {\n-\n-                                                NoParentLink |\n-                                                BlockParentLink(*) => {\n-                                                    fail ~\"can't happen\";\n-                                                }\n-                                                ModuleParentLink\n-                                                        (parent_module,\n-                                                         atom) => {\n-\n-                                                    let name_bindings =\n-                                                        parent_module.\n-                                                            children.get\n-                                                                (atom);\n-\n-                                                    resolution.module_target =\n-                                                        some(Target\n-                                                            (parent_module,\n-                                                             name_bindings));\n-                                                }\n-                                            }\n-\n-                                            debug!{\"(building reduced graph \\\n-                                                     for external crate) \\\n-                                                     ... creating import \\\n-                                                     resolution\"};\n-\n-                                            new_parent.import_resolutions.\n-                                                insert(atom, resolution);\n-                                        }\n-                                    }\n-                                }\n-                                ModuleDef(module_) => {\n-                                    debug!{\"(building reduced graph for \\\n-                                            external crate) already created \\\n-                                            module\"};\n-                                    module_.def_id = some(def_id);\n-                                    modules.insert(def_id, module_);\n-                                }\n-                            }\n-                        }\n-                        def_fn(def_id, _) | def_const(def_id) |\n-                        def_variant(_, def_id) => {\n-                            debug!{\"(building reduced graph for external \\\n-                                    crate) building value %s\", final_ident};\n-                            // Might want a better span\n-                            (*child_name_bindings).define_value(def,\n-                                                                dummy_sp());\n-                        }\n-                        def_ty(def_id) => {\n-                            debug!{\"(building reduced graph for external \\\n-                                    crate) building type %s\", final_ident};\n-\n-                            // If this is a trait, add all the method names\n-                            // to the trait info.\n-\n-                            match get_method_names_if_trait(\n-                                self.session.cstore, def_id) {\n-\n-                                none => {\n-                                    // Nothing to do.\n-                                }\n-                                some(method_names) => {\n-                                    let interned_method_names =\n-                                        @atom_hashmap();\n-                                    for method_names.each |method_name| {\n-                                        debug!{\"(building reduced graph for \\\n-                                                 external crate) ... adding \\\n-                                                 trait method '%?'\",\n-                                               method_name};\n-                                        let atom =\n-                                            (*self.atom_table).intern\n-                                                (method_name);\n-                                        (*interned_method_names).insert(atom,\n-                                                                        ());\n-                                    }\n-                                    self.trait_info.insert\n-                                        (def_id, interned_method_names);\n-                                }\n-                            }\n-\n-                            // Might want a better span\n-                            (*child_name_bindings).define_type(def,\n-                                                               dummy_sp());\n-                        }\n-                        def_class(def_id, has_constructor) => {\n-                            debug!{\"(building reduced graph for external \\\n-                                    crate) building type %s (value? %d)\",\n-                                    final_ident,\n-                                    if has_constructor { 1 } else { 0 }};\n-                            // Might want a better span\n-                            (*child_name_bindings).define_type(def,\n-                                                               dummy_sp());\n-\n-                            // Might want a better span\n-                            if has_constructor {\n-                                (*child_name_bindings).define_value(def,\n-                                                              dummy_sp());\n-                            }\n-                        }\n-                        def_self(*) | def_arg(*) | def_local(*) |\n-                        def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n-                        def_use(*) | def_upvar(*) | def_region(*) |\n-                          def_typaram_binder(*) => {\n-                            fail fmt!{\"didn't expect `%?`\", def};\n-                        }\n-                    }\n+                    self.handle_external_def(def, modules,\n+                                             child_name_bindings,\n+                                             final_ident, atom, new_parent);\n                 }\n                 dl_impl(_) => {\n                     // Because of the infelicitous way the metadata is\n@@ -3589,11 +3579,17 @@ class Resolver {\n                               method.id,\n                               outer_type_parameter_count,\n                               rib_kind);\n+        // we only have self ty if it is a non static method\n+        let self_binding = match method.self_ty.node {\n+          sty_static => { NoSelfBinding }\n+          _ => { HasSelfBinding(method.self_id) }\n+        };\n+\n         self.resolve_function(rib_kind,\n                               some(@method.decl),\n                               type_parameters,\n                               method.body,\n-                              HasSelfBinding(method.self_id),\n+                              self_binding,\n                               NoCaptureClause,\n                               visitor);\n     }\n@@ -3647,7 +3643,11 @@ class Resolver {\n             for methods.each |method| {\n                 // We also need a new scope for the method-specific\n                 // type parameters.\n-\n+                self.resolve_method(MethodRibKind(id, Provided(method.id)),\n+                                    method,\n+                                    outer_type_parameter_count,\n+                                    visitor);\n+/*\n                 let borrowed_type_parameters = &method.tps;\n                 self.resolve_function(MethodRibKind(id, Provided(method.id)),\n                                       some(@method.decl),\n@@ -3660,6 +3660,7 @@ class Resolver {\n                                       HasSelfBinding(method.self_id),\n                                       NoCaptureClause,\n                                       visitor);\n+*/\n             }\n \n             // Restore the original trait references."}, {"sha": "11643f8a5ee9bc26d602144929aa42943d6472bc", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -2454,6 +2454,9 @@ fn trans_var(cx: block, def: ast::def, id: ast::node_id)-> lval_maybe_callee {\n       ast::def_fn(did, _) => {\n         return lval_static_fn(cx, did, id);\n       }\n+      ast::def_static_method(did, _) => {\n+        return impl::trans_static_method_callee(cx, did, id);\n+      }\n       ast::def_variant(tid, vid) => {\n         if ty::enum_variant_with_id(ccx.tcx, tid, vid).args.len() > 0u {\n             // N-ary variant."}, {"sha": "5d821dbd86d52dac19d9deae2034ce755b63de03", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -26,10 +26,15 @@ fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n     for vec::each(methods) |m| {\n         if m.tps.len() == 0u {\n             let llfn = get_item_val(ccx, m.id);\n+            let self_arg = match m.self_ty.node {\n+              ast::sty_static => { no_self }\n+              _ => { impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)) }\n+            };\n+\n             trans_fn(ccx,\n                      vec::append_one(sub_path, path_name(m.ident)),\n                      m.decl, m.body,\n-                     llfn, impl_self(ty::node_id_to_type(ccx.tcx, m.self_id)),\n+                     llfn, self_arg,\n                      none, m.id);\n         }\n     }\n@@ -65,8 +70,9 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n                             param_num:p, bound_num:b}) => {\n         match check bcx.fcx.param_substs {\n           some(substs) => {\n+            let vtbl = find_vtable_in_fn_ctxt(substs, p, b);\n             trans_monomorphized_callee(bcx, callee_id, self, mentry.derefs,\n-                                       iid, off, p, b, substs)\n+                                       iid, off, vtbl)\n           }\n         }\n       }\n@@ -81,6 +87,54 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n     }\n }\n \n+fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n+                              callee_id: ast::node_id) -> lval_maybe_callee {\n+    let _icx = bcx.insn_ctxt(~\"impl::trans_static_method_callee\");\n+    let ccx = bcx.ccx();\n+\n+    let mname = if method_id.crate == ast::local_crate {\n+        match check bcx.tcx().items.get(method_id.node) {\n+          ast_map::node_trait_method(trait_method, _, _) => {\n+            ast_util::trait_method_to_ty_method(*trait_method).ident\n+          }\n+        }\n+    } else {\n+        let path = csearch::get_item_path(bcx.tcx(), method_id);\n+        match path[path.len()-1] {\n+          path_name(s) => { s }\n+          path_mod(_) => { fail ~\"path doesn't have a name?\" }\n+        }\n+    };\n+    debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n+            name=%s\", method_id, callee_id, *mname);\n+\n+    let vtbls = resolve_vtables_in_fn_ctxt(\n+        bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n+\n+    match vtbls[0] { // is index 0 always the one we want?\n+      typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n+\n+        let mth_id = method_with_name(bcx.ccx(), impl_did, mname);\n+        let n_m_tps = method_ty_param_count(ccx, mth_id, impl_did);\n+        let node_substs = node_id_type_params(bcx, callee_id);\n+        let ty_substs\n+            = vec::append(impl_substs,\n+                          vec::tailn(node_substs,\n+                                     node_substs.len() - n_m_tps));\n+\n+        let lval = lval_static_fn_inner(bcx, mth_id, callee_id, ty_substs,\n+                                        some(sub_origins));\n+        {env: null_env,\n+         val: PointerCast(bcx, lval.val, T_ptr(type_of_fn_from_ty(\n+             ccx, node_id_type(bcx, callee_id))))\n+         with lval}\n+      }\n+      _ => {\n+        fail ~\"vtable_param left in monomorphized function's vtable substs\";\n+      }\n+    }\n+}\n+\n fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n     -> ast::def_id {\n   local_def(option::get(vec::find(ms, |m| m.ident == name)).id)\n@@ -119,10 +173,10 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n                               base: @ast::expr, derefs: uint,\n                               trait_id: ast::def_id, n_method: uint,\n-                              n_param: uint, n_bound: uint,\n-                              substs: param_substs) -> lval_maybe_callee {\n+                              vtbl: typeck::vtable_origin)\n+    -> lval_maybe_callee {\n     let _icx = bcx.insn_ctxt(~\"impl::trans_monomorphized_callee\");\n-    match find_vtable_in_fn_ctxt(substs, n_param, n_bound) {\n+    match vtbl {\n       typeck::vtable_static(impl_did, impl_substs, sub_origins) => {\n         let ccx = bcx.ccx();\n         let mname = ty::trait_methods(ccx.tcx, trait_id)[n_method].ident;"}, {"sha": "fda5902e594a7d497d27cb6beeeb0192536be81c", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -69,6 +69,12 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_method(@{body, _}, _, _) => {\n         handle_body(cx, body);\n       }\n+      ast_map::node_trait_method(*) => {\n+        // This will be a static trait method. For now, we just assume\n+        // it fully depends on all of the type information. (Doing\n+        // otherwise would require finding the actual implementation).\n+        for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr|use_tydesc;}\n+      }\n       ast_map::node_variant(_, _, _) => {\n         for uint::range(0u, n_tps) |n| { cx.uses[n] |= use_repr;}\n       }"}, {"sha": "cb723bca83d35e141ced1d97c6125dcd4bda266a", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -2179,14 +2179,16 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n         };\n       }\n \n-      ast::def_fn(id, ast::unsafe_fn) => {\n+      ast::def_fn(id, ast::unsafe_fn) |\n+      ast::def_static_method(id, ast::unsafe_fn) => {\n         // Unsafe functions can only be touched in an unsafe context\n         fcx.require_unsafe(sp, ~\"access to unsafe function\");\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n \n-      ast::def_fn(id, _) | ast::def_const(id) |\n-      ast::def_variant(_, id) | ast::def_class(id, _) => {\n+      ast::def_fn(id, _) | ast::def_static_method(id, _) |\n+      ast::def_const(id) | ast::def_variant(_, id) |\n+      ast::def_class(id, _) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       ast::def_binding(nid, _) => {"}, {"sha": "2f2da5b65bc76178386338dce579f3fb846c300b", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -4,7 +4,8 @@ import coherence::get_base_type_def_id;\n import middle::resolve3::{Impl, MethodInfo};\n import middle::ty::{mk_box, mk_rptr, mk_uniq};\n import middle::typeck::infer::methods; // next_ty_vars\n-import syntax::ast::{def_id, sty_box, sty_by_ref, sty_region, sty_uniq};\n+import syntax::ast::{def_id,\n+                     sty_static, sty_box, sty_by_ref, sty_region, sty_uniq};\n import syntax::ast::{sty_value};\n import syntax::ast_map;\n import syntax::ast_map::node_id_to_str;\n@@ -25,6 +26,10 @@ fn transform_self_type_for_method(fcx: @fn_ctxt,\n                                   method_info: MethodInfo)\n                                -> ty::t {\n     match method_info.self_type {\n+      sty_static => {\n+        fcx.tcx().sess.bug(~\"calling transform_self_type_for_method on \\\n+                             static method\");\n+      }\n       sty_by_ref | sty_value => {\n         impl_ty\n       }"}, {"sha": "eb2f31d1c16348c4c0d0bf47f7bf8fecee6f1375", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -21,6 +21,7 @@ are represented as `ty_param()` instances.\n */\n \n import astconv::{ast_conv, ty_of_fn_decl, ty_of_arg, ast_ty_to_ty};\n+import ast_util::trait_method_to_ty_method;\n import rscope::*;\n \n fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n@@ -147,19 +148,54 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id) {\n         ty::store_trait_methods(ccx.tcx, id, @vec::map(stuff, f));\n     }\n \n+    fn make_static_method_ty(ccx: @crate_ctxt, id: ast::node_id,\n+                             am: ast::ty_method,\n+                             rp: bool, m: ty::method,\n+                             trait_bounds: @~[ty::param_bounds]) {\n+        // We need to create a typaram that replaces self. This param goes\n+        // *in between* the typarams from the trait and those from the\n+        // method (since its bound can depend on the trait? or\n+        // something like that).\n+\n+        // build up a subst that shifts all of the parameters over\n+        // by one and substitute in a new type param for self\n+\n+        let dummy_defid = {crate: 0, node: 0};\n+\n+        let non_shifted_trait_tps = do vec::from_fn(trait_bounds.len()) |i| {\n+            ty::mk_param(ccx.tcx, i, dummy_defid)\n+        };\n+        let self_param = ty::mk_param(ccx.tcx, trait_bounds.len(),\n+                                      dummy_defid);\n+        let shifted_method_tps = do vec::from_fn(m.tps.len()) |i| {\n+            ty::mk_param(ccx.tcx, i + 1, dummy_defid)\n+        };\n+\n+        let substs = { self_r: none, self_ty: some(self_param),\n+                       tps: non_shifted_trait_tps + shifted_method_tps };\n+\n+        let ty = ty::subst(ccx.tcx, substs, ty::mk_fn(ccx.tcx, m.fty));\n+        let trait_ty = ty::node_id_to_type(ccx.tcx, id);\n+        let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n+                       + *m.tps);\n+        ccx.tcx.tcache.insert(local_def(am.id),\n+                              {bounds: bounds, rp: rp, ty: ty});\n+    }\n+\n+\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.contains_key(id);\n     match check tcx.items.get(id) {\n-      ast_map::node_item(@{node: ast::item_trait(_, _, ms), _}, _) => {\n+      ast_map::node_item(@{node: ast::item_trait(params, _, ms), _}, _) => {\n         store_methods::<ast::trait_method>(ccx, id, ms, |m| {\n-            match m {\n-              required(ty_m) => {\n-                ty_of_ty_method(ccx, ty_m, rp)\n-              }\n-              provided(m) => {\n-                ty_of_method(ccx, m, rp)\n-              }\n+            let trait_bounds = ty_param_bounds(ccx, params);\n+            let ty_m = trait_method_to_ty_method(m);\n+            let method_ty = ty_of_ty_method(ccx, ty_m, rp);\n+            if ty_m.self_ty.node == ast::sty_static {\n+                make_static_method_ty(ccx, id, ty_m, rp,\n+                                      method_ty, trait_bounds);\n             }\n+            method_ty\n         });\n       }\n       ast_map::node_item(@{node: ast::item_class(struct_def, _), _}, _) => {\n@@ -190,6 +226,21 @@ fn compare_impl_method(tcx: ty::ctxt, sp: span,\n                        trait_m: ty::method, trait_substs: ty::substs,\n                        self_ty: ty::t) {\n \n+    if impl_m.purity != trait_m.purity {\n+        tcx.sess.span_err(\n+            sp, fmt!{\"method `%s`'s purity does \\\n+                          not match the trait method's \\\n+                          purity\", *impl_m.ident});\n+    }\n+\n+    // is this check right?\n+    if impl_m.self_ty != trait_m.self_ty {\n+        tcx.sess.span_err(\n+            sp, fmt!{\"method `%s`'s self type does \\\n+                          not match the trait method's \\\n+                          self type\", *impl_m.ident});\n+    }\n+\n     if impl_m.tps != trait_m.tps {\n         tcx.sess.span_err(sp, ~\"method `\" + *trait_m.ident +\n                           ~\"` has an incompatible set of type parameters\");\n@@ -259,12 +310,6 @@ fn check_methods_against_trait(ccx: @crate_ctxt,\n     for vec::each(*ty::trait_methods(tcx, did)) |trait_m| {\n         match vec::find(impl_ms, |impl_m| trait_m.ident == impl_m.mty.ident) {\n           some({mty: impl_m, id, span}) => {\n-            if impl_m.purity != trait_m.purity {\n-                ccx.tcx.sess.span_err(\n-                    span, fmt!{\"method `%s`'s purity does \\\n-                                not match the trait method's \\\n-                                purity\", *impl_m.ident});\n-            }\n             compare_impl_method(\n                 ccx.tcx, span, impl_m, vec::len(tps),\n                 trait_m, tpt.substs, selfty);"}, {"sha": "56cc7f9aca3a6bafb4f159d4941ada0b748243b5", "filename": "src/test/auxiliary/static-methods-crate.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstatic-methods-crate.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -0,0 +1,33 @@\n+#[link(name = \"static_methods_crate\",\n+       vers = \"0.1\")];\n+\n+#[crate_type = \"lib\"];\n+\n+export read, readMaybe;\n+\n+trait read {\n+    static fn readMaybe(s: ~str) -> option<self>;\n+}\n+\n+impl of read for int {\n+    static fn readMaybe(s: ~str) -> option<int> {\n+        int::from_str(s)\n+    }\n+}\n+\n+impl of read for bool {\n+    static fn readMaybe(s: ~str) -> option<bool> {\n+        match s {\n+          ~\"true\" => some(true),\n+          ~\"false\" => some(false),\n+          _ => none\n+        }\n+    }\n+}\n+\n+fn read<T: read copy>(s: ~str) -> T {\n+    match readMaybe(s) {\n+      some(x) => x,\n+      _ => fail ~\"read failed!\"\n+    }\n+}"}, {"sha": "1e23f5888431eac46fe5d10606b513be3718352c", "filename": "src/test/compile-fail/staticness-mismatch.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstaticness-mismatch.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -0,0 +1,10 @@\n+\n+trait foo {\n+    static fn bar();\n+}\n+\n+impl of foo for int {\n+    fn bar() {} //~ ERROR self type does not match the trait method's\n+}\n+\n+fn main() {}"}, {"sha": "5cfa34ed59bbc49c2d998669bcfc002a4abc63be", "filename": "src/test/run-pass/static-method-test.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-test.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -0,0 +1,79 @@\n+\n+// A trait for objects that can be used to do an if-then-else\n+// (No actual need for this to be static, but it is a simple test.)\n+trait bool_like {\n+    static fn select<A>(b: self, +x1: A, +x2: A) -> A;\n+}\n+\n+fn andand<T: bool_like copy>(x1: T, x2: T) -> T {\n+    select(x1, x2, x1)\n+}\n+\n+impl of bool_like for bool {\n+    static fn select<A>(&&b: bool, +x1: A, +x2: A) -> A {\n+        if b { x1 } else { x2 }\n+    }\n+}\n+\n+impl of bool_like for int {\n+    static fn select<A>(&&b: int, +x1: A, +x2: A) -> A {\n+        if b != 0 { x1 } else { x2 }\n+    }\n+}\n+\n+// A trait for sequences that can be constructed imperatively.\n+trait buildable<A> {\n+     static pure fn build_sized(size: uint,\n+                                builder: fn(push: pure fn(+A))) -> self;\n+}\n+\n+\n+impl extensions<A> of buildable<A> for @[A] {\n+    #[inline(always)]\n+     static pure fn build_sized(size: uint,\n+                                builder: fn(push: pure fn(+A))) -> @[A] {\n+         at_vec::build_sized(size, builder)\n+     }\n+}\n+impl extensions<A> of buildable<A> for ~[A] {\n+    #[inline(always)]\n+     static pure fn build_sized(size: uint,\n+                                builder: fn(push: pure fn(+A))) -> ~[A] {\n+         vec::build_sized(size, builder)\n+     }\n+}\n+\n+#[inline(always)]\n+pure fn build<A, B: buildable<A>>(builder: fn(push: pure fn(+A))) -> B {\n+    build_sized(4, builder)\n+}\n+\n+/// Apply a function to each element of an iterable and return the results\n+fn map<T, IT: base_iter<T>, U, BU: buildable<U>>\n+    (v: IT, f: fn(T) -> U) -> BU {\n+    do build |push| {\n+        for v.each() |elem| {\n+            push(f(elem));\n+        }\n+    }\n+}\n+\n+fn seq_range<BT: buildable<int>>(lo: uint, hi: uint) -> BT {\n+    do build_sized(hi-lo) |push| {\n+        for uint::range(lo, hi) |i| {\n+            push(i as int);\n+        }\n+    }\n+}\n+\n+fn main() {\n+    assert seq_range(0, 10) == @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+    assert map(&[1,2,3], |x| 1+x) == @[2, 3, 4];\n+    assert map(&[1,2,3], |x| 1+x) == ~[2, 3, 4];\n+\n+    assert select(true, 9, 14) == 9;\n+    assert !andand(true, false);\n+    assert andand(7, 12) == 12;\n+    assert andand(0, 12) == 0;\n+}"}, {"sha": "a502e4ac2d5af4e2c504cb633411e0193a866979", "filename": "src/test/run-pass/static-method-xcrate.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f7f47620eaeaab8e4993e568d2f5c23e1cb6416/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-method-xcrate.rs?ref=7f7f47620eaeaab8e4993e568d2f5c23e1cb6416", "patch": "@@ -0,0 +1,12 @@\n+// xfail-fast\n+// aux-build:static-methods-crate.rs\n+\n+use static_methods_crate;\n+import static_methods_crate::read;\n+import readMaybeRenamed = static_methods_crate::readMaybe;\n+\n+fn main() {\n+    assert read(~\"5\") == 5;\n+    assert readMaybeRenamed(~\"false\") == some(false);\n+    assert readMaybeRenamed(~\"foo\") == none::<bool>;\n+}"}]}