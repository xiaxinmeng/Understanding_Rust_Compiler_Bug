{"sha": "35e844ffc1e3c022e868817ad1c548b900db800a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1ZTg0NGZmYzFlM2MwMjJlODY4ODE3YWQxYzU0OGI5MDBkYjgwMGE=", "commit": {"author": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-09T01:58:18Z"}, "committer": {"name": "Eric Reed", "email": "ecreed@cs.washington.edu", "date": "2013-08-19T23:31:21Z"}, "message": "Make IO thread-safe.\n\nEach IO handle has a home event loop, which created it.\nWhen a task wants to use an IO handle, it must first make sure it is on that home event loop.\nIt uses the scheduler handle in the IO handle to send itself there before starting the IO action.\nOnce the IO action completes, the task restores its previous home state.\nIf it is an AnySched task, then it will be executed on the new scheduler.\nIf it has a normal home, then it will return there before executing any more code after the IO action.", "tree": {"sha": "876d39c320381af77708ceace32f55094b27384d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/876d39c320381af77708ceace32f55094b27384d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35e844ffc1e3c022e868817ad1c548b900db800a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35e844ffc1e3c022e868817ad1c548b900db800a", "html_url": "https://github.com/rust-lang/rust/commit/35e844ffc1e3c022e868817ad1c548b900db800a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35e844ffc1e3c022e868817ad1c548b900db800a/comments", "author": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "anasazi", "id": 591682, "node_id": "MDQ6VXNlcjU5MTY4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/591682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/anasazi", "html_url": "https://github.com/anasazi", "followers_url": "https://api.github.com/users/anasazi/followers", "following_url": "https://api.github.com/users/anasazi/following{/other_user}", "gists_url": "https://api.github.com/users/anasazi/gists{/gist_id}", "starred_url": "https://api.github.com/users/anasazi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/anasazi/subscriptions", "organizations_url": "https://api.github.com/users/anasazi/orgs", "repos_url": "https://api.github.com/users/anasazi/repos", "events_url": "https://api.github.com/users/anasazi/events{/privacy}", "received_events_url": "https://api.github.com/users/anasazi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d09412ab893f54ef5309cf63d17bcb6110d582b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d09412ab893f54ef5309cf63d17bcb6110d582b9", "html_url": "https://github.com/rust-lang/rust/commit/d09412ab893f54ef5309cf63d17bcb6110d582b9"}], "stats": {"total": 1313, "additions": 653, "deletions": 660}, "files": [{"sha": "bfd1ed48ac180d1ac50eb383681c060dba746f2a", "filename": "src/libstd/rt/io/timer.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ftimer.rs?ref=35e844ffc1e3c022e868817ad1c548b900db800a", "patch": "@@ -41,7 +41,7 @@ impl Timer {\n }\n \n impl RtioTimer for Timer {\n-    fn sleep(&self, msecs: u64) {\n+    fn sleep(&mut self, msecs: u64) {\n         (**self).sleep(msecs);\n     }\n }\n@@ -50,15 +50,11 @@ impl RtioTimer for Timer {\n mod test {\n     use super::*;\n     use rt::test::*;\n-    use option::{Some, None};\n     #[test]\n     fn test_io_timer_sleep_simple() {\n         do run_in_newsched_task {\n             let timer = Timer::new();\n-            match timer {\n-                Some(t) => t.sleep(1),\n-                None => assert!(false)\n-            }\n+            do timer.map_move |mut t| { t.sleep(1) };\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "36eb37a3630fb096de891df7e8bfb0d4529c1358", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=35e844ffc1e3c022e868817ad1c548b900db800a", "patch": "@@ -22,7 +22,7 @@ pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n-pub type RtioUdpSocketObject = uvio::HomedUvUdpSocket; //uvio::UvUdpSocket;\n+pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n pub type RtioTimerObject = uvio::UvTimer;\n \n pub trait EventLoop {\n@@ -88,5 +88,5 @@ pub trait RtioUdpSocket : RtioSocket {\n }\n \n pub trait RtioTimer {\n-    fn sleep(&self, msecs: u64);\n+    fn sleep(&mut self, msecs: u64);\n }"}, {"sha": "1250a4512f71322aecdcdd3716f411985d65eb8f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 647, "deletions": 650, "changes": 1297, "blob_url": "https://github.com/rust-lang/rust/blob/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=35e844ffc1e3c022e868817ad1c548b900db800a", "patch": "@@ -37,6 +37,49 @@ use unstable::sync::Exclusive;\n                             run_in_newsched_task};\n #[cfg(test)] use iterator::{Iterator, range};\n \n+// XXX we should not be calling uvll functions in here.\n+\n+trait HomingIO {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n+    /* XXX This will move pinned tasks to do IO on the proper scheduler\n+     * and then move them back to their home.\n+     */\n+    fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n+        use rt::sched::{PinnedTask, TaskFromFriend};\n+        // go home\n+        let old_home = Cell::new_empty();\n+        let old_home_ptr = &old_home;\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            // get the old home first\n+            do task.wake().map_move |mut task| {\n+                old_home_ptr.put_back(task.take_unwrap_home());\n+                self.home().send(PinnedTask(task));\n+            };\n+        }\n+\n+        // do IO\n+        let a = io(self);\n+\n+        // unhome home\n+        let scheduler = Local::take::<Scheduler>();\n+        do scheduler.deschedule_running_task_and_then |scheduler, task| {\n+            do task.wake().map_move |mut task| {\n+                task.give_home(old_home.take());\n+                scheduler.make_handle().send(TaskFromFriend(task));\n+            };\n+        }\n+\n+        // return the result of the IO\n+        a\n+    }\n+}\n+\n+// get a handle for the current scheduler\n+macro_rules! get_handle_to_current_scheduler(\n+    () => (do Local::borrow::<Scheduler, SchedHandle> |sched| { sched.make_handle() })\n+)\n+\n enum SocketNameKind {\n     TcpPeer,\n     Tcp,\n@@ -45,12 +88,10 @@ enum SocketNameKind {\n \n fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n                                                  handle: U) -> Result<SocketAddr, IoError> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n     let getsockname = match sk {\n-        TcpPeer => uvll::rust_uv_tcp_getpeername,\n-        Tcp     => uvll::rust_uv_tcp_getsockname,\n-        Udp     => uvll::rust_uv_udp_getsockname\n+        TcpPeer => uvll::tcp_getpeername,\n+        Tcp     => uvll::tcp_getsockname,\n+        Udp     => uvll::udp_getsockname,\n     };\n \n     // Allocate a sockaddr_storage\n@@ -80,6 +121,7 @@ fn socket_name<T, U: Watcher + NativeHandle<*T>>(sk: SocketNameKind,\n \n }\n \n+// Obviously an Event Loop is always home.\n pub struct UvEventLoop {\n     uvio: UvIoFactory\n }\n@@ -149,6 +191,7 @@ fn test_callback_run_once() {\n     }\n }\n \n+// The entire point of async is to call into a loop from other threads so it does not need to home.\n pub struct UvRemoteCallback {\n     // The uv async handle for triggering the callback\n     async: AsyncWatcher,\n@@ -251,40 +294,38 @@ impl IoFactory for UvIoFactory {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioTcpStreamObject, IoError>> = &result_cell;\n \n-        let scheduler = Local::take::<Scheduler>();\n-\n         // Block this task and take ownership, switch to scheduler context\n+        let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n \n-            rtdebug!(\"connect: entered scheduler context\");\n-            let mut tcp_watcher = TcpWatcher::new(self.uv_loop());\n+            let mut tcp = TcpWatcher::new(self.uv_loop());\n             let task_cell = Cell::new(task);\n \n             // Wait for a connection\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connect: in connect callback\");\n-                if status.is_none() {\n-                    rtdebug!(\"status is none\");\n-                    let tcp_watcher =\n-                        NativeHandle::from_native_handle(stream_watcher.native_handle());\n-                    let res = Ok(~UvTcpStream(tcp_watcher));\n-\n-                    // Store the stream in the task's stack\n-                    unsafe { (*result_cell_ptr).put_back(res); }\n-\n-                    // Context switch\n-                    let scheduler = Local::take::<Scheduler>();\n-                    scheduler.resume_blocked_task_immediately(task_cell.take());\n-                } else {\n-                    rtdebug!(\"status is some\");\n-                    let task_cell = Cell::new(task_cell.take());\n-                    do stream_watcher.close {\n-                        let res = Err(uv_error_to_io_error(status.unwrap()));\n+            do tcp.connect(addr) |stream, status| {\n+                match status {\n+                    None => {\n+                        let tcp = NativeHandle::from_native_handle(stream.native_handle());\n+                        let home = get_handle_to_current_scheduler!();\n+                        let res = Ok(~UvTcpStream { watcher: tcp, home: home });\n+\n+                        // Store the stream in the task's stack\n                         unsafe { (*result_cell_ptr).put_back(res); }\n+\n+                        // Context switch\n                         let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     }\n-                };\n+                    Some(_) => {\n+                        let task_cell = Cell::new(task_cell.take());\n+                        do stream.close {\n+                            let res = Err(uv_error_to_io_error(status.unwrap()));\n+                            unsafe { (*result_cell_ptr).put_back(res); }\n+                            let scheduler = Local::take::<Scheduler>();\n+                            scheduler.resume_blocked_task_immediately(task_cell.take());\n+                        }\n+                    }\n+                }\n             }\n         }\n \n@@ -295,7 +336,10 @@ impl IoFactory for UvIoFactory {\n     fn tcp_bind(&mut self, addr: SocketAddr) -> Result<~RtioTcpListenerObject, IoError> {\n         let mut watcher = TcpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n-            Ok(_) => Ok(~UvTcpListener::new(watcher)),\n+            Ok(_) => {\n+                let home = get_handle_to_current_scheduler!();\n+                Ok(~UvTcpListener::new(watcher, home))\n+            }\n             Err(uverr) => {\n                 let scheduler = Local::take::<Scheduler>();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n@@ -310,32 +354,12 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    /*\n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~RtioUdpSocketObject, IoError> {\n-        let mut watcher = UdpWatcher::new(self.uv_loop());\n-        match watcher.bind(addr) {\n-            Ok(_) => Ok(~UvUdpSocket(watcher)),\n-            Err(uverr) => {\n-                let scheduler = Local::take::<Scheduler>();\n-                do scheduler.deschedule_running_task_and_then |_, task| {\n-                    let task_cell = Cell::new(task);\n-                    do watcher.close {\n-                        let scheduler = Local::take::<Scheduler>();\n-                        scheduler.resume_blocked_task_immediately(task_cell.take());\n-                    }\n-                }\n-                Err(uv_error_to_io_error(uverr))\n-            }\n-        }\n-    }\n-    */\n-\n-    pub fn /*homed_*/udp_bind(&mut self, addr: SocketAddr) -> Result<~/*HomedUvUdpSocket*/RtioUdpSocketObject, IoError> {\n         let mut watcher = UdpWatcher::new(self.uv_loop());\n         match watcher.bind(addr) {\n             Ok(_) => {\n-                let home = do Local::borrow::<Scheduler, SchedHandle> |sched| {sched.make_handle()};\n-                Ok(~HomedUvUdpSocket { watcher: watcher, home: home })\n+                let home = get_handle_to_current_scheduler!();\n+                Ok(~UvUdpSocket { watcher: watcher, home: home })\n             }\n             Err(uverr) => {\n                 let scheduler = Local::take::<Scheduler>();\n@@ -352,22 +376,30 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn timer_init(&mut self) -> Result<~RtioTimerObject, IoError> {\n-        Ok(~UvTimer(TimerWatcher::new(self.uv_loop())))\n+        let watcher = TimerWatcher::new(self.uv_loop());\n+        let home = get_handle_to_current_scheduler!();\n+        Ok(~UvTimer::new(watcher, home))\n     }\n }\n \n pub struct UvTcpListener {\n     watcher: TcpWatcher,\n     listening: bool,\n-    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>\n+    incoming_streams: Tube<Result<~RtioTcpStreamObject, IoError>>,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpListener {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n impl UvTcpListener {\n-    fn new(watcher: TcpWatcher) -> UvTcpListener {\n+    fn new(watcher: TcpWatcher, home: SchedHandle) -> UvTcpListener {\n         UvTcpListener {\n             watcher: watcher,\n             listening: false,\n-            incoming_streams: Tube::new()\n+            incoming_streams: Tube::new(),\n+            home: home,\n         }\n     }\n \n@@ -376,790 +408,682 @@ impl UvTcpListener {\n \n impl Drop for UvTcpListener {\n     fn drop(&self) {\n-        let watcher = self.watcher();\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do watcher.as_stream().close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        // XXX need mutable finalizer\n+        let self_ = unsafe { transmute::<&UvTcpListener, &mut UvTcpListener>(self) };\n+        do self_.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher().as_stream().close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvTcpListener {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(Tcp, self.watcher)\n+        do self.home_for_io |self_| {\n+          socket_name(Tcp, self_.watcher)\n+        }\n     }\n }\n \n impl RtioTcpListener for UvTcpListener {\n \n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError> {\n-        rtdebug!(\"entering listen\");\n-\n-        if self.listening {\n-            return self.incoming_streams.recv();\n-        }\n-\n-        self.listening = true;\n-\n-        let server_tcp_watcher = self.watcher();\n-        let incoming_streams_cell = Cell::new(self.incoming_streams.clone());\n-\n-        let incoming_streams_cell = Cell::new(incoming_streams_cell.take());\n-        let mut server_tcp_watcher = server_tcp_watcher;\n-        do server_tcp_watcher.listen |mut server_stream_watcher, status| {\n-            let maybe_stream = if status.is_none() {\n-                let mut loop_ = server_stream_watcher.event_loop();\n-                let client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-                // XXX: Need's to be surfaced in interface\n-                server_stream_watcher.accept(client_tcp_watcher.as_stream());\n-                Ok(~UvTcpStream(client_tcp_watcher))\n-            } else {\n-                Err(standard_error(OtherIoError))\n-            };\n+        do self.home_for_io |self_| {\n+\n+            if !self_.listening {\n+                self_.listening = true;\n+\n+                let incoming_streams_cell = Cell::new(self_.incoming_streams.clone());\n+\n+                do self_.watcher().listen |mut server, status| {\n+                    let stream = match status {\n+                        Some(_) => Err(standard_error(OtherIoError)),\n+                        None => {\n+                            let client = TcpWatcher::new(&server.event_loop());\n+                            // XXX: needs to be surfaced in interface\n+                            server.accept(client.as_stream());\n+                            let home = get_handle_to_current_scheduler!();\n+                            Ok(~UvTcpStream { watcher: client, home: home })\n+                        }\n+                    };\n+\n+                    let mut incoming_streams = incoming_streams_cell.take();\n+                    incoming_streams.send(stream);\n+                    incoming_streams_cell.put_back(incoming_streams);\n+                }\n \n-            let mut incoming_streams = incoming_streams_cell.take();\n-            incoming_streams.send(maybe_stream);\n-            incoming_streams_cell.put_back(incoming_streams);\n+            }\n+            self_.incoming_streams.recv()\n         }\n-\n-        return self.incoming_streams.recv();\n     }\n \n     fn accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 1 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 1 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher(), r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn dont_accept_simultaneously(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_simultaneous_accepts(self.watcher.native_handle(), 0 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_simultaneous_accepts(self_.watcher().native_handle(), 0 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher(), r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n }\n \n-pub struct UvTcpStream(TcpWatcher);\n+pub struct UvTcpStream {\n+    watcher: TcpWatcher,\n+    home: SchedHandle,\n+}\n+\n+impl HomingIO for UvTcpStream {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n+}\n \n impl Drop for UvTcpStream {\n     fn drop(&self) {\n-        rtdebug!(\"closing tcp stream\");\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.as_stream().close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        // XXX need mutable finalizer\n+        let this = unsafe { transmute::<&UvTcpStream, &mut UvTcpStream>(self) };\n+        do this.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.as_stream().close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n impl RtioSocket for UvTcpStream {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(Tcp, **self)\n+        do self.home_for_io |self_| {\n+            socket_name(Tcp, self_.watcher)\n+        }\n     }\n }\n \n impl RtioTcpStream for UvTcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n-\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            rtdebug!(\"read: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            // XXX: We shouldn't reallocate these callbacks every\n-            // call to read\n-            let alloc: AllocCallback = |_| unsafe {\n-                slice_to_uv_buf(*buf_ptr)\n-            };\n-            let mut watcher = self.as_stream();\n-            do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n-\n-                // Stop reading so that no read callbacks are\n-                // triggered before the user calls `read` again.\n-                // XXX: Is there a performance impact to calling\n-                // stop here?\n-                watcher.read_stop();\n-\n-                let result = if status.is_none() {\n-                    assert!(nread >= 0);\n-                    Ok(nread as uint)\n-                } else {\n-                    Err(uv_error_to_io_error(status.unwrap()))\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&mut [u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                let task_cell = Cell::new(task);\n+                // XXX: We shouldn't reallocate these callbacks every\n+                // call to read\n+                let alloc: AllocCallback = |_| unsafe {\n+                    slice_to_uv_buf(*buf_ptr)\n                 };\n+                let mut watcher = self_.watcher.as_stream();\n+                do watcher.read_start(alloc) |mut watcher, nread, _buf, status| {\n \n-                unsafe { (*result_cell_ptr).put_back(result); }\n+                    // Stop reading so that no read callbacks are\n+                    // triggered before the user calls `read` again.\n+                    // XXX: Is there a performance impact to calling\n+                    // stop here?\n+                    watcher.read_stop();\n \n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let result = if status.is_none() {\n+                        assert!(nread >= 0);\n+                        Ok(nread as uint)\n+                    } else {\n+                        Err(uv_error_to_io_error(status.unwrap()))\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            let mut watcher = self.as_stream();\n-            do watcher.write(buf) |_watcher, status| {\n-                let result = if status.is_none() {\n-                    Ok(())\n-                } else {\n-                    Err(uv_error_to_io_error(status.unwrap()))\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&[u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                let mut watcher = self_.watcher.as_stream();\n+                do watcher.write(buf) |_watcher, status| {\n+                    let result = if status.is_none() {\n+                        Ok(())\n+                    } else {\n+                        Err(uv_error_to_io_error(status.unwrap()))\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn peer_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(TcpPeer, **self)\n+        do self.home_for_io |self_| {\n+            socket_name(TcpPeer, self_.watcher)\n+        }\n     }\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_nodelay(self.native_handle(), 0 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_nodelay(self.native_handle(), 1 as c_int)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_keepalive(self.native_handle(), 1 as c_int,\n-                                        delay_in_seconds as c_uint)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n+                                    delay_in_seconds as c_uint)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn letdie(&mut self) -> Result<(), IoError> {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        let r = unsafe {\n-            uvll::rust_uv_tcp_keepalive(self.native_handle(), 0 as c_int, 0 as c_uint)\n-        };\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n+            };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n }\n \n-pub struct HomedUvUdpSocket {\n+pub struct UvUdpSocket {\n     watcher: UdpWatcher,\n     home: SchedHandle,\n }\n \n-impl HomedUvUdpSocket {\n-    fn go_home(&mut self) {\n-        use rt::sched::PinnedTask;\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            do task.wake().map_move |task| { self.home.send(PinnedTask(task)); };\n-        }\n-    }\n+impl HomingIO for UvUdpSocket {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n-impl Drop for HomedUvUdpSocket {\n+impl Drop for UvUdpSocket {\n     fn drop(&self) {\n-        rtdebug!(\"closing homed udp socket\");\n-        // first go home\n         // XXX need mutable finalizer\n-        let this = unsafe { transmute::<&HomedUvUdpSocket, &mut HomedUvUdpSocket>(self) };\n-        this.go_home();\n-        // now we're home so block the task and start IO\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do this.watcher.close {\n-                // now IO is finished so resume the blocked task\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        let this = unsafe { transmute::<&UvUdpSocket, &mut UvUdpSocket>(self) };\n+        do this.home_for_io |_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do this.watcher.close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n-impl RtioSocket for HomedUvUdpSocket {\n+impl RtioSocket for UvUdpSocket {\n     fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-\t// first go home\n-        self.go_home();\n-        socket_name(Udp, self.watcher)\n+        do self.home_for_io |self_| {\n+            socket_name(Udp, self_.watcher)\n+        }\n     }\n }\n \n-impl RtioUdpSocket for HomedUvUdpSocket {\n+impl RtioUdpSocket for UvUdpSocket {\n     fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-\t// first go home\n-\tself.go_home();\n-\n-\tlet result_cell = Cell::new_empty();\n-\tlet result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-\n-\tlet scheduler = Local::take::<Scheduler>();\n-\tlet buf_ptr: *&mut [u8] = &buf;\n-\tdo scheduler.deschedule_running_task_and_then |_, task| {\n-\t    rtdebug!(\"recvfrom: entered scheduler context\");\n-\t    let task_cell = Cell::new(task);\n-\t    let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n-\t    do self.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n-\t\tlet _ = flags; // /XXX add handling for partials?\n-\n-\t\twatcher.recv_stop();\n-\n-\t\tlet result = match status {\n-\t\t    None => {\n-\t\t\tassert!(nread >= 0);\n-\t\t\tOk((nread as uint, addr))\n-\t\t    }\n-\t\t    Some(err) => Err(uv_error_to_io_error(err)),\n-\t\t};\n-\n-\t\tunsafe { (*result_cell_ptr).put_back(result); }\n-\n-\t\tlet scheduler = Local::take::<Scheduler>();\n-\t\tscheduler.resume_blocked_task_immediately(task_cell.take());\n-\t    }\n-\t}\n-\n-\tassert!(!result_cell.is_empty());\n-\treturn result_cell.take();\n-    }\n-\n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n+\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&mut [u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+                do self_.watcher.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n+                    let _ = flags; // /XXX add handling for partials?\n+\n+                    watcher.recv_stop();\n+\n+                    let result = match status {\n+                        None => {\n+                            assert!(nread >= 0);\n+                            Ok((nread as uint, addr))\n+                        }\n+                        Some(err) => Err(uv_error_to_io_error(err)),\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n \n-\tlet result_cell = Cell::new_empty();\n-\tlet result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.watcher.send(buf, dst) |_watcher, status| {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n \n-                let result = match status {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err)),\n-                };\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n+    }\n \n-                unsafe { (*result_cell_ptr).put_back(result); }\n+    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n+        do self.home_for_io |self_| {\n+            let result_cell = Cell::new_empty();\n+            let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+            let scheduler = Local::take::<Scheduler>();\n+            let buf_ptr: *&[u8] = &buf;\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+                do self_.watcher.send(buf, dst) |_watcher, status| {\n+\n+                    let result = match status {\n+                        None => Ok(()),\n+                        Some(err) => Err(uv_error_to_io_error(err)),\n+                    };\n+\n+                    unsafe { (*result_cell_ptr).put_back(result); }\n \n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n-        }\n \n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n+            assert!(!result_cell.is_empty());\n+            result_cell.take()\n+        }\n     }\n \n     fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                do multi.to_str().with_c_str |m_addr| {\n+                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n+                                             ptr::null(), uvll::UV_JOIN_GROUP)\n+                }\n+            };\n \n-        let r = unsafe {\n-            do multi.to_str().as_c_str |m_addr| {\n-                uvll::udp_set_membership(self.watcher.native_handle(), m_addr,\n-                                         ptr::null(), uvll::UV_JOIN_GROUP)\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n             }\n-        };\n-\n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n         }\n     }\n \n     fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n+            let r = unsafe {\n+                do multi.to_str().with_c_str |m_addr| {\n+                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n+                                             ptr::null(), uvll::UV_LEAVE_GROUP)\n+                }\n+            };\n \n-        let r = unsafe {\n-            do multi.to_str().as_c_str |m_addr| {\n-                uvll::udp_set_membership(self.watcher.native_handle(), m_addr,\n-                                         ptr::null(), uvll::UV_LEAVE_GROUP)\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n             }\n-        };\n-\n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n         }\n     }\n \n     fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n \n-        let r = unsafe {\n-            uvll::udp_set_multicast_loop(self.watcher.native_handle(), 1 as c_int)\n-        };\n+            let r = unsafe {\n+                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n \n-        let r = unsafe {\n-            uvll::udp_set_multicast_loop(self.watcher.native_handle(), 0 as c_int)\n-        };\n+            let r = unsafe {\n+                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n \n-        let r = unsafe {\n-            uvll::udp_set_multicast_ttl(self.watcher.native_handle(), ttl as c_int)\n-        };\n+            let r = unsafe {\n+                uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n \n-        let r = unsafe {\n-            uvll::udp_set_ttl(self.watcher.native_handle(), ttl as c_int)\n-        };\n+            let r = unsafe {\n+                uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n \n-        let r = unsafe {\n-            uvll::udp_set_broadcast(self.watcher.native_handle(), 1 as c_int)\n-        };\n+            let r = unsafe {\n+                uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n \n     fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-\t// first go home\n-\tself.go_home();\n+        do self.home_for_io |self_| {\n \n-        let r = unsafe {\n-            uvll::udp_set_broadcast(self.watcher.native_handle(), 0 as c_int)\n-        };\n+            let r = unsafe {\n+                uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n+            };\n \n-        match status_to_maybe_uv_error(self.watcher, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n+            match status_to_maybe_uv_error(self_.watcher, r) {\n+                Some(err) => Err(uv_error_to_io_error(err)),\n+                None => Ok(())\n+            }\n         }\n     }\n }\n \n-#[test]\n-fn test_simple_homed_udp_io_bind_only() {\n-    do run_in_newsched_task {\n-        unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n-            let addr = next_test_ip4();\n-            let maybe_socket = (*io)./*homed_*/udp_bind(addr);\n-            assert!(maybe_socket.is_ok());\n-        }\n-    }\n+pub struct UvTimer {\n+    watcher: timer::TimerWatcher,\n+    home: SchedHandle,\n }\n \n-#[test]\n-fn test_simple_homed_udp_io_bind_then_move_then_home_and_close() {\n-    use rt::sleeper_list::SleeperList;\n-    use rt::work_queue::WorkQueue;\n-    use rt::thread::Thread;\n-    use rt::task::Task;\n-    use rt::sched::{Shutdown, TaskFromFriend};\n-    do run_in_bare_thread {\n-\tlet sleepers = SleeperList::new();\n-\tlet work_queue1 = WorkQueue::new();\n-\tlet work_queue2 = WorkQueue::new();\n-\tlet queues = ~[work_queue1.clone(), work_queue2.clone()];\n-\n-\tlet mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n-\t\t\t\t\t sleepers.clone());\n-\tlet mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n-\t\t\t\t\t sleepers.clone());\n-\n-\tlet handle1 = Cell::new(sched1.make_handle());\n-\tlet handle2 = Cell::new(sched2.make_handle());\n-\tlet tasksFriendHandle = Cell::new(sched2.make_handle());\n-\n-\tlet on_exit: ~fn(bool) = |exit_status| {\n-\t    handle1.take().send(Shutdown);\n-\t    handle2.take().send(Shutdown);\n-\t    rtassert!(exit_status);\n-\t};\n-\n-\tlet test_function: ~fn() = || {\n-\t    let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n-\t    let addr = next_test_ip4();\n-\t    let maybe_socket = unsafe { (*io)./*homed_*/udp_bind(addr) };\n-\t    // this socket is bound to this event loop\n-\t    assert!(maybe_socket.is_ok());\n-\n-\t    // block self on sched1\n-\t    let scheduler = Local::take::<Scheduler>();\n-\t    do scheduler.deschedule_running_task_and_then |_, task| {\n-\t\t// unblock task\n-\t\tdo task.wake().map_move |task| {\n-\t\t  // send self to sched2\n-\t\t  tasksFriendHandle.take().send(TaskFromFriend(task));\n-\t\t};\n-\t\t// sched1 should now sleep since it has nothing else to do\n-\t    }\n-\t    // sched2 will wake up and get the task\n-\t    // as we do nothing else, the function ends and the socket goes out of scope\n-\t    // sched2 will start to run the destructor\n-\t    // the destructor will first block the task, set it's home as sched1, then enqueue it\n-\t    // sched2 will dequeue the task, see that it has a home, and send it to sched1\n-\t    // sched1 will wake up, execute the close function on the correct loop, and then we're done\n-\t};\n-\n-\tlet mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n-\tmain_task.death.on_exit = Some(on_exit);\n-\tlet main_task = Cell::new(main_task);\n-\n-\tlet null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n-\n-\tlet sched1 = Cell::new(sched1);\n-\tlet sched2 = Cell::new(sched2);\n-\n-\t// XXX could there be a race on the threads that causes a crash?\n-\tlet thread1 = do Thread::start {\n-\t    sched1.take().bootstrap(main_task.take());\n-\t};\n-\tlet thread2 = do Thread::start {\n-\t    sched2.take().bootstrap(null_task.take());\n-\t};\n-\n-\tthread1.join();\n-\tthread2.join();\n-    }\n+impl HomingIO for UvTimer {\n+    fn home<'r>(&'r mut self) -> &'r mut SchedHandle { &mut self.home }\n }\n \n-pub struct UvUdpSocket(UdpWatcher);\n+impl UvTimer {\n+    fn new(w: timer::TimerWatcher, home: SchedHandle) -> UvTimer {\n+        UvTimer { watcher: w, home: home }\n+    }\n+}\n \n-impl Drop for UvUdpSocket {\n+impl Drop for UvTimer {\n     fn drop(&self) {\n-        rtdebug!(\"closing udp socket\");\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n+        let self_ = unsafe { transmute::<&UvTimer, &mut UvTimer>(self) };\n+        do self_.home_for_io |self_| {\n+            rtdebug!(\"closing UvTimer\");\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.close {\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n             }\n         }\n     }\n }\n \n-impl RtioSocket for UvUdpSocket {\n-    fn socket_name(&mut self) -> Result<SocketAddr, IoError> {\n-        socket_name(Udp, **self)\n+impl RtioTimer for UvTimer {\n+    fn sleep(&mut self, msecs: u64) {\n+        do self.home_for_io |self_| {\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_sched, task| {\n+                rtdebug!(\"sleep: entered scheduler context\");\n+                let task_cell = Cell::new(task);\n+                do self_.watcher.start(msecs, 0) |_, status| {\n+                    assert!(status.is_none());\n+                    let scheduler = Local::take::<Scheduler>();\n+                    scheduler.resume_blocked_task_immediately(task_cell.take());\n+                }\n+            }\n+            self_.watcher.stop();\n+        }\n     }\n }\n \n-impl RtioUdpSocket for UvUdpSocket {\n-    fn recvfrom(&mut self, buf: &mut [u8]) -> Result<(uint, SocketAddr), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(uint, SocketAddr), IoError>> = &result_cell;\n-\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&mut [u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            rtdebug!(\"recvfrom: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.recv_start(alloc) |mut watcher, nread, _buf, addr, flags, status| {\n-                let _ = flags; // XXX add handling for partials?\n-\n-                watcher.recv_stop();\n-\n-                let result = match status {\n-                    None => {\n-                        assert!(nread >= 0);\n-                        Ok((nread as uint, addr))\n-                    }\n-                    Some(err) => Err(uv_error_to_io_error(err))\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n+#[test]\n+fn test_simple_io_no_connect() {\n+    do run_in_newsched_task {\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let addr = next_test_ip4();\n+            let maybe_chan = (*io).tcp_connect(addr);\n+            assert!(maybe_chan.is_err());\n         }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n+}\n \n-    fn sendto(&mut self, buf: &[u8], dst: SocketAddr) -> Result<(), IoError> {\n-        let result_cell = Cell::new_empty();\n-        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n-        let scheduler = Local::take::<Scheduler>();\n-        let buf_ptr: *&[u8] = &buf;\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n-            do self.send(buf, dst) |_watcher, status| {\n-\n-                let result = match status {\n-                    None => Ok(()),\n-                    Some(err) => Err(uv_error_to_io_error(err)),\n-                };\n-\n-                unsafe { (*result_cell_ptr).put_back(result); }\n-\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n+#[test]\n+fn test_simple_udp_io_bind_only() {\n+    do run_in_newsched_task {\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let addr = next_test_ip4();\n+            let maybe_socket = (*io).udp_bind(addr);\n+            assert!(maybe_socket.is_ok());\n         }\n-\n-        assert!(!result_cell.is_empty());\n-        return result_cell.take();\n     }\n+}\n \n-    fn join_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let r = unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n-                uvll::udp_set_membership(self.native_handle(), m_addr,\n-                                         ptr::null(), uvll::UV_JOIN_GROUP)\n-            }\n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_task_then_home_and_close() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::sched::{Shutdown, TaskFromFriend};\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+        let work_queue1 = WorkQueue::new();\n+        let work_queue2 = WorkQueue::new();\n+        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n+\n+        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+                                         sleepers.clone());\n+        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+                                         sleepers.clone());\n+\n+        let handle1 = Cell::new(sched1.make_handle());\n+        let handle2 = Cell::new(sched2.make_handle());\n+        let tasksFriendHandle = Cell::new(sched2.make_handle());\n+\n+        let on_exit: ~fn(bool) = |exit_status| {\n+            handle1.take().send(Shutdown);\n+            handle2.take().send(Shutdown);\n+            rtassert!(exit_status);\n         };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n+        let test_function: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let addr = next_test_ip4();\n+            let maybe_socket = unsafe { (*io).udp_bind(addr) };\n+            // this socket is bound to this event loop\n+            assert!(maybe_socket.is_ok());\n \n-    fn leave_multicast(&mut self, multi: IpAddr) -> Result<(), IoError> {\n-        let r = unsafe {\n-            do multi.to_str().with_c_str |m_addr| {\n-                uvll::udp_set_membership(self.native_handle(), m_addr,\n-                                         ptr::null(), uvll::UV_LEAVE_GROUP)\n+            // block self on sched1\n+            let scheduler = Local::take::<Scheduler>();\n+            do scheduler.deschedule_running_task_and_then |_, task| {\n+                // unblock task\n+                do task.wake().map_move |task| {\n+                  // send self to sched2\n+                  tasksFriendHandle.take().send(TaskFromFriend(task));\n+                };\n+                // sched1 should now sleep since it has nothing else to do\n             }\n+            // sched2 will wake up and get the task\n+            // as we do nothing else, the function ends and the socket goes out of scope\n+            // sched2 will start to run the destructor\n+            // the destructor will first block the task, set it's home as sched1, then enqueue it\n+            // sched2 will dequeue the task, see that it has a home, and send it to sched1\n+            // sched1 will wake up, exec the close function on the correct loop, and then we're done\n         };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n+        let mut main_task = ~Task::new_root(&mut sched1.stack_pool, None, test_function);\n+        main_task.death.on_exit = Some(on_exit);\n+        let main_task = Cell::new(main_task);\n \n-    fn loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_multicast_loop(self.native_handle(), 1 as c_int)\n-        };\n+        let null_task = Cell::new(~do Task::new_root(&mut sched2.stack_pool, None) || {});\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n+        let sched1 = Cell::new(sched1);\n+        let sched2 = Cell::new(sched2);\n \n-    fn dont_loop_multicast_locally(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_multicast_loop(self.native_handle(), 0 as c_int)\n+        let thread1 = do Thread::start {\n+            sched1.take().bootstrap(main_task.take());\n         };\n-\n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n-\n-    fn multicast_time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_multicast_ttl(self.native_handle(), ttl as c_int)\n+        let thread2 = do Thread::start {\n+            sched2.take().bootstrap(null_task.take());\n         };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n+        thread1.join();\n+        thread2.join();\n     }\n+}\n \n-    fn time_to_live(&mut self, ttl: int) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_ttl(self.native_handle(), ttl as c_int)\n-        };\n+#[test]\n+fn test_simple_homed_udp_io_bind_then_move_handle_then_home_and_close() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::comm::oneshot;\n+    use rt::sched::Shutdown;\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+        let work_queue1 = WorkQueue::new();\n+        let work_queue2 = WorkQueue::new();\n+        let queues = ~[work_queue1.clone(), work_queue2.clone()];\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n+        let mut sched1 = ~Scheduler::new(~UvEventLoop::new(), work_queue1, queues.clone(),\n+                                         sleepers.clone());\n+        let mut sched2 = ~Scheduler::new(~UvEventLoop::new(), work_queue2, queues.clone(),\n+                                         sleepers.clone());\n \n-    fn hear_broadcasts(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_broadcast(self.native_handle(), 1 as c_int)\n-        };\n+        let handle1 = Cell::new(sched1.make_handle());\n+        let handle2 = Cell::new(sched2.make_handle());\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n+        let (port, chan) = oneshot();\n+        let port = Cell::new(port);\n+        let chan = Cell::new(chan);\n \n-    fn ignore_broadcasts(&mut self) -> Result<(), IoError> {\n-        let r = unsafe {\n-            uvll::udp_set_broadcast(self.native_handle(), 0 as c_int)\n+        let body1: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let addr = next_test_ip4();\n+            let socket = unsafe { (*io).udp_bind(addr) };\n+            assert!(socket.is_ok());\n+            chan.take().send(socket);\n         };\n \n-        match status_to_maybe_uv_error(**self, r) {\n-            Some(err) => Err(uv_error_to_io_error(err)),\n-            None => Ok(())\n-        }\n-    }\n-}\n+        let body2: ~fn() = || {\n+            let socket = port.take().recv();\n+            assert!(socket.is_ok());\n+            /* The socket goes out of scope and the destructor is called.\n+             * The destructor:\n+             *  - sends itself back to sched1\n+             *  - frees the socket\n+             *  - resets the home of the task to whatever it was previously\n+             */\n+        };\n \n-pub struct UvTimer(timer::TimerWatcher);\n+        let on_exit: ~fn(bool) = |exit| {\n+            handle1.take().send(Shutdown);\n+            handle2.take().send(Shutdown);\n+            rtassert!(exit);\n+        };\n \n-impl UvTimer {\n-    fn new(w: timer::TimerWatcher) -> UvTimer {\n-        UvTimer(w)\n-    }\n-}\n+        let task1 = Cell::new(~Task::new_root(&mut sched1.stack_pool, None, body1));\n \n-impl Drop for UvTimer {\n-    fn drop(&self) {\n-        rtdebug!(\"closing UvTimer\");\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell::new(task);\n-            do self.close {\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-    }\n-}\n+        let mut task2 = ~Task::new_root(&mut sched2.stack_pool, None, body2);\n+        task2.death.on_exit = Some(on_exit);\n+        let task2 = Cell::new(task2);\n \n-impl RtioTimer for UvTimer {\n-    fn sleep(&self, msecs: u64) {\n-        let scheduler = Local::take::<Scheduler>();\n-        do scheduler.deschedule_running_task_and_then |_sched, task| {\n-            rtdebug!(\"sleep: entered scheduler context\");\n-            let task_cell = Cell::new(task);\n-            let mut watcher = **self;\n-            do watcher.start(msecs, 0) |_, status| {\n-                assert!(status.is_none());\n-                let scheduler = Local::take::<Scheduler>();\n-                scheduler.resume_blocked_task_immediately(task_cell.take());\n-            }\n-        }\n-        let mut w = **self;\n-        w.stop();\n-    }\n-}\n+        let sched1 = Cell::new(sched1);\n+        let sched2 = Cell::new(sched2);\n \n-#[test]\n-fn test_simple_io_no_connect() {\n-    do run_in_newsched_task {\n-        unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n-            let addr = next_test_ip4();\n-            let maybe_chan = (*io).tcp_connect(addr);\n-            assert!(maybe_chan.is_err());\n-        }\n-    }\n-}\n+        let thread1 = do Thread::start {\n+            sched1.take().bootstrap(task1.take());\n+        };\n+        let thread2 = do Thread::start {\n+            sched2.take().bootstrap(task2.take());\n+        };\n \n-#[test]\n-fn test_simple_udp_io_bind_only() {\n-    do run_in_newsched_task {\n-        unsafe {\n-            let io = Local::unsafe_borrow::<IoFactoryObject>();\n-            let addr = next_test_ip4();\n-            let maybe_socket = (*io).udp_bind(addr);\n-            assert!(maybe_socket.is_ok());\n-        }\n+        thread1.join();\n+        thread2.join();\n     }\n }\n \n@@ -1194,6 +1118,85 @@ fn test_simple_tcp_server_and_client() {\n     }\n }\n \n+#[test]\n+fn test_simple_tcp_server_and_client_on_diff_threads() {\n+    use rt::sleeper_list::SleeperList;\n+    use rt::work_queue::WorkQueue;\n+    use rt::thread::Thread;\n+    use rt::task::Task;\n+    use rt::sched::{Shutdown};\n+    do run_in_bare_thread {\n+        let sleepers = SleeperList::new();\n+\n+        let server_addr = next_test_ip4();\n+        let client_addr = server_addr.clone();\n+\n+        let server_work_queue = WorkQueue::new();\n+        let client_work_queue = WorkQueue::new();\n+        let queues = ~[server_work_queue.clone(), client_work_queue.clone()];\n+\n+        let mut server_sched = ~Scheduler::new(~UvEventLoop::new(), server_work_queue,\n+                                               queues.clone(), sleepers.clone());\n+        let mut client_sched = ~Scheduler::new(~UvEventLoop::new(), client_work_queue,\n+                                               queues.clone(), sleepers.clone());\n+\n+        let server_handle = Cell::new(server_sched.make_handle());\n+        let client_handle = Cell::new(client_sched.make_handle());\n+\n+        let server_on_exit: ~fn(bool) = |exit_status| {\n+            server_handle.take().send(Shutdown);\n+            rtassert!(exit_status);\n+        };\n+\n+        let client_on_exit: ~fn(bool) = |exit_status| {\n+            client_handle.take().send(Shutdown);\n+            rtassert!(exit_status);\n+        };\n+\n+        let server_fn: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let mut listener = unsafe { (*io).tcp_bind(server_addr).unwrap() };\n+            let mut stream = listener.accept().unwrap();\n+            let mut buf = [0, .. 2048];\n+            let nread = stream.read(buf).unwrap();\n+            assert_eq!(nread, 8);\n+            for i in range(0u, nread) {\n+                assert_eq!(buf[i], i as u8);\n+            }\n+        };\n+\n+        let client_fn: ~fn() = || {\n+            let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n+            let mut stream = unsafe { (*io).tcp_connect(client_addr) };\n+            while stream.is_err() {\n+                stream = unsafe { (*io).tcp_connect(client_addr) };\n+            }\n+            stream.unwrap().write([0, 1, 2, 3, 4, 5, 6, 7]);\n+        };\n+\n+        let mut server_task = ~Task::new_root(&mut server_sched.stack_pool, None, server_fn);\n+        server_task.death.on_exit = Some(server_on_exit);\n+        let server_task = Cell::new(server_task);\n+\n+        let mut client_task = ~Task::new_root(&mut client_sched.stack_pool, None, client_fn);\n+        client_task.death.on_exit = Some(client_on_exit);\n+        let client_task = Cell::new(client_task);\n+\n+        let server_sched = Cell::new(server_sched);\n+        let client_sched = Cell::new(client_sched);\n+\n+        let server_thread = do Thread::start {\n+            server_sched.take().bootstrap(server_task.take());\n+        };\n+        let client_thread = do Thread::start {\n+            client_sched.take().bootstrap(client_task.take());\n+        };\n+\n+        server_thread.join();\n+        client_thread.join();\n+    }\n+}\n+\n #[test]\n fn test_simple_udp_server_and_client() {\n     do run_in_newsched_task {\n@@ -1410,19 +1413,13 @@ fn test_udp_many_read() {\n     }\n }\n \n-fn test_timer_sleep_simple_impl() {\n-    unsafe {\n-        let io = Local::unsafe_borrow::<IoFactoryObject>();\n-        let timer = (*io).timer_init();\n-        match timer {\n-            Ok(t) => t.sleep(1),\n-            Err(_) => assert!(false)\n-        }\n-    }\n-}\n #[test]\n fn test_timer_sleep_simple() {\n     do run_in_newsched_task {\n-        test_timer_sleep_simple_impl();\n+        unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            let timer = (*io).timer_init();\n+            do timer.map_move |mut t| { t.sleep(1) };\n+        }\n     }\n }"}, {"sha": "0ea2175336ab02aefae3f50aa5225b20db43529c", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35e844ffc1e3c022e868817ad1c548b900db800a/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=35e844ffc1e3c022e868817ad1c548b900db800a", "patch": "@@ -288,7 +288,7 @@ pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_\n     return rust_uv_get_udp_handle_from_send_req(send_req);\n }\n \n-pub unsafe fn udp_get_sockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n+pub unsafe fn udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     return rust_uv_udp_getsockname(handle, name);"}]}