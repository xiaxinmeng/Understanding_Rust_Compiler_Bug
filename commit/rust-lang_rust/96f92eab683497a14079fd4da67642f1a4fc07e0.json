{"sha": "96f92eab683497a14079fd4da67642f1a4fc07e0", "node_id": "C_kwDOAAsO6NoAKDk2ZjkyZWFiNjgzNDk3YTE0MDc5ZmQ0ZGE2NzY0MmYxYTRmYzA3ZTA", "commit": {"author": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-09-27T15:44:56Z"}, "committer": {"name": "Nathan Stocks", "email": "cleancut@github.com", "date": "2022-10-07T19:19:27Z"}, "message": "migrate naked_functions.rs to translateable diagnostics", "tree": {"sha": "f550cbb253a4f0ffe70cac65cfe1fb9c62ba0567", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f550cbb253a4f0ffe70cac65cfe1fb9c62ba0567"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96f92eab683497a14079fd4da67642f1a4fc07e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96f92eab683497a14079fd4da67642f1a4fc07e0", "html_url": "https://github.com/rust-lang/rust/commit/96f92eab683497a14079fd4da67642f1a4fc07e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96f92eab683497a14079fd4da67642f1a4fc07e0/comments", "author": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "committer": {"login": "CleanCut", "id": 5838512, "node_id": "MDQ6VXNlcjU4Mzg1MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5838512?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CleanCut", "html_url": "https://github.com/CleanCut", "followers_url": "https://api.github.com/users/CleanCut/followers", "following_url": "https://api.github.com/users/CleanCut/following{/other_user}", "gists_url": "https://api.github.com/users/CleanCut/gists{/gist_id}", "starred_url": "https://api.github.com/users/CleanCut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CleanCut/subscriptions", "organizations_url": "https://api.github.com/users/CleanCut/orgs", "repos_url": "https://api.github.com/users/CleanCut/repos", "events_url": "https://api.github.com/users/CleanCut/events{/privacy}", "received_events_url": "https://api.github.com/users/CleanCut/received_events", "type": "User", "site_admin": true}, "parents": [{"sha": "69766e4f167f4097e1f8975bd866c1f782fa26d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/69766e4f167f4097e1f8975bd866c1f782fa26d5", "html_url": "https://github.com/rust-lang/rust/commit/69766e4f167f4097e1f8975bd866c1f782fa26d5"}], "stats": {"total": 188, "additions": 129, "deletions": 59}, "files": [{"sha": "ddc8f149d134c02aa81ee991b62b1ccec31b53fc", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/96f92eab683497a14079fd4da67642f1a4fc07e0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/96f92eab683497a14079fd4da67642f1a4fc07e0/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=96f92eab683497a14079fd4da67642f1a4fc07e0", "patch": "@@ -467,3 +467,31 @@ passes_unlabeled_in_labeled_block =\n passes_unlabeled_cf_in_while_condition =\n     `break` or `continue` with no label in the condition of a `while` loop\n     .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n+\n+passes_cannot_inline_naked_function =\n+    naked functions cannot be inlined\n+\n+passes_undefined_naked_function_abi =\n+    Rust ABI is unsupported in naked functions\n+\n+passes_no_patterns =\n+    patterns not allowed in naked function parameters\n+\n+passes_params_not_allowed =\n+    referencing function parameters is not allowed in naked functions\n+    .help = follow the calling convention in asm block to use parameters\n+\n+passes_naked_functions_asm_block =\n+    naked functions must contain a single asm block\n+    .label_multiple_asm = multiple asm blocks are unsupported in naked functions\n+    .label_non_asm = non-asm is unsupported in naked functions\n+\n+passes_naked_functions_operands =\n+    only `const` and `sym` operands are supported in naked functions\n+\n+passes_naked_functions_asm_options =\n+    asm options unsupported in naked functions: {$unsupported_options}\n+\n+passes_naked_functions_must_use_noreturn =\n+    asm in naked functions must use `noreturn` option\n+    .suggestion = consider specifying that the asm block is responsible for returning from the function"}, {"sha": "fd79c54cdd7b0526f211ed31fd4b839d2402b438", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/96f92eab683497a14079fd4da67642f1a4fc07e0/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f92eab683497a14079fd4da67642f1a4fc07e0/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=96f92eab683497a14079fd4da67642f1a4fc07e0", "patch": "@@ -987,3 +987,79 @@ pub struct UnlabeledCfInWhileCondition<'a> {\n     pub span: Span,\n     pub cf_type: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::cannot_inline_naked_function)]\n+pub struct CannotInlineNakedFunction {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes::undefined_naked_function_abi)]\n+pub struct UndefinedNakedFunctionAbi;\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::no_patterns)]\n+pub struct NoPatterns {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::params_not_allowed)]\n+#[help]\n+pub struct ParamsNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+pub struct NakedFunctionsAsmBlock {\n+    pub span: Span,\n+    pub multiple_asms: Vec<Span>,\n+    pub non_asms: Vec<Span>,\n+}\n+\n+impl IntoDiagnostic<'_> for NakedFunctionsAsmBlock {\n+    fn into_diagnostic(\n+        self,\n+        handler: &rustc_errors::Handler,\n+    ) -> rustc_errors::DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        let mut diag = handler.struct_span_err_with_code(\n+            self.span,\n+            rustc_errors::fluent::passes::naked_functions_asm_block,\n+            error_code!(E0787),\n+        );\n+        for span in self.multiple_asms.iter() {\n+            diag.span_label(*span, rustc_errors::fluent::passes::label_multiple_asm);\n+        }\n+        for span in self.non_asms.iter() {\n+            diag.span_label(*span, rustc_errors::fluent::passes::label_non_asm);\n+        }\n+        diag\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_operands, code = \"E0787\")]\n+pub struct NakedFunctionsOperands {\n+    #[primary_span]\n+    pub unsupported_operands: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_asm_options, code = \"E0787\")]\n+pub struct NakedFunctionsAsmOptions {\n+    #[primary_span]\n+    pub span: Span,\n+    pub unsupported_options: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(passes::naked_functions_must_use_noreturn, code = \"E0787\")]\n+pub struct NakedFunctionsMustUseNoreturn {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \", options(noreturn)\", applicability = \"machine-applicable\")]\n+    pub last_span: Span,\n+}"}, {"sha": "acc54e7e11006885c3eee899c05fba4a44252295", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 25, "deletions": 59, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/96f92eab683497a14079fd4da67642f1a4fc07e0/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96f92eab683497a14079fd4da67642f1a4fc07e0/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=96f92eab683497a14079fd4da67642f1a4fc07e0", "patch": "@@ -1,7 +1,6 @@\n //! Checks validity of naked functions.\n \n use rustc_ast::InlineAsmOptions;\n-use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -14,6 +13,12 @@ use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n+use crate::errors::{\n+    CannotInlineNakedFunction, NakedFunctionsAsmBlock, NakedFunctionsAsmOptions,\n+    NakedFunctionsMustUseNoreturn, NakedFunctionsOperands, NoPatterns, ParamsNotAllowed,\n+    UndefinedNakedFunctionAbi,\n+};\n+\n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n@@ -56,7 +61,7 @@ fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n fn check_inline(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let attrs = tcx.get_attrs(def_id.to_def_id(), sym::inline);\n     for attr in attrs {\n-        tcx.sess.struct_span_err(attr.span, \"naked functions cannot be inlined\").emit();\n+        tcx.sess.emit_err(CannotInlineNakedFunction { span: attr.span });\n     }\n }\n \n@@ -65,12 +70,11 @@ fn check_abi(tcx: TyCtxt<'_>, def_id: LocalDefId, abi: Abi) {\n     if abi == Abi::Rust {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let span = tcx.def_span(def_id);\n-        tcx.struct_span_lint_hir(\n+        tcx.emit_spanned_lint(\n             UNDEFINED_NAKED_FUNCTION_ABI,\n             hir_id,\n             span,\n-            \"Rust ABI is unsupported in naked functions\",\n-            |lint| lint,\n+            UndefinedNakedFunctionAbi,\n         );\n     }\n }\n@@ -82,12 +86,7 @@ fn check_no_patterns(tcx: TyCtxt<'_>, params: &[hir::Param<'_>]) {\n             hir::PatKind::Wild\n             | hir::PatKind::Binding(hir::BindingAnnotation::NONE, _, _, None) => {}\n             _ => {\n-                tcx.sess\n-                    .struct_span_err(\n-                        param.pat.span,\n-                        \"patterns not allowed in naked function parameters\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(NoPatterns { span: param.pat.span });\n             }\n         }\n     }\n@@ -117,14 +116,7 @@ impl<'tcx> Visitor<'tcx> for CheckParameters<'tcx> {\n         )) = expr.kind\n         {\n             if self.params.contains(var_hir_id) {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        expr.span,\n-                        \"referencing function parameters is not allowed in naked functions\",\n-                    )\n-                    .help(\"follow the calling convention in asm block to use parameters\")\n-                    .emit();\n+                self.tcx.sess.emit_err(ParamsNotAllowed { span: expr.span });\n                 return;\n             }\n         }\n@@ -139,26 +131,21 @@ fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<\n     if let [(ItemKind::Asm | ItemKind::Err, _)] = this.items[..] {\n         // Ok.\n     } else {\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            tcx.def_span(def_id),\n-            E0787,\n-            \"naked functions must contain a single asm block\"\n-        );\n-\n         let mut must_show_error = false;\n         let mut has_asm = false;\n         let mut has_err = false;\n+        let mut multiple_asms = vec![];\n+        let mut non_asms = vec![];\n         for &(kind, span) in &this.items {\n             match kind {\n                 ItemKind::Asm if has_asm => {\n                     must_show_error = true;\n-                    diag.span_label(span, \"multiple asm blocks are unsupported in naked functions\");\n+                    multiple_asms.push(span);\n                 }\n                 ItemKind::Asm => has_asm = true,\n                 ItemKind::NonAsm => {\n                     must_show_error = true;\n-                    diag.span_label(span, \"non-asm is unsupported in naked functions\");\n+                    non_asms.push(span);\n                 }\n                 ItemKind::Err => has_err = true,\n             }\n@@ -168,9 +155,11 @@ fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<\n         // errors, then don't show an additional error. This allows for appending/prepending\n         // `compile_error!(\"...\")` statements and reduces error noise.\n         if must_show_error || !has_err {\n-            diag.emit();\n-        } else {\n-            diag.cancel();\n+            tcx.sess.emit_err(NakedFunctionsAsmBlock {\n+                span: tcx.def_span(def_id),\n+                multiple_asms,\n+                non_asms,\n+            });\n         }\n     }\n }\n@@ -251,13 +240,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n             })\n             .collect();\n         if !unsupported_operands.is_empty() {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                unsupported_operands,\n-                E0787,\n-                \"only `const` and `sym` operands are supported in naked functions\",\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(NakedFunctionsOperands { unsupported_operands });\n         }\n \n         let unsupported_options: Vec<&'static str> = [\n@@ -273,14 +256,10 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n         .collect();\n \n         if !unsupported_options.is_empty() {\n-            struct_span_err!(\n-                self.tcx.sess,\n+            self.tcx.sess.emit_err(NakedFunctionsAsmOptions {\n                 span,\n-                E0787,\n-                \"asm options unsupported in naked functions: {}\",\n-                unsupported_options.join(\", \")\n-            )\n-            .emit();\n+                unsupported_options: unsupported_options.join(\", \"),\n+            });\n         }\n \n         if !asm.options.contains(InlineAsmOptions::NORETURN) {\n@@ -290,20 +269,7 @@ impl<'tcx> CheckInlineAssembly<'tcx> {\n                 .map_or_else(|| asm.template_strs.last().unwrap().2, |op| op.1)\n                 .shrink_to_hi();\n \n-            struct_span_err!(\n-                self.tcx.sess,\n-                span,\n-                E0787,\n-                \"asm in naked functions must use `noreturn` option\"\n-            )\n-            .span_suggestion(\n-                last_span,\n-                \"consider specifying that the asm block is responsible \\\n-                for returning from the function\",\n-                \", options(noreturn)\",\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n+            self.tcx.sess.emit_err(NakedFunctionsMustUseNoreturn { span, last_span });\n         }\n     }\n }"}]}