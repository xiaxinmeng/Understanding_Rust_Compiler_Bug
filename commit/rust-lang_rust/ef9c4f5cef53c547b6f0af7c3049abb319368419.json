{"sha": "ef9c4f5cef53c547b6f0af7c3049abb319368419", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOWM0ZjVjZWY1M2M1NDdiNmYwYWY3YzMwNDlhYmIzMTkzNjg0MTk=", "commit": {"author": {"name": "Philippe Nadon", "email": "phil@nadon.io", "date": "2020-07-22T15:08:59Z"}, "committer": {"name": "Philippe Nadon", "email": "phil@nadon.io", "date": "2020-07-25T17:04:55Z"}, "message": "Miri: rename \"undef\" to \"uninit\"\n\nrenamed Allocation::check_defined_and_ptr to Allocation::check_init_and_ptr\n\nrenamed Allocation::check_defined_and_ptr to Allocation::check_init_and_ptr\n\nin src/librustc_middle/mir/interpret/allocation.rs\n\nrenamed Allocation::is_defined and Allocation::check_defined, fixed documentation\n\nrenamed Allocation::is_defined and Allocation::check_defined to is_init and check_init respectively.\n\nFixed documentation so it correctly refers to \"initialization\" instead of \"defined\"-ness\n\nrenamed Allocation::mark_definedness\n\nrenamed Allocation::mark_definedness to Allocation::mark_init\n\nRenamed new_state parameter in Allocation::mark_init\n\nRenamed new_state to is_init, as the latter is more descriptive.\n\nrenamed functions in AllocationDefinedness\n\nrenamed AllocationDefinedness::all_bytes_undef and AllocationDefinedness::mark_compressed_undef_range to no_bytes_init and mark_compressed_init_range respectively.\n\nrenamed AllocationDefinedness to InitMaskCompressed\n\nrenamed Immediate::to_scalar_or_undef\n\nrenamed to to_scalar_or_uninit\n\nfixed comment references to \"undef\"\n\nChanged comments referring to \"undef\" and \"definedness\" to \"initialization\" and \"initialization state\" in src/librustc_mir/interpret/memory.rs and src/librustc_middle/mir/interpret/allocation.rs\n\nchanged references to \"undef\" in comments and a variable\n\nChanged some comments referring to \"undef\" to use \"uninitialized\" instead. Also changed a variable from \"undef_end\" to \"uninit_end\".\nAll changes were made within src/librustc_middle/mir/interpret/allocation.rs.\n\nChanged more comments referring to undef\n\nChanged comments to use \"uninitialized\" instead of \"undef\" in src/librustc_middle/mir/interpret/allocation.rs.", "tree": {"sha": "e5e97dfd0999090f15326852406cd9b9d0c2a799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5e97dfd0999090f15326852406cd9b9d0c2a799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef9c4f5cef53c547b6f0af7c3049abb319368419", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9c4f5cef53c547b6f0af7c3049abb319368419", "html_url": "https://github.com/rust-lang/rust/commit/ef9c4f5cef53c547b6f0af7c3049abb319368419", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef9c4f5cef53c547b6f0af7c3049abb319368419/comments", "author": {"login": "pnadon", "id": 12490688, "node_id": "MDQ6VXNlcjEyNDkwNjg4", "avatar_url": "https://avatars.githubusercontent.com/u/12490688?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnadon", "html_url": "https://github.com/pnadon", "followers_url": "https://api.github.com/users/pnadon/followers", "following_url": "https://api.github.com/users/pnadon/following{/other_user}", "gists_url": "https://api.github.com/users/pnadon/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnadon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnadon/subscriptions", "organizations_url": "https://api.github.com/users/pnadon/orgs", "repos_url": "https://api.github.com/users/pnadon/repos", "events_url": "https://api.github.com/users/pnadon/events{/privacy}", "received_events_url": "https://api.github.com/users/pnadon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnadon", "id": 12490688, "node_id": "MDQ6VXNlcjEyNDkwNjg4", "avatar_url": "https://avatars.githubusercontent.com/u/12490688?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnadon", "html_url": "https://github.com/pnadon", "followers_url": "https://api.github.com/users/pnadon/followers", "following_url": "https://api.github.com/users/pnadon/following{/other_user}", "gists_url": "https://api.github.com/users/pnadon/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnadon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnadon/subscriptions", "organizations_url": "https://api.github.com/users/pnadon/orgs", "repos_url": "https://api.github.com/users/pnadon/repos", "events_url": "https://api.github.com/users/pnadon/events{/privacy}", "received_events_url": "https://api.github.com/users/pnadon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55984b65ce7aad961236410bd8ad465424fe506b", "url": "https://api.github.com/repos/rust-lang/rust/commits/55984b65ce7aad961236410bd8ad465424fe506b", "html_url": "https://github.com/rust-lang/rust/commit/55984b65ce7aad961236410bd8ad465424fe506b"}], "stats": {"total": 118, "additions": 59, "deletions": 59}, "files": [{"sha": "dd4fc7adff11785a5edc1246c41da16ddf14179b", "filename": "src/librustc_middle/mir/interpret/allocation.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/ef9c4f5cef53c547b6f0af7c3049abb319368419/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9c4f5cef53c547b6f0af7c3049abb319368419/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fallocation.rs?ref=ef9c4f5cef53c547b6f0af7c3049abb319368419", "patch": "@@ -105,7 +105,7 @@ impl<Tag> Allocation<Tag> {\n         Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n     }\n \n-    pub fn undef(size: Size, align: Align) -> Self {\n+    pub fn uninit(size: Size, align: Align) -> Self {\n         Allocation {\n             bytes: vec![0; size.bytes_usize()],\n             relocations: Relocations::new(),\n@@ -153,7 +153,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         self.size.bytes_usize()\n     }\n \n-    /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// Looks at a slice which may describe uninitialized bytes or describe a relocation. This differs\n     /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n     /// edges) at all. It further ignores `AllocationExtra` callbacks.\n     /// This must not be used for reads affecting the interpreter execution.\n@@ -192,7 +192,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         offset.bytes_usize()..end\n     }\n \n-    /// The last argument controls whether we error out when there are undefined\n+    /// The last argument controls whether we error out when there are uninitialized\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n@@ -206,12 +206,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        check_defined_and_ptr: bool,\n+        check_init_and_ptr: bool,\n     ) -> InterpResult<'tcx, &[u8]> {\n         let range = self.check_bounds(ptr.offset, size);\n \n-        if check_defined_and_ptr {\n-            self.check_defined(ptr, size)?;\n+        if check_init_and_ptr {\n+            self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n             // We still don't want relocations on the *edges*.\n@@ -239,7 +239,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n-    /// It is the caller's responsibility to handle undefined and pointer bytes.\n+    /// It is the caller's responsibility to handle uninitialized and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -267,7 +267,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ) -> InterpResult<'tcx, &mut [u8]> {\n         let range = self.check_bounds(ptr.offset, size);\n \n-        self.mark_definedness(ptr, size, true);\n+        self.mark_init(ptr, size, true);\n         self.clear_relocations(cx, ptr, size)?;\n \n         AllocationExtra::memory_written(self, ptr, size)?;\n@@ -303,7 +303,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n \n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n-    /// given range contains neither relocations nor undef bytes.\n+    /// given range contains neither relocations nor uninitialized bytes.\n     pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n@@ -313,9 +313,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ) -> InterpResult<'tcx> {\n         // Check bounds and relocations on the edges.\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n-        // Check undef and ptr.\n+        // Check uninit and ptr.\n         if !allow_ptr_and_undef {\n-            self.check_defined(ptr, size)?;\n+            self.check_init(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         }\n         Ok(())\n@@ -364,7 +364,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Uninit check happens *after* we established that the alignment is correct.\n         // We must not return `Ok()` for unaligned pointers!\n-        if self.is_defined(ptr, size).is_err() {\n+        if self.is_init(ptr, size).is_err() {\n             // This inflates uninitialized bytes to the entire scalar, even if only a few\n             // bytes are uninitialized.\n             return Ok(ScalarMaybeUninit::Uninit);\n@@ -416,7 +416,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let val = match val {\n             ScalarMaybeUninit::Scalar(scalar) => scalar,\n             ScalarMaybeUninit::Uninit => {\n-                self.mark_definedness(ptr, type_size, false);\n+                self.mark_init(ptr, type_size, false);\n                 return Ok(());\n             }\n         };\n@@ -512,7 +512,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         let start = ptr.offset;\n         let end = start + size; // `Size` addition\n \n-        // Mark parts of the outermost relocations as undefined if they partially fall outside the\n+        // Mark parts of the outermost relocations as uninitialized if they partially fall outside the\n         // given range.\n         if first < start {\n             self.init_mask.set_range(first, start, false);\n@@ -542,20 +542,20 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Undefined bytes.\n+/// Uninitialized bytes.\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Checks whether the given range  is entirely defined.\n+    /// Checks whether the given range  is entirely initialized.\n     ///\n-    /// Returns `Ok(())` if it's defined. Otherwise returns the range of byte\n-    /// indexes of the first contiguous undefined access.\n-    fn is_defined(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n+    /// Returns `Ok(())` if it's initialized. Otherwise returns the range of byte\n+    /// indexes of the first contiguous uninitialized access.\n+    fn is_init(&self, ptr: Pointer<Tag>, size: Size) -> Result<(), Range<Size>> {\n         self.init_mask.is_range_initialized(ptr.offset, ptr.offset + size) // `Size` addition\n     }\n \n-    /// Checks that a range of bytes is defined. If not, returns the `InvalidUndefBytes`\n-    /// error which will report the first range of bytes which is undefined.\n-    fn check_defined(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n-        self.is_defined(ptr, size).or_else(|idx_range| {\n+    /// Checks that a range of bytes is initialized. If not, returns the `InvalidUninitBytes`\n+    /// error which will report the first range of bytes which is uninitialized.\n+    fn check_init(&self, ptr: Pointer<Tag>, size: Size) -> InterpResult<'tcx> {\n+        self.is_init(ptr, size).or_else(|idx_range| {\n             throw_ub!(InvalidUninitBytes(Some(Box::new(UninitBytesAccess {\n                 access_ptr: ptr.erase_tag(),\n                 access_size: size,\n@@ -565,44 +565,44 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         })\n     }\n \n-    pub fn mark_definedness(&mut self, ptr: Pointer<Tag>, size: Size, new_state: bool) {\n+    pub fn mark_init(&mut self, ptr: Pointer<Tag>, size: Size, is_init: bool) {\n         if size.bytes() == 0 {\n             return;\n         }\n-        self.init_mask.set_range(ptr.offset, ptr.offset + size, new_state);\n+        self.init_mask.set_range(ptr.offset, ptr.offset + size, is_init);\n     }\n }\n \n-/// Run-length encoding of the undef mask.\n+/// Run-length encoding of the uninit mask.\n /// Used to copy parts of a mask multiple times to another allocation.\n-pub struct AllocationDefinedness {\n-    /// The definedness of the first range.\n+pub struct InitMaskCompressed {\n+    /// Whether the first range is initialized.\n     initial: bool,\n     /// The lengths of ranges that are run-length encoded.\n-    /// The definedness of the ranges alternate starting with `initial`.\n+    /// The initialization state of the ranges alternate starting with `initial`.\n     ranges: smallvec::SmallVec<[u64; 1]>,\n }\n \n-impl AllocationDefinedness {\n-    pub fn all_bytes_undef(&self) -> bool {\n-        // The `ranges` are run-length encoded and of alternating definedness.\n-        // So if `ranges.len() > 1` then the second block is a range of defined.\n+impl InitMaskCompressed {\n+    pub fn no_bytes_init(&self) -> bool {\n+        // The `ranges` are run-length encoded and of alternating initialization state.\n+        // So if `ranges.len() > 1` then the second block is an initialized range.\n         !self.initial && self.ranges.len() == 1\n     }\n }\n \n-/// Transferring the definedness mask to other allocations.\n+/// Transferring the initialization mask to other allocations.\n impl<Tag, Extra> Allocation<Tag, Extra> {\n-    /// Creates a run-length encoding of the undef mask.\n-    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> AllocationDefinedness {\n+    /// Creates a run-length encoding of the initialization mask.\n+    pub fn compress_undef_range(&self, src: Pointer<Tag>, size: Size) -> InitMaskCompressed {\n         // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n-        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // a naive initialization mask copying algorithm would repeatedly have to read the initialization mask from\n         // the source and write it to the destination. Even if we optimized the memory accesses,\n         // we'd be doing all of this `repeat` times.\n-        // Therefore we precompute a compressed version of the undef mask of the source value and\n+        // Therefore we precompute a compressed version of the initialization mask of the source value and\n         // then write it back `repeat` times without computing any more information from the source.\n \n-        // A precomputed cache for ranges of defined/undefined bits\n+        // A precomputed cache for ranges of initialized / uninitialized bits\n         // 0000010010001110 will become\n         // `[5, 1, 2, 1, 3, 3, 1]`,\n         // where each element toggles the state.\n@@ -613,7 +613,7 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n         let mut cur = initial;\n \n         for i in 1..size.bytes() {\n-            // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n+            // FIXME: optimize to bitshift the current uninitialized block's bits and read the top bit.\n             if self.init_mask.get(src.offset + Size::from_bytes(i)) == cur {\n                 cur_len += 1;\n             } else {\n@@ -625,13 +625,13 @@ impl<Tag, Extra> Allocation<Tag, Extra> {\n \n         ranges.push(cur_len);\n \n-        AllocationDefinedness { ranges, initial }\n+        InitMaskCompressed { ranges, initial }\n     }\n \n-    /// Applies multiple instances of the run-length encoding to the undef mask.\n-    pub fn mark_compressed_undef_range(\n+    /// Applies multiple instances of the run-length encoding to the initialization mask.\n+    pub fn mark_compressed_init_range(\n         &mut self,\n-        defined: &AllocationDefinedness,\n+        defined: &InitMaskCompressed,\n         dest: Pointer<Tag>,\n         size: Size,\n         repeat: u64,\n@@ -740,7 +740,7 @@ impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n-// Undefined byte tracking\n+// Uninitialized byte tracking\n ////////////////////////////////////////////////////////////////////////////////\n \n type Block = u64;\n@@ -778,11 +778,11 @@ impl InitMask {\n \n         match idx {\n             Some(idx) => {\n-                let undef_end = (idx.bytes()..end.bytes())\n+                let uninit_end = (idx.bytes()..end.bytes())\n                     .map(Size::from_bytes)\n                     .find(|&i| self.get(i))\n                     .unwrap_or(end);\n-                Err(idx..undef_end)\n+                Err(idx..uninit_end)\n             }\n             None => Ok(()),\n         }"}, {"sha": "8485a6c5df8459f3a4a2e38c891fc159c74b58b4", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef9c4f5cef53c547b6f0af7c3049abb319368419/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9c4f5cef53c547b6f0af7c3049abb319368419/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ef9c4f5cef53c547b6f0af7c3049abb319368419", "patch": "@@ -171,7 +171,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> Pointer<M::PointerTag> {\n-        let alloc = Allocation::undef(size, align);\n+        let alloc = Allocation::uninit(size, align);\n         self.allocate_with(alloc, kind)\n     }\n \n@@ -904,18 +904,18 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         let dest_bytes = dest_bytes.as_mut_ptr();\n \n-        // Prepare a copy of the undef mask.\n+        // Prepare a copy of the initialization mask.\n         let compressed = self.get_raw(src.alloc_id)?.compress_undef_range(src, size);\n \n-        if compressed.all_bytes_undef() {\n-            // Fast path: If all bytes are `undef` then there is nothing to copy. The target range\n-            // is marked as undef but we otherwise omit changing the byte representation which may\n-            // be arbitrary for undef bytes.\n+        if compressed.no_bytes_init() {\n+            // Fast path: If all bytes are `uninit` then there is nothing to copy. The target range\n+            // is marked as unititialized but we otherwise omit changing the byte representation which may\n+            // be arbitrary for uninitialized bytes.\n             // This also avoids writing to the target bytes so that the backing allocation is never\n-            // touched if the bytes stay undef for the whole interpreter execution. On contemporary\n+            // touched if the bytes stay uninitialized for the whole interpreter execution. On contemporary\n             // operating system this can avoid physically allocating the page.\n             let dest_alloc = self.get_raw_mut(dest.alloc_id)?;\n-            dest_alloc.mark_definedness(dest, size * length, false); // `Size` multiplication\n+            dest_alloc.mark_init(dest, size * length, false); // `Size` multiplication\n             dest_alloc.mark_relocation_range(relocations);\n             return Ok(());\n         }\n@@ -955,7 +955,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n \n         // now fill in all the data\n-        self.get_raw_mut(dest.alloc_id)?.mark_compressed_undef_range(\n+        self.get_raw_mut(dest.alloc_id)?.mark_compressed_init_range(\n             &compressed,\n             dest,\n             size,"}, {"sha": "9f86f2bc588fc86b07fda021af3b9f3b7e48f5ae", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef9c4f5cef53c547b6f0af7c3049abb319368419/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef9c4f5cef53c547b6f0af7c3049abb319368419/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ef9c4f5cef53c547b6f0af7c3049abb319368419", "patch": "@@ -63,7 +63,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_scalar_or_undef(self) -> ScalarMaybeUninit<Tag> {\n+    pub fn to_scalar_or_uninit(self) -> ScalarMaybeUninit<Tag> {\n         match self {\n             Immediate::Scalar(val) => val,\n             Immediate::ScalarPair(..) => bug!(\"Got a wide pointer where a scalar was expected\"),\n@@ -72,7 +72,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n \n     #[inline]\n     pub fn to_scalar(self) -> InterpResult<'tcx, Scalar<Tag>> {\n-        self.to_scalar_or_undef().check_init()\n+        self.to_scalar_or_uninit().check_init()\n     }\n \n     #[inline]\n@@ -333,7 +333,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: OpTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, ScalarMaybeUninit<M::PointerTag>> {\n-        Ok(self.read_immediate(op)?.to_scalar_or_undef())\n+        Ok(self.read_immediate(op)?.to_scalar_or_uninit())\n     }\n \n     // Turn the wide MPlace into a string (must already be dereferenced!)"}]}