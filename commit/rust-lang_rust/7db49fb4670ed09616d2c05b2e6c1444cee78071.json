{"sha": "7db49fb4670ed09616d2c05b2e6c1444cee78071", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkYjQ5ZmI0NjcwZWQwOTYxNmQyYzA1YjJlNmMxNDQ0Y2VlNzgwNzE=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-05T17:14:54Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:23:58Z"}, "message": "Move cargo() to Builder", "tree": {"sha": "f16ee1dc377ff9f63a627198e90d197a191cf018", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f16ee1dc377ff9f63a627198e90d197a191cf018"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7db49fb4670ed09616d2c05b2e6c1444cee78071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7db49fb4670ed09616d2c05b2e6c1444cee78071", "html_url": "https://github.com/rust-lang/rust/commit/7db49fb4670ed09616d2c05b2e6c1444cee78071", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7db49fb4670ed09616d2c05b2e6c1444cee78071/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "276090e870a6a1685701bc91425ffb44439385fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/276090e870a6a1685701bc91425ffb44439385fd", "html_url": "https://github.com/rust-lang/rust/commit/276090e870a6a1685701bc91425ffb44439385fd"}], "stats": {"total": 267, "additions": 43, "deletions": 224}, "files": [{"sha": "ae614e75632b525d7f28dd4c49512993351efb4d", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7db49fb4670ed09616d2c05b2e6c1444cee78071/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db49fb4670ed09616d2c05b2e6c1444cee78071/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=7db49fb4670ed09616d2c05b2e6c1444cee78071", "patch": "@@ -261,68 +261,61 @@ impl<'a> Builder<'a> {\n     /// rustc compiler, its output will be scoped by `mode`'s output directory,\n     /// it will pass the `--target` flag for the specified `target`, and will be\n     /// executing the Cargo command `cmd`.\n-    pub fn cargo(&self, compiler: Compiler, mode: Mode, target: &str, cmd: &str) -> Command {\n-        let build = self.build;\n-\n-        // Clear out the output we're about to generate if our compiler changed\n-        {\n-            let out_dir = build.cargo_out(compiler, mode, target);\n-            build.clear_if_dirty(&out_dir, &self.rustc(compiler));\n-        }\n-\n-        let mut cargo = Command::new(&build.initial_cargo);\n-        let out_dir = build.stage_out(compiler, mode);\n-\n+    fn cargo(&self,\n+             compiler: Compiler,\n+             mode: Mode,\n+             target: &str,\n+             cmd: &str) -> Command {\n+        let mut cargo = Command::new(&self.initial_cargo);\n+        let out_dir = self.stage_out(compiler, mode);\n         cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n              .arg(cmd)\n-             .arg(\"-j\").arg(build.jobs().to_string())\n+             .arg(\"-j\").arg(self.jobs().to_string())\n              .arg(\"--target\").arg(target);\n \n         // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n         // Force cargo to output binaries with disambiguating hashes in the name\n-        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &self.build.config.channel);\n+        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &self.config.channel);\n \n         let stage;\n-        if compiler.stage == 0 && build.local_rebuild {\n+        if compiler.stage == 0 && self.local_rebuild {\n             // Assume the local-rebuild rustc already has stage1 features.\n             stage = 1;\n         } else {\n             stage = compiler.stage;\n         }\n \n-        self.build.verbose(&format!(\"cargo using: {:?}\", self.rustc(compiler)));\n-\n         // Customize the compiler we're running. Specify the compiler to cargo\n         // as our shim and then pass it some various options used to configure\n-        // how the actual compiler itbuild is called.\n+        // how the actual compiler itself is called.\n         //\n         // These variables are primarily all read by\n         // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTBUILD_NATIVE_DIR\", build.native_dir(target))\n-             .env(\"RUSTC\", build.out.join(\"bootstrap/debug/rustc\"))\n-             .env(\"RUSTC_REAL\", self.rustc(compiler))\n+        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n+             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n+             .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n              .env(\"RUSTC_CODEGEN_UNITS\",\n-                  build.config.rust_codegen_units.to_string())\n+                  self.config.rust_codegen_units.to_string())\n              .env(\"RUSTC_DEBUG_ASSERTIONS\",\n-                  build.config.rust_debug_assertions.to_string())\n+                  self.config.rust_debug_assertions.to_string())\n              .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n              .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n-             .env(\"RUSTC_RPATH\", build.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", build.out.join(\"bootstrap/debug/rustdoc\"))\n+             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n+             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n              .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n-             .env(\"RUSTC_FLAGS\", build.rustc_flags(target).join(\" \"));\n+             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n \n         if mode != Mode::Tool {\n             // Tools don't get debuginfo right now, e.g. cargo and rls don't\n             // get compiled with debuginfo.\n-            cargo.env(\"RUSTC_DEBUGINFO\", build.config.rust_debuginfo.to_string())\n-                 .env(\"RUSTC_DEBUGINFO_LINES\", build.config.rust_debuginfo_lines.to_string())\n+            cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n+                 .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string())\n                  .env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n             // then other crates can depend on the compiler (e.g. proc-macro\n-            // crates). Let's say, for example that rustc itbuild depends on the\n+            // crates). Let's say, for example that rustc itself depends on the\n             // bitflags crate. If an external crate then depends on the\n             // bitflags crate as well, we need to make sure they don't\n             // conflict, even if they pick the same verison of bitflags. We'll\n@@ -341,58 +334,58 @@ impl<'a> Builder<'a> {\n \n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        build.add_rust_test_threads(&mut cargo);\n+        self.add_rust_test_threads(&mut cargo);\n \n         // Almost all of the crates that we compile as part of the bootstrap may\n         // have a build script, including the standard library. To compile a\n-        // build script, however, it itbuild needs a standard library! This\n+        // build script, however, it itself needs a standard library! This\n         // introduces a bit of a pickle when we're compiling the standard\n-        // library itbuild.\n+        // library itself.\n         //\n         // To work around this we actually end up using the snapshot compiler\n-        // (stage0) for compiling build scripts of the standard library itbuild.\n+        // (stage0) for compiling build scripts of the standard library itself.\n         // The stage0 compiler is guaranteed to have a libstd available for use.\n         //\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n         if mode == Mode::Libstd {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &build.initial_rustc)\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", build.rustc_snapshot_libdir());\n+            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n+                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n         } else {\n-            cargo.env(\"RUSTC_SNAPSHOT\", self.rustc(compiler))\n+            cargo.env(\"RUSTC_SNAPSHOT\", self.compiler_path(compiler))\n                  .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n         // Ignore incremental modes except for stage0, since we're\n         // not guaranteeing correctness across builds if the compiler\n         // is changing under your feet.`\n-        if build.flags.incremental && compiler.stage == 0 {\n-            let incr_dir = build.incremental_dir(compiler);\n+        if self.flags.incremental && compiler.stage == 0 {\n+            let incr_dir = self.incremental_dir(compiler);\n             cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n         }\n \n-        if let Some(ref on_fail) = build.flags.on_fail {\n+        if let Some(ref on_fail) = self.flags.on_fail {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n \n-        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", build.verbosity));\n+        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n         //\n         // FIXME: the guard against msvc shouldn't need to be here\n         if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), build.cc(target))\n-                 .env(format!(\"AR_{}\", target), build.ar(target).unwrap()) // only msvc is None\n-                 .env(format!(\"CFLAGS_{}\", target), build.cflags(target).join(\" \"));\n+            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n+                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n+                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n \n-            if let Ok(cxx) = build.cxx(target) {\n+            if let Ok(cxx) = self.cxx(target) {\n                  cargo.env(format!(\"CXX_{}\", target), cxx);\n             }\n         }\n \n-        if build.config.extended && compiler.is_final_stage(self) {\n+        if mode == Mode::Libstd && self.config.extended && compiler.is_final_stage(self) {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n \n@@ -414,21 +407,21 @@ impl<'a> Builder<'a> {\n         // FIXME: should update code to not require this env var\n         cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n \n-        if build.is_verbose() {\n+        if self.is_verbose() {\n             cargo.arg(\"-v\");\n         }\n         // FIXME: cargo bench does not accept `--release`\n-        if build.config.rust_optimize && cmd != \"bench\" {\n+        if self.config.rust_optimize && cmd != \"bench\" {\n             cargo.arg(\"--release\");\n         }\n-        if build.config.locked_deps {\n+        if self.config.locked_deps {\n             cargo.arg(\"--locked\");\n         }\n-        if build.config.vendor || build.is_sudo {\n+        if self.config.vendor || self.is_sudo {\n             cargo.arg(\"--frozen\");\n         }\n \n-        build.ci_env.force_coloring_in_ci(&mut cargo);\n+        self.ci_env.force_coloring_in_ci(&mut cargo);\n \n         cargo\n     }"}, {"sha": "58a5316ea0a66fc4e279cb8067baabaf06d33668", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/7db49fb4670ed09616d2c05b2e6c1444cee78071/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7db49fb4670ed09616d2c05b2e6c1444cee78071/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7db49fb4670ed09616d2c05b2e6c1444cee78071", "patch": "@@ -352,180 +352,6 @@ impl Build {\n         t!(File::create(stamp));\n     }\n \n-    /// Prepares an invocation of `cargo` to be run.\n-    ///\n-    /// This will create a `Command` that represents a pending execution of\n-    /// Cargo. This cargo will be configured to use `compiler` as the actual\n-    /// rustc compiler, its output will be scoped by `mode`'s output directory,\n-    /// it will pass the `--target` flag for the specified `target`, and will be\n-    /// executing the Cargo command `cmd`.\n-    fn cargo(&self,\n-             compiler: Compiler,\n-             mode: Mode,\n-             target: &str,\n-             cmd: &str) -> Command {\n-        let mut cargo = Command::new(&self.initial_cargo);\n-        let out_dir = self.stage_out(compiler, mode);\n-        cargo.env(\"CARGO_TARGET_DIR\", out_dir)\n-             .arg(cmd)\n-             .arg(\"-j\").arg(self.jobs().to_string())\n-             .arg(\"--target\").arg(target);\n-\n-        // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n-        // Force cargo to output binaries with disambiguating hashes in the name\n-        cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &self.config.channel);\n-\n-        let stage;\n-        if compiler.stage == 0 && self.local_rebuild {\n-            // Assume the local-rebuild rustc already has stage1 features.\n-            stage = 1;\n-        } else {\n-            stage = compiler.stage;\n-        }\n-\n-        // Customize the compiler we're running. Specify the compiler to cargo\n-        // as our shim and then pass it some various options used to configure\n-        // how the actual compiler itself is called.\n-        //\n-        // These variables are primarily all read by\n-        // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n-        cargo.env(\"RUSTBUILD_NATIVE_DIR\", self.native_dir(target))\n-             .env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n-             .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n-             .env(\"RUSTC_STAGE\", stage.to_string())\n-             .env(\"RUSTC_CODEGEN_UNITS\",\n-                  self.config.rust_codegen_units.to_string())\n-             .env(\"RUSTC_DEBUG_ASSERTIONS\",\n-                  self.config.rust_debug_assertions.to_string())\n-             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n-             .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n-             .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n-             .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n-             .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n-             .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n-\n-        if mode != Mode::Tool {\n-            // Tools don't get debuginfo right now, e.g. cargo and rls don't\n-            // get compiled with debuginfo.\n-            cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string())\n-                 .env(\"RUSTC_DEBUGINFO_LINES\", self.config.rust_debuginfo_lines.to_string())\n-                 .env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n-\n-            // Currently the compiler depends on crates from crates.io, and\n-            // then other crates can depend on the compiler (e.g. proc-macro\n-            // crates). Let's say, for example that rustc itself depends on the\n-            // bitflags crate. If an external crate then depends on the\n-            // bitflags crate as well, we need to make sure they don't\n-            // conflict, even if they pick the same verison of bitflags. We'll\n-            // want to make sure that e.g. a plugin and rustc each get their\n-            // own copy of bitflags.\n-\n-            // Cargo ensures that this works in general through the -C metadata\n-            // flag. This flag will frob the symbols in the binary to make sure\n-            // they're different, even though the source code is the exact\n-            // same. To solve this problem for the compiler we extend Cargo's\n-            // already-passed -C metadata flag with our own. Our rustc.rs\n-            // wrapper around the actual rustc will detect -C metadata being\n-            // passed and frob it with this extra string we're passing in.\n-            cargo.env(\"RUSTC_METADATA_SUFFIX\", \"rustc\");\n-        }\n-\n-        // Enable usage of unstable features\n-        cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        self.add_rust_test_threads(&mut cargo);\n-\n-        // Almost all of the crates that we compile as part of the bootstrap may\n-        // have a build script, including the standard library. To compile a\n-        // build script, however, it itself needs a standard library! This\n-        // introduces a bit of a pickle when we're compiling the standard\n-        // library itself.\n-        //\n-        // To work around this we actually end up using the snapshot compiler\n-        // (stage0) for compiling build scripts of the standard library itself.\n-        // The stage0 compiler is guaranteed to have a libstd available for use.\n-        //\n-        // For other crates, however, we know that we've already got a standard\n-        // library up and running, so we can use the normal compiler to compile\n-        // build scripts in that situation.\n-        if mode == Mode::Libstd {\n-            cargo.env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n-        } else {\n-            cargo.env(\"RUSTC_SNAPSHOT\", self.compiler_path(compiler))\n-                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_libdir(compiler));\n-        }\n-\n-        // Ignore incremental modes except for stage0, since we're\n-        // not guaranteeing correctness across builds if the compiler\n-        // is changing under your feet.`\n-        if self.flags.incremental && compiler.stage == 0 {\n-            let incr_dir = self.incremental_dir(compiler);\n-            cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n-        }\n-\n-        if let Some(ref on_fail) = self.flags.on_fail {\n-            cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n-        }\n-\n-        cargo.env(\"RUSTC_VERBOSE\", format!(\"{}\", self.verbosity));\n-\n-        // Specify some various options for build scripts used throughout\n-        // the build.\n-        //\n-        // FIXME: the guard against msvc shouldn't need to be here\n-        if !target.contains(\"msvc\") {\n-            cargo.env(format!(\"CC_{}\", target), self.cc(target))\n-                 .env(format!(\"AR_{}\", target), self.ar(target).unwrap()) // only msvc is None\n-                 .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n-\n-            if let Ok(cxx) = self.cxx(target) {\n-                 cargo.env(format!(\"CXX_{}\", target), cxx);\n-            }\n-        }\n-\n-        if mode == Mode::Libstd &&\n-           self.config.extended &&\n-           compiler.is_final_stage(self) {\n-            cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n-        }\n-\n-        // When being built Cargo will at some point call `nmake.exe` on Windows\n-        // MSVC. Unfortunately `nmake` will read these two environment variables\n-        // below and try to intepret them. We're likely being run, however, from\n-        // MSYS `make` which uses the same variables.\n-        //\n-        // As a result, to prevent confusion and errors, we remove these\n-        // variables from our environment to prevent passing MSYS make flags to\n-        // nmake, causing it to blow up.\n-        if cfg!(target_env = \"msvc\") {\n-            cargo.env_remove(\"MAKE\");\n-            cargo.env_remove(\"MAKEFLAGS\");\n-        }\n-\n-        // Environment variables *required* throughout the build\n-        //\n-        // FIXME: should update code to not require this env var\n-        cargo.env(\"CFG_COMPILER_HOST_TRIPLE\", target);\n-\n-        if self.is_verbose() {\n-            cargo.arg(\"-v\");\n-        }\n-        // FIXME: cargo bench does not accept `--release`\n-        if self.config.rust_optimize && cmd != \"bench\" {\n-            cargo.arg(\"--release\");\n-        }\n-        if self.config.locked_deps {\n-            cargo.arg(\"--locked\");\n-        }\n-        if self.config.vendor || self.is_sudo {\n-            cargo.arg(\"--frozen\");\n-        }\n-\n-        self.ci_env.force_coloring_in_ci(&mut cargo);\n-\n-        cargo\n-    }\n-\n     /// Get a path to the compiler specified.\n     fn compiler_path(&self, compiler: Compiler) -> PathBuf {\n         if compiler.is_snapshot(self) {"}]}