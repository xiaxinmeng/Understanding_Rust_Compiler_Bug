{"sha": "216f5fba043ff787ba2dd6bbf01e0e077304adf0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNmY1ZmJhMDQzZmY3ODdiYTJkZDZiYmYwMWUwZTA3NzMwNGFkZjA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-03-06T12:54:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2016-05-27T21:54:29Z"}, "message": "Separate bindings from other patterns in HIR", "tree": {"sha": "9b24ca0a92fe4d0629afe3059424b0544b1dfddb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b24ca0a92fe4d0629afe3059424b0544b1dfddb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/216f5fba043ff787ba2dd6bbf01e0e077304adf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/216f5fba043ff787ba2dd6bbf01e0e077304adf0", "html_url": "https://github.com/rust-lang/rust/commit/216f5fba043ff787ba2dd6bbf01e0e077304adf0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/216f5fba043ff787ba2dd6bbf01e0e077304adf0/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab7c35fa0fcd725cdc207487b760d85fd07ecdd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7c35fa0fcd725cdc207487b760d85fd07ecdd7", "html_url": "https://github.com/rust-lang/rust/commit/ab7c35fa0fcd725cdc207487b760d85fd07ecdd7"}], "stats": {"total": 544, "additions": 237, "deletions": 307}, "files": [{"sha": "61c0f1c1c6498c21dc92e49577e9d7e3c054ff93", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n-            PatKind::Ident(_, _, None) |\n+            PatKind::Binding(_, _, None) |\n             PatKind::Path(..) |\n             PatKind::QPath(..) |\n             PatKind::Lit(..) |\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             PatKind::Box(ref subpat) |\n             PatKind::Ref(ref subpat, _) |\n-            PatKind::Ident(_, _, Some(ref subpat)) => {\n+            PatKind::Binding(_, _, Some(ref subpat)) => {\n                 let subpat_exit = self.pat(&subpat, pred);\n                 self.add_ast_node(pat.id, &[subpat_exit])\n             }"}, {"sha": "1e80bc3c54dd023767d9990a0b46afa26afd5dbc", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -914,8 +914,8 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n             id: folder.new_id(id),\n             node: match node {\n                 PatKind::Wild => PatKind::Wild,\n-                PatKind::Ident(binding_mode, pth1, sub) => {\n-                    PatKind::Ident(binding_mode,\n+                PatKind::Binding(binding_mode, pth1, sub) => {\n+                    PatKind::Binding(binding_mode,\n                              Spanned {\n                                  span: folder.new_span(pth1.span),\n                                  node: folder.fold_name(pth1.node),"}, {"sha": "4593f19daadb9afc3901fb65f3bbc8ecfd349af6", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -485,7 +485,7 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Ident(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Binding(_, ref pth1, ref optional_subpattern) => {\n             visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }"}, {"sha": "90dd2dad7203d3e1d7556e17bf9e8ea75010cb28", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -866,14 +866,16 @@ impl<'a> LoweringContext<'a> {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n                     self.with_parent_def(p.id, |this| {\n-                        let name = match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n-                            // Only pattern bindings are renamed\n-                            None | Some(Def::Local(..)) => this.lower_ident(pth1.node),\n-                            _ => pth1.node.name,\n-                        };\n-                        hir::PatKind::Ident(this.lower_binding_mode(binding_mode),\n-                                            respan(pth1.span, name),\n-                                            sub.as_ref().map(|x| this.lower_pat(x)))\n+                        match this.resolver.get_resolution(p.id).map(|d| d.full_def()) {\n+                            // `None` can occur in body-less function signatures\n+                            None | Some(Def::Local(..)) => {\n+                                hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n+                                                      respan(pth1.span,\n+                                                             this.lower_ident(pth1.node)),\n+                                                      sub.as_ref().map(|x| this.lower_pat(x)))\n+                            }\n+                            _ => hir::PatKind::Path(hir::Path::from_name(pth1.span, pth1.node.name))\n+                        }\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n@@ -1868,7 +1870,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n-        let pat_ident = hir::PatKind::Ident(bm,\n+        let pat_ident = hir::PatKind::Binding(bm,\n                                             Spanned {\n                                                 span: span,\n                                                 node: name,"}, {"sha": "692f56bde28f5e5481aec88a20b103dd27aa4e32", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -165,7 +165,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     }\n \n     fn visit_pat(&mut self, pat: &'ast Pat) {\n-        let node = if let PatKind::Ident(..) = pat.node {\n+        let node = if let PatKind::Binding(..) = pat.node {\n             NodeLocal(pat)\n         } else {\n             NodePat(pat)"}, {"sha": "e3b6539b8ccab2f80e3de32a8d9f5627ba4fc62b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -396,7 +396,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n         let parent_def = self.parent_def;\n \n-        if let hir::PatKind::Ident(_, name, _) = pat.node {\n+        if let hir::PatKind::Binding(_, name, _) = pat.node {\n             let def = self.create_def(pat.id, DefPathData::Binding(name.node));\n             self.parent_def = Some(def);\n         }"}, {"sha": "41b72e569f475aae749be162c5b940b3d5e0b2d4", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -561,7 +561,7 @@ impl<'ast> Map<'ast> {\n             NodeVariant(v) => v.node.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Ident(_,l,_), .. }) => l.node,\n+            NodeLocal(&Pat { node: PatKind::Binding(_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }"}, {"sha": "0e89dde70ee77d8f6259d7bfa78f23d789983587", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -466,7 +466,7 @@ impl Pat {\n         }\n \n         match self.node {\n-            PatKind::Ident(_, _, Some(ref p)) => p.walk_(it),\n+            PatKind::Binding(_, _, Some(ref p)) => p.walk_(it),\n             PatKind::Struct(_, ref fields, _) => {\n                 fields.iter().all(|field| field.node.pat.walk_(it))\n             }\n@@ -484,7 +484,7 @@ impl Pat {\n             PatKind::Wild |\n             PatKind::Lit(_) |\n             PatKind::Range(_, _) |\n-            PatKind::Ident(_, _, _) |\n+            PatKind::Binding(..) |\n             PatKind::Path(..) |\n             PatKind::QPath(_, _) => {\n                 true\n@@ -532,7 +532,7 @@ pub enum PatKind {\n     /// which it is. The resolver determines this, and\n     /// records this pattern's `NodeId` in an auxiliary\n     /// set (of \"PatIdents that refer to unit patterns or constants\").\n-    Ident(BindingMode, Spanned<Name>, Option<P<Pat>>),\n+    Binding(BindingMode, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -1144,7 +1144,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(BindByValue(mutbl), name, _) = self.pat.node {\n+        if let PatKind::Binding(BindByValue(mutbl), name, _) = self.pat.node {\n             if name.node.unhygienize() == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -1160,7 +1160,7 @@ impl Arg {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Ident(_, name, _) = self.pat.node {\n+        if let PatKind::Binding(_, name, _) = self.pat.node {\n             name.node.unhygienize() == keywords::SelfValue.name()\n         } else {\n             false"}, {"sha": "35a7f7174cbbc6667ed4871c608d5df26985fbbf", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -70,7 +70,6 @@ pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n         PatKind::Lit(_) | PatKind::Range(_, _) | PatKind::QPath(..) => true,\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n-        PatKind::Ident(_, _, None) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) => true,\n@@ -86,7 +85,6 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n         PatKind::TupleStruct(..) |\n         PatKind::Path(..) |\n-        PatKind::Ident(_, _, None) |\n         PatKind::Struct(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Variant(..)) | Some(Def::Struct(..)) | Some(Def::TyAlias(..)) => true,\n@@ -99,7 +97,7 @@ pub fn pat_is_variant_or_struct(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id).map(|d| d.full_def()) {\n                 Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n                 _ => false\n@@ -113,7 +111,7 @@ pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n // returned instead of a panic.\n pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(_, _, None) | PatKind::Path(..) | PatKind::QPath(..) => {\n+        PatKind::Path(..) | PatKind::QPath(..) => {\n             match dm.get(&pat.id)\n                     .and_then(|d| if d.depth == 0 { Some(d.base_def) }\n                                   else { None } ) {\n@@ -125,32 +123,28 @@ pub fn pat_is_resolved_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n     }\n }\n \n-pub fn pat_is_binding(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_binding(_: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(..) => {\n-            !pat_is_variant_or_struct(dm, pat) &&\n-            !pat_is_const(dm, pat)\n-        }\n+        PatKind::Binding(..) => true,\n         _ => false\n     }\n }\n \n-pub fn pat_is_binding_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n+pub fn pat_is_binding_or_wild(_: &DefMap, pat: &hir::Pat) -> bool {\n     match pat.node {\n-        PatKind::Ident(..) => pat_is_binding(dm, pat),\n-        PatKind::Wild => true,\n+        PatKind::Binding(..) | PatKind::Wild => true,\n         _ => false\n     }\n }\n \n /// Call `it` on every \"binding\" in a pattern, e.g., on `a` in\n /// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<I>(dm: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n+pub fn pat_bindings<I>(_: &RefCell<DefMap>, pat: &hir::Pat, mut it: I) where\n     I: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n {\n     pat.walk(|p| {\n         match p.node {\n-          PatKind::Ident(binding_mode, ref pth, _) if pat_is_binding(&dm.borrow(), p) => {\n+          PatKind::Binding(binding_mode, ref pth, _) => {\n             it(binding_mode, p.id, p.span, &respan(pth.span, pth.node));\n           }\n           _ => {}\n@@ -221,7 +215,7 @@ pub fn pat_contains_bindings_or_wild(dm: &DefMap, pat: &hir::Pat) -> bool {\n \n pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Ident(hir::BindByValue(_), ref path1, None) => {\n+        PatKind::Binding(hir::BindByValue(..), ref path1, None) => {\n             Some(path1.node)\n         }\n         _ => {\n@@ -241,7 +235,6 @@ pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n         match p.node {\n             PatKind::TupleStruct(..) |\n             PatKind::Path(..) |\n-            PatKind::Ident(_, _, None) |\n             PatKind::Struct(..) => {\n                 match dm.get(&p.id) {\n                     Some(&PathResolution { base_def: Def::Variant(_, id), .. }) => {"}, {"sha": "ceaf348117e1711b5c8d5bef3c7ca049daa60969", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -1716,7 +1716,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => word(&mut self.s, \"_\")?,\n-            PatKind::Ident(binding_mode, ref path1, ref sub) => {\n+            PatKind::Binding(binding_mode, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -2170,7 +2170,7 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n-                    let invalid = if let PatKind::Ident(_, name, _) = input.pat.node {\n+                    let invalid = if let PatKind::Binding(_, name, _) = input.pat.node {\n                         name.node == keywords::Invalid.name()\n                     } else {\n                         false"}, {"sha": "12517d927de46c62cf1af4dab52845224146dfa1", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -935,9 +935,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             let def_map = &self.tcx().def_map;\n             if pat_util::pat_is_binding(&def_map.borrow(), pat) {\n                 match pat.node {\n-                    PatKind::Ident(hir::BindByRef(_), _, _) =>\n+                    PatKind::Binding(hir::BindByRef(_), _, _) =>\n                         mode.lub(BorrowingMatch),\n-                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n+                    PatKind::Binding(hir::BindByValue(_), _, _) => {\n                         match copy_or_move(self.mc.infcx, &cmt_pat, PatBindingMove) {\n                             Copy => mode.lub(CopyingMatch),\n                             Move(_) => mode.lub(MovingMatch),\n@@ -989,14 +989,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n                 // It is also a borrow or copy/move of the value being matched.\n                 match pat.node {\n-                    PatKind::Ident(hir::BindByRef(m), _, _) => {\n+                    PatKind::Binding(hir::BindByRef(m), _, _) => {\n                         if let ty::TyRef(&r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat,\n                                             r, bk, RefBinding);\n                         }\n                     }\n-                    PatKind::Ident(hir::BindByValue(_), _, _) => {\n+                    PatKind::Binding(hir::BindByValue(_), _, _) => {\n                         let mode = copy_or_move(infcx, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n@@ -1057,8 +1057,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             let tcx = infcx.tcx;\n \n             match pat.node {\n-                PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::QPath(..) |\n-                PatKind::Ident(_, _, None) | PatKind::Struct(..) => {\n+                PatKind::Struct(..) | PatKind::TupleStruct(..) |\n+                PatKind::Path(..) | PatKind::QPath(..) => {\n                     match def_map.get(&pat.id).map(|d| d.full_def()) {\n                         None => {\n                             // no definition found: pat is not a\n@@ -1094,8 +1094,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n \n                         Some(Def::Const(..)) |\n-                        Some(Def::AssociatedConst(..)) |\n-                        Some(Def::Local(..)) => {\n+                        Some(Def::AssociatedConst(..)) => {\n                             // This is a leaf (i.e. identifier binding\n                             // or constant value to match); thus no\n                             // `matched_pat` call.\n@@ -1121,16 +1120,10 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                PatKind::Ident(_, _, Some(_)) => {\n-                    // Do nothing; this is a binding (not an enum\n-                    // variant or struct), and the cat_pattern call\n-                    // will visit the substructure recursively.\n-                }\n-\n                 PatKind::Wild | PatKind::Tuple(..) | PatKind::Box(..) |\n                 PatKind::Ref(..) | PatKind::Lit(..) | PatKind::Range(..) |\n-                PatKind::Vec(..) => {\n-                    // Similarly, each of these cases does not\n+                PatKind::Vec(..) | PatKind::Binding(..) => {\n+                    // Each of these cases does not\n                     // correspond to an enum variant or struct, so we\n                     // do not do any `matched_pat` calls for these\n                     // cases either."}, {"sha": "31e3db51f55d859db24bb4a87ca3f068036f5778", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -306,7 +306,7 @@ impl MutabilityCategory {\n     fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.map.get(id) {\n             ast_map::NodeLocal(p) => match p.node {\n-                PatKind::Ident(bind_mode, _, _) => {\n+                PatKind::Binding(bind_mode, _, _) => {\n                     if bind_mode == hir::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -398,7 +398,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            PatKind::Ident(hir::BindByRef(_), _, _) => {\n+            PatKind::Binding(hir::BindByRef(_), _, _) => {\n                 // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                 // but what we want here is the type of the underlying value being borrowed.\n                 // So peel off one-level, turning the &T into T.\n@@ -1276,11 +1276,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Ident(_, _, None) => {\n+          PatKind::Path(..) | PatKind::QPath(..) | PatKind::Binding(_, _, None) => {\n               // Lone constant, or unit variant or identifier: ignore\n           }\n \n-          PatKind::Ident(_, _, Some(ref subpat)) => {\n+          PatKind::Binding(_, _, Some(ref subpat)) => {\n               self.cat_pattern_(cmt, &subpat, op)?;\n           }\n "}, {"sha": "3efc584ae2b66df3f1a52480fdc021ce391575f4", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -752,13 +752,9 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n-    // If this is a binding (or maybe a binding, I'm too lazy to check\n-    // the def map) then record the lifetime of that binding.\n-    match pat.node {\n-        PatKind::Ident(..) => {\n-            record_var_lifetime(visitor, pat.id, pat.span);\n-        }\n-        _ => { }\n+    // If this is a binding then record the lifetime of that binding.\n+    if let PatKind::Binding(..) = pat.node {\n+        record_var_lifetime(visitor, pat.id, pat.span);\n     }\n \n     intravisit::walk_pat(visitor, pat);\n@@ -958,7 +954,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n         match pat.node {\n-            PatKind::Ident(hir::BindByRef(_), _, _) => true,\n+            PatKind::Binding(hir::BindByRef(_), _, _) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))"}, {"sha": "24f0671ce6184c2c03a396653ecb9a329df81421", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -2216,7 +2216,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    PatKind::Ident(_, ref path1, _) => path1.node.as_str(),\n+                    PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },"}, {"sha": "8682661d35a849053f5982581dd7b6f933c82bc8", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Ident(_, ref path1, _) => {\n+        PatKind::Binding(_, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node})\n         },"}, {"sha": "46e05d218fc64893d879ffa043af34c4fefc9ce7", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 44, "deletions": 63, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -239,31 +239,28 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n     pat.walk(|p| {\n-        match p.node {\n-            PatKind::Ident(hir::BindByValue(hir::MutImmutable), name, None) => {\n-                let pat_ty = cx.tcx.pat_ty(p);\n-                if let ty::TyEnum(edef, _) = pat_ty.sty {\n-                    let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-                    if let Some(Def::Local(..)) = def {\n-                        if edef.variants.iter().any(|variant|\n-                            variant.name == name.node.unhygienize()\n-                                && variant.kind() == VariantKind::Unit\n-                        ) {\n-                            let ty_path = cx.tcx.item_path_str(edef.did);\n-                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                                \"pattern binding `{}` is named the same as one \\\n-                                 of the variants of the type `{}`\",\n-                                name.node, ty_path);\n-                            help!(err,\n-                                \"if you meant to match on a variant, \\\n-                                 consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_path, name.node);\n-                            err.emit();\n-                        }\n+        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n+            let pat_ty = cx.tcx.pat_ty(p);\n+            if let ty::TyEnum(edef, _) = pat_ty.sty {\n+                let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n+                if let Some(Def::Local(..)) = def {\n+                    if edef.variants.iter().any(|variant|\n+                        variant.name == name.node.unhygienize()\n+                            && variant.kind() == VariantKind::Unit\n+                    ) {\n+                        let ty_path = cx.tcx.item_path_str(edef.did);\n+                        let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                            \"pattern binding `{}` is named the same as one \\\n+                             of the variants of the type `{}`\",\n+                            name.node, ty_path);\n+                        help!(err,\n+                            \"if you meant to match on a variant, \\\n+                             consider making the path in the pattern qualified: `{}::{}`\",\n+                            ty_path, name.node);\n+                        err.emit();\n                     }\n                 }\n             }\n-            _ => ()\n         }\n         true\n     });\n@@ -371,8 +368,8 @@ fn check_arms(cx: &MatchCheckCtxt,\n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n     match p.node {\n-        PatKind::Ident(_, _, None) => pat_is_binding(dm, p),\n-        PatKind::Ident(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n+        PatKind::Binding(_, _, None) => true,\n+        PatKind::Binding(_, _, Some(ref s)) => pat_is_catchall(dm, &s),\n         PatKind::Ref(ref s, _) => pat_is_catchall(dm, &s),\n         PatKind::Tuple(ref v, _) => v.iter().all(|p| pat_is_catchall(dm, &p)),\n         _ => false\n@@ -381,7 +378,7 @@ fn pat_is_catchall(dm: &DefMap, p: &Pat) -> bool {\n \n fn raw_pat(p: &Pat) -> &Pat {\n     match p.node {\n-        PatKind::Ident(_, _, Some(ref s)) => raw_pat(&s),\n+        PatKind::Binding(_, _, Some(ref s)) => raw_pat(&s),\n         _ => p\n     }\n }\n@@ -487,11 +484,10 @@ impl<'map> IdVisitingOperation for RenamingRecorder<'map> {\n impl<'a, 'tcx> Folder for StaticInliner<'a, 'tcx> {\n     fn fold_pat(&mut self, pat: P<Pat>) -> P<Pat> {\n         return match pat.node {\n-            PatKind::Ident(..) | PatKind::Path(..) | PatKind::QPath(..) => {\n+            PatKind::Path(..) | PatKind::QPath(..) => {\n                 let def = self.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def());\n                 match def {\n-                    Some(Def::AssociatedConst(did)) |\n-                    Some(Def::Const(did)) => {\n+                    Some(Def::AssociatedConst(did)) | Some(Def::Const(did)) => {\n                         let substs = Some(self.tcx.node_id_item_substs(pat.id).substs);\n                         if let Some((const_expr, _)) = lookup_const_by_id(self.tcx, did, substs) {\n                             match const_expr_to_pat(self.tcx, const_expr, pat.id, pat.span) {\n@@ -717,7 +713,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n         let left_ty = cx.tcx.pat_ty(&real_pat);\n \n         match real_pat.node {\n-            PatKind::Ident(hir::BindByRef(..), _, _) => {\n+            PatKind::Binding(hir::BindByRef(..), _, _) => {\n                 left_ty.builtin_deref(false, NoPreference).unwrap().ty\n             }\n             _ => left_ty,\n@@ -804,38 +800,37 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n                     left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n     let pat = raw_pat(p);\n     match pat.node {\n-        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) | PatKind::Ident(..) =>\n+        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n             match cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat.span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Struct(..) | Def::TyAlias(..) => vec![Single],\n                 Def::Variant(_, id) => vec![Variant(id)],\n-                Def::Local(..) => vec![],\n                 def => span_bug!(pat.span, \"pat_constructors: unexpected \\\n                                             definition {:?}\", def),\n             },\n         PatKind::QPath(..) =>\n             span_bug!(pat.span, \"const pattern should've been rewritten\"),\n         PatKind::Lit(ref expr) =>\n-            vec!(ConstantValue(eval_const_expr(cx.tcx, &expr))),\n+            vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n         PatKind::Range(ref lo, ref hi) =>\n-            vec!(ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))),\n+            vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n         PatKind::Vec(ref before, ref slice, ref after) =>\n             match left_ty.sty {\n-                ty::TyArray(_, _) => vec!(Single),\n+                ty::TyArray(_, _) => vec![Single],\n                 _                      => if slice.is_some() {\n                     (before.len() + after.len()..max_slice_length+1)\n                         .map(|length| Slice(length))\n                         .collect()\n                 } else {\n-                    vec!(Slice(before.len() + after.len()))\n+                    vec![Slice(before.len() + after.len())]\n                 }\n             },\n         PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n-            vec!(Single),\n-        PatKind::Wild =>\n-            vec!(),\n+            vec![Single],\n+        PatKind::Binding(..) | PatKind::Wild =>\n+            vec![],\n     }\n }\n \n@@ -897,18 +892,17 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         id: pat_id, ref node, span: pat_span\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n-        PatKind::Wild =>\n+        PatKind::Binding(..) | PatKind::Wild =>\n             Some(vec![DUMMY_WILD_PAT; arity]),\n \n-        PatKind::Path(..) | PatKind::Ident(..) => {\n+        PatKind::Path(..) => {\n             let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 Def::Const(..) | Def::AssociatedConst(..) =>\n                     span_bug!(pat_span, \"const pattern should've \\\n                                          been rewritten\"),\n                 Def::Variant(_, id) if *constructor != Variant(id) => None,\n                 Def::Variant(..) | Def::Struct(..) => Some(Vec::new()),\n-                Def::Local(..) => Some(vec![DUMMY_WILD_PAT; arity]),\n                 _ => span_bug!(pat_span, \"specialize: unexpected \\\n                                           definition {:?}\", def),\n             }\n@@ -1128,28 +1122,15 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if pat_is_binding(&def_map.borrow(), &p) {\n-                match p.node {\n-                    PatKind::Ident(hir::BindByValue(_), _, ref sub) => {\n-                        let pat_ty = tcx.node_id_to_type(p.id);\n-                        //FIXME: (@jroesch) this code should be floated up as well\n-                        cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                                          ProjectionMode::AnyFinal).enter(|infcx| {\n-                            if infcx.type_moves_by_default(pat_ty, pat.span) {\n-                                check_move(p, sub.as_ref().map(|p| &**p));\n-                            }\n-                        });\n+            if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n+                let pat_ty = tcx.node_id_to_type(p.id);\n+                //FIXME: (@jroesch) this code should be floated up as well\n+                cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n+                                  ProjectionMode::AnyFinal).enter(|infcx| {\n+                    if infcx.type_moves_by_default(pat_ty, pat.span) {\n+                        check_move(p, sub.as_ref().map(|p| &**p));\n                     }\n-                    PatKind::Ident(hir::BindByRef(_), _, _) => {\n-                    }\n-                    _ => {\n-                        span_bug!(\n-                            p.span,\n-                            \"binding pattern {} is not an identifier: {:?}\",\n-                            p.id,\n-                            p.node);\n-                    }\n-                }\n+                });\n             }\n             true\n         });\n@@ -1225,7 +1206,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n         }\n \n         match pat.node {\n-            PatKind::Ident(_, _, Some(_)) => {\n+            PatKind::Binding(_, _, Some(_)) => {\n                 let bindings_were_allowed = self.bindings_allowed;\n                 self.bindings_allowed = false;\n                 intravisit::walk_pat(self, pat);"}, {"sha": "4c4dea406ba9e80cac255c0d07d9fe5a20c58057", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -274,9 +274,9 @@ impl LateLintPass for NonSnakeCase {\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &PatKind::Ident(_, ref path1, _) = &p.node {\n-            let def = cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def());\n-            if let Some(Def::Local(..)) = def {\n+        if let &PatKind::Binding(_, ref path1, _) = &p.node {\n+            // Exclude parameter names from foreign functions (they have no `Def`)\n+            if cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def()).is_some() {\n                 self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n             }\n         }\n@@ -360,12 +360,14 @@ impl LateLintPass for NonUpperCaseGlobals {\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n-        match (&p.node, cx.tcx.def_map.borrow().get(&p.id).map(|d| d.full_def())) {\n-            (&PatKind::Ident(_, ref path1, _), Some(Def::Const(..))) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n-                                                      path1.node, p.span);\n+        if let PatKind::Path(ref path) = p.node {\n+            if !path.global && path.segments.len() == 1 && path.segments[0].parameters.is_empty() {\n+                if let Some(Def::Const(..)) = cx.tcx.def_map.borrow().get(&p.id)\n+                                                                     .map(|d| d.full_def()) {\n+                    NonUpperCaseGlobals::check_upper_case(cx, \"constant in pattern\",\n+                                                          path.segments[0].name, path.span);\n+                }\n             }\n-            _ => {}\n         }\n     }\n }"}, {"sha": "3005f564ff41a4fb87b074db3c8ecbce9c714472", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -171,7 +171,7 @@ impl LateLintPass for NonShorthandFieldPatterns {\n                 }\n             });\n             for fieldpat in field_pats {\n-                if let PatKind::Ident(_, ident, None) = fieldpat.node.pat.node {\n+                if let PatKind::Binding(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.unhygienize() == fieldpat.node.name {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\"}, {"sha": "e0c35a6fba84f3d253792f874918c57e65dbb27f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -744,7 +744,7 @@ fn encode_method_argument_names(rbml_w: &mut Encoder,\n     rbml_w.start_tag(tag_method_argument_names);\n     for arg in &decl.inputs {\n         let tag = tag_method_argument_name;\n-        if let PatKind::Ident(_, ref path1, _) = arg.pat.node {\n+        if let PatKind::Binding(_, ref path1, _) = arg.pat.node {\n             let name = path1.node.as_str();\n             rbml_w.wr_tagged_bytes(tag, name.as_bytes());\n         } else {"}, {"sha": "9d7818a9ba4d67e0c8ea5bdac6a677e5b65cd78c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n-use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n use syntax::abi::Abi;\n use syntax::ast;\n@@ -221,7 +220,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref: by_ref\n             };\n             if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n-                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }\n             }\n@@ -333,10 +332,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n             let mut name = keywords::Invalid.name();\n             if let Some(pat) = pattern {\n-                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n-                    if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n-                        name = ident.node;\n-                    }\n+                if let hir::PatKind::Binding(_, ref ident, _) = pat.node {\n+                    name = ident.node;\n                 }\n             }\n "}, {"sha": "acde81979f92713fd97e35e891a5dfa94f5c373c", "filename": "src/librustc_mir/hair/cx/pattern.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fpattern.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -13,7 +13,7 @@ use hair::cx::Cx;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc_const_eval as const_eval;\n use rustc::hir::def::Def;\n-use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const, pat_is_binding};\n+use rustc::hir::pat_util::{EnumerateAndAdjustIterator, pat_is_resolved_const};\n use rustc::ty::{self, Ty};\n use rustc::mir::repr::*;\n use rustc::hir::{self, PatKind};\n@@ -81,7 +81,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 PatternKind::Range { lo: lo, hi: hi }\n             },\n \n-            PatKind::Path(..) | PatKind::Ident(..) | PatKind::QPath(..)\n+            PatKind::Path(..) | PatKind::QPath(..)\n                 if pat_is_resolved_const(&self.cx.tcx.def_map.borrow(), pat) =>\n             {\n                 let def = self.cx.tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n@@ -167,9 +167,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Ident(bm, ref ident, ref sub)\n-                if pat_is_binding(&self.cx.tcx.def_map.borrow(), pat) =>\n-            {\n+            PatKind::Binding(bm, ref ident, ref sub) => {\n                 let id = match self.binding_map {\n                     None => pat.id,\n                     Some(ref map) => map[&ident.node],\n@@ -210,7 +208,7 @@ impl<'patcx, 'cx, 'gcx, 'tcx> PatCx<'patcx, 'cx, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Ident(..) | PatKind::Path(..) => {\n+            PatKind::Path(..) => {\n                 self.variant_or_leaf(pat, vec![])\n             }\n "}, {"sha": "bdde5ce16178b726cb3e86548906d87da190cc54", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 45, "deletions": 56, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -424,12 +424,11 @@ impl<'a, 'p, 'blk, 'tcx> fmt::Debug for Match<'a, 'p, 'blk, 'tcx> {\n \n fn has_nested_bindings(m: &[Match], col: usize) -> bool {\n     for br in m {\n-        match br.pats[col].node {\n-            PatKind::Ident(_, _, Some(_)) => return true,\n-            _ => ()\n+        if let PatKind::Binding(_, _, Some(..)) = br.pats[col].node {\n+            return true\n         }\n     }\n-    return false;\n+    false\n }\n \n // As noted in `fn match_datum`, we should eventually pass around a\n@@ -481,7 +480,7 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let mut pat = br.pats[col];\n         loop {\n             pat = match pat.node {\n-                PatKind::Ident(_, ref path, Some(ref inner)) => {\n+                PatKind::Binding(_, ref path, Some(ref inner)) => {\n                     bound_ptrs.push((path.node, val.val));\n                     &inner\n                 },\n@@ -501,7 +500,6 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                          dm: &RefCell<DefMap>,\n                                           m: &[Match<'a, 'p, 'blk, 'tcx>],\n                                           col: usize,\n                                           val: MatchInput,\n@@ -518,13 +516,11 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n-                PatKind::Ident(_, ref path, None) => {\n-                    if pat_is_binding(&dm.borrow(), &this) {\n-                        bound_ptrs.push((path.node, val.val));\n-                    }\n+                PatKind::Binding(_, ref path, None) => {\n+                    bound_ptrs.push((path.node, val.val));\n                 }\n                 PatKind::Vec(ref before, Some(ref slice), ref after) => {\n-                    if let PatKind::Ident(_, ref path, None) = slice.node {\n+                    if let PatKind::Binding(_, ref path, None) = slice.node {\n                         let subslice_val = bind_subslice_pat(\n                             bcx, this.id, val,\n                             before.len(), after.len());\n@@ -554,7 +550,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     // Collect all of the matches that can match against anything.\n-    enter_match(bcx, dm, m, col, val, |pats| {\n+    enter_match(bcx, m, col, val, |pats| {\n         if pat_is_binding_or_wild(&dm.borrow(), &pats[col]) {\n             let mut r = pats[..col].to_vec();\n             r.extend_from_slice(&pats[col + 1..]);\n@@ -596,7 +592,6 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n fn enter_opt<'a, 'p, 'blk, 'tcx>(\n              bcx: Block<'blk, 'tcx>,\n              _: ast::NodeId,\n-             dm: &RefCell<DefMap>,\n              m: &[Match<'a, 'p, 'blk, 'tcx>],\n              opt: &Opt,\n              col: usize,\n@@ -628,7 +623,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         tcx: bcx.tcx(),\n         param_env: param_env,\n     };\n-    enter_match(bcx, dm, m, col, val, |pats|\n+    enter_match(bcx, m, col, val, |pats|\n         check_match::specialize(&mcx, &pats[..], &ctor, col, variant_size)\n     )\n }\n@@ -659,9 +654,7 @@ fn get_branches<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             PatKind::Lit(ref l) => {\n                 ConstantValue(ConstantExpr(&l), debug_loc)\n             }\n-            PatKind::Ident(..) | PatKind::Path(..) |\n-            PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n-                // This is either an enum variant or a variable binding.\n+            PatKind::Path(..) | PatKind::TupleStruct(..) | PatKind::Struct(..) => {\n                 let opt_def = tcx.def_map.borrow().get(&cur.id).map(|d| d.full_def());\n                 match opt_def {\n                     Some(Def::Variant(enum_id, var_id)) => {\n@@ -793,8 +786,7 @@ fn any_irrefutable_adt_pat(tcx: TyCtxt, m: &[Match], col: usize) -> bool {\n         let pat = br.pats[col];\n         match pat.node {\n             PatKind::Tuple(..) => true,\n-            PatKind::Struct(..) | PatKind::TupleStruct(..) |\n-            PatKind::Path(..) | PatKind::Ident(_, _, None) => {\n+            PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => {\n                 match tcx.def_map.borrow().get(&pat.id).unwrap().full_def() {\n                     Def::Struct(..) | Def::TyAlias(..) => true,\n                     _ => false,\n@@ -839,7 +831,7 @@ impl FailureHandler {\n fn pick_column_to_specialize(def_map: &RefCell<DefMap>, m: &[Match]) -> Option<usize> {\n     fn pat_score(def_map: &RefCell<DefMap>, pat: &hir::Pat) -> usize {\n         match pat.node {\n-            PatKind::Ident(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n+            PatKind::Binding(_, _, Some(ref inner)) => pat_score(def_map, &inner),\n             _ if pat_is_refutable(&def_map.borrow(), pat) => 1,\n             _ => 0\n         }\n@@ -1226,7 +1218,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     };\n     match adt_vals {\n         Some(field_vals) => {\n-            let pats = enter_match(bcx, dm, m, col, val, |pats|\n+            let pats = enter_match(bcx, m, col, val, |pats|\n                 check_match::specialize(&mcx, pats,\n                                         &Constructor::Single, col,\n                                         field_vals.len())\n@@ -1391,7 +1383,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             ConstantValue(..) | ConstantRange(..) => ()\n         }\n-        let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n+        let opt_ms = enter_opt(opt_cx, pat_id, m, opt, col, size, val);\n         let mut opt_vals: Vec<_> = unpacked.into_iter()\n             .map(|v|MatchInput::from_val(v))\n             .collect();\n@@ -1796,38 +1788,35 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n     match pat.node {\n-        PatKind::Ident(pat_binding_mode, ref path1, ref inner) => {\n-            if pat_is_binding(&tcx.def_map.borrow(), &pat) {\n-                // Allocate the stack slot where the value of this\n-                // binding will live and place it into the appropriate\n-                // map.\n-                bcx = mk_binding_alloca(\n-                    bcx, pat.id, path1.node, cleanup_scope, (),\n-                    \"_match::bind_irrefutable_pat\",\n-                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n-                        match pat_binding_mode {\n-                            hir::BindByValue(_) => {\n-                                // By value binding: move the value that `val`\n-                                // points at into the binding's stack slot.\n-                                let d = val.to_datum(ty);\n-                                d.store_to(bcx, llval)\n-                            }\n+        PatKind::Binding(pat_binding_mode, ref path1, ref inner) => {\n+            // Allocate the stack slot where the value of this\n+            // binding will live and place it into the appropriate\n+            // map.\n+            bcx = mk_binding_alloca(bcx, pat.id, path1.node, cleanup_scope, (),\n+                                    \"_match::bind_irrefutable_pat\",\n+                                    |(), bcx, Datum { val: llval, ty, kind: _ }| {\n+                match pat_binding_mode {\n+                    hir::BindByValue(_) => {\n+                        // By value binding: move the value that `val`\n+                        // points at into the binding's stack slot.\n+                        let d = val.to_datum(ty);\n+                        d.store_to(bcx, llval)\n+                    }\n \n-                            hir::BindByRef(_) => {\n-                                // By ref binding: the value of the variable\n-                                // is the pointer `val` itself or fat pointer referenced by `val`\n-                                if type_is_fat_ptr(bcx.tcx(), ty) {\n-                                    expr::copy_fat_ptr(bcx, val.val, llval);\n-                                }\n-                                else {\n-                                    Store(bcx, val.val, llval);\n-                                }\n-\n-                                bcx\n-                            }\n+                    hir::BindByRef(_) => {\n+                        // By ref binding: the value of the variable\n+                        // is the pointer `val` itself or fat pointer referenced by `val`\n+                        if type_is_fat_ptr(bcx.tcx(), ty) {\n+                            expr::copy_fat_ptr(bcx, val.val, llval);\n                         }\n-                    });\n-            }\n+                        else {\n+                            Store(bcx, val.val, llval);\n+                        }\n+\n+                        bcx\n+                    }\n+                }\n+            });\n \n             if let Some(ref inner_pat) = *inner {\n                 bcx = bind_irrefutable_pat(bcx, &inner_pat, val, cleanup_scope);\n@@ -1941,7 +1930,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Binding(hir::BindByRef(..),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -1960,7 +1949,7 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let val = if type_is_fat_ptr(tcx, pat_ty) {\n                 // We need to check for this, as the pattern could be binding\n                 // a fat pointer by-value.\n-                if let PatKind::Ident(hir::BindByRef(_),_,_) = inner.node {\n+                if let PatKind::Binding(hir::BindByRef(..),_,_) = inner.node {\n                     val.val\n                 } else {\n                     Load(bcx, val.val)\n@@ -2001,8 +1990,8 @@ pub fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         cleanup_scope)\n                 });\n         }\n-        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild | PatKind::Lit(_) |\n-        PatKind::Range(_, _) => ()\n+        PatKind::Path(..) | PatKind::QPath(..) | PatKind::Wild |\n+        PatKind::Lit(..) | PatKind::Range(..) => ()\n     }\n     return bcx;\n }"}, {"sha": "66409a4c481c93a030c9c4d640721c71e702e8a5", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 56, "deletions": 66, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -235,76 +235,66 @@ fn walk_pattern(cx: &CrateContext,\n                 pat: &hir::Pat,\n                 scope_stack: &mut Vec<ScopeStackEntry> ,\n                 scope_map: &mut NodeMap<DIScope>) {\n-\n-    let def_map = &cx.tcx().def_map;\n-\n     // Unfortunately, we cannot just use pat_util::pat_bindings() or\n     // ast_util::walk_pat() here because we have to visit *all* nodes in\n     // order to put them into the scope map. The above functions don't do that.\n     match pat.node {\n-        PatKind::Ident(_, ref path1, ref sub_pat_opt) => {\n-\n-            // Check if this is a binding. If so we need to put it on the\n-            // scope stack and maybe introduce an artificial scope\n-            if pat_util::pat_is_binding(&def_map.borrow(), &pat) {\n-\n-                let name = path1.node.unhygienize();\n-\n-                // LLVM does not properly generate 'DW_AT_start_scope' fields\n-                // for variable DIEs. For this reason we have to introduce\n-                // an artificial scope at bindings whenever a variable with\n-                // the same name is declared in *any* parent scope.\n-                //\n-                // Otherwise the following error occurs:\n-                //\n-                // let x = 10;\n-                //\n-                // do_something(); // 'gdb print x' correctly prints 10\n-                //\n-                // {\n-                //     do_something(); // 'gdb print x' prints 0, because it\n-                //                     // already reads the uninitialized 'x'\n-                //                     // from the next line...\n-                //     let x = 100;\n-                //     do_something(); // 'gdb print x' correctly prints 100\n-                // }\n-\n-                // Is there already a binding with that name?\n-                // N.B.: this comparison must be UNhygienic... because\n-                // gdb knows nothing about the context, so any two\n-                // variables with the same name will cause the problem.\n-                let need_new_scope = scope_stack\n-                    .iter()\n-                    .any(|entry| entry.name == Some(name));\n-\n-                if need_new_scope {\n-                    // Create a new lexical scope and push it onto the stack\n-                    let loc = span_start(cx, pat.span);\n-                    let file_metadata = file_metadata(cx, &loc.file.name);\n-                    let parent_scope = scope_stack.last().unwrap().scope_metadata;\n-\n-                    let scope_metadata = unsafe {\n-                        llvm::LLVMDIBuilderCreateLexicalBlock(\n-                            DIB(cx),\n-                            parent_scope,\n-                            file_metadata,\n-                            loc.line as c_uint,\n-                            loc.col.to_usize() as c_uint)\n-                    };\n-\n-                    scope_stack.push(ScopeStackEntry {\n-                        scope_metadata: scope_metadata,\n-                        name: Some(name)\n-                    });\n-\n-                } else {\n-                    // Push a new entry anyway so the name can be found\n-                    let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n-                    scope_stack.push(ScopeStackEntry {\n-                        scope_metadata: prev_metadata,\n-                        name: Some(name)\n-                    });\n-                }\n+        PatKind::Binding(_, ref path1, ref sub_pat_opt) => {\n+            // LLVM does not properly generate 'DW_AT_start_scope' fields\n+            // for variable DIEs. For this reason we have to introduce\n+            // an artificial scope at bindings whenever a variable with\n+            // the same name is declared in *any* parent scope.\n+            //\n+            // Otherwise the following error occurs:\n+            //\n+            // let x = 10;\n+            //\n+            // do_something(); // 'gdb print x' correctly prints 10\n+            //\n+            // {\n+            //     do_something(); // 'gdb print x' prints 0, because it\n+            //                     // already reads the uninitialized 'x'\n+            //                     // from the next line...\n+            //     let x = 100;\n+            //     do_something(); // 'gdb print x' correctly prints 100\n+            // }\n+\n+            // Is there already a binding with that name?\n+            // N.B.: this comparison must be UNhygienic... because\n+            // gdb knows nothing about the context, so any two\n+            // variables with the same name will cause the problem.\n+            let name = path1.node.unhygienize();\n+            let need_new_scope = scope_stack\n+                .iter()\n+                .any(|entry| entry.name == Some(name));\n+\n+            if need_new_scope {\n+                // Create a new lexical scope and push it onto the stack\n+                let loc = span_start(cx, pat.span);\n+                let file_metadata = file_metadata(cx, &loc.file.name);\n+                let parent_scope = scope_stack.last().unwrap().scope_metadata;\n+\n+                let scope_metadata = unsafe {\n+                    llvm::LLVMDIBuilderCreateLexicalBlock(\n+                        DIB(cx),\n+                        parent_scope,\n+                        file_metadata,\n+                        loc.line as c_uint,\n+                        loc.col.to_usize() as c_uint)\n+                };\n+\n+                scope_stack.push(ScopeStackEntry {\n+                    scope_metadata: scope_metadata,\n+                    name: Some(name)\n+                });\n+\n+            } else {\n+                // Push a new entry anyway so the name can be found\n+                let prev_metadata = scope_stack.last().unwrap().scope_metadata;\n+                scope_stack.push(ScopeStackEntry {\n+                    scope_metadata: prev_metadata,\n+                    name: Some(name)\n+                });\n             }\n \n             scope_map.insert(pat.id, scope_stack.last().unwrap().scope_metadata);"}, {"sha": "b401166cfdb4ca49138a6743b7dcbe7195797e7d", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -1945,7 +1945,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n         Some(hir_map::NodeLocal(pat)) => {\n             match pat.node {\n-                PatKind::Ident(_, ref path1, _) => {\n+                PatKind::Binding(_, ref path1, _) => {\n                     path1.node\n                 }\n                 _ => {"}, {"sha": "31805f14a8cde56ffcd275ef539b14043e231a7a", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -149,8 +149,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n             }\n-            PatKind::Path(..) | PatKind::Ident(..)\n-                    if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n+            PatKind::Path(..) if pat_is_resolved_const(&tcx.def_map.borrow(), pat) => {\n                 if let Some(pat_def) = tcx.def_map.borrow().get(&pat.id) {\n                     let const_did = pat_def.def_id();\n                     let const_scheme = tcx.lookup_item_type(const_did);\n@@ -170,8 +169,7 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                     self.write_error(pat.id);\n                 }\n             }\n-            PatKind::Ident(bm, ref path, ref sub)\n-                    if pat_is_binding(&tcx.def_map.borrow(), pat) => {\n+            PatKind::Binding(bm, ref path, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     hir::BindByRef(mutbl) => {\n@@ -211,10 +209,6 @@ impl<'a, 'gcx, 'tcx> PatCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            PatKind::Ident(_, ref path, _) => {\n-                let path = hir::Path::from_name(path.span, path.node);\n-                self.check_pat_enum(pat, &path, &[], None, expected, false);\n-            }\n             PatKind::TupleStruct(ref path, ref subpats, ddpos) => {\n                 self.check_pat_enum(pat, path, &subpats, ddpos, expected, true);\n             }"}, {"sha": "85a5d5b629338157ae5728a2c00fb34753770d7d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -572,19 +572,17 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if let PatKind::Ident(_, ref path1, _) = p.node {\n-            if pat_util::pat_is_binding(&self.fcx.tcx.def_map.borrow(), p) {\n-                let var_ty = self.assign(p.span, p.id, None);\n-\n-                self.fcx.require_type_is_sized(var_ty, p.span,\n-                                               traits::VariableType(p.id));\n-\n-                debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n-                       path1.node,\n-                       self.fcx.ty_to_string(\n-                           self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n-                       var_ty);\n-            }\n+        if let PatKind::Binding(_, ref path1, _) = p.node {\n+            let var_ty = self.assign(p.span, p.id, None);\n+\n+            self.fcx.require_type_is_sized(var_ty, p.span,\n+                                           traits::VariableType(p.id));\n+\n+            debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n+                   path1.node,\n+                   self.fcx.ty_to_string(\n+                       self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n+                   var_ty);\n         }\n         intravisit::walk_pat(self, p);\n     }"}, {"sha": "bf34428832d2ea5596f12efc8e063185282b3e27", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -1160,7 +1160,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n-                    PatKind::Ident(hir::BindByRef(mutbl), _, _) => {\n+                    PatKind::Binding(hir::BindByRef(mutbl), _, _) => {\n                         self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n                                                         mutbl, sub_cmt);\n                     }"}, {"sha": "92027a56ec1b0ac814a1d141c420f0b7680fcbf8", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -2152,12 +2152,9 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n {\n     for i in &decl.inputs {\n         match i.pat.node {\n-            PatKind::Ident(_, _, _) => (),\n-            PatKind::Wild => (),\n-            _ => {\n-                span_err!(ccx.tcx.sess, i.pat.span, E0130,\n-                          \"patterns aren't allowed in foreign function declarations\");\n-            }\n+            PatKind::Binding(..) | PatKind::Wild => {}\n+            _ => span_err!(ccx.tcx.sess, i.pat.span, E0130,\n+                           \"patterns aren't allowed in foreign function declarations\")\n         }\n     }\n "}, {"sha": "bf503141ff642c09e5cdbb36207759788e578f29", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/216f5fba043ff787ba2dd6bbf01e0e077304adf0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=216f5fba043ff787ba2dd6bbf01e0e077304adf0", "patch": "@@ -2578,7 +2578,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n \n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n-        PatKind::Ident(_, ref p, _) => p.node.to_string(),\n+        PatKind::Binding(_, ref p, _) => p.node.to_string(),\n         PatKind::TupleStruct(ref p, _, _) | PatKind::Path(ref p) => path_to_string(p),\n         PatKind::QPath(..) => panic!(\"tried to get argument name from PatKind::QPath, \\\n                                 which is not allowed in function arguments\"),"}]}