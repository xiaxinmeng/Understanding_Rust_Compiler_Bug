{"sha": "5da10c01214a3d3ebec65b8ba6effada92a0673f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkYTEwYzAxMjE0YTNkM2ViZWM2NWI4YmE2ZWZmYWRhOTJhMDY3M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-25T04:45:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-25T04:45:39Z"}, "message": "Auto merge of #84115 - CDirkx:rt, r=m-ou-se\n\nRework `init` and `cleanup`\n\nThis PR reworks the code in `std` that runs before and after `main` and centralizes this code respectively in the functions `init` and `cleanup` in both `sys_common` and `sys`. This makes is easy to see what code is executed during initialization and cleanup on each platform just by looking at e.g. `sys::windows::init`.\n\nFull list of changes:\n- new module `rt` in `sys_common` to contain `init` and `cleanup` and the runtime macros.\n- `at_exit` and the mechanism to register exit handlers has been completely removed. In practice this was only used for closing sockets on windows and flushing stdout, which have been moved to `cleanup`.\n- <s>On windows `alloc` and `net` initialization is now done in `init`, this saves a runtime check in every allocation and network use.</s>", "tree": {"sha": "94bbe380b059b6f77025a1e7c8d290f62390998e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94bbe380b059b6f77025a1e7c8d290f62390998e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5da10c01214a3d3ebec65b8ba6effada92a0673f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5da10c01214a3d3ebec65b8ba6effada92a0673f", "html_url": "https://github.com/rust-lang/rust/commit/5da10c01214a3d3ebec65b8ba6effada92a0673f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5da10c01214a3d3ebec65b8ba6effada92a0673f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0", "html_url": "https://github.com/rust-lang/rust/commit/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0"}, {"sha": "7171fec13f3a3091f702a8e55f495ad1563dc4cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7171fec13f3a3091f702a8e55f495ad1563dc4cd", "html_url": "https://github.com/rust-lang/rust/commit/7171fec13f3a3091f702a8e55f495ad1563dc4cd"}], "stats": {"total": 437, "additions": 175, "deletions": 262}, "files": [{"sha": "94c70c4f267b16a82892d0221428040c52c8a729", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -293,6 +293,10 @@ mod util;\n \n const DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n+pub(crate) fn cleanup() {\n+    stdio::cleanup()\n+}\n+\n struct Guard<'a> {\n     buf: &'a mut Vec<u8>,\n     len: usize,"}, {"sha": "2b0d2b7e0be23e87e3a674591c78d535c699589e", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -13,7 +13,6 @@ use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n-use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n \n type LocalStream = Arc<Mutex<Vec<u8>>>;\n@@ -508,6 +507,8 @@ pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n }\n \n+static STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = SyncOnceCell::new();\n+\n /// Constructs a new handle to the standard output of the current process.\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n@@ -549,34 +550,28 @@ pub struct StdoutLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> =\n-        SyncOnceCell::new();\n-\n-    fn cleanup() {\n-        if let Some(instance) = INSTANCE.get() {\n-            // Flush the data and disable buffering during shutdown\n-            // by replacing the line writer by one with zero\n-            // buffering capacity.\n-            // We use try_lock() instead of lock(), because someone\n-            // might have leaked a StdoutLock, which would\n-            // otherwise cause a deadlock here.\n-            if let Some(lock) = Pin::static_ref(instance).try_lock() {\n-                *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n-            }\n-        }\n-    }\n-\n     Stdout {\n-        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n-            || unsafe {\n-                let _ = sys_common::at_exit(cleanup);\n-                ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())))\n-            },\n+        inner: Pin::static_ref(&STDOUT).get_or_init_pin(\n+            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },\n             |mutex| unsafe { mutex.init() },\n         ),\n     }\n }\n \n+pub fn cleanup() {\n+    if let Some(instance) = STDOUT.get() {\n+        // Flush the data and disable buffering during shutdown\n+        // by replacing the line writer by one with zero\n+        // buffering capacity.\n+        // We use try_lock() instead of lock(), because someone\n+        // might have leaked a StdoutLock, which would\n+        // otherwise cause a deadlock here.\n+        if let Some(lock) = Pin::static_ref(instance).try_lock() {\n+            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+        }\n+    }\n+}\n+\n impl Stdout {\n     /// Locks this handle to the standard output stream, returning a writable\n     /// guard."}, {"sha": "b45c620fd0b068e25fbb2d27fb046a8f13a3bd30", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -1749,7 +1749,7 @@ impl Child {\n /// [platform-specific behavior]: #platform-specific-behavior\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn exit(code: i32) -> ! {\n-    crate::sys_common::cleanup();\n+    crate::sys_common::rt::cleanup();\n     crate::sys::os::exit(code)\n }\n "}, {"sha": "1e19aff51f8d6bb8054298096333b013590490f1", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -26,33 +26,16 @@ fn lang_start_internal(\n     argv: *const *const u8,\n ) -> isize {\n     use crate::panic;\n-    use crate::sys;\n     use crate::sys_common;\n-    use crate::sys_common::thread_info;\n-    use crate::thread::Thread;\n \n-    sys::init();\n+    // SAFETY: Only called once during runtime initialization.\n+    unsafe { sys_common::rt::init(argc, argv) };\n \n-    unsafe {\n-        let main_guard = sys::thread::guard::init();\n-        sys::stack_overflow::init();\n+    let exit_code = panic::catch_unwind(main);\n \n-        // Next, set up the current Thread with the guard information we just\n-        // created. Note that this isn't necessary in general for new threads,\n-        // but we just do this to name the main thread and to give it correct\n-        // info about the stack bounds.\n-        let thread = Thread::new(Some(\"main\".to_owned()));\n-        thread_info::set(main_guard, thread);\n+    sys_common::rt::cleanup();\n \n-        // Store our args if necessary in a squirreled away location\n-        sys::args::init(argc, argv);\n-\n-        // Let's run some code!\n-        let exit_code = panic::catch_unwind(main);\n-\n-        sys_common::cleanup();\n-        exit_code.unwrap_or(101) as isize\n-    }\n+    exit_code.unwrap_or(101) as isize\n }\n \n #[cfg(not(test))]"}, {"sha": "a70d1db7ca67240e2bce771b67cfd8a1cada39df", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -37,7 +37,6 @@ pub mod pipe;\n #[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n-pub mod stack_overflow;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_dtor;\n@@ -96,9 +95,17 @@ pub extern \"C\" fn __rust_abort() {\n     abort_internal();\n }\n \n-#[cfg(not(test))]\n-pub fn init() {\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     let _ = net::init();\n+    args::init(argc, argv);\n+}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub unsafe fn cleanup() {\n+    args::cleanup();\n }\n \n #[cfg(not(test))]"}, {"sha": "121fe42011da5ac355e4e507d06455cea1e3280d", "filename": "library/std/src/sys/hermit/stack_overflow.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fstack_overflow.rs?ref=f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0", "patch": "@@ -1,5 +0,0 @@\n-#[inline]\n-pub unsafe fn init() {}\n-\n-#[inline]\n-pub unsafe fn cleanup() {}"}, {"sha": "ef4176c4ac0f0caa3b7573b2ff530ffba30f7b1a", "filename": "library/std/src/sys/sgx/args.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fargs.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -23,8 +23,6 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     }\n }\n \n-pub unsafe fn cleanup() {}\n-\n pub fn args() -> Args {\n     let args = unsafe { (ARGS.load(Ordering::Relaxed) as *const ArgsStore).as_ref() };\n     if let Some(args) = args { Args(args.iter()) } else { Args([].iter()) }"}, {"sha": "059d6cb5ba13122994c69ee86439d1be1fe1181a", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -32,16 +32,24 @@ pub mod pipe;\n #[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n-pub mod stack_overflow;\n pub mod stdio;\n pub mod thread;\n pub mod thread_local_key;\n pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n-#[cfg(not(test))]\n-pub fn init() {}\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    unsafe {\n+        args::init(argc, argv);\n+    }\n+}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub unsafe fn cleanup() {}\n \n /// This function is used to implement functionality that simply doesn't exist.\n /// Programs relying on this functionality will need to deal with the error."}, {"sha": "b96652a8330e9f490465ccd6dc4837de74fedb42", "filename": "library/std/src/sys/sgx/stack_overflow.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fstack_overflow.rs?ref=f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0", "patch": "@@ -1,4 +0,0 @@\n-#[cfg_attr(test, allow(dead_code))]\n-pub unsafe fn init() {}\n-\n-pub unsafe fn cleanup() {}"}, {"sha": "a0ee69c2f72ddf871b6fef8320c7097437dacf21", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -44,14 +44,13 @@ pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n-#[cfg(not(test))]\n-pub fn init() {\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     // The standard streams might be closed on application startup. To prevent\n     // std::io::{stdin, stdout,stderr} objects from using other unrelated file\n     // resources opened later, we reopen standards streams when they are closed.\n-    unsafe {\n-        sanitize_standard_fds();\n-    }\n+    sanitize_standard_fds();\n \n     // By default, some platforms will send a *signal* when an EPIPE error\n     // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n@@ -60,26 +59,24 @@ pub fn init() {\n     //\n     // Hence, we set SIGPIPE to ignore when the program starts up in order\n     // to prevent this problem.\n-    unsafe {\n-        reset_sigpipe();\n-    }\n+    reset_sigpipe();\n+\n+    stack_overflow::init();\n+    args::init(argc, argv);\n \n-    cfg_if::cfg_if! {\n-        if #[cfg(miri)] {\n-            // The standard fds are always available in Miri.\n-            unsafe fn sanitize_standard_fds() {}\n-        } else if #[cfg(not(any(\n-            target_os = \"emscripten\",\n-            target_os = \"fuchsia\",\n-            target_os = \"vxworks\",\n-            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n-            target_os = \"macos\",\n-            target_os = \"ios\",\n-            target_os = \"redox\",\n-        )))] {\n-            // In the case when all file descriptors are open, the poll has been\n-            // observed to perform better than fcntl (on GNU/Linux).\n-            unsafe fn sanitize_standard_fds() {\n+    unsafe fn sanitize_standard_fds() {\n+        #[cfg(not(miri))]\n+        // The standard fds are always available in Miri.\n+        cfg_if::cfg_if! {\n+            if #[cfg(not(any(\n+                target_os = \"emscripten\",\n+                target_os = \"fuchsia\",\n+                target_os = \"vxworks\",\n+                // The poll on Darwin doesn't set POLLNVAL for closed fds.\n+                target_os = \"macos\",\n+                target_os = \"ios\",\n+                target_os = \"redox\",\n+            )))] {\n                 use crate::sys::os::errno;\n                 let pfds: &mut [_] = &mut [\n                     libc::pollfd { fd: 0, events: 0, revents: 0 },\n@@ -104,9 +101,7 @@ pub fn init() {\n                         libc::abort();\n                     }\n                 }\n-            }\n-        } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))] {\n-            unsafe fn sanitize_standard_fds() {\n+            } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))] {\n                 use crate::sys::os::errno;\n                 for fd in 0..3 {\n                     if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n@@ -116,17 +111,20 @@ pub fn init() {\n                     }\n                 }\n             }\n-        } else {\n-            unsafe fn sanitize_standard_fds() {}\n         }\n     }\n \n-    #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n     unsafe fn reset_sigpipe() {\n+        #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n         assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n     }\n-    #[cfg(any(target_os = \"emscripten\", target_os = \"fuchsia\"))]\n-    unsafe fn reset_sigpipe() {}\n+}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub unsafe fn cleanup() {\n+    args::cleanup();\n+    stack_overflow::cleanup();\n }\n \n #[cfg(target_os = \"android\")]"}, {"sha": "c924a7d8a26723043424a4e64914619919bf2245", "filename": "library/std/src/sys/unsupported/args.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fargs.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -1,8 +1,5 @@\n use crate::ffi::OsString;\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n-pub unsafe fn cleanup() {}\n-\n pub struct Args {}\n \n pub fn args() -> Args {"}, {"sha": "6e72a7c632ed0b4755d3f56034a75c0296e9f31d", "filename": "library/std/src/sys/unsupported/common.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -10,8 +10,13 @@ pub use crate::sys_common::os_str_bytes as os_str;\n // spec definition?\n use crate::os::raw::c_char;\n \n-#[cfg(not(test))]\n-pub fn init() {}\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub unsafe fn cleanup() {}\n \n pub fn unsupported<T>() -> std_io::Result<T> {\n     Err(unsupported_err())"}, {"sha": "32ca68ef15b5b54c3c4d1714cd978b17d581cfd1", "filename": "library/std/src/sys/unsupported/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -15,7 +15,6 @@ pub mod path;\n pub mod pipe;\n pub mod process;\n pub mod rwlock;\n-pub mod stack_overflow;\n pub mod stdio;\n pub mod thread;\n #[cfg(target_thread_local)]"}, {"sha": "32555394cd5a58fa3f5347bafd85af5f91350aab", "filename": "library/std/src/sys/unsupported/stack_overflow.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fstack_overflow.rs?ref=f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0", "patch": "@@ -1,3 +0,0 @@\n-pub unsafe fn init() {}\n-\n-pub unsafe fn cleanup() {}"}, {"sha": "c42c310e3a254f934b15cbc8e464e53f218e612b", "filename": "library/std/src/sys/wasi/args.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fargs.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -5,10 +5,6 @@ use crate::fmt;\n use crate::os::wasi::ffi::OsStrExt;\n use crate::vec;\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n-\n-pub unsafe fn cleanup() {}\n-\n pub struct Args {\n     iter: vec::IntoIter<OsString>,\n }"}, {"sha": "2584d35b6ef8aad68162d2593a7d8ea855f70b5d", "filename": "library/std/src/sys/wasi/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -42,8 +42,6 @@ pub mod pipe;\n pub mod process;\n #[path = \"../unsupported/rwlock.rs\"]\n pub mod rwlock;\n-#[path = \"../unsupported/stack_overflow.rs\"]\n-pub mod stack_overflow;\n pub mod stdio;\n pub mod thread;\n #[path = \"../unsupported/thread_local_dtor.rs\"]"}, {"sha": "fde1ab79e1f4b97d73bc1ed1e3333755ab2e93f1", "filename": "library/std/src/sys/wasm/args.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fargs.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -2,12 +2,6 @@ use crate::ffi::OsString;\n use crate::fmt;\n use crate::vec;\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n-    // On wasm these should always be null, so there's nothing for us to do here\n-}\n-\n-pub unsafe fn cleanup() {}\n-\n pub fn args() -> Args {\n     Args { iter: Vec::new().into_iter() }\n }"}, {"sha": "8705910c73a8180e2ca8ec09c25f67732bc6de40", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -35,8 +35,6 @@ pub mod path;\n pub mod pipe;\n #[path = \"../unsupported/process.rs\"]\n pub mod process;\n-#[path = \"../unsupported/stack_overflow.rs\"]\n-pub mod stack_overflow;\n #[path = \"../unsupported/stdio.rs\"]\n pub mod stdio;\n pub mod thread;"}, {"sha": "f1264130faf7abe64148586f4ab2ecd52efc365e", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -14,10 +14,6 @@ use crate::vec;\n \n use core::iter;\n \n-pub unsafe fn init(_argc: isize, _argv: *const *const u8) {}\n-\n-pub unsafe fn cleanup() {}\n-\n pub fn args() -> Args {\n     unsafe {\n         let lp_cmd_line = c::GetCommandLineW();"}, {"sha": "ddb6ac5f55c0d9684f5bc00a65a07d0072bef437", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -49,8 +49,17 @@ cfg_if::cfg_if! {\n     }\n }\n \n-#[cfg(not(test))]\n-pub fn init() {}\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+pub unsafe fn init(_argc: isize, _argv: *const *const u8) {\n+    stack_overflow::init();\n+}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+pub unsafe fn cleanup() {\n+    net::cleanup();\n+}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as c::DWORD {"}, {"sha": "1ad13254c0846f2e27bfd0a4793b906211ef991f", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -9,7 +9,7 @@ use crate::sync::Once;\n use crate::sys;\n use crate::sys::c;\n use crate::sys_common::net;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n use libc::{c_int, c_long, c_ulong, c_void};\n@@ -26,23 +26,28 @@ pub mod netc {\n \n pub struct Socket(c::SOCKET);\n \n+static INIT: Once = Once::new();\n+\n /// Checks whether the Windows socket interface has been started already, and\n /// if not, starts it.\n pub fn init() {\n-    static START: Once = Once::new();\n-\n-    START.call_once(|| unsafe {\n+    INIT.call_once(|| unsafe {\n         let mut data: c::WSADATA = mem::zeroed();\n         let ret = c::WSAStartup(\n             0x202, // version 2.2\n             &mut data,\n         );\n         assert_eq!(ret, 0);\n+    });\n+}\n \n-        let _ = sys_common::at_exit(|| {\n+pub fn cleanup() {\n+    if INIT.is_completed() {\n+        // only close the socket interface if it has actually been started\n+        unsafe {\n             c::WSACleanup();\n-        });\n-    });\n+        }\n+    }\n }\n \n /// Returns the last error from the Windows socket interface."}, {"sha": "39efb778207fc5386729b34ce9d4d8fecd7a6e7c", "filename": "library/std/src/sys/windows/stack_overflow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -37,5 +37,3 @@ pub unsafe fn init() {\n     // Set the thread stack guarantee for the main thread.\n     let _h = Handler::new();\n }\n-\n-pub unsafe fn cleanup() {}"}, {"sha": "afdf7f566ae515eb38b3a3c13ef56839a53c5a4b", "filename": "library/std/src/sys/windows/stack_overflow_uwp.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow_uwp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow_uwp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fstack_overflow_uwp.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -9,5 +9,3 @@ impl Handler {\n }\n \n pub unsafe fn init() {}\n-\n-pub unsafe fn cleanup() {}"}, {"sha": "90d5d3a78987fe6b289745fbc3490ab77af36a00", "filename": "library/std/src/sys_common/at_exit_imp.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs?ref=f7c468fe9a1448b1f6ceee6a4c831fe6122a54f0", "patch": "@@ -1,74 +0,0 @@\n-//! Implementation of running at_exit routines\n-//!\n-//! Documentation can be found on the `rt::at_exit` function.\n-\n-use crate::mem;\n-use crate::ptr;\n-use crate::sys_common::mutex::StaticMutex;\n-\n-type Queue = Vec<Box<dyn FnOnce()>>;\n-\n-// NB these are specifically not types from `std::sync` as they currently rely\n-// on poisoning and this module needs to operate at a lower level than requiring\n-// the thread infrastructure to be in place (useful on the borders of\n-// initialization/destruction).\n-// It is UB to attempt to acquire this mutex reentrantly!\n-static LOCK: StaticMutex = StaticMutex::new();\n-static mut QUEUE: *mut Queue = ptr::null_mut();\n-\n-const DONE: *mut Queue = 1_usize as *mut _;\n-\n-// The maximum number of times the cleanup routines will be run. While running\n-// the at_exit closures new ones may be registered, and this count is the number\n-// of times the new closures will be allowed to register successfully. After\n-// this number of iterations all new registrations will return `false`.\n-const ITERS: usize = 10;\n-\n-unsafe fn init() -> bool {\n-    if QUEUE.is_null() {\n-        let state: Box<Queue> = box Vec::new();\n-        QUEUE = Box::into_raw(state);\n-    } else if QUEUE == DONE {\n-        // can't re-init after a cleanup\n-        return false;\n-    }\n-\n-    true\n-}\n-\n-pub fn cleanup() {\n-    for i in 1..=ITERS {\n-        unsafe {\n-            let queue = {\n-                let _guard = LOCK.lock();\n-                mem::replace(&mut QUEUE, if i == ITERS { DONE } else { ptr::null_mut() })\n-            };\n-\n-            // make sure we're not recursively cleaning up\n-            assert!(queue != DONE);\n-\n-            // If we never called init, not need to cleanup!\n-            if !queue.is_null() {\n-                let queue: Box<Queue> = Box::from_raw(queue);\n-                for to_run in *queue {\n-                    // We are not holding any lock, so reentrancy is fine.\n-                    to_run();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn push(f: Box<dyn FnOnce()>) -> bool {\n-    unsafe {\n-        let _guard = LOCK.lock();\n-        if init() {\n-            // We are just moving `f` around, not calling it.\n-            // There is no possibility of reentrancy here.\n-            (*QUEUE).push(f);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "7fa6977f2af26dc04c10891c479b084bb19cc340", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -20,35 +20,6 @@\n #[cfg(test)]\n mod tests;\n \n-use crate::sync::Once;\n-use crate::sys;\n-\n-macro_rules! rtabort {\n-    ($($t:tt)*) => (crate::sys_common::util::abort(format_args!($($t)*)))\n-}\n-\n-macro_rules! rtassert {\n-    ($e:expr) => {\n-        if !$e {\n-            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n-        }\n-    };\n-}\n-\n-#[allow(unused_macros)] // not used on all platforms\n-macro_rules! rtunwrap {\n-    ($ok:ident, $e:expr) => {\n-        match $e {\n-            $ok(v) => v,\n-            ref err => {\n-                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n-                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n-            }\n-        }\n-    };\n-}\n-\n-pub mod at_exit_imp;\n pub mod backtrace;\n pub mod bytestring;\n pub mod condvar;\n@@ -61,6 +32,8 @@ pub mod mutex;\n pub mod os_str_bytes;\n pub mod process;\n pub mod remutex;\n+#[macro_use]\n+pub mod rt;\n pub mod rwlock;\n pub mod thread;\n pub mod thread_info;\n@@ -108,30 +81,6 @@ pub trait FromInner<Inner> {\n     fn from_inner(inner: Inner) -> Self;\n }\n \n-/// Enqueues a procedure to run when the main thread exits.\n-///\n-/// Currently these closures are only run once the main *Rust* thread exits.\n-/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n-/// infinitely so. Eventually a handler registration will be forced to fail.\n-///\n-/// Returns `Ok` if the handler was successfully registered, meaning that the\n-/// closure will be run once the main thread exits. Returns `Err` to indicate\n-/// that the closure could not be registered, meaning that it is not scheduled\n-/// to be run.\n-pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n-    if at_exit_imp::push(Box::new(f)) { Ok(()) } else { Err(()) }\n-}\n-\n-/// One-time runtime cleanup.\n-pub fn cleanup() {\n-    static CLEANUP: Once = Once::new();\n-    CLEANUP.call_once(|| unsafe {\n-        sys::args::cleanup();\n-        sys::stack_overflow::cleanup();\n-        at_exit_imp::cleanup();\n-    });\n-}\n-\n // Computes (value*numer)/denom without overflow, as long as both\n // (numer*denom) and the overall result fit into i64 (which is the case\n // for our time conversions)."}, {"sha": "c70f2ecc04e3a9caff6af4a1d49d045c4e7cf1ff", "filename": "library/std/src/sys_common/rt.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5da10c01214a3d3ebec65b8ba6effada92a0673f/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs?ref=5da10c01214a3d3ebec65b8ba6effada92a0673f", "patch": "@@ -0,0 +1,64 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n+use crate::sync::Once;\n+use crate::sys;\n+use crate::sys_common::thread_info;\n+use crate::thread::Thread;\n+\n+// One-time runtime initialization.\n+// Runs before `main`.\n+// SAFETY: must be called only once during runtime initialization.\n+// NOTE: this is not guaranteed to run, for example when Rust code is called externally.\n+#[cfg_attr(test, allow(dead_code))]\n+pub unsafe fn init(argc: isize, argv: *const *const u8) {\n+    unsafe {\n+        sys::init(argc, argv);\n+\n+        let main_guard = sys::thread::guard::init();\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread = Thread::new(Some(\"main\".to_owned()));\n+        thread_info::set(main_guard, thread);\n+    }\n+}\n+\n+// One-time runtime cleanup.\n+// Runs after `main` or at program exit.\n+// NOTE: this is not guaranteed to run, for example when the program aborts.\n+#[cfg_attr(test, allow(dead_code))]\n+pub fn cleanup() {\n+    static CLEANUP: Once = Once::new();\n+    CLEANUP.call_once(|| unsafe {\n+        // Flush stdout and disable buffering.\n+        crate::io::cleanup();\n+        // SAFETY: Only called once during runtime cleanup.\n+        sys::cleanup();\n+    });\n+}\n+\n+macro_rules! rtabort {\n+    ($($t:tt)*) => (crate::sys_common::util::abort(format_args!($($t)*)))\n+}\n+\n+macro_rules! rtassert {\n+    ($e:expr) => {\n+        if !$e {\n+            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n+        }\n+    };\n+}\n+\n+#[allow(unused_macros)] // not used on all platforms\n+macro_rules! rtunwrap {\n+    ($ok:ident, $e:expr) => {\n+        match $e {\n+            $ok(v) => v,\n+            ref err => {\n+                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n+                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n+            }\n+        }\n+    };\n+}"}]}