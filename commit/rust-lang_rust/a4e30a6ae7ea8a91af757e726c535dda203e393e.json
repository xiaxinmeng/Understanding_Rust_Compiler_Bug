{"sha": "a4e30a6ae7ea8a91af757e726c535dda203e393e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZTMwYTZhZTdlYThhOTFhZjc1N2U3MjZjNTM1ZGRhMjAzZTM5M2U=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-09-03T00:22:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-03T00:22:06Z"}, "message": "Rollup merge of #76167 - mati865:mingw-self-contained-heuristic, r=petrochenkov\n\nReplace MinGW library hack with heuristic controlling link mode\n\nDepends on https://github.com/rust-lang/rust/pull/76158\nCloses https://github.com/rust-lang/rust/issues/68887", "tree": {"sha": "d109a7ede228987ed290e0d7982c6a705286dc0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d109a7ede228987ed290e0d7982c6a705286dc0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4e30a6ae7ea8a91af757e726c535dda203e393e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfUDcuCRBK7hj4Ov3rIwAAdHIIADLLoYaMuctb7lXDIntFN1Xh\ngYKpOiAii0ZWQVEM+l1NQTRnM7L4zddkLUxG3sxyFV9gJ/uH4+7+08f4SAc1xe4Y\nh0tQ2/vGYyxHC+q8E3iQSShD5U/ak3ESHchavUoDpzRujDBur2eVYArQwDJKisXk\nuIgygwgVAdVRI0pT14ujTix4K1yQ9ivye4FVeRdMRXBlwQB7HjL+tNiV/gZG52Lb\nPcL/ZotDjhizqnQpuAbxSJ0LKn+D3V6GILQVZKvFywA+k4GOAG8i7V/yyKupxCA+\nTvxoiqshq9OPWBSRyxnjWOTKBCmcOkdOE6SiQLnWaXT2LoNT0bZWYl1hdpfpWUk=\n=hMRd\n-----END PGP SIGNATURE-----\n", "payload": "tree d109a7ede228987ed290e0d7982c6a705286dc0c\nparent 3e156cfe90ae883a82e4fc3e62945542ae2033b0\nparent 770231e54d0266406791bab1fda7e300d074ebda\nauthor Dylan DPC <dylan.dpc@gmail.com> 1599092526 +0200\ncommitter GitHub <noreply@github.com> 1599092526 +0200\n\nRollup merge of #76167 - mati865:mingw-self-contained-heuristic, r=petrochenkov\n\nReplace MinGW library hack with heuristic controlling link mode\n\nDepends on https://github.com/rust-lang/rust/pull/76158\nCloses https://github.com/rust-lang/rust/issues/68887\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4e30a6ae7ea8a91af757e726c535dda203e393e", "html_url": "https://github.com/rust-lang/rust/commit/a4e30a6ae7ea8a91af757e726c535dda203e393e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4e30a6ae7ea8a91af757e726c535dda203e393e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e156cfe90ae883a82e4fc3e62945542ae2033b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e156cfe90ae883a82e4fc3e62945542ae2033b0", "html_url": "https://github.com/rust-lang/rust/commit/3e156cfe90ae883a82e4fc3e62945542ae2033b0"}, {"sha": "770231e54d0266406791bab1fda7e300d074ebda", "url": "https://api.github.com/repos/rust-lang/rust/commits/770231e54d0266406791bab1fda7e300d074ebda", "html_url": "https://github.com/rust-lang/rust/commit/770231e54d0266406791bab1fda7e300d074ebda"}], "stats": {"total": 117, "additions": 25, "deletions": 92}, "files": [{"sha": "c044020d9301b05ca70ab16d5de0c64ebb7e41d6", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 25, "deletions": 92, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/a4e30a6ae7ea8a91af757e726c535dda203e393e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4e30a6ae7ea8a91af757e726c535dda203e393e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=a4e30a6ae7ea8a91af757e726c535dda203e393e", "patch": "@@ -1014,86 +1014,7 @@ fn print_native_static_libs(sess: &Session, all_native_libs: &[NativeLib]) {\n     }\n }\n \n-// Because windows-gnu target is meant to be self-contained for pure Rust code it bundles\n-// own mingw-w64 libraries. These libraries are usually not compatible with mingw-w64\n-// installed in the system. This breaks many cases where Rust is mixed with other languages\n-// (e.g. *-sys crates).\n-// We prefer system mingw-w64 libraries if they are available to avoid this issue.\n-fn get_crt_libs_path(sess: &Session) -> Option<PathBuf> {\n-    fn find_exe_in_path<P>(exe_name: P) -> Option<PathBuf>\n-    where\n-        P: AsRef<Path>,\n-    {\n-        for dir in env::split_paths(&env::var_os(\"PATH\")?) {\n-            let full_path = dir.join(&exe_name);\n-            if full_path.is_file() {\n-                return Some(fix_windows_verbatim_for_gcc(&full_path));\n-            }\n-        }\n-        None\n-    }\n-\n-    fn probe(sess: &Session) -> Option<PathBuf> {\n-        if let (linker, LinkerFlavor::Gcc) = linker_and_flavor(&sess) {\n-            let linker_path = if cfg!(windows) && linker.extension().is_none() {\n-                linker.with_extension(\"exe\")\n-            } else {\n-                linker\n-            };\n-            if let Some(linker_path) = find_exe_in_path(linker_path) {\n-                let mingw_arch = match &sess.target.target.arch {\n-                    x if x == \"x86\" => \"i686\",\n-                    x => x,\n-                };\n-                let mingw_bits = &sess.target.target.target_pointer_width;\n-                let mingw_dir = format!(\"{}-w64-mingw32\", mingw_arch);\n-                // Here we have path/bin/gcc but we need path/\n-                let mut path = linker_path;\n-                path.pop();\n-                path.pop();\n-                // Loosely based on Clang MinGW driver\n-                let probe_paths = vec![\n-                    path.join(&mingw_dir).join(\"lib\"),                // Typical path\n-                    path.join(&mingw_dir).join(\"sys-root/mingw/lib\"), // Rare path\n-                    path.join(format!(\n-                        \"lib/mingw/tools/install/mingw{}/{}/lib\",\n-                        &mingw_bits, &mingw_dir\n-                    )), // Chocolatey is creative\n-                ];\n-                for probe_path in probe_paths {\n-                    if probe_path.join(\"crt2.o\").exists() {\n-                        return Some(probe_path);\n-                    };\n-                }\n-            };\n-        };\n-        None\n-    }\n-\n-    let mut system_library_path = sess.system_library_path.borrow_mut();\n-    match &*system_library_path {\n-        Some(Some(compiler_libs_path)) => Some(compiler_libs_path.clone()),\n-        Some(None) => None,\n-        None => {\n-            let path = probe(sess);\n-            *system_library_path = Some(path.clone());\n-            path\n-        }\n-    }\n-}\n-\n fn get_object_file_path(sess: &Session, name: &str, self_contained: bool) -> PathBuf {\n-    // prefer system {,dll}crt2.o libs, see get_crt_libs_path comment for more details\n-    if sess.opts.cg.link_self_contained.is_none()\n-        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n-    {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            let file_path = compiler_libs_path.join(name);\n-            if file_path.exists() {\n-                return file_path;\n-            }\n-        }\n-    }\n     let fs = sess.target_filesearch(PathKind::Native);\n     let file_path = fs.get_lib_path().join(name);\n     if file_path.exists() {\n@@ -1286,6 +1207,28 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     }\n }\n \n+// Returns true if linker is located within sysroot\n+fn detect_self_contained_mingw(sess: &Session) -> bool {\n+    let (linker, _) = linker_and_flavor(&sess);\n+    // Assume `-C linker=rust-lld` as self-contained mode\n+    if linker == Path::new(\"rust-lld\") {\n+        return true;\n+    }\n+    let linker_with_extension = if cfg!(windows) && linker.extension().is_none() {\n+        linker.with_extension(\"exe\")\n+    } else {\n+        linker\n+    };\n+    for dir in env::split_paths(&env::var_os(\"PATH\").unwrap_or_default()) {\n+        let full_path = dir.join(&linker_with_extension);\n+        // If linker comes from sysroot assume self-contained mode\n+        if full_path.is_file() && !full_path.starts_with(&sess.sysroot) {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n /// Whether we link to our own CRT objects instead of relying on gcc to pull them.\n /// We only provide such support for a very limited number of targets.\n fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n@@ -1298,10 +1241,10 @@ fn crt_objects_fallback(sess: &Session, crate_type: CrateType) -> bool {\n         // based on host and linker path, for example.\n         // (https://github.com/rust-lang/rust/pull/71769#issuecomment-626330237).\n         Some(CrtObjectsFallback::Musl) => sess.crt_static(Some(crate_type)),\n-        // FIXME: Find some heuristic for \"native mingw toolchain is available\",\n-        // likely based on `get_crt_libs_path` (https://github.com/rust-lang/rust/pull/67429).\n         Some(CrtObjectsFallback::Mingw) => {\n-            sess.host == sess.target.target && sess.target.target.target_vendor != \"uwp\"\n+            sess.host == sess.target.target\n+                && sess.target.target.target_vendor != \"uwp\"\n+                && detect_self_contained_mingw(&sess)\n         }\n         // FIXME: Figure out cases in which WASM needs to link with a native toolchain.\n         Some(CrtObjectsFallback::Wasm) => true,\n@@ -1498,16 +1441,6 @@ fn link_local_crate_native_libs_and_dependent_crate_libs<'a, B: ArchiveBuilder<'\n \n /// Add sysroot and other globally set directories to the directory search list.\n fn add_library_search_dirs(cmd: &mut dyn Linker, sess: &Session, self_contained: bool) {\n-    // Prefer system mingw-w64 libs, see get_crt_libs_path comment for more details.\n-    if sess.opts.cg.link_self_contained.is_none()\n-        && cfg!(windows)\n-        && sess.target.target.llvm_target.contains(\"windows-gnu\")\n-    {\n-        if let Some(compiler_libs_path) = get_crt_libs_path(sess) {\n-            cmd.include_path(&compiler_libs_path);\n-        }\n-    }\n-\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     let lib_path = sess.target_filesearch(PathKind::All).get_lib_path();"}]}