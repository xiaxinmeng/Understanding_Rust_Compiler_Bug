{"sha": "cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmYzY1OTAwOWU3ZWIyM2RmYjZhZDRjNDllODM2Y2FkOWYzNTBjNjE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-05T06:29:15Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-06T18:09:07Z"}, "message": "rustc: Move middle::tstate::auxiliary and middle::tstate::bitvectors over to interior vectors", "tree": {"sha": "930c459767a39e0332d0314e2a348c261eda8ae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/930c459767a39e0332d0314e2a348c261eda8ae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "html_url": "https://github.com/rust-lang/rust/commit/cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702f88a3bee11d1a09541093280ef27a1453710b", "url": "https://api.github.com/repos/rust-lang/rust/commits/702f88a3bee11d1a09541093280ef27a1453710b", "html_url": "https://github.com/rust-lang/rust/commit/702f88a3bee11d1a09541093280ef27a1453710b"}], "stats": {"total": 254, "additions": 131, "deletions": 123}, "files": [{"sha": "861a0a945b6b5d9a67a5f61af1c7036b0dcba8ee", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "patch": "@@ -1,3 +1,4 @@\n+import std::ivec;\n import std::str;\n import std::vec;\n import std::vec::len;\n@@ -48,7 +49,7 @@ fn def_id_to_str(def_id d) -> str {\n     ret int::str(d._0) + \",\" + int::str(d._1);\n }\n \n-fn comma_str(vec[@constr_arg_use] args) -> str {\n+fn comma_str(&(@constr_arg_use)[] args) -> str {\n     auto rslt = \"\";\n     auto comma = false;\n     for (@constr_arg_use a in args) {\n@@ -107,17 +108,17 @@ fn first_difference_string(&fn_ctxt fcx, &tritv::t expected, &tritv::t actual)\n \n fn log_tritv_err(fn_ctxt fcx, tritv::t v) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(vec[uint] v) -> str {\n+fn tos(&uint[] v) -> str {\n     auto rslt = \"\";\n     for (uint i in v) { if (i == 0u) { rslt += \"0\"; } \n         else if (i == 1u) { rslt += \"1\"; }\n         else { rslt += \"?\"; } }\n     ret rslt;\n }\n \n-fn log_cond(vec[uint] v) { log tos(v); }\n+fn log_cond(&uint[] v) { log tos(v); }\n \n-fn log_cond_err(vec[uint] v) { log_err tos(v); }\n+fn log_cond_err(&uint[] v) { log_err tos(v); }\n \n fn log_pp(&pre_and_post pp) {\n     auto p1 = tritv::to_vec(pp.precondition);\n@@ -157,10 +158,10 @@ fn log_states_err(&pre_and_post_state pp) {\n \n fn print_ident(&ident i) { log \" \" + i + \" \"; }\n \n-fn print_idents(vec[ident] idents) {\n-    if (len[ident](idents) == 0u) {\n-        ret;\n-    } else { log \"an ident: \" + pop[ident](idents); print_idents(idents); }\n+fn print_idents(&mutable ident[] idents) {\n+    if (ivec::len[ident](idents) == 0u) { ret; }\n+    log \"an ident: \" + ivec::pop[ident](idents);\n+    print_idents(idents);\n }\n \n \n@@ -194,18 +195,21 @@ to represent predicate *arguments* however. This type\n \n Both types store an ident and span, for error-logging purposes.\n */\n-type pred_desc_ = rec(vec[@constr_arg_use] args, uint bit_num);\n+type pred_desc_ = rec((@constr_arg_use)[] args, uint bit_num);\n \n type pred_desc = spanned[pred_desc_];\n \n type constr_arg_use = constr_arg_general[tup(ident, def_id)];\n \n tag constraint {\n     cinit(uint, span, ident);\n-    cpred(path, @mutable vec[pred_desc]);\n+    cpred(path, @mutable pred_desc[]);\n }\n \n-tag constr__ { ninit(ident); npred(path, vec[@constr_arg_use]); }\n+tag constr__ {\n+    ninit(ident);\n+    npred(path, (@constr_arg_use)[]);\n+}\n \n type constr_ = rec(node_id id, constr__ c);\n \n@@ -223,11 +227,11 @@ type fn_info = rec(constr_map constrs,\n                     used*/\n                    // Doesn't seem to work without the @ --\n                    // bug?\n-                   @mutable vec[node_id] used_vars);\n+                   @mutable node_id[] used_vars);\n \n \n /* mapping from node ID to typestate annotation */\n-type node_ann_table = @mutable vec[mutable ts_ann];\n+type node_ann_table = @mutable ts_ann[mutable];\n \n \n /* mapping from function name to fn_info map */\n@@ -243,15 +247,15 @@ fn get_fn_info(&crate_ctxt ccx, node_id id) -> fn_info {\n }\n \n fn add_node(&crate_ctxt ccx, node_id i, &ts_ann a) {\n-    auto sz = len(*ccx.node_anns);\n+    auto sz = ivec::len(*ccx.node_anns);\n     if (sz <= i as uint) {\n-        grow(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n+        ivec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n     }\n     ccx.node_anns.(i) = a;\n }\n \n fn get_ts_ann(&crate_ctxt ccx, node_id i) -> option::t[ts_ann] {\n-    if (i as uint < len(*ccx.node_anns)) {\n+    if (i as uint < ivec::len(*ccx.node_anns)) {\n         ret some[ts_ann](ccx.node_anns.(i));\n     } else { ret none[ts_ann]; }\n }\n@@ -439,7 +443,7 @@ fn pure_exp(&crate_ctxt ccx, node_id id, &prestate p) -> bool {\n fn num_constraints(fn_info m) -> uint { ret m.num_constraints; }\n \n fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n-    let vec[mutable ts_ann] na = vec::empty_mut();\n+    let ts_ann[mutable] na = ~[mutable];\n     ret rec(tcx=cx, node_anns=@mutable na, fm=@new_int_hash[fn_info]());\n }\n \n@@ -474,19 +478,18 @@ fn node_id_to_def(&crate_ctxt ccx, node_id id) -> option::t[def] {\n     ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(node_id id, &constraint c) -> vec[norm_constraint] {\n+fn norm_a_constraint(node_id id, &constraint c) -> norm_constraint[] {\n     alt (c) {\n         case (cinit(?n, ?sp, ?i)) {\n-            ret [rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n+            ret ~[rec(bit_num=n, c=respan(sp, rec(id=id, c=ninit(i))))];\n         }\n         case (cpred(?p, ?descs)) {\n-            let vec[norm_constraint] rslt = [];\n+            let norm_constraint[] rslt = ~[];\n             for (pred_desc pd in *descs) {\n-                vec::push(rslt,\n-                          rec(bit_num=pd.node.bit_num,\n+                rslt += ~[rec(bit_num=pd.node.bit_num,\n                               c=respan(pd.span,\n                                        rec(id=id,\n-                                           c=npred(p, pd.node.args)))));\n+                                           c=npred(p, pd.node.args))))];\n             }\n             ret rslt;\n         }\n@@ -496,15 +499,15 @@ fn norm_a_constraint(node_id id, &constraint c) -> vec[norm_constraint] {\n \n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n-fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n-    let vec[norm_constraint] rslt = [];\n+fn constraints(&fn_ctxt fcx) -> norm_constraint[] {\n+    let norm_constraint[] rslt = ~[];\n     for each (@tup(node_id, constraint) p in fcx.enclosing.constrs.items()) {\n         rslt += norm_a_constraint(p._0, p._1);\n     }\n     ret rslt;\n }\n \n-fn match_args(&fn_ctxt fcx, vec[pred_desc] occs, &(@constr_arg_use)[] occ) ->\n+fn match_args(&fn_ctxt fcx, &pred_desc[] occs, &(@constr_arg_use)[] occ) ->\n    uint {\n     log \"match_args: looking at \" +\n         constr_args_to_str(std::util::fst[ident, def_id], occ);\n@@ -564,10 +567,10 @@ fn expr_to_constr_arg(ty::ctxt tcx, &@expr e) -> @constr_arg_use {\n     }\n }\n \n-fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) ->\n-   vec[@constr_arg_use] {\n+fn exprs_to_constr_args(ty::ctxt tcx, &(@expr)[] args)\n+        -> (@constr_arg_use)[] {\n     auto f = bind expr_to_constr_arg(tcx, _);\n-    ret vec::map(f, args);\n+    ret ivec::map(f, args);\n }\n \n fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n@@ -578,10 +581,14 @@ fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constr {\n              expr_call(?operator, ?args)) {\n             alt (operator.node) {\n                 case (expr_path(?p)) {\n+                    // FIXME: Remove this vec->ivec conversion.\n+                    auto args_ivec = ~[];\n+                    for (@expr e in args) { args_ivec += ~[e]; }\n+\n                     ret respan(e.span,\n                                rec(id=node_id_for_constr(tcx, operator.id),\n-                                   c=npred(p,\n-                                           exprs_to_constr_args(tcx, args))));\n+                                   c=npred(p, exprs_to_constr_args(tcx,\n+                                        args_ivec))));\n                 }\n                 case (_) {\n                     tcx.sess.span_fatal(operator.span,\n@@ -609,20 +616,20 @@ fn pred_desc_to_str(&pred_desc p) -> str {\n         constr_args_to_str(std::util::fst[ident, def_id], cau_ivec) + \">\";\n }\n \n-fn substitute_constr_args(&ty::ctxt cx, &vec[@expr] actuals,\n+fn substitute_constr_args(&ty::ctxt cx, &(@expr)[] actuals,\n                           &@ty::constr_def c) -> constr__ {\n-    let vec[@constr_arg_use] rslt = [];\n+    let (@constr_arg_use)[] rslt = ~[];\n     for (@constr_arg a in c.node.args) {\n-        rslt += [substitute_arg(cx, actuals, a)];\n+        rslt += ~[substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, rslt);\n }\n \n-type subst = vec[tup(arg, @expr)];\n+type subst = tup(arg, @expr)[];\n \n-fn substitute_arg(&ty::ctxt cx, &vec[@expr] actuals, @constr_arg a) ->\n+fn substitute_arg(&ty::ctxt cx, &(@expr)[] actuals, @constr_arg a) ->\n    @constr_arg_use {\n-    auto num_actuals = vec::len(actuals);\n+    auto num_actuals = ivec::len(actuals);\n     alt (a.node) {\n         case (carg_ident(?i)) {\n             if (i < num_actuals) {\n@@ -778,26 +785,28 @@ fn non_init_constraint_mentions(&fn_ctxt fcx, &norm_constraint c,\n }\n \n \n-fn args_mention(&vec[@constr_arg_use] args, &def_id v) -> bool {\n+fn args_mention(&(@constr_arg_use)[] args, &def_id v) -> bool {\n     fn mentions(&def_id v, &@constr_arg_use a) -> bool {\n         alt (a.node) {\n             case (carg_ident(?p1)) { p1._1 == v }\n             case (_)               { false }\n         }\n     }\n-    ret util::common::any[@constr_arg_use](bind mentions(v,_), args);\n+    ret ivec::any[@constr_arg_use](bind mentions(v,_), args);\n }\n \n fn use_var(&fn_ctxt fcx, &node_id v) {\n-    vec::push(*fcx.enclosing.used_vars, v);\n+    *fcx.enclosing.used_vars += ~[v];\n }\n \n-fn vec_contains(&@mutable vec[node_id] v, &node_id i) -> bool {\n+// FIXME: This should be a function in std::ivec::.\n+fn vec_contains(&@mutable (node_id[]) v, &node_id i) -> bool {\n     for (node_id d in *v) {\n         if (d == i) { ret true; }\n     }\n     ret false;\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "4353ef56cd4414480b249179927b040f2478939e", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "patch": "@@ -1,10 +1,9 @@\n \n import syntax::ast::*;\n import syntax::walk;\n+import std::ivec;\n import std::option::*;\n import std::vec;\n-import std::vec::len;\n-import std::vec::slice;\n import aux::constr_arg_use;\n import aux::local_node_id_to_def;\n import aux::fn_ctxt;\n@@ -70,7 +69,8 @@ fn bit_num(&fn_ctxt fcx, &constr_ c) -> uint {\n                     for (@constr_arg_use cau in args) {\n                         cau_ivec += ~[cau];\n                     }\n-                    ret match_args(fcx, *descs, cau_ivec);\n+                    auto d = *descs;\n+                    ret match_args(fcx, d, cau_ivec);\n                 }\n                 case (_) {\n                     fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n@@ -106,11 +106,11 @@ fn seq_tritv(&postcond p, &postcond q) {\n     }\n }\n \n-fn seq_postconds(&fn_ctxt fcx, &vec[postcond] ps) -> postcond {\n-    auto sz = vec::len(ps);\n+fn seq_postconds(&fn_ctxt fcx, &postcond[] ps) -> postcond {\n+    auto sz = ivec::len(ps);\n     if (sz >= 1u) {\n         auto prev = tritv_clone(ps.(0));\n-        for (postcond p in slice(ps, 1u, sz)) {\n+        for (postcond p in ivec::slice(ps, 1u, sz)) {\n             seq_tritv(prev, p);\n         }\n         ret prev;\n@@ -124,14 +124,14 @@ fn seq_postconds(&fn_ctxt fcx, &vec[postcond] ps) -> postcond {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(&fn_ctxt fcx, &vec[pre_and_post] pps) -> precond {\n-    let uint sz = len(pps);\n+fn seq_preconds(&fn_ctxt fcx, &pre_and_post[] pps) -> precond {\n+    let uint sz = ivec::len(pps);\n     let uint num_vars = num_constraints(fcx.enclosing);\n \n-    fn seq_preconds_go(&fn_ctxt fcx, &vec[pre_and_post] pps,\n+    fn seq_preconds_go(&fn_ctxt fcx, &pre_and_post[] pps,\n                        &pre_and_post first)\n         -> precond {\n-        let uint sz = len(pps);\n+        let uint sz = ivec::len(pps);\n         if (sz >= 1u) {\n             auto second = pps.(0);\n             assert (pps_len(second) == num_constraints(fcx.enclosing));\n@@ -141,7 +141,7 @@ fn seq_preconds(&fn_ctxt fcx, &vec[pre_and_post] pps) -> precond {\n             union(next_first, second_pre);\n             auto next_first_post = clone(first.postcondition);\n             seq_tritv(next_first_post, second.postcondition); \n-            ret seq_preconds_go(fcx, slice(pps, 1u, sz), \n+            ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz),\n                                 @rec(precondition=next_first,\n                                      postcondition=next_first_post));\n         }\n@@ -153,7 +153,7 @@ fn seq_preconds(&fn_ctxt fcx, &vec[pre_and_post] pps) -> precond {\n     if (sz >= 1u) {\n         auto first = pps.(0);\n         assert (pps_len(first) == num_vars);\n-        ret seq_preconds_go(fcx, slice(pps, 1u, sz), first);\n+        ret seq_preconds_go(fcx, ivec::slice(pps, 1u, sz), first);\n     } else { ret true_precond(num_vars); }\n }\n "}, {"sha": "4a190b6f6ae32eded3892e9ad60236cb2555766f", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "patch": "@@ -46,11 +46,15 @@ fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n         // If it's a call, generate appropriate instances of the\n         // call's constraints.\n         case (expr_call(?operator, ?operands)) {\n+            // FIXME: Remove this vec->ivec conversion.\n+            auto operands_ivec = ~[];\n+            for (@expr opd in operands) { operands_ivec += ~[opd]; }\n+\n             for (@ty::constr_def c in constraints_expr(cx.tcx, operator)) {\n                 let aux::constr ct = respan(c.span,\n                       rec(id=c.node.id._1,\n                           c=aux::substitute_constr_args(cx.tcx,\n-                                                        operands, c)));\n+                                                        operands_ivec, c)));\n                 vec::push(*cx.cs, ct);\n             }\n         }\n@@ -93,18 +97,17 @@ fn add_constraint(&ty::ctxt tcx, aux::constr c, uint next, constr_map tbl) ->\n                                              \" as a variable and a pred\");\n                         }\n                         case (cpred(_, ?pds)) {\n-                            vec::push(*pds,\n-                                      respan(c.span,\n-                                             rec(args=args, bit_num=next)));\n+                            *pds += ~[respan(c.span,\n+                                             rec(args=args, bit_num=next))];\n                         }\n                     }\n                 }\n                 case (none) {\n                     tbl.insert(c.node.id,\n                                cpred(p,\n-                                     @mutable [respan(c.span,\n-                                                      rec(args=args,\n-                                                          bit_num=next))]));\n+                                     @mutable ~[respan(c.span,\n+                                                       rec(args=args,\n+                                                           bit_num=next))]));\n                 }\n             }\n         }\n@@ -134,7 +137,7 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &vec[ty_param] tp,\n     auto name = fn_ident_to_string(id, f_name);\n     add_constraint(cx.tcx, respan(f_sp, rec(id=id, c=ninit(name))), next,\n                    res_map);\n-    let @mutable vec[node_id] v = @mutable [];\n+    let @mutable node_id[] v = @mutable ~[];\n     auto rslt =\n         rec(constrs=res_map,\n             num_constraints=vec::len(*cx.cs) + 1u,"}, {"sha": "84ec3ddf552bc6b46731ce9d615cea801cc13b4a", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 55, "deletions": 59, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "patch": "@@ -1,4 +1,5 @@\n \n+import std::ivec;\n import std::vec;\n import std::vec::plus_option;\n import std::option;\n@@ -110,7 +111,7 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) {\n     alt (i.node) {\n         case (item_const(_, ?e)) {\n             // make a fake fcx\n-            let @mutable vec[node_id] v = @mutable [];\n+            let @mutable node_id[] v = @mutable ~[];\n             auto fake_fcx =\n                 rec(enclosing=rec(constrs=@new_int_hash[constraint](),\n                                   num_constraints=0u,\n@@ -163,9 +164,13 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, node_id id) {\n     }\n     auto g = bind get_pp(fcx.ccx, _);\n     auto pps = vec::map[@expr, pre_and_post](g, args);\n-    auto h = get_post;\n-    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps),\n-                     seq_postconds(fcx, vec::map(h, pps)));\n+\n+    // TODO: Remove this vec->ivec conversion.\n+    auto pps_ivec = ~[];\n+    for (pre_and_post pp in pps) { pps_ivec += ~[pp]; }\n+\n+    set_pre_and_post(fcx.ccx, id, seq_preconds(fcx, pps_ivec),\n+                     seq_postconds(fcx, ivec::map(get_post, pps_ivec)));\n }\n \n fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n@@ -179,10 +184,8 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n     // so we pretend they're used\n     use_var(fcx, l.node.id);\n \n-    auto loop_precond =\n-        seq_preconds(fcx,\n-                     [expr_pp(fcx.ccx, index),\n-                      block_pp(fcx.ccx, body)]);\n+    auto loop_precond = seq_preconds(fcx, ~[expr_pp(fcx.ccx, index),\n+                                            block_pp(fcx.ccx, body)]);\n     auto loop_postcond = intersect_states(expr_postcond(fcx.ccx, index),\n                                           block_postcond(fcx.ccx, body));\n     copy_pre_post_(fcx.ccx, id, loop_precond, loop_postcond);\n@@ -205,10 +208,8 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 case (_) {}\n             }\n \n-            auto precond_res =\n-                seq_preconds(fcx,\n-                             [expr_pp(fcx.ccx, antec),\n-                              block_pp(fcx.ccx, conseq)]);\n+            auto precond_res = seq_preconds(fcx,\n+                ~[expr_pp(fcx.ccx, antec), block_pp(fcx.ccx, conseq)]);\n             set_pre_and_post(fcx.ccx, id, precond_res,\n                              expr_poststate(fcx.ccx, antec));\n         }\n@@ -219,13 +220,11 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n               is *not* true in the alternative\n              */\n             find_pre_post_expr(fcx, altern);\n-            auto precond_false_case =\n-                seq_preconds(fcx,\n-                             [expr_pp(fcx.ccx, antec),\n-                              expr_pp(fcx.ccx, altern)]);\n-            auto postcond_false_case =\n-                seq_postconds(fcx, [expr_postcond(fcx.ccx, antec),\n-                                    expr_postcond(fcx.ccx, altern)]);\n+            auto precond_false_case = seq_preconds(fcx,\n+                ~[expr_pp(fcx.ccx, antec), expr_pp(fcx.ccx, altern)]);\n+            auto postcond_false_case = seq_postconds(fcx,\n+                ~[expr_postcond(fcx.ccx, antec),\n+                  expr_postcond(fcx.ccx, altern)]);\n \n             /* Be sure to set the bit for the check condition here,\n              so that it's *not* set in the alternative. */\n@@ -236,17 +235,14 @@ fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                 }\n                 case (_) {}\n             }\n-            auto precond_true_case =\n-                seq_preconds(fcx,\n-                             [expr_pp(fcx.ccx, antec),\n-                              block_pp(fcx.ccx, conseq)]);\n-            auto postcond_true_case =\n-                seq_postconds(fcx, [expr_postcond(fcx.ccx, antec),\n-                                    block_postcond(fcx.ccx, conseq)]);\n-\n-            auto precond_res =\n-                seq_postconds(fcx, [precond_true_case,\n-                                    precond_false_case]);\n+            auto precond_true_case = seq_preconds(fcx,\n+                ~[expr_pp(fcx.ccx, antec), block_pp(fcx.ccx, conseq)]);\n+            auto postcond_true_case = seq_postconds(fcx,\n+                ~[expr_postcond(fcx.ccx, antec),\n+                  block_postcond(fcx.ccx, conseq)]);\n+\n+            auto precond_res = seq_postconds(fcx, ~[precond_true_case,\n+                                                    precond_false_case]);\n             auto postcond_res =\n                 intersect_states(postcond_true_case, postcond_false_case);\n             set_pre_and_post(fcx.ccx, id, precond_res, postcond_res);\n@@ -286,6 +282,11 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n         case (expr_call(?operator, ?operands)) {\n             auto args = vec::clone(operands);\n             vec::push(args, operator);\n+\n+            // TODO: Remove this vec->ivec conversion.\n+            auto operands_ivec = ~[];\n+            for (@expr e in operands) { operands_ivec += ~[e]; }\n+\n             find_pre_post_exprs(fcx, args, e.id);\n             /* see if the call has any constraints on its type */\n             for (@ty::constr_def c in constraints_expr(fcx.ccx.tcx, operator))\n@@ -294,7 +295,8 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                         bit_num(fcx,\n                                 rec(id=c.node.id._1,\n                                     c=substitute_constr_args(fcx.ccx.tcx,\n-                                                             operands, c)));\n+                                                             operands_ivec,\n+                                                             c)));\n                     require(i, expr_pp(fcx.ccx, e));\n                 }\n \n@@ -440,7 +442,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n                 find_pre_post_expr(fcx, l);\n                 find_pre_post_expr(fcx, r);\n                 auto overall_pre = seq_preconds(fcx,\n-                   [expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n+                   ~[expr_pp(fcx.ccx, l), expr_pp(fcx.ccx, r)]);\n                 set_precondition(node_id_to_ts_ann(fcx.ccx, e.id),\n                                  overall_pre);\n                 set_postcondition(node_id_to_ts_ann(fcx.ccx, e.id),\n@@ -465,29 +467,27 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             find_pre_post_expr(fcx, test);\n             find_pre_post_block(fcx, body);\n             set_pre_and_post(fcx.ccx, e.id,\n-                             seq_preconds(fcx,\n-                                          [expr_pp(fcx.ccx, test),\n-                                           block_pp(fcx.ccx, body)]),\n+                             seq_preconds(fcx, ~[expr_pp(fcx.ccx, test),\n+                                                 block_pp(fcx.ccx, body)]),\n                              intersect_states(expr_postcond(fcx.ccx, test),\n-                                              block_postcond(fcx.ccx,\n-                                                             body)));\n+                                              block_postcond(fcx.ccx, body)));\n         }\n         case (expr_do_while(?body, ?test)) {\n             find_pre_post_block(fcx, body);\n             find_pre_post_expr(fcx, test);\n-            auto loop_postcond =\n-                seq_postconds(fcx, [block_postcond(fcx.ccx, body),\n-                                    expr_postcond(fcx.ccx, test)]);\n-            /* conservative approximination: if the body\n+            auto loop_postcond = seq_postconds(fcx,\n+                ~[block_postcond(fcx.ccx, body),\n+                  expr_postcond(fcx.ccx, test)]);\n+            /* conservative approximation: if the body\n                could break or cont, the test may never be executed */\n \n             if (has_nonlocal_exits(body)) {\n                 loop_postcond = empty_poststate(num_local_vars);\n             }\n             set_pre_and_post(fcx.ccx, e.id,\n                              seq_preconds(fcx,\n-                                          [block_pp(fcx.ccx, body),\n-                                           expr_pp(fcx.ccx, test)]),\n+                                          ~[block_pp(fcx.ccx, body),\n+                                            expr_pp(fcx.ccx, test)]),\n                              loop_postcond);\n         }\n         case (expr_for(?d, ?index, ?body)) {\n@@ -509,7 +509,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n             auto alt_pps = vec::map[arm, pre_and_post](f, alts);\n             fn combine_pp(pre_and_post antec, fn_ctxt fcx, &pre_and_post pp,\n                           &pre_and_post next) -> pre_and_post {\n-                union(pp.precondition, seq_preconds(fcx, [antec, next]));\n+                union(pp.precondition, seq_preconds(fcx, ~[antec, next]));\n                 intersect(pp.postcondition, next.postcondition);\n                 ret pp;\n             }\n@@ -664,27 +664,23 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) {\n     fn do_inner_(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     auto do_inner = bind do_inner_(fcx, _);\n     option::map[@expr, ()](do_inner, b.node.expr);\n-    let vec[pre_and_post] pps = [];\n-    fn get_pp_stmt(crate_ctxt ccx, &@stmt s) -> pre_and_post {\n-        ret stmt_pp(ccx, *s);\n-    }\n-    auto f = bind get_pp_stmt(fcx.ccx, _);\n-    pps += vec::map[@stmt, pre_and_post](f, b.node.stmts);\n-    fn get_pp_expr(crate_ctxt ccx, &@expr e) -> pre_and_post {\n-        ret expr_pp(ccx, e);\n+\n+    let pre_and_post[] pps = ~[];\n+    for (@stmt s in b.node.stmts) { pps += ~[stmt_pp(fcx.ccx, *s)]; }\n+    alt (b.node.expr) {\n+      case (none) { /* no-op */ }\n+      case (some(?e)) { pps += ~[expr_pp(fcx.ccx, e)]; }\n     }\n-    auto g = bind get_pp_expr(fcx.ccx, _);\n-    plus_option[pre_and_post](pps,\n-                              option::map[@expr,\n-                                          pre_and_post](g, b.node.expr));\n \n     auto block_precond = seq_preconds(fcx, pps);\n-    auto h = get_post;\n-    auto postconds = vec::map[pre_and_post, postcond](h, pps);\n+\n+    auto postconds = ~[];\n+    for (pre_and_post pp in pps) { postconds += ~[get_post(pp)]; }\n+\n     /* A block may be empty, so this next line ensures that the postconds\n        vector is non-empty. */\n+    postconds += ~[block_precond];\n \n-    vec::push[postcond](postconds, block_precond);\n     auto block_postcond = empty_poststate(nv);\n     /* conservative approximation */\n "}, {"sha": "59ad4461689644540bb2b8a2c6300c2f7b4cc359", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfc659009e7eb23dfb6ad4c49e836cad9f350c61/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=cfc659009e7eb23dfb6ad4c49e836cad9f350c61", "patch": "@@ -240,11 +240,11 @@ fn tritv_doesntcare(&t v) -> bool {\n   ret true;\n }\n \n-fn to_vec(&t v) -> vec[uint] {\n+fn to_vec(&t v) -> uint[] {\n   let uint i = 0u;\n-  let vec[uint] rslt = [];\n+  let uint[] rslt = ~[];\n   while (i < v.nbits) {\n-    rslt += [alt (tritv_get(v, i)) {\n+    rslt += ~[alt (tritv_get(v, i)) {\n         case (dont_care) { 2u }\n         case (ttrue)     { 1u }\n         case (tfalse)    { 0u } }];"}]}