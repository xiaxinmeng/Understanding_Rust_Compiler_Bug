{"sha": "f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "node_id": "C_kwDOAAsO6NoAKGY3MDY2Zjc5ZDdhYmJlYjVjOWU2NTMxZjNlNDU5ZWFmYWRkZWM0ZDg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-18T23:00:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-01-18T23:00:28Z"}, "message": "Rollup merge of #105796 - notriddle:notriddle/rustdoc-search-stop-doing-demerits, r=GuillaumeGomez\n\nrustdoc: simplify JS search routine by not messing with lev distance\n\nSince the sorting function accounts for an `index` field, there's not much reason to also be applying changes to the levenshtein distance. Instead, we can just not treat `lev` as a filter if there's already a non-sentinel value for `index`.\n\n<details>\n\nThis change gives slightly more weight to the index and path part, as search criteria, than it used to. This changes some of the test cases, but not in any obviously-\"worse\" way, and, in particular, substring matches are a bigger deal than levenshtein distances (we're assuming that a typo is less likely than someone just not typing the entire name).\n\nThe biggest change is the addition of a `path_lev` field to result items. It's always zero if the search query has no parent path part and for type queries, making the check in the `sortResults` function a no-op. When it's present, it is used to implement different precedence for the parent path and the tail.\n\nConsider the query `hashset::insert`, a test case [that already exists and can be found here](https://github.com/rust-lang/rust/blob/5c6a1681a9a7b815febdd9de2f840da338984e68/src/test/rustdoc-js-std/path-ordering.js). We want the ordering shown in the test case:\n\n```\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_with' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_owned' },\n        { 'path': 'std::collections::hash_map::HashMap', 'name': 'insert' },\n```\n\nWe do not want this ordering, which is the ordering that would occur if substring position took priority over `path_lev`:\n\n```\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'insert' },\n        { 'path': 'std::collections::hash_map::HashMap', 'name': 'insert' }, // BAD\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_with' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_owned' },\n```\n\nWe also do not want `HashSet::iter` to appear before `HashMap::insert`, which is what would happen if `path_lev` took priority over the appearance of any substring match. This is why the `sortResults` function has `path_lev` sandwiched between a `index < 0` check and a `index` comparison check:\n\n```\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_with' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_owned' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'iter' }, // BAD\n        { 'path': 'std::collections::hash_map::HashMap', 'name': 'insert' },\n```\n\nThe old code implemented a similar feature by manipulating the `lev` member based on whether a substring match was found and averaging in the path distance (`item.lev = name_lev + path_lev / 10`), so the path lev wound up acting like a tie breaker, but it gives slightly different results for `Vec::new`, [changing the test case](https://github.com/rust-lang/rust/pull/105796/files#diff-b346e2ef72a407915f438063c8c2c04f7a621df98923d441b41c0312211a5b21) because of the slight changes to ordering priority.\n\n</details>\n\nBased on https://github.com/rust-lang/rust/pull/103710#issuecomment-1296894296\n\nPreviews:\n\n* https://notriddle.com/notriddle-rustdoc-demos/rustdoc-search-stop-doing-demerits/std/index.html\n* https://notriddle.com/notriddle-rustdoc-demos/rustdoc-search-stop-doing-demerits-compiler/index.html", "tree": {"sha": "5d9052a8ca2aa28cfc035f6dd52c8981c9c8098f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d9052a8ca2aa28cfc035f6dd52c8981c9c8098f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjyHoMCRBK7hj4Ov3rIwAAfiIIAJ6F0m4Gb7+G517/nGKDUeXm\nAhbr95V/bmCJSuuUjV+AoBvjezOlyR6t7aXyh7HinOi7f5ZEZhGA+wXkTDYKRysU\nBXTgorh2IT0s6HqrEMwOOqFcAzxjy13T1ExvEEkC6XghR6TPxFsAy+0NJDjjNgrZ\nFTLcvDZLB/sxlKkOldRz3v7gHnTB3Cr6lscyEHgg13P2HVDuydHwqgKWyRyZjh9W\n43NLoa4RCd5TRsm7N3VQs/NIJOu8ul2Rad09jIyNJv+NPMNooe98Fum0fQ8xhKbN\nHu/mO80oFEqTn3Fbyl5BNjdm/CP9OQ2ZnULRXKBEo7e5IwVW2fsp1ZLXjskVagA=\n=06Bb\n-----END PGP SIGNATURE-----\n", "payload": "tree 5d9052a8ca2aa28cfc035f6dd52c8981c9c8098f\nparent 333ee6c466972185973d5097f8b5fb0f9fb13fa5\nparent db558b46861ee2f812ee1cc2b03b796f691a246d\nauthor Michael Goulet <michael@errs.io> 1674082828 -0500\ncommitter GitHub <noreply@github.com> 1674082828 -0500\n\nRollup merge of #105796 - notriddle:notriddle/rustdoc-search-stop-doing-demerits, r=GuillaumeGomez\n\nrustdoc: simplify JS search routine by not messing with lev distance\n\nSince the sorting function accounts for an `index` field, there's not much reason to also be applying changes to the levenshtein distance. Instead, we can just not treat `lev` as a filter if there's already a non-sentinel value for `index`.\n\n<details>\n\nThis change gives slightly more weight to the index and path part, as search criteria, than it used to. This changes some of the test cases, but not in any obviously-\"worse\" way, and, in particular, substring matches are a bigger deal than levenshtein distances (we're assuming that a typo is less likely than someone just not typing the entire name).\n\nThe biggest change is the addition of a `path_lev` field to result items. It's always zero if the search query has no parent path part and for type queries, making the check in the `sortResults` function a no-op. When it's present, it is used to implement different precedence for the parent path and the tail.\n\nConsider the query `hashset::insert`, a test case [that already exists and can be found here](https://github.com/rust-lang/rust/blob/5c6a1681a9a7b815febdd9de2f840da338984e68/src/test/rustdoc-js-std/path-ordering.js). We want the ordering shown in the test case:\n\n```\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_with' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_owned' },\n        { 'path': 'std::collections::hash_map::HashMap', 'name': 'insert' },\n```\n\nWe do not want this ordering, which is the ordering that would occur if substring position took priority over `path_lev`:\n\n```\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'insert' },\n        { 'path': 'std::collections::hash_map::HashMap', 'name': 'insert' }, // BAD\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_with' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_owned' },\n```\n\nWe also do not want `HashSet::iter` to appear before `HashMap::insert`, which is what would happen if `path_lev` took priority over the appearance of any substring match. This is why the `sortResults` function has `path_lev` sandwiched between a `index < 0` check and a `index` comparison check:\n\n```\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_with' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'get_or_insert_owned' },\n        { 'path': 'std::collections::hash_set::HashSet', 'name': 'iter' }, // BAD\n        { 'path': 'std::collections::hash_map::HashMap', 'name': 'insert' },\n```\n\nThe old code implemented a similar feature by manipulating the `lev` member based on whether a substring match was found and averaging in the path distance (`item.lev = name_lev + path_lev / 10`), so the path lev wound up acting like a tie breaker, but it gives slightly different results for `Vec::new`, [changing the test case](https://github.com/rust-lang/rust/pull/105796/files#diff-b346e2ef72a407915f438063c8c2c04f7a621df98923d441b41c0312211a5b21) because of the slight changes to ordering priority.\n\n</details>\n\nBased on https://github.com/rust-lang/rust/pull/103710#issuecomment-1296894296\n\nPreviews:\n\n* https://notriddle.com/notriddle-rustdoc-demos/rustdoc-search-stop-doing-demerits/std/index.html\n* https://notriddle.com/notriddle-rustdoc-demos/rustdoc-search-stop-doing-demerits-compiler/index.html\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "html_url": "https://github.com/rust-lang/rust/commit/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "333ee6c466972185973d5097f8b5fb0f9fb13fa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/333ee6c466972185973d5097f8b5fb0f9fb13fa5", "html_url": "https://github.com/rust-lang/rust/commit/333ee6c466972185973d5097f8b5fb0f9fb13fa5"}, {"sha": "db558b46861ee2f812ee1cc2b03b796f691a246d", "url": "https://api.github.com/repos/rust-lang/rust/commits/db558b46861ee2f812ee1cc2b03b796f691a246d", "html_url": "https://github.com/rust-lang/rust/commit/db558b46861ee2f812ee1cc2b03b796f691a246d"}], "stats": {"total": 126, "additions": 70, "deletions": 56}, "files": [{"sha": "88592fa0c84c1453fbda216b9f3d92eddb0ab307", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "patch": "@@ -781,7 +781,29 @@ function initSearch(rawSearchIndex) {\n                     return a - b;\n                 }\n \n-                // Sort by non levenshtein results and then levenshtein results by the distance\n+                // sort by index of keyword in item name (no literal occurrence goes later)\n+                a = (aaa.index < 0);\n+                b = (bbb.index < 0);\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n+                // Sort by distance in the path part, if specified\n+                // (less changes required to match means higher rankings)\n+                a = aaa.path_lev;\n+                b = bbb.path_lev;\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n+                // (later literal occurrence, if any, goes later)\n+                a = aaa.index;\n+                b = bbb.index;\n+                if (a !== b) {\n+                    return a - b;\n+                }\n+\n+                // Sort by distance in the name part, the last part of the path\n                 // (less changes required to match means higher rankings)\n                 a = (aaa.lev);\n                 b = (bbb.lev);\n@@ -810,19 +832,6 @@ function initSearch(rawSearchIndex) {\n                     return (a > b ? +1 : -1);\n                 }\n \n-                // sort by index of keyword in item name (no literal occurrence goes later)\n-                a = (aaa.index < 0);\n-                b = (bbb.index < 0);\n-                if (a !== b) {\n-                    return a - b;\n-                }\n-                // (later literal occurrence, if any, goes later)\n-                a = aaa.index;\n-                b = bbb.index;\n-                if (a !== b) {\n-                    return a - b;\n-                }\n-\n                 // special precedence for primitive and keyword pages\n                 if ((aaa.item.ty === TY_PRIMITIVE && bbb.item.ty !== TY_KEYWORD) ||\n                     (aaa.item.ty === TY_KEYWORD && bbb.item.ty !== TY_PRIMITIVE)) {\n@@ -1230,15 +1239,19 @@ function initSearch(rawSearchIndex) {\n          * * `id` is the index in both `searchWords` and `searchIndex` arrays for this element.\n          * * `index` is an `integer`` used to sort by the position of the word in the item's name.\n          * * `lev` is the main metric used to sort the search results.\n+         * * `path_lev` is zero if a single-component search query is used, otherwise it's the\n+         *   distance computed for everything other than the last path component.\n          *\n          * @param {Results} results\n          * @param {string} fullId\n          * @param {integer} id\n          * @param {integer} index\n          * @param {integer} lev\n+         * @param {integer} path_lev\n          */\n-        function addIntoResults(results, fullId, id, index, lev) {\n-            if (lev === 0 || (!parsedQuery.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n+        function addIntoResults(results, fullId, id, index, lev, path_lev) {\n+            const inBounds = lev <= MAX_LEV_DISTANCE || index !== -1;\n+            if (lev === 0 || (!parsedQuery.literalSearch && inBounds)) {\n                 if (results[fullId] !== undefined) {\n                     const result = results[fullId];\n                     if (result.dontValidate || result.lev <= lev) {\n@@ -1250,6 +1263,7 @@ function initSearch(rawSearchIndex) {\n                     index: index,\n                     dontValidate: parsedQuery.literalSearch,\n                     lev: lev,\n+                    path_lev: path_lev,\n                 };\n             }\n         }\n@@ -1280,68 +1294,68 @@ function initSearch(rawSearchIndex) {\n             if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n-            let lev, lev_add = 0, index = -1;\n+            let lev, index = -1, path_lev = 0;\n             const fullId = row.id;\n+            const searchWord = searchWords[pos];\n \n             const in_args = findArg(row, elem, parsedQuery.typeFilter);\n             const returned = checkReturned(row, elem, parsedQuery.typeFilter);\n \n-            addIntoResults(results_in_args, fullId, pos, index, in_args);\n-            addIntoResults(results_returned, fullId, pos, index, returned);\n+            // path_lev is 0 because no parent path information is currently stored\n+            // in the search index\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0);\n+            addIntoResults(results_returned, fullId, pos, -1, returned, 0);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n             }\n-            const searchWord = searchWords[pos];\n \n-            if (parsedQuery.literalSearch) {\n-                if (searchWord === elem.name) {\n-                    addIntoResults(results_others, fullId, pos, -1, 0);\n-                }\n-                return;\n+            const row_index = row.normalizedName.indexOf(elem.pathLast);\n+            const word_index = searchWord.indexOf(elem.pathLast);\n+\n+            // lower indexes are \"better\" matches\n+            // rank based on the \"best\" match\n+            if (row_index === -1) {\n+                index = word_index;\n+            } else if (word_index === -1) {\n+                index = row_index;\n+            } else if (word_index < row_index) {\n+                index = word_index;\n+            } else {\n+                index = row_index;\n             }\n \n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n                 if (row.type !== null) {\n                     lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n-                    addIntoResults(results_others, fullId, pos, index, lev);\n+                    // path_lev is 0 because we know it's empty\n+                    addIntoResults(results_others, fullId, pos, index, lev, 0);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                lev = checkPath(elem.pathWithoutLast, row);\n-                if (lev > MAX_LEV_DISTANCE || (parsedQuery.literalSearch && lev !== 0)) {\n+                path_lev = checkPath(elem.pathWithoutLast, row);\n+                if (path_lev > MAX_LEV_DISTANCE) {\n                     return;\n-                } else if (lev > 0) {\n-                    lev_add = lev / 10;\n                 }\n             }\n \n-            if (searchWord.indexOf(elem.pathLast) > -1 ||\n-                row.normalizedName.indexOf(elem.pathLast) > -1\n-            ) {\n-                index = row.normalizedName.indexOf(elem.pathLast);\n-            }\n-            lev = levenshtein(searchWord, elem.pathLast);\n-            if (lev > 0 && elem.pathLast.length > 2 && searchWord.indexOf(elem.pathLast) > -1) {\n-                if (elem.pathLast.length < 6) {\n-                    lev = 1;\n-                } else {\n-                    lev = 0;\n+            if (parsedQuery.literalSearch) {\n+                if (searchWord === elem.name) {\n+                    addIntoResults(results_others, fullId, pos, index, 0, path_lev);\n                 }\n-            }\n-            lev += lev_add;\n-            if (lev > MAX_LEV_DISTANCE) {\n                 return;\n-            } else if (index !== -1 && elem.fullPath.length < 2) {\n-                lev -= 1;\n             }\n-            if (lev < 0) {\n-                lev = 0;\n+\n+            lev = levenshtein(searchWord, elem.pathLast);\n+\n+            if (index === -1 && lev + path_lev > MAX_LEV_DISTANCE) {\n+                return;\n             }\n-            addIntoResults(results_others, fullId, pos, index, lev);\n+\n+            addIntoResults(results_others, fullId, pos, index, lev, path_lev);\n         }\n \n         /**\n@@ -1386,7 +1400,7 @@ function initSearch(rawSearchIndex) {\n                 return;\n             }\n             const lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, row.id, pos, 0, lev);\n+            addIntoResults(results, row.id, pos, 0, lev, 0);\n         }\n \n         function innerRunQuery() {"}, {"sha": "1b4c7b40570203b2b4eecb55488615984a72505d", "filename": "tests/rustdoc-js-std/macro-print.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js-std%2Fmacro-print.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js-std%2Fmacro-print.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fmacro-print.js?ref=f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "patch": "@@ -3,8 +3,8 @@ const QUERY = 'macro:print';\n const EXPECTED = {\n     'others': [\n         { 'path': 'std', 'name': 'print' },\n-        { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'println' },\n+        { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'eprintln' },\n     ],\n };"}, {"sha": "fd5c5489d79cfe04a4d844cfdec619ec542719f7", "filename": "tests/rustdoc-js-std/typed-query.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js-std%2Ftyped-query.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js-std%2Ftyped-query.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Ftyped-query.js?ref=f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "patch": "@@ -6,8 +6,8 @@ const FILTER_CRATE = 'std';\n const EXPECTED = {\n     'others': [\n         { 'path': 'std', 'name': 'print' },\n-        { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'println' },\n+        { 'path': 'std', 'name': 'eprint' },\n         { 'path': 'std', 'name': 'eprintln' },\n         { 'path': 'std::pin', 'name': 'pin' },\n         { 'path': 'std::future', 'name': 'join' },"}, {"sha": "fc44a566af21f8ab1f2d9554370366c60975ab09", "filename": "tests/rustdoc-js-std/vec-new.js", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js-std%2Fvec-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js-std%2Fvec-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js-std%2Fvec-new.js?ref=f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "patch": "@@ -3,7 +3,8 @@ const QUERY = 'Vec::new';\n const EXPECTED = {\n     'others': [\n         { 'path': 'std::vec::Vec', 'name': 'new' },\n-        { 'path': 'std::vec::Vec', 'name': 'ne' },\n-        { 'path': 'alloc::vec::Vec', 'name': 'ne' },\n+        { 'path': 'alloc::vec::Vec', 'name': 'new' },\n+        { 'path': 'std::vec::Vec', 'name': 'new_in' },\n+        { 'path': 'alloc::vec::Vec', 'name': 'new_in' },\n     ],\n };"}, {"sha": "3b2f15a40bf87448fb9f441266e1934d1a6c6301", "filename": "tests/rustdoc-js/search-short-types.js", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js%2Fsearch-short-types.js", "raw_url": "https://github.com/rust-lang/rust/raw/f7066f79d7abbeb5c9e6531f3e459eafaddec4d8/tests%2Frustdoc-js%2Fsearch-short-types.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fsearch-short-types.js?ref=f7066f79d7abbeb5c9e6531f3e459eafaddec4d8", "patch": "@@ -4,7 +4,6 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'search_short_types', 'name': 'P' },\n         { 'path': 'search_short_types::VeryLongTypeName', 'name': 'p' },\n-        { 'path': 'search_short_types', 'name': 'Ap' },\n-        { 'path': 'search_short_types::VeryLongTypeName', 'name': 'ap' },\n+        { 'path': 'search_short_types', 'name': 'Pa' },\n     ],\n };"}]}