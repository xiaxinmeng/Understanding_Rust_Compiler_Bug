{"sha": "3464401576f707ff6cfb71bf15da6a95088e54e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0NjQ0MDE1NzZmNzA3ZmY2Y2ZiNzFiZjE1ZGE2YTk1MDg4ZTU0ZTU=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-08-26T21:13:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-08-26T21:13:55Z"}, "message": "Merge branch 'master' into memory", "tree": {"sha": "619dac28a905a96ecf12e70f27118bd6d9f98e7d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/619dac28a905a96ecf12e70f27118bd6d9f98e7d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3464401576f707ff6cfb71bf15da6a95088e54e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3464401576f707ff6cfb71bf15da6a95088e54e5", "html_url": "https://github.com/rust-lang/rust/commit/3464401576f707ff6cfb71bf15da6a95088e54e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3464401576f707ff6cfb71bf15da6a95088e54e5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2307d6fc5bbc71ad961f0d80b8d532194968be0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2307d6fc5bbc71ad961f0d80b8d532194968be0b", "html_url": "https://github.com/rust-lang/rust/commit/2307d6fc5bbc71ad961f0d80b8d532194968be0b"}, {"sha": "b6d05976eade1ccbd75d084d8f3071be7b6cbba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6d05976eade1ccbd75d084d8f3071be7b6cbba0", "html_url": "https://github.com/rust-lang/rust/commit/b6d05976eade1ccbd75d084d8f3071be7b6cbba0"}], "stats": {"total": 86, "additions": 3, "deletions": 83}, "files": [{"sha": "79f170ace6c8b42f28bc24d919262eddb687dc2d", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 83, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/3464401576f707ff6cfb71bf15da6a95088e54e5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3464401576f707ff6cfb71bf15da6a95088e54e5/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=3464401576f707ff6cfb71bf15da6a95088e54e5", "patch": "@@ -10,10 +10,9 @@ use rustc::traits::Reveal;\n use rustc::ty::layout::{self, Layout, Size, Align, HasDataLayout};\n use rustc::ty::subst::{Subst, Substs, Kind};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Binder};\n-use rustc::traits;\n use rustc_data_structures::indexed_vec::Idx;\n-use syntax::codemap::{self, DUMMY_SP, Span};\n-use syntax::ast::{self, Mutability};\n+use syntax::codemap::{self, DUMMY_SP};\n+use syntax::ast::Mutability;\n use syntax::abi::Abi;\n \n use super::{EvalError, EvalResult, EvalErrorKind, GlobalId, Lvalue, LvalueExtra, Memory,\n@@ -2410,7 +2409,7 @@ fn resolve_associated_item<'a, 'tcx>(\n     );\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = fulfill_obligation(tcx, DUMMY_SP, ty::Binder(trait_ref));\n+    let vtbl = tcx.trans_fulfill_obligation(DUMMY_SP, ty::Binder(trait_ref));\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n@@ -2517,85 +2516,6 @@ fn type_is_sized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> bool {\n     ty.is_sized(tcx, ty::ParamEnv::empty(Reveal::All), DUMMY_SP)\n }\n \n-/// Attempts to resolve an obligation. The result is a shallow vtable resolution -- meaning that we\n-/// do not (necessarily) resolve all nested obligations on the impl. Note that type check should\n-/// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n-fn fulfill_obligation<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    span: Span,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> traits::Vtable<'tcx, ()> {\n-    // Remove any references to regions; this helps improve caching.\n-    let trait_ref = tcx.erase_regions(&trait_ref);\n-\n-    debug!(\n-        \"trans::fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n-        trait_ref,\n-        trait_ref.def_id()\n-    );\n-\n-    // Do the initial selection for the obligation. This yields the\n-    // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt().enter(|infcx| {\n-        let mut selcx = traits::SelectionContext::new(&infcx);\n-\n-        let obligation_cause = traits::ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n-        let obligation = traits::Obligation::new(\n-            obligation_cause,\n-            ty::ParamEnv::empty(Reveal::All),\n-            trait_ref.to_poly_trait_predicate(),\n-        );\n-\n-        let selection = match selcx.select(&obligation) {\n-            Ok(Some(selection)) => selection,\n-            Ok(None) => {\n-                // Ambiguity can happen when monomorphizing during trans\n-                // expands to some humongo type that never occurred\n-                // statically -- this humongo type can then overflow,\n-                // leading to an ambiguous result. So report this as an\n-                // overflow bug, since I believe this is the only case\n-                // where ambiguity can result.\n-                debug!(\n-                    \"Encountered ambiguity selecting `{:?}` during trans, \\\n-                        presuming due to overflow\",\n-                    trait_ref\n-                );\n-                tcx.sess.span_fatal(\n-                    span,\n-                    \"reached the recursion limit during monomorphization \\\n-                        (selection ambiguity)\",\n-                );\n-            }\n-            Err(e) => {\n-                span_bug!(\n-                    span,\n-                    \"Encountered error `{:?}` selecting `{:?}` during trans\",\n-                    e,\n-                    trait_ref\n-                )\n-            }\n-        };\n-\n-        debug!(\"fulfill_obligation: selection={:?}\", selection);\n-\n-        // Currently, we use a fulfillment context to completely resolve\n-        // all nested obligations. This is because they can inform the\n-        // inference of the impl's type parameters.\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n-        let vtable = selection.map(|predicate| {\n-            debug!(\n-                \"fulfill_obligation: register_predicate_obligation {:?}\",\n-                predicate\n-            );\n-            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n-        });\n-        let vtable = infcx.drain_fulfillment_cx_or_panic(span, &mut fulfill_cx, &vtable);\n-\n-        debug!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n-        vtable\n-    })\n-}\n-\n pub fn resolve_drop_in_place<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ty: Ty<'tcx>,"}]}