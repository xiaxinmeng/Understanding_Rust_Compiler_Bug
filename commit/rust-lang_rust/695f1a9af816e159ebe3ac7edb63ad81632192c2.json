{"sha": "695f1a9af816e159ebe3ac7edb63ad81632192c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5NWYxYTlhZjgxNmUxNTllYmUzYWM3ZWRiNjNhZDgxNjMyMTkyYzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-07T15:47:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-07T15:47:37Z"}, "message": "Merge #5252\n\n5252: Fix symbol search in salsa r=matklad a=matklad\n\nPrevious solution for binning paths into disjoint directories was\r\nsimple and fast -- just a single binary search.\r\n\r\nUnfortunatelly, it wasn't coorrect: if the ditr are\r\n\r\n  /d\r\n  /d/a\r\n  /d/c\r\n\r\nthen partitioning the file /d/b/lib.rs won't pick /d as a correct\r\ndirectory.\r\n\r\nThe correct solution here is a trie, but it requires exposing path\r\ncomponents.\r\n\r\nSo, we use a poor man's substitution -- a *vector* of sorted paths,\r\nsuch that each bucket is prefix-free\r\n\r\ncloses #5246\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "31bb591b935992d7f30e0fabe8633018ddbf6d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31bb591b935992d7f30e0fabe8633018ddbf6d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/695f1a9af816e159ebe3ac7edb63ad81632192c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfBJkZCRBK7hj4Ov3rIwAAdHIIAIbLAdDfpyBcgcbf+C6oF+gh\nCNXW/3KWw+17rJW+nWApTJjDtEHQlgkurL4p2t0aZSn7lA0w++wj4U+YiAmeNH+T\nvEDK36ekD6KRBVsiiqptyj8EzNG9K+SfWeqbDtJdXHgtSKGWb46sC275Utl+NqQ5\nq5thyNUUdue8g2fLgBZxyHRIePxC6d7C0vjh9nFzjcrVtWeEvqgdtWtEwGgHVTBC\ngnWlA+Hqn9wYJsJp6AOTrKfwX6odCeKx6xCcl7W/4KVUOyT5T41pZbbSGCiDsjG4\nbLUjHs5PQPzXJ/vvjpzXsf4alUxkLHmS5d7NkbGE427ht4uNBqrJYmpMPgz7qpg=\n=+Ta+\n-----END PGP SIGNATURE-----\n", "payload": "tree 31bb591b935992d7f30e0fabe8633018ddbf6d02\nparent 7407636568c791b39cd12f9176f667dac2deef1b\nparent 5d2225f4bc82c4cd551db5a53500e7a076bf5586\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594136857 +0000\ncommitter GitHub <noreply@github.com> 1594136857 +0000\n\nMerge #5252\n\n5252: Fix symbol search in salsa r=matklad a=matklad\n\nPrevious solution for binning paths into disjoint directories was\r\nsimple and fast -- just a single binary search.\r\n\r\nUnfortunatelly, it wasn't coorrect: if the ditr are\r\n\r\n  /d\r\n  /d/a\r\n  /d/c\r\n\r\nthen partitioning the file /d/b/lib.rs won't pick /d as a correct\r\ndirectory.\r\n\r\nThe correct solution here is a trie, but it requires exposing path\r\ncomponents.\r\n\r\nSo, we use a poor man's substitution -- a *vector* of sorted paths,\r\nsuch that each bucket is prefix-free\r\n\r\ncloses #5246\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/695f1a9af816e159ebe3ac7edb63ad81632192c2", "html_url": "https://github.com/rust-lang/rust/commit/695f1a9af816e159ebe3ac7edb63ad81632192c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/695f1a9af816e159ebe3ac7edb63ad81632192c2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7407636568c791b39cd12f9176f667dac2deef1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7407636568c791b39cd12f9176f667dac2deef1b", "html_url": "https://github.com/rust-lang/rust/commit/7407636568c791b39cd12f9176f667dac2deef1b"}, {"sha": "5d2225f4bc82c4cd551db5a53500e7a076bf5586", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2225f4bc82c4cd551db5a53500e7a076bf5586", "html_url": "https://github.com/rust-lang/rust/commit/5d2225f4bc82c4cd551db5a53500e7a076bf5586"}], "stats": {"total": 109, "additions": 90, "deletions": 19}, "files": [{"sha": "b0130017e77a4bb55ca0ad980a0e9811bf17cfeb", "filename": "crates/vfs/src/file_set.rs", "status": "modified", "additions": 90, "deletions": 19, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/695f1a9af816e159ebe3ac7edb63ad81632192c2/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/695f1a9af816e159ebe3ac7edb63ad81632192c2/crates%2Fvfs%2Fsrc%2Ffile_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fvfs%2Fsrc%2Ffile_set.rs?ref=695f1a9af816e159ebe3ac7edb63ad81632192c2", "patch": "@@ -2,7 +2,7 @@\n //!\n //! Files which do not belong to any explicitly configured `FileSet` belong to\n //! the default `FileSet`.\n-use std::{fmt, iter};\n+use std::{fmt, mem};\n \n use rustc_hash::FxHashMap;\n \n@@ -15,6 +15,9 @@ pub struct FileSet {\n }\n \n impl FileSet {\n+    pub fn len(&self) -> usize {\n+        self.files.len()\n+    }\n     pub fn resolve_path(&self, anchor: FileId, path: &str) -> Option<FileId> {\n         let mut base = self.paths[&anchor].clone();\n         base.pop();\n@@ -37,10 +40,15 @@ impl fmt::Debug for FileSet {\n     }\n }\n \n+// Invariant: if k1 is a prefix of k2, then they are in different buckets (k2\n+// is closer to 0th bucket).\n+// FIXME: replace with an actual trie some day.\n+type BadTrie<K, V> = Vec<Vec<(K, V)>>;\n+\n #[derive(Debug)]\n pub struct FileSetConfig {\n     n_file_sets: usize,\n-    roots: Vec<(VfsPath, usize)>,\n+    trie: BadTrie<VfsPath, usize>,\n }\n \n impl Default for FileSetConfig {\n@@ -65,15 +73,7 @@ impl FileSetConfig {\n         self.n_file_sets\n     }\n     fn classify(&self, path: &VfsPath) -> usize {\n-        let idx = match self.roots.binary_search_by(|(p, _)| p.cmp(path)) {\n-            Ok(it) => it,\n-            Err(it) => it.saturating_sub(1),\n-        };\n-        if !self.roots.is_empty() && path.starts_with(&self.roots[idx].0) {\n-            self.roots[idx].1\n-        } else {\n-            self.len() - 1\n-        }\n+        find_ancestor(&self.trie, path, is_prefix).copied().unwrap_or(self.len() - 1)\n     }\n }\n \n@@ -96,13 +96,84 @@ impl FileSetConfigBuilder {\n     }\n     pub fn build(self) -> FileSetConfig {\n         let n_file_sets = self.roots.len() + 1;\n-        let mut roots: Vec<(VfsPath, usize)> = self\n-            .roots\n-            .into_iter()\n-            .enumerate()\n-            .flat_map(|(i, paths)| paths.into_iter().zip(iter::repeat(i)))\n-            .collect();\n-        roots.sort();\n-        FileSetConfig { n_file_sets, roots }\n+\n+        let mut trie = BadTrie::new();\n+\n+        for (i, paths) in self.roots.into_iter().enumerate() {\n+            for p in paths {\n+                insert(&mut trie, p, i, is_prefix);\n+            }\n+        }\n+        trie.iter_mut().for_each(|it| it.sort());\n+        FileSetConfig { n_file_sets, trie }\n+    }\n+}\n+\n+fn is_prefix(short: &VfsPath, long: &VfsPath) -> bool {\n+    long.starts_with(short)\n+}\n+\n+fn insert<K: Ord, V, P: Fn(&K, &K) -> bool>(\n+    trie: &mut BadTrie<K, V>,\n+    mut key: K,\n+    mut value: V,\n+    is_prefix: P,\n+) {\n+    'outer: for level in 0.. {\n+        if trie.len() == level {\n+            trie.push(Vec::new())\n+        }\n+        for (k, v) in trie[level].iter_mut() {\n+            if is_prefix(&key, k) {\n+                continue 'outer;\n+            }\n+            if is_prefix(k, &key) {\n+                mem::swap(k, &mut key);\n+                mem::swap(v, &mut value);\n+                continue 'outer;\n+            }\n+        }\n+        trie[level].push((key, value));\n+        return;\n+    }\n+}\n+\n+fn find_ancestor<'t, K: Ord, V, P: Fn(&K, &K) -> bool>(\n+    trie: &'t BadTrie<K, V>,\n+    key: &K,\n+    is_prefix: P,\n+) -> Option<&'t V> {\n+    for bucket in trie {\n+        let idx = match bucket.binary_search_by(|(k, _)| k.cmp(key)) {\n+            Ok(it) => it,\n+            Err(it) => it.saturating_sub(1),\n+        };\n+        if !bucket.is_empty() && is_prefix(&bucket[idx].0, key) {\n+            return Some(&bucket[idx].1);\n+        }\n     }\n+    None\n+}\n+\n+#[test]\n+fn test_partitioning() {\n+    let mut file_set = FileSetConfig::builder();\n+    file_set.add_file_set(vec![VfsPath::new_virtual_path(\"/foo\".into())]);\n+    file_set.add_file_set(vec![VfsPath::new_virtual_path(\"/foo/bar/baz\".into())]);\n+    let file_set = file_set.build();\n+\n+    let mut vfs = Vfs::default();\n+    vfs.set_file_contents(VfsPath::new_virtual_path(\"/foo/src/lib.rs\".into()), Some(Vec::new()));\n+    vfs.set_file_contents(\n+        VfsPath::new_virtual_path(\"/foo/src/bar/baz/lib.rs\".into()),\n+        Some(Vec::new()),\n+    );\n+    vfs.set_file_contents(\n+        VfsPath::new_virtual_path(\"/foo/bar/baz/lib.rs\".into()),\n+        Some(Vec::new()),\n+    );\n+    vfs.set_file_contents(VfsPath::new_virtual_path(\"/quux/lib.rs\".into()), Some(Vec::new()));\n+\n+    let partition = file_set.partition(&vfs).into_iter().map(|it| it.len()).collect::<Vec<_>>();\n+    assert_eq!(partition, vec![2, 1, 1]);\n }"}]}