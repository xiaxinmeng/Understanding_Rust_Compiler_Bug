{"sha": "b4b6b62e70f94c949b82f669498a925e3d4c3c2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YjZiNjJlNzBmOTRjOTQ5YjgyZjY2OTQ5OGE5MjVlM2Q0YzNjMmI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-01-06T14:19:47Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-10T19:46:44Z"}, "message": "resolve: Cleanup visibility resolution in enums and traits", "tree": {"sha": "45fea706ea4df7114ccdac82ae2e0c36ce234d37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45fea706ea4df7114ccdac82ae2e0c36ce234d37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4b6b62e70f94c949b82f669498a925e3d4c3c2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b6b62e70f94c949b82f669498a925e3d4c3c2b", "html_url": "https://github.com/rust-lang/rust/commit/b4b6b62e70f94c949b82f669498a925e3d4c3c2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4b6b62e70f94c949b82f669498a925e3d4c3c2b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07194ffcd25b0871ce560b9f702e52db27ac9f77", "url": "https://api.github.com/repos/rust-lang/rust/commits/07194ffcd25b0871ce560b9f702e52db27ac9f77", "html_url": "https://github.com/rust-lang/rust/commit/07194ffcd25b0871ce560b9f702e52db27ac9f77"}], "stats": {"total": 105, "additions": 42, "deletions": 63}, "files": [{"sha": "c4f3b3ff857434ff243c0013fa87c580dc8428f5", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 42, "deletions": 63, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/b4b6b62e70f94c949b82f669498a925e3d4c3c2b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b6b62e70f94c949b82f669498a925e3d4c3c2b/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=b4b6b62e70f94c949b82f669498a925e3d4c3c2b", "patch": "@@ -258,16 +258,16 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 Ok(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)))\n             }\n             ast::VisibilityKind::Inherited => {\n-                if matches!(self.parent_scope.module.kind, ModuleKind::Def(DefKind::Enum, _, _)) {\n-                    // Any inherited visibility resolved directly inside an enum\n-                    // (e.g. variants or fields) inherits from the visibility of the enum.\n-                    let parent_enum = self.parent_scope.module.def_id().unwrap().expect_local();\n-                    Ok(self.r.visibilities[&parent_enum])\n-                } else {\n-                    // If it's not in an enum, its visibility is restricted to the `mod` item\n-                    // that it's defined in.\n-                    Ok(ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod))\n-                }\n+                Ok(match self.parent_scope.module.kind {\n+                    // Any inherited visibility resolved directly inside an enum or trait\n+                    // (i.e. variants, fields, and trait items) inherits from the visibility\n+                    // of the enum or trait.\n+                    ModuleKind::Def(DefKind::Enum | DefKind::Trait, def_id, _) => {\n+                        self.r.visibilities[&def_id.expect_local()]\n+                    }\n+                    // Otherwise, the visibility is restricted to the nearest parent `mod` item.\n+                    _ => ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod),\n+                })\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n                 // For visibilities we are not ready to provide correct implementation of \"uniform\n@@ -1365,58 +1365,43 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n             return;\n         }\n \n+        let vis = self.resolve_visibility(&item.vis);\n         let local_def_id = self.r.local_def_id(item.id);\n         let def_id = local_def_id.to_def_id();\n-        let vis = match ctxt {\n-            AssocCtxt::Trait => {\n-                let (def_kind, ns) = match item.kind {\n-                    AssocItemKind::Const(..) => (DefKind::AssocConst, ValueNS),\n-                    AssocItemKind::Fn(box FnKind(_, ref sig, _, _)) => {\n-                        if sig.decl.has_self() {\n-                            self.r.has_self.insert(def_id);\n-                        }\n-                        (DefKind::AssocFn, ValueNS)\n-                    }\n-                    AssocItemKind::TyAlias(..) => (DefKind::AssocTy, TypeNS),\n-                    AssocItemKind::MacCall(_) => bug!(), // handled above\n-                };\n \n-                let parent = self.parent_scope.module;\n-                let expansion = self.parent_scope.expansion;\n-                let res = Res::Def(def_kind, def_id);\n-                // Trait item visibility is inherited from its trait when not specified explicitly.\n-                let vis = match &item.vis.kind {\n-                    ast::VisibilityKind::Inherited => {\n-                        self.r.visibilities[&parent.def_id().unwrap().expect_local()]\n+        if !(ctxt == AssocCtxt::Impl\n+            && matches!(item.vis.kind, ast::VisibilityKind::Inherited)\n+            && self\n+                .r\n+                .trait_impl_items\n+                .contains(&ty::DefIdTree::parent(&*self.r, def_id).unwrap().expect_local()))\n+        {\n+            // Trait impl item visibility is inherited from its trait when not specified\n+            // explicitly. In that case we cannot determine it here in early resolve,\n+            // so we leave a hole in the visibility table to be filled later.\n+            self.r.visibilities.insert(local_def_id, vis);\n+        }\n+\n+        if ctxt == AssocCtxt::Trait {\n+            let (def_kind, ns) = match item.kind {\n+                AssocItemKind::Const(..) => (DefKind::AssocConst, ValueNS),\n+                AssocItemKind::Fn(box FnKind(_, ref sig, _, _)) => {\n+                    if sig.decl.has_self() {\n+                        self.r.has_self.insert(def_id);\n                     }\n-                    _ => self.resolve_visibility(&item.vis),\n-                };\n-                // FIXME: For historical reasons the binding visibility is set to public,\n-                // use actual visibility here instead, using enum variants as an example.\n-                let vis_hack = ty::Visibility::Public;\n-                self.r.define(parent, item.ident, ns, (res, vis_hack, item.span, expansion));\n-                Some(vis)\n-            }\n-            AssocCtxt::Impl => {\n-                // Trait impl item visibility is inherited from its trait when not specified\n-                // explicitly. In that case we cannot determine it here in early resolve,\n-                // so we leave a hole in the visibility table to be filled later.\n-                // Inherent impl item visibility is never inherited from other items.\n-                if matches!(item.vis.kind, ast::VisibilityKind::Inherited)\n-                    && self\n-                        .r\n-                        .trait_impl_items\n-                        .contains(&ty::DefIdTree::parent(&*self.r, def_id).unwrap().expect_local())\n-                {\n-                    None\n-                } else {\n-                    Some(self.resolve_visibility(&item.vis))\n+                    (DefKind::AssocFn, ValueNS)\n                 }\n-            }\n-        };\n+                AssocItemKind::TyAlias(..) => (DefKind::AssocTy, TypeNS),\n+                AssocItemKind::MacCall(_) => bug!(), // handled above\n+            };\n \n-        if let Some(vis) = vis {\n-            self.r.visibilities.insert(local_def_id, vis);\n+            let parent = self.parent_scope.module;\n+            let expansion = self.parent_scope.expansion;\n+            let res = Res::Def(def_kind, def_id);\n+            // FIXME: For historical reasons the binding visibility is set to public,\n+            // use actual visibility here instead, using enum variants as an example.\n+            let vis_hack = ty::Visibility::Public;\n+            self.r.define(parent, item.ident, ns, (res, vis_hack, item.span, expansion));\n         }\n \n         visit::walk_assoc_item(self, item, ctxt);\n@@ -1490,19 +1475,13 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         let parent = self.parent_scope.module;\n-        let vis = match variant.vis.kind {\n-            // Variant visibility is inherited from its enum when not specified explicitly.\n-            ast::VisibilityKind::Inherited => {\n-                self.r.visibilities[&parent.def_id().unwrap().expect_local()]\n-            }\n-            _ => self.resolve_visibility(&variant.vis),\n-        };\n         let expn_id = self.parent_scope.expansion;\n         let ident = variant.ident;\n \n         // Define a name in the type namespace.\n         let def_id = self.r.local_def_id(variant.id);\n         let res = Res::Def(DefKind::Variant, def_id.to_def_id());\n+        let vis = self.resolve_visibility(&variant.vis);\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n         self.r.visibilities.insert(def_id, vis);\n "}]}