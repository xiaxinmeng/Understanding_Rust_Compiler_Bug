{"sha": "f9c0ea2862280102bf33e9df81f33b1b7b464e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5YzBlYTI4NjIyODAxMDJiZjMzZTlkZjgxZjMzYjFiN2I0NjRlMTk=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-11T15:52:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-11T15:52:08Z"}, "message": "Rollup merge of #70644 - nnethercote:clean-up-ModuleConfig-init, r=Mark-Simulacrum\n\nClean up `ModuleConfig` initialization\n\nBecause it's currently a mess.\n\nr? @Mark-Simulacrum", "tree": {"sha": "8dc807756e130a072283d26f7c790ae2e0e9e925", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dc807756e130a072283d26f7c790ae2e0e9e925"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9c0ea2862280102bf33e9df81f33b1b7b464e19", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekeeoCRBK7hj4Ov3rIwAAdHIIAJx9ffUv6NiPcojsKXaFTKul\nKEZNn0A5p5U+nsdo0BiN6iSr7/RaKEBPS4VO9kx8Cm2vv1dbVtPiH0/GkGbw90JW\nLPeI/CaeLjCjmL5pDethZPHB8n2DL6mndN1A7hfeoIZEuYrNM8WJC1EJ7dn5GdTh\n4o69dqev5s2hPbXHfM6DmmKxX/D2R+erK45mncNYXcyTcC1wAnQVUpqgwSsghqhy\nIEyOvBtqLKIHacghxwXm9KXURnCwQVzEag7E8MR0mWdiW/zy5cwCEMgNC7viek6i\nDx+jWQfUxbc7YubRxk1vPyYntlfEzM5OaYq387EZQSaANy5m3TtxR0E9x43tzzo=\n=oWuZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 8dc807756e130a072283d26f7c790ae2e0e9e925\nparent 76882666eba15a186402a911c227f8e9c1682186\nparent 5131c69dd67d9fc61d593803b252cf93ec369c18\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586620328 +0200\ncommitter GitHub <noreply@github.com> 1586620328 +0200\n\nRollup merge of #70644 - nnethercote:clean-up-ModuleConfig-init, r=Mark-Simulacrum\n\nClean up `ModuleConfig` initialization\n\nBecause it's currently a mess.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9c0ea2862280102bf33e9df81f33b1b7b464e19", "html_url": "https://github.com/rust-lang/rust/commit/f9c0ea2862280102bf33e9df81f33b1b7b464e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9c0ea2862280102bf33e9df81f33b1b7b464e19/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76882666eba15a186402a911c227f8e9c1682186", "url": "https://api.github.com/repos/rust-lang/rust/commits/76882666eba15a186402a911c227f8e9c1682186", "html_url": "https://github.com/rust-lang/rust/commit/76882666eba15a186402a911c227f8e9c1682186"}, {"sha": "5131c69dd67d9fc61d593803b252cf93ec369c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/5131c69dd67d9fc61d593803b252cf93ec369c18", "html_url": "https://github.com/rust-lang/rust/commit/5131c69dd67d9fc61d593803b252cf93ec369c18"}], "stats": {"total": 302, "additions": 140, "deletions": 162}, "files": [{"sha": "b1fb1ef0e331cf0776ed93fd2f69ee3767654759", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 140, "deletions": 162, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/f9c0ea2862280102bf33e9df81f33b1b7b464e19/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9c0ea2862280102bf33e9df81f33b1b7b464e19/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=f9c0ea2862280102bf33e9df81f33b1b7b464e19", "patch": "@@ -104,6 +104,7 @@ pub struct ModuleConfig {\n     pub emit_ir: bool,\n     pub emit_asm: bool,\n     pub emit_obj: EmitObj,\n+\n     // Miscellaneous flags.  These are mostly copied from command-line\n     // options.\n     pub verify_llvm_ir: bool,\n@@ -118,77 +119,144 @@ pub struct ModuleConfig {\n }\n \n impl ModuleConfig {\n-    fn new(passes: Vec<String>) -> ModuleConfig {\n-        ModuleConfig {\n-            passes,\n-            opt_level: None,\n-            opt_size: None,\n-\n-            pgo_gen: SwitchWithOptPath::Disabled,\n-            pgo_use: None,\n-\n-            sanitizer: None,\n-            sanitizer_recover: Default::default(),\n-            sanitizer_memory_track_origins: 0,\n-\n-            emit_no_opt_bc: false,\n-            emit_pre_lto_bc: false,\n-            emit_bc: false,\n-            emit_bc_compressed: false,\n-            emit_ir: false,\n-            emit_asm: false,\n-            emit_obj: EmitObj::None,\n-\n-            verify_llvm_ir: false,\n-            no_prepopulate_passes: false,\n-            no_builtins: false,\n-            time_module: true,\n-            vectorize_loop: false,\n-            vectorize_slp: false,\n-            merge_functions: false,\n-            inline_threshold: None,\n-            new_llvm_pass_manager: None,\n+    fn new(kind: ModuleKind, sess: &Session, no_builtins: bool) -> ModuleConfig {\n+        // If it's a regular module, use `$regular`, otherwise use `$other`.\n+        // `$regular` and `$other` are evaluated lazily.\n+        macro_rules! if_regular {\n+            ($regular: expr, $other: expr) => {\n+                if let ModuleKind::Regular = kind { $regular } else { $other }\n+            };\n         }\n-    }\n \n-    fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n-        self.verify_llvm_ir = sess.verify_llvm_ir();\n-        self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n-        self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n-        self.inline_threshold = sess.opts.cg.inline_threshold;\n-        self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n-\n-        // Copy what clang does by turning on loop vectorization at O2 and\n-        // slp vectorization at O3. Otherwise configure other optimization aspects\n-        // of this pass manager builder.\n-        self.vectorize_loop = !sess.opts.cg.no_vectorize_loops\n-            && (sess.opts.optimize == config::OptLevel::Default\n-                || sess.opts.optimize == config::OptLevel::Aggressive);\n-\n-        self.vectorize_slp =\n-            !sess.opts.cg.no_vectorize_slp && sess.opts.optimize == config::OptLevel::Aggressive;\n-\n-        // Some targets (namely, NVPTX) interact badly with the MergeFunctions\n-        // pass. This is because MergeFunctions can generate new function calls\n-        // which may interfere with the target calling convention; e.g. for the\n-        // NVPTX target, PTX kernels should not call other PTX kernels.\n-        // MergeFunctions can also be configured to generate aliases instead,\n-        // but aliases are not supported by some backends (again, NVPTX).\n-        // Therefore, allow targets to opt out of the MergeFunctions pass,\n-        // but otherwise keep the pass enabled (at O2 and O3) since it can be\n-        // useful for reducing code size.\n-        self.merge_functions = match sess\n-            .opts\n-            .debugging_opts\n-            .merge_functions\n-            .unwrap_or(sess.target.target.options.merge_functions)\n+        let opt_level_and_size = if_regular!(Some(sess.opts.optimize), None);\n+\n+        let save_temps = sess.opts.cg.save_temps;\n+\n+        let should_emit_obj = sess.opts.output_types.contains_key(&OutputType::Exe)\n+            || match kind {\n+                ModuleKind::Regular => sess.opts.output_types.contains_key(&OutputType::Object),\n+                ModuleKind::Allocator => false,\n+                ModuleKind::Metadata => sess.opts.output_types.contains_key(&OutputType::Metadata),\n+            };\n+\n+        let emit_obj = if !should_emit_obj {\n+            EmitObj::None\n+        } else if sess.target.target.options.obj_is_bitcode\n+            || sess.opts.cg.linker_plugin_lto.enabled()\n         {\n-            MergeFunctions::Disabled => false,\n-            MergeFunctions::Trampolines | MergeFunctions::Aliases => {\n-                sess.opts.optimize == config::OptLevel::Default\n-                    || sess.opts.optimize == config::OptLevel::Aggressive\n+            EmitObj::Bitcode\n+        } else if sess.opts.debugging_opts.embed_bitcode {\n+            match sess.opts.optimize {\n+                config::OptLevel::No | config::OptLevel::Less => {\n+                    EmitObj::ObjectCode(BitcodeSection::Marker)\n+                }\n+                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n             }\n+        } else {\n+            EmitObj::ObjectCode(BitcodeSection::None)\n         };\n+\n+        ModuleConfig {\n+            passes: if_regular!(\n+                {\n+                    let mut passes = sess.opts.cg.passes.clone();\n+                    if sess.opts.debugging_opts.profile {\n+                        passes.push(\"insert-gcov-profiling\".to_owned());\n+                    }\n+                    passes\n+                },\n+                vec![]\n+            ),\n+\n+            opt_level: opt_level_and_size,\n+            opt_size: opt_level_and_size,\n+\n+            pgo_gen: if_regular!(\n+                sess.opts.cg.profile_generate.clone(),\n+                SwitchWithOptPath::Disabled\n+            ),\n+            pgo_use: if_regular!(sess.opts.cg.profile_use.clone(), None),\n+\n+            sanitizer: if_regular!(sess.opts.debugging_opts.sanitizer.clone(), None),\n+            sanitizer_recover: if_regular!(\n+                sess.opts.debugging_opts.sanitizer_recover.clone(),\n+                vec![]\n+            ),\n+            sanitizer_memory_track_origins: if_regular!(\n+                sess.opts.debugging_opts.sanitizer_memory_track_origins,\n+                0\n+            ),\n+\n+            emit_pre_lto_bc: if_regular!(\n+                save_temps || need_pre_lto_bitcode_for_incr_comp(sess),\n+                false\n+            ),\n+            emit_no_opt_bc: if_regular!(save_temps, false),\n+            emit_bc: if_regular!(\n+                save_temps || sess.opts.output_types.contains_key(&OutputType::Bitcode),\n+                save_temps\n+            ),\n+            emit_bc_compressed: match kind {\n+                ModuleKind::Regular | ModuleKind::Allocator => {\n+                    // Emit compressed bitcode files for the crate if we're\n+                    // emitting an rlib. Whenever an rlib is created, the\n+                    // bitcode is inserted into the archive in order to allow\n+                    // LTO against it.\n+                    need_crate_bitcode_for_rlib(sess)\n+                }\n+                ModuleKind::Metadata => false,\n+            },\n+            emit_ir: if_regular!(\n+                sess.opts.output_types.contains_key(&OutputType::LlvmAssembly),\n+                false\n+            ),\n+            emit_asm: if_regular!(\n+                sess.opts.output_types.contains_key(&OutputType::Assembly),\n+                false\n+            ),\n+            emit_obj,\n+\n+            verify_llvm_ir: sess.verify_llvm_ir(),\n+            no_prepopulate_passes: sess.opts.cg.no_prepopulate_passes,\n+            no_builtins: no_builtins || sess.target.target.options.no_builtins,\n+\n+            // Exclude metadata and allocator modules from time_passes output,\n+            // since they throw off the \"LLVM passes\" measurement.\n+            time_module: if_regular!(true, false),\n+\n+            // Copy what clang does by turning on loop vectorization at O2 and\n+            // slp vectorization at O3.\n+            vectorize_loop: !sess.opts.cg.no_vectorize_loops\n+                && (sess.opts.optimize == config::OptLevel::Default\n+                    || sess.opts.optimize == config::OptLevel::Aggressive),\n+            vectorize_slp: !sess.opts.cg.no_vectorize_slp\n+                && sess.opts.optimize == config::OptLevel::Aggressive,\n+\n+            // Some targets (namely, NVPTX) interact badly with the\n+            // MergeFunctions pass. This is because MergeFunctions can generate\n+            // new function calls which may interfere with the target calling\n+            // convention; e.g. for the NVPTX target, PTX kernels should not\n+            // call other PTX kernels. MergeFunctions can also be configured to\n+            // generate aliases instead, but aliases are not supported by some\n+            // backends (again, NVPTX). Therefore, allow targets to opt out of\n+            // the MergeFunctions pass, but otherwise keep the pass enabled (at\n+            // O2 and O3) since it can be useful for reducing code size.\n+            merge_functions: match sess\n+                .opts\n+                .debugging_opts\n+                .merge_functions\n+                .unwrap_or(sess.target.target.options.merge_functions)\n+            {\n+                MergeFunctions::Disabled => false,\n+                MergeFunctions::Trampolines | MergeFunctions::Aliases => {\n+                    sess.opts.optimize == config::OptLevel::Default\n+                        || sess.opts.optimize == config::OptLevel::Aggressive\n+                }\n+            },\n+\n+            inline_threshold: sess.opts.cg.inline_threshold,\n+            new_llvm_pass_manager: sess.opts.debugging_opts.new_llvm_pass_manager,\n+        }\n     }\n \n     pub fn bitcode_needed(&self) -> bool {\n@@ -353,99 +421,9 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n     let linker_info = LinkerInfo::new(tcx);\n     let crate_info = CrateInfo::new(tcx);\n \n-    // Figure out what we actually need to build.\n-    let mut modules_config = ModuleConfig::new(sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(vec![]);\n-    let mut allocator_config = ModuleConfig::new(vec![]);\n-\n-    if sess.opts.debugging_opts.profile {\n-        modules_config.passes.push(\"insert-gcov-profiling\".to_owned())\n-    }\n-\n-    modules_config.pgo_gen = sess.opts.cg.profile_generate.clone();\n-    modules_config.pgo_use = sess.opts.cg.profile_use.clone();\n-    modules_config.sanitizer = sess.opts.debugging_opts.sanitizer.clone();\n-    modules_config.sanitizer_recover = sess.opts.debugging_opts.sanitizer_recover.clone();\n-    modules_config.sanitizer_memory_track_origins =\n-        sess.opts.debugging_opts.sanitizer_memory_track_origins;\n-    modules_config.opt_level = Some(sess.opts.optimize);\n-    modules_config.opt_size = Some(sess.opts.optimize);\n-\n-    // Save all versions of the bytecode if we're saving our temporaries.\n-    if sess.opts.cg.save_temps {\n-        modules_config.emit_no_opt_bc = true;\n-        modules_config.emit_pre_lto_bc = true;\n-        modules_config.emit_bc = true;\n-        metadata_config.emit_bc = true;\n-        allocator_config.emit_bc = true;\n-    }\n-\n-    // Emit compressed bitcode files for the crate if we're emitting an rlib.\n-    // Whenever an rlib is created, the bitcode is inserted into the archive in\n-    // order to allow LTO against it.\n-    if need_crate_bitcode_for_rlib(sess) {\n-        modules_config.emit_bc_compressed = true;\n-        allocator_config.emit_bc_compressed = true;\n-    }\n-\n-    let emit_obj =\n-        if sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled() {\n-            EmitObj::Bitcode\n-        } else if sess.opts.debugging_opts.embed_bitcode {\n-            match sess.opts.optimize {\n-                config::OptLevel::No | config::OptLevel::Less => {\n-                    EmitObj::ObjectCode(BitcodeSection::Marker)\n-                }\n-                _ => EmitObj::ObjectCode(BitcodeSection::Full),\n-            }\n-        } else {\n-            EmitObj::ObjectCode(BitcodeSection::None)\n-        };\n-\n-    modules_config.emit_pre_lto_bc = need_pre_lto_bitcode_for_incr_comp(sess);\n-\n-    for output_type in sess.opts.output_types.keys() {\n-        match *output_type {\n-            OutputType::Bitcode => {\n-                modules_config.emit_bc = true;\n-            }\n-            OutputType::LlvmAssembly => {\n-                modules_config.emit_ir = true;\n-            }\n-            OutputType::Assembly => {\n-                modules_config.emit_asm = true;\n-                // If we're not using the LLVM assembler, this function\n-                // could be invoked specially with output_type_assembly, so\n-                // in this case we still want the metadata object file.\n-                if !sess.opts.output_types.contains_key(&OutputType::Assembly) {\n-                    metadata_config.emit_obj = emit_obj;\n-                    allocator_config.emit_obj = emit_obj;\n-                }\n-            }\n-            OutputType::Object => {\n-                modules_config.emit_obj = emit_obj;\n-            }\n-            OutputType::Metadata => {\n-                metadata_config.emit_obj = emit_obj;\n-            }\n-            OutputType::Exe => {\n-                modules_config.emit_obj = emit_obj;\n-                metadata_config.emit_obj = emit_obj;\n-                allocator_config.emit_obj = emit_obj;\n-            }\n-            OutputType::Mir => {}\n-            OutputType::DepInfo => {}\n-        }\n-    }\n-\n-    modules_config.set_flags(sess, no_builtins);\n-    metadata_config.set_flags(sess, no_builtins);\n-    allocator_config.set_flags(sess, no_builtins);\n-\n-    // Exclude metadata and allocator modules from time_passes output, since\n-    // they throw off the \"LLVM passes\" measurement.\n-    metadata_config.time_module = false;\n-    allocator_config.time_module = false;\n+    let regular_config = ModuleConfig::new(ModuleKind::Regular, sess, no_builtins);\n+    let metadata_config = ModuleConfig::new(ModuleKind::Metadata, sess, no_builtins);\n+    let allocator_config = ModuleConfig::new(ModuleKind::Allocator, sess, no_builtins);\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n     let (codegen_worker_send, codegen_worker_receive) = channel();\n@@ -459,7 +437,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         coordinator_receive,\n         total_cgus,\n         sess.jobserver.clone(),\n-        Arc::new(modules_config),\n+        Arc::new(regular_config),\n         Arc::new(metadata_config),\n         Arc::new(allocator_config),\n         coordinator_send.clone(),\n@@ -959,7 +937,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     coordinator_receive: Receiver<Box<dyn Any + Send>>,\n     total_cgus: usize,\n     jobserver: Client,\n-    modules_config: Arc<ModuleConfig>,\n+    regular_config: Arc<ModuleConfig>,\n     metadata_config: Arc<ModuleConfig>,\n     allocator_config: Arc<ModuleConfig>,\n     tx_to_llvm_workers: Sender<Box<dyn Any + Send>>,\n@@ -1042,7 +1020,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n         output_filenames: tcx.output_filenames(LOCAL_CRATE),\n-        regular_module_config: modules_config,\n+        regular_module_config: regular_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,\n         tm_factory: TargetMachineFactory(backend.target_machine_factory(tcx.sess, ol, false)),"}]}