{"sha": "ef04fc82b198487b0ffb1832304714519f9f1a35", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDRmYzgyYjE5ODQ4N2IwZmZiMTgzMjMwNDcxNDUxOWY5ZjFhMzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-14T13:17:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-14T13:17:16Z"}, "message": "Auto merge of #38944 - michaelwoerister:incr-generics-partitioning, r=nikomatsakis\n\ntrans: Treat generics like regular functions, not like #[inline] function, during CGU partitioning\n\nThis PR makes generics be treated just like regular functions during CGU partitioning:\n\n+ the function instantiation is placed in a codegen unit based on the function's DefPath,\n+ unless it is marked with `#[inline]`  -- which causes a private copy of the function to be placed in every referencing codegen unit.\n\nThis has the following effects:\n+ Multi codegen unit builds will become faster because code for generic functions is duplicated less.\n+ Multi codegen unit builds might have lower runtime performance, since generics are not available for inlining automatically any more.\n+ Single codegen unit builds are not affected one way or the other.\n\nThis partitioning scheme is particularly good for incremental compilation as it drastically reduces the number of false positives during codegen unit invalidation.\n\nI'd love to have a benchmark suite for estimating the effect on runtime performance for changes like this one.\n\nr? @nikomatsakis\n\ncc @rust-lang/compiler", "tree": {"sha": "c8c575d60cac53b8d3c90685fe5e489e953e193e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8c575d60cac53b8d3c90685fe5e489e953e193e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef04fc82b198487b0ffb1832304714519f9f1a35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef04fc82b198487b0ffb1832304714519f9f1a35", "html_url": "https://github.com/rust-lang/rust/commit/ef04fc82b198487b0ffb1832304714519f9f1a35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef04fc82b198487b0ffb1832304714519f9f1a35/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4c0207148f58163af00d81428bdc74da651928c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c0207148f58163af00d81428bdc74da651928c", "html_url": "https://github.com/rust-lang/rust/commit/b4c0207148f58163af00d81428bdc74da651928c"}, {"sha": "fc9dfcacf87eb5bb24271cdbb3863345fd27d751", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc9dfcacf87eb5bb24271cdbb3863345fd27d751", "html_url": "https://github.com/rust-lang/rust/commit/fc9dfcacf87eb5bb24271cdbb3863345fd27d751"}], "stats": {"total": 362, "additions": 175, "deletions": 187}, "files": [{"sha": "496a3d4a498478ce148a59f0d7d9170ec81a7267", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -211,6 +211,7 @@ pub trait CrateStore<'tcx> {\n     fn is_foreign_item(&self, did: DefId) -> bool;\n     fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n+    fn is_exported_symbol(&self, def_id: DefId) -> bool;\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -258,11 +259,6 @@ pub trait CrateStore<'tcx> {\n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n-    /// Take a look if we need to inline or monomorphize this. If so, we\n-    /// will emit code for this item in the local crate, and thus\n-    /// create a translation item for it.\n-    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool;\n-\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum>;\n@@ -368,6 +364,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n     fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n     fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n+    fn is_exported_symbol(&self, def_id: DefId) -> bool { false }\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -436,9 +433,6 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n-    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool {\n-        bug!(\"can_have_local_instance\")\n-    }\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that."}, {"sha": "8f7b9c24cbf8a5c4adc8de1a62f3f2b00c40def1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -302,10 +302,13 @@ impl<'a> CrateLoader<'a> {\n             crate_root.def_path_table.decode(&metadata)\n         });\n \n+        let exported_symbols = crate_root.exported_symbols.decode(&metadata).collect();\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n             def_path_table: def_path_table,\n+            exported_symbols: exported_symbols,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),"}, {"sha": "761041ad7198aa6cdd3d146d3199280bc6d5998b", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -80,6 +80,8 @@ pub struct CrateMetadata {\n     /// compilation support.\n     pub def_path_table: DefPathTable,\n \n+    pub exported_symbols: FxHashSet<DefIndex>,\n+\n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n "}, {"sha": "7cd26df0246eab36eca935717958451e8f723384", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -226,6 +226,10 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.do_is_statically_included_foreign_item(def_id)\n     }\n \n+    fn is_exported_symbol(&self, def_id: DefId) -> bool {\n+        self.get_crate_data(def_id.krate).exported_symbols.contains(&def_id.index)\n+    }\n+\n     fn is_dllimport_foreign_item(&self, def_id: DefId) -> bool {\n         if def_id.krate == LOCAL_CRATE {\n             self.dllimport_foreign_items.borrow().contains(&def_id.index)\n@@ -466,11 +470,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def.krate).is_item_mir_available(def.index)\n     }\n \n-    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool {\n-        self.dep_graph.read(DepNode::MetaData(def));\n-        def.is_local() || self.get_crate_data(def.krate).can_have_local_instance(tcx, def.index)\n-    }\n-\n     fn crates(&self) -> Vec<CrateNum>\n     {\n         let mut result = vec![];"}, {"sha": "4abdee345c2985011e4a2d9e87954652ef95d47f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 33, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -445,14 +445,6 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Closure(_) => return None,\n         })\n     }\n-    fn is_const_fn(&self, meta: &CrateMetadata) -> bool {\n-        let constness = match *self {\n-            EntryKind::Method(data) => data.decode(meta).fn_data.constness,\n-            EntryKind::Fn(data) => data.decode(meta).constness,\n-            _ => hir::Constness::NotConst,\n-        };\n-        constness == hir::Constness::Const\n-    }\n }\n \n impl<'a, 'tcx> CrateMetadata {\n@@ -804,29 +796,6 @@ impl<'a, 'tcx> CrateMetadata {\n         self.maybe_entry(id).and_then(|item| item.decode(self).mir).is_some()\n     }\n \n-    pub fn can_have_local_instance(&self,\n-                                   tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   id: DefIndex) -> bool {\n-        self.maybe_entry(id).map_or(false, |item| {\n-            let item = item.decode(self);\n-            // if we don't have a MIR, then this item was never meant to be locally instantiated\n-            // or we have a bug in the metadata serialization\n-            item.mir.is_some() && (\n-                // items with generics always can have local instances if monomorphized\n-                item.generics.map_or(false, |generics| {\n-                    let generics = generics.decode((self, tcx));\n-                    generics.parent_types != 0 || !generics.types.is_empty()\n-                }) ||\n-                match item.kind {\n-                    EntryKind::Closure(_) => true,\n-                    _ => false,\n-                } ||\n-                item.kind.is_const_fn(self) ||\n-                attr::requests_inline(&self.get_attributes(&item))\n-            )\n-        })\n-    }\n-\n     pub fn maybe_get_item_mir(&self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               id: DefIndex)\n@@ -1031,7 +1000,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn get_exported_symbols(&self) -> Vec<DefId> {\n-        self.root.exported_symbols.decode(self).map(|index| self.local_def_id(index)).collect()\n+        self.exported_symbols.iter().map(|&index| self.local_def_id(index)).collect()\n     }\n \n     pub fn get_macro(&self, id: DefIndex) -> (ast::Name, MacroDef) {\n@@ -1043,7 +1012,12 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     pub fn is_const_fn(&self, id: DefIndex) -> bool {\n-        self.entry(id).kind.is_const_fn(self)\n+        let constness = match self.entry(id).kind {\n+            EntryKind::Method(data) => data.decode(self).fn_data.constness,\n+            EntryKind::Fn(data) => data.decode(self).constness,\n+            _ => hir::Constness::NotConst,\n+        };\n+        constness == hir::Constness::Const\n     }\n \n     pub fn is_foreign_item(&self, id: DefIndex) -> bool {"}, {"sha": "8f8c48a06b2c086bc749b72513442d3067b46ae4", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -152,6 +152,15 @@ fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             assert!(!substs.has_erasable_regions());\n             assert!(!substs.needs_subst());\n             substs.visit_with(&mut hasher);\n+\n+            // If this is an instance of a generic function, we also hash in\n+            // the ID of the instantiating crate. This avoids symbol conflicts\n+            // in case the same instances is emitted in two crates of the same\n+            // project.\n+            if substs.types().next().is_some() {\n+                hasher.hash(scx.tcx().crate_name.as_str());\n+                hasher.hash(scx.sess().local_crate_disambiguator().as_str());\n+            }\n         }\n     });\n "}, {"sha": "5e409a2aa5520e076afd3a7d1dbb16d05f9c2c9b", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 53, "deletions": 27, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -212,7 +212,7 @@ use glue::{self, DropGlueKind};\n use monomorphize::{self, Instance};\n use util::nodemap::{FxHashSet, FxHashMap, DefIdMap};\n \n-use trans_item::{TransItem, DefPathBasedNames};\n+use trans_item::{TransItem, DefPathBasedNames, InstantiationMode};\n \n use std::iter;\n \n@@ -337,6 +337,10 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         TransItem::Static(node_id) => {\n             let def_id = scx.tcx().map.local_def_id(node_id);\n+\n+            // Sanity check whether this ended up being collected accidentally\n+            debug_assert!(should_trans_locally(scx.tcx(), def_id));\n+\n             let ty = scx.tcx().item_type(def_id);\n             let ty = glue::get_drop_glue_type(scx, ty);\n             neighbors.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n@@ -346,6 +350,9 @@ fn collect_items_rec<'a, 'tcx: 'a>(scx: &SharedCrateContext<'a, 'tcx>,\n             collect_neighbours(scx, Instance::mono(scx, def_id), &mut neighbors);\n         }\n         TransItem::Fn(instance) => {\n+            // Sanity check whether this ended up being collected accidentally\n+            debug_assert!(should_trans_locally(scx.tcx(), instance.def));\n+\n             // Keep track of the monomorphization recursion depth\n             recursion_depth_reset = Some(check_recursion_limit(scx.tcx(),\n                                                                instance,\n@@ -374,7 +381,7 @@ fn record_inlining_canditates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         callees: &[TransItem<'tcx>],\n                                         inlining_map: &mut InliningMap<'tcx>) {\n     let is_inlining_candidate = |trans_item: &TransItem<'tcx>| {\n-        trans_item.needs_local_copy(tcx)\n+        trans_item.instantiation_mode(tcx) == InstantiationMode::LocalCopy\n     };\n \n     let inlining_candidates = callees.into_iter()\n@@ -490,15 +497,16 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                         .require(ExchangeMallocFnLangItem)\n                         .unwrap_or_else(|e| self.scx.sess().fatal(&e));\n \n-                assert!(can_have_local_instance(self.scx.tcx(), exchange_malloc_fn_def_id));\n-                let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n-                let exchange_malloc_fn_trans_item =\n-                    create_fn_trans_item(self.scx,\n-                                         exchange_malloc_fn_def_id,\n-                                         empty_substs,\n-                                         self.param_substs);\n+                if should_trans_locally(self.scx.tcx(), exchange_malloc_fn_def_id) {\n+                    let empty_substs = self.scx.empty_substs_for_def_id(exchange_malloc_fn_def_id);\n+                    let exchange_malloc_fn_trans_item =\n+                        create_fn_trans_item(self.scx,\n+                                             exchange_malloc_fn_def_id,\n+                                             empty_substs,\n+                                             self.param_substs);\n \n-                self.output.push(exchange_malloc_fn_trans_item);\n+                    self.output.push(exchange_malloc_fn_trans_item);\n+                }\n             }\n             _ => { /* not interesting */ }\n         }\n@@ -609,7 +617,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             match tcx.item_type(def_id).sty {\n                 ty::TyFnDef(def_id, _, f) => {\n                     // Some constructors also have type TyFnDef but they are\n-                    // always instantiated inline and don't result in\n+                    // always instantiated inline and don't result in a\n                     // translation item. Same for FFI functions.\n                     if let Some(hir_map::NodeForeignItem(_)) = tcx.map.get_if_local(def_id) {\n                         return false;\n@@ -625,7 +633,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                 _ => return false\n             }\n \n-            can_have_local_instance(tcx, def_id)\n+            should_trans_locally(tcx, def_id)\n         }\n     }\n \n@@ -675,10 +683,27 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     }\n }\n \n-fn can_have_local_instance<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     def_id: DefId)\n-                                     -> bool {\n-    tcx.sess.cstore.can_have_local_instance(tcx, def_id)\n+// Returns true if we should translate an instance in the local crate.\n+// Returns false if we can just link to the upstream crate and therefore don't\n+// need a translation item.\n+fn should_trans_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  def_id: DefId)\n+                                  -> bool {\n+    if def_id.is_local() {\n+        true\n+    } else {\n+        if tcx.sess.cstore.is_exported_symbol(def_id) ||\n+           tcx.sess.cstore.is_foreign_item(def_id) {\n+            // We can link to the item in question, no instance needed in this\n+            // crate\n+            false\n+        } else {\n+            if !tcx.sess.cstore.is_item_mir_available(def_id) {\n+                bug!(\"Cannot create local trans-item for {:?}\", def_id)\n+            }\n+            true\n+        }\n+    }\n }\n \n fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n@@ -698,14 +723,15 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // Make sure the BoxFreeFn lang-item gets translated if there is a boxed value.\n     if let ty::TyBox(content_type) = ty.sty {\n         let def_id = scx.tcx().require_lang_item(BoxFreeFnLangItem);\n-        assert!(can_have_local_instance(scx.tcx(), def_id));\n-        let box_free_fn_trans_item =\n-            create_fn_trans_item(scx,\n-                                 def_id,\n-                                 scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n-                                 scx.tcx().intern_substs(&[]));\n-\n-        output.push(box_free_fn_trans_item);\n+\n+        if should_trans_locally(scx.tcx(), def_id) {\n+            let box_free_fn_trans_item =\n+                create_fn_trans_item(scx,\n+                                     def_id,\n+                                     scx.tcx().mk_substs(iter::once(Kind::from(content_type))),\n+                                     scx.tcx().intern_substs(&[]));\n+            output.push(box_free_fn_trans_item);\n+        }\n     }\n \n     // If the type implements Drop, also add a translation item for the\n@@ -735,7 +761,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             _ => bug!()\n         };\n \n-        if can_have_local_instance(scx.tcx(), destructor_did) {\n+        if should_trans_locally(scx.tcx(), destructor_did) {\n             let trans_item = create_fn_trans_item(scx,\n                                                   destructor_did,\n                                                   substs,\n@@ -1080,7 +1106,7 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n                         None\n                     }\n                 })\n-                .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n+                .filter(|&(def_id, _)| should_trans_locally(scx.tcx(), def_id))\n                 .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n             output.extend(methods);\n         }\n@@ -1255,7 +1281,7 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(scx: &SharedCrateContext<'a, '\n                         continue;\n                     }\n \n-                    if can_have_local_instance(tcx, method.def_id) {\n+                    if should_trans_locally(tcx, method.def_id) {\n                         let item = create_fn_trans_item(scx,\n                                                         method.def_id,\n                                                         callee_substs,"}, {"sha": "d1d167306c1fdb9fff02e4d06850415204b9bfae", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 16, "deletions": 59, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -53,8 +53,6 @@\n //! - One for \"stable\", that is non-generic, code\n //! - One for more \"volatile\" code, i.e. monomorphized instances of functions\n //!   defined in that module\n-//! - Code for monomorphized instances of functions from external crates gets\n-//!   placed into every codegen unit that uses that instance.\n //!\n //! In order to see why this heuristic makes sense, let's take a look at when a\n //! codegen unit can get invalidated:\n@@ -82,17 +80,6 @@\n //! side-effect of references a little by at least not touching the non-generic\n //! code of the module.\n //!\n-//! As another optimization, monomorphized functions from external crates get\n-//! some special handling. Since we assume that the definition of such a\n-//! function changes rather infrequently compared to local items, we can just\n-//! instantiate external functions in every codegen unit where it is referenced\n-//! -- without having to fear that doing this will cause a lot of unnecessary\n-//! re-compilations. If such a reference is added or removed, the codegen unit\n-//! has to be re-translated anyway.\n-//! (Note that this only makes sense if external crates actually don't change\n-//! frequently. For certain multi-crate projects this might not be a valid\n-//! assumption).\n-//!\n //! A Note on Inlining\n //! ------------------\n //! As briefly mentioned above, in order for LLVM to be able to inline a\n@@ -107,10 +94,9 @@\n //!   inlined, so it can distribute function instantiations accordingly. Since\n //!   there is no way of knowing for sure which functions LLVM will decide to\n //!   inline in the end, we apply a heuristic here: Only functions marked with\n-//!   #[inline] and (as stated above) functions from external crates are\n-//!   considered for inlining by the partitioner. The current implementation\n-//!   will not try to determine if a function is likely to be inlined by looking\n-//!   at the functions definition.\n+//!   #[inline] are considered for inlining by the partitioner. The current\n+//!   implementation will not try to determine if a function is likely to be\n+//!   inlined by looking at the functions definition.\n //!\n //! Note though that as a side-effect of creating a codegen units per\n //! source-level module, functions from the same module will be available for\n@@ -133,7 +119,7 @@ use std::sync::Arc;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::symbol::{Symbol, InternedString};\n-use trans_item::TransItem;\n+use trans_item::{TransItem, InstantiationMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n \n pub enum PartitioningStrategy {\n@@ -326,13 +312,15 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     let tcx = scx.tcx();\n     let mut roots = FxHashSet();\n     let mut codegen_units = FxHashMap();\n+    let is_incremental_build = tcx.sess.opts.incremental.is_some();\n \n     for trans_item in trans_items {\n-        let is_root = !trans_item.is_instantiated_only_on_demand(tcx);\n+        let is_root = trans_item.instantiation_mode(tcx) == InstantiationMode::GloballyShared;\n \n         if is_root {\n             let characteristic_def_id = characteristic_def_id_of_trans_item(scx, trans_item);\n-            let is_volatile = trans_item.is_generic_fn();\n+            let is_volatile = is_incremental_build &&\n+                              trans_item.is_generic_fn();\n \n             let codegen_unit_name = match characteristic_def_id {\n                 Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n@@ -350,25 +338,9 @@ fn place_root_translation_items<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n                 Some(explicit_linkage) => explicit_linkage,\n                 None => {\n                     match trans_item {\n+                        TransItem::Fn(..) |\n                         TransItem::Static(..) => llvm::ExternalLinkage,\n                         TransItem::DropGlue(..) => unreachable!(),\n-                        // Is there any benefit to using ExternalLinkage?:\n-                        TransItem::Fn(ref instance) => {\n-                            if instance.substs.types().next().is_none() {\n-                                // This is a non-generic functions, we always\n-                                // make it visible externally on the chance that\n-                                // it might be used in another codegen unit.\n-                                // Later on base::internalize_symbols() will\n-                                // assign \"internal\" linkage to those symbols\n-                                // that are not referenced from other codegen\n-                                // units (and are not publicly visible).\n-                                llvm::ExternalLinkage\n-                            } else {\n-                                // In the current setup, generic functions cannot\n-                                // be roots.\n-                                unreachable!()\n-                            }\n-                        }\n                     }\n                 }\n             };\n@@ -448,29 +420,14 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n             if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n                 // This is a root, just copy it over\n                 new_codegen_unit.items.insert(trans_item, *linkage);\n-            } else if initial_partitioning.roots.contains(&trans_item) {\n-                // This item will be instantiated in some other codegen unit,\n-                // so we just add it here with AvailableExternallyLinkage\n-                // FIXME(mw): I have not seen it happening yet but having\n-                //            available_externally here could potentially lead\n-                //            to the same problem with exception handling tables\n-                //            as in the case below.\n-                new_codegen_unit.items.insert(trans_item,\n-                                              llvm::AvailableExternallyLinkage);\n-            } else if trans_item.is_from_extern_crate() && !trans_item.is_generic_fn() {\n-                // FIXME(mw): It would be nice if we could mark these as\n-                // `AvailableExternallyLinkage`, since they should have\n-                // been instantiated in the extern crate. But this\n-                // sometimes leads to crashes on Windows because LLVM\n-                // does not handle exception handling table instantiation\n-                // reliably in that case.\n-                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             } else {\n-                // We can't be sure if this will also be instantiated\n-                // somewhere else, so we add an instance here with\n-                // InternalLinkage so we don't get any conflicts.\n-                new_codegen_unit.items.insert(trans_item,\n-                                              llvm::InternalLinkage);\n+                if initial_partitioning.roots.contains(&trans_item) {\n+                    bug!(\"GloballyShared trans-item inlined into other CGU: \\\n+                          {:?}\", trans_item);\n+                }\n+\n+                // This is a cgu-private copy\n+                new_codegen_unit.items.insert(trans_item, llvm::InternalLinkage);\n             }\n         }\n "}, {"sha": "816c34425437166e985b823fe2e75f7d05754d50", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -45,6 +45,18 @@ pub enum TransItem<'tcx> {\n     Static(NodeId)\n }\n \n+/// Describes how a translation item will be instantiated in object files.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n+pub enum InstantiationMode {\n+    /// There will be exactly one instance of the given TransItem. It will have\n+    /// external linkage so that it can be linked to from other codegen units.\n+    GloballyShared,\n+\n+    /// Each codegen unit containing a reference to the given TransItem will\n+    /// have its own private copy of the function (with internal linkage).\n+    LocalCopy,\n+}\n+\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n@@ -231,22 +243,21 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    /// True if the translation item should only be translated to LLVM IR if\n-    /// it is referenced somewhere (like inline functions, for example).\n-    pub fn is_instantiated_only_on_demand(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        if self.explicit_linkage(tcx).is_some() {\n-            return false;\n-        }\n-\n+    pub fn instantiation_mode(&self,\n+                              tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                              -> InstantiationMode {\n         match *self {\n             TransItem::Fn(ref instance) => {\n-                !instance.def.is_local() ||\n-                instance.substs.types().next().is_some() ||\n-                common::is_closure(tcx, instance.def) ||\n-                attr::requests_inline(&tcx.get_attrs(instance.def)[..])\n+                if self.explicit_linkage(tcx).is_none() &&\n+                   (common::is_closure(tcx, instance.def) ||\n+                    attr::requests_inline(&tcx.get_attrs(instance.def)[..])) {\n+                    InstantiationMode::LocalCopy\n+                } else {\n+                    InstantiationMode::GloballyShared\n+                }\n             }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n+            TransItem::DropGlue(..) => InstantiationMode::LocalCopy,\n+            TransItem::Static(..) => InstantiationMode::GloballyShared,\n         }\n     }\n \n@@ -260,18 +271,6 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n-    /// Returns true if there has to be a local copy of this TransItem in every\n-    /// codegen unit that references it (as with inlined functions, for example)\n-    pub fn needs_local_copy(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        // Currently everything that is instantiated only on demand is done so\n-        // with \"internal\" linkage, so we need a copy to be present in every\n-        // codegen unit.\n-        // This is coincidental: We could also instantiate something only if it\n-        // is referenced (e.g. a regular, private function) but place it in its\n-        // own codegen unit with \"external\" linkage.\n-        self.is_instantiated_only_on_demand(tcx)\n-    }\n-\n     pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n         let def_id = match *self {\n             TransItem::Fn(ref instance) => instance.def,"}, {"sha": "db36b50702a43efd090be185914bddd167dd9527", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -57,8 +57,8 @@ mod mod3 {\n }\n \n // Make sure the two generic functions from the extern crate get instantiated\n-// privately in every module they are use in.\n-//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ extern_generic[Internal] extern_generic-mod1[Internal] extern_generic-mod2[Internal] extern_generic-mod1-mod1[Internal]\n-//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ extern_generic[Internal] extern_generic-mod1[Internal] extern_generic-mod2[Internal] extern_generic-mod1-mod1[Internal]\n+// once for the current crate\n+//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ cgu_generic_function.volatile[External]\n+//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ cgu_generic_function.volatile[External]\n \n //~ TRANS_ITEM drop-glue i8"}, {"sha": "70fc75c6970b7a23218fd245ab5cef7897b264bb", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -16,10 +16,10 @@\n #![allow(dead_code)]\n #![crate_type=\"lib\"]\n \n-//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic[Internal]\n-//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic-mod1[Internal]\n-//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic-mod1-mod1[Internal]\n-//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic-mod2[Internal]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[External]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[External]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[External]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[External]\n pub fn generic<T>(x: T) -> T { x }\n \n //~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[External]"}, {"sha": "7a0217072f32c597cd44011f191f4bbaf7dff69d", "filename": "src/test/codegen-units/partitioning/vtable-through-const.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fvtable-through-const.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -74,19 +74,19 @@ fn main() {\n     // Since Trait1::do_something() is instantiated via its default implementation,\n     // it is considered a generic and is instantiated here only because it is\n     // referenced in this module.\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something_else[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n \n     // Although it is never used, Trait1::do_something_else() has to be\n     // instantiated locally here too, otherwise the <&u32 as &Trait1> vtable\n     // could not be fully constructed.\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::Trait1[0]::do_something[0]<u32> @@ vtable_through_const-mod1.volatile[External]\n     mod1::TRAIT1_REF.do_something();\n \n     // Same as above\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const[Internal]\n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::{{impl}}[1]::do_something_else[0]<u8> @@ vtable_through_const-mod1.volatile[External]\n     mod1::TRAIT1_GEN_REF.do_something(0u8);\n \n-    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const[Internal]\n+    //~ TRANS_ITEM fn vtable_through_const::mod1[0]::id[0]<char> @@ vtable_through_const-mod1.volatile[External]\n     mod1::ID_CHAR('x');\n }"}, {"sha": "3cbc5593ac0a2241926a577341285a84aa9b0732", "filename": "src/test/run-make/stable-symbol-names/Makefile", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2FMakefile?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -9,14 +9,32 @@\n #  5. write the result into a file\n \n dump-symbols = nm \"$(TMPDIR)/lib$(1).rlib\" \\\n-             | grep -E \"some_test_function|Bar|bar\" \\\n+             | grep -E \"$(2)\" \\\n              | sed \"s/.*\\(_ZN.*E\\).*/\\1/\" \\\n              | sort \\\n-             > \"$(TMPDIR)/$(1).nm\"\n+             > \"$(TMPDIR)/$(1)$(3).nm\"\n+\n+# This test\n+# - compiles each of the two crates 2 times and makes sure each time we get\n+#   exactly the same symbol names\n+# - makes sure that both crates agree on the same symbol names for monomorphic\n+#   functions\n \n all:\n \t$(RUSTC) stable-symbol-names1.rs\n+\t$(call dump-symbols,stable_symbol_names1,generic_|mono_,_v1)\n+\trm $(TMPDIR)/libstable_symbol_names1.rlib\n+\t$(RUSTC) stable-symbol-names1.rs\n+\t$(call dump-symbols,stable_symbol_names1,generic_|mono_,_v2)\n+\tcmp \"$(TMPDIR)/stable_symbol_names1_v1.nm\" \"$(TMPDIR)/stable_symbol_names1_v2.nm\"\n+\n \t$(RUSTC) stable-symbol-names2.rs\n-\t$(call dump-symbols,stable_symbol_names1)\n-\t$(call dump-symbols,stable_symbol_names2)\n-\tcmp \"$(TMPDIR)/stable_symbol_names1.nm\" \"$(TMPDIR)/stable_symbol_names2.nm\"\n+\t$(call dump-symbols,stable_symbol_names2,generic_|mono_,_v1)\n+\trm $(TMPDIR)/libstable_symbol_names2.rlib\n+\t$(RUSTC) stable-symbol-names2.rs\n+\t$(call dump-symbols,stable_symbol_names2,generic_|mono_,_v2)\n+\tcmp \"$(TMPDIR)/stable_symbol_names2_v1.nm\" \"$(TMPDIR)/stable_symbol_names2_v2.nm\"\n+\n+\t$(call dump-symbols,stable_symbol_names1,mono_,_cross)\n+\t$(call dump-symbols,stable_symbol_names2,mono_,_cross)\n+\tcmp \"$(TMPDIR)/stable_symbol_names1_cross.nm\" \"$(TMPDIR)/stable_symbol_names2_cross.nm\""}, {"sha": "7344bdf49f6f2e2cde77bd4e363addebfd9199a7", "filename": "src/test/run-make/stable-symbol-names/stable-symbol-names1.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names1.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -11,26 +11,31 @@\n #![crate_type=\"rlib\"]\n \n pub trait Foo {\n-  fn foo<T>();\n+  fn generic_method<T>();\n }\n \n pub struct Bar;\n \n impl Foo for Bar {\n-  fn foo<T>() {}\n+  fn generic_method<T>() {}\n }\n \n-pub fn bar() {\n-  Bar::foo::<Bar>();\n+pub fn mono_function() {\n+  Bar::generic_method::<Bar>();\n }\n \n-pub fn some_test_function<T>(t: T) -> T {\n+pub fn mono_function_lifetime<'a>(x: &'a u64) -> u64 {\n+  *x\n+}\n+\n+pub fn generic_function<T>(t: T) -> T {\n   t\n }\n \n pub fn user() {\n-  some_test_function(0u32);\n-  some_test_function(\"abc\");\n+  generic_function(0u32);\n+  generic_function(\"abc\");\n   let x = 2u64;\n-  some_test_function(&x);\n+  generic_function(&x);\n+  let _ = mono_function_lifetime(&x);\n }"}, {"sha": "eacba4ddb25c0c5e5a41a59480fd15da24f953b9", "filename": "src/test/run-make/stable-symbol-names/stable-symbol-names2.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef04fc82b198487b0ffb1832304714519f9f1a35/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstable-symbol-names%2Fstable-symbol-names2.rs?ref=ef04fc82b198487b0ffb1832304714519f9f1a35", "patch": "@@ -13,14 +13,16 @@\n extern crate stable_symbol_names1;\n \n pub fn user() {\n-  stable_symbol_names1::some_test_function(1u32);\n-  stable_symbol_names1::some_test_function(\"def\");\n+  stable_symbol_names1::generic_function(1u32);\n+  stable_symbol_names1::generic_function(\"def\");\n   let x = 2u64;\n-  stable_symbol_names1::some_test_function(&x);\n+  stable_symbol_names1::generic_function(&x);\n+  stable_symbol_names1::mono_function();\n+  stable_symbol_names1::mono_function_lifetime(&0);\n }\n \n pub fn trait_impl_test_function() {\n   use stable_symbol_names1::*;\n-  Bar::foo::<Bar>();\n-  bar();\n+  Bar::generic_method::<Bar>();\n }\n+"}]}