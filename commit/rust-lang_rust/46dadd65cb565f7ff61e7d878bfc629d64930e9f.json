{"sha": "46dadd65cb565f7ff61e7d878bfc629d64930e9f", "node_id": "C_kwDOAAsO6NoAKDQ2ZGFkZDY1Y2I1NjVmN2ZmNjFlN2Q4NzhiZmM2MjlkNjQ5MzBlOWY", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-09-09T13:36:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-09T13:36:34Z"}, "message": "Rollup merge of #101475 - joboet:hermit_futex_locks, r=m-ou-se\n\nUse futex-based locks and thread parker on Hermit\n\n[Hermit now has futex syscalls](https://github.com/hermitcore/libhermit-rs/pull/534), which means Hermit can share the well-tested and performant locks and thread parker used on Linux.\n\nPing `@mkroening,` `@stlankes`\nr? `@m-ou-se`", "tree": {"sha": "c22b2b32d387fa2a203b6ca698b40026948f47f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c22b2b32d387fa2a203b6ca698b40026948f47f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46dadd65cb565f7ff61e7d878bfc629d64930e9f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjG0FiCRBK7hj4Ov3rIwAAlVMIAC25BtKKv5xNrB5JBpqkVibk\nHdiZVsM8GsRGnQe1hqEpf9tXQrwg0LS7YuQolPnmaAqRUjTM4Wn1BNAAeM1zC6hT\n6n+1Y+U0SzAQblvGjl/SZU1eJYgqVgMlyoX6vd9FdAYIXs5+t9myZLkHuzvTGEyx\nINwmlWZHRwgC7co6LEnnndqIBdD31HQEOXIQzUvGnSmr6UXRXAxi/rZmDyNc+FU+\n6vjZFxdCIqMM2Aapub26a1ulzbS7VjYwro5/C5hrkkLpWG/pKcmqZeqkiFnFvA8w\n6m9vNQ4FFu4cYOvfkiMkdlbZiG6NbqoFHy+VtZncl1N7qwK/h0AA7IaILblgqOg=\n=NMK/\n-----END PGP SIGNATURE-----\n", "payload": "tree c22b2b32d387fa2a203b6ca698b40026948f47f8\nparent 98f3001eecbe4cbd091c10ffab45b4c164bb507b\nparent 262193e044a4604807a82d2a249dfbbb72a1bade\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1662730594 +0200\ncommitter GitHub <noreply@github.com> 1662730594 +0200\n\nRollup merge of #101475 - joboet:hermit_futex_locks, r=m-ou-se\n\nUse futex-based locks and thread parker on Hermit\n\n[Hermit now has futex syscalls](https://github.com/hermitcore/libhermit-rs/pull/534), which means Hermit can share the well-tested and performant locks and thread parker used on Linux.\n\nPing `@mkroening,` `@stlankes`\nr? `@m-ou-se`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46dadd65cb565f7ff61e7d878bfc629d64930e9f", "html_url": "https://github.com/rust-lang/rust/commit/46dadd65cb565f7ff61e7d878bfc629d64930e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46dadd65cb565f7ff61e7d878bfc629d64930e9f/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98f3001eecbe4cbd091c10ffab45b4c164bb507b", "url": "https://api.github.com/repos/rust-lang/rust/commits/98f3001eecbe4cbd091c10ffab45b4c164bb507b", "html_url": "https://github.com/rust-lang/rust/commit/98f3001eecbe4cbd091c10ffab45b4c164bb507b"}, {"sha": "262193e044a4604807a82d2a249dfbbb72a1bade", "url": "https://api.github.com/repos/rust-lang/rust/commits/262193e044a4604807a82d2a249dfbbb72a1bade", "html_url": "https://github.com/rust-lang/rust/commit/262193e044a4604807a82d2a249dfbbb72a1bade"}], "stats": {"total": 509, "additions": 53, "deletions": 456}, "files": [{"sha": "4e0e72d34153f0a84c173b2194f8f07846ea0f0c", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46dadd65cb565f7ff61e7d878bfc629d64930e9f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/46dadd65cb565f7ff61e7d878bfc629d64930e9f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=46dadd65cb565f7ff61e7d878bfc629d64930e9f", "patch": "@@ -1656,12 +1656,13 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.2.0\"\n+version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1ab7905ea95c6d9af62940f9d7dd9596d54c334ae2c15300c482051292d5637f\"\n+checksum = \"ee512640fe35acbfb4bb779db6f0d80704c2cacfa2e39b601ef3e3f47d1ae4c7\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n+ \"rustc-std-workspace-alloc\",\n  \"rustc-std-workspace-core\",\n ]\n \n@@ -4608,7 +4609,7 @@ dependencies = [\n  \"dlmalloc\",\n  \"fortanix-sgx-abi\",\n  \"hashbrown\",\n- \"hermit-abi 0.2.0\",\n+ \"hermit-abi 0.2.6\",\n  \"libc\",\n  \"miniz_oxide 0.4.0\",\n  \"object 0.26.2\","}, {"sha": "324ecc8047730df5ed4407ba2f5488a726c850c5", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=46dadd65cb565f7ff61e7d878bfc629d64930e9f", "patch": "@@ -42,7 +42,7 @@ dlmalloc = { version = \"0.2.3\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.5.0\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(target_os = \"hermit\")'.dependencies]\n-hermit-abi = { version = \"0.2.0\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.2.6\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.11.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "22059ca0dbe107ec24b6f64c3bf5c6f60f6d1bec", "filename": "library/std/src/sys/hermit/condvar.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/98f3001eecbe4cbd091c10ffab45b4c164bb507b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f3001eecbe4cbd091c10ffab45b4c164bb507b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs?ref=98f3001eecbe4cbd091c10ffab45b4c164bb507b", "patch": "@@ -1,90 +0,0 @@\n-use crate::ffi::c_void;\n-use crate::ptr;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-use crate::sys::hermit::abi;\n-use crate::sys::locks::Mutex;\n-use crate::sys_common::lazy_box::{LazyBox, LazyInit};\n-use crate::time::Duration;\n-\n-// The implementation is inspired by Andrew D. Birrell's paper\n-// \"Implementing Condition Variables with Semaphores\"\n-\n-pub struct Condvar {\n-    counter: AtomicUsize,\n-    sem1: *const c_void,\n-    sem2: *const c_void,\n-}\n-\n-pub(crate) type MovableCondvar = LazyBox<Condvar>;\n-\n-impl LazyInit for Condvar {\n-    fn init() -> Box<Self> {\n-        Box::new(Self::new())\n-    }\n-}\n-\n-unsafe impl Send for Condvar {}\n-unsafe impl Sync for Condvar {}\n-\n-impl Condvar {\n-    pub fn new() -> Self {\n-        let mut condvar =\n-            Self { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() };\n-        unsafe {\n-            let _ = abi::sem_init(&mut condvar.sem1, 0);\n-            let _ = abi::sem_init(&mut condvar.sem2, 0);\n-        }\n-        condvar\n-    }\n-\n-    pub unsafe fn notify_one(&self) {\n-        if self.counter.load(SeqCst) > 0 {\n-            self.counter.fetch_sub(1, SeqCst);\n-            abi::sem_post(self.sem1);\n-            abi::sem_timedwait(self.sem2, 0);\n-        }\n-    }\n-\n-    pub unsafe fn notify_all(&self) {\n-        let counter = self.counter.swap(0, SeqCst);\n-        for _ in 0..counter {\n-            abi::sem_post(self.sem1);\n-        }\n-        for _ in 0..counter {\n-            abi::sem_timedwait(self.sem2, 0);\n-        }\n-    }\n-\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        self.counter.fetch_add(1, SeqCst);\n-        mutex.unlock();\n-        abi::sem_timedwait(self.sem1, 0);\n-        abi::sem_post(self.sem2);\n-        mutex.lock();\n-    }\n-\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        self.counter.fetch_add(1, SeqCst);\n-        mutex.unlock();\n-        let millis = dur.as_millis().min(u32::MAX as u128) as u32;\n-\n-        let res = if millis > 0 {\n-            abi::sem_timedwait(self.sem1, millis)\n-        } else {\n-            abi::sem_trywait(self.sem1)\n-        };\n-\n-        abi::sem_post(self.sem2);\n-        mutex.lock();\n-        res == 0\n-    }\n-}\n-\n-impl Drop for Condvar {\n-    fn drop(&mut self) {\n-        unsafe {\n-            let _ = abi::sem_destroy(self.sem1);\n-            let _ = abi::sem_destroy(self.sem2);\n-        }\n-    }\n-}"}, {"sha": "b64c174b06c6df2ddda458f2742988a1010374b5", "filename": "library/std/src/sys/hermit/futex.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffutex.rs?ref=46dadd65cb565f7ff61e7d878bfc629d64930e9f", "patch": "@@ -0,0 +1,39 @@\n+use super::abi;\n+use crate::ptr::null;\n+use crate::sync::atomic::AtomicU32;\n+use crate::time::Duration;\n+\n+pub fn futex_wait(futex: &AtomicU32, expected: u32, timeout: Option<Duration>) -> bool {\n+    // Calculate the timeout as a relative timespec.\n+    //\n+    // Overflows are rounded up to an infinite timeout (None).\n+    let timespec = timeout.and_then(|dur| {\n+        Some(abi::timespec {\n+            tv_sec: dur.as_secs().try_into().ok()?,\n+            tv_nsec: dur.subsec_nanos().into(),\n+        })\n+    });\n+\n+    let r = unsafe {\n+        abi::futex_wait(\n+            futex.as_mut_ptr(),\n+            expected,\n+            timespec.as_ref().map_or(null(), |t| t as *const abi::timespec),\n+            abi::FUTEX_RELATIVE_TIMEOUT,\n+        )\n+    };\n+\n+    r != -abi::errno::ETIMEDOUT\n+}\n+\n+#[inline]\n+pub fn futex_wake(futex: &AtomicU32) -> bool {\n+    unsafe { abi::futex_wake(futex.as_mut_ptr(), 1) > 0 }\n+}\n+\n+#[inline]\n+pub fn futex_wake_all(futex: &AtomicU32) {\n+    unsafe {\n+        abi::futex_wake(futex.as_mut_ptr(), i32::MAX);\n+    }\n+}"}, {"sha": "827d82900eae41d0b2f4972fd4727a2da30237a8", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=46dadd65cb565f7ff61e7d878bfc629d64930e9f", "patch": "@@ -25,6 +25,7 @@ pub mod cmath;\n pub mod env;\n pub mod fd;\n pub mod fs;\n+pub mod futex;\n #[path = \"../unsupported/io.rs\"]\n pub mod io;\n pub mod memchr;\n@@ -45,14 +46,14 @@ pub mod thread_local_dtor;\n pub mod thread_local_key;\n pub mod time;\n \n-mod condvar;\n-mod mutex;\n-mod rwlock;\n-\n+#[path = \"../unix/locks\"]\n pub mod locks {\n-    pub use super::condvar::*;\n-    pub use super::mutex::*;\n-    pub use super::rwlock::*;\n+    mod futex_condvar;\n+    mod futex_mutex;\n+    mod futex_rwlock;\n+    pub(crate) use futex_condvar::MovableCondvar;\n+    pub(crate) use futex_mutex::{MovableMutex, Mutex};\n+    pub(crate) use futex_rwlock::{MovableRwLock, RwLock};\n }\n \n use crate::io::ErrorKind;"}, {"sha": "30c8fc4562d52dd4ce2affa0dad5459ebda821cb", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "removed", "additions": 0, "deletions": 212, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/98f3001eecbe4cbd091c10ffab45b4c164bb507b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f3001eecbe4cbd091c10ffab45b4c164bb507b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=98f3001eecbe4cbd091c10ffab45b4c164bb507b", "patch": "@@ -1,212 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::collections::VecDeque;\n-use crate::hint;\n-use crate::ops::{Deref, DerefMut, Drop};\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-use crate::sys::hermit::abi;\n-\n-/// This type provides a lock based on busy waiting to realize mutual exclusion\n-///\n-/// # Description\n-///\n-/// This structure behaves a lot like a common mutex. There are some differences:\n-///\n-/// - By using busy waiting, it can be used outside the runtime.\n-/// - It is a so called ticket lock and is completely fair.\n-#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n-#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\n-struct Spinlock<T: ?Sized> {\n-    queue: AtomicUsize,\n-    dequeue: AtomicUsize,\n-    data: UnsafeCell<T>,\n-}\n-\n-unsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\n-unsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n-\n-/// A guard to which the protected data can be accessed\n-///\n-/// When the guard falls out of scope it will release the lock.\n-struct SpinlockGuard<'a, T: ?Sized + 'a> {\n-    dequeue: &'a AtomicUsize,\n-    data: &'a mut T,\n-}\n-\n-impl<T> Spinlock<T> {\n-    pub const fn new(user_data: T) -> Spinlock<T> {\n-        Spinlock {\n-            queue: AtomicUsize::new(0),\n-            dequeue: AtomicUsize::new(1),\n-            data: UnsafeCell::new(user_data),\n-        }\n-    }\n-\n-    #[inline]\n-    fn obtain_lock(&self) {\n-        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n-        let mut counter: u16 = 0;\n-        while self.dequeue.load(Ordering::SeqCst) != ticket {\n-            counter += 1;\n-            if counter < 100 {\n-                hint::spin_loop();\n-            } else {\n-                counter = 0;\n-                unsafe {\n-                    abi::yield_now();\n-                }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n-        self.obtain_lock();\n-        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n-    }\n-}\n-\n-impl<T: ?Sized + Default> Default for Spinlock<T> {\n-    fn default() -> Spinlock<T> {\n-        Spinlock::new(Default::default())\n-    }\n-}\n-\n-impl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n-    type Target = T;\n-    fn deref(&self) -> &T {\n-        &*self.data\n-    }\n-}\n-\n-impl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut *self.data\n-    }\n-}\n-\n-impl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n-    /// The dropping of the SpinlockGuard will release the lock it was created from.\n-    fn drop(&mut self) {\n-        self.dequeue.fetch_add(1, Ordering::SeqCst);\n-    }\n-}\n-\n-/// Realize a priority queue for tasks\n-struct PriorityQueue {\n-    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n-    prio_bitmap: u64,\n-}\n-\n-impl PriorityQueue {\n-    pub const fn new() -> PriorityQueue {\n-        PriorityQueue {\n-            queues: [\n-                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n-                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n-                None, None, None,\n-            ],\n-            prio_bitmap: 0,\n-        }\n-    }\n-\n-    /// Add a task id by its priority to the queue\n-    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n-        let i: usize = prio.into().into();\n-        self.prio_bitmap |= (1 << i) as u64;\n-        if let Some(queue) = &mut self.queues[i] {\n-            queue.push_back(id);\n-        } else {\n-            let mut queue = VecDeque::new();\n-            queue.push_back(id);\n-            self.queues[i] = Some(queue);\n-        }\n-    }\n-\n-    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n-        if let Some(queue) = &mut self.queues[queue_index] {\n-            let id = queue.pop_front();\n-\n-            if queue.is_empty() {\n-                self.prio_bitmap &= !(1 << queue_index as u64);\n-            }\n-\n-            id\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Pop the task handle with the highest priority from the queue\n-    pub fn pop(&mut self) -> Option<abi::Tid> {\n-        for i in 0..abi::NO_PRIORITIES {\n-            if self.prio_bitmap & (1 << i) != 0 {\n-                return self.pop_from_queue(i);\n-            }\n-        }\n-\n-        None\n-    }\n-}\n-\n-struct MutexInner {\n-    locked: bool,\n-    blocked_task: PriorityQueue,\n-}\n-\n-impl MutexInner {\n-    pub const fn new() -> MutexInner {\n-        MutexInner { locked: false, blocked_task: PriorityQueue::new() }\n-    }\n-}\n-\n-pub struct Mutex {\n-    inner: Spinlock<MutexInner>,\n-}\n-\n-pub type MovableMutex = Mutex;\n-\n-unsafe impl Send for Mutex {}\n-unsafe impl Sync for Mutex {}\n-\n-impl Mutex {\n-    pub const fn new() -> Mutex {\n-        Mutex { inner: Spinlock::new(MutexInner::new()) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        loop {\n-            let mut guard = self.inner.lock();\n-            if guard.locked == false {\n-                guard.locked = true;\n-                return;\n-            } else {\n-                let prio = abi::get_priority();\n-                let id = abi::getpid();\n-\n-                guard.blocked_task.push(prio, id);\n-                abi::block_current_task();\n-                drop(guard);\n-                abi::yield_now();\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let mut guard = self.inner.lock();\n-        guard.locked = false;\n-        if let Some(tid) = guard.blocked_task.pop() {\n-            abi::wakeup_task(tid);\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        let mut guard = self.inner.lock();\n-        if guard.locked == false {\n-            guard.locked = true;\n-        }\n-        guard.locked\n-    }\n-}"}, {"sha": "1adf0b2be6b7342d3e5d0bfec3a234a43b3e5308", "filename": "library/std/src/sys/hermit/rwlock.rs", "status": "removed", "additions": 0, "deletions": 143, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/98f3001eecbe4cbd091c10ffab45b4c164bb507b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98f3001eecbe4cbd091c10ffab45b4c164bb507b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Frwlock.rs?ref=98f3001eecbe4cbd091c10ffab45b4c164bb507b", "patch": "@@ -1,143 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sys::locks::{MovableCondvar, Mutex};\n-\n-pub struct RwLock {\n-    lock: Mutex,\n-    cond: MovableCondvar,\n-    state: UnsafeCell<State>,\n-}\n-\n-pub type MovableRwLock = RwLock;\n-\n-enum State {\n-    Unlocked,\n-    Reading(usize),\n-    Writing,\n-}\n-\n-unsafe impl Send for RwLock {}\n-unsafe impl Sync for RwLock {}\n-\n-// This rwlock implementation is a relatively simple implementation which has a\n-// condition variable for readers/writers as well as a mutex protecting the\n-// internal state of the lock. A current downside of the implementation is that\n-// unlocking the lock will notify *all* waiters rather than just readers or just\n-// writers. This can cause lots of \"thundering stampede\" problems. While\n-// hopefully correct this implementation is very likely to want to be changed in\n-// the future.\n-\n-impl RwLock {\n-    pub const fn new() -> RwLock {\n-        RwLock {\n-            lock: Mutex::new(),\n-            cond: MovableCondvar::new(),\n-            state: UnsafeCell::new(State::Unlocked),\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_readers() {\n-            self.cond.wait(&self.lock);\n-        }\n-        self.lock.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_readers();\n-        self.lock.unlock();\n-        return ok;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_writers() {\n-            self.cond.wait(&self.lock);\n-        }\n-        self.lock.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_writers();\n-        self.lock.unlock();\n-        return ok;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        self.lock.lock();\n-        let notify = (*self.state.get()).dec_readers();\n-        self.lock.unlock();\n-        if notify {\n-            // FIXME: should only wake up one of these some of the time\n-            self.cond.notify_all();\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        self.lock.lock();\n-        (*self.state.get()).dec_writers();\n-        self.lock.unlock();\n-        // FIXME: should only wake up one of these some of the time\n-        self.cond.notify_all();\n-    }\n-}\n-\n-impl State {\n-    fn inc_readers(&mut self) -> bool {\n-        match *self {\n-            State::Unlocked => {\n-                *self = State::Reading(1);\n-                true\n-            }\n-            State::Reading(ref mut cnt) => {\n-                *cnt += 1;\n-                true\n-            }\n-            State::Writing => false,\n-        }\n-    }\n-\n-    fn inc_writers(&mut self) -> bool {\n-        match *self {\n-            State::Unlocked => {\n-                *self = State::Writing;\n-                true\n-            }\n-            State::Reading(_) | State::Writing => false,\n-        }\n-    }\n-\n-    fn dec_readers(&mut self) -> bool {\n-        let zero = match *self {\n-            State::Reading(ref mut cnt) => {\n-                *cnt -= 1;\n-                *cnt == 0\n-            }\n-            State::Unlocked | State::Writing => invalid(),\n-        };\n-        if zero {\n-            *self = State::Unlocked;\n-        }\n-        zero\n-    }\n-\n-    fn dec_writers(&mut self) {\n-        match *self {\n-            State::Writing => {}\n-            State::Unlocked | State::Reading(_) => invalid(),\n-        }\n-        *self = State::Unlocked;\n-    }\n-}\n-\n-fn invalid() -> ! {\n-    panic!(\"inconsistent rwlock\");\n-}"}, {"sha": "f86a9a555d322e02c08c885aadcd4af194795921", "filename": "library/std/src/sys_common/thread_parker/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46dadd65cb565f7ff61e7d878bfc629d64930e9f/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parker%2Fmod.rs?ref=46dadd65cb565f7ff61e7d878bfc629d64930e9f", "patch": "@@ -7,6 +7,7 @@ cfg_if::cfg_if! {\n         target_os = \"openbsd\",\n         target_os = \"dragonfly\",\n         target_os = \"fuchsia\",\n+        target_os = \"hermit\",\n     ))] {\n         mod futex;\n         pub use futex::Parker;"}]}