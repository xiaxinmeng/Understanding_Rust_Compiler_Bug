{"sha": "c120464be07a5d14f10909ea6718c58c3aa911e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMjA0NjRiZTA3YTVkMTRmMTA5MDllYTY3MThjNThjM2FhOTExZTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-05-28T00:45:16Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-06-02T01:48:07Z"}, "message": "rustc/rusti/rustpkg: Infer packages from `extern mod` directives\n\nThis commit won't be quite as useful until I implement RUST_PATH and\nuntil we change `extern mod` to take a general string instead of\nan identifier (#5682 and #6407).\n\nWith that said, now if you're using rustpkg and a program contains:\n\nextern mod foo;\n\nrustpkg will attempt to search for `foo`, so that you don't have to\nprovide a -L directory explicitly. In addition, rustpkg will\nactually try to build and install `foo`, unless it's already\ninstalled (specifically, I tested that `extern mod extra;` would\nnot cause it to try to find source for `extra` and compile it\nagain).\n\nThis is as per #5681.\n\nIncidentally, I changed some driver code to infer the link name\nfrom the crate link_meta attributes. If that change isn't ok, say\nsomething. Also, I changed the addl_lib_search_paths field in the\nsession options to be an @mut ~[Path] so that it can be modified\nafter expansion but before later phases.", "tree": {"sha": "f2b7694316b9ebf41403e786b23245c86179d1d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b7694316b9ebf41403e786b23245c86179d1d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c120464be07a5d14f10909ea6718c58c3aa911e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c120464be07a5d14f10909ea6718c58c3aa911e4", "html_url": "https://github.com/rust-lang/rust/commit/c120464be07a5d14f10909ea6718c58c3aa911e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c120464be07a5d14f10909ea6718c58c3aa911e4/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341678b815051717c86cc63a00a5d256bf5b2a35", "url": "https://api.github.com/repos/rust-lang/rust/commits/341678b815051717c86cc63a00a5d256bf5b2a35", "html_url": "https://github.com/rust-lang/rust/commit/341678b815051717c86cc63a00a5d256bf5b2a35"}], "stats": {"total": 1201, "additions": 729, "deletions": 472}, "files": [{"sha": "9e23c7df212d81abc3460b95cb7e27e8576cd006", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 152, "deletions": 121, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -161,8 +161,15 @@ pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n     }\n }\n \n+/// First phase to do, last phase to do\n #[deriving(Eq)]\n-pub enum compile_upto {\n+pub struct compile_upto {\n+    from: compile_phase,\n+    to: compile_phase\n+}\n+\n+#[deriving(Eq)]\n+pub enum compile_phase {\n     cu_parse,\n     cu_expand,\n     cu_typeck,\n@@ -177,138 +184,147 @@ pub enum compile_upto {\n #[fixed_stack_segment]\n pub fn compile_rest(sess: Session,\n                     cfg: ast::crate_cfg,\n-                    upto: compile_upto,\n+                    phases: compile_upto,\n                     outputs: Option<@OutputFilenames>,\n                     curr: Option<@ast::crate>)\n     -> (Option<@ast::crate>, Option<ty::ctxt>) {\n \n     let time_passes = sess.time_passes();\n \n-    let (llmod, link_meta) = {\n+    let mut crate_opt = curr;\n \n-        let mut crate = curr.unwrap();\n+    if phases.from == cu_parse || phases.from == cu_everything {\n \n         *sess.building_library = session::building_library(\n-            sess.opts.crate_type, crate, sess.opts.test);\n+            sess.opts.crate_type, crate_opt.unwrap(), sess.opts.test);\n \n-        crate = time(time_passes, ~\"expansion\", ||\n+        crate_opt = Some(time(time_passes, ~\"expansion\", ||\n                      syntax::ext::expand::expand_crate(sess.parse_sess, copy cfg,\n-                                                       crate));\n+                                                       crate_opt.unwrap())));\n+\n+        crate_opt = Some(time(time_passes, ~\"configuration\", ||\n+                     front::config::strip_unconfigured_items(crate_opt.unwrap())));\n+\n+        crate_opt = Some(time(time_passes, ~\"maybe building test harness\", ||\n+                     front::test::modify_for_testing(sess, crate_opt.unwrap())));\n+    }\n \n-        crate = time(time_passes, ~\"configuration\", ||\n-                     front::config::strip_unconfigured_items(crate));\n+    if phases.to == cu_expand { return (crate_opt, None); }\n \n-        crate = time(time_passes, ~\"maybe building test harness\", ||\n-                     front::test::modify_for_testing(sess, crate));\n+    assert!(phases.from != cu_no_trans);\n \n-        if upto == cu_expand { return (Some(crate), None); }\n+    let mut crate = crate_opt.unwrap();\n \n-        crate = time(time_passes, ~\"intrinsic injection\", ||\n-                     front::intrinsic_inject::inject_intrinsic(sess, crate));\n+    let (llmod, link_meta) = {\n+    crate = time(time_passes, ~\"intrinsic injection\", ||\n+                 front::intrinsic_inject::inject_intrinsic(sess, crate));\n \n-        crate = time(time_passes, ~\"extra injection\", ||\n-                     front::std_inject::maybe_inject_libstd_ref(sess, crate));\n+    crate = time(time_passes, ~\"extra injection\", ||\n+                 front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n-        let ast_map = time(time_passes, ~\"ast indexing\", ||\n-                           syntax::ast_map::map_crate(sess.diagnostic(), crate));\n+    let ast_map = time(time_passes, ~\"ast indexing\", ||\n+                       syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n-        time(time_passes, ~\"external crate/lib resolution\", ||\n-             creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n-                                  sess.filesearch,\n-                                  session::sess_os_to_meta_os(sess.targ_cfg.os),\n-                                  sess.opts.is_static,\n-                                  sess.parse_sess.interner));\n+    time(time_passes, ~\"external crate/lib resolution\", ||\n+         creader::read_crates(sess.diagnostic(), crate, sess.cstore,\n+                              sess.filesearch,\n+                              session::sess_os_to_meta_os(sess.targ_cfg.os),\n+                              sess.opts.is_static,\n+                              sess.parse_sess.interner));\n \n-        let lang_items = time(time_passes, ~\"language item collection\", ||\n-                              middle::lang_items::collect_language_items(crate, sess));\n+    let lang_items = time(time_passes, ~\"language item collection\", ||\n+                          middle::lang_items::collect_language_items(crate, sess));\n \n-        let middle::resolve::CrateMap {\n-            def_map: def_map,\n-            exp_map2: exp_map2,\n-            trait_map: trait_map\n-        } =\n-            time(time_passes, ~\"resolution\", ||\n-                 middle::resolve::resolve_crate(sess, lang_items, crate));\n+    let middle::resolve::CrateMap {\n+        def_map: def_map,\n+        exp_map2: exp_map2,\n+        trait_map: trait_map\n+    } =\n+        time(time_passes, ~\"resolution\", ||\n+             middle::resolve::resolve_crate(sess, lang_items, crate));\n \n-        time(time_passes, ~\"looking for entry point\",\n-             || middle::entry::find_entry_point(sess, crate, ast_map));\n+    time(time_passes, ~\"looking for entry point\",\n+         || middle::entry::find_entry_point(sess, crate, ast_map));\n \n-        let freevars = time(time_passes, ~\"freevar finding\", ||\n-                            freevars::annotate_freevars(def_map, crate));\n+    let freevars = time(time_passes, ~\"freevar finding\", ||\n+                        freevars::annotate_freevars(def_map, crate));\n \n-        let region_map = time(time_passes, ~\"region resolution\", ||\n-                              middle::region::resolve_crate(sess, def_map, crate));\n+    let freevars = time(time_passes, ~\"freevar finding\", ||\n+                        freevars::annotate_freevars(def_map, crate));\n \n-        let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n-                          middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n+    let region_map = time(time_passes, ~\"region resolution\", ||\n+                          middle::region::resolve_crate(sess, def_map, crate));\n \n-        let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n-                                region_map, rp_set, lang_items);\n+    let rp_set = time(time_passes, ~\"region parameterization inference\", ||\n+                      middle::region::determine_rp_in_crate(sess, ast_map, def_map, crate));\n \n-        // passes are timed inside typeck\n-        let (method_map, vtable_map) = typeck::check_crate(\n-            ty_cx, trait_map, crate);\n+    let ty_cx = ty::mk_ctxt(sess, def_map, ast_map, freevars,\n+                            region_map, rp_set, lang_items);\n \n-        // These next two const passes can probably be merged\n-        time(time_passes, ~\"const marking\", ||\n-             middle::const_eval::process_crate(crate, ty_cx));\n+    // passes are timed inside typeck\n+    let (method_map, vtable_map) = typeck::check_crate(\n+        ty_cx, trait_map, crate);\n \n-        time(time_passes, ~\"const checking\", ||\n-             middle::check_const::check_crate(sess, crate, ast_map, def_map,\n-                                              method_map, ty_cx));\n+    // These next two const passes can probably be merged\n+    time(time_passes, ~\"const marking\", ||\n+         middle::const_eval::process_crate(crate, ty_cx));\n \n-        if upto == cu_typeck { return (Some(crate), Some(ty_cx)); }\n+    time(time_passes, ~\"const checking\", ||\n+         middle::check_const::check_crate(sess, crate, ast_map, def_map,\n+                                          method_map, ty_cx));\n \n-        time(time_passes, ~\"privacy checking\", ||\n-             middle::privacy::check_crate(ty_cx, &method_map, crate));\n+    if phases.to == cu_typeck { return (Some(crate), Some(ty_cx)); }\n \n-        time(time_passes, ~\"effect checking\", ||\n-             middle::effect::check_crate(ty_cx, method_map, crate));\n+    time(time_passes, ~\"privacy checking\", ||\n+         middle::privacy::check_crate(ty_cx, &method_map, crate));\n \n-        time(time_passes, ~\"loop checking\", ||\n-             middle::check_loop::check_crate(ty_cx, crate));\n+    time(time_passes, ~\"effect checking\", ||\n+         middle::effect::check_crate(ty_cx, method_map, crate));\n \n-        let middle::moves::MoveMaps {moves_map, moved_variables_set,\n-                                     capture_map} =\n-            time(time_passes, ~\"compute moves\", ||\n-                 middle::moves::compute_moves(ty_cx, method_map, crate));\n+    time(time_passes, ~\"loop checking\", ||\n+         middle::check_loop::check_crate(ty_cx, crate));\n \n-        time(time_passes, ~\"match checking\", ||\n-             middle::check_match::check_crate(ty_cx, method_map,\n-                                              moves_map, crate));\n+    let middle::moves::MoveMaps {moves_map, moved_variables_set,\n+                                 capture_map} =\n+        time(time_passes, ~\"compute moves\", ||\n+             middle::moves::compute_moves(ty_cx, method_map, crate));\n \n-        time(time_passes, ~\"liveness checking\", ||\n-             middle::liveness::check_crate(ty_cx, method_map,\n-                                           capture_map, crate));\n+    time(time_passes, ~\"match checking\", ||\n+         middle::check_match::check_crate(ty_cx, method_map,\n+                                          moves_map, crate));\n \n-        let (root_map, write_guard_map) =\n-            time(time_passes, ~\"borrow checking\", ||\n-                 middle::borrowck::check_crate(ty_cx, method_map,\n-                                               moves_map, moved_variables_set,\n-                                               capture_map, crate));\n+    time(time_passes, ~\"liveness checking\", ||\n+         middle::liveness::check_crate(ty_cx, method_map,\n+                                       capture_map, crate));\n \n-        time(time_passes, ~\"kind checking\", ||\n-             kind::check_crate(ty_cx, method_map, crate));\n+    let (root_map, write_guard_map) =\n+        time(time_passes, ~\"borrow checking\", ||\n+             middle::borrowck::check_crate(ty_cx, method_map,\n+                                           moves_map, moved_variables_set,\n+                                           capture_map, crate));\n \n-        time(time_passes, ~\"lint checking\", ||\n-             lint::check_crate(ty_cx, crate));\n+    time(time_passes, ~\"kind checking\", ||\n+         kind::check_crate(ty_cx, method_map, crate));\n \n-        if upto == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+    time(time_passes, ~\"lint checking\", ||\n+         lint::check_crate(ty_cx, crate));\n \n-        let maps = astencode::Maps {\n-            root_map: root_map,\n-            method_map: method_map,\n-            vtable_map: vtable_map,\n-            write_guard_map: write_guard_map,\n-            moves_map: moves_map,\n-            capture_map: capture_map\n-        };\n+    if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+\n+    let maps = astencode::Maps {\n+        root_map: root_map,\n+        method_map: method_map,\n+        vtable_map: vtable_map,\n+        write_guard_map: write_guard_map,\n+        moves_map: moves_map,\n+        capture_map: capture_map\n+    };\n \n-        let outputs = outputs.get_ref();\n-        time(time_passes, ~\"translation\", ||\n-             trans::base::trans_crate(sess, crate, ty_cx,\n-                                      &outputs.obj_filename,\n-                                      exp_map2, maps))\n+    let outputs = outputs.get_ref();\n+    time(time_passes, ~\"translation\", ||\n+         trans::base::trans_crate(sess, crate, ty_cx,\n+                                  &outputs.obj_filename,\n+                                  exp_map2, maps))\n     };\n \n     let outputs = outputs.get_ref();\n@@ -351,23 +367,24 @@ pub fn compile_rest(sess: Session,\n }\n \n pub fn compile_upto(sess: Session, cfg: ast::crate_cfg,\n-                input: &input, upto: compile_upto,\n+                input: &input, upto: compile_phase,\n                 outputs: Option<@OutputFilenames>)\n     -> (Option<@ast::crate>, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let crate = time(time_passes, ~\"parsing\",\n                          || parse_input(sess, copy cfg, input) );\n     if upto == cu_parse { return (Some(crate), None); }\n \n-    compile_rest(sess, cfg, upto, outputs, Some(crate))\n+    compile_rest(sess, cfg, compile_upto { from: cu_parse, to: upto },\n+                 outputs, Some(crate))\n }\n \n pub fn compile_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n                      outdir: &Option<Path>, output: &Option<Path>) {\n     let upto = if sess.opts.parse_only { cu_parse }\n                else if sess.opts.no_trans { cu_no_trans }\n                else { cu_everything };\n-    let outputs = build_output_filenames(input, outdir, output, sess);\n+    let outputs = build_output_filenames(input, outdir, output, [], sess); // ???\n     compile_upto(sess, cfg, input, upto, Some(outputs));\n }\n \n@@ -645,8 +662,7 @@ pub fn build_session_options(binary: @~str,\n               ~\"2\" => Default,\n               ~\"3\" => Aggressive,\n               _ => {\n-                early_error(demitter, ~\"optimization level needs \" +\n-                            \"to be between 0-3\")\n+                early_error(demitter, ~\"optimization level needs to be between 0-3\")\n               }\n             }\n         } else { No }\n@@ -706,7 +722,7 @@ pub fn build_session_options(binary: @~str,\n         save_temps: save_temps,\n         jit: jit,\n         output_type: output_type,\n-        addl_lib_search_paths: addl_lib_search_paths,\n+        addl_lib_search_paths: @mut addl_lib_search_paths,\n         linker: linker,\n         linker_args: linker_args,\n         maybe_sysroot: sysroot_opt,\n@@ -745,7 +761,7 @@ pub fn build_session_(sopts: @session::options,\n     let filesearch = filesearch::mk_filesearch(\n         &sopts.maybe_sysroot,\n         sopts.target_triple,\n-        /*bad*/copy sopts.addl_lib_search_paths);\n+        sopts.addl_lib_search_paths);\n     @Session_ {\n         targ_cfg: target_cfg,\n         opts: sopts,\n@@ -854,6 +870,7 @@ pub struct OutputFilenames {\n pub fn build_output_filenames(input: &input,\n                               odir: &Option<Path>,\n                               ofile: &Option<Path>,\n+                              attrs: &[ast::attribute],\n                               sess: Session)\n                            -> @OutputFilenames {\n     let obj_path;\n@@ -863,7 +880,6 @@ pub fn build_output_filenames(input: &input,\n         sopts.output_type != link::output_type_exe ||\n             sopts.is_static && *sess.building_library;\n \n-\n     let obj_suffix =\n         match sopts.output_type {\n           link::output_type_none => ~\"none\",\n@@ -876,29 +892,44 @@ pub fn build_output_filenames(input: &input,\n \n     match *ofile {\n       None => {\n-        // \"-\" as input file will cause the parser to read from stdin so we\n-        // have to make up a name\n-        // We want to toss everything after the final '.'\n-        let dirpath = match *odir {\n-          Some(ref d) => (/*bad*/copy *d),\n-          None => match *input {\n-            str_input(_) => os::getcwd(),\n-            file_input(ref ifile) => (*ifile).dir_path()\n+          // \"-\" as input file will cause the parser to read from stdin so we\n+          // have to make up a name\n+          // We want to toss everything after the final '.'\n+          let dirpath = match *odir {\n+              Some(ref d) => (/*bad*/copy *d),\n+              None => match *input {\n+                  str_input(_) => os::getcwd(),\n+                  file_input(ref ifile) => (*ifile).dir_path()\n+              }\n+          };\n+\n+          let mut stem = match *input {\n+              file_input(ref ifile) => (*ifile).filestem().get(),\n+              str_input(_) => ~\"rust_out\"\n+          };\n+\n+          // If a linkage name meta is present, we use it as the link name\n+          let linkage_metas = attr::find_linkage_metas(attrs);\n+          if !linkage_metas.is_empty() {\n+              // But if a linkage meta is present, that overrides\n+              let maybe_matches = attr::find_meta_items_by_name(linkage_metas, \"name\");\n+              if !maybe_matches.is_empty() {\n+                  match attr::get_meta_item_value_str(maybe_matches[0]) {\n+                      Some(s) => stem = copy *s,\n+                      _ => ()\n+                  }\n+              }\n+              // If the name is missing, we just default to the filename\n+              // version\n           }\n-        };\n \n-        let stem = match *input {\n-          file_input(ref ifile) => (*ifile).filestem().get(),\n-          str_input(_) => ~\"rust_out\"\n-        };\n-\n-        if *sess.building_library {\n-            out_path = dirpath.push(os::dll_filename(stem));\n-            obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n-        } else {\n-            out_path = dirpath.push(stem);\n-            obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n-        }\n+          if *sess.building_library {\n+              out_path = dirpath.push(os::dll_filename(stem));\n+              obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n+          } else {\n+              out_path = dirpath.push(stem);\n+              obj_path = dirpath.push(stem).with_filetype(obj_suffix);\n+          }\n       }\n \n       Some(ref out_file) => {"}, {"sha": "d6a99b3edc9510ca0ca7b8138411323e1e049283", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -136,7 +136,9 @@ pub struct options {\n     save_temps: bool,\n     jit: bool,\n     output_type: back::link::output_type,\n-    addl_lib_search_paths: ~[Path],\n+    addl_lib_search_paths: @mut ~[Path], // This is mutable for rustpkg, which\n+                                         // updates search paths based on the\n+                                         // parsed code\n     linker: Option<~str>,\n     linker_args: ~[~str],\n     maybe_sysroot: Option<@Path>,\n@@ -316,7 +318,7 @@ pub fn basic_options() -> @options {\n         save_temps: false,\n         jit: false,\n         output_type: link::output_type_exe,\n-        addl_lib_search_paths: ~[],\n+        addl_lib_search_paths: @mut ~[],\n         linker: None,\n         linker_args: ~[],\n         maybe_sysroot: None,"}, {"sha": "f83d33dcb3c0609e5ad8cb8c35fb30da9454d454", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -35,17 +35,18 @@ pub trait FileSearch {\n \n pub fn mk_filesearch(maybe_sysroot: &Option<@Path>,\n                      target_triple: &str,\n-                     addl_lib_search_paths: ~[Path])\n+                     addl_lib_search_paths: @mut ~[Path])\n                   -> @FileSearch {\n     struct FileSearchImpl {\n         sysroot: @Path,\n-        addl_lib_search_paths: ~[Path],\n+        addl_lib_search_paths: @mut ~[Path],\n         target_triple: ~str\n     }\n     impl FileSearch for FileSearchImpl {\n         fn sysroot(&self) -> @Path { self.sysroot }\n         fn for_each_lib_search_path(&self, f: &fn(&Path) -> bool) -> bool {\n-            debug!(\"filesearch: searching additional lib search paths\");\n+            debug!(\"filesearch: searching additional lib search paths [%?]\",\n+                   self.addl_lib_search_paths.len());\n             // a little weird\n             self.addl_lib_search_paths.each(f);\n "}, {"sha": "baf920c04acbea3cc9851c2aae831dd424637cd1", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -183,11 +183,11 @@ pub fn version(argv0: &str) {\n \n pub fn usage(argv0: &str) {\n     let message = fmt!(\"Usage: %s [OPTIONS] INPUT\", argv0);\n-    io::println(groups::usage(message, optgroups()) +\n-                \"Additional help:\n-    -W help             Print 'lint' options and default settings\n-    -Z help             Print internal options for debugging rustc\n-\");\n+    io::println(fmt!(\"%s \\\n+                Additional help: \\\n+    -W help             Print 'lint' options and default settings \\\n+    -Z help             Print internal options for debugging rustc\",\n+                     groups::usage(message, optgroups())));\n }\n \n pub fn describe_warnings() {"}, {"sha": "08325ffb2a3ec73d7d4d28b7d33b8e6f919d6cfb", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -121,7 +121,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n         binary: binary,\n-        addl_lib_search_paths: repl.lib_search_paths.map(|p| Path(*p)),\n+        addl_lib_search_paths: @mut repl.lib_search_paths.map(|p| Path(*p)),\n         jit: true,\n         .. copy *session::basic_options()\n     };\n@@ -142,12 +142,13 @@ fn run(repl: Repl, input: ~str) -> Repl {\n                                           binary,\n                                           &wrapped);\n \n-    let outputs = driver::build_output_filenames(&wrapped, &None, &None, sess);\n+    let outputs = driver::build_output_filenames(&wrapped, &None, &None, [], sess);\n     debug!(\"calling compile_upto\");\n \n     let crate = driver::parse_input(sess, copy cfg, &wrapped);\n-    driver::compile_rest(sess, cfg, driver::cu_everything,\n-                         Some(outputs), Some(crate));\n+    driver::compile_rest(sess, cfg, driver::compile_upto { from: driver::cu_parse,\n+                                                           to: driver::cu_everything },\n+                          Some(outputs), Some(crate));\n \n     let mut opt = None;\n \n@@ -188,15 +189,15 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         let binary = @copy binary;\n         let options = @session::options {\n             binary: binary,\n-            addl_lib_search_paths: ~[os::getcwd()],\n+            addl_lib_search_paths: @mut ~[os::getcwd()],\n             .. copy *session::basic_options()\n         };\n         let input = driver::file_input(copy src_path);\n         let sess = driver::build_session(options, diagnostic::emit);\n         *sess.building_library = true;\n         let cfg = driver::build_configuration(sess, binary, &input);\n         let outputs = driver::build_output_filenames(\n-            &input, &None, &None, sess);\n+            &input, &None, &None, [], sess);\n         // If the library already exists and is newer than the source\n         // file, skip compilation and return None.\n         let mut should_compile = true;"}, {"sha": "caab16cd2917d88972eab952e0c3019a30d662a5", "filename": "src/librustpkg/conditions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fconditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fconditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fconditions.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -11,14 +11,14 @@\n // Useful conditions\n \n pub use core::path::Path;\n-pub use util::PkgId;\n+pub use package_id::PkgId;\n \n condition! {\n     bad_path: (super::Path, ~str) -> super::Path;\n }\n \n condition! {\n-    nonexistent_package: (super::PkgId, ~str) -> ();\n+    nonexistent_package: (super::PkgId, ~str) -> super::Path;\n }\n \n condition! {\n@@ -30,5 +30,5 @@ condition! {\n }\n \n condition! {\n-    bad_pkg_id: (super::Path, ~str) -> ::util::PkgId;\n+    bad_pkg_id: (super::Path, ~str) -> super::PkgId;\n }"}, {"sha": "ca0210f469b1c8e4853f08c44f7b70b0b5e7e7bc", "filename": "src/librustpkg/package_id.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use package_path::{RemotePath, LocalPath, normalize, hash};\n+use extra::semver;\n+use core::prelude::*;\n+use core::result;\n+\n+/// Placeholder\n+pub fn default_version() -> Version { ExactRevision(0.1) }\n+\n+/// Path-fragment identifier of a package such as\n+/// 'github.com/graydon/test'; path must be a relative\n+/// path with >=1 component.\n+pub struct PkgId {\n+    /// Remote path: for example, github.com/mozilla/quux-whatever\n+    remote_path: RemotePath,\n+    /// Local path: for example, /home/quux/github.com/mozilla/quux_whatever\n+    /// Note that '-' normalizes to '_' when mapping a remote path\n+    /// onto a local path\n+    /// Also, this will change when we implement #6407, though we'll still\n+    /// need to keep track of separate local and remote paths\n+    local_path: LocalPath,\n+    /// Short name. This is the local path's filestem, but we store it\n+    /// redundantly so as to not call get() everywhere (filestem() returns an\n+    /// option)\n+    short_name: ~str,\n+    version: Version\n+}\n+\n+pub impl PkgId {\n+    fn new(s: &str) -> PkgId {\n+        use conditions::bad_pkg_id::cond;\n+\n+        let p = Path(s);\n+        if p.is_absolute {\n+            return cond.raise((p, ~\"absolute pkgid\"));\n+        }\n+        if p.components.len() < 1 {\n+            return cond.raise((p, ~\"0-length pkgid\"));\n+        }\n+        let remote_path = RemotePath(p);\n+        let local_path = normalize(copy remote_path);\n+        let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n+        PkgId {\n+            local_path: local_path,\n+            remote_path: remote_path,\n+            short_name: short_name,\n+            version: default_version()\n+        }\n+    }\n+\n+    fn hash(&self) -> ~str {\n+        fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n+             hash(self.remote_path.to_str() + self.version.to_str()),\n+             self.version.to_str())\n+    }\n+\n+    fn short_name_with_version(&self) -> ~str {\n+        fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n+    }\n+}\n+\n+impl ToStr for PkgId {\n+    fn to_str(&self) -> ~str {\n+        // should probably use the filestem and not the whole path\n+        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n+    }\n+}\n+\n+/// A version is either an exact revision,\n+/// or a semantic version\n+pub enum Version {\n+    ExactRevision(float),\n+    SemVersion(semver::Version)\n+}\n+\n+\n+impl Ord for Version {\n+    fn lt(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn le(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn ge(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn gt(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+\n+}\n+\n+impl ToStr for Version {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ExactRevision(ref n) => n.to_str(),\n+            SemVersion(ref v) => v.to_str()\n+        }\n+    }\n+}\n+\n+pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n+    match semver::parse(vers) {\n+        Some(vers) => result::Ok(vers),\n+        None => result::Err(~\"could not parse version: invalid\")\n+    }\n+}"}, {"sha": "a54f9ad152f48c9038081b527b3b99eeb6ee315b", "filename": "src/librustpkg/package_path.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fpackage_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fpackage_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_path.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rustpkg utilities having to do with local and remote paths\n+\n+use core::path::Path;\n+use core::option::Some;\n+use core::{hash, str};\n+use core::rt::io::Writer;\n+use core::hash::Streaming;\n+\n+/// Wrappers to prevent local and remote paths from getting confused\n+/// (These will go away after #6407)\n+pub struct RemotePath (Path);\n+pub struct LocalPath (Path);\n+\n+\n+// normalize should be the only way to construct a LocalPath\n+// (though this isn't enforced)\n+/// Replace all occurrences of '-' in the stem part of path with '_'\n+/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n+/// as the same name\n+pub fn normalize(p_: RemotePath) -> LocalPath {\n+    let RemotePath(p) = p_;\n+    match p.filestem() {\n+        None => LocalPath(p),\n+        Some(st) => {\n+            let replaced = str::replace(st, \"-\", \"_\");\n+            if replaced != st {\n+                LocalPath(p.with_filestem(replaced))\n+            }\n+            else {\n+                LocalPath(p)\n+            }\n+        }\n+    }\n+}\n+\n+pub fn write<W: Writer>(writer: &mut W, string: &str) {\n+    let buffer = str::as_bytes_slice(string);\n+    writer.write(buffer);\n+}\n+\n+pub fn hash(data: ~str) -> ~str {\n+    let hasher = &mut hash::default_state();\n+    write(hasher, data);\n+    hasher.result_str()\n+}"}, {"sha": "7b4a9a63a4ec07e4cfae0e45a77bd471b36549cf", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 94, "deletions": 42, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -11,9 +11,9 @@\n // rustpkg utilities having to do with paths and directories\n \n use core::prelude::*;\n-\n-pub use util::{PkgId, RemotePath, LocalPath};\n-pub use util::{normalize, OutputType, Main, Lib, Bench, Test};\n+pub use package_path::{RemotePath, LocalPath};\n+pub use package_id::{PkgId, Version};\n+pub use target::{OutputType, Main, Lib, Test, Bench, Target, Build, Install};\n use core::libc::consts::os::posix88::{S_IRUSR, S_IWUSR, S_IXUSR};\n use core::os::mkdir_recursive;\n use core::os;\n@@ -32,30 +32,46 @@ pub static u_rwx: i32 = (S_IRUSR | S_IWUSR | S_IXUSR) as i32;\n /// succeeded.\n pub fn make_dir_rwx(p: &Path) -> bool { os::make_dir(p, u_rwx) }\n \n-// n.b. So far this only handles local workspaces\n // n.b. The next three functions ignore the package version right\n // now. Should fix that.\n \n /// True if there's a directory in <workspace> with\n /// pkgid's short name\n pub fn workspace_contains_package_id(pkgid: &PkgId, workspace: &Path) -> bool {\n-    let pkgpath = workspace.push(\"src\").push(pkgid.local_path.to_str());\n+    let pkgpath = workspace.push(\"src\").push(pkgid.remote_path.to_str());\n     os::path_is_dir(&pkgpath)\n }\n \n-/// Return the directory for <pkgid>'s source files in <workspace>.\n-/// Doesn't check that it exists.\n-pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    let result = workspace.push(\"src\");\n-    result.push(pkgid.local_path.to_str())\n+/// Returns a list of possible directories\n+/// for <pkgid>'s source files in <workspace>.\n+/// Doesn't check that any of them exist.\n+/// (for example, try both with and without the version)\n+pub fn pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> ~[Path] {\n+    let mut results = ~[];\n+    let result = workspace.push(\"src\").push(fmt!(\"%s-%s\",\n+                     pkgid.local_path.to_str(), pkgid.version.to_str()));\n+    results.push(result);\n+    results.push(workspace.push(\"src\").push_rel(&*pkgid.remote_path));\n+    results\n+}\n+\n+/// Returns a src for pkgid that does exist -- None if none of them do\n+pub fn first_pkgid_src_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n+    let rs = pkgid_src_in_workspace(pkgid, workspace);\n+    for rs.each |p| {\n+        if os::path_exists(p) {\n+            return Some(copy *p);\n+        }\n+    }\n+    None\n }\n \n /// Figure out what the executable name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     // should use a target-specific subdirectory\n-    result = mk_output_path(Main, pkgid, &result);\n+    result = mk_output_path(Main, Build, pkgid, &result);\n     debug!(\"built_executable_in_workspace: checking whether %s exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n@@ -83,7 +99,7 @@ pub fn built_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path>\n fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Option<Path> {\n     let mut result = workspace.push(\"build\");\n     // should use a target-specific subdirectory\n-    result = mk_output_path(what, pkgid, &result);\n+    result = mk_output_path(what, Build, pkgid, &result);\n     debug!(\"output_in_workspace: checking whether %s exists\",\n            result.to_str());\n     if os::path_exists(&result) {\n@@ -98,27 +114,59 @@ fn output_in_workspace(pkgid: &PkgId, workspace: &Path, what: OutputType) -> Opt\n /// Figure out what the library name for <pkgid> in <workspace>'s build\n /// directory is, and if the file exists, return it.\n pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Path> {\n-    let result = mk_output_path(Lib, pkgid, &workspace.push(\"build\"));\n-    debug!(\"built_library_in_workspace: checking whether %s exists\",\n-           result.to_str());\n+                        // passing in local_path here sounds fishy\n+    library_in_workspace(pkgid.local_path.to_str(), pkgid.short_name, Build,\n+                         workspace, \"build\")\n+}\n+\n+/// Does the actual searching stuff\n+pub fn installed_library_in_workspace(short_name: &str, workspace: &Path) -> Option<Path> {\n+    library_in_workspace(short_name, short_name, Install, workspace, \"lib\")\n+}\n+\n+\n+/// This doesn't take a PkgId, so we can use it for `extern mod` inference, where we\n+/// don't know the entire package ID.\n+/// `full_name` is used to figure out the directory to search.\n+/// `short_name` is taken as the link name of the library.\n+fn library_in_workspace(full_name: &str, short_name: &str, where: Target,\n+                        workspace: &Path, prefix: &str) -> Option<Path> {\n+    debug!(\"library_in_workspace: checking whether a library named %s exists\",\n+           short_name);\n \n     // We don't know what the hash is, so we have to search through the directory\n     // contents\n-    let dir_contents = os::list_dir(&result.pop());\n+\n+    let dir_to_search = match where {\n+        Build => workspace.push(prefix).push(full_name),\n+        Install => workspace.push(prefix)\n+    };\n+    debug!(\"Listing directory %s\", dir_to_search.to_str());\n+    let dir_contents = os::list_dir(&dir_to_search);\n     debug!(\"dir has %? entries\", dir_contents.len());\n \n-    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, pkgid.short_name);\n-    let lib_filetype = fmt!(\"%s%s\", pkgid.version.to_str(), os::consts::DLL_SUFFIX);\n+    let lib_prefix = fmt!(\"%s%s\", os::consts::DLL_PREFIX, short_name);\n+    let lib_filetype = os::consts::DLL_SUFFIX;\n \n     debug!(\"lib_prefix = %s and lib_filetype = %s\", lib_prefix, lib_filetype);\n \n     let mut result_filename = None;\n     for dir_contents.each |&p| {\n         let mut which = 0;\n         let mut hash = None;\n+        let p_path = Path(p);\n+        let extension = p_path.filetype();\n+        debug!(\"p = %s, p's extension is %?\", p.to_str(), extension);\n+        match extension {\n+            Some(ref s) if lib_filetype == *s => (),\n+            _ => loop\n+        }\n         // Find a filename that matches the pattern: (lib_prefix)-hash-(version)(lib_suffix)\n         // and remember what the hash was\n-        for p.each_split_char('-') |piece| {\n+        let f_name = match p_path.filename() {\n+            Some(s) => s, None => loop\n+        };\n+        for f_name.each_split_char('-') |piece| {\n             debug!(\"a piece = %s\", piece);\n             if which == 0 && piece != lib_prefix {\n                 break;\n@@ -128,13 +176,6 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n             }\n             else if which == 1 {\n                 hash = Some(piece.to_owned());\n-                which += 1;\n-            }\n-            else if which == 2 && piece != lib_filetype {\n-                hash = None;\n-                break;\n-            }\n-            else if which == 2 {\n                 break;\n             }\n             else {\n@@ -144,20 +185,19 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n             }\n         }\n         if hash.is_some() {\n-            result_filename = Some(p);\n+            result_filename = Some(p_path);\n             break;\n         }\n     }\n \n     // Return the filename that matches, which we now know exists\n     // (if result_filename != None)\n-    debug!(\"result_filename = %?\", result_filename);\n     match result_filename {\n         None => None,\n         Some(result_filename) => {\n-            let result_filename = result.with_filename(result_filename);\n-            debug!(\"result_filename = %s\", result_filename.to_str());\n-            Some(result_filename)\n+            let absolute_path = dir_to_search.push_rel(&result_filename);\n+            debug!(\"result_filename = %s\", absolute_path.to_str());\n+            Some(absolute_path)\n         }\n     }\n }\n@@ -166,33 +206,36 @@ pub fn built_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Option<Pat\n /// in <workspace>\n /// As a side effect, creates the bin-dir if it doesn't exist\n pub fn target_executable_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Main)\n+    target_file_in_workspace(pkgid, workspace, Main, Install)\n }\n \n \n /// Returns the executable that would be installed for <pkgid>\n /// in <workspace>\n-/// As a side effect, creates the bin-dir if it doesn't exist\n+/// As a side effect, creates the lib-dir if it doesn't exist\n pub fn target_library_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Lib)\n+    target_file_in_workspace(pkgid, workspace, Lib, Install)\n }\n \n /// Returns the test executable that would be installed for <pkgid>\n /// in <workspace>\n /// note that we *don't* install test executables, so this is just for unit testing\n pub fn target_test_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Test)\n+    target_file_in_workspace(pkgid, workspace, Test, Install)\n }\n \n /// Returns the bench executable that would be installed for <pkgid>\n /// in <workspace>\n /// note that we *don't* install bench executables, so this is just for unit testing\n pub fn target_bench_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n-    target_file_in_workspace(pkgid, workspace, Bench)\n+    target_file_in_workspace(pkgid, workspace, Bench, Install)\n }\n \n+\n+/// Returns the path that pkgid `pkgid` would have if placed `where`\n+/// in `workspace`\n fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n-                            what: OutputType) -> Path {\n+                            what: OutputType, where: Target) -> Path {\n     use conditions::bad_path::cond;\n \n     let subdir = match what {\n@@ -202,7 +245,7 @@ fn target_file_in_workspace(pkgid: &PkgId, workspace: &Path,\n     if !os::path_exists(&result) && !mkdir_recursive(&result, u_rwx) {\n         cond.raise((copy result, fmt!(\"I couldn't create the %s dir\", subdir)));\n     }\n-    mk_output_path(what, pkgid, &result)\n+    mk_output_path(what, where, pkgid, &result)\n }\n \n /// Return the directory for <pkgid>'s build artifacts in <workspace>.\n@@ -224,15 +267,21 @@ pub fn build_pkg_id_in_workspace(pkgid: &PkgId, workspace: &Path) -> Path {\n \n /// Return the output file for a given directory name,\n /// given whether we're building a library and whether we're building tests\n-pub fn mk_output_path(what: OutputType, pkg_id: &PkgId, workspace: &Path) -> Path {\n+pub fn mk_output_path(what: OutputType, where: Target,\n+                      pkg_id: &PkgId, workspace: &Path) -> Path {\n     let short_name_with_version = pkg_id.short_name_with_version();\n     // Not local_path.dir_path()! For package foo/bar/blat/, we want\n     // the executable blat-0.5 to live under blat/\n-    let dir = workspace.push_rel(&*pkg_id.local_path);\n-    debug!(\"mk_output_path: short_name = %s, path = %s\",\n+    let dir = match where {\n+        // If we're installing, it just goes under <workspace>...\n+        Install => copy *workspace, // bad copy, but I just couldn't make the borrow checker happy\n+        // and if we're just building, it goes in a package-specific subdir\n+        Build => workspace.push_rel(&*pkg_id.local_path)\n+    };\n+    debug!(\"[%?:%?] mk_output_path: short_name = %s, path = %s\", what, where,\n            if what == Lib { copy short_name_with_version } else { copy pkg_id.short_name },\n            dir.to_str());\n-    let output_path = match what {\n+    let mut output_path = match what {\n         // this code is duplicated from elsewhere; fix this\n         Lib => dir.push(os::dll_filename(short_name_with_version)),\n         // executable names *aren't* versioned\n@@ -244,6 +293,9 @@ pub fn mk_output_path(what: OutputType, pkg_id: &PkgId, workspace: &Path) -> Pat\n                            }\n                            os::EXE_SUFFIX))\n     };\n+    if !output_path.is_absolute() {\n+        output_path = os::getcwd().push_rel(&output_path).normalize();\n+    }\n     debug!(\"mk_output_path: returning %s\", output_path.to_str());\n     output_path\n }"}, {"sha": "005f2de3f4276fb87bf6904c6434254ebde97927", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 62, "deletions": 51, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -35,15 +35,21 @@ use rustc::metadata::filesearch;\n use extra::{getopts};\n use syntax::{ast, diagnostic};\n use util::*;\n-use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace, u_rwx};\n+use path_util::{build_pkg_id_in_workspace, pkgid_src_in_workspace, first_pkgid_src_in_workspace};\n+use path_util::u_rwx;\n use path_util::{built_executable_in_workspace, built_library_in_workspace};\n use path_util::{target_executable_in_workspace, target_library_in_workspace};\n use workspace::pkg_parent_workspaces;\n use context::Ctx;\n+use package_id::PkgId;\n \n mod conditions;\n mod context;\n+mod package_id;\n+mod package_path;\n mod path_util;\n+mod search;\n+mod target;\n #[cfg(test)]\n mod tests;\n mod util;\n@@ -99,8 +105,7 @@ impl<'self> PkgScript<'self> {\n         let input = driver::file_input(script);\n         let sess = driver::build_session(options, diagnostic::emit);\n         let cfg = driver::build_configuration(sess, binary, &input);\n-        let (crate, _) = driver::compile_upto(sess, copy cfg, &input,\n-                                              driver::cu_parse, None);\n+        let (crate, _) = driver::compile_upto(sess, copy cfg, &input, driver::cu_parse, None);\n         let work_dir = build_pkg_id_in_workspace(id, workspace);\n \n         debug!(\"Returning package script with id %?\", id);\n@@ -134,11 +139,13 @@ impl<'self> PkgScript<'self> {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                util::compile_crate_from_input(&self.input, self.id,\n-                                               Some(copy self.build_dir),\n-                                               sess, Some(crate),\n-                                               &exe, @copy os::args()[0],\n-                                               driver::cu_everything);\n+                let binary = @copy os::args()[0];\n+                util::compile_crate_from_input(&self.input,\n+                                               &self.build_dir,\n+                                               sess,\n+                                               crate,\n+                                               driver::build_configuration(sess,\n+                                                                           binary, &self.input));\n                 debug!(\"Running program: %s %s %s\", exe.to_str(), root.to_str(), what);\n                 let status = run::process_status(exe.to_str(), [root.to_str(), what]);\n                 if status != 0 {\n@@ -170,9 +177,9 @@ impl<'self> PkgScript<'self> {\n \n impl Ctx {\n \n-    fn run(&self, cmd: ~str, args: ~[~str]) {\n+    fn run(&self, cmd: &str, args: ~[~str]) {\n         match cmd {\n-            ~\"build\" => {\n+            \"build\" => {\n                 if args.len() < 1 {\n                     return usage::build();\n                 }\n@@ -183,7 +190,7 @@ impl Ctx {\n                     self.build(workspace, &pkgid);\n                 }\n             }\n-            ~\"clean\" => {\n+            \"clean\" => {\n                 if args.len() < 1 {\n                     return usage::build();\n                 }\n@@ -193,17 +200,17 @@ impl Ctx {\n                 let cwd = os::getcwd();\n                 self.clean(&cwd, &pkgid); // tjc: should use workspace, not cwd\n             }\n-            ~\"do\" => {\n+            \"do\" => {\n                 if args.len() < 2 {\n                     return usage::do_cmd();\n                 }\n \n                 self.do_cmd(copy args[0], copy args[1]);\n             }\n-            ~\"info\" => {\n+            \"info\" => {\n                 self.info();\n             }\n-            ~\"install\" => {\n+            \"install\" => {\n                 if args.len() < 1 {\n                     return usage::install();\n                 }\n@@ -215,24 +222,24 @@ impl Ctx {\n                     self.install(workspace, &pkgid);\n                 }\n             }\n-            ~\"prefer\" => {\n+            \"prefer\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n                 self.prefer(args[0], None);\n             }\n-            ~\"test\" => {\n+            \"test\" => {\n                 self.test();\n             }\n-            ~\"uninstall\" => {\n+            \"uninstall\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n \n                 self.uninstall(args[0], None);\n             }\n-            ~\"unprefer\" => {\n+            \"unprefer\" => {\n                 if args.len() < 1 {\n                     return usage::uninstall();\n                 }\n@@ -249,7 +256,7 @@ impl Ctx {\n     }\n \n     fn build(&self, workspace: &Path, pkgid: &PkgId) {\n-        let src_dir   = pkgid_src_in_workspace(pkgid, workspace);\n+        let src_dir   = first_pkgid_src_in_workspace(pkgid, workspace);\n         let build_dir = build_pkg_id_in_workspace(pkgid, workspace);\n         debug!(\"Destination dir = %s\", build_dir.to_str());\n \n@@ -260,8 +267,8 @@ impl Ctx {\n         // Is there custom build logic? If so, use it\n         let pkg_src_dir = src_dir;\n         let mut custom = false;\n-        debug!(\"Package source directory = %s\", pkg_src_dir.to_str());\n-        let cfgs = match src.package_script_option(&pkg_src_dir) {\n+        debug!(\"Package source directory = %?\", pkg_src_dir);\n+        let cfgs = match pkg_src_dir.chain_ref(|p| src.package_script_option(p)) {\n             Some(package_script_path) => {\n                 let pscript = PkgScript::parse(package_script_path,\n                                                workspace,\n@@ -290,7 +297,7 @@ impl Ctx {\n             // Find crates inside the workspace\n             src.find_crates();\n             // Build it!\n-            src.build(&build_dir, cfgs, self.sysroot_opt);\n+            src.build(self, build_dir, cfgs);\n         }\n     }\n \n@@ -352,7 +359,7 @@ impl Ctx {\n     }\n \n     fn prefer(&self, _id: &str, _vers: Option<~str>)  {\n-        fail!(~\"prefer not yet implemented\");\n+        fail!(\"prefer not yet implemented\");\n     }\n \n     fn test(&self)  {\n@@ -522,21 +529,20 @@ impl PkgSrc {\n     fn check_dir(&self) -> Path {\n         use conditions::nonexistent_package::cond;\n \n-        debug!(\"Pushing onto root: %s | %s\", self.id.to_str(),\n+        debug!(\"Pushing onto root: %s | %s\", self.id.remote_path.to_str(),\n                self.root.to_str());\n-\n-        let mut dir = self.root.push(\"src\");\n-        dir = dir.push(self.id.to_str()); // ?? Should this use the version number?\n-\n-        debug!(\"Checking dir: %s\", dir.to_str());\n-\n-        if !os::path_exists(&dir) {\n-            if !self.fetch_git() {\n-                cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n-                    exist, and couldn't interpret it as a URL fragment\"));\n+        let dir;\n+        let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n+        debug!(\"Checking dirs: %?\", dirs);\n+        let path = dirs.find(|d| os::path_exists(d));\n+        match path {\n+            Some(d) => dir = d,\n+            None => dir = match self.fetch_git() {\n+                None => cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n+                                      exist, and couldn't interpret it as a URL fragment\")),\n+                Some(d) => d\n             }\n         }\n-\n         if !os::path_is_dir(&dir) {\n             cond.raise((copy self.id, ~\"supplied path for package dir is a \\\n                                         non-directory\"));\n@@ -546,10 +552,10 @@ impl PkgSrc {\n     }\n \n     /// Try interpreting self's package id as a remote package, and try\n-    /// fetching it and caching it in a local directory. If that didn't\n-    /// work, return false.\n+    /// fetching it and caching it in a local directory. Return the cached directory\n+    /// if this was successful, None otherwise\n     /// (right now we only support git)\n-    fn fetch_git(&self) -> bool {\n+    fn fetch_git(&self) -> Option<Path> {\n \n         let mut local = self.root.push(\"src\");\n         local = local.push(self.id.to_str());\n@@ -561,9 +567,11 @@ impl PkgSrc {\n \n         if run::process_output(\"git\", [~\"clone\", copy url, local.to_str()]).status != 0 {\n             util::note(fmt!(\"fetching %s failed: can't clone repository\", url));\n-            return false;\n+            None\n+        }\n+        else {\n+            Some(local)\n         }\n-        true\n     }\n \n \n@@ -655,7 +663,7 @@ impl PkgSrc {\n     }\n \n     fn build_crates(&self,\n-                    maybe_sysroot: Option<@Path>,\n+                    ctx: &Ctx,\n                     dst_dir: &Path,\n                     src_dir: &Path,\n                     crates: &[Crate],\n@@ -666,11 +674,14 @@ impl PkgSrc {\n             util::note(fmt!(\"build_crates: compiling %s\", path.to_str()));\n             util::note(fmt!(\"build_crates: destination dir is %s\", dst_dir.to_str()));\n \n-            let result = util::compile_crate(maybe_sysroot, &self.id, path,\n-                                     dst_dir,\n-                                     crate.flags,\n-                                     crate.cfgs + cfgs,\n-                                     false, what);\n+            let result = util::compile_crate(ctx,\n+                                             &self.id,\n+                                             path,\n+                                             dst_dir,\n+                                             crate.flags,\n+                                             crate.cfgs + cfgs,\n+                                             false,\n+                                             what);\n             if !result {\n                 build_err::cond.raise(fmt!(\"build failure on %s\",\n                                            path.to_str()));\n@@ -680,15 +691,15 @@ impl PkgSrc {\n         }\n     }\n \n-    fn build(&self, dst_dir: &Path, cfgs: ~[~str], maybe_sysroot: Option<@Path>) {\n+    fn build(&self, ctx: &Ctx, dst_dir: Path, cfgs: ~[~str]) {\n         let dir = self.check_dir();\n         debug!(\"Building libs\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.libs, cfgs, Lib);\n+        self.build_crates(ctx, &dst_dir, &dir, self.libs, cfgs, Lib);\n         debug!(\"Building mains\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.mains, cfgs, Main);\n+        self.build_crates(ctx, &dst_dir, &dir, self.mains, cfgs, Main);\n         debug!(\"Building tests\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.tests, cfgs, Test);\n+        self.build_crates(ctx, &dst_dir, &dir, self.tests, cfgs, Test);\n         debug!(\"Building benches\");\n-        self.build_crates(maybe_sysroot, dst_dir, &dir, self.benchs, cfgs, Bench);\n+        self.build_crates(ctx, &dst_dir, &dir, self.benchs, cfgs, Bench);\n     }\n }"}, {"sha": "987e01009fc8b8580da1832e86ff78bce0f855c3", "filename": "src/librustpkg/search.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fsearch.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use path_util::installed_library_in_workspace;\n+use core::prelude::*;\n+\n+/// If a library with path `p` matching pkg_id's name exists under sroot_opt,\n+/// return Some(p). Return None if there's no such path or if sroot_opt is None.\n+pub fn find_library_in_search_path(sroot_opt: Option<@Path>, short_name: &str) -> Option<Path> {\n+    match sroot_opt {\n+        Some(sroot) => {\n+            debug!(\"Will search for a library with short name %s in \\\n+                    %s\", short_name, (sroot.push(\"lib\")).to_str());\n+            installed_library_in_workspace(short_name, sroot)\n+        }\n+        None => None\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "03c2f5a4fe42afa5ae5c2514cd461333aaae63ac", "filename": "src/librustpkg/target.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftarget.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Data types that express build artifacts\n+\n+#[deriving(Eq)]\n+pub enum OutputType { Main, Lib, Bench, Test }\n+\n+#[deriving(Eq)]\n+pub enum Target {\n+    // In-place build\n+    Build,\n+    // Install to bin/ or lib/ dir\n+    Install\n+}"}, {"sha": "a96a7a0a5fc9a7b601f193b2a14148b40ecd5637", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -17,10 +17,11 @@ use core::os;\n use core::prelude::*;\n use core::result;\n use extra::tempfile::mkdtemp;\n-use util::{PkgId, default_version};\n+use package_path::*;\n+use package_id::{PkgId, default_version};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n-               make_dir_rwx, u_rwx, RemotePath, LocalPath, normalize,\n+               make_dir_rwx, u_rwx,\n                built_bench_in_workspace, built_test_in_workspace};\n \n fn fake_ctxt(sysroot_opt: Option<@Path>) -> Ctx {\n@@ -52,7 +53,7 @@ fn remote_pkg() -> PkgId {\n     }\n }\n \n-fn writeFile(file_path: &Path, contents: ~str) {\n+fn writeFile(file_path: &Path, contents: &str) {\n     let out: @io::Writer =\n         result::get(&io::file_writer(file_path,\n                                      [io::Create, io::Truncate]));\n@@ -64,15 +65,17 @@ fn mk_temp_workspace(short_name: &LocalPath) -> Path {\n     // include version number in directory name\n     let package_dir = workspace.push(\"src\").push(fmt!(\"%s-0.1\", short_name.to_str()));\n     assert!(os::mkdir_recursive(&package_dir, u_rwx));\n+    debug!(\"Created %s and does it exist? %?\", package_dir.to_str(),\n+          os::path_is_dir(&package_dir));\n     // Create main, lib, test, and bench files\n     writeFile(&package_dir.push(\"main.rs\"),\n-              ~\"fn main() { let _x = (); }\");\n+              \"fn main() { let _x = (); }\");\n     writeFile(&package_dir.push(\"lib.rs\"),\n-              ~\"pub fn f() { let _x = (); }\");\n+              \"pub fn f() { let _x = (); }\");\n     writeFile(&package_dir.push(\"test.rs\"),\n-              ~\"#[test] pub fn f() { (); }\");\n+              \"#[test] pub fn f() { (); }\");\n     writeFile(&package_dir.push(\"bench.rs\"),\n-              ~\"#[bench] pub fn f() { (); }\");\n+              \"#[bench] pub fn f() { (); }\");\n     workspace\n }\n \n@@ -111,6 +114,8 @@ fn test_make_dir_rwx() {\n \n #[test]\n fn test_install_valid() {\n+    use path_util::installed_library_in_workspace;\n+\n     let sysroot = test_sysroot();\n     debug!(\"sysroot = %s\", sysroot.to_str());\n     let ctxt = fake_ctxt(Some(@sysroot));\n@@ -123,10 +128,12 @@ fn test_install_valid() {\n     debug!(\"exec = %s\", exec.to_str());\n     assert!(os::path_exists(&exec));\n     assert!(is_rwx(&exec));\n-    let lib = target_library_in_workspace(&temp_pkg_id, &temp_workspace);\n-    debug!(\"lib = %s\", lib.to_str());\n-    assert!(os::path_exists(&lib));\n-    assert!(is_rwx(&lib));\n+\n+    let lib = installed_library_in_workspace(temp_pkg_id.short_name, &temp_workspace);\n+    debug!(\"lib = %?\", lib);\n+    assert!(lib.map_default(false, |l| os::path_exists(l)));\n+    assert!(lib.map_default(false, |l| is_rwx(l)));\n+\n     // And that the test and bench executables aren't installed\n     assert!(!os::path_exists(&target_test_in_workspace(&temp_pkg_id, &temp_workspace)));\n     let bench = target_bench_in_workspace(&temp_pkg_id, &temp_workspace);\n@@ -149,6 +156,7 @@ fn test_install_invalid() {\n     }).in {\n         do cond.trap(|_| {\n             error_occurred = true;\n+            copy temp_workspace\n         }).in {\n             ctxt.install(&temp_workspace, &pkgid);\n         }\n@@ -174,10 +182,11 @@ fn test_install_url() {\n     debug!(\"lib = %s\", lib.to_str());\n     assert!(os::path_exists(&lib));\n     assert!(is_rwx(&lib));\n-    let built_test = built_test_in_workspace(&temp_pkg_id, &workspace).expect(\"test_install_url\");\n+    let built_test = built_test_in_workspace(&temp_pkg_id,\n+                         &workspace).expect(\"test_install_url: built test should exist\");\n     assert!(os::path_exists(&built_test));\n     let built_bench = built_bench_in_workspace(&temp_pkg_id,\n-                                               &workspace).expect(\"test_install_url\");\n+                          &workspace).expect(\"test_install_url: built bench should exist\");\n     assert!(os::path_exists(&built_bench));\n     // And that the test and bench executables aren't installed\n     let test = target_test_in_workspace(&temp_pkg_id, &workspace);"}, {"sha": "1e5c1d5e627d18a9c4f8ee57d5bd6bd574ace710", "filename": "src/librustpkg/testsuite/pass/src/external-crate/main.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fexternal-crate%2Fmain.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -13,9 +13,12 @@ The test runner should check that, after `rustpkg install external crate`\n   with RUST_PATH undefined in the environment\n   and with `rustpkg install deeply/nested/path/foo` already\n      executed:\n-   * ./.rust/external_crate exists and is an executable\n+   * ../bin/external_crate exists and is an executable\n+\n+  tjc: Also want a test like this where foo is an external URL,\n+    which requires the `extern mod` changes\n */\n \n-extern mod foo; // refers to deeply/nested/path/foo\n+extern mod foo;\n \n fn main() {}"}, {"sha": "91fc466f8c65b075eef43d88604ebc07678fbe78", "filename": "src/librustpkg/testsuite/pass/src/foo/lib.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffoo%2Flib.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {}"}, {"sha": "c5a5aaea178ade81f1236a0fed65ceead4d934ba", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 124, "deletions": 223, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -9,23 +9,28 @@\n // except according to those terms.\n \n use core::prelude::*;\n-use core::*;\n-use core::cmp::Ord;\n-use core::hash::Streaming;\n-use core::rt::io::Writer;\n+use core::{io, libc, os, result, str};\n use rustc::driver::{driver, session};\n use rustc::metadata::filesearch;\n use extra::getopts::groups::getopts;\n-use extra::semver;\n use extra::term;\n+#[cfg(not(test))]\n+use extra::getopts;\n use syntax::ast_util::*;\n-use syntax::codemap::{dummy_sp, spanned, dummy_spanned};\n+use syntax::codemap::{dummy_sp, spanned};\n+use syntax::codemap::dummy_spanned;\n use syntax::ext::base::ExtCtxt;\n use syntax::{ast, attr, codemap, diagnostic, fold};\n use syntax::ast::{meta_name_value, meta_list};\n use syntax::attr::{mk_attr};\n use rustc::back::link::output_type_exe;\n+use rustc::driver::driver::compile_upto;\n use rustc::driver::session::{lib_crate, bin_crate};\n+use context::Ctx;\n+use package_id::PkgId;\n+use path_util::target_library_in_workspace;\n+use search::find_library_in_search_path;\n+pub use target::{OutputType, Main, Lib, Bench, Test};\n \n static Commands: &'static [&'static str] =\n     &[\"build\", \"clean\", \"do\", \"info\", \"install\", \"prefer\", \"test\", \"uninstall\",\n@@ -34,119 +39,6 @@ static Commands: &'static [&'static str] =\n \n pub type ExitCode = int; // For now\n \n-/// A version is either an exact revision,\n-/// or a semantic version\n-pub enum Version {\n-    ExactRevision(float),\n-    SemVersion(semver::Version)\n-}\n-\n-impl Ord for Version {\n-    fn lt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn le(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn ge(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn gt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-\n-}\n-\n-impl ToStr for Version {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ExactRevision(ref n) => n.to_str(),\n-            SemVersion(ref v) => v.to_str()\n-        }\n-    }\n-}\n-\n-#[deriving(Eq)]\n-pub enum OutputType { Main, Lib, Bench, Test }\n-\n-/// Placeholder\n-pub fn default_version() -> Version { ExactRevision(0.1) }\n-\n-/// Path-fragment identifier of a package such as\n-/// 'github.com/graydon/test'; path must be a relative\n-/// path with >=1 component.\n-pub struct PkgId {\n-    /// Remote path: for example, github.com/mozilla/quux-whatever\n-    remote_path: RemotePath,\n-    /// Local path: for example, /home/quux/github.com/mozilla/quux_whatever\n-    /// Note that '-' normalizes to '_' when mapping a remote path\n-    /// onto a local path\n-    /// Also, this will change when we implement #6407, though we'll still\n-    /// need to keep track of separate local and remote paths\n-    local_path: LocalPath,\n-    /// Short name. This is the local path's filestem, but we store it\n-    /// redundantly so as to not call get() everywhere (filestem() returns an\n-    /// option)\n-    short_name: ~str,\n-    version: Version\n-}\n-\n-impl PkgId {\n-    pub fn new(s: &str) -> PkgId {\n-        use conditions::bad_pkg_id::cond;\n-\n-        let p = Path(s);\n-        if p.is_absolute {\n-            return cond.raise((p, ~\"absolute pkgid\"));\n-        }\n-        if p.components.len() < 1 {\n-            return cond.raise((p, ~\"0-length pkgid\"));\n-        }\n-        let remote_path = RemotePath(p);\n-        let local_path = normalize(copy remote_path);\n-        let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n-        PkgId {\n-            local_path: local_path,\n-            remote_path: remote_path,\n-            short_name: short_name,\n-            version: default_version()\n-        }\n-    }\n-\n-    pub fn hash(&self) -> ~str {\n-        fmt!(\"%s-%s-%s\", self.remote_path.to_str(),\n-             hash(self.remote_path.to_str() + self.version.to_str()),\n-             self.version.to_str())\n-    }\n-\n-    pub fn short_name_with_version(&self) -> ~str {\n-        fmt!(\"%s-%s\", self.short_name, self.version.to_str())\n-    }\n-}\n-\n-impl ToStr for PkgId {\n-    fn to_str(&self) -> ~str {\n-        // should probably use the filestem and not the whole path\n-        fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n-    }\n-}\n-\n pub struct Pkg {\n     id: PkgId,\n     bins: ~[~str],\n@@ -264,13 +156,6 @@ pub fn ready_crate(sess: session::Session,\n     @fold.fold_crate(crate)\n }\n \n-pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n-    match semver::parse(vers) {\n-        Some(vers) => result::Ok(vers),\n-        None => result::Err(~\"could not parse version: invalid\")\n-    }\n-}\n-\n pub fn need_dir(s: &Path) {\n     if !os::path_is_dir(s) && !os::make_dir(s, 493_i32) {\n         fail!(\"can't create dir: %s\", s.to_str());\n@@ -316,15 +201,8 @@ pub fn error(msg: ~str) {\n     }\n }\n \n-pub fn hash(data: ~str) -> ~str {\n-    let mut hasher = hash::default_state();\n-    let buffer = str::as_bytes_slice(data);\n-    hasher.write(buffer);\n-    hasher.result_str()\n-}\n-\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_input(sysroot: Option<@Path>,\n+pub fn compile_input(ctxt: &Ctx,\n                      pkg_id: &PkgId,\n                      in_file: &Path,\n                      out_dir: &Path,\n@@ -333,30 +211,19 @@ pub fn compile_input(sysroot: Option<@Path>,\n                      opt: bool,\n                      what: OutputType) -> bool {\n \n+    let workspace = out_dir.pop().pop();\n+\n     assert!(in_file.components.len() > 1);\n     let input = driver::file_input(copy *in_file);\n     debug!(\"compile_input: %s / %?\", in_file.to_str(), what);\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n     let binary = @(copy os::args()[0]);\n-    let building_library = what == Lib;\n-\n-    let out_file = if building_library {\n-        out_dir.push(os::dll_filename(pkg_id.short_name))\n-    }\n-    else {\n-        out_dir.push(pkg_id.short_name + match what {\n-            Test => ~\"test\", Bench => ~\"bench\", Main | Lib => ~\"\"\n-        } + os::EXE_SUFFIX)\n-    };\n \n-    debug!(\"compiling %s into %s\",\n-           in_file.to_str(),\n-           out_file.to_str());\n     debug!(\"flags: %s\", str::connect(flags, \" \"));\n     debug!(\"cfgs: %s\", str::connect(cfgs, \" \"));\n-    debug!(\"compile_input's sysroot = %?\", sysroot);\n+    debug!(\"compile_input's sysroot = %?\", ctxt.sysroot_opt);\n \n     let crate_type = match what {\n         Lib => lib_crate,\n@@ -372,28 +239,62 @@ pub fn compile_input(sysroot: Option<@Path>,\n                           + flags\n                           + cfgs.flat_map(|&c| { ~[~\"--cfg\", c] }),\n                           driver::optgroups()).get();\n-    let mut options = session::options {\n+    let options = @session::options {\n         crate_type: crate_type,\n         optimize: if opt { session::Aggressive } else { session::No },\n         test: what == Test || what == Bench,\n-        maybe_sysroot: sysroot,\n-        addl_lib_search_paths: ~[copy *out_dir],\n+        maybe_sysroot: ctxt.sysroot_opt,\n+        addl_lib_search_paths: @mut ~[copy *out_dir],\n         // output_type should be conditional\n         output_type: output_type_exe, // Use this to get a library? That's weird\n         .. copy *driver::build_session_options(binary, &matches, diagnostic::emit)\n     };\n \n-    for cfgs.each |&cfg| {\n-        options.cfg.push(attr::mk_word_item(@cfg));\n-    }\n+    let addl_lib_search_paths = @mut options.addl_lib_search_paths;\n \n-    let sess = driver::build_session(@options, diagnostic::emit);\n+    let sess = driver::build_session(options, diagnostic::emit);\n+\n+    // Infer dependencies that rustpkg needs to build, by scanning for\n+    // `extern mod` directives.\n+    let cfg = driver::build_configuration(sess, binary, &input);\n+    let (crate_opt, _) = driver::compile_upto(sess, copy cfg, &input, driver::cu_expand, None);\n+\n+    let mut crate = match crate_opt {\n+        Some(c) => c,\n+        None => fail!(\"compile_input expected...\")\n+    };\n+\n+    // Not really right. Should search other workspaces too, and the installed\n+    // database (which doesn't exist yet)\n+    find_and_install_dependencies(ctxt, sess, &workspace, crate,\n+                                  |p| {\n+                                      debug!(\"a dependency: %s\", p.to_str());\n+                                      // Pass the directory containing a dependency\n+                                      // as an additional lib search path\n+                                      addl_lib_search_paths.push(p);\n+                                  });\n+\n+    // Inject the link attributes so we get the right package name and version\n+    if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n+        let short_name_to_use = match what {\n+            Test  => fmt!(\"%stest\", pkg_id.short_name),\n+            Bench => fmt!(\"%sbench\", pkg_id.short_name),\n+            _     => copy pkg_id.short_name\n+        };\n+        debug!(\"Injecting link name: %s\", short_name_to_use);\n+        crate = @codemap::respan(crate.span, ast::crate_ {\n+            attrs: ~[mk_attr(@dummy_spanned(\n+                meta_list(@~\"link\",\n+                 ~[@dummy_spanned(meta_name_value(@~\"name\",\n+                                      mk_string_lit(@short_name_to_use))),\n+                   @dummy_spanned(meta_name_value(@~\"vers\",\n+                                      mk_string_lit(@(copy pkg_id.version.to_str()))))])))],\n+            ..copy crate.node});\n+    }\n \n     debug!(\"calling compile_crate_from_input, out_dir = %s,\n            building_library = %?\", out_dir.to_str(), sess.building_library);\n-    let _ = compile_crate_from_input(&input, pkg_id, Some(copy *out_dir), sess,\n-                                     None, &out_file, binary,\n-                                     driver::cu_everything);\n+    compile_crate_from_input(&input, out_dir, sess, crate, copy cfg);\n     true\n }\n \n@@ -403,52 +304,31 @@ pub fn compile_input(sysroot: Option<@Path>,\n // call compile_upto and return the crate\n // also, too many arguments\n pub fn compile_crate_from_input(input: &driver::input,\n-                                pkg_id: &PkgId,\n-                                build_dir_opt: Option<Path>,\n+                                build_dir: &Path,\n                                 sess: session::Session,\n-                                crate_opt: Option<@ast::crate>,\n-                                out_file: &Path,\n-                                binary: @~str,\n-                                what: driver::compile_upto) -> @ast::crate {\n-    debug!(\"Calling build_output_filenames with %? and %s\", build_dir_opt, out_file.to_str());\n-    let outputs = driver::build_output_filenames(input, &build_dir_opt,\n-                                                 &Some(copy *out_file), sess);\n-    debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n-    let cfg = driver::build_configuration(sess, binary, input);\n-    match crate_opt {\n-        Some(c) => {\n-            debug!(\"Calling compile_rest, outputs = %?\", outputs);\n-            assert_eq!(what, driver::cu_everything);\n-            driver::compile_rest(sess, cfg, driver::cu_everything, Some(outputs), Some(c));\n-            c\n-        }\n-        None => {\n-            debug!(\"Calling compile_upto, outputs = %?\", outputs);\n-            let (crate, _) = driver::compile_upto(sess, copy cfg, input,\n-                                                  driver::cu_parse, Some(outputs));\n-            let mut crate = crate.unwrap();\n-\n-            debug!(\"About to inject link_meta info...\");\n-            // Inject the inferred link_meta info if it's not already there\n-            // (assumes that name and vers are the only linkage metas)\n-\n-            debug!(\"How many attrs? %?\", attr::find_linkage_metas(crate.node.attrs).len());\n-\n-            if attr::find_linkage_metas(crate.node.attrs).is_empty() {\n-                crate = @codemap::respan(crate.span, ast::crate_ {\n-                    attrs: ~[mk_attr(@dummy_spanned(\n-                        meta_list(@~\"link\",\n-                                  ~[@dummy_spanned(meta_name_value(@~\"name\",\n-                                        mk_string_lit(@(copy pkg_id.short_name)))),\n-                                    @dummy_spanned(meta_name_value(@~\"vers\",\n-                                        mk_string_lit(@(copy pkg_id.version.to_str()))))])))],\n-                    ..copy crate.node});\n-            }\n+                                crate: @ast::crate,\n+                                cfg: ast::crate_cfg) {\n+    debug!(\"Calling build_output_filenames with %s, building library? %?\",\n+           build_dir.to_str(), sess.building_library);\n \n-            driver::compile_rest(sess, cfg, what, Some(outputs), Some(crate));\n-            crate\n-        }\n+    // bad copy\n+    let outputs = driver::build_output_filenames(input, &Some(copy *build_dir), &None,\n+                                                 crate.node.attrs, sess);\n+\n+    debug!(\"Outputs are %? and output type = %?\", outputs, sess.opts.output_type);\n+    debug!(\"additional libraries:\");\n+    for sess.opts.addl_lib_search_paths.each |lib| {\n+        debug!(\"an additional library: %s\", lib.to_str());\n     }\n+\n+    driver::compile_rest(sess,\n+                         cfg,\n+                         compile_upto {\n+                             from: driver::cu_expand,\n+                             to: driver::cu_everything\n+                         },\n+                         Some(outputs),\n+                         Some(crate));\n }\n \n #[cfg(windows)]\n@@ -462,7 +342,7 @@ pub fn exe_suffix() -> ~str { ~\"\" }\n \n // Called by build_crates\n // FIXME (#4432): Use workcache to only compile when needed\n-pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n+pub fn compile_crate(ctxt: &Ctx, pkg_id: &PkgId,\n                      crate: &Path, dir: &Path,\n                      flags: &[~str], cfgs: &[~str], opt: bool,\n                      what: OutputType) -> bool {\n@@ -471,26 +351,51 @@ pub fn compile_crate(sysroot: Option<@Path>, pkg_id: &PkgId,\n     for flags.each |&fl| {\n         debug!(\"+++ %s\", fl);\n     }\n-    compile_input(sysroot, pkg_id, crate, dir, flags, cfgs, opt, what)\n+    compile_input(ctxt, pkg_id, crate, dir, flags, cfgs, opt, what)\n }\n \n-// normalize should be the only way to construct a LocalPath\n-// (though this isn't enforced)\n-/// Replace all occurrences of '-' in the stem part of path with '_'\n-/// This is because we treat rust-foo-bar-quux and rust_foo_bar_quux\n-/// as the same name\n-pub fn normalize(p_: RemotePath) -> LocalPath {\n-    let RemotePath(p) = p_;\n-    match p.filestem() {\n-        None => LocalPath(p),\n-        Some(st) => {\n-            let replaced = str::replace(st, \"-\", \"_\");\n-            if replaced != st {\n-                LocalPath(p.with_filestem(replaced))\n-            }\n-            else {\n-                LocalPath(p)\n+/// Collect all `extern mod` directives in `c`, then\n+/// try to install their targets, failing if any target\n+/// can't be found.\n+fn find_and_install_dependencies(ctxt: &Ctx,\n+                                 sess: session::Session,\n+                                 workspace: &Path,\n+                                 c: &ast::crate,\n+                                 save: @fn(Path)\n+                                ) {\n+    // :-(\n+    debug!(\"In find_and_install_dependencies...\");\n+    let my_workspace = copy *workspace;\n+    let my_ctxt      = copy *ctxt;\n+    for c.each_view_item() |vi: @ast::view_item| {\n+        debug!(\"A view item!\");\n+        match vi.node {\n+            // ignore metadata, I guess\n+            ast::view_item_extern_mod(lib_ident, _, _) => {\n+                match my_ctxt.sysroot_opt {\n+                    Some(ref x) => debug!(\"sysroot: %s\", x.to_str()),\n+                    None => ()\n+                };\n+                let lib_name = sess.str_of(lib_ident);\n+                match find_library_in_search_path(my_ctxt.sysroot_opt, *lib_name) {\n+                    Some(installed_path) => {\n+                        debug!(\"It exists: %s\", installed_path.to_str());\n+                    }\n+                    None => {\n+                        // Try to install it\n+                        let pkg_id = PkgId::new(*lib_name);\n+                        my_ctxt.install(&my_workspace, &pkg_id);\n+                        // Also, add an additional search path\n+                        let installed_path = target_library_in_workspace(&pkg_id,\n+                                                                         &my_workspace).pop();\n+                        debug!(\"Great, I installed %s, and it's in %s\",\n+                               *lib_name, installed_path.to_str());\n+                        save(installed_path);\n+                    }\n+                }\n             }\n+            // Ignore `use`s\n+            _ => ()\n         }\n     }\n }\n@@ -526,10 +431,6 @@ pub fn mk_string_lit(s: @~str) -> ast::lit {\n     }\n }\n \n-/// Wrappers to prevent local and remote paths from getting confused\n-pub struct RemotePath (Path);\n-pub struct LocalPath (Path);\n-\n #[cfg(test)]\n mod test {\n     use super::is_cmd;"}, {"sha": "3010e27385fa0d79a10b8436946f7b944288a3db", "filename": "src/librustpkg/workspace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c120464be07a5d14f10909ea6718c58c3aa911e4/src%2Flibrustpkg%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fworkspace.rs?ref=c120464be07a5d14f10909ea6718c58c3aa911e4", "patch": "@@ -11,7 +11,7 @@\n // rustpkg utilities having to do with workspaces\n \n use path_util::{rust_path, workspace_contains_package_id};\n-use util::PkgId;\n+use package_id::PkgId;\n use core::path::Path;\n \n pub fn pkg_parent_workspaces(pkgid: &PkgId, action: &fn(&Path) -> bool) -> bool {"}]}