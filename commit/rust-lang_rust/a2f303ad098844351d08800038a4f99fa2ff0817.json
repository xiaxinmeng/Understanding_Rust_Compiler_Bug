{"sha": "a2f303ad098844351d08800038a4f99fa2ff0817", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZjMwM2FkMDk4ODQ0MzUxZDA4ODAwMDM4YTRmOTlmYTJmZjA4MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-09T03:51:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-09T03:51:41Z"}, "message": "auto merge of #18743 : nikomatsakis/rust/hrtb-refactor-2, r=pcwalton\n\nVarious miscellaneous changes pushing towards HRTB support:\r\n\r\n1. Update parser and adjust ast to support `for<'a,'b>` syntax, both in closures and trait bounds. Warn on the old syntax (not error, for stage0).\r\n2. Refactor TyTrait representation to include a TraitRef.\r\n3. Purge `once_fns` feature gate and `once` keyword.\r\n\r\nr? @pcwalton \r\n\r\nThis is a [breaking-change]:\r\n\r\n- The `once_fns` feature is now officially deprecated. Rewrite using normal closures or unboxed closures.\r\n- The new `for`-based syntax now issues warnings (but not yet errors):\r\n  - `fn<'a>(T) -> U` becomes `for<'a> fn(T) -> U`\r\n  - `<'a> |T| -> U` becomes `for<'a> |T| -> U`", "tree": {"sha": "8ab2d0ef6dc8abb598082f43f8496911bdc4c470", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ab2d0ef6dc8abb598082f43f8496911bdc4c470"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2f303ad098844351d08800038a4f99fa2ff0817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2f303ad098844351d08800038a4f99fa2ff0817", "html_url": "https://github.com/rust-lang/rust/commit/a2f303ad098844351d08800038a4f99fa2ff0817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2f303ad098844351d08800038a4f99fa2ff0817/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93c85eb8bdcc910a27caf6abd20207a626ae98e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/93c85eb8bdcc910a27caf6abd20207a626ae98e5", "html_url": "https://github.com/rust-lang/rust/commit/93c85eb8bdcc910a27caf6abd20207a626ae98e5"}, {"sha": "cf4e53eee7377b42524176f39b0b428175c74fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf4e53eee7377b42524176f39b0b428175c74fb1", "html_url": "https://github.com/rust-lang/rust/commit/cf4e53eee7377b42524176f39b0b428175c74fb1"}], "stats": {"total": 1486, "additions": 749, "deletions": 737}, "files": [{"sha": "6f1287014d7760b73d1428e5644b31c0d66419a9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1690,8 +1690,8 @@ impl LintPass for Stability {\n                 for t in supertraits.iter() {\n                     match *t {\n                         ast::TraitTyParamBound(ref t) => {\n-                            let id = ty::trait_ref_to_def_id(cx.tcx, t);\n-                            self.lint(cx, id, t.path.span);\n+                            let id = ty::trait_ref_to_def_id(cx.tcx, &t.trait_ref);\n+                            self.lint(cx, id, t.trait_ref.path.span);\n                         }\n                         _ => (/* pass */)\n                     }"}, {"sha": "26b2afd2f3c319c6a8c6709f111e0f5d6638c696", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -389,11 +389,10 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let def = parse_def(st, NominalType, |x,y| conv(x,y));\n-        let substs = parse_substs(st, |x,y| conv(x,y));\n+        let trait_ref = parse_trait_ref(st, |x,y| conv(x,y));\n         let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, bounds);\n+        return ty::mk_trait(st.tcx, trait_ref, bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, |x,y| conv(x,y));"}, {"sha": "a7b64cb20e58812fa5fdb0b966b43656b658b535", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -231,13 +231,10 @@ fn enc_sty(w: &mut SeekableMemWriter, cx: &ctxt, st: &ty::sty) {\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_trait(box ty::TyTrait {\n-                def_id,\n-                ref substs,\n-                ref bounds\n-            }) => {\n-            mywrite!(w, \"x[{}|\", (cx.ds)(def_id));\n-            enc_substs(w, cx, substs);\n+        ty::ty_trait(box ty::TyTrait { ref principal,\n+                                       ref bounds }) => {\n+            mywrite!(w, \"x[\");\n+            enc_trait_ref(w, cx, principal);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }"}, {"sha": "aaf3b16c5eedb356f62c734c491bec8c659f677b", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1085,16 +1085,19 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                         this.emit_enum_variant_arg(1, |this| idx.encode(this))\n                     })\n                 }\n-                ty::UnsizeVtable(ty::TyTrait { def_id,\n-                                               bounds: ref b,\n-                                               ref substs },\n+                ty::UnsizeVtable(ty::TyTrait { ref principal,\n+                                               bounds: ref b },\n                                  self_ty) => {\n                     this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n-                        this.emit_enum_variant_arg(\n-                            0, |this| Ok(this.emit_existential_bounds(ecx, b)));\n-                        this.emit_enum_variant_arg(1, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(2, |this| Ok(this.emit_ty(ecx, self_ty)));\n-                        this.emit_enum_variant_arg(3, |this| Ok(this.emit_substs(ecx, substs)))\n+                        this.emit_enum_variant_arg(0, |this| {\n+                            try!(this.emit_struct_field(\"principal\", 0, |this| {\n+                                Ok(this.emit_trait_ref(ecx, &*principal))\n+                            }));\n+                            this.emit_struct_field(\"bounds\", 1, |this| {\n+                                Ok(this.emit_existential_bounds(ecx, b))\n+                            })\n+                        });\n+                        this.emit_enum_variant_arg(1, |this| Ok(this.emit_ty(ecx, self_ty)))\n                     })\n                 }\n             }\n@@ -1693,18 +1696,19 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         ty::UnsizeStruct(box uk, idx)\n                     }\n                     2 => {\n-                        let b =\n-                            this.read_enum_variant_arg(\n-                                0, |this| Ok(this.read_existential_bounds(dcx))).unwrap();\n-                        let def_id: ast::DefId =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this)).unwrap();\n+                        let ty_trait = try!(this.read_enum_variant_arg(0, |this| {\n+                            let principal = try!(this.read_struct_field(\"principal\", 0, |this| {\n+                                Ok(this.read_trait_ref(dcx))\n+                            }));\n+                            Ok(ty::TyTrait {\n+                                principal: (*principal).clone(),\n+                                bounds: try!(this.read_struct_field(\"bounds\", 1, |this| {\n+                                    Ok(this.read_existential_bounds(dcx))\n+                                })),\n+                            })\n+                        }));\n                         let self_ty =\n-                            this.read_enum_variant_arg(2, |this| Ok(this.read_ty(dcx))).unwrap();\n-                        let substs = this.read_enum_variant_arg(3,\n-                            |this| Ok(this.read_substs(dcx))).unwrap();\n-                        let ty_trait = ty::TyTrait { def_id: def_id.tr(dcx),\n-                                                     bounds: b,\n-                                                     substs: substs };\n+                            this.read_enum_variant_arg(1, |this| Ok(this.read_ty(dcx))).unwrap();\n                         ty::UnsizeVtable(ty_trait, self_ty)\n                     }\n                     _ => panic!(\"bad enum variant for ty::UnsizeKind\")"}, {"sha": "eddd616e616e0ca05898cb59f1290d59bf4f7a3c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1291,7 +1291,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         match *ty_param_bound {\n             ast::TraitTyParamBound(ref trait_ref) => {\n                 if !self.tcx.sess.features.borrow().visible_private_types &&\n-                        self.path_is_private_type(trait_ref.ref_id) {\n+                        self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n                     self.tcx.sess.span_err(span,\n                                            \"private type in exported type \\\n                                             parameter bound\");\n@@ -1432,7 +1432,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                             //\n                             // Those in 2. are warned via walk_generics and this\n                             // call here.\n-                            visit::walk_trait_ref_helper(self, tr)\n+                            self.visit_trait_ref(tr)\n                         }\n                     }\n                 } else if trait_ref.is_none() && self_is_public_path {"}, {"sha": "62d1e13d41f0665071e370fe0490b0291b4b907b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -33,12 +33,12 @@ use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, ItemConst};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n-use syntax::ast::{PrimTy, Public, SelfExplicit, SelfStatic};\n+use syntax::ast::{PolyTraitRef, PrimTy, Public, SelfExplicit, SelfStatic};\n use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n-use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyQPath};\n+use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyPolyTraitRef, TyProc, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem, UnnamedField};\n use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n@@ -607,6 +607,7 @@ enum TraitReferenceType {\n     TraitImplementation,             // impl SomeTrait for T { ... }\n     TraitDerivation,                 // trait T : SomeTrait { ... }\n     TraitBoundingTypeParameter,      // fn f<T:SomeTrait>() { ... }\n+    TraitObject,                     // Box<for<'a> SomeTrait>\n }\n \n impl NameBindings {\n@@ -4244,11 +4245,11 @@ impl<'a> Resolver<'a> {\n                     this.resolve_type_parameter_bounds(item.id, bounds,\n                                                        TraitDerivation);\n \n-                    match unbound {\n-                        &Some(ast::TraitTyParamBound(ref tpb)) => {\n+                    match *unbound {\n+                        Some(ref tpb) => {\n                             this.resolve_trait_reference(item.id, tpb, TraitDerivation);\n                         }\n-                        _ => {}\n+                        None => {}\n                     }\n \n                     for trait_item in (*trait_items).iter() {\n@@ -4495,7 +4496,7 @@ impl<'a> Resolver<'a> {\n         }\n         match &type_parameter.unbound {\n             &Some(ref unbound) =>\n-                self.resolve_type_parameter_bound(\n+                self.resolve_trait_reference(\n                     type_parameter.id, unbound, TraitBoundingTypeParameter),\n             &None => {}\n         }\n@@ -4521,12 +4522,19 @@ impl<'a> Resolver<'a> {\n                                     reference_type: TraitReferenceType) {\n         match *type_parameter_bound {\n             TraitTyParamBound(ref tref) => {\n-                self.resolve_trait_reference(id, tref, reference_type)\n+                self.resolve_poly_trait_reference(id, tref, reference_type)\n             }\n             RegionTyParamBound(..) => {}\n         }\n     }\n \n+    fn resolve_poly_trait_reference(&mut self,\n+                                    id: NodeId,\n+                                    poly_trait_reference: &PolyTraitRef,\n+                                    reference_type: TraitReferenceType) {\n+        self.resolve_trait_reference(id, &poly_trait_reference.trait_ref, reference_type)\n+    }\n+\n     fn resolve_trait_reference(&mut self,\n                                id: NodeId,\n                                trait_reference: &TraitRef,\n@@ -4538,6 +4546,7 @@ impl<'a> Resolver<'a> {\n                     TraitBoundingTypeParameter => \"bound type parameter with\",\n                     TraitImplementation        => \"implement\",\n                     TraitDerivation            => \"derive\",\n+                    TraitObject                => \"reference\",\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n@@ -5044,6 +5053,13 @@ impl<'a> Resolver<'a> {\n                 visit::walk_ty(self, ty);\n             }\n \n+            TyPolyTraitRef(ref poly_trait_ref) => {\n+                self.resolve_poly_trait_reference(\n+                    ty.id,\n+                    &**poly_trait_ref,\n+                    TraitObject);\n+                visit::walk_ty(self, ty);\n+            }\n             _ => {\n                 // Just resolve embedded types.\n                 visit::walk_ty(self, ty);"}, {"sha": "8ac52b891b99d65ad735175bd0f57daa410a5af5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 78, "deletions": 83, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -19,6 +19,7 @@\n \n use driver::session::Session;\n use middle::subst;\n+use std::fmt;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::owned_slice::OwnedSlice;\n@@ -46,18 +47,12 @@ pub enum DefRegion {\n // that it corresponds to\n pub type NamedRegionMap = NodeMap<DefRegion>;\n \n-// Returns an instance of some type that implements std::fmt::Show\n-fn lifetime_show(lt_name: &ast::Name) -> token::InternedString {\n-    token::get_name(*lt_name)\n-}\n-\n struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n     scope: Scope<'a>\n }\n \n-#[deriving(Show)]\n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n@@ -88,50 +83,42 @@ pub fn krate(sess: &Session, krate: &ast::Crate) -> NamedRegionMap {\n \n impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_item(&mut self, item: &ast::Item) {\n-        let lifetimes = match item.node {\n-            ast::ItemFn(..) | // fn lifetimes get added in visit_fn below\n+        match item.node {\n+            ast::ItemFn(..) => {\n+                // Fn lifetimes get added in visit_fn below:\n+                self.with(RootScope, |this| visit::walk_item(this, item));\n+            }\n             ast::ItemMod(..) |\n             ast::ItemMac(..) |\n             ast::ItemForeignMod(..) |\n-            ast::ItemStatic(..) | ast::ItemConst(..) => {\n-                self.with(|_, f| f(RootScope), |v| visit::walk_item(v, item));\n-                return;\n+            ast::ItemStatic(..) |\n+            ast::ItemConst(..) => {\n+                // These sorts of items have no lifetime parameters at all.\n+                self.with(RootScope, |this| visit::walk_item(this, item));\n             }\n             ast::ItemTy(_, ref generics) |\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(ref generics, _, _, _) => {\n-                self.with(|scope, f| {\n-                    f(EarlyScope(subst::TypeSpace,\n-                                 &generics.lifetimes,\n-                                 scope))\n-                }, |v| v.check_lifetime_defs(&generics.lifetimes));\n-                &generics.lifetimes\n-            }\n+            ast::ItemTrait(ref generics, _, _, _) |\n             ast::ItemImpl(ref generics, _, _, _) => {\n-                self.with(|scope, f| {\n-                    f(EarlyScope(subst::TypeSpace,\n-                                 &generics.lifetimes,\n-                                 scope))\n-                }, |v| v.check_lifetime_defs(&generics.lifetimes));\n-                &generics.lifetimes\n+                // These kinds of items have only early bound lifetime parameters.\n+                let lifetimes = &generics.lifetimes;\n+                self.with(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE), |this| {\n+                    this.check_lifetime_defs(lifetimes);\n+                    visit::walk_item(this, item);\n+                });\n             }\n-        };\n-\n-        self.with(|_, f| f(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE)), |v| {\n-            debug!(\"entering scope {}\", v.scope);\n-            v.check_lifetime_defs(lifetimes);\n-            visit::walk_item(v, item);\n-            debug!(\"exiting scope {}\", v.scope);\n-        });\n+        }\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, n: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n-                self.visit_fn_decl(n, generics, |v| visit::walk_fn(v, fk, fd, b, s))\n+                self.visit_early_late(\n+                    subst::FnSpace, n, generics,\n+                    |this| visit::walk_fn(this, fk, fd, b, s))\n             }\n             visit::FkFnBlock(..) => {\n                 visit::walk_fn(self, fk, fd, b, s)\n@@ -146,22 +133,20 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             _ => return visit::walk_ty(self, ty)\n         };\n \n-        self.with(|scope, f| f(LateScope(ty.id, lifetimes, scope)), |v| {\n-            v.check_lifetime_defs(lifetimes);\n-            debug!(\"pushing fn scope id={} due to type\", ty.id);\n-            visit::walk_ty(v, ty);\n-            debug!(\"popping fn scope id={} due to type\", ty.id);\n+        self.with(LateScope(ty.id, lifetimes, self.scope), |this| {\n+            this.check_lifetime_defs(lifetimes);\n+            visit::walk_ty(this, ty);\n         });\n     }\n \n     fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n-        self.visit_fn_decl(m.id, &m.generics, |v| visit::walk_ty_method(v, m))\n+        self.visit_early_late(\n+            subst::FnSpace, m.id, &m.generics,\n+            |this| visit::walk_ty_method(this, m))\n     }\n \n     fn visit_block(&mut self, b: &ast::Block) {\n-        debug!(\"pushing block scope {}\", b.id);\n-        self.with(|scope, f| f(BlockScope(b.id, scope)), |v| visit::walk_block(v, b));\n-        debug!(\"popping block scope {}\", b.id);\n+        self.with(BlockScope(b.id, self.scope), |this| visit::walk_block(this, b));\n     }\n \n     fn visit_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -188,21 +173,24 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n }\n \n impl<'a> LifetimeContext<'a> {\n-    fn with(&mut self, wrap_scope: |Scope, |ScopeChain||, f: |&mut LifetimeContext|) {\n-        let LifetimeContext { sess, ref mut named_region_map, scope} = *self;\n-        wrap_scope(scope, |scope1| f(&mut LifetimeContext {\n+    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n+        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n+        let mut this = LifetimeContext {\n             sess: sess,\n             named_region_map: *named_region_map,\n-            scope: &scope1\n-        }))\n+            scope: &wrap_scope\n+        };\n+        debug!(\"entering scope {}\", this.scope);\n+        f(&mut this);\n+        debug!(\"exiting scope {}\", this.scope);\n     }\n \n     fn visit_ty_param_bounds(&mut self,\n                              bounds: &OwnedSlice<ast::TyParamBound>) {\n         for bound in bounds.iter() {\n             match *bound {\n                 ast::TraitTyParamBound(ref trait_ref) => {\n-                    self.visit_trait_ref(trait_ref);\n+                    self.visit_poly_trait_ref(trait_ref);\n                 }\n                 ast::RegionTyParamBound(ref lifetime) => {\n                     self.visit_lifetime_ref(lifetime);\n@@ -211,23 +199,27 @@ impl<'a> LifetimeContext<'a> {\n         }\n     }\n \n-    fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n-        self.with(|scope, f| {\n-            f(LateScope(trait_ref.ref_id, &trait_ref.lifetimes, scope))\n-        }, |v| {\n-            v.check_lifetime_defs(&trait_ref.lifetimes);\n-            for lifetime in trait_ref.lifetimes.iter() {\n-                v.visit_lifetime_decl(lifetime);\n+    fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n+        let ref_id = trait_ref.trait_ref.ref_id;\n+        self.with(LateScope(ref_id, &trait_ref.bound_lifetimes, self.scope), |this| {\n+            this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n+            for lifetime in trait_ref.bound_lifetimes.iter() {\n+                this.visit_lifetime_decl(lifetime);\n             }\n-            v.visit_path(&trait_ref.path, trait_ref.ref_id);\n+            this.visit_trait_ref(&trait_ref.trait_ref)\n         })\n     }\n \n+    fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n+        self.visit_path(&trait_ref.path, trait_ref.ref_id);\n+    }\n+\n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n-    fn visit_fn_decl(&mut self,\n-                     n: ast::NodeId,\n-                     generics: &ast::Generics,\n-                     walk: |&mut LifetimeContext|) {\n+    fn visit_early_late(&mut self,\n+                        early_space: subst::ParamSpace,\n+                        binder_id: ast::NodeId,\n+                        generics: &ast::Generics,\n+                        walk: |&mut LifetimeContext|) {\n         /*!\n          * Handles visiting fns and methods. These are a bit\n          * complicated because we must distinguish early- vs late-bound\n@@ -248,33 +240,25 @@ impl<'a> LifetimeContext<'a> {\n          * numbered sequentially, starting from the lowest index that\n          * is already in scope (for a fn item, that will be 0, but for\n          * a method it might not be). Late bound lifetimes are\n-         * resolved by name and associated with a binder id (`n`), so\n+         * resolved by name and associated with a binder id (`binder_id`), so\n          * the ordering is not important there.\n          */\n \n         let referenced_idents = early_bound_lifetime_names(generics);\n-        debug!(\"pushing fn scope id={} due to fn item/method\\\n-               referenced_idents={}\",\n-               n,\n-               referenced_idents.iter().map(lifetime_show).collect::<Vec<token::InternedString>>());\n-        let lifetimes = &generics.lifetimes;\n-        if referenced_idents.is_empty() {\n-            self.with(|scope, f| f(LateScope(n, lifetimes, scope)), |v| {\n-                v.check_lifetime_defs(lifetimes);\n-                walk(v);\n-            });\n-        } else {\n-            let (early, late) = lifetimes.clone().partition(\n-                |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n-\n-            self.with(|scope, f| f(EarlyScope(subst::FnSpace, &early, scope)), |v| {\n-                v.with(|scope1, f| f(LateScope(n, &late, scope1)), |v| {\n-                    v.check_lifetime_defs(lifetimes);\n-                    walk(v);\n-                });\n+\n+        debug!(\"visit_early_late: binder_id={} referenced_idents={}\",\n+               binder_id,\n+               referenced_idents);\n+\n+        let (early, late) = generics.lifetimes.clone().partition(\n+            |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n+\n+        self.with(EarlyScope(early_space, &early, self.scope), |this| {\n+            this.with(LateScope(binder_id, &late, this.scope), |this| {\n+                this.check_lifetime_defs(&generics.lifetimes);\n+                walk(this);\n             });\n-        }\n-        debug!(\"popping fn scope id={} due to fn item/method\", n);\n+        });\n     }\n \n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &ast::Lifetime) {\n@@ -525,3 +509,14 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n         }\n     }\n }\n+\n+impl<'a> fmt::Show for ScopeChain<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({}, {})\", space, defs),\n+            LateScope(id, defs, _) => write!(fmt, \"LateScope({}, {})\", id, defs),\n+            BlockScope(id, _) => write!(fmt, \"BlockScope({})\", id),\n+            RootScope => write!(fmt, \"RootScope\"),\n+        }\n+    }\n+}"}, {"sha": "a2b80686d010ef7853ad97946b826e185017a77a", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -710,6 +710,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 }\n             };\n \n+            let trait_ref = &trait_ref.trait_ref;\n             match self.lookup_type_ref(trait_ref.ref_id) {\n                 Some(id) => {\n                     let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n@@ -1068,7 +1069,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             for bound in param.bounds.iter() {\n                 match *bound {\n                     ast::TraitTyParamBound(ref trait_ref) => {\n-                        self.process_trait_ref(trait_ref, None);\n+                        self.process_trait_ref(&trait_ref.trait_ref, None);\n                     }\n                     _ => {}\n                 }"}, {"sha": "9900620b229dab9f5044c8e17ed05591a2f6f351", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -143,7 +143,7 @@ pub fn ty_is_local(tcx: &ty::ctxt,\n         }\n \n         ty::ty_trait(ref tt) => {\n-            tt.def_id.krate == ast::LOCAL_CRATE\n+            tt.principal.def_id.krate == ast::LOCAL_CRATE\n         }\n \n         // Type parameters may be bound to types that are not local to"}, {"sha": "5b2e978e11fee3d803824b70943fa9a43d109bcb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -423,8 +423,8 @@ impl TypeMap {\n \n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.def_id,\n-                                       &trait_data.substs,\n+                                       trait_data.principal.def_id,\n+                                       &trait_data.principal.substs,\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(ty::BareFnTy{ fn_style, abi, ref sig } ) => {\n@@ -2813,7 +2813,7 @@ fn trait_pointer_metadata(cx: &CrateContext,\n     // But it does not describe the trait's methods.\n \n     let def_id = match ty::get(trait_type).sty {\n-        ty::ty_trait(box ty::TyTrait { def_id, .. }) => def_id,\n+        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id,\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n@@ -3739,8 +3739,8 @@ fn push_debuginfo_type_name(cx: &CrateContext,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.def_id, false, output);\n-            push_type_params(cx, &trait_data.substs, output);\n+            push_item_name(cx, trait_data.principal.def_id, false, output);\n+            push_type_params(cx, &trait_data.principal.substs, output);\n         },\n         ty::ty_bare_fn(ty::BareFnTy{ fn_style, abi, ref sig } ) => {\n             if fn_style == ast::UnsafeFn {"}, {"sha": "4b61f0c1409116a003c7004f6867ff7e87bf8e91", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -324,10 +324,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n                                           bcx.ty_to_string(unsized_ty)).as_slice())\n             },\n-            &ty::UnsizeVtable(ty::TyTrait { def_id, ref substs, .. }, _) => {\n-                let substs = substs.with_self_ty(unsized_ty);\n+            &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n+                let substs = principal.substs.with_self_ty(unsized_ty);\n                 let trait_ref =\n-                    Rc::new(ty::TraitRef { def_id: def_id,\n+                    Rc::new(ty::TraitRef { def_id: principal.def_id,\n                                            substs: substs });\n                 let trait_ref =\n                     trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);"}, {"sha": "1a6e8eeb320f048378527b559edc57f94805b60a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -378,14 +378,14 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n     fn type_of_autoref(cx: &ctxt, autoref: &AutoRef) -> Option<t> {\n         match autoref {\n             &AutoUnsize(ref k) => match k {\n-                &UnsizeVtable(TyTrait { def_id, ref substs, bounds }, _) => {\n-                    Some(mk_trait(cx, def_id, substs.clone(), bounds))\n+                &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n+                    Some(mk_trait(cx, (*principal).clone(), bounds))\n                 }\n                 _ => None\n             },\n             &AutoUnsizeUniq(ref k) => match k {\n-                &UnsizeVtable(TyTrait { def_id, ref substs, bounds }, _) => {\n-                    Some(mk_uniq(cx, mk_trait(cx, def_id, substs.clone(), bounds)))\n+                &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n+                    Some(mk_uniq(cx, mk_trait(cx, (*principal).clone(), bounds)))\n                 }\n                 _ => None\n             },\n@@ -983,12 +983,12 @@ pub enum sty {\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait {\n-    pub def_id: DefId,\n-    pub substs: Substs,\n+    // Principal trait reference.\n+    pub principal: TraitRef, // would use Rc<TraitRef>, but it runs afoul of some static rules\n     pub bounds: ExistentialBounds\n }\n \n-#[deriving(PartialEq, Eq, Hash, Show)]\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TraitRef {\n     pub def_id: DefId,\n     pub substs: Substs,\n@@ -1643,8 +1643,8 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n           flags = flags | sflags(substs);\n       }\n-      &ty_trait(box TyTrait { ref substs, ref bounds, .. }) => {\n-          flags = flags | sflags(substs);\n+      &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n+          flags = flags | sflags(&principal.substs);\n           flags = flags | flags_for_bounds(bounds);\n       }\n       &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n@@ -1874,14 +1874,12 @@ pub fn mk_ctor_fn(cx: &ctxt,\n \n \n pub fn mk_trait(cx: &ctxt,\n-                did: ast::DefId,\n-                substs: Substs,\n+                principal: ty::TraitRef,\n                 bounds: ExistentialBounds)\n                 -> t {\n     // take a copy of substs so that we own the vectors inside\n     let inner = box TyTrait {\n-        def_id: did,\n-        substs: substs,\n+        principal: principal,\n         bounds: bounds\n     };\n     mk_t(cx, ty_trait(inner))\n@@ -1934,9 +1932,15 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n         ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n             maybe_walk_ty(tm.ty, f);\n         }\n-        ty_enum(_, ref substs) | ty_struct(_, ref substs) | ty_unboxed_closure(_, _, ref substs) |\n-        ty_trait(box TyTrait { ref substs, .. }) => {\n-            for subty in (*substs).types.iter() {\n+        ty_trait(box TyTrait { ref principal, .. }) => {\n+            for subty in principal.substs.types.iter() {\n+                maybe_walk_ty(*subty, |x| f(x));\n+            }\n+        }\n+        ty_enum(_, ref substs) |\n+        ty_struct(_, ref substs) |\n+        ty_unboxed_closure(_, _, ref substs) => {\n+            for subty in substs.types.iter() {\n                 maybe_walk_ty(*subty, |x| f(x));\n             }\n         }\n@@ -3554,8 +3558,8 @@ pub fn unsize_ty(cx: &ctxt,\n                                   format!(\"UnsizeStruct with bad sty: {}\",\n                                           ty_to_string(cx, ty)).as_slice())\n         },\n-        &UnsizeVtable(TyTrait { def_id, ref substs, bounds }, _) => {\n-            mk_trait(cx, def_id, substs.clone(), bounds)\n+        &UnsizeVtable(TyTrait { ref principal, bounds }, _) => {\n+            mk_trait(cx, (*principal).clone(), bounds)\n         }\n     }\n }\n@@ -3808,7 +3812,7 @@ pub fn ty_sort_string(cx: &ctxt, t: t) -> String {\n         ty_bare_fn(_) => \"extern fn\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n-            format!(\"trait {}\", item_path_str(cx, inner.def_id))\n+            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id))\n         }\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n@@ -4230,11 +4234,14 @@ pub fn try_add_builtin_trait(\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n     match get(ty).sty {\n-        ty_trait(box TyTrait { def_id: id, .. }) |\n+        ty_trait(ref tt) =>\n+            Some(tt.principal.def_id),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_unboxed_closure(id, _, _) => Some(id),\n-        _ => None\n+        ty_unboxed_closure(id, _, _) =>\n+            Some(id),\n+        _ =>\n+            None\n     }\n }\n \n@@ -5213,9 +5220,9 @@ pub fn hash_crate_independent(tcx: &ctxt, t: t, svh: &Svh) -> u64 {\n                     }\n                 }\n             }\n-            ty_trait(box TyTrait { def_id: d, bounds, .. }) => {\n+            ty_trait(box TyTrait { ref principal, bounds }) => {\n                 byte!(17);\n-                did(&mut state, d);\n+                did(&mut state, principal.def_id);\n                 hash!(bounds);\n             }\n             ty_struct(d, _) => {\n@@ -5504,12 +5511,13 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                                     typ: t) {\n     walk_ty(typ, |typ| {\n         match get(typ).sty {\n-            ty_rptr(region, _) => accumulator.push(region),\n+            ty_rptr(region, _) => {\n+                accumulator.push(region)\n+            }\n+            ty_trait(ref t) => {\n+                accumulator.push_all(t.principal.substs.regions().as_slice());\n+            }\n             ty_enum(_, ref substs) |\n-            ty_trait(box TyTrait {\n-                ref substs,\n-                ..\n-            }) |\n             ty_struct(_, ref substs) => {\n                 accum_substs(accumulator, substs);\n             }\n@@ -5538,7 +5546,8 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_param(_) |\n             ty_infer(_) |\n             ty_open(_) |\n-            ty_err => {}\n+            ty_err => {\n+            }\n         }\n     });\n "}, {"sha": "031c7b2aed6d34c67e69e1b42b4d008b97975f1c", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -373,12 +373,11 @@ impl TypeFoldable for ty::UnsizeKind {\n         match *self {\n             ty::UnsizeLength(len) => ty::UnsizeLength(len),\n             ty::UnsizeStruct(box ref k, n) => ty::UnsizeStruct(box k.fold_with(folder), n),\n-            ty::UnsizeVtable(ty::TyTrait{bounds, def_id, ref substs}, self_ty) => {\n+            ty::UnsizeVtable(ty::TyTrait{ref principal, bounds}, self_ty) => {\n                 ty::UnsizeVtable(\n                     ty::TyTrait {\n+                        principal: principal.fold_with(folder),\n                         bounds: bounds.fold_with(folder),\n-                        def_id: def_id,\n-                        substs: substs.fold_with(folder)\n                     },\n                     self_ty.fold_with(folder))\n             }\n@@ -531,15 +530,10 @@ pub fn super_fold_sty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         ty::ty_enum(tid, ref substs) => {\n             ty::ty_enum(tid, substs.fold_with(this))\n         }\n-        ty::ty_trait(box ty::TyTrait {\n-                def_id,\n-                ref substs,\n-                bounds\n-            }) => {\n+        ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n             ty::ty_trait(box ty::TyTrait {\n-                def_id: def_id,\n-                substs: substs.fold_with(this),\n-                bounds: this.fold_existential_bounds(bounds),\n+                principal: (*principal).fold_with(this),\n+                bounds: bounds.fold_with(this),\n             })\n         }\n         ty::ty_tup(ref ts) => {"}, {"sha": "e27ff636a2a6f3779a0526a0b294c09a3418d6c7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 66, "deletions": 62, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -51,8 +51,6 @@\n \n use middle::const_eval;\n use middle::def;\n-use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem};\n-use middle::lang_items::{FnOnceTraitLangItem};\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n@@ -398,18 +396,58 @@ fn ast_path_substs<'tcx,AC,RS>(\n     }\n }\n \n+pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n+                                         rscope: &RS,\n+                                         ast_trait_ref: &ast::TraitRef,\n+                                         self_ty: Option<ty::t>,\n+                                         associated_type: Option<ty::t>)\n+                                         -> Rc<ty::TraitRef>\n+                                         where AC: AstConv<'tcx>,\n+                                               RS: RegionScope\n+{\n+    /*!\n+     * Instantiates the path for the given trait reference, assuming that\n+     * it's bound to a valid trait type. Returns the def_id for the defining\n+     * trait. Fails if the type is a type other than a trait type.\n+     */\n+\n+    match lookup_def_tcx(this.tcx(),\n+                         ast_trait_ref.path.span,\n+                         ast_trait_ref.ref_id) {\n+        def::DefTrait(trait_did) => {\n+            let trait_ref =\n+                Rc::new(ast_path_to_trait_ref(this,\n+                                              rscope,\n+                                              trait_did,\n+                                              self_ty,\n+                                              associated_type,\n+                                              &ast_trait_ref.path,\n+                                              ast_trait_ref.ref_id));\n+\n+            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n+                                                      trait_ref.clone());\n+            trait_ref\n+        }\n+        _ => {\n+            this.tcx().sess.span_fatal(\n+                ast_trait_ref.path.span,\n+                format!(\"`{}` is not a trait\", ast_trait_ref.path.user_string(this.tcx()))[]);\n+        }\n+    }\n+}\n+\n pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          trait_def_id: ast::DefId,\n                                          self_ty: Option<ty::t>,\n                                          associated_type: Option<ty::t>,\n                                          path: &ast::Path,\n                                          binder_id: ast::NodeId)\n-                                         -> Rc<ty::TraitRef>\n+                                         -> ty::TraitRef\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope {\n     let trait_def = this.get_trait_def(trait_def_id);\n-    Rc::new(ty::TraitRef {\n+    ty::TraitRef {\n         def_id: trait_def_id,\n         substs: ast_path_substs(this,\n                                 rscope,\n@@ -419,7 +457,7 @@ pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                 associated_type,\n                                 path,\n                                 binder_id)\n-    })\n+    }\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n@@ -620,41 +658,6 @@ enum PointerTy {\n     Uniq\n }\n \n-pub fn trait_ref_for_unboxed_function<'tcx, AC: AstConv<'tcx>,\n-                                      RS:RegionScope>(\n-                                      this: &AC,\n-                                      rscope: &RS,\n-                                      kind: ast::UnboxedClosureKind,\n-                                      decl: &ast::FnDecl,\n-                                      self_ty: Option<ty::t>)\n-                                      -> ty::TraitRef {\n-    let lang_item = match kind {\n-        ast::FnUnboxedClosureKind => FnTraitLangItem,\n-        ast::FnMutUnboxedClosureKind => FnMutTraitLangItem,\n-        ast::FnOnceUnboxedClosureKind => FnOnceTraitLangItem,\n-    };\n-    let trait_did = this.tcx().lang_items.require(lang_item).unwrap();\n-    let input_types = decl.inputs\n-                          .iter()\n-                          .map(|input| {\n-                            ast_ty_to_ty(this, rscope, &*input.ty)\n-                          }).collect::<Vec<_>>();\n-    let input_tuple = ty::mk_tup_or_nil(this.tcx(), input_types);\n-    let output_type = ast_ty_to_ty(this, rscope, &*decl.output);\n-    let mut substs = Substs::new_type(vec!(input_tuple, output_type),\n-                                      Vec::new());\n-\n-    match self_ty {\n-        Some(s) => substs.types.push(SelfSpace, s),\n-        None => ()\n-    }\n-\n-    ty::TraitRef {\n-        def_id: trait_did,\n-        substs: substs,\n-    }\n-}\n-\n // Handle `~`, `Box`, and `&` being able to mean strs and vecs.\n // If a_seq_ty is a str or a vec, make it a str/vec.\n // Also handle first-class trait types.\n@@ -702,26 +705,17 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        None,\n                                                        path,\n                                                        id);\n-                    let bounds = match *opt_bounds {\n-                        None => {\n-                            conv_existential_bounds(this,\n-                                                    rscope,\n-                                                    path.span,\n-                                                    [result.clone()].as_slice(),\n-                                                    [].as_slice())\n-                        }\n-                        Some(ref bounds) => {\n-                            conv_existential_bounds(this,\n-                                                    rscope,\n-                                                    path.span,\n-                                                    [result.clone()].as_slice(),\n-                                                    bounds.as_slice())\n-                        }\n-                    };\n+                    let empty_vec = [];\n+                    let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n+                                                     Some(ref bounds) => bounds.as_slice() };\n+                    let existential_bounds = conv_existential_bounds(this,\n+                                                                     rscope,\n+                                                                     path.span,\n+                                                                     &[Rc::new(result.clone())],\n+                                                                     bounds);\n                     let tr = ty::mk_trait(tcx,\n-                                          result.def_id,\n-                                          result.substs.clone(),\n-                                          bounds);\n+                                          result,\n+                                          existential_bounds);\n                     return match ptr_ty {\n                         Uniq => {\n                             return ty::mk_uniq(tcx, tr);\n@@ -907,6 +901,16 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n                 ty::mk_closure(tcx, fn_decl)\n             }\n+            ast::TyPolyTraitRef(ref data) => {\n+                // FIXME(#18639) this is just a placeholder for code to come\n+                let principal = instantiate_trait_ref(this, rscope, &data.trait_ref, None, None);\n+                let bounds = conv_existential_bounds(this,\n+                                                     rscope,\n+                                                     ast_ty.span,\n+                                                     &[principal.clone()],\n+                                                     &[]);\n+                ty::mk_trait(tcx, (*principal).clone(), bounds)\n+            }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n@@ -943,11 +947,10 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                         let bounds = conv_existential_bounds(this,\n                                                              rscope,\n                                                              ast_ty.span,\n-                                                             &[result.clone()],\n+                                                             &[Rc::new(result.clone())],\n                                                              ast_bounds);\n                         ty::mk_trait(tcx,\n-                                     result.def_id,\n-                                     result.substs.clone(),\n+                                     result,\n                                      bounds)\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1546,6 +1549,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n+                let b = &b.trait_ref; // FIXME\n                 match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n                     def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {"}, {"sha": "6280fce035a6cdf50dcf9b449ed0243db7e6003b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -632,9 +632,9 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, NoPreference, |self_ty, _| {\n             match get(self_ty).sty {\n-                ty_trait(box TyTrait { def_id, ref substs, bounds, .. }) => {\n-                    self.push_inherent_candidates_from_object(self_ty, def_id, substs, bounds);\n-                    self.push_inherent_impl_candidates_for_type(def_id);\n+                ty_trait(box TyTrait { ref principal, bounds, .. }) => {\n+                    self.push_inherent_candidates_from_object(self_ty, &*principal, bounds);\n+                    self.push_inherent_impl_candidates_for_type(principal.def_id);\n                 }\n                 ty_enum(did, _) |\n                 ty_struct(did, _) |\n@@ -744,24 +744,23 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n     fn push_inherent_candidates_from_object(&mut self,\n                                             self_ty: ty::t,\n-                                            did: DefId,\n-                                            substs: &subst::Substs,\n+                                            principal: &ty::TraitRef,\n                                             _bounds: ty::ExistentialBounds) {\n         debug!(\"push_inherent_candidates_from_object(self_ty={})\",\n                self_ty.repr(self.tcx()));\n \n         let tcx = self.tcx();\n \n-        // It is illegal to invoke a method on a trait instance that refers to\n-        // the `Self` type.  Here, we use a substitution that replaces `Self`\n-        // with the object type itself. Hence, a `&self` method will wind up\n-        // with an argument type like `&Trait`.\n-        let rcvr_substs = substs.with_self_ty(self_ty);\n-\n-        let trait_ref = Rc::new(TraitRef {\n-            def_id: did,\n-            substs: rcvr_substs.clone()\n-        });\n+        // It is illegal to invoke a method on a trait instance that\n+        // refers to the `Self` type. An error will be reported by\n+        // `enforce_object_limitations()` if the method refers to the\n+        // `Self` type anywhere other than the receiver. Here, we use\n+        // a substitution that replaces `Self` with the object type\n+        // itself. Hence, a `&self` method will wind up with an\n+        // argument type like `&Trait`.\n+        let rcvr_substs = principal.substs.with_self_ty(self_ty);\n+        let trait_ref = Rc::new(TraitRef { def_id: principal.def_id,\n+                                           substs: rcvr_substs.clone() });\n \n         self.push_inherent_candidates_from_bounds_inner(\n             &[trait_ref.clone()],\n@@ -796,7 +795,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     method_ty: m,\n                     origin: MethodTraitObject(MethodObject {\n                         trait_ref: new_trait_ref,\n-                        object_trait_id: did,\n+                        object_trait_id: principal.def_id,\n                         method_num: method_num,\n                         real_index: vtable_index\n                     })\n@@ -1151,17 +1150,19 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n     fn auto_slice_trait(&self, ty: ty::t, autoderefs: uint) -> Option<MethodResult> {\n         debug!(\"auto_slice_trait\");\n         match ty::get(ty).sty {\n-            ty_trait(box ty::TyTrait {\n-                    def_id: trt_did,\n-                    substs: ref trt_substs,\n-                    bounds: b,\n-                    .. }) => {\n+            ty_trait(box ty::TyTrait { ref principal,\n+                                       bounds: b,\n+                                       .. }) => {\n+                let trt_did = principal.def_id;\n+                let trt_substs = &principal.substs;\n                 let tcx = self.tcx();\n                 self.search_for_some_kind_of_autorefd_method(\n                     |r, m| AutoPtr(r, m, None),\n                     autoderefs, [MutImmutable, MutMutable],\n                     |m, r| {\n-                        let tr = ty::mk_trait(tcx, trt_did, trt_substs.clone(), b);\n+                        let principal = ty::TraitRef::new(trt_did,\n+                                                          trt_substs.clone());\n+                        let tr = ty::mk_trait(tcx, principal, b);\n                         ty::mk_rptr(tcx, r, ty::mt{ ty: tr, mutbl: m })\n                     })\n             }"}, {"sha": "498594716e7ab795339db49c5caf36b39187f721", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -140,11 +140,11 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n     // `call_once` which is the method which takes self by value. What could go\n     // wrong?\n     match tcx.lang_items.fn_once_trait() {\n-        Some(def_id) if def_id == object_trait.def_id => return,\n+        Some(def_id) if def_id == object_trait.principal.def_id => return,\n         _ => {}\n     }\n \n-    let trait_items = ty::trait_items(tcx, object_trait.def_id);\n+    let trait_items = ty::trait_items(tcx, object_trait.principal.def_id);\n \n     let mut errors = Vec::new();\n     for item in trait_items.iter() {\n@@ -158,7 +158,7 @@ pub fn check_object_safety(tcx: &ty::ctxt, object_trait: &ty::TyTrait, span: Spa\n \n     let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n     if errors.peek().is_some() {\n-        let trait_name = ty::item_path_str(tcx, object_trait.def_id);\n+        let trait_name = ty::item_path_str(tcx, object_trait.principal.def_id);\n         span_err!(tcx.sess, span, E0038,\n             \"cannot convert to a trait object because trait `{}` is not object-safe\",\n             trait_name);\n@@ -241,8 +241,7 @@ pub fn register_object_cast_obligations(fcx: &FnCtxt,\n     // needs some refactoring so there is a more convenient type to pass around.\n     let object_trait_ty =\n         ty::mk_trait(fcx.tcx(),\n-                     object_trait.def_id,\n-                     object_trait.substs.clone(),\n+                     object_trait.principal.clone(),\n                      object_trait.bounds);\n \n     debug!(\"register_object_cast_obligations: referent_ty={} object_trait_ty={}\",\n@@ -252,13 +251,13 @@ pub fn register_object_cast_obligations(fcx: &FnCtxt,\n     // Take the type parameters from the object type, but set\n     // the Self type (which is unknown, for the object type)\n     // to be the type we are casting from.\n-    let mut object_substs = object_trait.substs.clone();\n+    let mut object_substs = object_trait.principal.substs.clone();\n     assert!(object_substs.self_ty().is_none());\n     object_substs.types.push(SelfSpace, referent_ty);\n \n     // Create the obligation for casting from T to Trait.\n     let object_trait_ref =\n-        Rc::new(ty::TraitRef { def_id: object_trait.def_id,\n+        Rc::new(ty::TraitRef { def_id: object_trait.principal.def_id,\n                                substs: object_substs });\n     let object_obligation =\n         Obligation::new("}, {"sha": "898d987ace7cb0367422f8ba7a0e2ac3ee0fb062", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -112,17 +112,17 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                 ty_rptr(_, ty::mt {ty, ..}) |\n                 ty_uniq(ty) => {\n                     match ty::get(ty).sty {\n-                        ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                            Some(def_id)\n+                        ty_trait(box ty::TyTrait { ref principal, .. }) => {\n+                            Some(principal.def_id)\n                         }\n                         _ => {\n                             panic!(\"get_base_type() returned a type that wasn't an \\\n                                    enum, struct, or trait\");\n                         }\n                     }\n                 }\n-                ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                    Some(def_id)\n+                ty_trait(box ty::TyTrait { ref principal, .. }) => {\n+                    Some(principal.def_id)\n                 }\n                 _ => {\n                     panic!(\"get_base_type() returned a type that wasn't an \\"}, {"sha": "ba362fb878c81b8d85c2c903ec2d70635ae05e99", "filename": "src/librustc/middle/typeck/coherence/orphan.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Forphan.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -18,6 +18,7 @@ use middle::ty;\n use syntax::ast::{Item, ItemImpl};\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::codemap::Span;\n use syntax::visit;\n use util::ppaux::Repr;\n \n@@ -30,6 +31,17 @@ struct OrphanChecker<'cx, 'tcx:'cx> {\n     tcx: &'cx ty::ctxt<'tcx>\n }\n \n+impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n+    fn check_def_id(&self, span: Span, def_id: ast::DefId) {\n+        if def_id.krate != ast::LOCAL_CRATE {\n+            span_err!(self.tcx.sess, span, E0116,\n+                      \"cannot associate methods with a type outside the \\\n+                       crate the type is defined in; define and implement \\\n+                       a trait or new type instead\");\n+        }\n+    }\n+}\n+\n impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v ast::Item) {\n         let def_id = ast_util::local_def(item.id);\n@@ -41,14 +53,11 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                 let self_ty = ty::lookup_item_type(self.tcx, def_id).ty;\n                 match ty::get(self_ty).sty {\n                     ty::ty_enum(def_id, _) |\n-                    ty::ty_struct(def_id, _) |\n-                    ty::ty_trait(box ty::TyTrait{ def_id, ..}) => {\n-                        if def_id.krate != ast::LOCAL_CRATE {\n-                            span_err!(self.tcx.sess, item.span, E0116,\n-                                      \"cannot associate methods with a type outside the \\\n-                                      crate the type is defined in; define and implement \\\n-                                      a trait or new type instead\");\n-                        }\n+                    ty::ty_struct(def_id, _) => {\n+                        self.check_def_id(item.span, def_id);\n+                    }\n+                    ty::ty_trait(box ty::TyTrait{ ref principal, ..}) => {\n+                        self.check_def_id(item.span, principal.def_id);\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,"}, {"sha": "c4e50c25e3ef4f2c1e62383394cd8a7563ea9028", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 34, "deletions": 65, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -61,7 +61,6 @@ use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::codemap::Span;\n use syntax::parse::token::{special_idents};\n use syntax::parse::token;\n-use syntax::print::pprust::{path_to_string};\n use syntax::ptr::P;\n use syntax::visit;\n \n@@ -633,24 +632,33 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n+    let mut warn = false;\n+\n     for ty_param in generics.ty_params.iter() {\n-        let bounds = ty_param.bounds.iter();\n-        let mut bounds = bounds.chain(ty_param.unbound.iter());\n-        for bound in bounds {\n+        for bound in ty_param.bounds.iter() {\n             match *bound {\n                 ast::TraitTyParamBound(..) => {\n-                    // According to accepted RFC #XXX, we should\n-                    // eventually accept these, but it will not be\n-                    // part of this PR. Still, convert to warning to\n-                    // make bootstrapping easier.\n-                    span_warn!(ccx.tcx.sess, span, E0122,\n-                               \"trait bounds are not (yet) enforced \\\n-                                in {} definitions\",\n-                               thing);\n+                    warn = true;\n                 }\n                 ast::RegionTyParamBound(..) => { }\n             }\n         }\n+\n+        match ty_param.unbound {\n+            Some(_) => { warn = true; }\n+            None => { }\n+        }\n+    }\n+\n+    if warn {\n+        // According to accepted RFC #XXX, we should\n+        // eventually accept these, but it will not be\n+        // part of this PR. Still, convert to warning to\n+        // make bootstrapping easier.\n+        span_warn!(ccx.tcx.sess, span, E0122,\n+                   \"trait bounds are not (yet) enforced \\\n+                   in {} definitions\",\n+                   thing);\n     }\n }\n \n@@ -1147,7 +1155,8 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                instantiate_trait_ref(&icx, trait_ref, selfty, None);\n+                astconv::instantiate_trait_ref(&icx, &ExplicitRscope, trait_ref,\n+                                               Some(selfty), None);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1315,47 +1324,6 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n }\n \n-pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n-                                      ast_trait_ref: &ast::TraitRef,\n-                                      self_ty: ty::t,\n-                                      associated_type: Option<ty::t>)\n-                                      -> Rc<ty::TraitRef>\n-                                      where AC: AstConv<'tcx> {\n-    /*!\n-     * Instantiates the path for the given trait reference, assuming that\n-     * it's bound to a valid trait type. Returns the def_id for the defining\n-     * trait. Fails if the type is a type other than a trait type.\n-     */\n-\n-    // FIXME(#5121) -- distinguish early vs late lifetime params\n-    let rscope = ExplicitRscope;\n-\n-    match lookup_def_tcx(this.tcx(),\n-                         ast_trait_ref.path.span,\n-                         ast_trait_ref.ref_id) {\n-        def::DefTrait(trait_did) => {\n-            let trait_ref =\n-                astconv::ast_path_to_trait_ref(this,\n-                                               &rscope,\n-                                               trait_did,\n-                                               Some(self_ty),\n-                                               associated_type,\n-                                               &ast_trait_ref.path,\n-                                               ast_trait_ref.ref_id);\n-\n-            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                      trait_ref.clone());\n-            trait_ref\n-        }\n-        _ => {\n-            this.tcx().sess.span_fatal(\n-                ast_trait_ref.path.span,\n-                format!(\"`{}` is not a trait\",\n-                        path_to_string(&ast_trait_ref.path)).as_slice());\n-        }\n-    }\n-}\n-\n fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n@@ -1720,14 +1688,14 @@ fn ty_generics_for_fn_or_method<'tcx,AC>(\n \n // Add the Sized bound, unless the type parameter is marked as `Sized?`.\n fn add_unsized_bound<'tcx,AC>(this: &AC,\n-                              unbound: &Option<ast::TyParamBound>,\n+                              unbound: &Option<ast::TraitRef>,\n                               bounds: &mut ty::BuiltinBounds,\n                               desc: &str,\n                               span: Span)\n                               where AC: AstConv<'tcx> {\n     let kind_id = this.tcx().lang_items.require(SizedTraitLangItem);\n     match unbound {\n-        &Some(ast::TraitTyParamBound(ref tpb)) => {\n+        &Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             let trait_def_id = ty::trait_ref_to_def_id(this.tcx(), tpb);\n             match kind_id {\n@@ -1752,7 +1720,7 @@ fn add_unsized_bound<'tcx,AC>(this: &AC,\n             ty::try_add_builtin_trait(this.tcx(), kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n-        _ => {}\n+        &None => {}\n     }\n }\n \n@@ -1870,11 +1838,11 @@ fn ty_generics<'tcx,AC>(this: &AC,\n \n                 let trait_def_id =\n                     match lookup_def_tcx(this.tcx(),\n-                                         ast_trait_ref.path.span,\n-                                         ast_trait_ref.ref_id) {\n+                                         ast_trait_ref.trait_ref.path.span,\n+                                         ast_trait_ref.trait_ref.ref_id) {\n                         def::DefTrait(trait_def_id) => trait_def_id,\n                         _ => {\n-                            this.tcx().sess.span_bug(ast_trait_ref.path.span,\n+                            this.tcx().sess.span_bug(ast_trait_ref.trait_ref.path.span,\n                                                      \"not a trait?!\")\n                         }\n                     };\n@@ -1972,7 +1940,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                            name_of_bounded_thing: ast::Name,\n                            param_ty: ty::ParamTy,\n                            ast_bounds: &[ast::TyParamBound],\n-                           unbound: &Option<ast::TyParamBound>,\n+                           unbound: &Option<ast::TraitRef>,\n                            span: Span,\n                            where_clause: &ast::WhereClause)\n                            -> ty::ParamBounds\n@@ -2047,10 +2015,11 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|b| {\n-            instantiate_trait_ref(this,\n-                                  b,\n-                                  param_ty.to_ty(this.tcx()),\n-                                  Some(param_ty.to_ty(this.tcx())))\n+            astconv::instantiate_trait_ref(this,\n+                                           &ExplicitRscope,\n+                                           b,\n+                                           Some(param_ty.to_ty(this.tcx())),\n+                                           Some(param_ty.to_ty(this.tcx())))\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> ="}, {"sha": "718d70050a08e449e234000039f33c0bd6e74cd9", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -413,15 +413,14 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     let ty = ty::mk_vec(tcx, t_a, None);\n                     Some((ty, ty::UnsizeLength(len)))\n                 }\n-                (&ty::ty_trait(..), &ty::ty_trait(..)) => None,\n-                (_, &ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds })) => {\n-                    let ty = ty::mk_trait(tcx,\n-                                          def_id,\n-                                          substs.clone(),\n-                                          bounds);\n-                    Some((ty, ty::UnsizeVtable(ty::TyTrait { def_id: def_id,\n-                                                             bounds: bounds,\n-                                                             substs: substs.clone() },\n+                (&ty::ty_trait(..), &ty::ty_trait(..)) => {\n+                    None\n+                }\n+                (_, &ty::ty_trait(box ty::TyTrait { ref principal, bounds })) => {\n+                    // FIXME what is the purpose of `ty`?\n+                    let ty = ty::mk_trait(tcx, (*principal).clone(), bounds);\n+                    Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: (*principal).clone(),\n+                                                             bounds: bounds },\n                                                ty_a)))\n                 }\n                 (&ty::ty_struct(did_a, ref substs_a), &ty::ty_struct(did_b, ref substs_b))\n@@ -524,16 +523,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         match *sty_a {\n             ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty::get(ty).sty {\n-                ty::ty_trait(box ty::TyTrait {\n-                        def_id,\n-                        ref substs,\n-                        bounds,\n-                        ..\n-                    }) =>\n-                {\n+                ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n-\n-                    let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n+                    // FIXME what is purpose of this type `tr`?\n+                    let tr = ty::mk_trait(tcx, (*principal).clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,"}, {"sha": "83d90274fd323c183f16a4ed34c3874846bd6560", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -52,7 +52,6 @@ use middle::typeck::infer::type_variable::{RelationDir, EqTo,\n use middle::ty_fold::{TypeFoldable};\n use util::ppaux::Repr;\n \n-\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast;\n use syntax::abi;\n@@ -461,15 +460,11 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<t\n       }\n \n       (&ty::ty_trait(ref a_),\n-       &ty::ty_trait(ref b_))\n-      if a_.def_id == b_.def_id => {\n+       &ty::ty_trait(ref b_)) => {\n           debug!(\"Trying to match traits {} and {}\", a, b);\n-          let substs = try!(this.substs(a_.def_id, &a_.substs, &b_.substs));\n+          let principal = try!(this.trait_refs(&a_.principal, &b_.principal));\n           let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n-          Ok(ty::mk_trait(tcx,\n-                          a_.def_id,\n-                          substs.clone(),\n-                          bounds))\n+          Ok(ty::mk_trait(tcx, principal, bounds))\n       }\n \n       (&ty::ty_struct(a_id, ref a_substs), &ty::ty_struct(b_id, ref b_substs))"}, {"sha": "80b4948f6fbf26bbc0e48ce3ba6380b67ca1a0a7", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -1102,7 +1102,8 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                     // be passing down a map.\n                     ast::RegionTyParamBound(lt)\n                 }\n-                &ast::TraitTyParamBound(ref tr) => {\n+                &ast::TraitTyParamBound(ref poly_tr) => {\n+                    let tr = &poly_tr.trait_ref;\n                     let last_seg = tr.path.segments.last().unwrap();\n                     let mut insert = Vec::new();\n                     let lifetimes = last_seg.parameters.lifetimes();\n@@ -1119,10 +1120,12 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         region_names: region_names\n                     };\n                     let new_path = self.rebuild_path(rebuild_info, lifetime);\n-                    ast::TraitTyParamBound(ast::TraitRef {\n-                        path: new_path,\n-                        ref_id: tr.ref_id,\n-                        lifetimes: tr.lifetimes.clone(),\n+                    ast::TraitTyParamBound(ast::PolyTraitRef {\n+                        bound_lifetimes: poly_tr.bound_lifetimes.clone(),\n+                        trait_ref: ast::TraitRef {\n+                            path: new_path,\n+                            ref_id: tr.ref_id,\n+                        }\n                     })\n                 }\n             }"}, {"sha": "23000949115c3ea916db553e7fc1ee80cbf1792a", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -856,16 +856,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                       -> ty::TraitRef {\n         // make up a dummy type just to reuse/abuse the resolve machinery\n         let dummy0 = ty::mk_trait(self.tcx,\n-                                  trait_ref.def_id,\n-                                  trait_ref.substs.clone(),\n+                                  (*trait_ref).clone(),\n                                   ty::region_existential_bound(ty::ReStatic));\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n-            ty::ty_trait(box ty::TyTrait { ref def_id, ref substs, .. }) => {\n-                ty::TraitRef {\n-                    def_id: *def_id,\n-                    substs: (*substs).clone(),\n-                }\n+            ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n+                (*principal).clone()\n             }\n             _ => {\n                 self.tcx.sess.bug("}, {"sha": "b6d8c85fa0b7ca0687a97c8537d168f343ac686a", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -778,14 +778,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     variance);\n             }\n \n-            ty::ty_trait(box ty::TyTrait { def_id, ref substs, bounds }) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), def_id);\n+            ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id);\n                 let generics = &trait_def.generics;\n \n                 // Traits DO have a Self type parameter, but it is\n                 // erased from object types.\n                 assert!(!generics.types.is_empty_in(subst::SelfSpace) &&\n-                        substs.types.is_empty_in(subst::SelfSpace));\n+                        principal.substs.types.is_empty_in(subst::SelfSpace));\n \n                 // Traits never declare region parameters in the self\n                 // space.\n@@ -801,10 +801,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_region(bounds.region_bound, contra);\n \n                 self.add_constraints_from_substs(\n-                    def_id,\n+                    principal.def_id,\n                     generics.types.get_slice(subst::TypeSpace),\n                     generics.regions.get_slice(subst::TypeSpace),\n-                    substs,\n+                    &principal.substs,\n                     variance);\n             }\n "}, {"sha": "60a7436dbaa19e63d57c14cb3c2f6ecb3f7398c1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -435,12 +435,12 @@ pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n             parameterized(cx, base.as_slice(), substs, &generics)\n         }\n         ty_trait(box ty::TyTrait {\n-            def_id: did, ref substs, ref bounds\n+            ref principal, ref bounds\n         }) => {\n-            let base = ty::item_path_str(cx, did);\n-            let trait_def = ty::lookup_trait_def(cx, did);\n+            let base = ty::item_path_str(cx, principal.def_id);\n+            let trait_def = ty::lookup_trait_def(cx, principal.def_id);\n             let ty = parameterized(cx, base.as_slice(),\n-                                   substs, &trait_def.generics);\n+                                   &principal.substs, &trait_def.generics);\n             let bound_str = bounds.user_string(cx);\n             let bound_sep = if bound_str.is_empty() { \"\" } else { \"+\" };\n             format!(\"{}{}{}\","}, {"sha": "38e0c4fe040bdd042422e2fe72c162892217f59f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -963,6 +963,12 @@ impl Clean<Type> for ast::TraitRef {\n     }\n }\n \n+impl Clean<Type> for ast::PolyTraitRef {\n+    fn clean(&self, cx: &DocContext) -> Type {\n+        self.trait_ref.clean(cx)\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum TraitMethod {\n     RequiredMethod(Item),\n@@ -1306,7 +1312,8 @@ impl Clean<Type> for ty::t {\n             }\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n-            ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n+            ty::ty_trait(box ty::TyTrait { principal: ty::TraitRef { def_id: did, ref substs },\n+                                           .. }) => {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<String> = fqn.into_iter().map(|i| {\n                     i.to_string()"}, {"sha": "145978bb73f4be6c7458445c6bf604f68039a57f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -307,7 +307,7 @@ pub const DUMMY_NODE_ID: NodeId = -1;\n /// detects Copy, Send and Sync.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum TyParamBound {\n-    TraitTyParamBound(TraitRef),\n+    TraitTyParamBound(PolyTraitRef),\n     RegionTyParamBound(Lifetime)\n }\n \n@@ -318,7 +318,7 @@ pub struct TyParam {\n     pub ident: Ident,\n     pub id: NodeId,\n     pub bounds: TyParamBounds,\n-    pub unbound: Option<TyParamBound>,\n+    pub unbound: Option<TraitRef>,\n     pub default: Option<P<Ty>>,\n     pub span: Span\n }\n@@ -1097,6 +1097,7 @@ pub enum Ty_ {\n     TyBareFn(P<BareFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n+    TyPolyTraitRef(P<PolyTraitRef>), // a type like `for<'a> Foo<&'a Bar>`\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n     TyQPath(P<QPath>),\n     /// No-op; kept solely so that we can pretty-print faithfully\n@@ -1350,7 +1351,6 @@ pub struct Attribute_ {\n     pub is_sugared_doc: bool,\n }\n \n-\n /// TraitRef's appear in impls.\n /// resolve maps each TraitRef's ref_id to its defining trait; that's all\n /// that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n@@ -1360,7 +1360,15 @@ pub struct Attribute_ {\n pub struct TraitRef {\n     pub path: Path,\n     pub ref_id: NodeId,\n-    pub lifetimes: Vec<LifetimeDef>,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct PolyTraitRef {\n+    /// The `'a` in `<'a> Foo<&'a T>`\n+    pub bound_lifetimes: Vec<LifetimeDef>,\n+\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    pub trait_ref: TraitRef\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n@@ -1448,8 +1456,8 @@ pub enum Item_ {\n     ItemStruct(P<StructDef>, Generics),\n     /// Represents a Trait Declaration\n     ItemTrait(Generics,\n-              Option<TyParamBound>, // (optional) default bound not required for Self.\n-                                    // Currently, only Sized makes sense here.\n+              Option<TraitRef>, // (optional) default bound not required for Self.\n+                                // Currently, only Sized makes sense here.\n               TyParamBounds,\n               Vec<TraitItem>),\n     ItemImpl(Generics,"}, {"sha": "d65be4c45e8f3a849c74cb5fcb412546d478d620", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -770,7 +770,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                 for b in bounds.iter() {\n                     match *b {\n                         TraitTyParamBound(ref t) => {\n-                            self.insert(t.ref_id, NodeItem(i));\n+                            self.insert(t.trait_ref.ref_id, NodeItem(i));\n                         }\n                         _ => {}\n                     }"}, {"sha": "862cbf3d7ca06f3506bf0f33602e8e3055f24048", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -68,10 +68,11 @@ pub trait AstBuilder {\n                span: Span,\n                id: ast::Ident,\n                bounds: OwnedSlice<ast::TyParamBound>,\n-               unbound: Option<ast::TyParamBound>,\n+               unbound: Option<ast::TraitRef>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam;\n \n     fn trait_ref(&self, path: ast::Path) -> ast::TraitRef;\n+    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef;\n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound;\n     fn lifetime(&self, span: Span, ident: ast::Name) -> ast::Lifetime;\n     fn lifetime_def(&self,\n@@ -417,7 +418,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                span: Span,\n                id: ast::Ident,\n                bounds: OwnedSlice<ast::TyParamBound>,\n-               unbound: Option<ast::TyParamBound>,\n+               unbound: Option<ast::TraitRef>,\n                default: Option<P<ast::Ty>>) -> ast::TyParam {\n         ast::TyParam {\n             ident: id,\n@@ -445,12 +446,18 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::TraitRef {\n             path: path,\n             ref_id: ast::DUMMY_NODE_ID,\n-            lifetimes: Vec::new(),\n+        }\n+    }\n+\n+    fn poly_trait_ref(&self, path: ast::Path) -> ast::PolyTraitRef {\n+        ast::PolyTraitRef {\n+            bound_lifetimes: Vec::new(),\n+            trait_ref: self.trait_ref(path)\n         }\n     }\n \n     fn typarambound(&self, path: ast::Path) -> ast::TyParamBound {\n-        ast::TraitTyParamBound(self.trait_ref(path))\n+        ast::TraitTyParamBound(self.poly_trait_ref(path))\n     }\n \n     fn lifetime(&self, span: Span, name: ast::Name) -> ast::Lifetime {"}, {"sha": "1ec1e3b1224c4d3d7cad2637d7445bb9adf8a160", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -194,7 +194,7 @@ impl<'a> Ty<'a> {\n \n \n fn mk_ty_param(cx: &ExtCtxt, span: Span, name: &str,\n-               bounds: &[Path], unbound: Option<ast::TyParamBound>,\n+               bounds: &[Path], unbound: Option<ast::TraitRef>,\n                self_ident: Ident, self_generics: &Generics) -> ast::TyParam {\n     let bounds =\n         bounds.iter().map(|b| {\n@@ -220,7 +220,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n #[deriving(Clone)]\n pub struct LifetimeBounds<'a> {\n     pub lifetimes: Vec<(&'a str, Vec<&'a str>)>,\n-    pub bounds: Vec<(&'a str, Option<ast::TyParamBound>, Vec<Path<'a>>)>,\n+    pub bounds: Vec<(&'a str, Option<ast::TraitRef>, Vec<Path<'a>>)>,\n }\n \n impl<'a> LifetimeBounds<'a> {"}, {"sha": "c38fea9b3d58a2b9576ea5e8fcd249ed1b182eb8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -38,7 +38,6 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"globs\", Active),\n     (\"macro_rules\", Active),\n     (\"struct_variant\", Active),\n-    (\"once_fns\", Active),\n     (\"asm\", Active),\n     (\"managed_boxes\", Removed),\n     (\"non_ascii_idents\", Active),\n@@ -307,11 +306,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n \n     fn visit_ty(&mut self, t: &ast::Ty) {\n         match t.node {\n-            ast::TyClosure(ref closure) if closure.onceness == ast::Once => {\n-                self.gate_feature(\"once_fns\", t.span,\n-                                  \"once functions are \\\n-                                   experimental and likely to be removed\");\n-\n+            ast::TyClosure(ref closure) => {\n+                // this used to be blocked by a feature gate, but it should just\n+                // be plain impossible right now\n+                assert!(closure.onceness != ast::Once);\n             },\n             _ => {}\n         }"}, {"sha": "d7c3ca8efc45702595ddc327ce53be86fa2b9dd6", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -227,6 +227,10 @@ pub trait Folder {\n         noop_fold_trait_ref(p, self)\n     }\n \n+    fn fold_poly_trait_ref(&mut self, p: PolyTraitRef) -> PolyTraitRef {\n+        noop_fold_poly_trait_ref(p, self)\n+    }\n+\n     fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n         noop_fold_struct_def(struct_def, self)\n     }\n@@ -442,7 +446,10 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n-            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr))\n+            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr)),\n+            TyPolyTraitRef(poly_trait_ref) => {\n+                TyPolyTraitRef(poly_trait_ref.map(|p| fld.fold_poly_trait_ref(p)))\n+            },\n         },\n         span: fld.new_span(span)\n     })\n@@ -711,7 +718,7 @@ pub fn noop_fold_ty_param_bound<T>(tpb: TyParamBound, fld: &mut T)\n                                    -> TyParamBound\n                                    where T: Folder {\n     match tpb {\n-        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n+        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_poly_trait_ref(ty)),\n         RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n     }\n }\n@@ -722,7 +729,7 @@ pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n         id: fld.new_id(id),\n         ident: ident,\n         bounds: fld.fold_bounds(bounds),\n-        unbound: unbound.map(|x| fld.fold_ty_param_bound(x)),\n+        unbound: unbound.map(|x| fld.fold_trait_ref(x)),\n         default: default.map(|x| fld.fold_ty(x)),\n         span: span\n     }\n@@ -842,13 +849,18 @@ pub fn noop_fold_trait_ref<T: Folder>(p: TraitRef, fld: &mut T) -> TraitRef {\n     let id = fld.new_id(p.ref_id);\n     let TraitRef {\n         path,\n-        lifetimes,\n-        ..\n+        ref_id: _,\n     } = p;\n     ast::TraitRef {\n         path: fld.fold_path(path),\n         ref_id: id,\n-        lifetimes: fld.fold_lifetime_defs(lifetimes),\n+    }\n+}\n+\n+pub fn noop_fold_poly_trait_ref<T: Folder>(p: PolyTraitRef, fld: &mut T) -> PolyTraitRef {\n+    ast::PolyTraitRef {\n+        bound_lifetimes: fld.fold_lifetime_defs(p.bound_lifetimes),\n+        trait_ref: fld.fold_trait_ref(p.trait_ref)\n     }\n }\n "}, {"sha": "6873c015fd51c43c657cc7d8743c0464e66baa37", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 174, "deletions": 136, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -42,6 +42,7 @@ use ast::{Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n+use ast::{PolyTraitRef};\n use ast::{QPath, RequiredMethod};\n use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n@@ -53,7 +54,7 @@ use ast::{TtDelimited, TtSequence, TtToken};\n use ast::{TupleVariantKind, Ty, Ty_, TyBot};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n+use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyUniq, TyVec, UnUniq};\n use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n@@ -968,30 +969,14 @@ impl<'a> Parser<'a> {\n     /// Is the current token one of the keywords that signals a bare function\n     /// type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n-        if self.token.is_keyword(keywords::Fn) {\n-            return true\n-        }\n-\n-        if self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Once) {\n-            return self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n-        }\n-\n-        false\n+        self.token.is_keyword(keywords::Fn) ||\n+            self.token.is_keyword(keywords::Unsafe) ||\n+            self.token.is_keyword(keywords::Extern)\n     }\n \n     /// Is the current token one of the keywords that signals a closure type?\n     pub fn token_is_closure_keyword(&mut self) -> bool {\n-        self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Once)\n-    }\n-\n-    /// Is the current token one of the keywords that signals an old-style\n-    /// closure type (with explicit sigil)?\n-    pub fn token_is_old_style_closure_keyword(&mut self) -> bool {\n-        self.token.is_keyword(keywords::Unsafe) ||\n-            self.token.is_keyword(keywords::Once) ||\n-            self.token.is_keyword(keywords::Fn)\n+        self.token.is_keyword(keywords::Unsafe)\n     }\n \n     pub fn get_lifetime(&mut self) -> ast::Ident {\n@@ -1001,8 +986,57 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn parse_for_in_type(&mut self) -> Ty_ {\n+        /*\n+        Parses whatever can come after a `for` keyword in a type.\n+        The `for` has already been consumed.\n+\n+        Deprecated:\n+\n+        - for <'lt> |S| -> T\n+        - for <'lt> proc(S) -> T\n+\n+        Eventually:\n+\n+        - for <'lt> [unsafe] [extern \"ABI\"] fn (S) -> T\n+        - for <'lt> path::foo(a, b)\n+\n+        */\n+\n+        // parse <'lt>\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs();\n+\n+        // examine next token to decide to do\n+        if self.eat_keyword(keywords::Proc) {\n+            self.parse_proc_type(lifetime_defs)\n+        } else if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n+            self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n+        } else if self.token == token::ModSep ||\n+                  self.token.is_ident() ||\n+                  self.token.is_path() {\n+            let trait_ref = self.parse_trait_ref();\n+            TyPolyTraitRef(P(PolyTraitRef { bound_lifetimes: lifetime_defs,\n+                                            trait_ref: trait_ref }))\n+        } else {\n+            self.parse_ty_closure(lifetime_defs)\n+        }\n+    }\n+\n+    pub fn parse_ty_path(&mut self, plus_allowed: bool) -> Ty_ {\n+        let mode = if plus_allowed {\n+            LifetimeAndTypesAndBounds\n+        } else {\n+            LifetimeAndTypesWithoutColons\n+        };\n+        let PathAndBounds {\n+            path,\n+            bounds\n+        } = self.parse_path(mode);\n+        TyPath(path, bounds, ast::DUMMY_NODE_ID)\n+    }\n+\n     /// parse a TyBareFn type:\n-    pub fn parse_ty_bare_fn(&mut self) -> Ty_ {\n+    pub fn parse_ty_bare_fn(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n         /*\n \n         [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n@@ -1023,18 +1057,26 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(keywords::Fn);\n-        let (decl, lifetimes) = self.parse_ty_fn_decl(true);\n+        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n+        let (inputs, variadic) = self.parse_fn_args(false, true);\n+        let (ret_style, ret_ty) = self.parse_ret_ty();\n+        let decl = P(FnDecl {\n+            inputs: inputs,\n+            output: ret_ty,\n+            cf: ret_style,\n+            variadic: variadic\n+        });\n         TyBareFn(P(BareFnTy {\n             abi: abi,\n             fn_style: fn_style,\n-            lifetimes: lifetimes,\n+            lifetimes: lifetime_defs,\n             decl: decl\n         }))\n     }\n \n     /// Parses a procedure type (`proc`). The initial `proc` keyword must\n     /// already have been parsed.\n-    pub fn parse_proc_type(&mut self) -> Ty_ {\n+    pub fn parse_proc_type(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n         /*\n \n         proc <'lt> (S) [:Bounds] -> T\n@@ -1043,19 +1085,12 @@ impl<'a> Parser<'a> {\n          |     |    |      |      Return type\n          |     |    |    Bounds\n          |     |  Argument types\n-         |   Lifetimes\n+         |   Legacy lifetimes\n         the `proc` keyword\n \n         */\n \n-        let lifetime_defs = if self.eat(&token::Lt) {\n-            let lifetime_defs = self.parse_lifetime_defs();\n-            self.expect_gt();\n-            lifetime_defs\n-        } else {\n-            Vec::new()\n-        };\n-\n+        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, false);\n         let bounds = self.parse_colon_then_ty_param_bounds();\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n@@ -1100,33 +1135,49 @@ impl<'a> Parser<'a> {\n         return None\n     }\n \n+    pub fn parse_ty_bare_fn_or_ty_closure(&mut self, lifetime_defs: Vec<LifetimeDef>) -> Ty_ {\n+        // Both bare fns and closures can begin with stuff like unsafe\n+        // and extern. So we just scan ahead a few tokens to see if we see\n+        // a `fn`.\n+        //\n+        // Closure:  [unsafe] <'lt> |S| [:Bounds] -> T\n+        // Fn:       [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n+\n+        if self.token.is_keyword(keywords::Fn) {\n+            self.parse_ty_bare_fn(lifetime_defs)\n+        } else if self.token.is_keyword(keywords::Extern) {\n+            self.parse_ty_bare_fn(lifetime_defs)\n+        } else if self.token.is_keyword(keywords::Unsafe) {\n+            if self.look_ahead(1, |t| t.is_keyword(keywords::Fn) ||\n+                                      t.is_keyword(keywords::Extern)) {\n+                self.parse_ty_bare_fn(lifetime_defs)\n+            } else {\n+                self.parse_ty_closure(lifetime_defs)\n+            }\n+        } else {\n+            self.parse_ty_closure(lifetime_defs)\n+        }\n+    }\n+\n     /// Parse a TyClosure type\n-    pub fn parse_ty_closure(&mut self) -> Ty_ {\n+    pub fn parse_ty_closure(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n         /*\n \n-        [unsafe] [once] <'lt> |S| [:Bounds] -> T\n-        ^~~~~~~^ ^~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n-          |        |      |    |      |        |\n-          |        |      |    |      |      Return type\n-          |        |      |    |  Closure bounds\n-          |        |      |  Argument types\n-          |        |    Lifetime defs\n-          |     Once-ness (a.k.a., affine)\n+        [unsafe] <'lt> |S| [:Bounds] -> T\n+        ^~~~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n+          |        |       |      |        |\n+          |        |       |      |      Return type\n+          |        |       |  Closure bounds\n+          |        |     Argument types\n+          |      Deprecated lifetime defs\n+          |\n         Function Style\n \n         */\n \n         let fn_style = self.parse_unsafety();\n-        let onceness = if self.eat_keyword(keywords::Once) {Once} else {Many};\n \n-        let lifetime_defs = if self.eat(&token::Lt) {\n-            let lifetime_defs = self.parse_lifetime_defs();\n-            self.expect_gt();\n-\n-            lifetime_defs\n-        } else {\n-            Vec::new()\n-        };\n+        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n \n         let inputs = if self.eat(&token::OrOr) {\n             Vec::new()\n@@ -1152,7 +1203,7 @@ impl<'a> Parser<'a> {\n \n         TyClosure(P(ClosureTy {\n             fn_style: fn_style,\n-            onceness: onceness,\n+            onceness: Many,\n             bounds: bounds,\n             decl: decl,\n             lifetimes: lifetime_defs,\n@@ -1167,36 +1218,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a function type (following the 'fn')\n-    pub fn parse_ty_fn_decl(&mut self, allow_variadic: bool)\n-                            -> (P<FnDecl>, Vec<ast::LifetimeDef>) {\n-        /*\n-\n-        (fn) <'lt> (S) -> T\n-             ^~~~^ ^~^    ^\n-               |    |     |\n-               |    |   Return type\n-               |  Argument types\n-           Lifetime_defs\n-\n-        */\n-        let lifetime_defs = if self.eat(&token::Lt) {\n-            let lifetime_defs = self.parse_lifetime_defs();\n-            self.expect_gt();\n-            lifetime_defs\n+    /// Parses `[ 'for' '<' lifetime_defs '>' ]'\n+    fn parse_legacy_lifetime_defs(&mut self,\n+                                  lifetime_defs: Vec<ast::LifetimeDef>)\n+                                  -> Vec<ast::LifetimeDef>\n+    {\n+        if self.eat(&token::Lt) {\n+            if lifetime_defs.is_empty() {\n+                self.warn(\"deprecated syntax, use `for` keyword now\");\n+                let lifetime_defs = self.parse_lifetime_defs();\n+                self.expect_gt();\n+                lifetime_defs\n+            } else {\n+                self.fatal(\"cannot use new `for` keyword and older syntax together\");\n+            }\n         } else {\n-            Vec::new()\n-        };\n-\n-        let (inputs, variadic) = self.parse_fn_args(false, allow_variadic);\n-        let (ret_style, ret_ty) = self.parse_ret_ty();\n-        let decl = P(FnDecl {\n-            inputs: inputs,\n-            output: ret_ty,\n-            cf: ret_style,\n-            variadic: variadic\n-        });\n-        (decl, lifetime_defs)\n+            lifetime_defs\n+        }\n     }\n \n     /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n@@ -1433,25 +1471,24 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Bracket));\n             t\n         } else if self.token == token::BinOp(token::And) ||\n-                self.token == token::AndAnd {\n+                  self.token == token::AndAnd {\n             // BORROWED POINTER\n             self.expect_and();\n             self.parse_borrowed_pointee()\n-        } else if self.token.is_keyword(keywords::Extern) ||\n-                  self.token.is_keyword(keywords::Unsafe) ||\n-                self.token_is_bare_fn_keyword() {\n-            // BARE FUNCTION\n-            self.parse_ty_bare_fn()\n-        } else if self.token_is_closure_keyword() ||\n-                self.token == token::BinOp(token::Or) ||\n-                self.token == token::OrOr ||\n-                (self.token == token::Lt &&\n-                 self.look_ahead(1, |t| {\n-                     *t == token::Gt || t.is_lifetime()\n-                 })) {\n+        } else if self.token.is_keyword(keywords::For) {\n+            self.parse_for_in_type()\n+        } else if self.token_is_bare_fn_keyword() ||\n+                  self.token_is_closure_keyword() {\n+            // BARE FUNCTION OR CLOSURE\n+            self.parse_ty_bare_fn_or_ty_closure(Vec::new())\n+        } else if self.token == token::BinOp(token::Or) ||\n+                  self.token == token::OrOr ||\n+                  (self.token == token::Lt &&\n+                   self.look_ahead(1, |t| {\n+                       *t == token::Gt || t.is_lifetime()\n+                   })) {\n             // CLOSURE\n-\n-            self.parse_ty_closure()\n+            self.parse_ty_closure(Vec::new())\n         } else if self.eat_keyword(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n@@ -1460,7 +1497,7 @@ impl<'a> Parser<'a> {\n             self.expect(&token::CloseDelim(token::Paren));\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n-            self.parse_proc_type()\n+            self.parse_proc_type(Vec::new())\n         } else if self.token == token::Lt {\n             // QUALIFIED PATH\n             self.bump();\n@@ -1479,16 +1516,7 @@ impl<'a> Parser<'a> {\n                   self.token.is_ident() ||\n                   self.token.is_path() {\n             // NAMED TYPE\n-            let mode = if plus_allowed {\n-                LifetimeAndTypesAndBounds\n-            } else {\n-                LifetimeAndTypesWithoutColons\n-            };\n-            let PathAndBounds {\n-                path,\n-                bounds\n-            } = self.parse_path(mode);\n-            TyPath(path, bounds, ast::DUMMY_NODE_ID)\n+            self.parse_ty_path(plus_allowed)\n         } else if self.eat(&token::Underscore) {\n             // TYPE TO BE INFERRED\n             TyInfer\n@@ -3848,29 +3876,17 @@ impl<'a> Parser<'a> {\n     }\n \n     // matches bounds    = ( boundseq )?\n-    // where   boundseq  = ( bound + boundseq ) | bound\n-    // and     bound     = 'region | ty\n+    // where   boundseq  = ( polybound + boundseq ) | polybound\n+    // and     polybound = ( 'for' '<' 'region '>' )? bound\n+    // and     bound     = 'region | trait_ref\n     // NB: The None/Some distinction is important for issue #7264.\n     fn parse_ty_param_bounds(&mut self)\n                              -> OwnedSlice<TyParamBound>\n     {\n         let mut result = vec!();\n         loop {\n-            let lifetime_defs = if self.eat(&token::Lt) {\n-                let lifetime_defs = self.parse_lifetime_defs();\n-                self.expect_gt();\n-                lifetime_defs\n-            } else {\n-                Vec::new()\n-            };\n             match self.token {\n                 token::Lifetime(lifetime) => {\n-                    if lifetime_defs.len() > 0 {\n-                        let span = self.last_span;\n-                        self.span_err(span, \"lifetime declarations are not \\\n-                                             allowed here\")\n-                    }\n-\n                     result.push(RegionTyParamBound(ast::Lifetime {\n                         id: ast::DUMMY_NODE_ID,\n                         span: self.span,\n@@ -3879,13 +3895,8 @@ impl<'a> Parser<'a> {\n                     self.bump();\n                 }\n                 token::ModSep | token::Ident(..) => {\n-                    let path =\n-                        self.parse_path(LifetimeAndTypesWithoutColons).path;\n-                    result.push(TraitTyParamBound(ast::TraitRef {\n-                        path: path,\n-                        ref_id: ast::DUMMY_NODE_ID,\n-                        lifetimes: lifetime_defs,\n-                    }))\n+                    let poly_trait_ref = self.parse_poly_trait_ref();\n+                    result.push(TraitTyParamBound(poly_trait_ref))\n                 }\n                 _ => break,\n             }\n@@ -3898,7 +3909,7 @@ impl<'a> Parser<'a> {\n         return OwnedSlice::from_vec(result);\n     }\n \n-    fn trait_ref_from_ident(ident: Ident, span: Span) -> ast::TraitRef {\n+    fn trait_ref_from_ident(ident: Ident, span: Span) -> TraitRef {\n         let segment = ast::PathSegment {\n             identifier: ident,\n             parameters: ast::PathParameters::none()\n@@ -3911,7 +3922,6 @@ impl<'a> Parser<'a> {\n         ast::TraitRef {\n             path: path,\n             ref_id: ast::DUMMY_NODE_ID,\n-            lifetimes: Vec::new(),\n         }\n     }\n \n@@ -3927,7 +3937,7 @@ impl<'a> Parser<'a> {\n         let mut unbound = None;\n         if self.eat(&token::Question) {\n             let tref = Parser::trait_ref_from_ident(ident, span);\n-            unbound = Some(TraitTyParamBound(tref));\n+            unbound = Some(tref);\n             span = self.span;\n             ident = self.parse_ident();\n         }\n@@ -4538,7 +4548,6 @@ impl<'a> Parser<'a> {\n                     Some(TraitRef {\n                         path: (*path).clone(),\n                         ref_id: node_id,\n-                        lifetimes: Vec::new(),\n                     })\n                 }\n                 TyPath(_, Some(_), _) => {\n@@ -4568,6 +4577,35 @@ impl<'a> Parser<'a> {\n          Some(attrs))\n     }\n \n+    /// Parse a::B<String,int>\n+    fn parse_trait_ref(&mut self) -> TraitRef {\n+        ast::TraitRef {\n+            path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n+            ref_id: ast::DUMMY_NODE_ID,\n+        }\n+    }\n+\n+    fn parse_late_bound_lifetime_defs(&mut self) -> Vec<ast::LifetimeDef> {\n+        if self.eat_keyword(keywords::For) {\n+            self.expect(&token::Lt);\n+            let lifetime_defs = self.parse_lifetime_defs();\n+            self.expect_gt();\n+            lifetime_defs\n+        } else {\n+            Vec::new()\n+        }\n+    }\n+\n+    /// Parse for<'l> a::B<String,int>\n+    fn parse_poly_trait_ref(&mut self) -> PolyTraitRef {\n+        let lifetime_defs = self.parse_late_bound_lifetime_defs();\n+\n+        ast::PolyTraitRef {\n+            bound_lifetimes: lifetime_defs,\n+            trait_ref: self.parse_trait_ref()\n+        }\n+    }\n+\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self) -> ItemInfo {\n         let class_name = self.parse_ident();\n@@ -4681,7 +4719,7 @@ impl<'a> Parser<'a> {\n         else { Inherited }\n     }\n \n-    fn parse_for_sized(&mut self) -> Option<ast::TyParamBound> {\n+    fn parse_for_sized(&mut self) -> Option<ast::TraitRef> {\n         if self.eat_keyword(keywords::For) {\n             let span = self.span;\n             let ident = self.parse_ident();\n@@ -4691,7 +4729,7 @@ impl<'a> Parser<'a> {\n                 return None;\n             }\n             let tref = Parser::trait_ref_from_ident(ident, span);\n-            Some(TraitTyParamBound(tref))\n+            Some(tref)\n         } else {\n             None\n         }"}, {"sha": "f501a5831d2ad533cfe630136806c6f25d596385", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -503,42 +503,41 @@ declare_special_idents_and_keywords! {\n         (27,                         Mod,        \"mod\");\n         (28,                         Move,       \"move\");\n         (29,                         Mut,        \"mut\");\n-        (30,                         Once,       \"once\");\n-        (31,                         Pub,        \"pub\");\n-        (32,                         Ref,        \"ref\");\n-        (33,                         Return,     \"return\");\n+        (30,                         Pub,        \"pub\");\n+        (31,                         Ref,        \"ref\");\n+        (32,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME_NUM, Static, \"static\");\n         (super::SELF_KEYWORD_NAME_NUM,   Self,   \"self\");\n-        (34,                         Struct,     \"struct\");\n+        (33,                         Struct,     \"struct\");\n         (super::SUPER_KEYWORD_NAME_NUM, Super,   \"super\");\n-        (35,                         True,       \"true\");\n-        (36,                         Trait,      \"trait\");\n-        (37,                         Type,       \"type\");\n-        (38,                         Unsafe,     \"unsafe\");\n-        (39,                         Use,        \"use\");\n-        (40,                         Virtual,    \"virtual\");\n-        (41,                         While,      \"while\");\n-        (42,                         Continue,   \"continue\");\n-        (43,                         Proc,       \"proc\");\n-        (44,                         Box,        \"box\");\n-        (45,                         Const,      \"const\");\n-        (46,                         Where,      \"where\");\n+        (34,                         True,       \"true\");\n+        (35,                         Trait,      \"trait\");\n+        (36,                         Type,       \"type\");\n+        (37,                         Unsafe,     \"unsafe\");\n+        (38,                         Use,        \"use\");\n+        (39,                         Virtual,    \"virtual\");\n+        (40,                         While,      \"while\");\n+        (41,                         Continue,   \"continue\");\n+        (42,                         Proc,       \"proc\");\n+        (43,                         Box,        \"box\");\n+        (44,                         Const,      \"const\");\n+        (45,                         Where,      \"where\");\n \n         'reserved:\n-        (47,                         Alignof,    \"alignof\");\n-        (48,                         Be,         \"be\");\n-        (49,                         Offsetof,   \"offsetof\");\n-        (50,                         Priv,       \"priv\");\n-        (51,                         Pure,       \"pure\");\n-        (52,                         Sizeof,     \"sizeof\");\n-        (53,                         Typeof,     \"typeof\");\n-        (54,                         Unsized,    \"unsized\");\n-        (55,                         Yield,      \"yield\");\n-        (56,                         Do,         \"do\");\n-        (57,                         Abstract,   \"abstract\");\n-        (58,                         Final,      \"final\");\n-        (59,                         Override,   \"override\");\n+        (46,                         Alignof,    \"alignof\");\n+        (47,                         Be,         \"be\");\n+        (48,                         Offsetof,   \"offsetof\");\n+        (49,                         Priv,       \"priv\");\n+        (50,                         Pure,       \"pure\");\n+        (51,                         Sizeof,     \"sizeof\");\n+        (52,                         Typeof,     \"typeof\");\n+        (53,                         Unsized,    \"unsized\");\n+        (54,                         Yield,      \"yield\");\n+        (55,                         Do,         \"do\");\n+        (56,                         Abstract,   \"abstract\");\n+        (57,                         Final,      \"final\");\n+        (58,                         Override,   \"override\");\n     }\n }\n "}, {"sha": "c1515a36bec6897a982445e5fbecee5ab4442952", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -743,6 +743,9 @@ impl<'a> State<'a> {\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n+            ast::TyPolyTraitRef(ref poly_trait_ref) => {\n+                try!(self.print_poly_trait_ref(&**poly_trait_ref));\n+            }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));\n                 try!(self.print_type(&*qpath.for_type));\n@@ -960,7 +963,7 @@ impl<'a> State<'a> {\n                 try!(self.print_ident(item.ident));\n                 try!(self.print_generics(generics));\n                 match unbound {\n-                    &Some(TraitTyParamBound(ref tref)) => {\n+                    &Some(ref tref) => {\n                         try!(space(&mut self.s));\n                         try!(self.word_space(\"for\"));\n                         try!(self.print_trait_ref(tref));\n@@ -995,19 +998,21 @@ impl<'a> State<'a> {\n     }\n \n     fn print_trait_ref(&mut self, t: &ast::TraitRef) -> IoResult<()> {\n-        if t.lifetimes.len() > 0 {\n-            try!(self.print_generics(&ast::Generics {\n-                lifetimes: t.lifetimes.clone(),\n-                ty_params: OwnedSlice::empty(),\n-                where_clause: ast::WhereClause {\n-                    id: ast::DUMMY_NODE_ID,\n-                    predicates: Vec::new(),\n-                },\n-            }));\n-        }\n         self.print_path(&t.path, false)\n     }\n \n+    fn print_poly_trait_ref(&mut self, t: &ast::PolyTraitRef) -> IoResult<()> {\n+        if !t.bound_lifetimes.is_empty() {\n+            try!(word(&mut self.s, \"for<\"));\n+            for lifetime_def in t.bound_lifetimes.iter() {\n+                try!(self.print_lifetime_def(lifetime_def));\n+            }\n+            try!(word(&mut self.s, \">\"));\n+        }\n+\n+        self.print_trait_ref(&t.trait_ref)\n+    }\n+\n     pub fn print_enum_def(&mut self, enum_definition: &ast::EnumDef,\n                           generics: &ast::Generics, ident: ast::Ident,\n                           span: codemap::Span,\n@@ -2383,7 +2388,7 @@ impl<'a> State<'a> {\n \n                 try!(match *bound {\n                     TraitTyParamBound(ref tref) => {\n-                        self.print_trait_ref(tref)\n+                        self.print_poly_trait_ref(tref)\n                     }\n                     RegionTyParamBound(ref lt) => {\n                         self.print_lifetime(lt)\n@@ -2450,7 +2455,7 @@ impl<'a> State<'a> {\n \n     pub fn print_ty_param(&mut self, param: &ast::TyParam) -> IoResult<()> {\n         match param.unbound {\n-            Some(TraitTyParamBound(ref tref)) => {\n+            Some(ref tref) => {\n                 try!(self.print_trait_ref(tref));\n                 try!(self.word_space(\"?\"));\n             }\n@@ -2658,12 +2663,10 @@ impl<'a> State<'a> {\n         } else if opt_sigil == Some('&') {\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_extern_opt_abi(opt_abi));\n-            try!(self.print_onceness(onceness));\n         } else {\n             assert!(opt_sigil.is_none());\n             try!(self.print_fn_style(fn_style));\n             try!(self.print_opt_abi_and_extern_if_nondefault(opt_abi));\n-            try!(self.print_onceness(onceness));\n             try!(word(&mut self.s, \"fn\"));\n         }\n \n@@ -2982,13 +2985,6 @@ impl<'a> State<'a> {\n             ast::UnsafeFn => self.word_nbsp(\"unsafe\"),\n         }\n     }\n-\n-    pub fn print_onceness(&mut self, o: ast::Onceness) -> IoResult<()> {\n-        match o {\n-            ast::Once => self.word_nbsp(\"once\"),\n-            ast::Many => Ok(())\n-        }\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "1b1d1e9cace1a8b8746ca95e324ab47413d78f1d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -75,6 +75,10 @@ pub trait Visitor<'v> {\n     }\n     fn visit_ty_method(&mut self, t: &'v TypeMethod) { walk_ty_method(self, t) }\n     fn visit_trait_item(&mut self, t: &'v TraitItem) { walk_trait_item(self, t) }\n+    fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef) {\n+        walk_poly_trait_ref(self, t)\n+    }\n     fn visit_struct_def(&mut self, s: &'v StructDef, _: Ident, _: &'v Generics, _: NodeId) {\n         walk_struct_def(self, s)\n     }\n@@ -202,9 +206,20 @@ pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n \n /// Like with walk_method_helper this doesn't correspond to a method\n /// in Visitor, and so it gets a _helper suffix.\n-pub fn walk_trait_ref_helper<'v,V>(visitor: &mut V, trait_ref: &'v TraitRef)\n-                                   where V: Visitor<'v> {\n-    walk_lifetime_decls(visitor, &trait_ref.lifetimes);\n+pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n+                                         trait_ref: &'v PolyTraitRef)\n+    where V: Visitor<'v>\n+{\n+    walk_lifetime_decls(visitor, &trait_ref.bound_lifetimes);\n+    visitor.visit_trait_ref(&trait_ref.trait_ref);\n+}\n+\n+/// Like with walk_method_helper this doesn't correspond to a method\n+/// in Visitor, and so it gets a _helper suffix.\n+pub fn walk_trait_ref<'v,V>(visitor: &mut V,\n+                                   trait_ref: &'v TraitRef)\n+    where V: Visitor<'v>\n+{\n     visitor.visit_path(&trait_ref.path, trait_ref.ref_id)\n }\n \n@@ -248,8 +263,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                  ref impl_items) => {\n             visitor.visit_generics(type_parameters);\n             match *trait_reference {\n-                Some(ref trait_reference) => walk_trait_ref_helper(visitor,\n-                                                                   trait_reference),\n+                Some(ref trait_reference) => visitor.visit_trait_ref(trait_reference),\n                 None => ()\n             }\n             visitor.visit_ty(&**typ);\n@@ -383,6 +397,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&**ty);\n             visitor.visit_expr(&**expression)\n         }\n+        TyPolyTraitRef(ref poly_trait_ref) => {\n+            visitor.visit_poly_trait_ref(&**poly_trait_ref)\n+        }\n         TyTypeof(ref expression) => {\n             visitor.visit_expr(&**expression)\n         }\n@@ -497,7 +514,7 @@ pub fn walk_ty_param_bounds<'v, V: Visitor<'v>>(visitor: &mut V,\n     for bound in bounds.iter() {\n         match *bound {\n             TraitTyParamBound(ref typ) => {\n-                walk_trait_ref_helper(visitor, typ)\n+                visitor.visit_poly_trait_ref(typ)\n             }\n             RegionTyParamBound(ref lifetime) => {\n                 visitor.visit_lifetime_ref(lifetime);"}, {"sha": "924132c6de26bff8023a066ecc71ff66e77813df", "filename": "src/test/compile-fail/issue-10291.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10291.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn test<'x>(x: &'x int) {\n-    drop::< <'z>|&'z int| -> &'z int >(|z| {\n+    drop::< for<'z>|&'z int| -> &'z int >(|z| {\n         x\n         //~^ ERROR cannot infer an appropriate lifetime\n     });"}, {"sha": "17968195280a10d1eed9fc9c0c67f77d5b8ede06", "filename": "src/test/compile-fail/once-cant-call-twice-on-stack.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-stack.rs?ref=93c85eb8bdcc910a27caf6abd20207a626ae98e5", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing guarantees provided by once functions.\n-// This program would segfault if it were legal.\n-\n-#![feature(once_fns)]\n-use std::sync::Arc;\n-\n-fn foo(blk: once ||) {\n-    blk();\n-    blk(); //~ ERROR use of moved value\n-}\n-\n-fn main() {\n-    let x = Arc::new(true);\n-    foo(|| {\n-        assert!(*x);\n-        drop(x);\n-    })\n-}"}, {"sha": "3efebf6184406f06bf916688639b6274b87830d1", "filename": "src/test/compile-fail/once-cant-move-out-of-non-once-on-stack.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-move-out-of-non-once-on-stack.rs?ref=93c85eb8bdcc910a27caf6abd20207a626ae98e5", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing guarantees provided by once functions.\n-// This program would segfault if it were legal.\n-\n-use std::sync::Arc;\n-\n-fn foo(blk: ||) {\n-    blk();\n-    blk();\n-}\n-\n-fn main() {\n-    let x = Arc::new(true);\n-    foo(|| {\n-        assert!(*x);\n-        drop(x); //~ ERROR cannot move out of captured outer variable\n-    })\n-}"}, {"sha": "7594deda3b2d854a70442450f0ce2b475e6b4207", "filename": "src/test/compile-fail/once-fn-subtyping.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Fcompile-fail%2Fonce-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Fcompile-fail%2Fonce-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-fn-subtyping.rs?ref=93c85eb8bdcc910a27caf6abd20207a626ae98e5", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(once_fns)]\n-fn main() {\n-    let f: once || = ||();\n-    let g: || = f;  //~ ERROR mismatched types\n-    let h: || = ||();\n-    let i: once || = h;  // ok\n-}"}, {"sha": "ac56e8ce14df6ad99820434ef6d7de7af9862d90", "filename": "src/test/compile-fail/regions-fn-subtyping-return-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping-return-static.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -22,11 +22,11 @@\n struct S;\n \n // Given 'cx, return 'cx\n-type F = fn<'cx>(&'cx S) -> &'cx S;\n+type F = for<'cx> fn(&'cx S) -> &'cx S;\n fn want_F(f: F) { }\n \n // Given anything, return 'static\n-type G = fn<'cx>(&'cx S) -> &'static S;\n+type G = for<'cx> fn(&'cx S) -> &'static S;\n fn want_G(f: G) { }\n \n // Should meet both."}, {"sha": "91a6ff789ea39fb9ca31fba3b84b238711b82b7f", "filename": "src/test/compile-fail/regions-fn-subtyping.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-fn-subtyping.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -17,29 +17,29 @@ fn test_fn<'x,'y,'z,T>(_x: &'x T, _y: &'y T, _z: &'z T) {\n     // subtype::<T1>(of::<T2>()) will typecheck\n     // iff T1 <: T2.\n \n-    subtype::< <'a>|&'a T|>(\n-        of::< <'a>|&'a T|>());\n+    subtype::< for<'a>|&'a T|>(\n+        of::< for<'a>|&'a T|>());\n \n-    subtype::< <'a>|&'a T|>(\n-        of::< <'b>|&'b T|>());\n+    subtype::< for<'a>|&'a T|>(\n+        of::< for<'b>|&'b T|>());\n \n-    subtype::< <'b>|&'b T|>(\n+    subtype::< for<'b>|&'b T|>(\n         of::<|&'x T|>());\n \n     subtype::<|&'x T|>(\n-        of::< <'b>|&'b T|>());  //~ ERROR mismatched types\n+        of::< for<'b>|&'b T|>());  //~ ERROR mismatched types\n \n-    subtype::< <'a,'b>|&'a T, &'b T|>(\n-        of::< <'a>|&'a T, &'a T|>());\n+    subtype::< for<'a,'b>|&'a T, &'b T|>(\n+        of::< for<'a>|&'a T, &'a T|>());\n \n-    subtype::< <'a>|&'a T, &'a T|>(\n-        of::< <'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n+    subtype::< for<'a>|&'a T, &'a T|>(\n+        of::< for<'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n \n-    subtype::< <'a,'b>|&'a T, &'b T|>(\n+    subtype::< for<'a,'b>|&'a T, &'b T|>(\n         of::<|&'x T, &'y T|>());\n \n     subtype::<|&'x T, &'y T|>(\n-        of::< <'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n+        of::< for<'a,'b>|&'a T, &'b T|>()); //~ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "518fe0b00b6ce7c743de9f0ba701bb644bafe24e", "filename": "src/test/compile-fail/regions-name-duplicated.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-duplicated.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n struct Foo<'a, 'a> { //~ ERROR lifetime name `'a` declared twice\n-//~^ ERROR lifetime name `'a` declared twice\n     x: &'a int\n }\n "}, {"sha": "9f50ad3666025823bed9aa0c70c6117ab8973ae7", "filename": "src/test/compile-fail/regions-name-static.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-static.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n struct Foo<'static> { //~ ERROR illegal lifetime parameter name: `'static`\n-//~^ ERROR illegal lifetime parameter name: `'static`\n     x: &'static int\n }\n "}, {"sha": "e9e585e84d0ef89c4b63b29c5cfd3827f79c020e", "filename": "src/test/compile-fail/regions-name-undeclared.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -43,16 +43,16 @@ fn bar<'a>(x: &'a int) {\n \n     // &'a CAN be declared on functions and used then:\n     fn g<'a>(a: &'a int) { } // OK\n-    fn h(a: <'a>|&'a int|) { } // OK\n+    fn h(a: for<'a>|&'a int|) { } // OK\n }\n \n // Test nesting of lifetimes in fn type declarations\n fn fn_types(a: &'a int, //~ ERROR undeclared lifetime\n-            b: <'a>|a: &'a int,\n-                    b: &'b int, //~ ERROR undeclared lifetime\n-                    c: <'b>|a: &'a int,\n-                            b: &'b int|,\n-                    d: &'b int|, //~ ERROR undeclared lifetime\n+            b: for<'a>|a: &'a int,\n+                       b: &'b int, //~ ERROR undeclared lifetime\n+                       c: for<'b>|a: &'a int,\n+                                  b: &'b int|,\n+                       d: &'b int|, //~ ERROR undeclared lifetime\n             c: &'a int) //~ ERROR undeclared lifetime\n {\n }"}, {"sha": "a08cf2263894dfc5396a63164f119f48588b16a8", "filename": "src/test/compile-fail/regions-nested-fns-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns-2.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn ignore(_f: <'z>|&'z int| -> &'z int) {}\n+fn ignore(_f: for<'z>|&'z int| -> &'z int) {}\n \n fn nested() {\n     let y = 3;"}, {"sha": "cf0b615bb01abbd6dd7e5b82f14207f00da98026", "filename": "src/test/compile-fail/regions-nested-fns.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-nested-fns.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -14,13 +14,13 @@ fn nested<'x>(x: &'x int) {\n     let y = 3;\n     let mut ay = &y; //~ ERROR cannot infer\n \n-    ignore::< <'z>|&'z int|>(|z| {\n+    ignore::< for<'z>|&'z int|>(|z| {\n         ay = x;\n         ay = &y;\n         ay = z;\n     });\n \n-    ignore::< <'z>|&'z int| -> &'z int>(|z| {\n+    ignore::< for<'z>|&'z int| -> &'z int>(|z| {\n         if false { return x; }  //~ ERROR cannot infer an appropriate lifetime for automatic\n         if false { return ay; }\n         return z;"}, {"sha": "997775efa84b52d60756dfc3ed3c62652f37dbbb", "filename": "src/test/compile-fail/regions-ret-borrowed-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ret-borrowed-1.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -12,7 +12,7 @@\n // some point regions-ret-borrowed reported an error but this file did\n // not, due to special hardcoding around the anonymous region.\n \n-fn with<R>(f: <'a>|x: &'a int| -> R) -> R {\n+fn with<R>(f: for<'a>|x: &'a int| -> R) -> R {\n     f(&3)\n }\n "}, {"sha": "080523f0060a7a3eed88fe8834a5eb1f4a2a67ac", "filename": "src/test/run-pass/hrtb-parse.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can parse all the various places that a `for` keyword\n+// can appear representing universal quantification.\n+\n+#![allow(unused_variables)]\n+#![allow(dead_code)]\n+\n+trait Get<A,R> {\n+    fn get(&self, arg: A) -> R;\n+}\n+\n+// Parse HRTB with explicit `for` in a where-clause:\n+\n+fn foo00<T>(t: T)\n+    where T : for<'a> Get<&'a int, &'a int>\n+{\n+}\n+\n+fn foo01<T: for<'a> Get<&'a int, &'a int>>(t: T)\n+{\n+}\n+\n+// Parse HRTB with explicit `for` in various sorts of types:\n+\n+fn foo10(t: Box<for<'a> Get<int, int>>) { }\n+fn foo11(t: Box<for<'a> Get(int) -> int>) { }\n+\n+fn foo20(t: for<'a> fn(int) -> int) { }\n+fn foo21(t: for<'a> unsafe fn(int) -> int) { }\n+fn foo22(t: for<'a> extern \"C\" fn(int) -> int) { }\n+fn foo23(t: for<'a> unsafe extern \"C\" fn(int) -> int) { }\n+\n+fn foo30(t: for<'a> |int| -> int) { }\n+fn foo31(t: for<'a> unsafe |int| -> int) { }\n+\n+//fn foo40(t: for<'a> proc(int) -> int) { }\n+\n+fn main() {\n+}"}, {"sha": "32432c07dcf415fd84f59f228c9cfa5210939c55", "filename": "src/test/run-pass/nullable-pointer-ffi-compat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-ffi-compat.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -29,7 +29,7 @@ static FOO: int = 0xDEADBEE;\n \n pub fn main() {\n     unsafe {\n-        let f: extern \"C\" fn<'a>(&'a int) -> &'a int = mem::transmute(foo);\n+        let f: for<'a> extern \"C\" fn(&'a int) -> &'a int = mem::transmute(foo);\n         assert_eq!(*f(&FOO), FOO);\n     }\n }"}, {"sha": "e24e809ed018a9416ade45f491318d0c3c34cbeb", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2f303ad098844351d08800038a4f99fa2ff0817/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=a2f303ad098844351d08800038a4f99fa2ff0817", "patch": "@@ -11,7 +11,6 @@\n // Testing guarantees provided by once functions.\n \n \n-#![feature(once_fns)]\n use std::sync::Arc;\n \n fn foo(blk: proc()) {"}, {"sha": "0419fc54add15b6e14a07ae4320308ed34435c2b", "filename": "src/test/run-pass/once-move-out-on-stack.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93c85eb8bdcc910a27caf6abd20207a626ae98e5/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-stack.rs?ref=93c85eb8bdcc910a27caf6abd20207a626ae98e5", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing guarantees provided by once functions.\n-\n-\n-#![feature(once_fns)]\n-use std::sync::Arc;\n-\n-fn foo(blk: once ||) {\n-    blk();\n-}\n-\n-pub fn main() {\n-    let x = Arc::new(true);\n-    foo(|| {\n-        assert!(*x);\n-        drop(x);\n-    })\n-}"}]}