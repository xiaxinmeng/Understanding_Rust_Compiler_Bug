{"sha": "4e83a38618cb6160cf6a7297ed3413f434149242", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlODNhMzg2MThjYjYxNjBjZjZhNzI5N2VkMzQxM2Y0MzQxNDkyNDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-16T20:43:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-16T20:43:45Z"}, "message": "Auto merge of #6123 - montrivo:less_concise_than, r=ebroto\n\nadd lint manual_unwrap_or\n\nImplements partially #5923.\n\nchangelog: add lint manual_unwrap_or", "tree": {"sha": "bd32046d824a430f41be020782d0c72eea29b657", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd32046d824a430f41be020782d0c72eea29b657"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e83a38618cb6160cf6a7297ed3413f434149242", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e83a38618cb6160cf6a7297ed3413f434149242", "html_url": "https://github.com/rust-lang/rust/commit/4e83a38618cb6160cf6a7297ed3413f434149242", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e83a38618cb6160cf6a7297ed3413f434149242/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81890c541e2da0d22992237c78190379b7497bb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/81890c541e2da0d22992237c78190379b7497bb4", "html_url": "https://github.com/rust-lang/rust/commit/81890c541e2da0d22992237c78190379b7497bb4"}, {"sha": "690a6a6c0eff1a3edeb5f4c2dcbf9994760c3184", "url": "https://api.github.com/repos/rust-lang/rust/commits/690a6a6c0eff1a3edeb5f4c2dcbf9994760c3184", "html_url": "https://github.com/rust-lang/rust/commit/690a6a6c0eff1a3edeb5f4c2dcbf9994760c3184"}], "stats": {"total": 481, "additions": 405, "deletions": 76}, "files": [{"sha": "d82f970b8bf20a24eb636af059bdf1ddf33516c1", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -1796,6 +1796,7 @@ Released 2018-09-13\n [`manual_saturating_arithmetic`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_saturating_arithmetic\n [`manual_strip`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_strip\n [`manual_swap`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_swap\n+[`manual_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#manual_unwrap_or\n [`many_single_char_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#many_single_char_names\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry"}, {"sha": "d4d2f92a6a695c7af893688ce2a1c1b966725570", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -234,6 +234,7 @@ mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n mod manual_strip;\n+mod manual_unwrap_or;\n mod map_clone;\n mod map_err_ignore;\n mod map_identity;\n@@ -640,6 +641,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &manual_strip::MANUAL_STRIP,\n+        &manual_unwrap_or::MANUAL_UNWRAP_OR,\n         &map_clone::MAP_CLONE,\n         &map_err_ignore::MAP_ERR_IGNORE,\n         &map_identity::MAP_IDENTITY,\n@@ -1126,6 +1128,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n     store.register_late_pass(|| box unwrap_in_result::UnwrapInResult);\n     store.register_late_pass(|| box self_assignment::SelfAssignment);\n+    store.register_late_pass(|| box manual_unwrap_or::ManualUnwrapOr);\n     store.register_late_pass(|| box float_equality_without_abs::FloatEqualityWithoutAbs);\n     store.register_late_pass(|| box async_yields_async::AsyncYieldsAsync);\n     store.register_late_pass(|| box manual_strip::ManualStrip);\n@@ -1367,6 +1370,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n+        LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n@@ -1662,6 +1666,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::WHILE_LET_LOOP),\n         LintId::of(&manual_strip::MANUAL_STRIP),\n+        LintId::of(&manual_unwrap_or::MANUAL_UNWRAP_OR),\n         LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),"}, {"sha": "ddb8cc25077e177bc3420f09a0e476799ab02e18", "filename": "clippy_lints/src/manual_unwrap_or.rs", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_unwrap_or.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -0,0 +1,104 @@\n+use crate::consts::constant_simple;\n+use crate::utils;\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{def, Arm, Expr, ExprKind, PatKind, QPath};\n+use rustc_lint::LintContext;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Finds patterns that reimplement `Option::unwrap_or`.\n+    ///\n+    /// **Why is this bad?**\n+    /// Concise code helps focusing on behavior instead of boilerplate.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// match foo {\n+    ///     Some(v) => v,\n+    ///     None => 1,\n+    /// };\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let foo: Option<i32> = None;\n+    /// foo.unwrap_or(1);\n+    /// ```\n+    pub MANUAL_UNWRAP_OR,\n+    complexity,\n+    \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\"\n+}\n+\n+declare_lint_pass!(ManualUnwrapOr => [MANUAL_UNWRAP_OR]);\n+\n+impl LateLintPass<'_> for ManualUnwrapOr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+        lint_option_unwrap_or_case(cx, expr);\n+    }\n+}\n+\n+fn lint_option_unwrap_or_case<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+    fn applicable_none_arm<'a>(arms: &'a [Arm<'a>]) -> Option<&'a Arm<'a>> {\n+        if_chain! {\n+            if arms.len() == 2;\n+            if arms.iter().all(|arm| arm.guard.is_none());\n+            if let Some((idx, none_arm)) = arms.iter().enumerate().find(|(_, arm)|\n+                if let PatKind::Path(ref qpath) = arm.pat.kind {\n+                    utils::match_qpath(qpath, &utils::paths::OPTION_NONE)\n+                } else {\n+                    false\n+                }\n+            );\n+            let some_arm = &arms[1 - idx];\n+            if let PatKind::TupleStruct(ref some_qpath, &[some_binding], _) = some_arm.pat.kind;\n+            if utils::match_qpath(some_qpath, &utils::paths::OPTION_SOME);\n+            if let PatKind::Binding(_, binding_hir_id, ..) = some_binding.kind;\n+            if let ExprKind::Path(QPath::Resolved(_, body_path)) = some_arm.body.kind;\n+            if let def::Res::Local(body_path_hir_id) = body_path.res;\n+            if body_path_hir_id == binding_hir_id;\n+            if !utils::usage::contains_return_break_continue_macro(none_arm.body);\n+            then {\n+                Some(none_arm)\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+\n+    if_chain! {\n+        if let ExprKind::Match(scrutinee, match_arms, _) = expr.kind;\n+        let ty = cx.typeck_results().expr_ty(scrutinee);\n+        if utils::is_type_diagnostic_item(cx, ty, sym!(option_type));\n+        if let Some(none_arm) = applicable_none_arm(match_arms);\n+        if let Some(scrutinee_snippet) = utils::snippet_opt(cx, scrutinee.span);\n+        if let Some(none_body_snippet) = utils::snippet_opt(cx, none_arm.body.span);\n+        if let Some(indent) = utils::indent_of(cx, expr.span);\n+        if constant_simple(cx, cx.typeck_results(), none_arm.body).is_some();\n+        then {\n+            let reindented_none_body =\n+                utils::reindent_multiline(none_body_snippet.into(), true, Some(indent));\n+            utils::span_lint_and_sugg(\n+                cx,\n+                MANUAL_UNWRAP_OR, expr.span,\n+                \"this pattern reimplements `Option::unwrap_or`\",\n+                \"replace with\",\n+                format!(\n+                    \"{}.unwrap_or({})\",\n+                    scrutinee_snippet,\n+                    reindented_none_body,\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "eb7624b25a3c994a0c1ffdbbd16f29963f3c8a55", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -5,10 +5,8 @@ use crate::utils::{is_type_diagnostic_item, paths, span_lint_and_sugg};\n use if_chain::if_chain;\n \n use rustc_errors::Applicability;\n-use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -84,53 +82,6 @@ struct OptionIfLetElseOccurence {\n     wrap_braces: bool,\n }\n \n-struct ReturnBreakContinueMacroVisitor {\n-    seen_return_break_continue: bool,\n-}\n-\n-impl ReturnBreakContinueMacroVisitor {\n-    fn new() -> ReturnBreakContinueMacroVisitor {\n-        ReturnBreakContinueMacroVisitor {\n-            seen_return_break_continue: false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n-    type Map = Map<'tcx>;\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        if self.seen_return_break_continue {\n-            // No need to look farther if we've already seen one of them\n-            return;\n-        }\n-        match &ex.kind {\n-            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n-                self.seen_return_break_continue = true;\n-            },\n-            // Something special could be done here to handle while or for loop\n-            // desugaring, as this will detect a break if there's a while loop\n-            // or a for loop inside the expression.\n-            _ => {\n-                if utils::in_macro(ex.span) {\n-                    self.seen_return_break_continue = true;\n-                } else {\n-                    rustc_hir::intravisit::walk_expr(self, ex);\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n-    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n-    recursive_visitor.visit_expr(expression);\n-    recursive_visitor.seen_return_break_continue\n-}\n-\n /// Extracts the body of a given arm. If the arm contains only an expression,\n /// then it returns the expression. Otherwise, it returns the entire block\n fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n@@ -208,8 +159,8 @@ fn detect_option_if_let_else<'tcx>(\n         if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n         if utils::match_qpath(struct_qpath, &paths::OPTION_SOME);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(arms[0].body);\n-        if !contains_return_break_continue_macro(arms[1].body);\n+        if !utils::usage::contains_return_break_continue_macro(arms[0].body);\n+        if !utils::usage::contains_return_break_continue_macro(arms[1].body);\n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n             let some_body = extract_body_from_arm(&arms[0])?;"}, {"sha": "30e812c284b006099f6226a2445dd4c3f5ca7489", "filename": "clippy_lints/src/utils/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Feager_or_lazy.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -82,7 +82,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n /// Identify some potentially computationally expensive patterns.\n /// This function is named so to stress that its implementation is non-exhaustive.\n /// It returns FNs and FPs.\n-fn identify_some_potentially_expensive_patterns<'a, 'tcx>(cx: &'a LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n+fn identify_some_potentially_expensive_patterns<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     // Searches an expression for method calls or function calls that aren't ctors\n     struct FunCallFinder<'a, 'tcx> {\n         cx: &'a LateContext<'tcx>,"}, {"sha": "2fd6046ebcf5a65401dc425f2d2229eca593590b", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -1,10 +1,11 @@\n+use crate::utils;\n use crate::utils::match_var;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, HirId, Path};\n+use rustc_hir::{Expr, ExprKind, HirId, Path};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -174,3 +175,50 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for BindingUsageFinder<'a, 'tcx> {\n         intravisit::NestedVisitorMap::OnlyBodies(self.cx.tcx.hir())\n     }\n }\n+\n+struct ReturnBreakContinueMacroVisitor {\n+    seen_return_break_continue: bool,\n+}\n+\n+impl ReturnBreakContinueMacroVisitor {\n+    fn new() -> ReturnBreakContinueMacroVisitor {\n+        ReturnBreakContinueMacroVisitor {\n+            seen_return_break_continue: false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self.seen_return_break_continue {\n+            // No need to look farther if we've already seen one of them\n+            return;\n+        }\n+        match &ex.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n+                self.seen_return_break_continue = true;\n+            },\n+            // Something special could be done here to handle while or for loop\n+            // desugaring, as this will detect a break if there's a while loop\n+            // or a for loop inside the expression.\n+            _ => {\n+                if utils::in_macro(ex.span) {\n+                    self.seen_return_break_continue = true;\n+                } else {\n+                    rustc_hir::intravisit::walk_expr(self, ex);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n+    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n+    recursive_visitor.visit_expr(expression);\n+    recursive_visitor.seen_return_break_continue\n+}"}, {"sha": "6301d623a2b12955c92a29c9afcf13bbb2deff51", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -1180,6 +1180,13 @@ vec![\n         deprecation: None,\n         module: \"swap\",\n     },\n+    Lint {\n+        name: \"manual_unwrap_or\",\n+        group: \"complexity\",\n+        desc: \"finds patterns that can be encoded more concisely with `Option::unwrap_or`\",\n+        deprecation: None,\n+        module: \"manual_unwrap_or\",\n+    },\n     Lint {\n         name: \"many_single_char_names\",\n         group: \"style\","}, {"sha": "a8736f1e6efe159c7390fc719585a2a2745369ae", "filename": "tests/ui/manual_unwrap_or.fixed", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fmanual_unwrap_or.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fmanual_unwrap_or.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.fixed?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -0,0 +1,68 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn unwrap_or() {\n+    // int case\n+    Some(1).unwrap_or(42);\n+\n+    // int case reversed\n+    Some(1).unwrap_or(42);\n+\n+    // richer none expr\n+    Some(1).unwrap_or(1 + 42);\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    Some(1).unwrap_or({\n+        42 + 42\n+            + 42 + 42 + 42\n+            + 42 + 42 + 42\n+    });\n+\n+    // string case\n+    Some(\"Bob\").unwrap_or(\"Alice\");\n+\n+    // don't lint\n+    match Some(1) {\n+        Some(i) => i + 2,\n+        None => 42,\n+    };\n+    match Some(1) {\n+        Some(i) => i,\n+        None => return,\n+    };\n+    for j in 0..4 {\n+        match Some(j) {\n+            Some(i) => i,\n+            None => continue,\n+        };\n+        match Some(j) {\n+            Some(i) => i,\n+            None => break,\n+        };\n+    }\n+\n+    // cases where the none arm isn't a constant expression\n+    // are not linted due to potential ownership issues\n+\n+    // ownership issue example, don't lint\n+    struct NonCopyable;\n+    let mut option: Option<NonCopyable> = None;\n+    match option {\n+        Some(x) => x,\n+        None => {\n+            option = Some(NonCopyable);\n+            // some more code ...\n+            option.unwrap()\n+        },\n+    };\n+\n+    // ownership issue example, don't lint\n+    let option: Option<&str> = None;\n+    match option {\n+        Some(s) => s,\n+        None => &format!(\"{} {}!\", \"hello\", \"world\"),\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "bede8cffc326ecea9783815694c69bf9141c9352", "filename": "tests/ui/manual_unwrap_or.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -0,0 +1,83 @@\n+// run-rustfix\n+#![allow(dead_code)]\n+\n+fn unwrap_or() {\n+    // int case\n+    match Some(1) {\n+        Some(i) => i,\n+        None => 42,\n+    };\n+\n+    // int case reversed\n+    match Some(1) {\n+        None => 42,\n+        Some(i) => i,\n+    };\n+\n+    // richer none expr\n+    match Some(1) {\n+        Some(i) => i,\n+        None => 1 + 42,\n+    };\n+\n+    // multiline case\n+    #[rustfmt::skip]\n+    match Some(1) {\n+        Some(i) => i,\n+        None => {\n+            42 + 42\n+                + 42 + 42 + 42\n+                + 42 + 42 + 42\n+        }\n+    };\n+\n+    // string case\n+    match Some(\"Bob\") {\n+        Some(i) => i,\n+        None => \"Alice\",\n+    };\n+\n+    // don't lint\n+    match Some(1) {\n+        Some(i) => i + 2,\n+        None => 42,\n+    };\n+    match Some(1) {\n+        Some(i) => i,\n+        None => return,\n+    };\n+    for j in 0..4 {\n+        match Some(j) {\n+            Some(i) => i,\n+            None => continue,\n+        };\n+        match Some(j) {\n+            Some(i) => i,\n+            None => break,\n+        };\n+    }\n+\n+    // cases where the none arm isn't a constant expression\n+    // are not linted due to potential ownership issues\n+\n+    // ownership issue example, don't lint\n+    struct NonCopyable;\n+    let mut option: Option<NonCopyable> = None;\n+    match option {\n+        Some(x) => x,\n+        None => {\n+            option = Some(NonCopyable);\n+            // some more code ...\n+            option.unwrap()\n+        },\n+    };\n+\n+    // ownership issue example, don't lint\n+    let option: Option<&str> = None;\n+    match option {\n+        Some(s) => s,\n+        None => &format!(\"{} {}!\", \"hello\", \"world\"),\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "674f2952635f6298adeb7d3cbfae994a804e7a10", "filename": "tests/ui/manual_unwrap_or.stderr", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fmanual_unwrap_or.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fmanual_unwrap_or.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_unwrap_or.stderr?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -0,0 +1,61 @@\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:6:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(i) => i,\n+LL | |         None => 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n+   |\n+   = note: `-D clippy::manual-unwrap-or` implied by `-D warnings`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:12:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         None => 42,\n+LL | |         Some(i) => i,\n+LL | |     };\n+   | |_____^ help: replace with: `Some(1).unwrap_or(42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:18:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(i) => i,\n+LL | |         None => 1 + 42,\n+LL | |     };\n+   | |_____^ help: replace with: `Some(1).unwrap_or(1 + 42)`\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:25:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(i) => i,\n+LL | |         None => {\n+LL | |             42 + 42\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+help: replace with\n+   |\n+LL |     Some(1).unwrap_or({\n+LL |         42 + 42\n+LL |             + 42 + 42 + 42\n+LL |             + 42 + 42 + 42\n+LL |     });\n+   |\n+\n+error: this pattern reimplements `Option::unwrap_or`\n+  --> $DIR/manual_unwrap_or.rs:35:5\n+   |\n+LL | /     match Some(\"Bob\") {\n+LL | |         Some(i) => i,\n+LL | |         None => \"Alice\",\n+LL | |     };\n+   | |_____^ help: replace with: `Some(\"Bob\").unwrap_or(\"Alice\")`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "e366c75335c20357659021928b32b4e834206997", "filename": "tests/ui/shadow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.rs?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -8,6 +8,7 @@\n #![allow(\n     unused_parens,\n     unused_variables,\n+    clippy::manual_unwrap_or,\n     clippy::missing_docs_in_private_items,\n     clippy::single_match\n )]"}, {"sha": "7c1ad2949e91b914cc75034d08034088fd140c99", "filename": "tests/ui/shadow.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4e83a38618cb6160cf6a7297ed3413f434149242/tests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.stderr?ref=4e83a38618cb6160cf6a7297ed3413f434149242", "patch": "@@ -1,135 +1,135 @@\n error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:26:5\n+  --> $DIR/shadow.rs:27:5\n    |\n LL |     let x = &mut x;\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:25:13\n+  --> $DIR/shadow.rs:26:13\n    |\n LL |     let mut x = 1;\n    |             ^\n \n error: `x` is shadowed by itself in `{ x }`\n-  --> $DIR/shadow.rs:27:5\n+  --> $DIR/shadow.rs:28:5\n    |\n LL |     let x = { x };\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:26:9\n+  --> $DIR/shadow.rs:27:9\n    |\n LL |     let x = &mut x;\n    |         ^\n \n error: `x` is shadowed by itself in `(&*x)`\n-  --> $DIR/shadow.rs:28:5\n+  --> $DIR/shadow.rs:29:5\n    |\n LL |     let x = (&*x);\n    |     ^^^^^^^^^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:27:9\n+  --> $DIR/shadow.rs:28:9\n    |\n LL |     let x = { x };\n    |         ^\n \n error: `x` is shadowed by `{ *x + 1 }` which reuses the original value\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n    |\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:29:13\n+  --> $DIR/shadow.rs:30:13\n    |\n LL |     let x = { *x + 1 };\n    |             ^^^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:28:9\n+  --> $DIR/shadow.rs:29:9\n    |\n LL |     let x = (&*x);\n    |         ^\n \n error: `x` is shadowed by `id(x)` which reuses the original value\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = id(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:30:13\n+  --> $DIR/shadow.rs:31:13\n    |\n LL |     let x = id(x);\n    |             ^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = { *x + 1 };\n    |         ^\n \n error: `x` is shadowed by `(1, x)` which reuses the original value\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = (1, x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:31:13\n+  --> $DIR/shadow.rs:32:13\n    |\n LL |     let x = (1, x);\n    |             ^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = id(x);\n    |         ^\n \n error: `x` is shadowed by `first(x)` which reuses the original value\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = first(x);\n    |         ^\n    |\n note: initialization happens here\n-  --> $DIR/shadow.rs:32:13\n+  --> $DIR/shadow.rs:33:13\n    |\n LL |     let x = first(x);\n    |             ^^^^^^^^\n note: previous binding is here\n-  --> $DIR/shadow.rs:31:9\n+  --> $DIR/shadow.rs:32:9\n    |\n LL |     let x = (1, x);\n    |         ^\n \n error: `x` is being shadowed\n-  --> $DIR/shadow.rs:34:9\n+  --> $DIR/shadow.rs:35:9\n    |\n LL |     let x = y;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: initialization happens here\n-  --> $DIR/shadow.rs:34:13\n+  --> $DIR/shadow.rs:35:13\n    |\n LL |     let x = y;\n    |             ^\n note: previous binding is here\n-  --> $DIR/shadow.rs:32:9\n+  --> $DIR/shadow.rs:33:9\n    |\n LL |     let x = first(x);\n    |         ^\n \n error: `x` shadows a previous declaration\n-  --> $DIR/shadow.rs:36:5\n+  --> $DIR/shadow.rs:37:5\n    |\n LL |     let x;\n    |     ^^^^^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:34:9\n+  --> $DIR/shadow.rs:35:9\n    |\n LL |     let x = y;\n    |         ^"}]}