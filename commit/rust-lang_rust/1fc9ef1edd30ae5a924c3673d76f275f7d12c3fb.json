{"sha": "1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "node_id": "C_kwDOAAsO6NoAKDFmYzllZjFlZGQzMGFlNWE5MjRjMzY3M2Q3NmYyNzVmN2QxMmMzZmI", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-06-28T15:18:07Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-01T14:54:27Z"}, "message": "tracing::instrument cleanup", "tree": {"sha": "bfcd5b96fdb596e08a0b0b187163a65287dfe777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfcd5b96fdb596e08a0b0b187163a65287dfe777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "html_url": "https://github.com/rust-lang/rust/commit/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee3c8350189de045ec71997874eaa6cebf99fbf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee3c8350189de045ec71997874eaa6cebf99fbf3", "html_url": "https://github.com/rust-lang/rust/commit/ee3c8350189de045ec71997874eaa6cebf99fbf3"}], "stats": {"total": 364, "additions": 117, "deletions": 247}, "files": [{"sha": "8dc9368a0b994d197943ea914fa19b6578b554dc", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -1139,7 +1139,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ///   include the CFG anyhow.\n     /// - For each `end('x)` element in `'r`, compute the mutual LUB, yielding\n     ///   a result `'y`.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     pub(crate) fn universal_upper_bound(&self, r: RegionVid) -> RegionVid {\n         debug!(r = %self.region_value_str(r));\n \n@@ -1151,8 +1151,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             lub = self.universal_region_relations.postdom_upper_bound(lub, ur);\n         }\n \n-        debug!(?lub);\n-\n         lub\n     }\n \n@@ -1333,15 +1331,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     // Evaluate whether `sup_region: sub_region`.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     fn eval_outlives(&self, sup_region: RegionVid, sub_region: RegionVid) -> bool {\n         debug!(\n-            \"eval_outlives: sup_region's value = {:?} universal={:?}\",\n+            \"sup_region's value = {:?} universal={:?}\",\n             self.region_value_str(sup_region),\n             self.universal_regions.is_universal_region(sup_region),\n         );\n         debug!(\n-            \"eval_outlives: sub_region's value = {:?} universal={:?}\",\n+            \"sub_region's value = {:?} universal={:?}\",\n             self.region_value_str(sub_region),\n             self.universal_regions.is_universal_region(sub_region),\n         );\n@@ -1354,7 +1352,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // true if `'sup` outlives static.\n         if !self.universe_compatible(sub_region_scc, sup_region_scc) {\n             debug!(\n-                \"eval_outlives: sub universe `{sub_region_scc:?}` is not nameable \\\n+                \"sub universe `{sub_region_scc:?}` is not nameable \\\n                 by super `{sup_region_scc:?}`, promoting to static\",\n             );\n \n@@ -1375,9 +1373,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             });\n \n         if !universal_outlives {\n-            debug!(\n-                \"eval_outlives: returning false because sub region contains a universal region not present in super\"\n-            );\n+            debug!(\"sub region contains a universal region not present in super\");\n             return false;\n         }\n \n@@ -1386,15 +1382,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if self.universal_regions.is_universal_region(sup_region) {\n             // Micro-opt: universal regions contain all points.\n-            debug!(\n-                \"eval_outlives: returning true because super is universal and hence contains all points\"\n-            );\n+            debug!(\"super is universal and hence contains all points\");\n             return true;\n         }\n \n-        let result = self.scc_values.contains_points(sup_region_scc, sub_region_scc);\n-        debug!(\"returning {} because of comparison between points in sup/sub\", result);\n-        result\n+        debug!(\"comparison between points in sup/sub\");\n+\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -1971,7 +1965,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     }\n \n     /// Finds some region R such that `fr1: R` and `R` is live at `elem`.\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     pub(crate) fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n         trace!(scc = ?self.constraint_sccs.scc(fr1));\n         trace!(universe = ?self.scc_universes[self.constraint_sccs.scc(fr1)]);"}, {"sha": "0392367288c40544cad175913f68626a3ca9684d", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -60,7 +60,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Calling `universal_upper_bound` for such a region gives `fr_fn_body`,\n     /// which has no `external_name` in which case we use `'empty` as the\n     /// region to pass to `infer_opaque_definition_from_instantiation`.\n-    #[instrument(level = \"debug\", skip(self, infcx))]\n+    #[instrument(level = \"debug\", skip(self, infcx), ret)]\n     pub(crate) fn infer_opaque_types(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,"}, {"sha": "b9b181681ec4b7495cf63f925799d205cdaff281", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -768,10 +768,9 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         mir_def_id: LocalDefId,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) {\n-        debug!(\"replace_late_bound_regions_with_nll_infer_vars(mir_def_id={:?})\", mir_def_id);\n         let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n         for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n-            debug!(\"replace_late_bound_regions_with_nll_infer_vars: r={:?}\", r);\n+            debug!(?r);\n             if !indices.indices.contains_key(&r) {\n                 let region_vid = self.next_nll_region_var(FR);\n                 debug!(?region_vid);"}, {"sha": "a2f14e753aebe7ca5cb6bf7b049123f7c746ff5d", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -197,7 +197,7 @@ pub(super) fn op_to_const<'tcx>(\n     }\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub(crate) fn turn_into_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     constant: ConstAlloc<'tcx>,\n@@ -224,10 +224,7 @@ pub(crate) fn turn_into_const_value<'tcx>(\n     );\n \n     // Turn this into a proper constant.\n-    let const_val = op_to_const(&ecx, &mplace.into());\n-    debug!(?const_val);\n-\n-    const_val\n+    op_to_const(&ecx, &mplace.into())\n }\n \n #[instrument(skip(tcx), level = \"debug\")]"}, {"sha": "8b7c3cf3377cc9108bc7a9e9f1f7f4763b35cdf8", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -204,7 +204,7 @@ fn get_info_on_unsized_field<'tcx>(\n     (unsized_inner_ty, num_elems)\n }\n \n-#[instrument(skip(ecx), level = \"debug\")]\n+#[instrument(skip(ecx), level = \"debug\", ret)]\n fn create_pointee_place<'tcx>(\n     ecx: &mut CompileTimeEvalContext<'tcx, 'tcx>,\n     ty: Ty<'tcx>,\n@@ -237,14 +237,11 @@ fn create_pointee_place<'tcx>(\n         let ptr = ecx.allocate_ptr(size, align, MemoryKind::Stack).unwrap();\n         debug!(?ptr);\n \n-        let place = MPlaceTy::from_aligned_ptr_with_meta(\n+        MPlaceTy::from_aligned_ptr_with_meta(\n             ptr.into(),\n             layout,\n             MemPlaceMeta::Meta(Scalar::from_machine_usize(num_elems as u64, &tcx)),\n-        );\n-        debug!(?place);\n-\n-        place\n+        )\n     } else {\n         create_mplace_from_layout(ecx, ty)\n     }\n@@ -253,7 +250,7 @@ fn create_pointee_place<'tcx>(\n /// Converts a `ValTree` to a `ConstValue`, which is needed after mir\n /// construction has finished.\n // FIXME Merge `valtree_to_const_value` and `valtree_into_mplace` into one function\n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(tcx), level = \"debug\", ret)]\n pub fn valtree_to_const_value<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n@@ -294,7 +291,7 @@ pub fn valtree_to_const_value<'tcx>(\n             dump_place(&ecx, place.into());\n             intern_const_alloc_recursive(&mut ecx, InternKind::Constant, &place).unwrap();\n \n-            let const_val = match ty.kind() {\n+            match ty.kind() {\n                 ty::Ref(_, _, _) => {\n                     let ref_place = place.to_ref(&tcx);\n                     let imm =\n@@ -303,10 +300,7 @@ pub fn valtree_to_const_value<'tcx>(\n                     op_to_const(&ecx, &imm.into())\n                 }\n                 _ => op_to_const(&ecx, &place.into()),\n-            };\n-            debug!(?const_val);\n-\n-            const_val\n+            }\n         }\n         ty::Never\n         | ty::Error(_)"}, {"sha": "d1d02ed73f9595a3847d38d96eb8665fc56badbc", "filename": "compiler/rustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FCargo.toml?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n-tracing = { version = \"0.1.28\" }\n+tracing = { version = \"0.1.35\" }\n serde_json = \"1.0.59\"\n rustc_log = { path = \"../rustc_log\" }\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "d4350aa5734dee4aefe5583a5f1e6233d0cf2303", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -391,7 +391,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     fn generalize(\n         &self,\n         ty: Ty<'tcx>,\n@@ -435,15 +435,8 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             cache: SsoHashMap::new(),\n         };\n \n-        let ty = match generalize.relate(ty, ty) {\n-            Ok(ty) => ty,\n-            Err(e) => {\n-                debug!(?e, \"failure\");\n-                return Err(e);\n-            }\n-        };\n+        let ty = generalize.relate(ty, ty)?;\n         let needs_wf = generalize.needs_wf;\n-        trace!(?ty, ?needs_wf, \"success\");\n         Ok(Generalization { ty, needs_wf })\n     }\n \n@@ -499,6 +492,7 @@ struct Generalizer<'cx, 'tcx> {\n /// Result from a generalization operation. This includes\n /// not only the generalized type, but also a bool flag\n /// indicating whether further WF checks are needed.\n+#[derive(Debug)]\n struct Generalization<'tcx> {\n     ty: Ty<'tcx>,\n \n@@ -856,10 +850,9 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn tys(&mut self, t: Ty<'tcx>, _t: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug_assert_eq!(t, _t);\n-        debug!(\"ConstInferUnifier: t={:?}\", t);\n \n         match t.kind() {\n             &ty::Infer(ty::TyVar(vid)) => {\n@@ -883,12 +876,7 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                             .borrow_mut()\n                             .type_variables()\n                             .new_var(self.for_universe, origin);\n-                        let u = self.tcx().mk_ty_var(new_var_id);\n-                        debug!(\n-                            \"ConstInferUnifier: replacing original vid={:?} with new={:?}\",\n-                            vid, u\n-                        );\n-                        Ok(u)\n+                        Ok(self.tcx().mk_ty_var(new_var_id))\n                     }\n                 }\n             }\n@@ -939,7 +927,6 @@ impl<'tcx> TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n         _c: ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, ty::Const<'tcx>> {\n         debug_assert_eq!(c, _c);\n-        debug!(\"ConstInferUnifier: c={:?}\", c);\n \n         match c.kind() {\n             ty::ConstKind::Infer(InferConst::Var(vid)) => {"}, {"sha": "67426fcf0feda6c5a7664772c7dfffd8cd941ae1", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// For more details visit the relevant sections of the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx> + Copy,\n@@ -104,9 +104,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let result = self.tcx.replace_bound_vars_uncached(binder, delegate);\n-        debug!(?next_universe, ?result);\n-        result\n+        debug!(?next_universe);\n+        self.tcx.replace_bound_vars_uncached(binder, delegate)\n     }\n \n     /// See [RegionConstraintCollector::leak_check][1]."}, {"sha": "13b7e8eb9643611e0a5678f9b936250e347ac216", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -333,9 +333,9 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     ///\n     /// Neither `a` nor `b` may be an inference variable (hence the\n     /// term \"concrete regions\").\n-    #[instrument(level = \"trace\", skip(self))]\n+    #[instrument(level = \"trace\", skip(self), ret)]\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n-        let r = match (*a, *b) {\n+        match (*a, *b) {\n             (ReLateBound(..), _) | (_, ReLateBound(..)) | (ReErased, _) | (_, ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n@@ -399,11 +399,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     self.tcx().lifetimes.re_static\n                 }\n             }\n-        };\n-\n-        debug!(\"lub_concrete_regions({:?}, {:?}) = {:?}\", a, b, r);\n-\n-        r\n+        }\n     }\n \n     /// After expansion is complete, go and check upper bounds (i.e.,"}, {"sha": "bb6f6ae60e26ac27c05ad3e59c889122e90d6ef3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -542,7 +542,7 @@ where\n         true\n     }\n \n-    #[instrument(skip(self, info), level = \"trace\")]\n+    #[instrument(skip(self, info), level = \"trace\", ret)]\n     fn relate_with_variance<T: Relate<'tcx>>(\n         &mut self,\n         variance: ty::Variance,\n@@ -560,8 +560,6 @@ where\n \n         self.ambient_variance = old_ambient_variance;\n \n-        debug!(?r);\n-\n         Ok(r)\n     }\n "}, {"sha": "d45adf43abfcc0040f0feeb235604eff4cc422a9", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -390,7 +390,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         });\n     }\n \n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     pub fn opaque_type_origin(&self, def_id: LocalDefId, span: Span) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let parent_def_id = match self.defining_use_anchor {\n@@ -421,16 +421,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         in_definition_scope.then_some(*origin)\n     }\n \n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     fn opaque_ty_origin_unchecked(&self, def_id: LocalDefId, span: Span) -> OpaqueTyOrigin {\n-        let origin = match self.tcx.hir().expect_item(def_id).kind {\n+        match self.tcx.hir().expect_item(def_id).kind {\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n             ref itemkind => {\n                 span_bug!(span, \"weird opaque type: {:?}, {:#?}\", def_id, itemkind)\n             }\n-        };\n-        trace!(?origin);\n-        origin\n+        }\n     }\n }\n "}, {"sha": "4d124554afb94d3bb119275e9c415932dbc8131b", "filename": "compiler/rustc_infer/src/infer/opaque_types/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types%2Ftable.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> OpaqueTypeStorage<'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\")]\n+    #[instrument(level = \"debug\", ret)]\n     pub fn take_opaque_types(&mut self) -> OpaqueTypeMap<'tcx> {\n         std::mem::take(&mut self.opaque_types)\n     }"}, {"sha": "2d19d1823fdfc2b04816cde419dd59aa3361009b", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -9,7 +9,7 @@ pub mod verify;\n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty;\n \n-#[instrument(level = \"debug\", skip(param_env))]\n+#[instrument(level = \"debug\", skip(param_env), ret)]\n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {"}, {"sha": "f3676604bb0e64b34b6d6d6e38eea52be4768683", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -2267,7 +2267,7 @@ impl<'tcx> ConstantKind<'tcx> {\n         Self::from_opt_const_arg_anon_const(tcx, ty::WithOptConstParam::unknown(def_id), param_env)\n     }\n \n-    #[instrument(skip(tcx), level = \"debug\")]\n+    #[instrument(skip(tcx), level = \"debug\", ret)]\n     pub fn from_inline_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Self {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = match tcx.hir().get(hir_id) {\n@@ -2305,21 +2305,18 @@ impl<'tcx> ConstantKind<'tcx> {\n         let substs =\n             ty::InlineConstSubsts::new(tcx, ty::InlineConstSubstsParts { parent_substs, ty })\n                 .substs;\n-        let uneval_const = tcx.mk_const(ty::ConstS {\n+        debug_assert!(!substs.has_free_regions());\n+        Self::Ty(tcx.mk_const(ty::ConstS {\n             kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                 def: ty::WithOptConstParam::unknown(def_id).to_global(),\n                 substs,\n                 promoted: None,\n             }),\n             ty,\n-        });\n-        debug!(?uneval_const);\n-        debug_assert!(!uneval_const.has_free_regions());\n-\n-        Self::Ty(uneval_const)\n+        }))\n     }\n \n-    #[instrument(skip(tcx), level = \"debug\")]\n+    #[instrument(skip(tcx), level = \"debug\", ret)]\n     fn from_opt_const_arg_anon_const(\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n@@ -2402,24 +2399,21 @@ impl<'tcx> ConstantKind<'tcx> {\n \n         match tcx.const_eval_resolve(param_env, uneval, Some(span)) {\n             Ok(val) => {\n-                debug!(\"evaluated const value: {:?}\", val);\n+                debug!(\"evaluated const value\");\n                 Self::Val(val, ty)\n             }\n             Err(_) => {\n                 debug!(\"error encountered during evaluation\");\n                 // Error was handled in `const_eval_resolve`. Here we just create a\n                 // new unevaluated const and error hard later in codegen\n-                let ty_const = tcx.mk_const(ty::ConstS {\n+                Self::Ty(tcx.mk_const(ty::ConstS {\n                     kind: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                         def: def.to_global(),\n                         substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n                         promoted: None,\n                     }),\n                     ty,\n-                });\n-                debug!(?ty_const);\n-\n-                Self::Ty(ty_const)\n+                }))\n             }\n         }\n     }"}, {"sha": "2eb5cffa6bc44360a25dc9cb7f578ac7addc31ff", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -65,8 +65,6 @@ impl<'tcx> Const<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def: ty::WithOptConstParam<LocalDefId>,\n     ) -> Self {\n-        debug!(\"Const::from_anon_const(def={:?})\", def);\n-\n         let body_id = match tcx.hir().get_by_def_id(def.did) {\n             hir::Node::AnonConst(ac) => ac.body,\n             _ => span_bug!("}, {"sha": "cb46a9dba579fd6d40a75e0b835cba021d2a7661", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         t\n     }\n \n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, _) if debruijn < self.current_index => {"}, {"sha": "cac8560ce1c320229dfe789a27695b039160ab26", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -188,13 +188,11 @@ struct NormalizeAfterErasingRegionsFolder<'tcx> {\n }\n \n impl<'tcx> NormalizeAfterErasingRegionsFolder<'tcx> {\n-    #[instrument(skip(self), level = \"debug\")]\n     fn normalize_generic_arg_after_erasing_regions(\n         &self,\n         arg: ty::GenericArg<'tcx>,\n     ) -> ty::GenericArg<'tcx> {\n         let arg = self.param_env.and(arg);\n-        debug!(?arg);\n \n         self.tcx.try_normalize_generic_arg_after_erasing_regions(arg).unwrap_or_else(|_| bug!(\n                 \"Failed to normalize {:?}, maybe try to call `try_normalize_erasing_regions` instead\","}, {"sha": "ac79949fca5cc40d7ed5391e8e96557ff459e36d", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -256,7 +256,6 @@ pub(super) fn trait_impls_of_provider(tcx: TyCtxt<'_>, trait_id: DefId) -> Trait\n }\n \n // Query provider for `incoherent_impls`.\n-#[instrument(level = \"debug\", skip(tcx))]\n pub(super) fn incoherent_impls_provider(tcx: TyCtxt<'_>, simp: SimplifiedType) -> &[DefId] {\n     let mut impls = Vec::new();\n "}, {"sha": "a3837512bce2652c1155ca2672e06bcb1cd07bdb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -627,7 +627,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Expands the given impl trait type, stopping if the type is recursive.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     pub fn try_expand_impl_trait_type(\n         self,\n         def_id: DefId,\n@@ -644,7 +644,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         let expanded_type = visitor.expand_opaque_ty(def_id, substs).unwrap();\n-        trace!(?expanded_type);\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n "}, {"sha": "5e042c3acfce25897621b4b4215df93554a266ed", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -84,7 +84,7 @@ pub trait TypeVisitable<'tcx>: fmt::Debug + Clone {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n-    #[instrument(level = \"trace\")]\n+    #[instrument(level = \"trace\", ret)]\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n         self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n     }\n@@ -560,7 +560,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     type BreakTy = FoundFlags;\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = t.flags();\n         trace!(t.flags=?t.flags());\n@@ -572,7 +572,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(skip(self), level = \"trace\")]\n+    #[instrument(skip(self), level = \"trace\", ret)]\n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = r.type_flags();\n         trace!(r.flags=?flags);\n@@ -584,7 +584,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n+    #[instrument(level = \"trace\", ret)]\n     fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_const(c);\n         trace!(r.flags=?flags);\n@@ -596,7 +596,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n+    #[instrument(level = \"trace\", ret)]\n     fn visit_unevaluated(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let flags = FlagComputation::for_unevaluated_const(uv);\n         trace!(r.flags=?flags);\n@@ -608,7 +608,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n     }\n \n     #[inline]\n-    #[instrument(level = \"trace\")]\n+    #[instrument(level = \"trace\", ret)]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\n             \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\","}, {"sha": "210d77c66e7002ff4928a9f26e45af4fee5117c8", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -19,21 +19,18 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n     /// Converts an evaluated constant to a pattern (if possible).\n     /// This means aggregate values (like structs and enums) are converted\n     /// to a pattern that matches the value (as if you'd compared via structural equality).\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn const_to_pat(\n         &self,\n         cv: mir::ConstantKind<'tcx>,\n         id: hir::HirId,\n         span: Span,\n         mir_structural_match_violation: bool,\n     ) -> Pat<'tcx> {\n-        let pat = self.tcx.infer_ctxt().enter(|infcx| {\n+        self.tcx.infer_ctxt().enter(|infcx| {\n             let mut convert = ConstToPat::new(self, id, span, infcx);\n             convert.to_pat(cv, mir_structural_match_violation)\n-        });\n-\n-        debug!(?pat);\n-        pat\n+        })\n     }\n }\n "}, {"sha": "319183eb9b33fc7e0a81f15cedd6f87cd641ad88", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -791,7 +791,7 @@ fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n /// `is_under_guard` is used to inform if the pattern has a guard. If it\n /// has one it must not be inserted into the matrix. This shouldn't be\n /// relied on for soundness.\n-#[instrument(level = \"debug\", skip(cx, matrix, hir_id))]\n+#[instrument(level = \"debug\", skip(cx, matrix, hir_id), ret)]\n fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n@@ -917,7 +917,6 @@ fn is_useful<'p, 'tcx>(\n         v.head().set_reachable();\n     }\n \n-    debug!(?ret);\n     ret\n }\n "}, {"sha": "6ec5e9e113d1b4b85f6134c36fc1e4e75c89e529", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -419,7 +419,6 @@ fn collect_items_rec<'tcx>(\n         // We've been here already, no need to search again.\n         return;\n     }\n-    debug!(\"BEGIN collect_items_rec({})\", starting_point.node);\n \n     let mut neighbors = MonoItems { compute_inlining: true, tcx, items: Vec::new() };\n     let recursion_depth_reset;\n@@ -545,8 +544,6 @@ fn collect_items_rec<'tcx>(\n     if let Some((def_id, depth)) = recursion_depth_reset {\n         recursion_depths.insert(def_id, depth);\n     }\n-\n-    debug!(\"END collect_items_rec({})\", starting_point.node);\n }\n \n /// Format instance name that is already known to be too long for rustc.\n@@ -1148,23 +1145,18 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     }\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(tcx), level = \"debug\", ret)]\n fn create_fn_mono_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: Instance<'tcx>,\n     source: Span,\n ) -> Spanned<MonoItem<'tcx>> {\n-    debug!(\"create_fn_mono_item(instance={})\", instance);\n-\n     let def_id = instance.def_id();\n     if tcx.sess.opts.unstable_opts.profile_closures && def_id.is_local() && tcx.is_closure(def_id) {\n         crate::util::dump_closure_profile(tcx, instance);\n     }\n \n-    let respanned = respan(source, MonoItem::Fn(instance.polymorphize(tcx)));\n-    debug!(?respanned);\n-\n-    respanned\n+    respan(source, MonoItem::Fn(instance.polymorphize(tcx)))\n }\n \n /// Creates a `MonoItem` for each method that is referenced by the vtable for\n@@ -1309,7 +1301,7 @@ impl<'v> RootCollector<'_, 'v> {\n     #[instrument(skip(self), level = \"debug\")]\n     fn push_if_root(&mut self, def_id: LocalDefId) {\n         if self.is_root(def_id) {\n-            debug!(\"RootCollector::push_if_root: found root def_id={:?}\", def_id);\n+            debug!(\"found root\");\n \n             let instance = Instance::mono(self.tcx, def_id.to_def_id());\n             self.output.push(create_fn_mono_item(self.tcx, instance, DUMMY_SP));"}, {"sha": "af4b35db3bace8bbaefb9b7808e01bd05aaf75ed", "filename": "compiler/rustc_monomorphize/src/polymorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpolymorphize.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -33,7 +33,6 @@ pub fn provide(providers: &mut Providers) {\n ///\n /// Returns a bitset where bits representing unused parameters are set (`is_empty` indicates all\n /// parameters are used).\n-#[instrument(level = \"debug\", skip(tcx))]\n fn unused_generic_params<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,"}, {"sha": "eabb316614747365eb4f1373bd2383aabca814f1", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -555,7 +555,7 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*\n             #[inline(always)]\n-            #[tracing::instrument(level = \"trace\", skip(self, tcx))]\n+            #[tracing::instrument(level = \"trace\", skip(self, tcx), ret)]\n             fn $name(\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,"}, {"sha": "4d94c92d3f2b182ce8521d059210527bf784d62d", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -1059,13 +1059,13 @@ impl FilePathMapping {\n \n         return remap_path_prefix(&self.mapping, path);\n \n-        #[instrument(level = \"debug\", skip(mapping))]\n+        #[instrument(level = \"debug\", skip(mapping), ret)]\n         fn remap_path_prefix(mapping: &[(PathBuf, PathBuf)], path: PathBuf) -> (PathBuf, bool) {\n             // NOTE: We are iterating over the mapping entries from last to first\n             //       because entries specified later on the command line should\n             //       take precedence.\n             for &(ref from, ref to) in mapping.iter().rev() {\n-                debug!(\"Trying to apply {:?} => {:?}\", from, to);\n+                debug!(\"Trying to apply {from:?} => {to:?}\");\n \n                 if let Ok(rest) = path.strip_prefix(from) {\n                     let remapped = if rest.as_os_str().is_empty() {\n@@ -1079,15 +1079,15 @@ impl FilePathMapping {\n                     } else {\n                         to.join(rest)\n                     };\n-                    debug!(\"Match - remapped {:?} => {:?}\", path, remapped);\n+                    debug!(\"Match - remapped\");\n \n                     return (remapped, true);\n                 } else {\n-                    debug!(\"No match - prefix {:?} does not match {:?}\", from, path);\n+                    debug!(\"No match - prefix {from:?} does not match\");\n                 }\n             }\n \n-            debug!(\"Path {:?} was not remapped\", path);\n+            debug!(\"not remapped\");\n             (path, false)\n         }\n     }"}, {"sha": "26f8e7d34c6eac056f1b06a4563b0e7c33497906", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -18,7 +18,6 @@ use rustc_middle::ty::{self, TyCtxt};\n /// obligations *could be* resolved if we wanted to.\n ///\n /// This also expects that `trait_ref` is fully normalized.\n-#[instrument(level = \"debug\", skip(tcx))]\n pub fn codegen_fulfill_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n@@ -74,7 +73,6 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n         let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-        debug!(\"Cache miss: {trait_ref:?} => {impl_source:?}\");\n         Ok(&*tcx.arena.alloc(impl_source))\n     })\n }"}, {"sha": "e84c462ca816195e39badb321ed16c0a2135404b", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -28,7 +28,7 @@ use super::SelectionCandidate::{self, *};\n use super::{EvaluatedCandidate, SelectionCandidateSet, SelectionContext, TraitObligationStack};\n \n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub(super) fn candidate_from_obligation<'o>(\n         &mut self,\n         stack: &TraitObligationStack<'o, 'tcx>,\n@@ -48,7 +48,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         if let Some(c) =\n             self.check_candidate_cache(stack.obligation.param_env, cache_fresh_trait_pred)\n         {\n-            debug!(candidate = ?c, \"CACHE HIT\");\n+            debug!(\"CACHE HIT\");\n             return c;\n         }\n \n@@ -61,7 +61,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let (candidate, dep_node) =\n             self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n \n-        debug!(?candidate, \"CACHE MISS\");\n+        debug!(\"CACHE MISS\");\n         self.insert_candidate_cache(\n             stack.obligation.param_env,\n             cache_fresh_trait_pred,"}, {"sha": "5da8cfab0b13b77102197cf235c3503b1cef9533", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -295,7 +295,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Attempts to satisfy the obligation. If successful, this will affect the surrounding\n     /// type environment by performing unification.\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn select(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -325,10 +325,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Err(SelectionError::Overflow(OverflowError::Canonical))\n             }\n             Err(e) => Err(e),\n-            Ok(candidate) => {\n-                debug!(?candidate, \"confirmed\");\n-                Ok(Some(candidate))\n-            }\n+            Ok(candidate) => Ok(Some(candidate)),\n         }\n     }\n \n@@ -435,6 +432,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         level = \"debug\",\n         skip(self, previous_stack),\n         fields(previous_stack = ?previous_stack.head())\n+        ret,\n     )]\n     fn evaluate_predicate_recursively<'o>(\n         &mut self,\n@@ -450,7 +448,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             None => self.check_recursion_limit(&obligation, &obligation)?,\n         }\n \n-        let result = ensure_sufficient_stack(|| {\n+        ensure_sufficient_stack(|| {\n             let bound_predicate = obligation.predicate.kind();\n             match bound_predicate.skip_binder() {\n                 ty::PredicateKind::Trait(t) => {\n@@ -760,14 +758,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n             }\n-        });\n-\n-        debug!(\"finished: {:?} from {:?}\", result, obligation);\n-\n-        result\n+        })\n     }\n \n-    #[instrument(skip(self, previous_stack), level = \"debug\")]\n+    #[instrument(skip(self, previous_stack), level = \"debug\", ret)]\n     fn evaluate_trait_predicate_recursively<'o>(\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n@@ -798,12 +792,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If a trait predicate is in the (local or global) evaluation cache,\n         // then we know it holds without cycles.\n         if let Some(result) = self.check_evaluation_cache(param_env, fresh_trait_pred) {\n-            debug!(?result, \"CACHE HIT\");\n+            debug!(\"CACHE HIT\");\n             return Ok(result);\n         }\n \n         if let Some(result) = stack.cache().get_provisional(fresh_trait_pred) {\n-            debug!(?result, \"PROVISIONAL CACHE HIT\");\n+            debug!(\"PROVISIONAL CACHE HIT\");\n             stack.update_reached_depth(result.reached_depth);\n             return Ok(result.result);\n         }\n@@ -826,11 +820,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let reached_depth = stack.reached_depth.get();\n         if reached_depth >= stack.depth {\n-            debug!(?result, \"CACHE MISS\");\n+            debug!(\"CACHE MISS\");\n             self.insert_evaluation_cache(param_env, fresh_trait_pred, dep_node, result);\n             stack.cache().on_completion(stack.dfn);\n         } else {\n-            debug!(?result, \"PROVISIONAL\");\n+            debug!(\"PROVISIONAL\");\n             debug!(\n                 \"caching provisionally because {:?} \\\n                  is a cycle participant (at depth {}, reached depth {})\",\n@@ -1023,7 +1017,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     #[instrument(\n         level = \"debug\",\n         skip(self, stack),\n-        fields(depth = stack.obligation.recursion_depth)\n+        fields(depth = stack.obligation.recursion_depth),\n+        ret\n     )]\n     fn evaluate_candidate<'o>(\n         &mut self,\n@@ -1056,7 +1051,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             result = result.max(EvaluatedToOkModuloRegions);\n         }\n \n-        debug!(?result);\n         Ok(result)\n     }\n \n@@ -1405,7 +1399,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// a projection, look at the bounds of `T::Bar`, see if we can find a\n     /// `Baz` bound. We return indexes into the list returned by\n     /// `tcx.item_bounds` for any applicable bounds.\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n@@ -1435,7 +1429,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // unnecessary ambiguity.\n         let mut distinct_normalized_bounds = FxHashSet::default();\n \n-        let matching_bounds = bounds\n+        bounds\n             .iter()\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n@@ -1462,10 +1456,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 None\n             })\n-            .collect();\n-\n-        debug!(?matching_bounds);\n-        matching_bounds\n+            .collect()\n     }\n \n     /// Equates the trait in `obligation` with trait bound. If the two traits\n@@ -2153,7 +2144,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn match_impl(\n         &mut self,\n         impl_def_id: DefId,\n@@ -2194,17 +2185,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .at(&cause, obligation.param_env)\n             .define_opaque_types(false)\n             .eq(placeholder_obligation_trait_ref, impl_trait_ref)\n-            .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{}`\", e))?;\n+            .map_err(|e| debug!(\"match_impl: failed eq_trait_refs due to `{e}`\"))?;\n         nested_obligations.extend(obligations);\n \n         if !self.intercrate\n             && self.tcx().impl_polarity(impl_def_id) == ty::ImplPolarity::Reservation\n         {\n-            debug!(\"match_impl: reservation impls only apply in intercrate mode\");\n+            debug!(\"reservation impls only apply in intercrate mode\");\n             return Err(());\n         }\n \n-        debug!(?impl_substs, ?nested_obligations, \"match_impl: success\");\n         Ok(Normalized { value: impl_substs, obligations: nested_obligations })\n     }\n "}, {"sha": "bb6009cb22a37b2df733bb9019e164eae8d5288b", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -841,7 +841,7 @@ pub fn object_region_bounds<'tcx>(\n ///\n /// Requires that trait definitions have been processed so that we can\n /// elaborate predicates and walk supertraits.\n-#[instrument(skip(tcx, predicates), level = \"debug\")]\n+#[instrument(skip(tcx, predicates), level = \"debug\", ret)]\n pub(crate) fn required_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     erased_self_ty: Ty<'tcx>,"}, {"sha": "9d640672cf92c8cd3bc2f7cc861c931a71b3edb7", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -104,7 +104,6 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n }\n \n /// See `ParamEnv` struct definition for details.\n-#[instrument(level = \"debug\", skip(tcx))]\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     // The param_env of an impl Trait type is its defining function's param_env\n     if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n@@ -410,7 +409,6 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n }\n \n /// Don't call this directly: use ``tcx.conservative_is_privately_uninhabited`` instead.\n-#[instrument(level = \"debug\", skip(tcx))]\n pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     param_env_and: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,"}, {"sha": "ef927058df4eef0781c1c7a512921844d540b2c9", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -144,7 +144,7 @@ enum ConvertedBindingKind<'a, 'tcx> {\n /// instantiated with some generic arguments providing `'a` explicitly,\n /// we taint those arguments with `ExplicitLateBound::Yes` so that we\n /// can provide an appropriate diagnostic later.\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ExplicitLateBound {\n     Yes,\n     No,\n@@ -167,7 +167,7 @@ pub(crate) enum GenericArgPosition {\n \n /// A marker denoting that the generic arguments that were\n /// provided did not match the respective generic parameters.\n-#[derive(Clone, Default)]\n+#[derive(Clone, Default, Debug)]\n pub struct GenericArgCountMismatch {\n     /// Indicates whether a fatal error was reported (`Some`), or just a lint (`None`).\n     pub reported: Option<ErrorGuaranteed>,\n@@ -177,7 +177,7 @@ pub struct GenericArgCountMismatch {\n \n /// Decorates the result of a generic argument count mismatch\n /// check with whether explicit late bounds were provided.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct GenericArgCountResult {\n     pub explicit_late_bound: ExplicitLateBound,\n     pub correct: Result<(), GenericArgCountMismatch>,\n@@ -201,7 +201,7 @@ pub trait CreateSubstsForGenericArgsCtxt<'a, 'tcx> {\n }\n \n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn ast_region_to_region(\n         &self,\n         lifetime: &hir::Lifetime,\n@@ -210,7 +210,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let tcx = self.tcx();\n         let lifetime_name = |def_id| tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id));\n \n-        let r = match tcx.named_region(lifetime.hir_id) {\n+        match tcx.named_region(lifetime.hir_id) {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n \n             Some(rl::Region::LateBound(debruijn, index, def_id)) => {\n@@ -255,9 +255,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     tcx.lifetimes.re_static\n                 })\n             }\n-        };\n-        debug!(\"ast_region_to_region(lifetime={:?}) yields {:?}\", lifetime, r);\n-        r\n+        }\n     }\n \n     /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n@@ -317,7 +315,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// `[Vec<u8>, u8]` and `generic_args` are the arguments for the associated\n     /// type itself: `['a]`. The returned `SubstsRef` concatenates these two\n     /// lists: `[Vec<u8>, u8, 'a]`.\n-    #[instrument(level = \"debug\", skip(self, span))]\n+    #[instrument(level = \"debug\", skip(self, span), ret)]\n     fn create_substs_for_ast_path<'a>(\n         &self,\n         span: Span,\n@@ -537,11 +535,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             &mut substs_ctx,\n         );\n \n-        debug!(\n-            \"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n-            generics, self_ty, substs\n-        );\n-\n         (substs, arg_count)\n     }\n \n@@ -2596,7 +2589,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     /// Turns a `hir::Ty` into a `Ty`. For diagnostics' purposes we keep track of whether trait\n     /// objects are borrowed like `&dyn Trait` to avoid emitting redundant errors.\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     fn ast_ty_to_ty_inner(&self, ast_ty: &hir::Ty<'_>, borrowed: bool, in_path: bool) -> Ty<'tcx> {\n         let tcx = self.tcx();\n \n@@ -2700,8 +2693,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Err => tcx.ty_error(),\n         };\n \n-        debug!(?result_ty);\n-\n         self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);\n         result_ty\n     }"}, {"sha": "25bafdfe859b882af75dee0a021595a9db8f7670", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -12,7 +12,7 @@ use rustc_trait_selection::traits::{\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n@@ -212,9 +212,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // We won't diverge unless the scrutinee or all arms diverge.\n         self.diverges.set(scrut_diverges | all_arms_diverge);\n \n-        let match_ty = coercion.complete(self);\n-        debug!(?match_ty);\n-        match_ty\n+        coercion.complete(self)\n     }\n \n     /// When the previously checked expression (the scrutinee) diverges,"}, {"sha": "bc3fec6e7d66a371dc57dfb0fd8a0039a30838fa", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.check_closure(expr, expected_kind, decl, body, gen, expected_sig)\n     }\n \n-    #[instrument(skip(self, expr, body, decl), level = \"debug\")]\n+    #[instrument(skip(self, expr, body, decl), level = \"debug\", ret)]\n     fn check_closure(\n         &self,\n         expr: &hir::Expr<'_>,\n@@ -158,11 +158,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         );\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id.to_def_id(), closure_substs.substs);\n-\n-        debug!(?expr.hir_id, ?closure_type);\n-\n-        closure_type\n+        self.tcx.mk_closure(expr_def_id.to_def_id(), closure_substs.substs)\n     }\n \n     /// Given the expected type, figures out what it can about this closure we\n@@ -262,7 +258,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// The `cause_span` should be the span that caused us to\n     /// have this expected signature, or `None` if we can't readily\n     /// know that.\n-    #[instrument(level = \"debug\", skip(self, cause_span))]\n+    #[instrument(level = \"debug\", skip(self, cause_span), ret)]\n     fn deduce_sig_from_projection(\n         &self,\n         cause_span: Option<Span>,\n@@ -317,7 +313,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir::Unsafety::Normal,\n             Abi::Rust,\n         ));\n-        debug!(?sig);\n \n         Some(ExpectedSig { cause_span, sig })\n     }\n@@ -576,7 +571,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// types that the user gave into a signature.\n     ///\n     /// Also, record this closure signature for later.\n-    #[instrument(skip(self, decl, body), level = \"debug\")]\n+    #[instrument(skip(self, decl, body), level = \"debug\", ret)]\n     fn supplied_sig_of_closure(\n         &self,\n         hir_id: hir::HirId,\n@@ -629,8 +624,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             bound_vars,\n         );\n \n-        debug!(?result);\n-\n         let c_result = self.inh.infcx.canonicalize_response(result);\n         self.typeck_results.borrow_mut().user_provided_sigs.insert(expr_def_id, c_result);\n \n@@ -643,7 +636,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// user specified. The \"desugared\" return type is an `impl\n     /// Future<Output = T>`, so we do this by searching through the\n     /// obligations to extract the `T`.\n-    #[instrument(skip(self), level = \"debug\")]\n+    #[instrument(skip(self), level = \"debug\", ret)]\n     fn deduce_future_output_from_obligations(\n         &self,\n         expr_def_id: DefId,\n@@ -704,7 +697,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         self.register_predicates(obligations);\n \n-        debug!(\"deduce_future_output_from_obligations: output_ty={:?}\", output_ty);\n         Some(output_ty)\n     }\n "}, {"sha": "66b737a493058861a7b36928ba4295eeb1b2ff8a", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -83,7 +83,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.resolve_vars_with_obligations_and_mutate_fulfillment(ty, |_| {})\n     }\n \n-    #[instrument(skip(self, mutate_fulfillment_errors), level = \"debug\")]\n+    #[instrument(skip(self, mutate_fulfillment_errors), level = \"debug\", ret)]\n     pub(in super::super) fn resolve_vars_with_obligations_and_mutate_fulfillment(\n         &self,\n         mut ty: Ty<'tcx>,\n@@ -107,10 +107,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         self.select_obligations_where_possible(false, mutate_fulfillment_errors);\n-        ty = self.resolve_vars_if_possible(ty);\n-\n-        debug!(?ty);\n-        ty\n+        self.resolve_vars_if_possible(ty)\n     }\n \n     pub(in super::super) fn record_deferred_call_resolution("}, {"sha": "a9071cd1fd949efe57c2bfd122425fb0b5277dd7", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * `call_expr`:             the complete method call: (`foo.bar::<T1,...Tn>(...)`)\n     /// * `self_expr`:             the self expression (`foo`)\n     /// * `args`:                  the expressions of the arguments (`a, b + 1, ...`)\n-    #[instrument(level = \"debug\", skip(self, call_expr, self_expr))]\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn lookup_method(\n         &self,\n         self_ty: Ty<'tcx>,\n@@ -178,11 +178,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_expr: &'tcx hir::Expr<'tcx>,\n         args: &'tcx [hir::Expr<'tcx>],\n     ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n-        debug!(\n-            \"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n-            segment.ident, self_ty, call_expr, self_expr\n-        );\n-\n         let pick =\n             self.lookup_probe(span, segment.ident, self_ty, call_expr, ProbeScope::TraitsInScope)?;\n \n@@ -383,7 +378,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// In particular, it doesn't really do any probing: it simply constructs\n     /// an obligation for a particular trait with the given self type and checks\n     /// whether that trait is implemented.\n-    #[instrument(level = \"debug\", skip(self, span, opt_input_types))]\n+    #[instrument(level = \"debug\", skip(self, span))]\n     pub(super) fn lookup_method_in_trait(\n         &self,\n         span: Span,\n@@ -392,11 +387,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         opt_input_types: Option<&[Ty<'tcx>]>,\n     ) -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        debug!(\n-            \"lookup_in_trait_adjusted(self_ty={:?}, m_name={}, trait_def_id={:?}, opt_input_types={:?})\",\n-            self_ty, m_name, trait_def_id, opt_input_types\n-        );\n-\n         let (obligation, substs) =\n             self.obligation_for_method(span, trait_def_id, self_ty, opt_input_types);\n         self.construct_obligation_for_trait(\n@@ -576,7 +566,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// * `self_ty`:               the type to search within (`Foo`)\n     /// * `self_ty_span`           the span for the type being searched within (span of `Foo`)\n     /// * `expr_id`:               the [`hir::HirId`] of the expression composing the entire call\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self), ret)]\n     pub fn resolve_fully_qualified_call(\n         &self,\n         span: Span,\n@@ -585,11 +575,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty_span: Span,\n         expr_id: hir::HirId,\n     ) -> Result<(DefKind, DefId), MethodError<'tcx>> {\n-        debug!(\n-            \"resolve_fully_qualified_call: method_name={:?} self_ty={:?} expr_id={:?}\",\n-            method_name, self_ty, expr_id,\n-        );\n-\n         let tcx = self.tcx;\n \n         // Check if we have an enum variant.\n@@ -633,21 +618,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             &pick,\n         );\n \n-        debug!(\"resolve_fully_qualified_call: pick={:?}\", pick);\n+        debug!(?pick);\n         {\n             let mut typeck_results = self.typeck_results.borrow_mut();\n             let used_trait_imports = Lrc::get_mut(&mut typeck_results.used_trait_imports).unwrap();\n             for import_id in pick.import_ids {\n-                debug!(\"resolve_fully_qualified_call: used_trait_import: {:?}\", import_id);\n+                debug!(used_trait_import=?import_id);\n                 used_trait_imports.insert(import_id);\n             }\n         }\n \n         let def_kind = pick.item.kind.as_def_kind();\n-        debug!(\n-            \"resolve_fully_qualified_call: def_kind={:?}, def_id={:?}\",\n-            def_kind, pick.item.def_id\n-        );\n         tcx.check_stability(pick.item.def_id, Some(expr_id), span, Some(method_name.span));\n         Ok((def_kind, pick.item.def_id))\n     }"}, {"sha": "e9f55ab3406f5df2ea9bc49c8e34985b479c36df", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// would result in an error (basically, the same criteria we\n     /// would use to decide if a method is a plausible fit for\n     /// ambiguity purposes).\n-    #[instrument(level = \"debug\", skip(self, scope_expr_id))]\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn probe_for_return_type(\n         &self,\n         span: Span,\n@@ -262,10 +262,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n     ) -> Vec<ty::AssocItem> {\n-        debug!(\n-            \"probe(self_ty={:?}, return_type={}, scope_expr_id={})\",\n-            self_ty, return_type, scope_expr_id\n-        );\n         let method_names = self\n             .probe_op(\n                 span,\n@@ -299,7 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .collect()\n     }\n \n-    #[instrument(level = \"debug\", skip(self, scope_expr_id))]\n+    #[instrument(level = \"debug\", skip(self))]\n     pub fn probe_for_name(\n         &self,\n         span: Span,\n@@ -310,10 +306,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         scope_expr_id: hir::HirId,\n         scope: ProbeScope,\n     ) -> PickResult<'tcx> {\n-        debug!(\n-            \"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n-            self_ty, item_name, scope_expr_id\n-        );\n         self.probe_op(\n             span,\n             mode,"}, {"sha": "66281448d40e88e6c5c45217b5d0183501de1281", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -341,7 +341,6 @@ fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::T\n     typeck_with_fallback(tcx, def_id, fallback)\n }\n \n-#[instrument(skip(tcx, fallback))]\n fn typeck_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,"}, {"sha": "9f931de6fdedb674b11b6fff3724a49c5b4a361a", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -19,7 +19,6 @@ use crate::errors::UnconstrainedOpaqueType;\n /// Computes the relevant generic parameter for a potential generic const argument.\n ///\n /// This should be called using the query `tcx.opt_const_param_of`.\n-#[instrument(level = \"debug\", skip(tcx))]\n pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n     use hir::*;\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);"}, {"sha": "c27f0ce18c1414d027453b4e8d2799105c980cfa", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=1fc9ef1edd30ae5a924c3673d76f275f7d12c3fb", "patch": "@@ -750,7 +750,7 @@ fn resolve_associated_trait_item<'a>(\n ///\n /// This is just a wrapper around [`TyCtxt::impl_item_implementor_ids()`] and\n /// [`TyCtxt::associated_item()`] (with some helpful logging added).\n-#[instrument(level = \"debug\", skip(tcx))]\n+#[instrument(level = \"debug\", skip(tcx), ret)]\n fn trait_assoc_to_impl_assoc_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     impl_id: DefId,\n@@ -760,9 +760,7 @@ fn trait_assoc_to_impl_assoc_item<'tcx>(\n     debug!(?trait_to_impl_assoc_map);\n     let impl_assoc_id = *trait_to_impl_assoc_map.get(&trait_assoc_id)?;\n     debug!(?impl_assoc_id);\n-    let impl_assoc = tcx.associated_item(impl_assoc_id);\n-    debug!(?impl_assoc);\n-    Some(impl_assoc)\n+    Some(tcx.associated_item(impl_assoc_id))\n }\n \n /// Given a type, return all trait impls in scope in `module` for that type."}]}