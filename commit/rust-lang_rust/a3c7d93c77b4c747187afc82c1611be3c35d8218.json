{"sha": "a3c7d93c77b4c747187afc82c1611be3c35d8218", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzYzdkOTNjNzdiNGM3NDcxODdhZmM4MmMxNjExYmUzYzM1ZDgyMTg=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-29T22:08:12Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-06-29T22:08:12Z"}, "message": "Get rid of basically all of the remaining old style vecs in tests.", "tree": {"sha": "421eda9bd6d36a6c59b06cc6727116985cff6cda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/421eda9bd6d36a6c59b06cc6727116985cff6cda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3c7d93c77b4c747187afc82c1611be3c35d8218", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3c7d93c77b4c747187afc82c1611be3c35d8218", "html_url": "https://github.com/rust-lang/rust/commit/a3c7d93c77b4c747187afc82c1611be3c35d8218", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3c7d93c77b4c747187afc82c1611be3c35d8218/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf5fef0e59f205074f46934f0fe10cc7ef1c04a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf5fef0e59f205074f46934f0fe10cc7ef1c04a", "html_url": "https://github.com/rust-lang/rust/commit/3bf5fef0e59f205074f46934f0fe10cc7ef1c04a"}], "stats": {"total": 189, "additions": 102, "deletions": 87}, "files": [{"sha": "285108d6e7603b4b94a1521b73ea04444d219f6f", "filename": "doc/rust.md", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/a3c7d93c77b4c747187afc82c1611be3c35d8218/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3c7d93c77b4c747187afc82c1611be3c35d8218/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=a3c7d93c77b4c747187afc82c1611be3c35d8218", "patch": "@@ -1006,12 +1006,12 @@ declared, in an angle-bracket-enclosed, comma-separated list following\n the function name.\n \n ~~~~\n-fn iter<T>(seq: [T], f: fn(T)) {\n+fn iter<T>(seq: ~[T], f: fn(T)) {\n     for seq.each {|elt| f(elt); }\n }\n-fn map<T, U>(seq: [T], f: fn(T) -> U) -> [U] {\n-    let mut acc = [];\n-    for seq.each {|elt| acc += [f(elt)]; }\n+fn map<T, U>(seq: ~[T], f: fn(T) -> U) -> ~[U] {\n+    let mut acc = ~[];\n+    for seq.each {|elt| vec::push(acc, f(elt)); }\n     acc\n }\n ~~~~\n@@ -1048,14 +1048,14 @@ same as any other Rust function, except that they are prepended with the\n `extern` keyword.\n \n ~~~\n-extern fn new_vec() -> [int] { [] }\n+extern fn new_vec() -> ~[int] { ~[] }\n ~~~\n \n Extern functions may not be called from Rust code, but their value\n may be taken as an unsafe `u8` pointer.\n \n ~~~\n-# extern fn new_vec() -> [int] { [] }\n+# extern fn new_vec() -> ~[int] { ~[] }\n let fptr: *u8 = new_vec;\n ~~~\n \n@@ -1289,7 +1289,7 @@ specified, after the `impl` keyword.\n ~~~~\n # iface seq<T> { }\n \n-impl <T> of seq<T> for [T] {\n+impl <T> of seq<T> for ~[T] {\n     /* ... */\n }\n impl of seq<bool> for u32 {\n@@ -1615,9 +1615,9 @@ indicate that the elements of the resulting vector may be mutated.\n When no mutability is specified, the vector is immutable.\n \n ~~~~\n-[1, 2, 3, 4];\n-[\"a\", \"b\", \"c\", \"d\"];\n-[mut 0u8, 0u8, 0u8, 0u8];\n+~[1, 2, 3, 4];\n+~[\"a\", \"b\", \"c\", \"d\"];\n+~[mut 0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n ### Index expressions\n@@ -1640,9 +1640,9 @@ task in a _failing state_.\n # task::unsupervise(buildr);\n # task::run(buildr) {||\n \n-[1, 2, 3, 4][0];\n-[mut 'x', 'y'][1] = 'z';\n-[\"a\", \"b\"][10]; // fails\n+(~[1, 2, 3, 4])[0];\n+(~[mut 'x', 'y'])[1] = 'z';\n+(~[\"a\", \"b\"])[10]; // fails\n \n # }\n ~~~~\n@@ -1760,10 +1760,10 @@ is unsupported and will fail to compile.\n An example of an `as` expression:\n \n ~~~~\n-# fn sum(v: [float]) -> float { 0.0 }\n-# fn len(v: [float]) -> int { 0 }\n+# fn sum(v: ~[float]) -> float { 0.0 }\n+# fn len(v: ~[float]) -> int { 0 }\n \n-fn avg(v: [float]) -> float {\n+fn avg(v: ~[float]) -> float {\n   let sum: float = sum(v);\n   let sz: float = len(v) as float;\n   ret sum / sz;\n@@ -1794,8 +1794,8 @@ expression. No allocation or destruction is entailed.\n An example of three different move expressions:\n \n ~~~~~~~~\n-# let mut x = [mut 0];\n-# let a = [mut 0];\n+# let mut x = ~[mut 0];\n+# let a = ~[mut 0];\n # let b = 0;\n # let y = {mut z: 0};\n # let c = 0;\n@@ -1823,8 +1823,8 @@ expression. No allocation or destruction is entailed.\n An example of three different swap expressions:\n \n ~~~~~~~~\n-# let mut x = [mut 0];\n-# let mut a = [mut 0];\n+# let mut x = ~[mut 0];\n+# let mut a = ~[mut 0];\n # let i = 0;\n # let y = {mut z: 0};\n # let b = {mut c: 0};\n@@ -1924,11 +1924,11 @@ argument to a function to be copied and passed by value.\n An example of a copy expression:\n \n ~~~~\n-fn mutate(vec: [mut int]) {\n+fn mutate(vec: ~[mut int]) {\n    vec[0] = 10;\n }\n \n-let v = [mut 1,2,3];\n+let v = ~[mut 1,2,3];\n \n mutate(copy v);   // Pass a copy\n \n@@ -2067,7 +2067,7 @@ An example a for loop:\n # fn bar(f: foo) { }\n # let a = 0, b = 0, c = 0;\n \n-let v: [foo] = [a, b, c];\n+let v: ~[foo] = ~[a, b, c];\n \n for v.each {|e|\n     bar(e);\n@@ -2272,12 +2272,12 @@ the `note` to the internal logging diagnostic buffer.\n An example of a `note` expression:\n \n ~~~~{.xfail-test}\n-fn read_file_lines(path: str) -> [str] {\n+fn read_file_lines(path: str) -> ~[str] {\n     note path;\n     let r: [str];\n     let f: file = open_read(path);\n     lines(f) {|s|\n-        r += [s];\n+        r += ~[s];\n     }\n     ret r;\n }\n@@ -2707,7 +2707,7 @@ the kind of its member type, as with other simple structural types.\n An example of a vector type and its use:\n \n ~~~~\n-let v: [int] = [7, 5, 3];\n+let v: ~[int] = ~[7, 5, 3];\n let i: int = v[2];\n assert (i == 3);\n ~~~~\n@@ -2719,8 +2719,8 @@ vector:\n \n \n ~~~~\n-let mut v: [int] = [1, 2, 3];\n-v += [4, 5, 6];\n+let mut v: ~[int] = ~[1, 2, 3];\n+v += ~[4, 5, 6];\n ~~~~\n \n Normal vector concatenation causes the allocation of a fresh vector to hold"}, {"sha": "e90ac9c12dd4f88513f97d7ebb5bab6efc9c5665", "filename": "doc/tutorial.md", "status": "modified", "additions": 62, "deletions": 53, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/a3c7d93c77b4c747187afc82c1611be3c35d8218/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/a3c7d93c77b4c747187afc82c1611be3c35d8218/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=a3c7d93c77b4c747187afc82c1611be3c35d8218", "patch": "@@ -131,7 +131,7 @@ Rust program files are, by convention, given the extension `.rs`. Say\n we have a file `hello.rs` containing this program:\n \n ~~~~\n-fn main(args: [str]) {\n+fn main(args: ~[str]) {\n     io::println(\"hello world from '\" + args[0] + \"'!\");\n }\n ~~~~\n@@ -322,10 +322,10 @@ annotation:\n \n ~~~~\n // The type of this vector will be inferred based on its use.\n-let x = [];\n+let x = ~[];\n # vec::map(x, fn&(&&_y:int) -> int { _y });\n // Explicitly say this is a vector of integers.\n-let y: [int] = [];\n+let y: ~[int] = ~[];\n ~~~~\n \n The basic types are written like this:\n@@ -363,10 +363,10 @@ The basic types are written like this:\n These can be combined in composite types, which will be described in\n more detail later on (the `T`s here stand for any other type):\n \n-`[T]`\n+`~[T]`\n   : Vector type.\n \n-`[mut T]`\n+`~[mut T]`\n   : Mutable vector type.\n \n `(T1, T2)`\n@@ -757,7 +757,7 @@ value.\n \n ~~~~\n log(warn, \"hi\");\n-log(error, (1, [2.5, -1.8]));\n+log(error, (1, ~[2.5, -1.8]));\n ~~~~\n \n The first argument is the log level (levels `debug`, `info`, `warn`,\n@@ -939,7 +939,7 @@ closure, the closure need not be placed within parentheses. You could,\n for example, write...\n \n ~~~~\n-let doubled = vec::map([1, 2, 3]) {|x| x*2};\n+let doubled = vec::map(~[1, 2, 3]) {|x| x*2};\n ~~~~\n \n `vec::map` is a function in the core library that applies its last\n@@ -955,7 +955,7 @@ iteration constructs. For example, this one iterates over a vector\n of integers backwards:\n \n ~~~~\n-fn for_rev(v: [int], act: fn(int)) {\n+fn for_rev(v: ~[int], act: fn(int)) {\n     let mut i = vec::len(v);\n     while (i > 0u) {\n         i -= 1u;\n@@ -967,17 +967,17 @@ fn for_rev(v: [int], act: fn(int)) {\n To run such an iteration, you could do this:\n \n ~~~~\n-# fn for_rev(v: [int], act: fn(int)) {}\n-for_rev([1, 2, 3], {|n| log(error, n); });\n+# fn for_rev(v: ~[int], act: fn(int)) {}\n+for_rev(~[1, 2, 3], {|n| log(error, n); });\n ~~~~\n \n Making use of the shorthand where a final closure argument can be\n moved outside of the parentheses permits the following, which\n looks quite like a normal loop:\n \n ~~~~\n-# fn for_rev(v: [int], act: fn(int)) {}\n-for_rev([1, 2, 3]) {|n|\n+# fn for_rev(v: ~[int], act: fn(int)) {}\n+for_rev(~[1, 2, 3]) {|n|\n     log(error, n);\n }\n ~~~~\n@@ -992,7 +992,7 @@ To allow breaking out of loops, many iteration functions, such as\n `false` to break off iteration.\n \n ~~~~\n-vec::each([2, 4, 8, 5, 16]) {|n|\n+vec::each(~[2, 4, 8, 5, 16]) {|n|\n     if n % 2 != 0 {\n         io::println(\"found odd number!\");\n         false\n@@ -1006,7 +1006,7 @@ return `true`, and `break` and `cont` can be used, much like in a\n `while` loop, to explicitly return `false` or `true`.\n \n ~~~~\n-for vec::each([2, 4, 8, 5, 16]) {|n|\n+for vec::each(~[2, 4, 8, 5, 16]) {|n|\n     if n % 2 != 0 {\n         io::println(\"found odd number!\");\n         break;\n@@ -1020,7 +1020,7 @@ normally allowed in blocks, in a block that appears as the body of a\n function, not just the loop body.\n \n ~~~~\n-fn contains(v: [int], elt: int) -> bool {\n+fn contains(v: ~[int], elt: int) -> bool {\n     for vec::each(v) {|x|\n         if (x == elt) { ret true; }\n     }\n@@ -1057,7 +1057,7 @@ Fields that you want to mutate must be explicitly marked as such. For\n example...\n \n ~~~~\n-type stack = {content: [int], mut head: uint};\n+type stack = {content: ~[int], mut head: uint};\n ~~~~\n \n With such a type, you can do `mystack.head += 1u`. If `mut` were\n@@ -1316,7 +1316,7 @@ fn increase_contents(pt: @mut int) {\n ## Vectors\n \n Rust vectors are always heap-allocated and unique. A value of type\n-`[T]` is represented by a pointer to a section of heap memory\n+`~[T]` is represented by a pointer to a section of heap memory\n containing any number of values of type `T`.\n \n NOTE: This uniqueness is turning out to be quite awkward in practice,\n@@ -1326,37 +1326,42 @@ Vector literals are enclosed in square brackets. Dereferencing is done\n with square brackets (zero-based):\n \n ~~~~\n-let myvec = [true, false, true, false];\n+let myvec = ~[true, false, true, false];\n if myvec[1] { io::println(\"boom\"); }\n ~~~~\n \n By default, vectors are immutable\u2014you can not replace their elements.\n-The type written as `[mut T]` is a vector with mutable\n-elements. Mutable vector literals are written `[mut]` (empty) or `[mut\n+The type written as `~[mut T]` is a vector with mutable\n+elements. Mutable vector literals are written `~[mut]` (empty) or `~[mut\n 1, 2, 3]` (with elements).\n \n The `+` operator means concatenation when applied to vector types.\n Growing a vector in Rust is not as inefficient as it looks :\n \n ~~~~\n-let mut myvec = [], i = 0;\n+let mut myvec = ~[], i = 0;\n while i < 100 {\n-    myvec += [i];\n+    myvec += ~[i];\n     i += 1;\n }\n ~~~~\n \n Because a vector is unique, replacing it with a longer one (which is\n-what `+= [i]` does) is indistinguishable from appending to it\n+what `+= ~[i]` does) is indistinguishable from appending to it\n in-place. Vector representations are optimized to grow\n logarithmically, so the above code generates about the same amount of\n copying and reallocation as `push` implementations in most other\n languages.\n \n+NOTE: Actually, current, growing a vector is *exactly* as inefficient\n+as it looks, since vector + has been moved to the libraries and rust's\n+operator overloading support is insufficient to allow this\n+optimization. Try using `vec::push`.\n+\n ## Strings\n \n The `str` type in Rust is represented exactly the same way as a vector\n-of bytes (`[u8]`), except that it is guaranteed to have a trailing\n+of bytes (`~[u8]`), except that it is guaranteed to have a trailing\n null byte (for interoperability with C APIs).\n \n This sequence of bytes is interpreted as an UTF-8 encoded sequence of\n@@ -1407,11 +1412,11 @@ very cheap, but you'll occasionally have to copy them to ensure\n safety.\n \n ~~~~\n-let mut my_rec = {a: 4, b: [1, 2, 3]};\n+let mut my_rec = {a: 4, b: ~[1, 2, 3]};\n alt my_rec {\n   {a, b} {\n     log(info, b); // This is okay\n-    my_rec = {a: a + 1, b: b + [a]};\n+    my_rec = {a: a + 1, b: b + ~[a]};\n     log(info, b); // Here reference b has become invalid\n   }\n }\n@@ -1433,8 +1438,8 @@ are often useful. The first is by-mutable-pointer, written with a\n single `&`:\n \n ~~~~\n-fn vec_push(&v: [int], elt: int) {\n-    v += [elt];\n+fn vec_push(&v: ~[int], elt: int) {\n+    v += ~[elt];\n }\n ~~~~\n \n@@ -1475,17 +1480,17 @@ they apply to.  Thus, Rust allows functions and datatypes to have type\n parameters.\n \n ~~~~\n-fn for_rev<T>(v: [T], act: fn(T)) {\n+fn for_rev<T>(v: ~[T], act: fn(T)) {\n     let mut i = vec::len(v);\n     while i > 0u {\n         i -= 1u;\n         act(v[i]);\n     }\n }\n \n-fn map<T, U>(v: [T], f: fn(T) -> U) -> [U] {\n-    let mut acc = [];\n-    for v.each {|elt| acc += [f(elt)]; }\n+fn map<T, U>(v: ~[T], f: fn(T) -> U) -> ~[U] {\n+    let mut acc = ~[];\n+    for v.each {|elt| vec::push(acc, f(elt)); }\n     ret acc;\n }\n ~~~~\n@@ -1505,7 +1510,7 @@ Generic `type` and `enum` declarations follow the same pattern:\n ~~~~\n type circular_buf<T> = {start: uint,\n                         end: uint,\n-                        buf: [mut T]};\n+                        buf: ~[mut T]};\n \n enum option<T> { some(T), none }\n ~~~~\n@@ -1573,9 +1578,9 @@ unless you explicitly declare that type parameter to have copyable\n \n ~~~~ {.ignore}\n // This does not compile\n-fn head_bad<T>(v: [T]) -> T { v[0] }\n+fn head_bad<T>(v: ~[T]) -> T { v[0] }\n // This does\n-fn head<T: copy>(v: [T]) -> T { v[0] }\n+fn head<T: copy>(v: ~[T]) -> T { v[0] }\n ~~~~\n \n When instantiating a generic function, you can only instantiate it\n@@ -1601,7 +1606,7 @@ difficult. If you try this program:\n \n ~~~~{.xfail-test}\n fn plus1(x: int) -> int { x + 1 }\n-vec::map([1, 2, 3], plus1);\n+vec::map(~[1, 2, 3], plus1);\n ~~~~\n \n You will get an error message about argument passing styles\n@@ -1615,7 +1620,7 @@ using the `&&` sigil:\n \n ~~~~\n fn plus1(&&x: int) -> int { x + 1 }\n-vec::map([1, 2, 3], plus1);\n+vec::map(~[1, 2, 3], plus1);\n ~~~~\n \n NOTE: This is inconvenient, and we are hoping to get rid of this\n@@ -1961,7 +1966,7 @@ parameters.\n \n ~~~~\n # iface to_str { fn to_str() -> str; }\n-fn comma_sep<T: to_str>(elts: [T]) -> str {\n+fn comma_sep<T: to_str>(elts: ~[T]) -> str {\n     let mut result = \"\", first = true;\n     for elts.each {|elt|\n         if first { first = false; }\n@@ -1990,7 +1995,7 @@ iface seq<T> {\n     fn len() -> uint;\n     fn iter(fn(T));\n }\n-impl <T> of seq<T> for [T] {\n+impl <T> of seq<T> for ~[T] {\n     fn len() -> uint { vec::len(self) }\n     fn iter(b: fn(T)) {\n         for self.each {|elt| b(elt); }\n@@ -2012,7 +2017,7 @@ However, consider this function:\n \n ~~~~\n # iface drawable { fn draw(); }\n-fn draw_all<T: drawable>(shapes: [T]) {\n+fn draw_all<T: drawable>(shapes: ~[T]) {\n     for shapes.each {|shape| shape.draw(); }\n }\n ~~~~\n@@ -2026,7 +2031,7 @@ the function to be written simply like this:\n \n ~~~~\n # iface drawable { fn draw(); }\n-fn draw_all(shapes: [drawable]) {\n+fn draw_all(shapes: ~[drawable]) {\n     for shapes.each {|shape| shape.draw(); }\n }\n ~~~~\n@@ -2048,10 +2053,10 @@ to an interface type:\n # impl of drawable for int { fn draw() {} }\n # fn new_circle() -> int { 1 }\n # fn new_rectangle() -> int { 2 }\n-# fn draw_all(shapes: [drawable]) {}\n+# fn draw_all(shapes: ~[drawable]) {}\n let c: circle = new_circle();\n let r: rectangle = new_rectangle();\n-draw_all([c as drawable, r as drawable]);\n+draw_all(~[c as drawable, r as drawable]);\n ~~~~\n \n This will store the value into a box, along with information about the\n@@ -2110,7 +2115,7 @@ extern mod crypto {\n     fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8;\n }\n \n-fn as_hex(data: [u8]) -> str {\n+fn as_hex(data: ~[u8]) -> str {\n     let mut acc = \"\";\n     for data.each {|byte| acc += #fmt(\"%02x\", byte as uint); }\n     ret acc;\n@@ -2123,7 +2128,7 @@ fn sha1(data: str) -> str unsafe {\n     ret as_hex(vec::unsafe::from_buf(hash, 20u));\n }\n \n-fn main(args: [str]) {\n+fn main(args: ~[str]) {\n     io::println(sha1(args[1]));\n }\n ~~~~\n@@ -2214,12 +2219,14 @@ The `sha1` function is the most obscure part of the program.\n \n ~~~~\n # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-# fn as_hex(data: [u8]) -> str { \"hi\" }\n-fn sha1(data: str) -> str unsafe {\n-    let bytes = str::bytes(data);\n-    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n-                            vec::len(bytes), ptr::null());\n-    ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+# fn as_hex(data: ~[u8]) -> str { \"hi\" }\n+fn sha1(data: str) -> str {\n+    unsafe {\n+        let bytes = str::bytes(data);\n+        let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+                                vec::len(bytes), ptr::null());\n+        ret as_hex(vec::unsafe::from_buf(hash, 20u));\n+    }\n }\n ~~~~\n \n@@ -2255,13 +2262,15 @@ Let's look at our `sha1` function again.\n \n ~~~~\n # mod crypto { fn SHA1(src: *u8, sz: uint, out: *u8) -> *u8 { out } }\n-# fn as_hex(data: [u8]) -> str { \"hi\" }\n-# fn x(data: str) -> str unsafe {\n+# fn as_hex(data: ~[u8]) -> str { \"hi\" }\n+# fn x(data: str) -> str {\n+# unsafe {\n let bytes = str::bytes(data);\n let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n                         vec::len(bytes), ptr::null());\n ret as_hex(vec::unsafe::from_buf(hash, 20u));\n # }\n+# }\n ~~~~\n \n The `str::bytes` function is perfectly safe, it converts a string to"}, {"sha": "0c3ffb53c25c3196ad22a13b8629ff3657f04fa7", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=a3c7d93c77b4c747187afc82c1611be3c35d8218", "patch": "@@ -1,4 +1,4 @@\n-fn f<T: copy>(x: [T]) -> T { ret x[0]; }\n+fn f<T: copy>(x: [T]/~) -> T { ret x[0]; }\n \n fn g(act: fn([int]/~) -> int) -> int { ret act([1, 2, 3]/~); }\n "}, {"sha": "41fbaa51a17cde233c529513e79d1a4a68b46462", "filename": "src/test/run-pass/iface-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fiface-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-generic.rs?ref=a3c7d93c77b4c747187afc82c1611be3c35d8218", "patch": "@@ -30,8 +30,8 @@ fn bar<U: to_str, T: map<U>>(x: T) -> [str]/~ {\n }\n \n fn main() {\n-    assert foo([1]) == [\"hi\"]/~;\n-    assert bar::<int, [int]>([4, 5]) == [\"4\", \"5\"]/~;\n-    assert bar::<str, [str]>([\"x\", \"y\"]/~) == [\"x\", \"y\"]/~;\n-    assert bar::<(), [()]>([()]) == [\"()\"]/~;\n+    assert foo([1]/~) == [\"hi\"]/~;\n+    assert bar::<int, [int]/~>([4, 5]/~) == [\"4\", \"5\"]/~;\n+    assert bar::<str, [str]/~>([\"x\", \"y\"]/~) == [\"x\", \"y\"]/~;\n+    assert bar::<(), [()]/~>([()]/~) == [\"()\"]/~;\n }"}, {"sha": "668405c19f71edb7f3355c9f2d82e459a833f035", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=a3c7d93c77b4c747187afc82c1611be3c35d8218", "patch": "@@ -1,3 +1,9 @@\n+// I can't for the life of me manage to untangle all of the brackets\n+// in this test. I am just suppessing the old_vec diagnostic. This\n+// doesn't actually care what sort of vector it uses, so if we change\n+// what vectors mean, it shouldn't mind...\n+#[warn(no_old_vecs)];\n+\n fn main() {\n     #macro[[#zip_or_unzip[[x, ...], [y, ...]], [[x, y], ...]],\n            [#zip_or_unzip[[xx, yy], ...], [[xx, ...], [yy, ...]]]];"}, {"sha": "847f5214331eb15679f449aeac04877514c62fc8", "filename": "src/test/run-pass/shape_intrinsic_tag_then_rec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3c7d93c77b4c747187afc82c1611be3c35d8218/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshape_intrinsic_tag_then_rec.rs?ref=a3c7d93c77b4c747187afc82c1611be3c35d8218", "patch": "@@ -23,7 +23,7 @@ type ty = spanned<ty_>;\n fn main() {\n     let sp: span = {lo: 57451u, hi: 57542u, expanded_from: os_none};\n     let t: @ty = @{ data: 3u, span: sp };\n-    let p_: path_ = { global: true, idents: [\"hi\"]/~, types: [t] };\n+    let p_: path_ = { global: true, idents: [\"hi\"]/~, types: [t]/~ };\n     let p: path = { data: p_, span: sp };\n     let x = { sp: sp, path: p };\n     log(error, x.path);"}]}