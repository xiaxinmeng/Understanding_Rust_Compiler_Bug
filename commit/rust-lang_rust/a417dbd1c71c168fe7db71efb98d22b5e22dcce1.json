{"sha": "a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0MTdkYmQxYzcxYzE2OGZlN2RiNzFlZmI5OGQyMmI1ZTIyZGNjZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-09T11:41:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-09T11:41:27Z"}, "message": "auto merge of #10859 : huonw/rust/helper-dists, r=cmr\n\nThis moves `std::rand::distribitions::{Normal, StandardNormal}` to `...::distributions::normal`, reexporting `Normal` from `distributions` (and similarly for `Exp` and Exp1`), and adds:\r\n- Log-normal\r\n- Chi-squared\r\n- F\r\n- Student T\r\n\r\nall of which are implemented in C++11's random library. Tests in https://github.com/huonw/random-tests/commit/0424b8aded5e608ae386c1f917934a726d9cac6a. Note that these are approximately half documentation & half implementation (of which a significant portion is boilerplate `}`'s and so on).", "tree": {"sha": "cf34353237d7ef5ec0f93919d459f80a19222e15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf34353237d7ef5ec0f93919d459f80a19222e15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "html_url": "https://github.com/rust-lang/rust/commit/a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5f20212028fd6cb5161dbb2c0f14c9d94f1caea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5f20212028fd6cb5161dbb2c0f14c9d94f1caea", "html_url": "https://github.com/rust-lang/rust/commit/e5f20212028fd6cb5161dbb2c0f14c9d94f1caea"}, {"sha": "705b705ba5182745e12652dc7eeeb10828f520d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/705b705ba5182745e12652dc7eeeb10828f520d0", "html_url": "https://github.com/rust-lang/rust/commit/705b705ba5182745e12652dc7eeeb10828f520d0"}], "stats": {"total": 814, "additions": 568, "deletions": 246}, "files": [{"sha": "4244e6bacdbbdf0c0e9779fbea466b9576cbd7d7", "filename": "src/libstd/rand/distributions/exponential.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fexponential.rs?ref=a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The exponential distribution.\n+\n+use rand::{Rng, Rand};\n+use rand::distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n+\n+/// A wrapper around an `f64` to generate Exp(1) random numbers.\n+///\n+/// See `Exp` for the general exponential distribution.Note that this\n+ // has to be unwrapped before use as an `f64` (using either\n+/// `*` or `cast::transmute` is safe).\n+///\n+/// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n+/// exact description in the paper was adjusted to use tables for the\n+/// exponential distribution rather than normal.\n+///\n+/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n+/// Generate Normal Random\n+/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n+/// College, Oxford\n+pub struct Exp1(f64);\n+\n+// This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n+impl Rand for Exp1 {\n+    #[inline]\n+    fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n+        #[inline]\n+        fn pdf(x: f64) -> f64 {\n+            (-x).exp()\n+        }\n+        #[inline]\n+        fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n+            ziggurat_tables::ZIG_EXP_R - rng.gen::<f64>().ln()\n+        }\n+\n+        Exp1(ziggurat(rng, false,\n+                      &ziggurat_tables::ZIG_EXP_X,\n+                      &ziggurat_tables::ZIG_EXP_F,\n+                      pdf, zero_case))\n+    }\n+}\n+\n+/// The exponential distribution `Exp(lambda)`.\n+///\n+/// This distribution has density function: `f(x) = lambda *\n+/// exp(-lambda * x)` for `x > 0`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{Exp, IndependentSample};\n+///\n+/// fn main() {\n+///     let exp = Exp::new(2.0);\n+///     let v = exp.ind_sample(&mut rand::task_rng());\n+///     println!(\"{} is from a Exp(2) distribution\", v);\n+/// }\n+/// ```\n+pub struct Exp {\n+    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n+    priv lambda_inverse: f64\n+}\n+\n+impl Exp {\n+    /// Construct a new `Exp` with the given shape parameter\n+    /// `lambda`. Fails if `lambda <= 0`.\n+    pub fn new(lambda: f64) -> Exp {\n+        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n+        Exp { lambda_inverse: 1.0 / lambda }\n+    }\n+}\n+\n+impl Sample<f64> for Exp {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Exp {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        (*rng.gen::<Exp1>()) * self.lambda_inverse\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    #[test]\n+    fn test_exp() {\n+        let mut exp = Exp::new(10.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            assert!(exp.sample(&mut rng) >= 0.0);\n+            assert!(exp.ind_sample(&mut rng) >= 0.0);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_zero() {\n+        Exp::new(0.0);\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_exp_invalid_lambda_neg() {\n+        Exp::new(-10.0);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use rand::{XorShiftRng, RAND_BENCH_N};\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+    use mem::size_of;\n+\n+    #[bench]\n+    fn rand_exp(bh: &mut BenchHarness) {\n+        let mut rng = XorShiftRng::new();\n+        let mut exp = Exp::new(2.71828 * 3.14159);\n+\n+        bh.iter(|| {\n+            for _ in range(0, RAND_BENCH_N) {\n+                exp.sample(&mut rng);\n+            }\n+        });\n+        bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n+    }\n+}"}, {"sha": "ae7ff99af9242281f04744bdc83898d7ad47cc82", "filename": "src/libstd/rand/distributions/gamma.rs", "status": "modified", "additions": 210, "deletions": 2, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The Gamma distribution.\n+//! The Gamma and derived distributions.\n \n use rand::{Rng, Open01};\n-use super::{IndependentSample, Sample, StandardNormal, Exp};\n+use super::{IndependentSample, Sample, Exp};\n+use super::normal::StandardNormal;\n use num;\n \n /// The Gamma distribution `Gamma(shape, scale)` distribution.\n@@ -168,6 +169,213 @@ impl IndependentSample<f64> for GammaLargeShape {\n     }\n }\n \n+/// The chi-squared distribution `\u03c7\u00b2(k)`, where `k` is the degrees of\n+/// freedom.\n+///\n+/// For `k > 0` integral, this distribution is the sum of the squares\n+/// of `k` independent standard normal random variables. For other\n+/// `k`, this uses the equivalent characterisation `\u03c7\u00b2(k) = Gamma(k/2,\n+/// 2)`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{ChiSquared, IndependentSample};\n+///\n+/// fn main() {\n+///     let chi = ChiSquared::new(11.0);\n+///     let v = chi.ind_sample(&mut rand::task_rng());\n+///     println!(\"{} is from a \u03c7\u00b2(11) distribution\", v)\n+/// }\n+/// ```\n+pub enum ChiSquared {\n+    // k == 1, Gamma(alpha, ..) is particularly slow for alpha < 1,\n+    // e.g. when alpha = 1/2 as it would be for this case, so special-\n+    // casing and using the definition of N(0,1)^2 is faster.\n+    priv DoFExactlyOne,\n+    priv DoFAnythingElse(Gamma)\n+}\n+\n+impl ChiSquared {\n+    /// Create a new chi-squared distribution with degrees-of-freedom\n+    /// `k`. Fails if `k < 0`.\n+    pub fn new(k: f64) -> ChiSquared {\n+        if k == 1.0 {\n+            DoFExactlyOne\n+        } else {\n+            assert!(k > 0.0, \"ChiSquared::new called with `k` < 0\");\n+            DoFAnythingElse(Gamma::new(0.5 * k, 2.0))\n+        }\n+    }\n+}\n+impl Sample<f64> for ChiSquared {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for ChiSquared {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        match *self {\n+            DoFExactlyOne => {\n+                // k == 1 => N(0,1)^2\n+                let norm = *rng.gen::<StandardNormal>();\n+                norm * norm\n+            }\n+            DoFAnythingElse(ref g) => g.ind_sample(rng)\n+        }\n+    }\n+}\n+\n+/// The Fisher F distribution `F(m, n)`.\n+///\n+/// This distribution is equivalent to the ratio of two normalised\n+/// chi-squared distributions, that is, `F(m,n) = (\u03c7\u00b2(m)/m) /\n+/// (\u03c7\u00b2(n)/n)`.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{FisherF, IndependentSample};\n+///\n+/// fn main() {\n+///     let f = FisherF::new(2.0, 32.0);\n+///     let v = f.ind_sample(&mut rand::task_rng());\n+///     println!(\"{} is from an F(2, 32) distribution\", v)\n+/// }\n+/// ```\n+pub struct FisherF {\n+    priv numer: ChiSquared,\n+    priv denom: ChiSquared,\n+    // denom_dof / numer_dof so that this can just be a straight\n+    // multiplication, rather than a division.\n+    priv dof_ratio: f64,\n+}\n+\n+impl FisherF {\n+    /// Create a new `FisherF` distribution, with the given\n+    /// parameter. Fails if either `m` or `n` are not positive.\n+    pub fn new(m: f64, n: f64) -> FisherF {\n+        assert!(m > 0.0, \"FisherF::new called with `m < 0`\");\n+        assert!(n > 0.0, \"FisherF::new called with `n < 0`\");\n+\n+        FisherF {\n+            numer: ChiSquared::new(m),\n+            denom: ChiSquared::new(n),\n+            dof_ratio: n / m\n+        }\n+    }\n+}\n+impl Sample<f64> for FisherF {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for FisherF {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        self.numer.ind_sample(rng) / self.denom.ind_sample(rng) * self.dof_ratio\n+    }\n+}\n+\n+/// The Student t distribution, `t(nu)`, where `nu` is the degrees of\n+/// freedom.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{StudentT, IndependentSample};\n+///\n+/// fn main() {\n+///     let t = StudentT::new(11.0);\n+///     let v = t.ind_sample(&mut rand::task_rng());\n+///     println!(\"{} is from a t(11) distribution\", v)\n+/// }\n+/// ```\n+pub struct StudentT {\n+    priv chi: ChiSquared,\n+    priv dof: f64\n+}\n+\n+impl StudentT {\n+    /// Create a new Student t distribution with `n` degrees of\n+    /// freedom. Fails if `n <= 0`.\n+    pub fn new(n: f64) -> StudentT {\n+        assert!(n > 0.0, \"StudentT::new called with `n <= 0`\");\n+        StudentT {\n+            chi: ChiSquared::new(n),\n+            dof: n\n+        }\n+    }\n+}\n+impl Sample<f64> for StudentT {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for StudentT {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        let norm = *rng.gen::<StandardNormal>();\n+        norm * (self.dof / self.chi.ind_sample(rng)).sqrt()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    #[test]\n+    fn test_chi_squared_one() {\n+        let mut chi = ChiSquared::new(1.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            chi.sample(&mut rng);\n+            chi.ind_sample(&mut rng);\n+        }\n+    }\n+    #[test]\n+    fn test_chi_squared_small() {\n+        let mut chi = ChiSquared::new(0.5);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            chi.sample(&mut rng);\n+            chi.ind_sample(&mut rng);\n+        }\n+    }\n+    #[test]\n+    fn test_chi_squared_large() {\n+        let mut chi = ChiSquared::new(30.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            chi.sample(&mut rng);\n+            chi.ind_sample(&mut rng);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_log_normal_invalid_dof() {\n+        ChiSquared::new(-1.0);\n+    }\n+\n+    #[test]\n+    fn test_f() {\n+        let mut f = FisherF::new(2.0, 32.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            f.sample(&mut rng);\n+            f.ind_sample(&mut rng);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_t() {\n+        let mut t = StudentT::new(11.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            t.sample(&mut rng);\n+            t.ind_sample(&mut rng);\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod bench {\n     use super::*;"}, {"sha": "a381ac35d30c304ca56edeb498ee2882533e8fd9", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 6, "deletions": 244, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "patch": "@@ -23,14 +23,18 @@ that do not need to record state.\n use iter::range;\n use option::{Some, None};\n use num;\n-use rand::{Rng, Rand, Open01};\n+use rand::{Rng, Rand};\n use clone::Clone;\n \n pub use self::range::Range;\n-pub use self::gamma::Gamma;\n+pub use self::gamma::{Gamma, ChiSquared, FisherF, StudentT};\n+pub use self::normal::{Normal, LogNormal};\n+pub use self::exponential::Exp;\n \n pub mod range;\n pub mod gamma;\n+pub mod normal;\n+pub mod exponential;\n \n /// Types that can be used to create a random instance of `Support`.\n pub trait Sample<Support> {\n@@ -246,181 +250,10 @@ fn ziggurat<R:Rng>(\n     }\n }\n \n-/// A wrapper around an `f64` to generate N(0, 1) random numbers\n-/// (a.k.a.  a standard normal, or Gaussian).\n-///\n-/// See `Normal` for the general normal distribution. That this has to\n-/// be unwrapped before use as an `f64` (using either `*` or\n-/// `cast::transmute` is safe).\n-///\n-/// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n-///\n-/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n-/// Generate Normal Random\n-/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n-/// College, Oxford\n-pub struct StandardNormal(f64);\n-\n-impl Rand for StandardNormal {\n-    fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n-        #[inline]\n-        fn pdf(x: f64) -> f64 {\n-            ((-x*x/2.0) as f64).exp()\n-        }\n-        #[inline]\n-        fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n-            // compute a random number in the tail by hand\n-\n-            // strange initial conditions, because the loop is not\n-            // do-while, so the condition should be true on the first\n-            // run, they get overwritten anyway (0 < 1, so these are\n-            // good).\n-            let mut x = 1.0f64;\n-            let mut y = 0.0f64;\n-\n-            while -2.0 * y < x * x {\n-                let x_ = *rng.gen::<Open01<f64>>();\n-                let y_ = *rng.gen::<Open01<f64>>();\n-\n-                x = x_.ln() / ziggurat_tables::ZIG_NORM_R;\n-                y = y_.ln();\n-            }\n-\n-            if u < 0.0 { x - ziggurat_tables::ZIG_NORM_R } else { ziggurat_tables::ZIG_NORM_R - x }\n-        }\n-\n-        StandardNormal(ziggurat(\n-            rng,\n-            true, // this is symmetric\n-            &ziggurat_tables::ZIG_NORM_X,\n-            &ziggurat_tables::ZIG_NORM_F,\n-            pdf, zero_case))\n-    }\n-}\n-\n-/// The normal distribution `N(mean, std_dev**2)`.\n-///\n-/// This uses the ZIGNOR variant of the Ziggurat method, see\n-/// `StandardNormal` for more details.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::rand;\n-/// use std::rand::distributions::{Normal, IndependentSample};\n-///\n-/// fn main() {\n-///     let normal = Normal::new(2.0, 3.0);\n-///     let v = normal.ind_sample(rand::task_rng());\n-///     println!(\"{} is from a N(2, 9) distribution\", v)\n-/// }\n-/// ```\n-pub struct Normal {\n-    priv mean: f64,\n-    priv std_dev: f64\n-}\n-\n-impl Normal {\n-    /// Construct a new `Normal` distribution with the given mean and\n-    /// standard deviation. Fails if `std_dev < 0`.\n-    pub fn new(mean: f64, std_dev: f64) -> Normal {\n-        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n-        Normal {\n-            mean: mean,\n-            std_dev: std_dev\n-        }\n-    }\n-}\n-impl Sample<f64> for Normal {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n-}\n-impl IndependentSample<f64> for Normal {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        self.mean + self.std_dev * (*rng.gen::<StandardNormal>())\n-    }\n-}\n-\n-/// A wrapper around an `f64` to generate Exp(1) random numbers.\n-///\n-/// See `Exp` for the general exponential distribution.Note that this\n- // has to be unwrapped before use as an `f64` (using either\n-/// `*` or `cast::transmute` is safe).\n-///\n-/// Implemented via the ZIGNOR variant[1] of the Ziggurat method. The\n-/// exact description in the paper was adjusted to use tables for the\n-/// exponential distribution rather than normal.\n-///\n-/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n-/// Generate Normal Random\n-/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n-/// College, Oxford\n-pub struct Exp1(f64);\n-\n-// This could be done via `-rng.gen::<f64>().ln()` but that is slower.\n-impl Rand for Exp1 {\n-    #[inline]\n-    fn rand<R:Rng>(rng: &mut R) -> Exp1 {\n-        #[inline]\n-        fn pdf(x: f64) -> f64 {\n-            (-x).exp()\n-        }\n-        #[inline]\n-        fn zero_case<R:Rng>(rng: &mut R, _u: f64) -> f64 {\n-            ziggurat_tables::ZIG_EXP_R - rng.gen::<f64>().ln()\n-        }\n-\n-        Exp1(ziggurat(rng, false,\n-                      &ziggurat_tables::ZIG_EXP_X,\n-                      &ziggurat_tables::ZIG_EXP_F,\n-                      pdf, zero_case))\n-    }\n-}\n-\n-/// The exponential distribution `Exp(lambda)`.\n-///\n-/// This distribution has density function: `f(x) = lambda *\n-/// exp(-lambda * x)` for `x > 0`.\n-///\n-/// # Example\n-///\n-/// ```\n-/// use std::rand;\n-/// use std::rand::distributions::{Exp, IndependentSample};\n-///\n-/// fn main() {\n-///     let exp = Exp::new(2.0);\n-///     let v = exp.ind_sample(rand::task_rng());\n-///     println!(\"{} is from a Exp(2) distribution\", v);\n-/// }\n-/// ```\n-pub struct Exp {\n-    /// `lambda` stored as `1/lambda`, since this is what we scale by.\n-    priv lambda_inverse: f64\n-}\n-\n-impl Exp {\n-    /// Construct a new `Exp` with the given shape parameter\n-    /// `lambda`. Fails if `lambda <= 0`.\n-    pub fn new(lambda: f64) -> Exp {\n-        assert!(lambda > 0.0, \"Exp::new called with `lambda` <= 0\");\n-        Exp { lambda_inverse: 1.0 / lambda }\n-    }\n-}\n-\n-impl Sample<f64> for Exp {\n-    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n-}\n-impl IndependentSample<f64> for Exp {\n-    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n-        (*rng.gen::<Exp1>()) * self.lambda_inverse\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use rand::*;\n     use super::*;\n-    use iter::range;\n     use option::{Some, None};\n \n     struct ConstRand(uint);\n@@ -449,42 +282,6 @@ mod tests {\n         assert_eq!(*rand_sample.sample(&mut task_rng()), 0);\n         assert_eq!(*rand_sample.ind_sample(&mut task_rng()), 0);\n     }\n-\n-    #[test]\n-    fn test_normal() {\n-        let mut norm = Normal::new(10.0, 10.0);\n-        let mut rng = task_rng();\n-        for _ in range(0, 1000) {\n-            norm.sample(&mut rng);\n-            norm.ind_sample(&mut rng);\n-        }\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_normal_invalid_sd() {\n-        Normal::new(10.0, -1.0);\n-    }\n-\n-    #[test]\n-    fn test_exp() {\n-        let mut exp = Exp::new(10.0);\n-        let mut rng = task_rng();\n-        for _ in range(0, 1000) {\n-            assert!(exp.sample(&mut rng) >= 0.0);\n-            assert!(exp.ind_sample(&mut rng) >= 0.0);\n-        }\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_exp_invalid_lambda_zero() {\n-        Exp::new(0.0);\n-    }\n-    #[test]\n-    #[should_fail]\n-    fn test_exp_invalid_lambda_neg() {\n-        Exp::new(-10.0);\n-    }\n-\n     #[test]\n     fn test_weighted_choice() {\n         // this makes assumptions about the internal implementation of\n@@ -556,38 +353,3 @@ mod tests {\n                               Weighted { weight: 1, item: 3 }]);\n     }\n }\n-\n-#[cfg(test)]\n-mod bench {\n-    use extra::test::BenchHarness;\n-    use rand::{XorShiftRng, RAND_BENCH_N};\n-    use super::*;\n-    use iter::range;\n-    use option::{Some, None};\n-    use mem::size_of;\n-\n-    #[bench]\n-    fn rand_normal(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n-        let mut normal = Normal::new(-2.71828, 3.14159);\n-\n-        bh.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n-                normal.sample(&mut rng);\n-            }\n-        });\n-        bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n-    }\n-    #[bench]\n-    fn rand_exp(bh: &mut BenchHarness) {\n-        let mut rng = XorShiftRng::new();\n-        let mut exp = Exp::new(2.71828 * 3.14159);\n-\n-        bh.iter(|| {\n-            for _ in range(0, RAND_BENCH_N) {\n-                exp.sample(&mut rng);\n-            }\n-        });\n-        bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n-    }\n-}"}, {"sha": "a779f4f60660ea11a2c6d72b34e81ee1b19a5f8a", "filename": "src/libstd/rand/distributions/normal.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a417dbd1c71c168fe7db71efb98d22b5e22dcce1/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs?ref=a417dbd1c71c168fe7db71efb98d22b5e22dcce1", "patch": "@@ -0,0 +1,211 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The normal and derived distributions.\n+\n+use rand::{Rng, Rand, Open01};\n+use rand::distributions::{ziggurat, ziggurat_tables, Sample, IndependentSample};\n+\n+/// A wrapper around an `f64` to generate N(0, 1) random numbers\n+/// (a.k.a.  a standard normal, or Gaussian).\n+///\n+/// See `Normal` for the general normal distribution. That this has to\n+/// be unwrapped before use as an `f64` (using either `*` or\n+/// `cast::transmute` is safe).\n+///\n+/// Implemented via the ZIGNOR variant[1] of the Ziggurat method.\n+///\n+/// [1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n+/// Generate Normal Random\n+/// Samples*](http://www.doornik.com/research/ziggurat.pdf). Nuffield\n+/// College, Oxford\n+pub struct StandardNormal(f64);\n+\n+impl Rand for StandardNormal {\n+    fn rand<R:Rng>(rng: &mut R) -> StandardNormal {\n+        #[inline]\n+        fn pdf(x: f64) -> f64 {\n+            ((-x*x/2.0) as f64).exp()\n+        }\n+        #[inline]\n+        fn zero_case<R:Rng>(rng: &mut R, u: f64) -> f64 {\n+            // compute a random number in the tail by hand\n+\n+            // strange initial conditions, because the loop is not\n+            // do-while, so the condition should be true on the first\n+            // run, they get overwritten anyway (0 < 1, so these are\n+            // good).\n+            let mut x = 1.0f64;\n+            let mut y = 0.0f64;\n+\n+            while -2.0 * y < x * x {\n+                let x_ = *rng.gen::<Open01<f64>>();\n+                let y_ = *rng.gen::<Open01<f64>>();\n+\n+                x = x_.ln() / ziggurat_tables::ZIG_NORM_R;\n+                y = y_.ln();\n+            }\n+\n+            if u < 0.0 { x - ziggurat_tables::ZIG_NORM_R } else { ziggurat_tables::ZIG_NORM_R - x }\n+        }\n+\n+        StandardNormal(ziggurat(\n+            rng,\n+            true, // this is symmetric\n+            &ziggurat_tables::ZIG_NORM_X,\n+            &ziggurat_tables::ZIG_NORM_F,\n+            pdf, zero_case))\n+    }\n+}\n+\n+/// The normal distribution `N(mean, std_dev**2)`.\n+///\n+/// This uses the ZIGNOR variant of the Ziggurat method, see\n+/// `StandardNormal` for more details.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{Normal, IndependentSample};\n+///\n+/// fn main() {\n+///     // mean 2, standard deviation 3\n+///     let normal = Normal::new(2.0, 3.0);\n+///     let v = normal.ind_sample(&mut rand::task_rng());\n+///     println!(\"{} is from a N(2, 9) distribution\", v)\n+/// }\n+/// ```\n+pub struct Normal {\n+    priv mean: f64,\n+    priv std_dev: f64\n+}\n+\n+impl Normal {\n+    /// Construct a new `Normal` distribution with the given mean and\n+    /// standard deviation. Fails if `std_dev < 0`.\n+    pub fn new(mean: f64, std_dev: f64) -> Normal {\n+        assert!(std_dev >= 0.0, \"Normal::new called with `std_dev` < 0\");\n+        Normal {\n+            mean: mean,\n+            std_dev: std_dev\n+        }\n+    }\n+}\n+impl Sample<f64> for Normal {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for Normal {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        self.mean + self.std_dev * (*rng.gen::<StandardNormal>())\n+    }\n+}\n+\n+\n+/// The log-normal distribution `ln N(mean, std_dev**2)`.\n+///\n+/// If `X` is log-normal distributed, then `ln(X)` is `N(mean,\n+/// std_dev**2)` distributed.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::rand;\n+/// use std::rand::distributions::{LogNormal, IndependentSample};\n+///\n+/// fn main() {\n+///     // mean 2, standard deviation 3\n+///     let log_normal = LogNormal::new(2.0, 3.0);\n+///     let v = normal.ind_sample(&mut rand::task_rng());\n+///     println!(\"{} is from an ln N(2, 9) distribution\", v)\n+/// }\n+/// ```\n+pub struct LogNormal {\n+    priv norm: Normal\n+}\n+\n+impl LogNormal {\n+    /// Construct a new `LogNormal` distribution with the given mean\n+    /// and standard deviation. Fails if `std_dev < 0`.\n+    pub fn new(mean: f64, std_dev: f64) -> LogNormal {\n+        assert!(std_dev >= 0.0, \"LogNormal::new called with `std_dev` < 0\");\n+        LogNormal { norm: Normal::new(mean, std_dev) }\n+    }\n+}\n+impl Sample<f64> for LogNormal {\n+    fn sample<R: Rng>(&mut self, rng: &mut R) -> f64 { self.ind_sample(rng) }\n+}\n+impl IndependentSample<f64> for LogNormal {\n+    fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n+        self.norm.ind_sample(rng).exp()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rand::*;\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+\n+    #[test]\n+    fn test_normal() {\n+        let mut norm = Normal::new(10.0, 10.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            norm.sample(&mut rng);\n+            norm.ind_sample(&mut rng);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_normal_invalid_sd() {\n+        Normal::new(10.0, -1.0);\n+    }\n+\n+\n+    #[test]\n+    fn test_log_normal() {\n+        let mut lnorm = LogNormal::new(10.0, 10.0);\n+        let mut rng = task_rng();\n+        for _ in range(0, 1000) {\n+            lnorm.sample(&mut rng);\n+            lnorm.ind_sample(&mut rng);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    fn test_log_normal_invalid_sd() {\n+        LogNormal::new(10.0, -1.0);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    use extra::test::BenchHarness;\n+    use rand::{XorShiftRng, RAND_BENCH_N};\n+    use super::*;\n+    use iter::range;\n+    use option::{Some, None};\n+    use mem::size_of;\n+\n+    #[bench]\n+    fn rand_normal(bh: &mut BenchHarness) {\n+        let mut rng = XorShiftRng::new();\n+        let mut normal = Normal::new(-2.71828, 3.14159);\n+\n+        bh.iter(|| {\n+            for _ in range(0, RAND_BENCH_N) {\n+                normal.sample(&mut rng);\n+            }\n+        });\n+        bh.bytes = size_of::<f64>() as u64 * RAND_BENCH_N;\n+    }\n+}"}]}