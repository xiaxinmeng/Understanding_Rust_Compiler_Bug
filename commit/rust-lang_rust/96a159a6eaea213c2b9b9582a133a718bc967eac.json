{"sha": "96a159a6eaea213c2b9b9582a133a718bc967eac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YTE1OWE2ZWFlYTIxM2MyYjliOTU4MmExMzNhNzE4YmM5NjdlYWM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T21:01:38Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-05-08T21:14:24Z"}, "message": "Support visibility modifiers and attributes on view items\n\nIssue #1893\nTangentially, issue #2357", "tree": {"sha": "875241bab9ff115d255578026c1437fcf392af77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/875241bab9ff115d255578026c1437fcf392af77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96a159a6eaea213c2b9b9582a133a718bc967eac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96a159a6eaea213c2b9b9582a133a718bc967eac", "html_url": "https://github.com/rust-lang/rust/commit/96a159a6eaea213c2b9b9582a133a718bc967eac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96a159a6eaea213c2b9b9582a133a718bc967eac/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c0577f233ee79c85c6890977f8f73ffe8a21233", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c0577f233ee79c85c6890977f8f73ffe8a21233", "html_url": "https://github.com/rust-lang/rust/commit/5c0577f233ee79c85c6890977f8f73ffe8a21233"}], "stats": {"total": 130, "additions": 61, "deletions": 69}, "files": [{"sha": "210244eca91ea6daaac3f41de42140079f5e45c2", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -612,7 +612,8 @@ enum view_path_ {\n }\n \n #[auto_serialize]\n-type view_item = spanned<view_item_>;\n+type view_item = {node: view_item_, attrs: [attribute],\n+                  vis: visibility, span: span};\n \n #[auto_serialize]\n enum view_item_ {"}, {"sha": "ebc65c9db38eab868ead4faa20c6f1d07f2cb782", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -679,6 +679,8 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     fn f_view_item(afp: ast_fold_precursor, f: ast_fold, &&x: @view_item) ->\n        @view_item {\n         ret @{node: afp.fold_view_item(x.node, f),\n+              attrs: vec::map(x.attrs, {|a| fold_attribute_(a, f)}),\n+              vis: x.vis,\n               span: afp.new_span(x.span)};\n     }\n     fn f_native_item(afp: ast_fold_precursor, f: ast_fold, &&x: @native_item)"}, {"sha": "e8d73915577a123255d9a5dc939eac3f83881d34", "filename": "src/librustsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fattr.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -39,7 +39,7 @@ fn parse_outer_attrs_or_ext(\n // Parse attributes that appear before an item\n fn parse_outer_attributes(p: parser) -> [ast::attribute] {\n     let mut attrs: [ast::attribute] = [];\n-    while p.token == token::POUND {\n+    while p.token == token::POUND && p.look_ahead(1u) == token::LBRACKET {\n         attrs += [parse_attribute(p, ast::attr_outer)];\n     }\n     ret attrs;"}, {"sha": "b50c2b7e7f3c66f0308f44c2b11b700d96950c12", "filename": "src/librustsyntax/parse/common.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fcommon.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -58,12 +58,16 @@ fn require_keyword(p: parser, word: str) {\n     }\n }\n \n-fn is_keyword(p: parser, word: str) -> bool {\n+fn token_is_keyword(p: parser, word: str, tok: token::token) -> bool {\n     require_keyword(p, word);\n-    ret alt p.token {\n-          token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n-          _ { false }\n-        };\n+    alt tok {\n+      token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n+      _ { false }\n+    }\n+}\n+\n+fn is_keyword(p: parser, word: str) -> bool {\n+    token_is_keyword(p, word, p.token)\n }\n \n fn eat_keyword(p: parser, word: str) -> bool {"}, {"sha": "7b1b9823a1ff8f8f16cdec294dfcc79e1eeda952", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 59, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -1606,8 +1606,8 @@ fn parse_block_tail_(p: parser, lo: uint, s: blk_check_mode,\n                      +first_item_attrs: [attribute]) -> blk {\n     let mut stmts = [];\n     let mut expr = none;\n-    let view_items = maybe_parse_view_import_only(p, first_item_attrs);\n-    let mut initial_attrs = first_item_attrs;\n+    let {attrs_remaining, view_items} = parse_view(p, first_item_attrs, true);\n+    let mut initial_attrs = attrs_remaining;\n \n     if p.token == token::RBRACE && !vec::is_empty(initial_attrs) {\n         p.fatal(\"expected item\");\n@@ -2036,12 +2036,13 @@ fn parse_visibility(p: parser, def: visibility) -> visibility {\n fn parse_mod_items(p: parser, term: token::token,\n                    +first_item_attrs: [attribute]) -> _mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n-    let view_items = maybe_parse_view(p, first_item_attrs);\n+    let {attrs_remaining, view_items} =\n+        parse_view(p, first_item_attrs, false);\n     let mut items: [@item] = [];\n     let mut first = true;\n     while p.token != term {\n         let mut attrs = parse_outer_attributes(p);\n-        if first { attrs = first_item_attrs + attrs; first = false; }\n+        if first { attrs = attrs_remaining + attrs; first = false; }\n         #debug[\"parse_mod_items: parse_item(attrs=%?)\", attrs];\n         let vis = parse_visibility(p, private);\n         alt parse_item(p, attrs, vis) {\n@@ -2054,7 +2055,7 @@ fn parse_mod_items(p: parser, term: token::token,\n         #debug[\"parse_mod_items: attrs=%?\", attrs];\n     }\n \n-    if first && first_item_attrs.len() > 0u {\n+    if first && attrs_remaining.len() > 0u {\n         // We parsed attributes for the first item but didn't find the item\n         p.fatal(\"expected item\");\n     }\n@@ -2113,12 +2114,10 @@ fn parse_native_item(p: parser, +attrs: [attribute]) ->\n fn parse_native_mod_items(p: parser, +first_item_attrs: [attribute]) ->\n    native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n-    let view_items =\n-        if vec::len(first_item_attrs) == 0u {\n-            parse_native_view(p)\n-        } else { [] };\n+    let {attrs_remaining, view_items} =\n+        parse_view(p, first_item_attrs, false);\n     let mut items: [@native_item] = [];\n-    let mut initial_attrs = first_item_attrs;\n+    let mut initial_attrs = attrs_remaining;\n     while p.token != token::RBRACE {\n         let attrs = initial_attrs + parse_outer_attributes(p);\n         initial_attrs = [];\n@@ -2378,58 +2377,38 @@ fn parse_view_paths(p: parser) -> [@view_path] {\n     ret vp;\n }\n \n-fn parse_view_item(p: parser) -> @view_item {\n-    let lo = p.span.lo;\n-    let the_item =\n-        if eat_keyword(p, \"use\") {\n-            parse_use(p)\n-        } else if eat_keyword(p, \"import\") {\n-            view_item_import(parse_view_paths(p))\n-        } else if eat_keyword(p, \"export\") {\n-            view_item_export(parse_view_paths(p))\n-        } else {\n-            fail\n-    };\n-    let mut hi = p.span.lo;\n-    expect(p, token::SEMI);\n-    ret @spanned(lo, hi, the_item);\n-}\n-\n fn is_view_item(p: parser) -> bool {\n-    is_keyword(p, \"use\") || is_keyword(p, \"import\") || is_keyword(p, \"export\")\n-}\n-\n-fn maybe_parse_view(\n-    p: parser,\n-    first_item_attrs: [attribute]) -> [@view_item] {\n-\n-    maybe_parse_view_while(p, first_item_attrs, is_view_item)\n-}\n-\n-fn maybe_parse_view_import_only(\n-    p: parser,\n-    first_item_attrs: [attribute]) -> [@view_item] {\n-\n-    maybe_parse_view_while(p, first_item_attrs, bind is_keyword(_, \"import\"))\n+    let tok = if !is_keyword(p, \"pub\") && !is_keyword(p, \"priv\") { p.token }\n+              else { p.look_ahead(1u) };\n+    token_is_keyword(p, \"use\", tok) || token_is_keyword(p, \"import\", tok) ||\n+        token_is_keyword(p, \"export\", tok)\n+}\n+\n+fn parse_view_item(p: parser, +attrs: [attribute]) -> @view_item {\n+    let lo = p.span.lo, vis = parse_visibility(p, private);\n+    let node = if eat_keyword(p, \"use\") {\n+        parse_use(p)\n+    } else if eat_keyword(p, \"import\") {\n+        view_item_import(parse_view_paths(p))\n+    } else if eat_keyword(p, \"export\") {\n+        view_item_export(parse_view_paths(p))\n+    } else { fail; };\n+    expect(p, token::SEMI);\n+    @{node: node, attrs: attrs,\n+      vis: vis, span: mk_sp(lo, p.last_span.hi)}\n }\n \n-fn maybe_parse_view_while(\n-    p: parser,\n-    first_item_attrs: [attribute],\n-    f: fn@(parser) -> bool) -> [@view_item] {\n-\n-    if vec::len(first_item_attrs) == 0u {\n-        let mut items = [];\n-        while f(p) { items += [parse_view_item(p)]; }\n-        ret items;\n-    } else {\n-        // Shouldn't be any view items since we've already parsed an item attr\n-        ret [];\n+fn parse_view(p: parser, +first_item_attrs: [attribute],\n+              only_imports: bool) -> {attrs_remaining: [attribute],\n+                                      view_items: [@view_item]} {\n+    let mut attrs = first_item_attrs + parse_outer_attributes(p);\n+    let mut items = [];\n+    while if only_imports { is_keyword(p, \"import\") }\n+          else { is_view_item(p) } {\n+        items += [parse_view_item(p, attrs)];\n+        attrs = parse_outer_attributes(p);\n     }\n-}\n-\n-fn parse_native_view(p: parser) -> [@view_item] {\n-    maybe_parse_view_while(p, [], is_view_item)\n+    {attrs_remaining: attrs, view_items: items}\n }\n \n // Parses a source module as a crate\n@@ -2494,7 +2473,7 @@ fn parse_crate_directive(p: parser, first_outer_attr: [attribute]) ->\n           _ { unexpected(p); }\n         }\n     } else if is_view_item(p) {\n-        let vi = parse_view_item(p);\n+        let vi = parse_view_item(p, outer_attrs);\n         ret spanned(lo, vi.span.hi, cdir_view_item(vi));\n     } else { ret p.fatal(\"expected crate directive\"); }\n }"}, {"sha": "590a371da07e1467493e1d33be07b9b5d32336fb", "filename": "src/rustc/front/core_inject.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Frustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Frustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fcore_inject.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -30,10 +30,16 @@ fn inject_libcore_ref(sess: session,\n     let n1 = sess.next_node_id();\n     let n2 = sess.next_node_id();\n \n-    let vi1 = spanned(ast::view_item_use(\"core\", [], n1));\n+    let vi1 = @{node: ast::view_item_use(\"core\", [], n1),\n+                attrs: [],\n+                vis: ast::public,\n+                span: dummy_sp()};\n     let vp = spanned(ast::view_path_glob(ident_to_path(dummy_sp(), \"core\"),\n                                          n2));\n-    let vi2 = spanned(ast::view_item_import([vp]));\n+    let vi2 = @{node: ast::view_item_import([vp]),\n+                attrs: [],\n+                vis: ast::public,\n+                span: dummy_sp()};\n \n     let vis = [vi1, vi2] + crate.node.module.view_items;\n "}, {"sha": "42d93b8220893bec4aeb28e02024d69a5f9797e4", "filename": "src/test/compile-fail/ext-after-attrib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fext-after-attrib.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:expecting '[' but found 'fmt'\n+// error-pattern:expected item but found '#'\n \n // Don't know how to deal with a syntax extension appearing after an\n // item attribute. Probably could use a better error message."}, {"sha": "60788d65b825e12584f1afee869060a1259484b0", "filename": "src/test/run-pass/attr-before-view-item.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Ftest%2Frun-pass%2Fattr-before-view-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Ftest%2Frun-pass%2Fattr-before-view-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-before-view-item.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "previous_filename": "src/test/compile-fail/attr-before-view-item.rs"}, {"sha": "539f028d61123bb52d3813660320ea4d7f21bfd4", "filename": "src/test/run-pass/attr-before-view-item2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Ftest%2Frun-pass%2Fattr-before-view-item2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a159a6eaea213c2b9b9582a133a718bc967eac/src%2Ftest%2Frun-pass%2Fattr-before-view-item2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fattr-before-view-item2.rs?ref=96a159a6eaea213c2b9b9582a133a718bc967eac", "previous_filename": "src/test/compile-fail/attr-before-view-item2.rs"}]}