{"sha": "ef870d37a58df136b18f1440f45d4f0102c55c1a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmODcwZDM3YTU4ZGYxMzZiMThmMTQ0MGY0NWQ0ZjAxMDJjNTVjMWE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-30T04:33:52Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-07-30T06:50:31Z"}, "message": "implement pointer arithmetic with GEP\n\nCloses #8118, #7136\n\n~~~rust\nextern mod extra;\n\nuse std::vec;\nuse std::ptr;\n\nfn bench_from_elem(b: &mut extra::test::BenchHarness) {\n    do b.iter {\n        let v: ~[u8] = vec::from_elem(1024, 0u8);\n    }\n}\n\nfn bench_set_memory(b: &mut extra::test::BenchHarness) {\n    do b.iter {\n        let mut v: ~[u8] = vec::with_capacity(1024);\n        unsafe {\n            let vp = vec::raw::to_mut_ptr(v);\n            ptr::set_memory(vp, 0, 1024);\n            vec::raw::set_len(&mut v, 1024);\n        }\n    }\n}\n\nfn bench_vec_repeat(b: &mut extra::test::BenchHarness) {\n    do b.iter {\n        let v: ~[u8] = ~[0u8, ..1024];\n    }\n}\n~~~\n\nBefore:\n\n    test bench_from_elem ... bench: 415 ns/iter (+/- 17)\n    test bench_set_memory ... bench: 85 ns/iter (+/- 4)\n    test bench_vec_repeat ... bench: 83 ns/iter (+/- 3)\n\nAfter:\n\n    test bench_from_elem ... bench: 84 ns/iter (+/- 2)\n    test bench_set_memory ... bench: 84 ns/iter (+/- 5)\n    test bench_vec_repeat ... bench: 84 ns/iter (+/- 3)", "tree": {"sha": "3f30f5d551a247978a6fc1a6af602126ed518121", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f30f5d551a247978a6fc1a6af602126ed518121"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef870d37a58df136b18f1440f45d4f0102c55c1a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef870d37a58df136b18f1440f45d4f0102c55c1a", "html_url": "https://github.com/rust-lang/rust/commit/ef870d37a58df136b18f1440f45d4f0102c55c1a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef870d37a58df136b18f1440f45d4f0102c55c1a/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e94e4d51ca01db908748ab79bafe3254bede645b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e94e4d51ca01db908748ab79bafe3254bede645b", "html_url": "https://github.com/rust-lang/rust/commit/e94e4d51ca01db908748ab79bafe3254bede645b"}], "stats": {"total": 211, "additions": 131, "deletions": 80}, "files": [{"sha": "efe1d47563e84644580d2dba91c5fdc7b0ff3424", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -116,7 +116,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n     let fill = chunk.fill;\n \n     while idx < fill {\n-        let tydesc_data: *uint = transmute(ptr::offset(buf, idx));\n+        let tydesc_data: *uint = transmute(ptr::offset(buf, idx as int));\n         let (tydesc, is_done) = un_bitpack_tydesc_ptr(*tydesc_data);\n         let (size, align) = ((*tydesc).size, (*tydesc).align);\n \n@@ -127,7 +127,7 @@ unsafe fn destroy_chunk(chunk: &Chunk) {\n         //debug!(\"freeing object: idx = %u, size = %u, align = %u, done = %b\",\n         //       start, size, align, is_done);\n         if is_done {\n-            ((*tydesc).drop_glue)(ptr::offset(buf, start) as *i8);\n+            ((*tydesc).drop_glue)(ptr::offset(buf, start as int) as *i8);\n         }\n \n         // Find where the next tydesc lives\n@@ -176,7 +176,7 @@ impl Arena {\n             //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n             //       start, n_bytes, align, head.fill);\n \n-            ptr::offset(vec::raw::to_ptr(this.pod_head.data), start)\n+            ptr::offset(vec::raw::to_ptr(this.pod_head.data), start as int)\n         }\n     }\n \n@@ -233,7 +233,7 @@ impl Arena {\n             //       start, n_bytes, align, head.fill);\n \n             let buf = vec::raw::to_ptr(self.head.data);\n-            return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n+            return (ptr::offset(buf, tydesc_start as int), ptr::offset(buf, start as int));\n         }\n     }\n "}, {"sha": "e656360aa5a793c859d2059d284ad43131e0b681", "filename": "src/libextra/c_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fc_vec.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -122,7 +122,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n pub fn get<T:Clone>(t: CVec<T>, ofs: uint) -> T {\n     assert!(ofs < len(t));\n     return unsafe {\n-        (*ptr::mut_offset(t.base, ofs)).clone()\n+        (*ptr::mut_offset(t.base, ofs as int)).clone()\n     };\n }\n \n@@ -133,7 +133,7 @@ pub fn get<T:Clone>(t: CVec<T>, ofs: uint) -> T {\n  */\n pub fn set<T>(t: CVec<T>, ofs: uint, v: T) {\n     assert!(ofs < len(t));\n-    unsafe { *ptr::mut_offset(t.base, ofs) = v };\n+    unsafe { *ptr::mut_offset(t.base, ofs as int) = v };\n }\n \n /*"}, {"sha": "f66677c21f7d11c2e40d53e348a14ed5f33bc16b", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -150,7 +150,7 @@ pub mod reader {\n \n         unsafe {\n             let (ptr, _): (*u8, uint) = transmute(data);\n-            let ptr = offset(ptr, start);\n+            let ptr = offset(ptr, start as int);\n             let ptr: *i32 = transmute(ptr);\n             let val = bswap32(*ptr);\n             let val: u32 = transmute(val);"}, {"sha": "4069c68e71c11decd173bdc1def1a4a745daa9b4", "filename": "src/libextra/par.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -58,7 +58,7 @@ fn map_slices<A:Clone + Send,B:Clone + Send>(\n                 let f = do future_spawn() || {\n                     unsafe {\n                         let len = end - base;\n-                        let slice = (ptr::offset(p, base),\n+                        let slice = (ptr::offset(p, base as int),\n                                      len * sys::size_of::<A>());\n                         info!(\"pre-slice: %?\", (base, slice));\n                         let slice : &[A] ="}, {"sha": "1037e3a762879c223263638351ba004147a3a7c5", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -215,7 +215,7 @@ fn get_metadata_section(os: os,\n                 }\n                 if !version_ok { return None; }\n \n-                let cvbuf1 = ptr::offset(cvbuf, vlen);\n+                let cvbuf1 = ptr::offset(cvbuf, vlen as int);\n                 debug!(\"inflating %u bytes of compressed metadata\",\n                        csz - vlen);\n                 do vec::raw::buf_as_slice(cvbuf1, csz-vlen) |bytes| {"}, {"sha": "f1850beb9a194bb46ff6a1d41bd7d8419c45f6e1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -884,6 +884,11 @@ pub fn trans_intrinsic(ccx: @mut CrateContext,\n             let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());\n             Ret(bcx, morestack_addr);\n         }\n+        \"offset\" => {\n+            let ptr = get_param(decl, first_real_arg);\n+            let offset = get_param(decl, first_real_arg + 1);\n+            Ret(bcx, GEP(bcx, ptr, [offset]));\n+        }\n         \"memcpy32\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i32\", substs.tys[0], 32),\n         \"memcpy64\" => memcpy_intrinsic(bcx, \"llvm.memcpy.p0i8.p0i8.i64\", substs.tys[0], 64),\n         \"memmove32\" => memcpy_intrinsic(bcx, \"llvm.memmove.p0i8.p0i8.i32\", substs.tys[0], 32),"}, {"sha": "61bb989764a94f19cd4e63738d13b5279e475a91", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -149,7 +149,7 @@ pub fn type_uses_for(ccx: @mut CrateContext, fn_id: def_id, n_tps: uint)\n                     \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n                     \"morestack_addr\" => 0,\n \n-                    \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n+                    \"offset\" | \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n                     \"memset32\" | \"memset64\" => use_repr,\n \n                     \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |"}, {"sha": "4c408147383da7a51b56237de43e7bd96260bd25", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -3606,6 +3606,20 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"morestack_addr\" => {\n               (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n             }\n+            \"offset\" => {\n+              (1,\n+               ~[\n+                  ty::mk_ptr(tcx, ty::mt {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::m_imm\n+                  }),\n+                  ty::mk_int()\n+               ],\n+               ty::mk_ptr(tcx, ty::mt {\n+                   ty: param(ccx, 0),\n+                   mutbl: ast::m_imm\n+               }))\n+            }\n             \"memcpy32\" => {\n               (1,\n                ~["}, {"sha": "8e5b6b9311116377f928cf6d321b9b64efd406a6", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -233,7 +233,7 @@ pub mod raw {\n         let repr: *mut Box<Vec<T>> = cast::transmute_copy(v);\n         let amt = v.len();\n         (*repr).data.fill += sys::size_of::<T>();\n-        let p = ptr::offset(&(*repr).data.data as *T, amt) as *mut T;\n+        let p = ptr::offset(&(*repr).data.data as *T, amt as int) as *mut T;\n         move_val_init(&mut(*p), initval);\n     }\n "}, {"sha": "ee270b553e68b765e3eab4cd3ab5b393adb860ad", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -74,7 +74,7 @@ pub mod rustrt {\n }\n \n unsafe fn bump<T, U>(ptr: *T, count: uint) -> *U {\n-    return ptr::offset(ptr, count) as *U;\n+    return ptr::offset(ptr, count as int) as *U;\n }\n \n unsafe fn align_to_pointer<T>(ptr: *T) -> *T {\n@@ -140,11 +140,11 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     // Stack roots\n     let mut sri = 0;\n     while sri < num_stack_roots {\n-        if *ptr::offset(addrspaces, sri) >= 1 {\n+        if *ptr::offset(addrspaces, sri as int) >= 1 {\n             let root =\n-                ptr::offset(fp_bytes, *ptr::offset(stack_roots, sri) as Word)\n+                ptr::offset(fp_bytes, *ptr::offset(stack_roots, sri as int) as int)\n                 as **Word;\n-            let tydescpp = ptr::offset(tydescs, sri);\n+            let tydescpp = ptr::offset(tydescs, sri as int);\n             let tydesc = if ptr::is_not_null(tydescpp) &&\n                 ptr::is_not_null(*tydescpp) {\n                 **tydescpp\n@@ -159,7 +159,7 @@ unsafe fn _walk_safe_point(fp: *Word, sp: SafePoint, visitor: Visitor) -> bool {\n     // Register roots\n     let mut rri = 0;\n     while rri < num_reg_roots {\n-        if *ptr::offset(addrspaces, num_stack_roots + rri) == 1 {\n+        if *ptr::offset(addrspaces, (num_stack_roots + rri) as int) == 1 {\n             // FIXME(#2997): Need to find callee saved registers on the stack.\n         }\n         rri += 1;\n@@ -246,7 +246,7 @@ unsafe fn _walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) -> boo\n         // for this second return address is 3 greater than the\n         // return address for morestack.\n         let ret_offset = if boundary { 4 } else { 1 };\n-        last_ret = *ptr::offset(frame.fp, ret_offset) as *Word;\n+        last_ret = *ptr::offset(frame.fp, ret_offset as int) as *Word;\n \n         if ptr::is_null(pc) {\n             loop;"}, {"sha": "1a92e5e07c72d19bd6345612ea655b12fd336eb4", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -1213,7 +1213,7 @@ impl Writer for fd_t {\n             let mut count = 0u;\n             do v.as_imm_buf |vbuf, len| {\n                 while count < len {\n-                    let vb = ptr::offset(vbuf, count) as *c_void;\n+                    let vb = ptr::offset(vbuf, count as int) as *c_void;\n                     let nout = libc::write(*self, vb, len as size_t);\n                     if nout < 0 as ssize_t {\n                         error!(\"error writing buffer\");"}, {"sha": "ac03735894a057f6c5b78b173034e48f6119f617", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -1114,7 +1114,7 @@ pub fn set_exit_status(code: int) {\n unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n     let mut args = ~[];\n     for uint::range(0, argc as uint) |i| {\n-        args.push(str::raw::from_c_str(*argv.offset(i)));\n+        args.push(str::raw::from_c_str(*argv.offset(i as int)));\n     }\n     args\n }\n@@ -1165,9 +1165,9 @@ pub fn real_args() -> ~[~str] {\n     for uint::range(0, nArgs as uint) |i| {\n         unsafe {\n             // Determine the length of this argument.\n-            let ptr = *szArgList.offset(i);\n+            let ptr = *szArgList.offset(i as int);\n             let mut len = 0;\n-            while *ptr.offset(len) != 0 { len += 1; }\n+            while *ptr.offset(len as int) != 0 { len += 1; }\n \n             // Push it onto the list.\n             args.push(vec::raw::buf_as_slice(ptr, len,"}, {"sha": "3af4769fcdb43d2436f6aea63cbc624d1b38d767", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -13,6 +13,7 @@\n use cast;\n use clone::Clone;\n use option::{Option, Some, None};\n+#[cfg(stage0)]\n use sys;\n use unstable::intrinsics;\n use util::swap;\n@@ -25,20 +26,44 @@ use uint;\n \n /// Calculate the offset from a pointer\n #[inline]\n-pub fn offset<T>(ptr: *T, count: uint) -> *T {\n-    (ptr as uint + count * sys::size_of::<T>()) as *T\n+#[cfg(stage0)]\n+pub fn offset<T>(ptr: *T, count: int) -> *T {\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a const pointer\n #[inline]\n-pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n-    (ptr as uint + count * sys::size_of::<T>()) as *T\n+#[cfg(stage0)]\n+pub fn const_offset<T>(ptr: *const T, count: int) -> *const T {\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a mut pointer\n #[inline]\n-pub fn mut_offset<T>(ptr: *mut T, count: uint) -> *mut T {\n-    (ptr as uint + count * sys::size_of::<T>()) as *mut T\n+#[cfg(stage0)]\n+pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *mut T\n+}\n+\n+/// Calculate the offset from a pointer\n+#[inline]\n+#[cfg(not(stage0))]\n+pub fn offset<T>(ptr: *T, count: int) -> *T {\n+    unsafe { intrinsics::offset(ptr, count) }\n+}\n+\n+/// Calculate the offset from a const pointer\n+#[inline]\n+#[cfg(not(stage0))]\n+pub fn const_offset<T>(ptr: *const T, count: int) -> *const T {\n+    unsafe { intrinsics::offset(ptr as *T, count) }\n+}\n+\n+/// Calculate the offset from a mut pointer\n+#[inline]\n+#[cfg(not(stage0))]\n+pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n+    unsafe { intrinsics::offset(ptr as *T, count) as *mut T }\n }\n \n /// Return the offset of the first null pointer in `buf`.\n@@ -58,7 +83,7 @@ impl<T> Clone for *T {\n pub unsafe fn position<T>(buf: *T, f: &fn(&T) -> bool) -> uint {\n     let mut i = 0;\n     loop {\n-        if f(&(*offset(buf, i))) { return i; }\n+        if f(&(*offset(buf, i as int))) { return i; }\n         else { i += 1; }\n     }\n }\n@@ -242,7 +267,7 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n     }\n     //let start_ptr = *arr;\n     uint::iterate(0, len, |e| {\n-        let n = offset(arr, e);\n+        let n = offset(arr, e as int);\n         cb(*n);\n         true\n     });\n@@ -273,7 +298,7 @@ pub trait RawPtr<T> {\n     fn is_null(&self) -> bool;\n     fn is_not_null(&self) -> bool;\n     unsafe fn to_option(&self) -> Option<&T>;\n-    fn offset(&self, count: uint) -> Self;\n+    fn offset(&self, count: int) -> Self;\n }\n \n /// Extension methods for immutable pointers\n@@ -305,7 +330,7 @@ impl<T> RawPtr<T> for *T {\n \n     /// Calculates the offset from a pointer.\n     #[inline]\n-    fn offset(&self, count: uint) -> *T { offset(*self, count) }\n+    fn offset(&self, count: int) -> *T { offset(*self, count) }\n }\n \n /// Extension methods for mutable pointers\n@@ -337,7 +362,7 @@ impl<T> RawPtr<T> for *mut T {\n \n     /// Calculates the offset from a mutable pointer.\n     #[inline]\n-    fn offset(&self, count: uint) -> *mut T { mut_offset(*self, count) }\n+    fn offset(&self, count: int) -> *mut T { mut_offset(*self, count) }\n }\n \n // Equality for pointers\n@@ -378,7 +403,7 @@ impl<T, I: Int> Add<I, *T> for *T {\n     /// Is calculated according to the size of the type pointed to.\n     #[inline]\n     pub fn add(&self, rhs: &I) -> *T {\n-        self.offset(rhs.to_int() as uint)\n+        self.offset(rhs.to_int() as int)\n     }\n }\n \n@@ -388,7 +413,7 @@ impl<T, I: Int> Sub<I, *T> for *T {\n     /// Is calculated according to the size of the type pointed to.\n     #[inline]\n     pub fn sub(&self, rhs: &I) -> *T {\n-        self.offset(-rhs.to_int() as uint)\n+        self.offset(-rhs.to_int() as int)\n     }\n }\n \n@@ -398,7 +423,7 @@ impl<T, I: Int> Add<I, *mut T> for *mut T {\n     /// Is calculated according to the size of the type pointed to.\n     #[inline]\n     pub fn add(&self, rhs: &I) -> *mut T {\n-        self.offset(rhs.to_int() as uint)\n+        self.offset(rhs.to_int() as int)\n     }\n }\n \n@@ -408,7 +433,7 @@ impl<T, I: Int> Sub<I, *mut T> for *mut T {\n     /// Is calculated according to the size of the type pointed to.\n     #[inline]\n     pub fn sub(&self, rhs: &I) -> *mut T {\n-        self.offset(-rhs.to_int() as uint)\n+        self.offset(-rhs.to_int() as int)\n     }\n }\n \n@@ -445,14 +470,14 @@ pub mod ptr_tests {\n             let v0 = ~[32000u16, 32001u16, 32002u16];\n             let mut v1 = ~[0u16, 0u16, 0u16];\n \n-            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1u),\n-                        offset(vec::raw::to_ptr(v0), 1u), 1u);\n+            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 1),\n+                        offset(vec::raw::to_ptr(v0), 1), 1);\n             assert!((v1[0] == 0u16 && v1[1] == 32001u16 && v1[2] == 0u16));\n             copy_memory(vec::raw::to_mut_ptr(v1),\n-                        offset(vec::raw::to_ptr(v0), 2u), 1u);\n+                        offset(vec::raw::to_ptr(v0), 2), 1);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 0u16));\n-            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2u),\n+            copy_memory(mut_offset(vec::raw::to_mut_ptr(v1), 2),\n                         vec::raw::to_ptr(v0), 1u);\n             assert!((v1[0] == 32002u16 && v1[1] == 32001u16 &&\n                      v1[2] == 32000u16));\n@@ -495,15 +520,15 @@ pub mod ptr_tests {\n         assert!(p.is_null());\n         assert!(!p.is_not_null());\n \n-        let q = offset(p, 1u);\n+        let q = offset(p, 1);\n         assert!(!q.is_null());\n         assert!(q.is_not_null());\n \n         let mp: *mut int = mut_null();\n         assert!(mp.is_null());\n         assert!(!mp.is_not_null());\n \n-        let mq = mp.offset(1u);\n+        let mq = mp.offset(1);\n         assert!(!mq.is_null());\n         assert!(mq.is_not_null());\n     }"}, {"sha": "60bd30bbee86314cf7102213ddecbf9886bfe3a3", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -212,7 +212,7 @@ impl ReprVisitor {\n                 self.writer.write_str(\", \");\n             }\n             self.visit_ptr_inner(p as *c_void, inner);\n-            p = align(ptr::offset(p, sz) as uint, al) as *u8;\n+            p = align(ptr::offset(p, sz as int) as uint, al) as *u8;\n             left -= dec;\n         }\n         self.writer.write_char(']');"}, {"sha": "cd95047128601cf35ef8a349985ecf2e4afc713d", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -114,7 +114,7 @@ mod imp {\n     unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n         let mut args = ~[];\n         for uint::range(0, argc as uint) |i| {\n-            args.push(str::raw::from_c_str(*(argv as **libc::c_char).offset(i)));\n+            args.push(str::raw::from_c_str(*(argv as **libc::c_char).offset(i as int)));\n         }\n         return args;\n     }"}, {"sha": "a126996892118074cafbb00753f8347cbf63177b", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -44,7 +44,7 @@ impl StackSegment {\n \n     /// Point one word beyond the high end of the allocated stack\n     pub fn end(&self) -> *uint {\n-        vec::raw::to_ptr(self.buf).offset(self.buf.len()) as *uint\n+        vec::raw::to_ptr(self.buf).offset(self.buf.len() as int) as *uint\n     }\n }\n "}, {"sha": "6031632031bbe68cba639d9ca2399ed1a8024e4f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -191,7 +191,7 @@ impl<'self, S: Str> StrVector for &'self [S] {\n                     do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n-                        buf = buf.offset(sslen);\n+                        buf = buf.offset(sslen as int);\n                     }\n                 }\n             }\n@@ -227,10 +227,10 @@ impl<'self, S: Str> StrVector for &'self [S] {\n                                 first = false;\n                             } else {\n                                 ptr::copy_memory(buf, sepbuf, seplen);\n-                                buf = buf.offset(seplen);\n+                                buf = buf.offset(seplen as int);\n                             }\n                             ptr::copy_memory(buf, ssbuf, sslen);\n-                            buf = buf.offset(sslen);\n+                            buf = buf.offset(sslen as int);\n                         }\n                     }\n                 }\n@@ -783,7 +783,7 @@ pub mod raw {\n         let mut i = 0u;\n         while *curr != 0u8 {\n             i += 1u;\n-            curr = ptr::offset(buf, i);\n+            curr = ptr::offset(buf, i as int);\n         }\n         return from_buf_len(buf, i);\n     }\n@@ -844,7 +844,7 @@ pub mod raw {\n         let mut len = 0u;\n         while *curr != 0u8 {\n             len += 1u;\n-            curr = ptr::offset(s, len);\n+            curr = ptr::offset(s, len as int);\n         }\n         let v = Slice { data: s, len: len + 1 };\n         assert!(is_utf8(cast::transmute(v)));\n@@ -868,7 +868,7 @@ pub mod raw {\n              assert!((end <= n));\n \n              cast::transmute(Slice {\n-                 data: ptr::offset(sbuf, begin),\n+                 data: ptr::offset(sbuf, begin as int),\n                  len: end - begin + 1,\n              })\n         }\n@@ -879,7 +879,7 @@ pub mod raw {\n         let new_len = s.len() + 1;\n         s.reserve_at_least(new_len);\n         do s.as_mut_buf |buf, len| {\n-            *ptr::mut_offset(buf, len) = b;\n+            *ptr::mut_offset(buf, len as int) = b;\n         }\n         set_len(&mut *s, new_len);\n     }\n@@ -915,7 +915,7 @@ pub mod raw {\n         let v: **mut String = cast::transmute(v);\n         let repr = *v;\n         (*repr).fill = new_len + 1u;\n-        let null = ptr::mut_offset(&mut ((*repr).data), new_len);\n+        let null = ptr::mut_offset(&mut ((*repr).data), new_len as int);\n         *null = 0u8;\n     }\n \n@@ -1833,7 +1833,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n                     for nn.times {\n                         ptr::copy_memory(rbuf, buf, len);\n-                        rbuf = rbuf.offset(len);\n+                        rbuf = rbuf.offset(len as int);\n                     }\n                 }\n                 raw::set_len(&mut ret, nn * len);\n@@ -1973,7 +1973,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         do self.as_imm_buf |buf, len| {\n             // NB: len includes the trailing null.\n             assert!(len > 0);\n-            if unsafe { *(ptr::offset(buf, len - 1)) != 0 } {\n+            if unsafe { *(ptr::offset(buf, (len - 1) as int)) != 0 } {\n                 self.to_owned().as_c_str(|s| f(s))\n             } else {\n                 f(buf as *libc::c_char)\n@@ -2051,7 +2051,7 @@ impl OwnedStr for ~str {\n             self.reserve(llen + rlen);\n             do self.as_imm_buf |lbuf, _llen| {\n                 do rhs.as_imm_buf |rbuf, _rlen| {\n-                    let dst = ptr::offset(lbuf, llen);\n+                    let dst = ptr::offset(lbuf, llen as int);\n                     let dst = cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n                 }\n@@ -2069,7 +2069,7 @@ impl OwnedStr for ~str {\n             self.reserve_at_least(llen + rlen);\n             do self.as_imm_buf |lbuf, _llen| {\n                 do rhs.as_imm_buf |rbuf, _rlen| {\n-                    let dst = ptr::offset(lbuf, llen);\n+                    let dst = ptr::offset(lbuf, llen as int);\n                     let dst = cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n                 }\n@@ -2090,26 +2090,26 @@ impl OwnedStr for ~str {\n             let len = self.len();\n             let new_len = len + nb;\n             self.reserve_at_least(new_len);\n-            let off = len;\n+            let off = len as int;\n             do self.as_mut_buf |buf, _len| {\n                 match nb {\n                     1u => {\n                         *ptr::mut_offset(buf, off) = code as u8;\n                     }\n                     2u => {\n                         *ptr::mut_offset(buf, off) = (code >> 6u & 31u | TAG_TWO_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 1) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     3u => {\n                         *ptr::mut_offset(buf, off) = (code >> 12u & 15u | TAG_THREE_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code >> 6u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 2u) = (code & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 1) = (code >> 6u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 2) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     4u => {\n                         *ptr::mut_offset(buf, off) = (code >> 18u & 7u | TAG_FOUR_B) as u8;\n-                        *ptr::mut_offset(buf, off + 1u) = (code >> 12u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 2u) = (code >> 6u & 63u | TAG_CONT) as u8;\n-                        *ptr::mut_offset(buf, off + 3u) = (code & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 1) = (code >> 12u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 2) = (code >> 6u & 63u | TAG_CONT) as u8;\n+                        *ptr::mut_offset(buf, off + 3) = (code & 63u | TAG_CONT) as u8;\n                     }\n                     _ => {}\n                 }"}, {"sha": "5d6cd594f487b63400fa5e9223f2e0c89529a23b", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -321,6 +321,13 @@ extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n+    /// Adjust a pointer by an offset.\n+    ///\n+    /// This is implemented as an intrinsic to avoid converting to and from an\n+    /// integer, since the conversion would throw away aliasing information.\n+    #[cfg(not(stage0))]\n+    pub fn offset<T>(dst: *T, offset: int) -> *T;\n+\n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n     /// `count` * `size_of::<T>()` and an alignment of `min_align_of::<T>()`\n     pub fn memcpy32<T>(dst: *mut T, src: *T, count: u32);"}, {"sha": "72e8ad71b34b9e98dea3090ef4997726d333de59", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef870d37a58df136b18f1440f45d4f0102c55c1a/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=ef870d37a58df136b18f1440f45d4f0102c55c1a", "patch": "@@ -52,7 +52,7 @@ pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> ~[T] {\n         let p = raw::to_mut_ptr(v);\n         let mut i: uint = 0u;\n         while i < n_elts {\n-            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), op(i));\n+            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), op(i));\n             i += 1u;\n         }\n         raw::set_len(&mut v, n_elts);\n@@ -76,7 +76,7 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n         let p = raw::to_mut_ptr(v);\n         let mut i = 0u;\n         while i < n_elts {\n-            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)), t.clone());\n+            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), t.clone());\n             i += 1u;\n         }\n         raw::set_len(&mut v, n_elts);\n@@ -735,7 +735,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         do self.as_imm_buf |p, _len| {\n             unsafe {\n                 cast::transmute(Slice {\n-                    data: ptr::offset(p, start),\n+                    data: ptr::offset(p, start as int),\n                     len: (end - start) * sys::nonzero_size_of::<T>(),\n                 })\n             }\n@@ -947,7 +947,7 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// bounds checking.\n     #[inline]\n     unsafe fn unsafe_ref(&self, index: uint) -> *T {\n-        self.repr().data.offset(index)\n+        self.repr().data.offset(index as int)\n     }\n \n     /**\n@@ -1237,14 +1237,14 @@ impl<T> OwnedVector<T> for ~[T] {\n             let fill = (**repr).data.fill;\n             (**repr).data.fill += sys::nonzero_size_of::<T>();\n             let p = to_unsafe_ptr(&((**repr).data.data));\n-            let p = ptr::offset(p, fill) as *mut T;\n+            let p = ptr::offset(p, fill as int) as *mut T;\n             intrinsics::move_val_init(&mut(*p), t);\n         } else {\n             let repr: **mut Vec<u8> = cast::transmute(self);\n             let fill = (**repr).fill;\n             (**repr).fill += sys::nonzero_size_of::<T>();\n             let p = to_unsafe_ptr(&((**repr).data));\n-            let p = ptr::offset(p, fill) as *mut T;\n+            let p = ptr::offset(p, fill as int) as *mut T;\n             intrinsics::move_val_init(&mut(*p), t);\n         }\n     }\n@@ -1270,7 +1270,7 @@ impl<T> OwnedVector<T> for ~[T] {\n         unsafe { // Note: infallible.\n             let self_p = vec::raw::to_mut_ptr(*self);\n             let rhs_p = vec::raw::to_ptr(rhs);\n-            ptr::copy_memory(ptr::mut_offset(self_p, self_len), rhs_p, rhs_len);\n+            ptr::copy_memory(ptr::mut_offset(self_p, self_len as int), rhs_p, rhs_len);\n             raw::set_len(self, new_len);\n             raw::set_len(&mut rhs, 0);\n         }\n@@ -1351,7 +1351,7 @@ impl<T> OwnedVector<T> for ~[T] {\n \n             // Swap out the element we want from the end\n             let vp = raw::to_mut_ptr(*self);\n-            let vp = ptr::mut_offset(vp, next_ln - 1);\n+            let vp = ptr::mut_offset(vp, (next_ln - 1) as int);\n \n             Some(ptr::replace_ptr(vp, work_elt))\n         }\n@@ -1415,7 +1415,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n                 for uint::range(newlen, oldlen) |i| {\n-                    ptr::read_and_zero_ptr(ptr::mut_offset(p, i));\n+                    ptr::read_and_zero_ptr(ptr::mut_offset(p, i as int));\n                 }\n             }\n         }\n@@ -1634,8 +1634,8 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n             let mut w = 1;\n \n             while r < ln {\n-                let p_r = ptr::mut_offset(p, r);\n-                let p_wm1 = ptr::mut_offset(p, w - 1);\n+                let p_r = ptr::mut_offset(p, r as int);\n+                let p_wm1 = ptr::mut_offset(p, (w - 1) as int);\n                 if *p_r != *p_wm1 {\n                     if r != w {\n                         let p_w = ptr::mut_offset(p_wm1, 1);\n@@ -1702,7 +1702,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n         do self.as_mut_buf |p, _len| {\n             unsafe {\n                 cast::transmute(Slice {\n-                    data: ptr::mut_offset(p, start) as *T,\n+                    data: ptr::mut_offset(p, start as int) as *T,\n                     len: (end - start) * sys::nonzero_size_of::<T>()\n                 })\n             }\n@@ -1793,7 +1793,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n \n     #[inline]\n     unsafe fn unsafe_mut_ref(self, index: uint) -> *mut T {\n-        ptr::mut_offset(self.repr().data as *mut T, index)\n+        ptr::mut_offset(self.repr().data as *mut T, index as int)\n     }\n \n     #[inline]\n@@ -1923,7 +1923,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn get<T:Clone>(v: &[T], i: uint) -> T {\n-        v.as_imm_buf(|p, _len| (*ptr::offset(p, i)).clone())\n+        v.as_imm_buf(|p, _len| (*ptr::offset(p, i as int)).clone())\n     }\n \n     /**\n@@ -1935,7 +1935,7 @@ pub mod raw {\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n         do v.as_mut_buf |p, _len| {\n-            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i)),\n+            intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)),\n                                       box.take_unwrap());\n         }\n     }\n@@ -2145,7 +2145,7 @@ impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n     fn idx(&self, index: uint) -> Option<&'self T> {\n         unsafe {\n             if index < self.indexable() {\n-                cast::transmute(self.ptr.offset(index))\n+                cast::transmute(self.ptr.offset(index as int))\n             } else {\n                 None\n             }"}]}