{"sha": "c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "node_id": "C_kwDOAAsO6NoAKGM1ZDgyZWQ3YTRhZDk0YTUzOGJiODdlNTAxNmU3ZDVjZTBiZDQzNGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T18:57:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-19T18:57:39Z"}, "message": "Auto merge of #102795 - lukas-code:constify-is-aligned-via-align-offset, r=oli-obk\n\nConstify `is_aligned` via `align_offset`\n\nAlternative to https://github.com/rust-lang/rust/pull/102753\n\nMake `align_offset` work in const eval (and not always return `usize::MAX`) and then use that to constify `is_aligned{_to}`.\n\nTracking Issue: https://github.com/rust-lang/rust/issues/104203", "tree": {"sha": "d750ff6e8581c0f61102ea195f0409ca77bd2f39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d750ff6e8581c0f61102ea195f0409ca77bd2f39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "html_url": "https://github.com/rust-lang/rust/commit/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a434286a96d61e9f55a3144004beec48206bb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a434286a96d61e9f55a3144004beec48206bb29", "html_url": "https://github.com/rust-lang/rust/commit/2a434286a96d61e9f55a3144004beec48206bb29"}, {"sha": "c9c017dfb55e375800c3e424311939a7ba3d4deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9c017dfb55e375800c3e424311939a7ba3d4deb", "html_url": "https://github.com/rust-lang/rust/commit/c9c017dfb55e375800c3e424311939a7ba3d4deb"}], "stats": {"total": 1081, "additions": 984, "deletions": 97}, "files": [{"sha": "04e68b96455251c2eeaa8651be41b7c88685b78f", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 135, "deletions": 53, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -1,8 +1,12 @@\n use rustc_hir::def::DefKind;\n+use rustc_hir::LangItem;\n use rustc_middle::mir;\n+use rustc_middle::mir::interpret::PointerArithmetic;\n+use rustc_middle::ty::layout::FnAbiOf;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use std::borrow::Borrow;\n use std::hash::Hash;\n+use std::ops::ControlFlow;\n \n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::fx::IndexEntry;\n@@ -17,58 +21,12 @@ use rustc_target::abi::{Align, Size};\n use rustc_target::spec::abi::Abi as CallAbi;\n \n use crate::interpret::{\n-    self, compile_time_machine, AllocId, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n+    self, compile_time_machine, AllocId, ConstAllocation, FnVal, Frame, ImmTy, InterpCx,\n+    InterpResult, OpTy, PlaceTy, Pointer, Scalar, StackPopUnwind,\n };\n \n use super::error::*;\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n-    /// \"Intercept\" a function call to a panic-related function\n-    /// because we have something special to do for it.\n-    /// If this returns successfully (`Ok`), the function should just be evaluated normally.\n-    fn hook_special_const_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx>],\n-    ) -> InterpResult<'tcx, Option<ty::Instance<'tcx>>> {\n-        // All `#[rustc_do_not_const_check]` functions should be hooked here.\n-        let def_id = instance.def_id();\n-\n-        if Some(def_id) == self.tcx.lang_items().panic_display()\n-            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n-        {\n-            // &str or &&str\n-            assert!(args.len() == 1);\n-\n-            let mut msg_place = self.deref_operand(&args[0])?;\n-            while msg_place.layout.ty.is_ref() {\n-                msg_place = self.deref_operand(&msg_place.into())?;\n-            }\n-\n-            let msg = Symbol::intern(self.read_str(&msg_place)?);\n-            let span = self.find_closest_untracked_caller_location();\n-            let (file, line, col) = self.location_triple_for_span(span);\n-            return Err(ConstEvalErrKind::Panic { msg, file, line, col }.into());\n-        } else if Some(def_id) == self.tcx.lang_items().panic_fmt() {\n-            // For panic_fmt, call const_panic_fmt instead.\n-            if let Some(const_panic_fmt) = self.tcx.lang_items().const_panic_fmt() {\n-                return Ok(Some(\n-                    ty::Instance::resolve(\n-                        *self.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        const_panic_fmt,\n-                        self.tcx.intern_substs(&[]),\n-                    )\n-                    .unwrap()\n-                    .unwrap(),\n-                ));\n-            }\n-        }\n-        Ok(None)\n-    }\n-}\n-\n /// Extra machine state for CTFE, and the Machine instance\n pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// For now, the number of terminators that can be evaluated before we throw a resource\n@@ -191,6 +149,125 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n+    /// \"Intercept\" a function call, because we have something special to do for it.\n+    /// All `#[rustc_do_not_const_check]` functions should be hooked here.\n+    /// If this returns `Some` function, which may be `instance` or a different function with\n+    /// compatible arguments, then evaluation should continue with that function.\n+    /// If this returns `None`, the function call has been handled and the function has returned.\n+    fn hook_special_const_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: &PlaceTy<'tcx>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx, Option<ty::Instance<'tcx>>> {\n+        let def_id = instance.def_id();\n+\n+        if Some(def_id) == self.tcx.lang_items().panic_display()\n+            || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n+        {\n+            // &str or &&str\n+            assert!(args.len() == 1);\n+\n+            let mut msg_place = self.deref_operand(&args[0])?;\n+            while msg_place.layout.ty.is_ref() {\n+                msg_place = self.deref_operand(&msg_place.into())?;\n+            }\n+\n+            let msg = Symbol::intern(self.read_str(&msg_place)?);\n+            let span = self.find_closest_untracked_caller_location();\n+            let (file, line, col) = self.location_triple_for_span(span);\n+            return Err(ConstEvalErrKind::Panic { msg, file, line, col }.into());\n+        } else if Some(def_id) == self.tcx.lang_items().panic_fmt() {\n+            // For panic_fmt, call const_panic_fmt instead.\n+            let const_def_id = self.tcx.require_lang_item(LangItem::ConstPanicFmt, None);\n+            let new_instance = ty::Instance::resolve(\n+                *self.tcx,\n+                ty::ParamEnv::reveal_all(),\n+                const_def_id,\n+                instance.substs,\n+            )\n+            .unwrap()\n+            .unwrap();\n+\n+            return Ok(Some(new_instance));\n+        } else if Some(def_id) == self.tcx.lang_items().align_offset_fn() {\n+            // For align_offset, we replace the function call if the pointer has no address.\n+            match self.align_offset(instance, args, dest, ret)? {\n+                ControlFlow::Continue(()) => return Ok(Some(instance)),\n+                ControlFlow::Break(()) => return Ok(None),\n+            }\n+        }\n+        Ok(Some(instance))\n+    }\n+\n+    /// `align_offset(ptr, target_align)` needs special handling in const eval, because the pointer\n+    /// may not have an address.\n+    ///\n+    /// If `ptr` does have a known address, then we return `CONTINUE` and the function call should\n+    /// proceed as normal.\n+    ///\n+    /// If `ptr` doesn't have an address, but its underlying allocation's alignment is at most\n+    /// `target_align`, then we call the function again with an dummy address relative to the\n+    /// allocation.\n+    ///\n+    /// If `ptr` doesn't have an address and `target_align` is stricter than the underlying\n+    /// allocation's alignment, then we return `usize::MAX` immediately.\n+    fn align_offset(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: &PlaceTy<'tcx>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx, ControlFlow<()>> {\n+        assert_eq!(args.len(), 2);\n+\n+        let ptr = self.read_pointer(&args[0])?;\n+        let target_align = self.read_scalar(&args[1])?.to_machine_usize(self)?;\n+\n+        if !target_align.is_power_of_two() {\n+            throw_ub_format!(\"`align_offset` called with non-power-of-two align: {}\", target_align);\n+        }\n+\n+        match self.ptr_try_get_alloc_id(ptr) {\n+            Ok((alloc_id, offset, _extra)) => {\n+                let (_size, alloc_align, _kind) = self.get_alloc_info(alloc_id);\n+\n+                if target_align <= alloc_align.bytes() {\n+                    // Extract the address relative to the allocation base that is definitely\n+                    // sufficiently aligned and call `align_offset` again.\n+                    let addr = ImmTy::from_uint(offset.bytes(), args[0].layout).into();\n+                    let align = ImmTy::from_uint(target_align, args[1].layout).into();\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty())?;\n+\n+                    // We replace the entire entire function call with a \"tail call\".\n+                    // Note that this happens before the frame of the original function\n+                    // is pushed on the stack.\n+                    self.eval_fn_call(\n+                        FnVal::Instance(instance),\n+                        (CallAbi::Rust, fn_abi),\n+                        &[addr, align],\n+                        /* with_caller_location = */ false,\n+                        dest,\n+                        ret,\n+                        StackPopUnwind::NotAllowed,\n+                    )?;\n+                    Ok(ControlFlow::BREAK)\n+                } else {\n+                    // Not alignable in const, return `usize::MAX`.\n+                    let usize_max = Scalar::from_machine_usize(self.machine_usize_max(), self);\n+                    self.write_scalar(usize_max, dest)?;\n+                    self.return_to_block(ret)?;\n+                    Ok(ControlFlow::BREAK)\n+                }\n+            }\n+            Err(_addr) => {\n+                // The pointer has an address, continue with function call.\n+                Ok(ControlFlow::CONTINUE)\n+            }\n+        }\n+    }\n+\n     /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n     fn guaranteed_cmp(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, u8> {\n         Ok(match (a, b) {\n@@ -271,8 +348,8 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         instance: ty::Instance<'tcx>,\n         _abi: CallAbi,\n         args: &[OpTy<'tcx>],\n-        _dest: &PlaceTy<'tcx>,\n-        _ret: Option<mir::BasicBlock>,\n+        dest: &PlaceTy<'tcx>,\n+        ret: Option<mir::BasicBlock>,\n         _unwind: StackPopUnwind, // unwinding is not supported in consts\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n         debug!(\"find_mir_or_eval_fn: {:?}\", instance);\n@@ -291,7 +368,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                 }\n             }\n \n-            if let Some(new_instance) = ecx.hook_special_const_fn(instance, args)? {\n+            let Some(new_instance) = ecx.hook_special_const_fn(instance, args, dest, ret)? else {\n+                return Ok(None);\n+            };\n+\n+            if new_instance != instance {\n                 // We call another const fn instead.\n                 // However, we return the *original* instance to make backtraces work out\n                 // (and we hope this does not confuse the FnAbi checks too much).\n@@ -300,13 +381,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     new_instance,\n                     _abi,\n                     args,\n-                    _dest,\n-                    _ret,\n+                    dest,\n+                    ret,\n                     _unwind,\n                 )?\n                 .map(|(body, _instance)| (body, instance)));\n             }\n         }\n+\n         // This is a const fn. Call it.\n         Ok(Some((ecx.load_mir(instance.def, None)?, instance)))\n     }"}, {"sha": "7940efcd2b11f1517a22631f0d5a4d77616ece7d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -243,6 +243,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let discr_val = self.read_discriminant(&place.into())?.0;\n                 self.write_scalar(discr_val, dest)?;\n             }\n+            sym::exact_div => {\n+                let l = self.read_immediate(&args[0])?;\n+                let r = self.read_immediate(&args[1])?;\n+                self.exact_div(&l, &r, dest)?;\n+            }\n             sym::unchecked_shl\n             | sym::unchecked_shr\n             | sym::unchecked_add"}, {"sha": "7ed7d767f2fb5b42955ac6c80cccaba8e9003885", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -1851,6 +1851,7 @@ extern \"rust-intrinsic\" {\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_const_unstable(feature = \"const_exact_div\", issue = \"none\")]\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior"}, {"sha": "848eccd7f2908ef05ac3a55930797e5c429465e1", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -109,6 +109,7 @@\n #![feature(const_cmp)]\n #![feature(const_discriminant)]\n #![feature(const_eval_select)]\n+#![feature(const_exact_div)]\n #![feature(const_float_bits_conv)]\n #![feature(const_float_classify)]\n #![feature(const_fmt_arguments_new)]\n@@ -129,6 +130,7 @@\n #![feature(const_option)]\n #![feature(const_option_ext)]\n #![feature(const_pin)]\n+#![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_sub_ptr)]\n #![feature(const_replace)]\n #![feature(const_result_drop)]"}, {"sha": "8a3eee0dc529f59988bdaa1fdaa8f9f8c5ddb843", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 241, "deletions": 17, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -1320,6 +1320,8 @@ impl<T: ?Sized> *const T {\n     /// }\n     /// # }\n     /// ```\n+    #[must_use]\n+    #[inline]\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n     pub const fn align_offset(self, align: usize) -> usize\n@@ -1330,32 +1332,149 @@ impl<T: ?Sized> *const T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n \n-        fn rt_impl<T>(p: *const T, align: usize) -> usize {\n-            // SAFETY: `align` has been checked to be a power of 2 above\n-            unsafe { align_offset(p, align) }\n-        }\n+        #[cfg(bootstrap)]\n+        {\n+            fn rt_impl<T>(p: *const T, align: usize) -> usize {\n+                // SAFETY: `align` has been checked to be a power of 2 above\n+                unsafe { align_offset(p, align) }\n+            }\n+\n+            const fn ctfe_impl<T>(_: *const T, _: usize) -> usize {\n+                usize::MAX\n+            }\n \n-        const fn ctfe_impl<T>(_: *const T, _: usize) -> usize {\n-            usize::MAX\n+            // SAFETY:\n+            // It is permissible for `align_offset` to always return `usize::MAX`,\n+            // algorithm correctness can not depend on `align_offset` returning non-max values.\n+            //\n+            // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n+            unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n         }\n \n-        // SAFETY:\n-        // It is permissible for `align_offset` to always return `usize::MAX`,\n-        // algorithm correctness can not depend on `align_offset` returning non-max values.\n-        //\n-        // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n-        unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n+        #[cfg(not(bootstrap))]\n+        {\n+            // SAFETY: `align` has been checked to be a power of 2 above\n+            unsafe { align_offset(self, align) }\n+        }\n     }\n \n     /// Returns whether the pointer is properly aligned for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let data = AlignedI32(42);\n+    /// let ptr = &data as *const AlignedI32;\n+    ///\n+    /// assert!(ptr.is_aligned());\n+    /// assert!(!ptr.wrapping_byte_add(1).is_aligned());\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// is never aligned if cast to a type with a stricter alignment than the reference's\n+    /// underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// const _: () = {\n+    ///     let data = AlignedI32(42);\n+    ///     let ptr = &data as *const AlignedI32;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // At runtime either `ptr1` or `ptr2` would be aligned, but at compiletime neither is aligned.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n+    ///     assert!(!ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// const COMPTIME_PTR: *const AlignedI32 = &AlignedI32(42);\n+    /// const _: () = assert!(!COMPTIME_PTR.cast::<AlignedI64>().is_aligned());\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).cast::<AlignedI64>().is_aligned());\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = COMPTIME_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.cast::<AlignedI64>().is_aligned(),\n+    ///     runtime_ptr.wrapping_add(1).cast::<AlignedI64>().is_aligned(),\n+    /// );\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *const AlignedI32;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // For pointers with a known address, runtime and compiletime behavior are identical.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n+    ///     assert!(ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    pub fn is_aligned(self) -> bool\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n+    pub const fn is_aligned(self) -> bool\n     where\n         T: Sized,\n     {\n-        self.is_aligned_to(core::mem::align_of::<T>())\n+        self.is_aligned_to(mem::align_of::<T>())\n     }\n \n     /// Returns whether the pointer is aligned to `align`.\n@@ -1366,16 +1485,121 @@ impl<T: ?Sized> *const T {\n     /// # Panics\n     ///\n     /// The function panics if `align` is not a power-of-two (this includes 0).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let data = AlignedI32(42);\n+    /// let ptr = &data as *const AlignedI32;\n+    ///\n+    /// assert!(ptr.is_aligned_to(1));\n+    /// assert!(ptr.is_aligned_to(2));\n+    /// assert!(ptr.is_aligned_to(4));\n+    ///\n+    /// assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));\n+    /// assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));\n+    ///\n+    /// assert_ne!(ptr.is_aligned_to(8), ptr.wrapping_add(1).is_aligned_to(8));\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// cannot be stricter aligned than the reference's underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// const _: () = {\n+    ///     let data = AlignedI32(42);\n+    ///     let ptr = &data as *const AlignedI32;\n+    ///\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///\n+    ///     // At compiletime, we know for sure that the pointer isn't aligned to 8.\n+    ///     assert!(!ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.wrapping_add(1).is_aligned_to(8));\n+    /// };\n+    /// ```\n+    ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// const COMPTIME_PTR: *const AlignedI32 = &AlignedI32(42);\n+    /// const _: () = assert!(!COMPTIME_PTR.is_aligned_to(8));\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).is_aligned_to(8));\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = COMPTIME_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.is_aligned_to(8),\n+    ///     runtime_ptr.wrapping_add(1).is_aligned_to(8),\n+    /// );\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *const u8;\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///     assert!(ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.is_aligned_to(16));\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    pub fn is_aligned_to(self, align: usize) -> bool {\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n+    pub const fn is_aligned_to(self, align: usize) -> bool {\n         if !align.is_power_of_two() {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // Cast is needed for `T: !Sized`\n-        self.cast::<u8>().addr() & align - 1 == 0\n+        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+        // The cast to `()` is used to\n+        //   1. deal with fat pointers; and\n+        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+        self.cast::<()>().align_offset(align) == 0\n     }\n }\n "}, {"sha": "73923753a3020062ad6811df4849eb013a5dd970", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -1574,10 +1574,14 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n \n /// Align pointer `p`.\n ///\n-/// Calculate offset (in terms of elements of `stride` stride) that has to be applied\n+/// Calculate offset (in terms of elements of `size_of::<T>()` stride) that has to be applied\n /// to pointer `p` so that pointer `p` would get aligned to `a`.\n ///\n-/// Note: This implementation has been carefully tailored to not panic. It is UB for this to panic.\n+/// # Safety\n+/// `a` must be a power of two.\n+///\n+/// # Notes\n+/// This implementation has been carefully tailored to not panic. It is UB for this to panic.\n /// The only real change that can be made here is change of `INV_TABLE_MOD_16` and associated\n /// constants.\n ///\n@@ -1587,7 +1591,7 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n ///\n /// Any questions go to @nagisa.\n #[lang = \"align_offset\"]\n-pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n+pub(crate) const unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n     // 1, where the method versions of these operations are not inlined.\n     use intrinsics::{\n@@ -1604,7 +1608,7 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n     ///\n     /// Implementation of this function shall not panic. Ever.\n     #[inline]\n-    unsafe fn mod_inv(x: usize, m: usize) -> usize {\n+    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n         /// Multiplicative modular inverse table modulo 2\u2074 = 16.\n         ///\n         /// Note, that this table does not contain values where inverse does not exist (i.e., for\n@@ -1646,8 +1650,14 @@ pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n         inverse & m_minus_one\n     }\n \n-    let addr = p.addr();\n     let stride = mem::size_of::<T>();\n+\n+    // SAFETY: This is just an inlined `p.addr()` (which is not\n+    // a `const fn` so we cannot call it).\n+    // During const eval, we hook this function to ensure that the pointer never\n+    // has provenance, making this sound.\n+    let addr: usize = unsafe { mem::transmute(p) };\n+\n     // SAFETY: `a` is a power-of-two, therefore non-zero.\n     let a_minus_one = unsafe { unchecked_sub(a, 1) };\n "}, {"sha": "8472b05ddbd40a595f6b1d3bdb8d2b2ba98a5438", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 245, "deletions": 17, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -1588,6 +1588,8 @@ impl<T: ?Sized> *mut T {\n     /// }\n     /// # }\n     /// ```\n+    #[must_use]\n+    #[inline]\n     #[stable(feature = \"align_offset\", since = \"1.36.0\")]\n     #[rustc_const_unstable(feature = \"const_align_offset\", issue = \"90962\")]\n     pub const fn align_offset(self, align: usize) -> usize\n@@ -1598,32 +1600,151 @@ impl<T: ?Sized> *mut T {\n             panic!(\"align_offset: align is not a power-of-two\");\n         }\n \n-        fn rt_impl<T>(p: *mut T, align: usize) -> usize {\n-            // SAFETY: `align` has been checked to be a power of 2 above\n-            unsafe { align_offset(p, align) }\n+        #[cfg(bootstrap)]\n+        {\n+            fn rt_impl<T>(p: *mut T, align: usize) -> usize {\n+                // SAFETY: `align` has been checked to be a power of 2 above\n+                unsafe { align_offset(p, align) }\n+            }\n+\n+            const fn ctfe_impl<T>(_: *mut T, _: usize) -> usize {\n+                usize::MAX\n+            }\n+\n+            // SAFETY:\n+            // It is permissible for `align_offset` to always return `usize::MAX`,\n+            // algorithm correctness can not depend on `align_offset` returning non-max values.\n+            //\n+            // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n+            unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n         }\n \n-        const fn ctfe_impl<T>(_: *mut T, _: usize) -> usize {\n-            usize::MAX\n+        #[cfg(not(bootstrap))]\n+        {\n+            // SAFETY: `align` has been checked to be a power of 2 above\n+            unsafe { align_offset(self, align) }\n         }\n-\n-        // SAFETY:\n-        // It is permissible for `align_offset` to always return `usize::MAX`,\n-        // algorithm correctness can not depend on `align_offset` returning non-max values.\n-        //\n-        // As such the behaviour can't change after replacing `align_offset` with `usize::MAX`, only performance can.\n-        unsafe { intrinsics::const_eval_select((self, align), ctfe_impl, rt_impl) }\n     }\n \n     /// Returns whether the pointer is properly aligned for `T`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let mut data = AlignedI32(42);\n+    /// let ptr = &mut data as *mut AlignedI32;\n+    ///\n+    /// assert!(ptr.is_aligned());\n+    /// assert!(!ptr.wrapping_byte_add(1).is_aligned());\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// is never aligned if cast to a type with a stricter alignment than the reference's\n+    /// underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    /// #![feature(const_mut_refs)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// const _: () = {\n+    ///     let mut data = AlignedI32(42);\n+    ///     let ptr = &mut data as *mut AlignedI32;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // At runtime either `ptr1` or `ptr2` would be aligned, but at compiletime neither is aligned.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n+    ///     assert!(!ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// // Also, note that mutable references are not allowed in the final value of constants.\n+    /// const COMPTIME_PTR: *mut AlignedI32 = (&AlignedI32(42) as *const AlignedI32).cast_mut();\n+    /// const _: () = assert!(!COMPTIME_PTR.cast::<AlignedI64>().is_aligned());\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).cast::<AlignedI64>().is_aligned());\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = COMPTIME_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.cast::<AlignedI64>().is_aligned(),\n+    ///     runtime_ptr.wrapping_add(1).cast::<AlignedI64>().is_aligned(),\n+    /// );\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of primitives is less than their size.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    /// #[repr(align(8))]\n+    /// struct AlignedI64(i64);\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *mut AlignedI32;\n+    ///     assert!(ptr.is_aligned());\n+    ///\n+    ///     // For pointers with a known address, runtime and compiletime behavior are identical.\n+    ///     let ptr1 = ptr.cast::<AlignedI64>();\n+    ///     let ptr2 = ptr.wrapping_add(1).cast::<AlignedI64>();\n+    ///     assert!(ptr1.is_aligned());\n+    ///     assert!(!ptr2.is_aligned());\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    pub fn is_aligned(self) -> bool\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n+    pub const fn is_aligned(self) -> bool\n     where\n         T: Sized,\n     {\n-        self.is_aligned_to(core::mem::align_of::<T>())\n+        self.is_aligned_to(mem::align_of::<T>())\n     }\n \n     /// Returns whether the pointer is aligned to `align`.\n@@ -1634,16 +1755,123 @@ impl<T: ?Sized> *mut T {\n     /// # Panics\n     ///\n     /// The function panics if `align` is not a power-of-two (this includes 0).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    /// ```\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(pointer_byte_offsets)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// let mut data = AlignedI32(42);\n+    /// let ptr = &mut data as *mut AlignedI32;\n+    ///\n+    /// assert!(ptr.is_aligned_to(1));\n+    /// assert!(ptr.is_aligned_to(2));\n+    /// assert!(ptr.is_aligned_to(4));\n+    ///\n+    /// assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));\n+    /// assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));\n+    ///\n+    /// assert_ne!(ptr.is_aligned_to(8), ptr.wrapping_add(1).is_aligned_to(8));\n+    /// ```\n+    ///\n+    /// # At compiletime\n+    /// **Note: Alignment at compiletime is experimental and subject to change. See the\n+    /// [tracking issue] for details.**\n+    ///\n+    /// At compiletime, the compiler may not know where a value will end up in memory.\n+    /// Calling this function on a pointer created from a reference at compiletime will only\n+    /// return `true` if the pointer is guaranteed to be aligned. This means that the pointer\n+    /// cannot be stricter aligned than the reference's underlying allocation.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    /// #![feature(const_mut_refs)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// const _: () = {\n+    ///     let mut data = AlignedI32(42);\n+    ///     let ptr = &mut data as *mut AlignedI32;\n+    ///\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///\n+    ///     // At compiletime, we know for sure that the pointer isn't aligned to 8.\n+    ///     assert!(!ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.wrapping_add(1).is_aligned_to(8));\n+    /// };\n+    /// ```\n+    ///\n+    /// Due to this behavior, it is possible that a runtime pointer derived from a compiletime\n+    /// pointer is aligned, even if the compiletime pointer wasn't aligned.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// // On some platforms, the alignment of i32 is less than 4.\n+    /// #[repr(align(4))]\n+    /// struct AlignedI32(i32);\n+    ///\n+    /// // At compiletime, neither `COMPTIME_PTR` nor `COMPTIME_PTR + 1` is aligned.\n+    /// // Also, note that mutable references are not allowed in the final value of constants.\n+    /// const COMPTIME_PTR: *mut AlignedI32 = (&AlignedI32(42) as *const AlignedI32).cast_mut();\n+    /// const _: () = assert!(!COMPTIME_PTR.is_aligned_to(8));\n+    /// const _: () = assert!(!COMPTIME_PTR.wrapping_add(1).is_aligned_to(8));\n+    ///\n+    /// // At runtime, either `runtime_ptr` or `runtime_ptr + 1` is aligned.\n+    /// let runtime_ptr = COMPTIME_PTR;\n+    /// assert_ne!(\n+    ///     runtime_ptr.is_aligned_to(8),\n+    ///     runtime_ptr.wrapping_add(1).is_aligned_to(8),\n+    /// );\n+    /// ```\n+    ///\n+    /// If a pointer is created from a fixed address, this function behaves the same during\n+    /// runtime and compiletime.\n+    ///\n+    #[cfg_attr(bootstrap, doc = \"```ignore\")]\n+    #[cfg_attr(not(bootstrap), doc = \"```\")]\n+    /// #![feature(pointer_is_aligned)]\n+    /// #![feature(const_pointer_is_aligned)]\n+    ///\n+    /// const _: () = {\n+    ///     let ptr = 40 as *mut u8;\n+    ///     assert!(ptr.is_aligned_to(1));\n+    ///     assert!(ptr.is_aligned_to(2));\n+    ///     assert!(ptr.is_aligned_to(4));\n+    ///     assert!(ptr.is_aligned_to(8));\n+    ///     assert!(!ptr.is_aligned_to(16));\n+    /// };\n+    /// ```\n+    ///\n+    /// [tracking issue]: https://github.com/rust-lang/rust/issues/104203\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"pointer_is_aligned\", issue = \"96284\")]\n-    pub fn is_aligned_to(self, align: usize) -> bool {\n+    #[rustc_const_unstable(feature = \"const_pointer_is_aligned\", issue = \"104203\")]\n+    pub const fn is_aligned_to(self, align: usize) -> bool {\n         if !align.is_power_of_two() {\n             panic!(\"is_aligned_to: align is not a power-of-two\");\n         }\n \n-        // Cast is needed for `T: !Sized`\n-        self.cast::<u8>().addr() & align - 1 == 0\n+        // We can't use the address of `self` in a `const fn`, so we use `align_offset` instead.\n+        // The cast to `()` is used to\n+        //   1. deal with fat pointers; and\n+        //   2. ensure that `align_offset` doesn't actually try to compute an offset.\n+        self.cast::<()>().align_offset(align) == 0\n     }\n }\n "}, {"sha": "66d28770b87f9fbdf177d660434a337410b9d65d", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -4,6 +4,7 @@\n #![feature(array_windows)]\n #![feature(bigint_helper_methods)]\n #![feature(cell_update)]\n+#![feature(const_align_offset)]\n #![feature(const_assume)]\n #![feature(const_align_of_val_raw)]\n #![feature(const_black_box)]\n@@ -18,6 +19,7 @@\n #![feature(const_nonnull_new)]\n #![feature(const_num_from_num)]\n #![feature(const_pointer_byte_offsets)]\n+#![feature(const_pointer_is_aligned)]\n #![feature(const_ptr_as_ref)]\n #![feature(const_ptr_read)]\n #![feature(const_ptr_write)]\n@@ -81,6 +83,7 @@\n #![feature(never_type)]\n #![feature(unwrap_infallible)]\n #![feature(pointer_byte_offsets)]\n+#![feature(pointer_is_aligned)]\n #![feature(portable_simd)]\n #![feature(ptr_metadata)]\n #![feature(once_cell)]"}, {"sha": "390148550a4b398d891d2db7110a6dc19b24e9b4", "filename": "library/core/tests/ptr.rs", "status": "modified", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/library%2Fcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fptr.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -358,6 +358,23 @@ fn align_offset_zst() {\n     }\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_zst_const() {\n+    const {\n+        // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n+        // all, because no amount of elements will align the pointer.\n+        let mut p = 1;\n+        while p < 1024 {\n+            assert!(ptr::invalid::<()>(p).align_offset(p) == 0);\n+            if p != 1 {\n+                assert!(ptr::invalid::<()>(p + 1).align_offset(p) == !0);\n+            }\n+            p = (p + 1).next_power_of_two();\n+        }\n+    }\n+}\n+\n #[test]\n fn align_offset_stride_one() {\n     // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n@@ -379,6 +396,26 @@ fn align_offset_stride_one() {\n     }\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_stride_one_const() {\n+    const {\n+        // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n+        // number of bytes.\n+        let mut align = 1;\n+        while align < 1024 {\n+            let mut ptr = 1;\n+            while ptr < 2 * align {\n+                let expected = ptr % align;\n+                let offset = if expected == 0 { 0 } else { align - expected };\n+                assert!(ptr::invalid::<u8>(ptr).align_offset(align) == offset);\n+                ptr += 1;\n+            }\n+            align = (align + 1).next_power_of_two();\n+        }\n+    }\n+}\n+\n #[test]\n fn align_offset_various_strides() {\n     unsafe fn test_stride<T>(ptr: *const T, align: usize) -> bool {\n@@ -455,6 +492,182 @@ fn align_offset_various_strides() {\n     assert!(!x);\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_various_strides_const() {\n+    const unsafe fn test_stride<T>(ptr: *const T, numptr: usize, align: usize) {\n+        let mut expected = usize::MAX;\n+        // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n+        let mut el = 0;\n+        while el < align {\n+            if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {\n+                expected = el;\n+                break;\n+            }\n+            el += 1;\n+        }\n+        let got = ptr.align_offset(align);\n+        assert!(got == expected);\n+    }\n+\n+    const {\n+        // For pointers of stride != 1, we verify the algorithm against the naivest possible\n+        // implementation\n+        let mut align = 1;\n+        let limit = 32;\n+        while align < limit {\n+            let mut ptr = 1;\n+            while ptr < 4 * align {\n+                unsafe {\n+                    #[repr(packed)]\n+                    struct A3(u16, u8);\n+                    test_stride::<A3>(ptr::invalid::<A3>(ptr), ptr, align);\n+\n+                    struct A4(u32);\n+                    test_stride::<A4>(ptr::invalid::<A4>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A5(u32, u8);\n+                    test_stride::<A5>(ptr::invalid::<A5>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A6(u32, u16);\n+                    test_stride::<A6>(ptr::invalid::<A6>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A7(u32, u16, u8);\n+                    test_stride::<A7>(ptr::invalid::<A7>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A8(u32, u32);\n+                    test_stride::<A8>(ptr::invalid::<A8>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A9(u32, u32, u8);\n+                    test_stride::<A9>(ptr::invalid::<A9>(ptr), ptr, align);\n+\n+                    #[repr(packed)]\n+                    struct A10(u32, u32, u16);\n+                    test_stride::<A10>(ptr::invalid::<A10>(ptr), ptr, align);\n+\n+                    test_stride::<u32>(ptr::invalid::<u32>(ptr), ptr, align);\n+                    test_stride::<u128>(ptr::invalid::<u128>(ptr), ptr, align);\n+                }\n+                ptr += 1;\n+            }\n+            align = (align + 1).next_power_of_two();\n+        }\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_with_provenance_const() {\n+    const {\n+        // On some platforms (e.g. msp430-none-elf), the alignment of `i32` is less than 4.\n+        #[repr(align(4))]\n+        struct AlignedI32(i32);\n+\n+        let data = AlignedI32(42);\n+\n+        // `stride % align == 0` (usual case)\n+\n+        let ptr: *const i32 = &data.0;\n+        assert!(ptr.align_offset(1) == 0);\n+        assert!(ptr.align_offset(2) == 0);\n+        assert!(ptr.align_offset(4) == 0);\n+        assert!(ptr.align_offset(8) == usize::MAX);\n+        assert!(ptr.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr.wrapping_byte_add(1).align_offset(2) == usize::MAX);\n+        assert!(ptr.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr.wrapping_byte_add(2).align_offset(4) == usize::MAX);\n+        assert!(ptr.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr.wrapping_byte_add(3).align_offset(2) == usize::MAX);\n+\n+        assert!(ptr.wrapping_add(42).align_offset(4) == 0);\n+        assert!(ptr.wrapping_add(42).align_offset(8) == usize::MAX);\n+\n+        let ptr1: *const i8 = ptr.cast();\n+        assert!(ptr1.align_offset(1) == 0);\n+        assert!(ptr1.align_offset(2) == 0);\n+        assert!(ptr1.align_offset(4) == 0);\n+        assert!(ptr1.align_offset(8) == usize::MAX);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(2) == 1);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(4) == 3);\n+        assert!(ptr1.wrapping_byte_add(1).align_offset(8) == usize::MAX);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(4) == 2);\n+        assert!(ptr1.wrapping_byte_add(2).align_offset(8) == usize::MAX);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(2) == 1);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(4) == 1);\n+        assert!(ptr1.wrapping_byte_add(3).align_offset(8) == usize::MAX);\n+\n+        let ptr2: *const i16 = ptr.cast();\n+        assert!(ptr2.align_offset(1) == 0);\n+        assert!(ptr2.align_offset(2) == 0);\n+        assert!(ptr2.align_offset(4) == 0);\n+        assert!(ptr2.align_offset(8) == usize::MAX);\n+        assert!(ptr2.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr2.wrapping_byte_add(1).align_offset(2) == usize::MAX);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(4) == 1);\n+        assert!(ptr2.wrapping_byte_add(2).align_offset(8) == usize::MAX);\n+        assert!(ptr2.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr2.wrapping_byte_add(3).align_offset(2) == usize::MAX);\n+\n+        let ptr3: *const i64 = ptr.cast();\n+        assert!(ptr3.align_offset(1) == 0);\n+        assert!(ptr3.align_offset(2) == 0);\n+        assert!(ptr3.align_offset(4) == 0);\n+        assert!(ptr3.align_offset(8) == usize::MAX);\n+        assert!(ptr3.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr3.wrapping_byte_add(1).align_offset(2) == usize::MAX);\n+\n+        // `stride % align != 0` (edge case)\n+\n+        let ptr4: *const [u8; 3] = ptr.cast();\n+        assert!(ptr4.align_offset(1) == 0);\n+        assert!(ptr4.align_offset(2) == 0);\n+        assert!(ptr4.align_offset(4) == 0);\n+        assert!(ptr4.align_offset(8) == usize::MAX);\n+        assert!(ptr4.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr4.wrapping_byte_add(1).align_offset(2) == 1);\n+        assert!(ptr4.wrapping_byte_add(1).align_offset(4) == 1);\n+        assert!(ptr4.wrapping_byte_add(1).align_offset(8) == usize::MAX);\n+        assert!(ptr4.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr4.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr4.wrapping_byte_add(2).align_offset(4) == 2);\n+        assert!(ptr4.wrapping_byte_add(2).align_offset(8) == usize::MAX);\n+        assert!(ptr4.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr4.wrapping_byte_add(3).align_offset(2) == 1);\n+        assert!(ptr4.wrapping_byte_add(3).align_offset(4) == 3);\n+        assert!(ptr4.wrapping_byte_add(3).align_offset(8) == usize::MAX);\n+\n+        let ptr5: *const [u8; 5] = ptr.cast();\n+        assert!(ptr5.align_offset(1) == 0);\n+        assert!(ptr5.align_offset(2) == 0);\n+        assert!(ptr5.align_offset(4) == 0);\n+        assert!(ptr5.align_offset(8) == usize::MAX);\n+        assert!(ptr5.wrapping_byte_add(1).align_offset(1) == 0);\n+        assert!(ptr5.wrapping_byte_add(1).align_offset(2) == 1);\n+        assert!(ptr5.wrapping_byte_add(1).align_offset(4) == 3);\n+        assert!(ptr5.wrapping_byte_add(1).align_offset(8) == usize::MAX);\n+        assert!(ptr5.wrapping_byte_add(2).align_offset(1) == 0);\n+        assert!(ptr5.wrapping_byte_add(2).align_offset(2) == 0);\n+        assert!(ptr5.wrapping_byte_add(2).align_offset(4) == 2);\n+        assert!(ptr5.wrapping_byte_add(2).align_offset(8) == usize::MAX);\n+        assert!(ptr5.wrapping_byte_add(3).align_offset(1) == 0);\n+        assert!(ptr5.wrapping_byte_add(3).align_offset(2) == 1);\n+        assert!(ptr5.wrapping_byte_add(3).align_offset(4) == 1);\n+        assert!(ptr5.wrapping_byte_add(3).align_offset(8) == usize::MAX);\n+    }\n+}\n+\n #[test]\n fn align_offset_issue_103361() {\n     #[cfg(target_pointer_width = \"64\")]\n@@ -467,6 +680,72 @@ fn align_offset_issue_103361() {\n     let _ = (SIZE as *const HugeSize).align_offset(SIZE);\n }\n \n+#[test]\n+#[cfg(not(bootstrap))]\n+fn align_offset_issue_103361_const() {\n+    #[cfg(target_pointer_width = \"64\")]\n+    const SIZE: usize = 1 << 47;\n+    #[cfg(target_pointer_width = \"32\")]\n+    const SIZE: usize = 1 << 30;\n+    #[cfg(target_pointer_width = \"16\")]\n+    const SIZE: usize = 1 << 13;\n+    struct HugeSize([u8; SIZE - 1]);\n+\n+    const {\n+        assert!(ptr::invalid::<HugeSize>(SIZE - 1).align_offset(SIZE) == SIZE - 1);\n+        assert!(ptr::invalid::<HugeSize>(SIZE).align_offset(SIZE) == 0);\n+        assert!(ptr::invalid::<HugeSize>(SIZE + 1).align_offset(SIZE) == 1);\n+    }\n+}\n+\n+#[test]\n+fn is_aligned() {\n+    let data = 42;\n+    let ptr: *const i32 = &data;\n+    assert!(ptr.is_aligned());\n+    assert!(ptr.is_aligned_to(1));\n+    assert!(ptr.is_aligned_to(2));\n+    assert!(ptr.is_aligned_to(4));\n+    assert!(ptr.wrapping_byte_add(2).is_aligned_to(1));\n+    assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));\n+    assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));\n+\n+    // At runtime either `ptr` or `ptr+1` is aligned to 8.\n+    assert_ne!(ptr.is_aligned_to(8), ptr.wrapping_add(1).is_aligned_to(8));\n+}\n+\n+#[test]\n+#[cfg(not(bootstrap))]\n+fn is_aligned_const() {\n+    const {\n+        let data = 42;\n+        let ptr: *const i32 = &data;\n+        assert!(ptr.is_aligned());\n+        assert!(ptr.is_aligned_to(1));\n+        assert!(ptr.is_aligned_to(2));\n+        assert!(ptr.is_aligned_to(4));\n+        assert!(ptr.wrapping_byte_add(2).is_aligned_to(1));\n+        assert!(ptr.wrapping_byte_add(2).is_aligned_to(2));\n+        assert!(!ptr.wrapping_byte_add(2).is_aligned_to(4));\n+\n+        // At comptime neither `ptr` nor `ptr+1` is aligned to 8.\n+        assert!(!ptr.is_aligned_to(8));\n+        assert!(!ptr.wrapping_add(1).is_aligned_to(8));\n+    }\n+}\n+\n+#[test]\n+#[cfg(bootstrap)]\n+fn is_aligned_const() {\n+    const {\n+        let data = 42;\n+        let ptr: *const i32 = &data;\n+        // The bootstrap compiler always returns false for is_aligned.\n+        assert!(!ptr.is_aligned());\n+        assert!(!ptr.is_aligned_to(1));\n+    }\n+}\n+\n #[test]\n fn offset_from() {\n     let mut a = [0; 5];"}, {"sha": "04b5de83423709c09a5980b1ec645712715956bb", "filename": "src/test/assembly/is_aligned.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/src%2Ftest%2Fassembly%2Fis_aligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/src%2Ftest%2Fassembly%2Fis_aligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fis_aligned.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -0,0 +1,58 @@\n+// assembly-output: emit-asm\n+// min-llvm-version: 14.0\n+// only-x86_64\n+// revisions: opt-speed opt-size\n+// [opt-speed] compile-flags: -Copt-level=1\n+// [opt-size] compile-flags: -Copt-level=s\n+#![crate_type=\"rlib\"]\n+\n+#![feature(core_intrinsics)]\n+#![feature(pointer_is_aligned)]\n+\n+// CHECK-LABEL: is_aligned_to_unchecked\n+// CHECK: decq\n+// CHECK-NEXT: testq\n+// CHECK-NEXT: sete\n+// CHECK: retq\n+#[no_mangle]\n+pub unsafe fn is_aligned_to_unchecked(ptr: *const u8, align: usize) -> bool {\n+    unsafe {\n+        std::intrinsics::assume(align.is_power_of_two())\n+    }\n+    ptr.is_aligned_to(align)\n+}\n+\n+// CHECK-LABEL: is_aligned_1\n+// CHECK: movb $1\n+// CHECK: retq\n+#[no_mangle]\n+pub fn is_aligned_1(ptr: *const u8) -> bool {\n+    ptr.is_aligned()\n+}\n+\n+// CHECK-LABEL: is_aligned_2\n+// CHECK: testb $1\n+// CHECK-NEXT: sete\n+// CHECK: retq\n+#[no_mangle]\n+pub fn is_aligned_2(ptr: *const u16) -> bool {\n+    ptr.is_aligned()\n+}\n+\n+// CHECK-LABEL: is_aligned_4\n+// CHECK: testb $3\n+// CHECK-NEXT: sete\n+// CHECK: retq\n+#[no_mangle]\n+pub fn is_aligned_4(ptr: *const u32) -> bool {\n+    ptr.is_aligned()\n+}\n+\n+// CHECK-LABEL: is_aligned_8\n+// CHECK: testb $7\n+// CHECK-NEXT: sete\n+// CHECK: retq\n+#[no_mangle]\n+pub fn is_aligned_8(ptr: *const u64) -> bool {\n+    ptr.is_aligned()\n+}"}, {"sha": "5ea82adb9c69c762d48e492010958647c85dae10", "filename": "src/tools/miri/src/shims/intrinsics/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fmod.rs?ref=c5d82ed7a4ad94a538bb87e5016e7d5ce0bd434b", "patch": "@@ -368,11 +368,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             }\n \n             // Other\n-            \"exact_div\" => {\n-                let [num, denom] = check_arg_count(args)?;\n-                this.exact_div(&this.read_immediate(num)?, &this.read_immediate(denom)?, dest)?;\n-            }\n-\n             \"breakpoint\" => {\n                 let [] = check_arg_count(args)?;\n                 // normally this would raise a SIGTRAP, which aborts if no debugger is connected"}]}