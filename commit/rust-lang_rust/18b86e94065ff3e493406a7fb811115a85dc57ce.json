{"sha": "18b86e94065ff3e493406a7fb811115a85dc57ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Yjg2ZTk0MDY1ZmYzZTQ5MzQwNmE3ZmI4MTExMTVhODVkYzU3Y2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-19T16:52:17Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-26T13:38:26Z"}, "message": "introduce `VerifyBound::IfEq` (presently unused)", "tree": {"sha": "b914d011eb3efd992f320645c45223060c91f488", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b914d011eb3efd992f320645c45223060c91f488"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18b86e94065ff3e493406a7fb811115a85dc57ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18b86e94065ff3e493406a7fb811115a85dc57ce", "html_url": "https://github.com/rust-lang/rust/commit/18b86e94065ff3e493406a7fb811115a85dc57ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18b86e94065ff3e493406a7fb811115a85dc57ce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58fd6fad24334ca5061dd864cb063bcf7030ecef", "url": "https://api.github.com/repos/rust-lang/rust/commits/58fd6fad24334ca5061dd864cb063bcf7030ecef", "html_url": "https://github.com/rust-lang/rust/commit/58fd6fad24334ca5061dd864cb063bcf7030ecef"}], "stats": {"total": 137, "additions": 111, "deletions": 26}, "files": [{"sha": "727b257f6f278ee47b53e33ed8da36d36adc6956", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/18b86e94065ff3e493406a7fb811115a85dc57ce/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b86e94065ff3e493406a7fb811115a85dc57ce/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=18b86e94065ff3e493406a7fb811115a85dc57ce", "patch": "@@ -25,11 +25,11 @@ use rustc_data_structures::graph::implementation::{\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::u32;\n-use ty::{self, TyCtxt};\n+use ty::fold::TypeFoldable;\n+use ty::{self, Ty, TyCtxt};\n use ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n use ty::{ReLateBound, ReScope, ReSkolemized, ReVar};\n use ty::{Region, RegionVid};\n-use ty::fold::TypeFoldable;\n \n mod graphviz;\n \n@@ -421,7 +421,8 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 continue;\n             }\n \n-            if self.bound_is_met(&verify.bound, var_data, sub) {\n+            let verify_kind_ty = verify.kind.to_ty(self.tcx());\n+            if self.bound_is_met(&verify.bound, var_data, verify_kind_ty, sub) {\n                 continue;\n             }\n \n@@ -713,9 +714,15 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n         &self,\n         bound: &VerifyBound<'tcx>,\n         var_values: &LexicalRegionResolutions<'tcx>,\n+        generic_ty: Ty<'tcx>,\n         min: ty::Region<'tcx>,\n     ) -> bool {\n         match bound {\n+            VerifyBound::IfEq(k, b) => {\n+                (var_values.normalize(self.region_rels.tcx, *k) == generic_ty)\n+                    && self.bound_is_met(b, var_values, generic_ty, min)\n+            }\n+\n             VerifyBound::AnyRegion(rs) => rs.iter()\n                 .map(|&r| var_values.normalize(self.tcx(), r))\n                 .any(|r| self.region_rels.is_subregion_of(min, r)),\n@@ -724,9 +731,11 @@ impl<'cx, 'gcx, 'tcx> LexicalResolver<'cx, 'gcx, 'tcx> {\n                 .map(|&r| var_values.normalize(self.tcx(), r))\n                 .all(|r| self.region_rels.is_subregion_of(min, r)),\n \n-            VerifyBound::AnyBound(bs) => bs.iter().any(|b| self.bound_is_met(b, var_values, min)),\n+            VerifyBound::AnyBound(bs) => bs.iter()\n+                .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n \n-            VerifyBound::AllBounds(bs) => bs.iter().all(|b| self.bound_is_met(b, var_values, min)),\n+            VerifyBound::AllBounds(bs) => bs.iter()\n+                .all(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n         }\n     }\n }"}, {"sha": "9e12ed0b52f7a24a616dddecfae7d2579a237534", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 92, "deletions": 21, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/18b86e94065ff3e493406a7fb811115a85dc57ce/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b86e94065ff3e493406a7fb811115a85dc57ce/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=18b86e94065ff3e493406a7fb811115a85dc57ce", "patch": "@@ -155,29 +155,98 @@ pub enum GenericKind<'tcx> {\n     Projection(ty::ProjectionTy<'tcx>),\n }\n \n-/// When we introduce a verification step, we wish to test that a\n-/// particular region (let's call it `'min`) meets some bound.\n-/// The bound is described the by the following grammar:\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for GenericKind<'tcx> {\n+        (GenericKind::Param)(a),\n+        (GenericKind::Projection)(a),\n+    }\n+}\n+\n+/// Describes the things that some `GenericKind` value G is known to\n+/// outlive. Each variant of `VerifyBound` can be thought of as a\n+/// function:\n+///\n+///     fn(min: Region) -> bool { .. }\n+///\n+/// where `true` means that the region `min` meets that `G: min`.\n+/// (False means nothing.)\n+///\n+/// So, for example, if we have the type `T` and we have in scope that\n+/// `T: 'a` and `T: 'b`, then the verify bound might be:\n+///\n+///     fn(min: Region) -> bool {\n+///        ('a: min) || ('b: min)\n+///     }\n+///\n+/// This is described with a `AnyRegion('a, 'b)` node.\n #[derive(Debug, Clone)]\n pub enum VerifyBound<'tcx> {\n-    /// B = exists {R} --> some 'r in {R} must outlive 'min\n+    /// Given a kind K and a bound B, expands to a function like the\n+    /// following, where `G` is the generic for which this verify\n+    /// bound was created:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       if G == K {\n+    ///         B(min)\n+    ///       } else {\n+    ///         false\n+    ///       }\n+    ///     }\n+    ///\n+    /// In other words, if the generic `G` that we are checking is\n+    /// equal to `K`, then check the associated verify bound\n+    /// (otherwise, false).\n+    ///\n+    /// This is used when we have something in the environment that\n+    /// may or may not be relevant, depending on the region inference\n+    /// results. For example, we may have `where <T as\n+    /// Trait<'a>>::Item: 'b` in our where clauses. If we are\n+    /// generating the verify-bound for `<T as Trait<'0>>::Item`, then\n+    /// this where-clause is only relevant if `'0` winds up inferred\n+    /// to `'a`.\n+    ///\n+    /// So we would compile to a verify-bound like\n     ///\n-    /// Put another way, the subject value is known to outlive all\n-    /// regions in {R}, so if any of those outlives 'min, then the\n-    /// bound is met.\n+    ///     IfEq(<T as Trait<'a>>::Item, AnyRegion('a))\n+    ///\n+    /// meaning, if the subject G is equal to `<T as Trait<'a>>::Item`\n+    /// (after inference), and `'a: min`, then `G: min`.\n+    IfEq(Ty<'tcx>, Box<VerifyBound<'tcx>>),\n+\n+    /// Given a set of regions `R`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       exists (r in R) { r: min }\n+    ///     }\n+    ///\n+    /// In other words, if some r in R outlives min, then G outlives\n+    /// min.  This is used when G is known to outlive all the regions\n+    /// in R.\n     AnyRegion(Vec<Region<'tcx>>),\n \n-    /// B = forall {R} --> all 'r in {R} must outlive 'min\n+    /// Given a set of regions `R`, expands to the function:\n     ///\n-    /// Put another way, the subject value is known to outlive some\n-    /// region in {R}, so if all of those outlives 'min, then the bound\n-    /// is met.\n+    ///     fn(min) -> bool {\n+    ///       forall (r in R) { r: min }\n+    ///     }\n+    ///\n+    /// In other words, if all r in R outlives min, then G outlives\n+    /// min. This is used when G is known to outlive some region in\n+    /// R, but we don't know which.\n     AllRegions(Vec<Region<'tcx>>),\n \n-    /// B = exists {B} --> 'min must meet some bound b in {B}\n+    /// Given a set of bounds `B`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       exists (b in B) { b(min) }\n+    ///     }\n     AnyBound(Vec<VerifyBound<'tcx>>),\n \n-    /// B = forall {B} --> 'min must meet all bounds b in {B}\n+    /// Given a set of bounds `B`, expands to the function:\n+    ///\n+    ///     fn(min) -> bool {\n+    ///       forall (b in B) { b(min) }\n+    ///     }\n     AllBounds(Vec<VerifyBound<'tcx>>),\n }\n \n@@ -884,19 +953,21 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n     pub fn must_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.contains(&&ty::ReStatic),\n-            &VerifyBound::AllRegions(ref bs) => bs.is_empty(),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().any(|b| b.must_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().all(|b| b.must_hold()),\n+            VerifyBound::IfEq(..) => false,\n+            VerifyBound::AnyRegion(bs) => bs.contains(&&ty::ReStatic),\n+            VerifyBound::AllRegions(bs) => bs.is_empty(),\n+            VerifyBound::AnyBound(bs) => bs.iter().any(|b| b.must_hold()),\n+            VerifyBound::AllBounds(bs) => bs.iter().all(|b| b.must_hold()),\n         }\n     }\n \n     pub fn cannot_hold(&self) -> bool {\n         match self {\n-            &VerifyBound::AnyRegion(ref bs) => bs.is_empty(),\n-            &VerifyBound::AllRegions(ref bs) => bs.contains(&&ty::ReEmpty),\n-            &VerifyBound::AnyBound(ref bs) => bs.iter().all(|b| b.cannot_hold()),\n-            &VerifyBound::AllBounds(ref bs) => bs.iter().any(|b| b.cannot_hold()),\n+            VerifyBound::IfEq(_, b) => b.cannot_hold(),\n+            VerifyBound::AnyRegion(bs) => bs.is_empty(),\n+            VerifyBound::AllRegions(bs) => bs.contains(&&ty::ReEmpty),\n+            VerifyBound::AnyBound(bs) => bs.iter().all(|b| b.cannot_hold()),\n+            VerifyBound::AllBounds(bs) => bs.iter().any(|b| b.cannot_hold()),\n         }\n     }\n "}, {"sha": "37a6022469ec7fbf915d705d3d759111e038d663", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18b86e94065ff3e493406a7fb811115a85dc57ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18b86e94065ff3e493406a7fb811115a85dc57ce/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=18b86e94065ff3e493406a7fb811115a85dc57ce", "patch": "@@ -156,6 +156,11 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n \n     fn verify_bound_to_region_test(&self, verify_bound: &VerifyBound<'tcx>) -> RegionTest {\n         match verify_bound {\n+            VerifyBound::IfEq(..) => {\n+                // FIXME: always false right now\n+                RegionTest::IsOutlivedByAnyRegionIn(vec![])\n+            }\n+\n             VerifyBound::AnyRegion(regions) => RegionTest::IsOutlivedByAnyRegionIn(\n                 regions.iter().map(|r| self.to_region_vid(r)).collect(),\n             ),"}]}