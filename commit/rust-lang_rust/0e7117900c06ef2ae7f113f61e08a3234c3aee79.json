{"sha": "0e7117900c06ef2ae7f113f61e08a3234c3aee79", "node_id": "C_kwDOAAsO6NoAKDBlNzExNzkwMGMwNmVmMmFlN2YxMTNmNjFlMDhhMzIzNGMzYWVlNzk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-06T10:50:16Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-06T12:21:20Z"}, "message": "internal: Resolve labels in body lowering", "tree": {"sha": "5e0d59a8c488987770a3da33161945b82ebf2921", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0d59a8c488987770a3da33161945b82ebf2921"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e7117900c06ef2ae7f113f61e08a3234c3aee79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e7117900c06ef2ae7f113f61e08a3234c3aee79", "html_url": "https://github.com/rust-lang/rust/commit/0e7117900c06ef2ae7f113f61e08a3234c3aee79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e7117900c06ef2ae7f113f61e08a3234c3aee79/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9e57725aa9ff093af5825503bcd0f28aca341a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e57725aa9ff093af5825503bcd0f28aca341a1", "html_url": "https://github.com/rust-lang/rust/commit/e9e57725aa9ff093af5825503bcd0f28aca341a1"}], "stats": {"total": 602, "additions": 420, "deletions": 182}, "files": [{"sha": "0bea905e115f772dd80de73e3e4bf1a050fe5871", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -13,7 +13,8 @@ use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n-    attrs::RawAttrs, hygiene::Hygiene, ExpandError, ExpandResult, HirFileId, InFile, MacroCallId,\n+    attrs::RawAttrs, hygiene::Hygiene, name::Name, ExpandError, ExpandResult, HirFileId, InFile,\n+    MacroCallId,\n };\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n@@ -343,6 +344,8 @@ pub enum BodyDiagnostic {\n     MacroError { node: InFile<AstPtr<ast::MacroCall>>, message: String },\n     UnresolvedProcMacro { node: InFile<AstPtr<ast::MacroCall>>, krate: CrateId },\n     UnresolvedMacroCall { node: InFile<AstPtr<ast::MacroCall>>, path: ModPath },\n+    UnreachableLabel { node: InFile<AstPtr<ast::Lifetime>>, name: Name },\n+    UndeclaredLabel { node: InFile<AstPtr<ast::Lifetime>>, name: Name },\n }\n \n impl Body {"}, {"sha": "91eeff5b0eb0c4d77bd9300796c798e745d3374d", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 199, "deletions": 76, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -102,9 +102,10 @@ pub(super) fn lower(\n             _c: Count::new(),\n         },\n         expander,\n-        current_try_block: None,\n+        current_try_block_label: None,\n         is_lowering_assignee_expr: false,\n         is_lowering_generator: false,\n+        label_ribs: Vec::new(),\n     }\n     .collect(params, body, is_async_fn)\n }\n@@ -116,9 +117,43 @@ struct ExprCollector<'a> {\n     body: Body,\n     krate: CrateId,\n     source_map: BodySourceMap,\n-    current_try_block: Option<LabelId>,\n+    current_try_block_label: Option<LabelId>,\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n+    label_ribs: Vec<LabelRib>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct LabelRib {\n+    kind: RibKind,\n+    // Once we handle macro hygiene this will need to be a map\n+    label: Option<(Name, LabelId)>,\n+}\n+\n+impl LabelRib {\n+    fn new(kind: RibKind) -> Self {\n+        LabelRib { kind, label: None }\n+    }\n+    fn new_normal(label: (Name, LabelId)) -> Self {\n+        LabelRib { kind: RibKind::Normal, label: Some(label) }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum RibKind {\n+    Normal,\n+    Closure,\n+    Constant,\n+}\n+\n+impl RibKind {\n+    /// This rib forbids referring to labels defined in upwards ribs.\n+    fn is_label_barrier(self) -> bool {\n+        match self {\n+            RibKind::Normal => false,\n+            RibKind::Closure | RibKind::Constant => true,\n+        }\n+    }\n }\n \n #[derive(Debug, Default)]\n@@ -171,26 +206,24 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n         };\n+        self.body.body_expr = self.with_label_rib(RibKind::Closure, |this| {\n+            if is_async_fn {\n+                match body {\n+                    Some(e) => {\n+                        let expr = this.collect_expr(e);\n+                        this.alloc_expr_desugared(Expr::Async {\n+                            id: None,\n+                            statements: Box::new([]),\n+                            tail: Some(expr),\n+                        })\n+                    }\n+                    None => this.missing_expr(),\n+                }\n+            } else {\n+                this.collect_expr_opt(body)\n+            }\n+        });\n \n-        self.body.body_expr = if is_async_fn {\n-            self.current_try_block =\n-                Some(self.alloc_label_desugared(Label { name: Name::generate_new_name() }));\n-            let expr = self.collect_expr_opt(body);\n-            let expr = self.alloc_expr_desugared(Expr::Block {\n-                id: None,\n-                statements: Box::new([]),\n-                tail: Some(expr),\n-                label: self.current_try_block,\n-            });\n-            let expr = self.alloc_expr_desugared(Expr::Async {\n-                id: None,\n-                statements: Box::new([]),\n-                tail: Some(expr),\n-            });\n-            expr\n-        } else {\n-            self.collect_expr_opt(body)\n-        };\n         (self.body, self.source_map)\n     }\n \n@@ -264,6 +297,7 @@ impl ExprCollector<'_> {\n         let syntax_ptr = AstPtr::new(&expr);\n         self.check_cfg(&expr)?;\n \n+        // FIXME: Move some of these arms out into separate methods for clarity\n         Some(match expr {\n             ast::Expr::IfExpr(e) => {\n                 let then_branch = self.collect_block_opt(e.then_branch());\n@@ -286,7 +320,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n             }\n             ast::Expr::BlockExpr(e) => match e.modifier() {\n-                Some(ast::BlockModifier::Try(_)) => self.collect_try_block(e),\n+                Some(ast::BlockModifier::Try(_)) => self.desugar_try_block(e),\n                 Some(ast::BlockModifier::Unsafe(_)) => {\n                     self.collect_block_(e, |id, statements, tail| Expr::Unsafe {\n                         id,\n@@ -296,28 +330,43 @@ impl ExprCollector<'_> {\n                 }\n                 Some(ast::BlockModifier::Label(label)) => {\n                     let label = self.collect_label(label);\n-                    self.collect_block_(e, |id, statements, tail| Expr::Block {\n-                        id,\n-                        statements,\n-                        tail,\n-                        label: Some(label),\n+                    self.with_labeled_rib(label, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Block {\n+                            id,\n+                            statements,\n+                            tail,\n+                            label: Some(label),\n+                        })\n+                    })\n+                }\n+                Some(ast::BlockModifier::Async(_)) => {\n+                    self.with_label_rib(RibKind::Closure, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Async {\n+                            id,\n+                            statements,\n+                            tail,\n+                        })\n+                    })\n+                }\n+                Some(ast::BlockModifier::Const(_)) => {\n+                    self.with_label_rib(RibKind::Constant, |this| {\n+                        this.collect_block_(e, |id, statements, tail| Expr::Const {\n+                            id,\n+                            statements,\n+                            tail,\n+                        })\n                     })\n                 }\n-                Some(ast::BlockModifier::Async(_)) => self\n-                    .collect_block_(e, |id, statements, tail| Expr::Async { id, statements, tail }),\n-                Some(ast::BlockModifier::Const(_)) => self\n-                    .collect_block_(e, |id, statements, tail| Expr::Const { id, statements, tail }),\n                 None => self.collect_block(e),\n             },\n             ast::Expr::LoopExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 self.alloc_expr(Expr::Loop { body, label }, syntax_ptr)\n             }\n             ast::Expr::WhileExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n-                let body = self.collect_block_opt(e.loop_body());\n-\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 let condition = self.collect_expr_opt(e.condition());\n \n                 self.alloc_expr(Expr::While { condition, body, label }, syntax_ptr)\n@@ -326,7 +375,7 @@ impl ExprCollector<'_> {\n                 let label = e.label().map(|label| self.collect_label(label));\n                 let iterable = self.collect_expr_opt(e.iterable());\n                 let pat = self.collect_pat_opt(e.pat());\n-                let body = self.collect_block_opt(e.loop_body());\n+                let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n             }\n             ast::Expr::CallExpr(e) => {\n@@ -386,16 +435,20 @@ impl ExprCollector<'_> {\n                     .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n-            ast::Expr::ContinueExpr(e) => self.alloc_expr(\n-                Expr::Continue { label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n-                syntax_ptr,\n-            ),\n+            ast::Expr::ContinueExpr(e) => {\n+                let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {\n+                    self.source_map.diagnostics.push(e);\n+                    None\n+                });\n+                self.alloc_expr(Expr::Continue { label }, syntax_ptr)\n+            }\n             ast::Expr::BreakExpr(e) => {\n+                let label = self.resolve_label(e.lifetime()).unwrap_or_else(|e| {\n+                    self.source_map.diagnostics.push(e);\n+                    None\n+                });\n                 let expr = e.expr().map(|e| self.collect_expr(e));\n-                self.alloc_expr(\n-                    Expr::Break { expr, label: e.lifetime().map(|l| Name::new_lifetime(&l)) },\n-                    syntax_ptr,\n-                )\n+                self.alloc_expr(Expr::Break { expr, label }, syntax_ptr)\n             }\n             ast::Expr::ParenExpr(e) => {\n                 let inner = self.collect_expr_opt(e.expr());\n@@ -496,29 +549,29 @@ impl ExprCollector<'_> {\n                     None => self.alloc_expr(Expr::Missing, syntax_ptr),\n                 }\n             }\n-            ast::Expr::ClosureExpr(e) => {\n+            ast::Expr::ClosureExpr(e) => self.with_label_rib(RibKind::Closure, |this| {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n-                        let pat = self.collect_pat_opt(param.pat());\n+                        let pat = this.collect_pat_opt(param.pat());\n                         let type_ref =\n-                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                            param.ty().map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n                         args.push(pat);\n                         arg_types.push(type_ref);\n                     }\n                 }\n                 let ret_type = e\n                     .ret_type()\n                     .and_then(|r| r.ty())\n-                    .map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n+                    .map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n \n-                let prev_is_lowering_generator = self.is_lowering_generator;\n-                self.is_lowering_generator = false;\n+                let prev_is_lowering_generator = this.is_lowering_generator;\n+                this.is_lowering_generator = false;\n \n-                let body = self.collect_expr_opt(e.body());\n+                let body = this.collect_expr_opt(e.body());\n \n-                let closure_kind = if self.is_lowering_generator {\n+                let closure_kind = if this.is_lowering_generator {\n                     let movability = if e.static_token().is_some() {\n                         Movability::Static\n                     } else {\n@@ -530,9 +583,9 @@ impl ExprCollector<'_> {\n                 } else {\n                     ClosureKind::Closure\n                 };\n-                self.is_lowering_generator = prev_is_lowering_generator;\n+                this.is_lowering_generator = prev_is_lowering_generator;\n \n-                self.alloc_expr(\n+                this.alloc_expr(\n                     Expr::Closure {\n                         args: args.into(),\n                         arg_types: arg_types.into(),\n@@ -542,7 +595,7 @@ impl ExprCollector<'_> {\n                     },\n                     syntax_ptr,\n                 )\n-            }\n+            }),\n             ast::Expr::BinExpr(e) => {\n                 let op = e.op_kind();\n                 if let Some(ast::BinaryOp::Assignment { op: None }) = op {\n@@ -581,7 +634,9 @@ impl ExprCollector<'_> {\n                     }\n                     ArrayExprKind::Repeat { initializer, repeat } => {\n                         let initializer = self.collect_expr_opt(initializer);\n-                        let repeat = self.collect_expr_opt(repeat);\n+                        let repeat = self.with_label_rib(RibKind::Constant, |this| {\n+                            this.collect_expr_opt(repeat)\n+                        });\n                         self.alloc_expr(\n                             Expr::Array(Array::Repeat { initializer, repeat }),\n                             syntax_ptr,\n@@ -630,20 +685,24 @@ impl ExprCollector<'_> {\n     /// Desugar `try { <stmts>; <expr> }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(<expr>) }`,\n     /// `try { <stmts>; }` into `'<new_label>: { <stmts>; ::std::ops::Try::from_output(()) }`\n     /// and save the `<new_label>` to use it as a break target for desugaring of the `?` operator.\n-    fn collect_try_block(&mut self, e: BlockExpr) -> ExprId {\n+    fn desugar_try_block(&mut self, e: BlockExpr) -> ExprId {\n         let Some(try_from_output) = LangItem::TryTraitFromOutput.path(self.db, self.krate) else {\n-            return self.alloc_expr_desugared(Expr::Missing);\n+            return self.collect_block(e);\n         };\n-        let prev_try_block = self.current_try_block.take();\n-        self.current_try_block =\n-            Some(self.alloc_label_desugared(Label { name: Name::generate_new_name() }));\n-        let expr_id = self.collect_block(e);\n+        let label = self.alloc_label_desugared(Label { name: Name::generate_new_name() });\n+        let old_label = self.current_try_block_label.replace(label);\n+\n+        let (btail, expr_id) = self.with_labeled_rib(label, |this| {\n+            let mut btail = None;\n+            let block = this.collect_block_(e, |id, statements, tail| {\n+                btail = tail;\n+                Expr::Block { id, statements, tail, label: Some(label) }\n+            });\n+            (btail, block)\n+        });\n+\n         let callee = self.alloc_expr_desugared(Expr::Path(try_from_output));\n-        let Expr::Block { label, tail, .. } = &mut self.body.exprs[expr_id] else {\n-            unreachable!(\"It is the output of collect block\");\n-        };\n-        *label = self.current_try_block;\n-        let next_tail = match *tail {\n+        let next_tail = match btail {\n             Some(tail) => self.alloc_expr_desugared(Expr::Call {\n                 callee,\n                 args: Box::new([tail]),\n@@ -662,10 +721,10 @@ impl ExprCollector<'_> {\n             }\n         };\n         let Expr::Block { tail, .. } = &mut self.body.exprs[expr_id] else {\n-            unreachable!(\"It is the output of collect block\");\n+            unreachable!(\"block was lowered to non-block\");\n         };\n         *tail = Some(next_tail);\n-        self.current_try_block = prev_try_block;\n+        self.current_try_block_label = old_label;\n         expr_id\n     }\n \n@@ -735,12 +794,13 @@ impl ExprCollector<'_> {\n                     Expr::Call { callee, args: Box::new([x]), is_assignee_expr: false },\n                     syntax_ptr.clone(),\n                 );\n-                if let Some(label) = self.current_try_block {\n-                    let label = Some(self.body.labels[label].name.clone());\n-                    self.alloc_expr(Expr::Break { expr: Some(result), label }, syntax_ptr.clone())\n-                } else {\n-                    self.alloc_expr(Expr::Return { expr: Some(result) }, syntax_ptr.clone())\n-                }\n+                self.alloc_expr(\n+                    match self.current_try_block_label {\n+                        Some(label) => Expr::Break { expr: Some(result), label: Some(label) },\n+                        None => Expr::Return { expr: Some(result) },\n+                    },\n+                    syntax_ptr.clone(),\n+                )\n             },\n         };\n         let arms = Box::new([continue_arm, break_arm]);\n@@ -966,6 +1026,17 @@ impl ExprCollector<'_> {\n         }\n     }\n \n+    fn collect_labelled_block_opt(\n+        &mut self,\n+        label: Option<LabelId>,\n+        expr: Option<ast::BlockExpr>,\n+    ) -> ExprId {\n+        match label {\n+            Some(label) => self.with_labeled_rib(label, |this| this.collect_block_opt(expr)),\n+            None => self.collect_block_opt(expr),\n+        }\n+    }\n+\n     fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n         let label = Label {\n             name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n@@ -1135,8 +1206,9 @@ impl ExprCollector<'_> {\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n-                if let Some(expr) = const_block_pat.block_expr() {\n-                    let expr_id = self.collect_block(expr);\n+                if let Some(block) = const_block_pat.block_expr() {\n+                    let expr_id =\n+                        self.with_label_rib(RibKind::Constant, |this| this.collect_block(block));\n                     Pat::ConstBlock(expr_id)\n                 } else {\n                     Pat::Missing\n@@ -1213,6 +1285,57 @@ impl ExprCollector<'_> {\n     fn add_definition_to_binding(&mut self, binding_id: BindingId, pat_id: PatId) {\n         self.body.bindings[binding_id].definitions.push(pat_id);\n     }\n+\n+    fn resolve_label(\n+        &self,\n+        lifetime: Option<ast::Lifetime>,\n+    ) -> Result<Option<LabelId>, BodyDiagnostic> {\n+        let Some(lifetime) = lifetime else {\n+            return Ok(None)\n+        };\n+        let name = Name::new_lifetime(&lifetime);\n+\n+        for (rib_idx, rib) in self.label_ribs.iter().enumerate().rev() {\n+            if let Some((label_name, id)) = &rib.label {\n+                if *label_name == name {\n+                    return if self.is_label_valid_from_rib(rib_idx) {\n+                        Ok(Some(*id))\n+                    } else {\n+                        Err(BodyDiagnostic::UnreachableLabel {\n+                            name,\n+                            node: InFile::new(\n+                                self.expander.current_file_id,\n+                                AstPtr::new(&lifetime),\n+                            ),\n+                        })\n+                    };\n+                }\n+            }\n+        }\n+\n+        Err(BodyDiagnostic::UndeclaredLabel {\n+            name,\n+            node: InFile::new(self.expander.current_file_id, AstPtr::new(&lifetime)),\n+        })\n+    }\n+\n+    fn is_label_valid_from_rib(&self, rib_index: usize) -> bool {\n+        !self.label_ribs[rib_index + 1..].iter().any(|rib| rib.kind.is_label_barrier())\n+    }\n+\n+    fn with_label_rib<T>(&mut self, kind: RibKind, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.label_ribs.push(LabelRib::new(kind));\n+        let res = f(self);\n+        self.label_ribs.pop();\n+        res\n+    }\n+\n+    fn with_labeled_rib<T>(&mut self, label: LabelId, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.label_ribs.push(LabelRib::new_normal((self.body[label].name.clone(), label)));\n+        let res = f(self);\n+        self.label_ribs.pop();\n+        res\n+    }\n }\n \n impl From<ast::LiteralKind> for Literal {"}, {"sha": "9ac42c86214da76cdef88fa946074fdb51802bd4", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -219,14 +219,14 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Continue { label } => {\n                 w!(self, \"continue\");\n-                if let Some(label) = label {\n-                    w!(self, \" {}\", label);\n+                if let Some(lbl) = label {\n+                    w!(self, \" {}\", self.body[*lbl].name);\n                 }\n             }\n             Expr::Break { expr, label } => {\n                 w!(self, \"break\");\n-                if let Some(label) = label {\n-                    w!(self, \" {}\", label);\n+                if let Some(lbl) = label {\n+                    w!(self, \" {}\", self.body[*lbl].name);\n                 }\n                 if let Some(expr) = expr {\n                     self.whitespace();"}, {"sha": "9e83d8ab118d18389c321818f01587c9324c02f1", "filename": "crates/hir-def/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpr.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -168,11 +168,11 @@ pub enum Expr {\n         arms: Box<[MatchArm]>,\n     },\n     Continue {\n-        label: Option<Name>,\n+        label: Option<LabelId>,\n     },\n     Break {\n         expr: Option<ExprId>,\n-        label: Option<Name>,\n+        label: Option<LabelId>,\n     },\n     Return {\n         expr: Option<ExprId>,"}, {"sha": "4e688c431ae22b5c1b285284edd518344d7b9f0f", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -120,8 +120,7 @@ impl Name {\n         use std::sync::atomic::{AtomicUsize, Ordering};\n         static CNT: AtomicUsize = AtomicUsize::new(0);\n         let c = CNT.fetch_add(1, Ordering::Relaxed);\n-        // FIXME: Currently a `__RA_generated_name` in user code will break our analysis\n-        Name::new_text(format!(\"__RA_geneated_name_{c}\").into())\n+        Name::new_text(format!(\"<ra@gennew>{c}\").into())\n     }\n \n     /// Returns the tuple index this name represents if it is a tuple field."}, {"sha": "ed530408abf529e96867357de4a2557658b46207", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -18,6 +18,7 @@ use std::{convert::identity, ops::Index};\n \n use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar, TypeFlags};\n use either::Either;\n+use hir_def::expr::LabelId;\n use hir_def::{\n     body::Body,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n@@ -188,12 +189,6 @@ pub enum InferenceDiagnostic {\n         /// Contains the type the field resolves to\n         field_with_same_name: Option<Ty>,\n     },\n-    // FIXME: Make this proper\n-    BreakOutsideOfLoop {\n-        expr: ExprId,\n-        is_break: bool,\n-        bad_value_break: bool,\n-    },\n     MismatchedArgCount {\n         call_expr: ExprId,\n         expected: usize,\n@@ -468,7 +463,7 @@ struct BreakableContext {\n     /// The coercion target of the context.\n     coerce: Option<CoerceMany>,\n     /// The optional label of the context.\n-    label: Option<name::Name>,\n+    label: Option<LabelId>,\n     kind: BreakableKind,\n }\n \n@@ -483,28 +478,18 @@ enum BreakableKind {\n \n fn find_breakable<'c>(\n     ctxs: &'c mut [BreakableContext],\n-    label: Option<&name::Name>,\n+    label: Option<LabelId>,\n ) -> Option<&'c mut BreakableContext> {\n     let mut ctxs = ctxs\n         .iter_mut()\n         .rev()\n         .take_while(|it| matches!(it.kind, BreakableKind::Block | BreakableKind::Loop));\n     match label {\n-        Some(_) => ctxs.find(|ctx| ctx.label.as_ref() == label),\n+        Some(_) => ctxs.find(|ctx| ctx.label == label),\n         None => ctxs.find(|ctx| matches!(ctx.kind, BreakableKind::Loop)),\n     }\n }\n \n-fn find_continuable<'c>(\n-    ctxs: &'c mut [BreakableContext],\n-    label: Option<&name::Name>,\n-) -> Option<&'c mut BreakableContext> {\n-    match label {\n-        Some(_) => find_breakable(ctxs, label).filter(|it| matches!(it.kind, BreakableKind::Loop)),\n-        None => find_breakable(ctxs, label),\n-    }\n-}\n-\n impl<'a> InferenceContext<'a> {\n     fn new(\n         db: &'a dyn HirDatabase,"}, {"sha": "4e62e41b586b34613f505fbc85bcfaa718b850e8", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -25,9 +25,7 @@ use syntax::ast::RangeOp;\n use crate::{\n     autoderef::{builtin_deref, deref_by_trait, Autoderef},\n     consteval,\n-    infer::{\n-        coerce::CoerceMany, find_continuable, pat::contains_explicit_ref_binding, BreakableKind,\n-    },\n+    infer::{coerce::CoerceMany, pat::contains_explicit_ref_binding, BreakableKind},\n     lang_items::lang_items_for_bin_op,\n     lower::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n@@ -459,29 +457,13 @@ impl<'a> InferenceContext<'a> {\n                 self.resolver.reset_to_guard(g);\n                 ty\n             }\n-            Expr::Continue { label } => {\n-                if let None = find_continuable(&mut self.breakables, label.as_ref()) {\n-                    self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n-                        expr: tgt_expr,\n-                        is_break: false,\n-                        bad_value_break: false,\n-                    });\n-                };\n-                self.result.standard_types.never.clone()\n-            }\n-            Expr::Break { expr, label } => {\n-                let val_ty = if let Some(expr) = *expr {\n-                    let opt_coerce_to = match find_breakable(&mut self.breakables, label.as_ref()) {\n+            Expr::Continue { .. } => self.result.standard_types.never.clone(),\n+            &Expr::Break { expr, label } => {\n+                let val_ty = if let Some(expr) = expr {\n+                    let opt_coerce_to = match find_breakable(&mut self.breakables, label) {\n                         Some(ctxt) => match &ctxt.coerce {\n                             Some(coerce) => coerce.expected_ty(),\n-                            None => {\n-                                self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n-                                    expr: tgt_expr,\n-                                    is_break: true,\n-                                    bad_value_break: true,\n-                                });\n-                                self.err_ty()\n-                            }\n+                            None => self.err_ty(),\n                         },\n                         None => self.err_ty(),\n                     };\n@@ -490,26 +472,20 @@ impl<'a> InferenceContext<'a> {\n                     TyBuilder::unit()\n                 };\n \n-                match find_breakable(&mut self.breakables, label.as_ref()) {\n+                match find_breakable(&mut self.breakables, label) {\n                     Some(ctxt) => match ctxt.coerce.take() {\n                         Some(mut coerce) => {\n-                            coerce.coerce(self, *expr, &val_ty);\n+                            coerce.coerce(self, expr, &val_ty);\n \n                             // Avoiding borrowck\n-                            let ctxt = find_breakable(&mut self.breakables, label.as_ref())\n+                            let ctxt = find_breakable(&mut self.breakables, label)\n                                 .expect(\"breakable stack changed during coercion\");\n                             ctxt.may_break = true;\n                             ctxt.coerce = Some(coerce);\n                         }\n                         None => ctxt.may_break = true,\n                     },\n-                    None => {\n-                        self.push_diagnostic(InferenceDiagnostic::BreakOutsideOfLoop {\n-                            expr: tgt_expr,\n-                            is_break: true,\n-                            bad_value_break: false,\n-                        });\n-                    }\n+                    None => {}\n                 }\n                 self.result.standard_types.never.clone()\n             }\n@@ -1900,7 +1876,6 @@ impl<'a> InferenceContext<'a> {\n         cb: impl FnOnce(&mut Self) -> T,\n     ) -> (Option<Ty>, T) {\n         self.breakables.push({\n-            let label = label.map(|label| self.body[label].name.clone());\n             BreakableContext { kind, may_break: false, coerce: ty.map(CoerceMany::new), label }\n         });\n         let res = cb(self);"}, {"sha": "0aa5b4dc8d5cdc7a2932afb7a2eeabf5e5514155", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -47,7 +47,7 @@ struct MirLowerCtx<'a> {\n     current_loop_blocks: Option<LoopBlocks>,\n     // FIXME: we should resolve labels in HIR lowering and always work with label id here, not\n     // with raw names.\n-    labeled_loop_blocks: FxHashMap<Name, LoopBlocks>,\n+    labeled_loop_blocks: FxHashMap<LabelId, LoopBlocks>,\n     discr_temp: Option<Place>,\n     db: &'a dyn HirDatabase,\n     body: &'a Body,\n@@ -579,19 +579,19 @@ impl MirLowerCtx<'_> {\n                     Ok(None)\n                 }\n             },\n-            Expr::Break { expr, label } => {\n+            &Expr::Break { expr, label } => {\n                 if let Some(expr) = expr {\n                     let loop_data = match label {\n-                        Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?,\n+                        Some(l) => self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?,\n                         None => self.current_loop_blocks.as_ref().ok_or(MirLowerError::BreakWithoutLoop)?,\n                     };\n-                    let Some(c) = self.lower_expr_to_place(*expr, loop_data.place.clone(), current)? else {\n+                    let Some(c) = self.lower_expr_to_place(expr, loop_data.place.clone(), current)? else {\n                         return Ok(None);\n                     };\n                     current = c;\n                 }\n                 let end = match label {\n-                    Some(l) => self.labeled_loop_blocks.get(l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n+                    Some(l) => self.labeled_loop_blocks.get(&l).ok_or(MirLowerError::UnresolvedLabel)?.end.expect(\"We always generate end for labeled loops\"),\n                     None => self.current_loop_end()?,\n                 };\n                 self.set_goto(current, end);\n@@ -1119,10 +1119,8 @@ impl MirLowerCtx<'_> {\n             // bad as we may emit end (unneccessary unreachable block) for unterminating loop, but\n             // it should not affect correctness.\n             self.current_loop_end()?;\n-            self.labeled_loop_blocks.insert(\n-                self.body.labels[label].name.clone(),\n-                self.current_loop_blocks.as_ref().unwrap().clone(),\n-            )\n+            self.labeled_loop_blocks\n+                .insert(label, self.current_loop_blocks.as_ref().unwrap().clone())\n         } else {\n             None\n         };\n@@ -1131,7 +1129,7 @@ impl MirLowerCtx<'_> {\n         let my = mem::replace(&mut self.current_loop_blocks, prev)\n             .ok_or(MirLowerError::ImplementationError(\"current_loop_blocks is corrupt\"))?;\n         if let Some(prev) = prev_label {\n-            self.labeled_loop_blocks.insert(self.body.labels[label.unwrap()].name.clone(), prev);\n+            self.labeled_loop_blocks.insert(label.unwrap(), prev);\n         }\n         Ok(my.end)\n     }"}, {"sha": "605bac61571f007ac55bc9ab26a29bc91520fe30", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -32,7 +32,6 @@ macro_rules! diagnostics {\n }\n \n diagnostics![\n-    BreakOutsideOfLoop,\n     ExpectedFunction,\n     InactiveCode,\n     IncorrectCase,\n@@ -50,7 +49,9 @@ diagnostics![\n     PrivateField,\n     ReplaceFilterMapNextWithFindMap,\n     TypeMismatch,\n+    UndeclaredLabel,\n     UnimplementedBuiltinMacro,\n+    UnreachableLabel,\n     UnresolvedExternCrate,\n     UnresolvedField,\n     UnresolvedImport,\n@@ -84,6 +85,17 @@ pub struct UnresolvedMacroCall {\n     pub path: ModPath,\n     pub is_bang: bool,\n }\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UnreachableLabel {\n+    pub node: InFile<AstPtr<ast::Lifetime>>,\n+    pub name: Name,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct UndeclaredLabel {\n+    pub node: InFile<AstPtr<ast::Lifetime>>,\n+    pub name: Name,\n+}\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct InactiveCode {\n@@ -166,13 +178,6 @@ pub struct PrivateField {\n     pub field: Field,\n }\n \n-#[derive(Debug)]\n-pub struct BreakOutsideOfLoop {\n-    pub expr: InFile<AstPtr<ast::Expr>>,\n-    pub is_break: bool,\n-    pub bad_value_break: bool,\n-}\n-\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub expr: InFile<AstPtr<ast::Expr>>,"}, {"sha": "cd4d8e17d3bb5fb0717d0cc7f908bc00cef67386", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -85,12 +85,13 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n-        IncorrectCase, InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount,\n-        MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem,\n-        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n-        UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n-        UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n+        AnyDiagnostic, ExpectedFunction, InactiveCode, IncoherentImpl, IncorrectCase,\n+        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n+        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n+        ReplaceFilterMapNextWithFindMap, TypeMismatch, UndeclaredLabel, UnimplementedBuiltinMacro,\n+        UnreachableLabel, UnresolvedExternCrate, UnresolvedField, UnresolvedImport,\n+        UnresolvedMacroCall, UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro,\n+        UnusedMut,\n     },\n     has_source::HasSource,\n     semantics::{PathResolution, Semantics, SemanticsScope, TypeInfo, VisibleTraits},\n@@ -1393,6 +1394,12 @@ impl DefWithBody {\n                     }\n                     .into(),\n                 ),\n+                BodyDiagnostic::UnreachableLabel { node, name } => {\n+                    acc.push(UnreachableLabel { node: node.clone(), name: name.clone() }.into())\n+                }\n+                BodyDiagnostic::UndeclaredLabel { node, name } => {\n+                    acc.push(UndeclaredLabel { node: node.clone(), name: name.clone() }.into())\n+                }\n             }\n         }\n \n@@ -1405,14 +1412,6 @@ impl DefWithBody {\n                     let field = source_map.field_syntax(expr);\n                     acc.push(NoSuchField { field }.into())\n                 }\n-                &hir_ty::InferenceDiagnostic::BreakOutsideOfLoop {\n-                    expr,\n-                    is_break,\n-                    bad_value_break,\n-                } => {\n-                    let expr = expr_syntax(expr);\n-                    acc.push(BreakOutsideOfLoop { expr, is_break, bad_value_break }.into())\n-                }\n                 &hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n                     acc.push(\n                         MismatchedArgCount { call_expr: expr_syntax(call_expr), expected, found }"}, {"sha": "9d5cbb31bbfb1d837c63cc25cd25470155fda317", "filename": "crates/ide-diagnostics/src/handlers/undeclared_label.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -0,0 +1,61 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: undeclared-label\n+pub(crate) fn undeclared_label(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UndeclaredLabel,\n+) -> Diagnostic {\n+    let name = &d.name;\n+    Diagnostic::new(\n+        \"undeclared-label\",\n+        format!(\"use of undeclared label `{name}`\"),\n+        ctx.sema.diagnostics_display_range(d.node.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn smoke_test() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    break 'a;\n+        //^^ error: use of undeclared label `'a`\n+    continue 'a;\n+           //^^ error: use of undeclared label `'a`\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_operator_desugar_works() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try\n+fn foo() {\n+    None?;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try, future\n+async fn foo() {\n+    None?;\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- minicore: option, try, future, fn\n+async fn foo() {\n+    || None?;\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "f09659fa9e1f8a0b486b1ba5fba18511247b3f93", "filename": "crates/ide-diagnostics/src/handlers/unreachable_label.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -0,0 +1,87 @@\n+use crate::{Diagnostic, DiagnosticsContext};\n+\n+// Diagnostic: unreachable-label\n+pub(crate) fn unreachable_label(\n+    ctx: &DiagnosticsContext<'_>,\n+    d: &hir::UnreachableLabel,\n+) -> Diagnostic {\n+    let name = &d.name;\n+    Diagnostic::new(\n+        \"unreachable-label\",\n+        format!(\"use of unreachable label `{name}`\"),\n+        ctx.sema.diagnostics_display_range(d.node.clone().map(|it| it.into())).range,\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn async_blocks_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        async {\n+            break 'a;\n+               // ^^ error: use of unreachable label `'a`\n+            continue 'a;\n+                  // ^^ error: use of unreachable label `'a`\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn closures_are_borders() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        || {\n+            break 'a;\n+               // ^^ error: use of unreachable label `'a`\n+            continue 'a;\n+                  // ^^ error: use of unreachable label `'a`\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        {\n+          break 'a;\n+          continue 'a;\n+        }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn try_blocks_pass_through() {\n+        check_diagnostics(\n+            r#\"\n+fn foo() {\n+    'a: loop {\n+        try {\n+            break 'a;\n+            continue 'a;\n+        };\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "5cb1d4e1b828571763b98c03c7d80740e819add7", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e7117900c06ef2ae7f113f61e08a3234c3aee79/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=0e7117900c06ef2ae7f113f61e08a3234c3aee79", "patch": "@@ -26,7 +26,6 @@\n #![warn(rust_2018_idioms, unused_lifetimes, semicolon_in_expressions_from_macros)]\n \n mod handlers {\n-    pub(crate) mod break_outside_of_loop;\n     pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n     pub(crate) mod incoherent_impl;\n@@ -52,6 +51,8 @@ mod handlers {\n     pub(crate) mod unresolved_macro_call;\n     pub(crate) mod unresolved_module;\n     pub(crate) mod unresolved_proc_macro;\n+    pub(crate) mod undeclared_label;\n+    pub(crate) mod unreachable_label;\n \n     // The handlers below are unusual, the implement the diagnostics as well.\n     pub(crate) mod field_shorthand;\n@@ -253,36 +254,38 @@ pub fn diagnostics(\n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n-            AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n+                Some(it) => it,\n+                None => continue,\n+            }\n             AnyDiagnostic::IncoherentImpl(d) => handlers::incoherent_impl::incoherent_impl(&ctx, &d),\n+            AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n             AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n             AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n             AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n             AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n             AnyDiagnostic::PrivateAssocItem(d) => handlers::private_assoc_item::private_assoc_item(&ctx, &d),\n             AnyDiagnostic::PrivateField(d) => handlers::private_field::private_field(&ctx, &d),\n             AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n             AnyDiagnostic::TypeMismatch(d) => handlers::type_mismatch::type_mismatch(&ctx, &d),\n+            AnyDiagnostic::UndeclaredLabel(d) => handlers::undeclared_label::undeclared_label(&ctx, &d),\n             AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n+            AnyDiagnostic::UnreachableLabel(d) => handlers::unreachable_label:: unreachable_label(&ctx, &d),\n             AnyDiagnostic::UnresolvedExternCrate(d) => handlers::unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n+            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n             AnyDiagnostic::UnresolvedImport(d) => handlers::unresolved_import::unresolved_import(&ctx, &d),\n             AnyDiagnostic::UnresolvedMacroCall(d) => handlers::unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n             AnyDiagnostic::UnresolvedModule(d) => handlers::unresolved_module::unresolved_module(&ctx, &d),\n             AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d, config.proc_macros_enabled, config.proc_attr_macros_enabled),\n-            AnyDiagnostic::InvalidDeriveTarget(d) => handlers::invalid_derive_target::invalid_derive_target(&ctx, &d),\n-            AnyDiagnostic::UnresolvedField(d) => handlers::unresolved_field::unresolved_field(&ctx, &d),\n-            AnyDiagnostic::UnresolvedMethodCall(d) => handlers::unresolved_method::unresolved_method(&ctx, &d),\n-            AnyDiagnostic::NeedMut(d) => handlers::mutability_errors::need_mut(&ctx, &d),\n             AnyDiagnostic::UnusedMut(d) => handlers::mutability_errors::unused_mut(&ctx, &d),\n-            AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n-                Some(it) => it,\n-                None => continue,\n-            }\n+\n         };\n         res.push(d)\n     }"}]}