{"sha": "1935bbd91321b4ebb61b21a300f43234a0be6433", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5MzViYmQ5MTMyMWI0ZWJiNjFiMjFhMzAwZjQzMjM0YTBiZTY0MzM=", "commit": {"author": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2015-01-31T18:49:12Z"}, "committer": {"name": "Edward Wang", "email": "edward.yu.wang@gmail.com", "date": "2015-01-31T20:06:06Z"}, "message": "Make use of a binary operator's RHS type for LHS inference\n\nFor \"symmetric\" binary operators, meaning the types of two side must be\nequal, if the type of LHS doesn't know yet but RHS does, use that as an\nhint to infer LHS' type.\n\nCloses #21634", "tree": {"sha": "cc5c68966939f30f9de76ae5a77d453fcb9318c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc5c68966939f30f9de76ae5a77d453fcb9318c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1935bbd91321b4ebb61b21a300f43234a0be6433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1935bbd91321b4ebb61b21a300f43234a0be6433", "html_url": "https://github.com/rust-lang/rust/commit/1935bbd91321b4ebb61b21a300f43234a0be6433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1935bbd91321b4ebb61b21a300f43234a0be6433/comments", "author": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwardw", "id": 454049, "node_id": "MDQ6VXNlcjQ1NDA0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/454049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwardw", "html_url": "https://github.com/edwardw", "followers_url": "https://api.github.com/users/edwardw/followers", "following_url": "https://api.github.com/users/edwardw/following{/other_user}", "gists_url": "https://api.github.com/users/edwardw/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwardw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwardw/subscriptions", "organizations_url": "https://api.github.com/users/edwardw/orgs", "repos_url": "https://api.github.com/users/edwardw/repos", "events_url": "https://api.github.com/users/edwardw/events{/privacy}", "received_events_url": "https://api.github.com/users/edwardw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "474b324eda10440d6568ef872a7307d38e7de95b", "url": "https://api.github.com/repos/rust-lang/rust/commits/474b324eda10440d6568ef872a7307d38e7de95b", "html_url": "https://github.com/rust-lang/rust/commit/474b324eda10440d6568ef872a7307d38e7de95b"}], "stats": {"total": 93, "additions": 77, "deletions": 16}, "files": [{"sha": "a41f27cfea88092921ddc44cef1a3352d32d09b7", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1935bbd91321b4ebb61b21a300f43234a0be6433/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1935bbd91321b4ebb61b21a300f43234a0be6433/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1935bbd91321b4ebb61b21a300f43234a0be6433", "patch": "@@ -2815,11 +2815,19 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             BinopAssignment => PreferMutLvalue,\n             SimpleBinop => NoPreference\n         };\n-        check_expr_with_lvalue_pref(fcx, &*lhs, lvalue_pref);\n+        check_expr_with_lvalue_pref(fcx, lhs, lvalue_pref);\n \n         // Callee does bot / err checking\n-        let lhs_t = structurally_resolved_type(fcx, lhs.span,\n-                                               fcx.expr_ty(&*lhs));\n+        let lhs_t =\n+            structurally_resolve_type_or_else(fcx, lhs.span, fcx.expr_ty(lhs), || {\n+                if ast_util::is_symmetric_binop(op.node) {\n+                    // Try RHS first\n+                    check_expr(fcx, &**rhs);\n+                    fcx.expr_ty(&**rhs)\n+                } else {\n+                    fcx.tcx().types.err\n+                }\n+            });\n \n         if ty::type_is_integral(lhs_t) && ast_util::is_shift_binop(op.node) {\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n@@ -5071,28 +5079,45 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-// Resolves `typ` by a single level if `typ` is a type variable.  If no\n-// resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                            sp: Span,\n-                                            ty: Ty<'tcx>)\n-                                            -> Ty<'tcx>\n+fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                  sp: Span,\n+                                                  ty: Ty<'tcx>,\n+                                                  f: F) -> Ty<'tcx>\n+    where F: Fn() -> Ty<'tcx>\n {\n     let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n-    // If not, error.\n     if ty::type_is_ty_var(ty) {\n-        fcx.type_error_message(sp, |_actual| {\n-            \"the type of this value must be known in this \\\n-             context\".to_string()\n-        }, ty, None);\n-        demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n-        ty = fcx.tcx().types.err;\n+        let alternative = f();\n+\n+        // If not, error.\n+        if ty::type_is_ty_var(alternative) || ty::type_is_error(alternative) {\n+            fcx.type_error_message(sp, |_actual| {\n+                \"the type of this value must be known in this context\".to_string()\n+            }, ty, None);\n+            demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n+            ty = fcx.tcx().types.err;\n+        } else {\n+            demand::suptype(fcx, sp, alternative, ty);\n+            ty = alternative;\n+        }\n     }\n \n     ty\n }\n \n+// Resolves `typ` by a single level if `typ` is a type variable.  If no\n+// resolution is possible, then an error is reported.\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                            sp: Span,\n+                                            ty: Ty<'tcx>)\n+                                            -> Ty<'tcx>\n+{\n+    structurally_resolve_type_or_else(fcx, sp, ty, || {\n+        fcx.tcx().types.err\n+    })\n+}\n+\n // Returns true if b contains a break that can exit from b\n pub fn may_break(cx: &ty::ctxt, id: ast::NodeId, b: &ast::Block) -> bool {\n     // First: is there an unlabeled break immediately"}, {"sha": "5049b87d694524f5a9389ddfed92a993f5050d9d", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1935bbd91321b4ebb61b21a300f43234a0be6433/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1935bbd91321b4ebb61b21a300f43234a0be6433/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1935bbd91321b4ebb61b21a300f43234a0be6433", "patch": "@@ -102,6 +102,20 @@ pub fn is_by_value_binop(b: BinOp_) -> bool {\n     }\n }\n \n+/// Returns `true` if the binary operator is symmetric in the sense that LHS\n+/// and RHS must have the same type. So the type of LHS can serve as an hint\n+/// for the type of RHS and vice versa.\n+pub fn is_symmetric_binop(b: BinOp_) -> bool {\n+    match b {\n+        BiAdd | BiSub | BiMul | BiDiv | BiRem |\n+        BiBitXor | BiBitAnd | BiBitOr |\n+        BiEq | BiLt | BiLe | BiNe | BiGt | BiGe => {\n+            true\n+        }\n+        _ => false\n+    }\n+}\n+\n /// Returns `true` if the unary operator takes its argument by value\n pub fn is_by_value_unop(u: UnOp) -> bool {\n     match u {"}, {"sha": "e5a2790917ff0a638424375e9721d5ecefd2f052", "filename": "src/test/run-pass/issue-21634.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1935bbd91321b4ebb61b21a300f43234a0be6433/src%2Ftest%2Frun-pass%2Fissue-21634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1935bbd91321b4ebb61b21a300f43234a0be6433/src%2Ftest%2Frun-pass%2Fissue-21634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21634.rs?ref=1935bbd91321b4ebb61b21a300f43234a0be6433", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+fn main() {\n+    if let Ok(x) = \"3.1415\".parse() {\n+        assert_eq!(false, x <= 0.0);\n+    }\n+    if let Ok(x) = \"3.1415\".parse() {\n+        assert_eq!(3.1415, x + 0.0);\n+    }\n+    if let Ok(mut x) = \"3.1415\".parse() {\n+        assert_eq!(8.1415, { x += 5.0; x });\n+    }\n+}"}]}